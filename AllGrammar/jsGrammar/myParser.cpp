
// Generated from myParser.g4 by ANTLR 4.13.0


#include "myParserListener.h"

#include "myParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct MyParserStaticData final {
  MyParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  MyParserStaticData(const MyParserStaticData&) = delete;
  MyParserStaticData(MyParserStaticData&&) = delete;
  MyParserStaticData& operator=(const MyParserStaticData&) = delete;
  MyParserStaticData& operator=(MyParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag myparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
MyParserStaticData *myparserParserStaticData = nullptr;

void myparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (myparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(myparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<MyParserStaticData>(
    std::vector<std::string>{
      "program", "sourceElement", "statement", "block", "statementList", 
      "importStatement", "importFromBlock", "moduleItems", "importDefault", 
      "importNamespace", "importFrom", "aliasName", "exportStatement", "exportFromBlock", 
      "declaration", "variableStatement", "variableDeclarationList", "variableDeclaration", 
      "emptyStatement_", "expressionStatement", "ifStatement", "iterationStatement", 
      "varModifier", "continueStatement", "breakStatement", "returnStatement", 
      "yieldStatement", "withStatement", "switchStatement", "caseBlock", 
      "caseClauses", "caseClause", "defaultClause", "labelledStatement", 
      "throwStatement", "tryStatement", "catchProduction", "finallyProduction", 
      "debuggerStatement", "functionDeclaration", "classDeclaration", "classTail", 
      "classElement", "methodDefinition", "formalParameterList", "formalParameterArg", 
      "lastFormalParameterArg", "functionBody", "sourceElements", "arrayLiteral", 
      "elementList", "arrayElement", "propertyAssignment", "propertyName", 
      "arguments", "argument", "expressionSequence", "singleExpression", 
      "assignable", "objectLiteral", "anonymousFunction", "arrowFunctionParameters", 
      "arrowFunctionBody", "assignmentOperator", "literal", "templateStringLiteral", 
      "templateStringAtom", "numericLiteral", "bigintLiteral", "getter", 
      "setter", "identifierName", "identifier", "reservedWord", "keyword", 
      "let_", "eos"
    },
    std::vector<std::string>{
      "", "", "", "", "", "'['", "']'", "'('", "')'", "'{'", "", "'}'", 
      "';'", "','", "'='", "'\\u003F'", "'\\u003F.'", "':'", "'...'", "'.'", 
      "'++'", "'--'", "'+'", "'-'", "'~'", "'!'", "'*'", "'/'", "'%'", "'**'", 
      "'\\u003F\\u003F'", "'#'", "'>>'", "'<<'", "'>>>'", "'<'", "'>'", 
      "'<='", "'>='", "'=='", "'!='", "'==='", "'!=='", "'&'", "'^'", "'|'", 
      "'&&'", "'||'", "'*='", "'/='", "'%='", "'+='", "'-='", "'<<='", "'>>='", 
      "'>>>='", "'&='", "'^='", "'|='", "'**='", "'=>'", "'null'", "", "", 
      "", "", "", "", "", "", "", "", "'break'", "'do'", "'instanceof'", 
      "'typeof'", "'case'", "'else'", "'new'", "'var'", "'catch'", "'finally'", 
      "'return'", "'void'", "'continue'", "'for'", "'switch'", "'while'", 
      "'debugger'", "'function'", "'this'", "'with'", "'default'", "'if'", 
      "'throw'", "'delete'", "'in'", "'try'", "'as'", "'from'", "'class'", 
      "'enum'", "'extends'", "'super'", "'const'", "'export'", "'import'", 
      "'async'", "'await'", "'yield'", "'implements'", "", "", "'private'", 
      "'public'", "'interface'", "'package'", "'protected'", "'static'", 
      "", "", "", "", "", "", "", "", "'${'"
    },
    std::vector<std::string>{
      "", "HashBangLine", "MultiLineComment", "SingleLineComment", "RegularExpressionLiteral", 
      "OpenBracket", "CloseBracket", "OpenParen", "CloseParen", "OpenBrace", 
      "TemplateCloseBrace", "CloseBrace", "SemiColon", "Comma", "Assign", 
      "QuestionMark", "QuestionMarkDot", "Colon", "Ellipsis", "Dot", "PlusPlus", 
      "MinusMinus", "Plus", "Minus", "BitNot", "Not", "Multiply", "Divide", 
      "Modulus", "Power", "NullCoalesce", "Hashtag", "RightShiftArithmetic", 
      "LeftShiftArithmetic", "RightShiftLogical", "LessThan", "MoreThan", 
      "LessThanEquals", "GreaterThanEquals", "Equals_", "NotEquals", "IdentityEquals", 
      "IdentityNotEquals", "BitAnd", "BitXOr", "BitOr", "And", "Or", "MultiplyAssign", 
      "DivideAssign", "ModulusAssign", "PlusAssign", "MinusAssign", "LeftShiftArithmeticAssign", 
      "RightShiftArithmeticAssign", "RightShiftLogicalAssign", "BitAndAssign", 
      "BitXorAssign", "BitOrAssign", "PowerAssign", "ARROW", "NullLiteral", 
      "BooleanLiteral", "DecimalLiteral", "HexIntegerLiteral", "OctalIntegerLiteral", 
      "OctalIntegerLiteral2", "BinaryIntegerLiteral", "BigHexIntegerLiteral", 
      "BigOctalIntegerLiteral", "BigBinaryIntegerLiteral", "BigDecimalIntegerLiteral", 
      "Break", "Do", "Instanceof", "Typeof", "Case", "Else", "New", "Var", 
      "Catch", "Finally", "Return", "Void", "Continue", "For", "Switch", 
      "While", "Debugger", "Function_", "This", "With", "Default", "If", 
      "Throw", "Delete", "In", "Try", "As", "From", "Class", "Enum", "Extends", 
      "Super", "Const", "Export", "Import", "Async", "Await", "Yield", "Implements", 
      "StrictLet", "NonStrictLet", "Private", "Public", "Interface", "Package", 
      "Protected", "Static", "Identifier", "StringLiteral", "BackTick", 
      "WhiteSpaces", "LineTerminator", "HtmlComment", "CDataComment", "UnexpectedCharacter", 
      "TemplateStringStartExpression", "TemplateStringAtom"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,128,1035,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,1,0,
  	3,0,156,8,0,1,0,3,0,159,8,0,1,0,1,0,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,
  	2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3,2,185,8,2,1,3,
  	1,3,3,3,189,8,3,1,3,1,3,1,4,4,4,194,8,4,11,4,12,4,195,1,5,1,5,1,5,1,6,
  	3,6,202,8,6,1,6,1,6,3,6,206,8,6,1,6,1,6,1,6,1,6,1,6,3,6,213,8,6,1,7,1,
  	7,1,7,1,7,5,7,219,8,7,10,7,12,7,222,9,7,1,7,1,7,3,7,226,8,7,3,7,228,8,
  	7,1,7,1,7,1,8,1,8,1,8,1,9,1,9,3,9,237,8,9,1,9,1,9,3,9,241,8,9,1,10,1,
  	10,1,10,1,11,1,11,1,11,3,11,249,8,11,1,12,1,12,1,12,3,12,254,8,12,1,12,
  	1,12,1,12,1,12,1,12,1,12,1,12,3,12,263,8,12,1,13,1,13,1,13,1,13,1,13,
  	1,13,3,13,271,8,13,1,13,1,13,3,13,275,8,13,1,14,1,14,1,14,3,14,280,8,
  	14,1,15,1,15,1,15,1,16,1,16,1,16,1,16,5,16,289,8,16,10,16,12,16,292,9,
  	16,1,17,1,17,1,17,3,17,297,8,17,1,18,1,18,1,19,1,19,1,19,1,19,1,20,1,
  	20,1,20,1,20,1,20,1,20,1,20,3,20,312,8,20,1,21,1,21,1,21,1,21,1,21,1,
  	21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,3,21,332,
  	8,21,1,21,1,21,3,21,336,8,21,1,21,1,21,3,21,340,8,21,1,21,1,21,1,21,1,
  	21,1,21,1,21,3,21,348,8,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,3,21,357,
  	8,21,1,21,1,21,1,21,3,21,362,8,21,1,21,1,21,1,21,1,21,1,21,1,21,3,21,
  	370,8,21,1,22,1,22,1,22,3,22,375,8,22,1,23,1,23,1,23,3,23,380,8,23,1,
  	23,1,23,1,24,1,24,1,24,3,24,387,8,24,1,24,1,24,1,25,1,25,1,25,3,25,394,
  	8,25,1,25,1,25,1,26,1,26,1,26,3,26,401,8,26,1,26,1,26,1,27,1,27,1,27,
  	1,27,1,27,1,27,1,28,1,28,1,28,1,28,1,28,1,28,1,29,1,29,3,29,419,8,29,
  	1,29,1,29,3,29,423,8,29,3,29,425,8,29,1,29,1,29,1,30,4,30,430,8,30,11,
  	30,12,30,431,1,31,1,31,1,31,1,31,3,31,438,8,31,1,32,1,32,1,32,3,32,443,
  	8,32,1,33,1,33,1,33,1,33,1,34,1,34,1,34,1,34,1,34,1,35,1,35,1,35,1,35,
  	3,35,458,8,35,1,35,3,35,461,8,35,1,36,1,36,1,36,3,36,466,8,36,1,36,3,
  	36,469,8,36,1,36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,1,39,3,39,480,8,39,
  	1,39,1,39,3,39,484,8,39,1,39,1,39,1,39,3,39,489,8,39,1,39,1,39,1,39,1,
  	40,1,40,1,40,1,40,1,41,1,41,3,41,500,8,41,1,41,1,41,5,41,504,8,41,10,
  	41,12,41,507,9,41,1,41,1,41,1,42,1,42,1,42,1,42,5,42,515,8,42,10,42,12,
  	42,518,9,42,1,42,1,42,1,42,1,42,1,42,1,42,3,42,526,8,42,1,42,1,42,3,42,
  	530,8,42,1,42,1,42,1,42,1,42,3,42,536,8,42,1,43,3,43,539,8,43,1,43,3,
  	43,542,8,43,1,43,1,43,1,43,3,43,547,8,43,1,43,1,43,1,43,1,43,3,43,553,
  	8,43,1,43,3,43,556,8,43,1,43,1,43,1,43,1,43,1,43,1,43,3,43,564,8,43,1,
  	43,3,43,567,8,43,1,43,1,43,1,43,3,43,572,8,43,1,43,1,43,1,43,3,43,577,
  	8,43,1,44,1,44,1,44,5,44,582,8,44,10,44,12,44,585,9,44,1,44,1,44,3,44,
  	589,8,44,1,44,3,44,592,8,44,1,45,1,45,1,45,3,45,597,8,45,1,46,1,46,1,
  	46,1,47,1,47,3,47,604,8,47,1,47,1,47,1,48,4,48,609,8,48,11,48,12,48,610,
  	1,49,1,49,1,49,1,49,1,50,5,50,618,8,50,10,50,12,50,621,9,50,1,50,3,50,
  	624,8,50,1,50,4,50,627,8,50,11,50,12,50,628,1,50,5,50,632,8,50,10,50,
  	12,50,635,9,50,1,50,5,50,638,8,50,10,50,12,50,641,9,50,1,51,3,51,644,
  	8,51,1,51,1,51,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,
  	3,52,659,8,52,1,52,3,52,662,8,52,1,52,1,52,1,52,3,52,667,8,52,1,52,1,
  	52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,3,
  	52,684,8,52,1,52,3,52,687,8,52,1,53,1,53,1,53,1,53,1,53,1,53,1,53,3,53,
  	696,8,53,1,54,1,54,1,54,1,54,5,54,702,8,54,10,54,12,54,705,9,54,1,54,
  	3,54,708,8,54,3,54,710,8,54,1,54,1,54,1,55,3,55,715,8,55,1,55,1,55,3,
  	55,719,8,55,1,56,1,56,1,56,5,56,724,8,56,10,56,12,56,727,9,56,1,57,1,
  	57,1,57,1,57,3,57,733,8,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,
  	57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,
  	57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,
  	57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,3,57,781,8,57,1,57,1,
  	57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,
  	57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,
  	57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,
  	57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,
  	57,1,57,1,57,3,57,843,8,57,1,57,1,57,1,57,1,57,1,57,1,57,3,57,851,8,57,
  	1,57,1,57,3,57,855,8,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,
  	1,57,1,57,5,57,868,8,57,10,57,12,57,871,9,57,1,58,1,58,1,58,3,58,876,
  	8,58,1,59,1,59,1,59,1,59,5,59,882,8,59,10,59,12,59,885,9,59,1,59,3,59,
  	888,8,59,3,59,890,8,59,1,59,1,59,1,60,1,60,3,60,896,8,60,1,60,1,60,3,
  	60,900,8,60,1,60,1,60,3,60,904,8,60,1,60,1,60,1,60,3,60,909,8,60,1,60,
  	1,60,1,60,1,60,3,60,915,8,60,1,61,1,61,1,61,3,61,920,8,61,1,61,3,61,923,
  	8,61,1,62,1,62,3,62,927,8,62,1,63,1,63,1,64,1,64,1,64,1,64,1,64,1,64,
  	1,64,3,64,938,8,64,1,65,1,65,5,65,942,8,65,10,65,12,65,945,9,65,1,65,
  	1,65,1,66,1,66,1,66,1,66,1,66,3,66,954,8,66,1,67,1,67,1,68,1,68,1,69,
  	1,69,1,69,1,69,1,70,1,70,1,70,1,70,1,71,1,71,3,71,970,8,71,1,72,1,72,
  	1,73,1,73,1,73,3,73,977,8,73,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,
  	1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,
  	1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,
  	1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,3,74,1025,8,74,1,75,
  	1,75,1,76,1,76,1,76,1,76,3,76,1033,8,76,1,76,0,1,114,77,0,2,4,6,8,10,
  	12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,
  	58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,
  	104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,
  	140,142,144,146,148,150,152,0,10,1,0,26,28,1,0,22,23,1,0,32,34,1,0,35,
  	38,1,0,39,42,1,0,48,59,1,0,63,67,1,0,68,71,3,0,107,107,112,112,119,119,
  	1,0,111,112,1201,0,155,1,0,0,0,2,162,1,0,0,0,4,184,1,0,0,0,6,186,1,0,
  	0,0,8,193,1,0,0,0,10,197,1,0,0,0,12,212,1,0,0,0,14,214,1,0,0,0,16,231,
  	1,0,0,0,18,236,1,0,0,0,20,242,1,0,0,0,22,245,1,0,0,0,24,262,1,0,0,0,26,
  	274,1,0,0,0,28,279,1,0,0,0,30,281,1,0,0,0,32,284,1,0,0,0,34,293,1,0,0,
  	0,36,298,1,0,0,0,38,300,1,0,0,0,40,304,1,0,0,0,42,369,1,0,0,0,44,374,
  	1,0,0,0,46,376,1,0,0,0,48,383,1,0,0,0,50,390,1,0,0,0,52,397,1,0,0,0,54,
  	404,1,0,0,0,56,410,1,0,0,0,58,416,1,0,0,0,60,429,1,0,0,0,62,433,1,0,0,
  	0,64,439,1,0,0,0,66,444,1,0,0,0,68,448,1,0,0,0,70,453,1,0,0,0,72,462,
  	1,0,0,0,74,472,1,0,0,0,76,475,1,0,0,0,78,479,1,0,0,0,80,493,1,0,0,0,82,
  	499,1,0,0,0,84,535,1,0,0,0,86,576,1,0,0,0,88,591,1,0,0,0,90,593,1,0,0,
  	0,92,598,1,0,0,0,94,601,1,0,0,0,96,608,1,0,0,0,98,612,1,0,0,0,100,619,
  	1,0,0,0,102,643,1,0,0,0,104,686,1,0,0,0,106,695,1,0,0,0,108,697,1,0,0,
  	0,110,714,1,0,0,0,112,720,1,0,0,0,114,780,1,0,0,0,116,875,1,0,0,0,118,
  	877,1,0,0,0,120,914,1,0,0,0,122,922,1,0,0,0,124,926,1,0,0,0,126,928,1,
  	0,0,0,128,937,1,0,0,0,130,939,1,0,0,0,132,953,1,0,0,0,134,955,1,0,0,0,
  	136,957,1,0,0,0,138,959,1,0,0,0,140,963,1,0,0,0,142,969,1,0,0,0,144,971,
  	1,0,0,0,146,976,1,0,0,0,148,1024,1,0,0,0,150,1026,1,0,0,0,152,1032,1,
  	0,0,0,154,156,5,1,0,0,155,154,1,0,0,0,155,156,1,0,0,0,156,158,1,0,0,0,
  	157,159,3,96,48,0,158,157,1,0,0,0,158,159,1,0,0,0,159,160,1,0,0,0,160,
  	161,5,0,0,1,161,1,1,0,0,0,162,163,3,4,2,0,163,3,1,0,0,0,164,185,3,6,3,
  	0,165,185,3,30,15,0,166,185,3,10,5,0,167,185,3,24,12,0,168,185,3,36,18,
  	0,169,185,3,80,40,0,170,185,3,38,19,0,171,185,3,40,20,0,172,185,3,42,
  	21,0,173,185,3,46,23,0,174,185,3,48,24,0,175,185,3,50,25,0,176,185,3,
  	52,26,0,177,185,3,54,27,0,178,185,3,66,33,0,179,185,3,56,28,0,180,185,
  	3,68,34,0,181,185,3,70,35,0,182,185,3,76,38,0,183,185,3,78,39,0,184,164,
  	1,0,0,0,184,165,1,0,0,0,184,166,1,0,0,0,184,167,1,0,0,0,184,168,1,0,0,
  	0,184,169,1,0,0,0,184,170,1,0,0,0,184,171,1,0,0,0,184,172,1,0,0,0,184,
  	173,1,0,0,0,184,174,1,0,0,0,184,175,1,0,0,0,184,176,1,0,0,0,184,177,1,
  	0,0,0,184,178,1,0,0,0,184,179,1,0,0,0,184,180,1,0,0,0,184,181,1,0,0,0,
  	184,182,1,0,0,0,184,183,1,0,0,0,185,5,1,0,0,0,186,188,5,9,0,0,187,189,
  	3,8,4,0,188,187,1,0,0,0,188,189,1,0,0,0,189,190,1,0,0,0,190,191,5,11,
  	0,0,191,7,1,0,0,0,192,194,3,4,2,0,193,192,1,0,0,0,194,195,1,0,0,0,195,
  	193,1,0,0,0,195,196,1,0,0,0,196,9,1,0,0,0,197,198,5,106,0,0,198,199,3,
  	12,6,0,199,11,1,0,0,0,200,202,3,16,8,0,201,200,1,0,0,0,201,202,1,0,0,
  	0,202,205,1,0,0,0,203,206,3,18,9,0,204,206,3,14,7,0,205,203,1,0,0,0,205,
  	204,1,0,0,0,206,207,1,0,0,0,207,208,3,20,10,0,208,209,3,152,76,0,209,
  	213,1,0,0,0,210,211,5,120,0,0,211,213,3,152,76,0,212,201,1,0,0,0,212,
  	210,1,0,0,0,213,13,1,0,0,0,214,220,5,9,0,0,215,216,3,22,11,0,216,217,
  	5,13,0,0,217,219,1,0,0,0,218,215,1,0,0,0,219,222,1,0,0,0,220,218,1,0,
  	0,0,220,221,1,0,0,0,221,227,1,0,0,0,222,220,1,0,0,0,223,225,3,22,11,0,
  	224,226,5,13,0,0,225,224,1,0,0,0,225,226,1,0,0,0,226,228,1,0,0,0,227,
  	223,1,0,0,0,227,228,1,0,0,0,228,229,1,0,0,0,229,230,5,11,0,0,230,15,1,
  	0,0,0,231,232,3,22,11,0,232,233,5,13,0,0,233,17,1,0,0,0,234,237,5,26,
  	0,0,235,237,3,142,71,0,236,234,1,0,0,0,236,235,1,0,0,0,237,240,1,0,0,
  	0,238,239,5,98,0,0,239,241,3,142,71,0,240,238,1,0,0,0,240,241,1,0,0,0,
  	241,19,1,0,0,0,242,243,5,99,0,0,243,244,5,120,0,0,244,21,1,0,0,0,245,
  	248,3,142,71,0,246,247,5,98,0,0,247,249,3,142,71,0,248,246,1,0,0,0,248,
  	249,1,0,0,0,249,23,1,0,0,0,250,253,5,105,0,0,251,254,3,26,13,0,252,254,
  	3,28,14,0,253,251,1,0,0,0,253,252,1,0,0,0,254,255,1,0,0,0,255,256,3,152,
  	76,0,256,263,1,0,0,0,257,258,5,105,0,0,258,259,5,92,0,0,259,260,3,114,
  	57,0,260,261,3,152,76,0,261,263,1,0,0,0,262,250,1,0,0,0,262,257,1,0,0,
  	0,263,25,1,0,0,0,264,265,3,18,9,0,265,266,3,20,10,0,266,267,3,152,76,
  	0,267,275,1,0,0,0,268,270,3,14,7,0,269,271,3,20,10,0,270,269,1,0,0,0,
  	270,271,1,0,0,0,271,272,1,0,0,0,272,273,3,152,76,0,273,275,1,0,0,0,274,
  	264,1,0,0,0,274,268,1,0,0,0,275,27,1,0,0,0,276,280,3,30,15,0,277,280,
  	3,80,40,0,278,280,3,78,39,0,279,276,1,0,0,0,279,277,1,0,0,0,279,278,1,
  	0,0,0,280,29,1,0,0,0,281,282,3,32,16,0,282,283,3,152,76,0,283,31,1,0,
  	0,0,284,285,3,44,22,0,285,290,3,34,17,0,286,287,5,13,0,0,287,289,3,34,
  	17,0,288,286,1,0,0,0,289,292,1,0,0,0,290,288,1,0,0,0,290,291,1,0,0,0,
  	291,33,1,0,0,0,292,290,1,0,0,0,293,296,3,116,58,0,294,295,5,14,0,0,295,
  	297,3,114,57,0,296,294,1,0,0,0,296,297,1,0,0,0,297,35,1,0,0,0,298,299,
  	5,12,0,0,299,37,1,0,0,0,300,301,4,19,0,0,301,302,3,112,56,0,302,303,3,
  	152,76,0,303,39,1,0,0,0,304,305,5,93,0,0,305,306,5,7,0,0,306,307,3,112,
  	56,0,307,308,5,8,0,0,308,311,3,4,2,0,309,310,5,77,0,0,310,312,3,4,2,0,
  	311,309,1,0,0,0,311,312,1,0,0,0,312,41,1,0,0,0,313,314,5,73,0,0,314,315,
  	3,4,2,0,315,316,5,87,0,0,316,317,5,7,0,0,317,318,3,112,56,0,318,319,5,
  	8,0,0,319,320,3,152,76,0,320,370,1,0,0,0,321,322,5,87,0,0,322,323,5,7,
  	0,0,323,324,3,112,56,0,324,325,5,8,0,0,325,326,3,4,2,0,326,370,1,0,0,
  	0,327,328,5,85,0,0,328,331,5,7,0,0,329,332,3,112,56,0,330,332,3,32,16,
  	0,331,329,1,0,0,0,331,330,1,0,0,0,331,332,1,0,0,0,332,333,1,0,0,0,333,
  	335,5,12,0,0,334,336,3,112,56,0,335,334,1,0,0,0,335,336,1,0,0,0,336,337,
  	1,0,0,0,337,339,5,12,0,0,338,340,3,112,56,0,339,338,1,0,0,0,339,340,1,
  	0,0,0,340,341,1,0,0,0,341,342,5,8,0,0,342,370,3,4,2,0,343,344,5,85,0,
  	0,344,347,5,7,0,0,345,348,3,114,57,0,346,348,3,32,16,0,347,345,1,0,0,
  	0,347,346,1,0,0,0,348,349,1,0,0,0,349,350,5,96,0,0,350,351,3,112,56,0,
  	351,352,5,8,0,0,352,353,3,4,2,0,353,370,1,0,0,0,354,356,5,85,0,0,355,
  	357,5,108,0,0,356,355,1,0,0,0,356,357,1,0,0,0,357,358,1,0,0,0,358,361,
  	5,7,0,0,359,362,3,114,57,0,360,362,3,32,16,0,361,359,1,0,0,0,361,360,
  	1,0,0,0,362,363,1,0,0,0,363,364,3,144,72,0,364,365,4,21,1,0,365,366,3,
  	112,56,0,366,367,5,8,0,0,367,368,3,4,2,0,368,370,1,0,0,0,369,313,1,0,
  	0,0,369,321,1,0,0,0,369,327,1,0,0,0,369,343,1,0,0,0,369,354,1,0,0,0,370,
  	43,1,0,0,0,371,375,5,79,0,0,372,375,3,150,75,0,373,375,5,104,0,0,374,
  	371,1,0,0,0,374,372,1,0,0,0,374,373,1,0,0,0,375,45,1,0,0,0,376,379,5,
  	84,0,0,377,378,4,23,2,0,378,380,3,144,72,0,379,377,1,0,0,0,379,380,1,
  	0,0,0,380,381,1,0,0,0,381,382,3,152,76,0,382,47,1,0,0,0,383,386,5,72,
  	0,0,384,385,4,24,3,0,385,387,3,144,72,0,386,384,1,0,0,0,386,387,1,0,0,
  	0,387,388,1,0,0,0,388,389,3,152,76,0,389,49,1,0,0,0,390,393,5,82,0,0,
  	391,392,4,25,4,0,392,394,3,112,56,0,393,391,1,0,0,0,393,394,1,0,0,0,394,
  	395,1,0,0,0,395,396,3,152,76,0,396,51,1,0,0,0,397,400,5,109,0,0,398,399,
  	4,26,5,0,399,401,3,112,56,0,400,398,1,0,0,0,400,401,1,0,0,0,401,402,1,
  	0,0,0,402,403,3,152,76,0,403,53,1,0,0,0,404,405,5,91,0,0,405,406,5,7,
  	0,0,406,407,3,112,56,0,407,408,5,8,0,0,408,409,3,4,2,0,409,55,1,0,0,0,
  	410,411,5,86,0,0,411,412,5,7,0,0,412,413,3,112,56,0,413,414,5,8,0,0,414,
  	415,3,58,29,0,415,57,1,0,0,0,416,418,5,9,0,0,417,419,3,60,30,0,418,417,
  	1,0,0,0,418,419,1,0,0,0,419,424,1,0,0,0,420,422,3,64,32,0,421,423,3,60,
  	30,0,422,421,1,0,0,0,422,423,1,0,0,0,423,425,1,0,0,0,424,420,1,0,0,0,
  	424,425,1,0,0,0,425,426,1,0,0,0,426,427,5,11,0,0,427,59,1,0,0,0,428,430,
  	3,62,31,0,429,428,1,0,0,0,430,431,1,0,0,0,431,429,1,0,0,0,431,432,1,0,
  	0,0,432,61,1,0,0,0,433,434,5,76,0,0,434,435,3,112,56,0,435,437,5,17,0,
  	0,436,438,3,8,4,0,437,436,1,0,0,0,437,438,1,0,0,0,438,63,1,0,0,0,439,
  	440,5,92,0,0,440,442,5,17,0,0,441,443,3,8,4,0,442,441,1,0,0,0,442,443,
  	1,0,0,0,443,65,1,0,0,0,444,445,3,144,72,0,445,446,5,17,0,0,446,447,3,
  	4,2,0,447,67,1,0,0,0,448,449,5,94,0,0,449,450,4,34,6,0,450,451,3,112,
  	56,0,451,452,3,152,76,0,452,69,1,0,0,0,453,454,5,97,0,0,454,460,3,6,3,
  	0,455,457,3,72,36,0,456,458,3,74,37,0,457,456,1,0,0,0,457,458,1,0,0,0,
  	458,461,1,0,0,0,459,461,3,74,37,0,460,455,1,0,0,0,460,459,1,0,0,0,461,
  	71,1,0,0,0,462,468,5,80,0,0,463,465,5,7,0,0,464,466,3,116,58,0,465,464,
  	1,0,0,0,465,466,1,0,0,0,466,467,1,0,0,0,467,469,5,8,0,0,468,463,1,0,0,
  	0,468,469,1,0,0,0,469,470,1,0,0,0,470,471,3,6,3,0,471,73,1,0,0,0,472,
  	473,5,81,0,0,473,474,3,6,3,0,474,75,1,0,0,0,475,476,5,88,0,0,476,477,
  	3,152,76,0,477,77,1,0,0,0,478,480,5,107,0,0,479,478,1,0,0,0,479,480,1,
  	0,0,0,480,481,1,0,0,0,481,483,5,89,0,0,482,484,5,26,0,0,483,482,1,0,0,
  	0,483,484,1,0,0,0,484,485,1,0,0,0,485,486,3,144,72,0,486,488,5,7,0,0,
  	487,489,3,88,44,0,488,487,1,0,0,0,488,489,1,0,0,0,489,490,1,0,0,0,490,
  	491,5,8,0,0,491,492,3,94,47,0,492,79,1,0,0,0,493,494,5,100,0,0,494,495,
  	3,144,72,0,495,496,3,82,41,0,496,81,1,0,0,0,497,498,5,102,0,0,498,500,
  	3,114,57,0,499,497,1,0,0,0,499,500,1,0,0,0,500,501,1,0,0,0,501,505,5,
  	9,0,0,502,504,3,84,42,0,503,502,1,0,0,0,504,507,1,0,0,0,505,503,1,0,0,
  	0,505,506,1,0,0,0,506,508,1,0,0,0,507,505,1,0,0,0,508,509,5,11,0,0,509,
  	83,1,0,0,0,510,515,5,118,0,0,511,512,4,42,7,0,512,515,3,144,72,0,513,
  	515,5,107,0,0,514,510,1,0,0,0,514,511,1,0,0,0,514,513,1,0,0,0,515,518,
  	1,0,0,0,516,514,1,0,0,0,516,517,1,0,0,0,517,525,1,0,0,0,518,516,1,0,0,
  	0,519,526,3,86,43,0,520,521,3,116,58,0,521,522,5,14,0,0,522,523,3,118,
  	59,0,523,524,5,12,0,0,524,526,1,0,0,0,525,519,1,0,0,0,525,520,1,0,0,0,
  	526,536,1,0,0,0,527,536,3,36,18,0,528,530,5,31,0,0,529,528,1,0,0,0,529,
  	530,1,0,0,0,530,531,1,0,0,0,531,532,3,106,53,0,532,533,5,14,0,0,533,534,
  	3,114,57,0,534,536,1,0,0,0,535,516,1,0,0,0,535,527,1,0,0,0,535,529,1,
  	0,0,0,536,85,1,0,0,0,537,539,5,26,0,0,538,537,1,0,0,0,538,539,1,0,0,0,
  	539,541,1,0,0,0,540,542,5,31,0,0,541,540,1,0,0,0,541,542,1,0,0,0,542,
  	543,1,0,0,0,543,544,3,106,53,0,544,546,5,7,0,0,545,547,3,88,44,0,546,
  	545,1,0,0,0,546,547,1,0,0,0,547,548,1,0,0,0,548,549,5,8,0,0,549,550,3,
  	94,47,0,550,577,1,0,0,0,551,553,5,26,0,0,552,551,1,0,0,0,552,553,1,0,
  	0,0,553,555,1,0,0,0,554,556,5,31,0,0,555,554,1,0,0,0,555,556,1,0,0,0,
  	556,557,1,0,0,0,557,558,3,138,69,0,558,559,5,7,0,0,559,560,5,8,0,0,560,
  	561,3,94,47,0,561,577,1,0,0,0,562,564,5,26,0,0,563,562,1,0,0,0,563,564,
  	1,0,0,0,564,566,1,0,0,0,565,567,5,31,0,0,566,565,1,0,0,0,566,567,1,0,
  	0,0,567,568,1,0,0,0,568,569,3,140,70,0,569,571,5,7,0,0,570,572,3,88,44,
  	0,571,570,1,0,0,0,571,572,1,0,0,0,572,573,1,0,0,0,573,574,5,8,0,0,574,
  	575,3,94,47,0,575,577,1,0,0,0,576,538,1,0,0,0,576,552,1,0,0,0,576,563,
  	1,0,0,0,577,87,1,0,0,0,578,583,3,90,45,0,579,580,5,13,0,0,580,582,3,90,
  	45,0,581,579,1,0,0,0,582,585,1,0,0,0,583,581,1,0,0,0,583,584,1,0,0,0,
  	584,588,1,0,0,0,585,583,1,0,0,0,586,587,5,13,0,0,587,589,3,92,46,0,588,
  	586,1,0,0,0,588,589,1,0,0,0,589,592,1,0,0,0,590,592,3,92,46,0,591,578,
  	1,0,0,0,591,590,1,0,0,0,592,89,1,0,0,0,593,596,3,116,58,0,594,595,5,14,
  	0,0,595,597,3,114,57,0,596,594,1,0,0,0,596,597,1,0,0,0,597,91,1,0,0,0,
  	598,599,5,18,0,0,599,600,3,114,57,0,600,93,1,0,0,0,601,603,5,9,0,0,602,
  	604,3,96,48,0,603,602,1,0,0,0,603,604,1,0,0,0,604,605,1,0,0,0,605,606,
  	5,11,0,0,606,95,1,0,0,0,607,609,3,2,1,0,608,607,1,0,0,0,609,610,1,0,0,
  	0,610,608,1,0,0,0,610,611,1,0,0,0,611,97,1,0,0,0,612,613,5,5,0,0,613,
  	614,3,100,50,0,614,615,5,6,0,0,615,99,1,0,0,0,616,618,5,13,0,0,617,616,
  	1,0,0,0,618,621,1,0,0,0,619,617,1,0,0,0,619,620,1,0,0,0,620,623,1,0,0,
  	0,621,619,1,0,0,0,622,624,3,102,51,0,623,622,1,0,0,0,623,624,1,0,0,0,
  	624,633,1,0,0,0,625,627,5,13,0,0,626,625,1,0,0,0,627,628,1,0,0,0,628,
  	626,1,0,0,0,628,629,1,0,0,0,629,630,1,0,0,0,630,632,3,102,51,0,631,626,
  	1,0,0,0,632,635,1,0,0,0,633,631,1,0,0,0,633,634,1,0,0,0,634,639,1,0,0,
  	0,635,633,1,0,0,0,636,638,5,13,0,0,637,636,1,0,0,0,638,641,1,0,0,0,639,
  	637,1,0,0,0,639,640,1,0,0,0,640,101,1,0,0,0,641,639,1,0,0,0,642,644,5,
  	18,0,0,643,642,1,0,0,0,643,644,1,0,0,0,644,645,1,0,0,0,645,646,3,114,
  	57,0,646,103,1,0,0,0,647,648,3,106,53,0,648,649,5,17,0,0,649,650,3,114,
  	57,0,650,687,1,0,0,0,651,652,5,5,0,0,652,653,3,114,57,0,653,654,5,6,0,
  	0,654,655,5,17,0,0,655,656,3,114,57,0,656,687,1,0,0,0,657,659,5,107,0,
  	0,658,657,1,0,0,0,658,659,1,0,0,0,659,661,1,0,0,0,660,662,5,26,0,0,661,
  	660,1,0,0,0,661,662,1,0,0,0,662,663,1,0,0,0,663,664,3,106,53,0,664,666,
  	5,7,0,0,665,667,3,88,44,0,666,665,1,0,0,0,666,667,1,0,0,0,667,668,1,0,
  	0,0,668,669,5,8,0,0,669,670,3,94,47,0,670,687,1,0,0,0,671,672,3,138,69,
  	0,672,673,5,7,0,0,673,674,5,8,0,0,674,675,3,94,47,0,675,687,1,0,0,0,676,
  	677,3,140,70,0,677,678,5,7,0,0,678,679,3,90,45,0,679,680,5,8,0,0,680,
  	681,3,94,47,0,681,687,1,0,0,0,682,684,5,18,0,0,683,682,1,0,0,0,683,684,
  	1,0,0,0,684,685,1,0,0,0,685,687,3,114,57,0,686,647,1,0,0,0,686,651,1,
  	0,0,0,686,658,1,0,0,0,686,671,1,0,0,0,686,676,1,0,0,0,686,683,1,0,0,0,
  	687,105,1,0,0,0,688,696,3,142,71,0,689,696,5,120,0,0,690,696,3,134,67,
  	0,691,692,5,5,0,0,692,693,3,114,57,0,693,694,5,6,0,0,694,696,1,0,0,0,
  	695,688,1,0,0,0,695,689,1,0,0,0,695,690,1,0,0,0,695,691,1,0,0,0,696,107,
  	1,0,0,0,697,709,5,7,0,0,698,703,3,110,55,0,699,700,5,13,0,0,700,702,3,
  	110,55,0,701,699,1,0,0,0,702,705,1,0,0,0,703,701,1,0,0,0,703,704,1,0,
  	0,0,704,707,1,0,0,0,705,703,1,0,0,0,706,708,5,13,0,0,707,706,1,0,0,0,
  	707,708,1,0,0,0,708,710,1,0,0,0,709,698,1,0,0,0,709,710,1,0,0,0,710,711,
  	1,0,0,0,711,712,5,8,0,0,712,109,1,0,0,0,713,715,5,18,0,0,714,713,1,0,
  	0,0,714,715,1,0,0,0,715,718,1,0,0,0,716,719,3,114,57,0,717,719,3,144,
  	72,0,718,716,1,0,0,0,718,717,1,0,0,0,719,111,1,0,0,0,720,725,3,114,57,
  	0,721,722,5,13,0,0,722,724,3,114,57,0,723,721,1,0,0,0,724,727,1,0,0,0,
  	725,723,1,0,0,0,725,726,1,0,0,0,726,113,1,0,0,0,727,725,1,0,0,0,728,729,
  	6,57,-1,0,729,781,3,120,60,0,730,732,5,100,0,0,731,733,3,144,72,0,732,
  	731,1,0,0,0,732,733,1,0,0,0,733,734,1,0,0,0,734,781,3,82,41,0,735,736,
  	5,78,0,0,736,737,3,114,57,0,737,738,3,108,54,0,738,781,1,0,0,0,739,740,
  	5,78,0,0,740,781,3,114,57,42,741,742,5,78,0,0,742,743,5,19,0,0,743,781,
  	3,144,72,0,744,745,5,95,0,0,745,781,3,114,57,37,746,747,5,83,0,0,747,
  	781,3,114,57,36,748,749,5,75,0,0,749,781,3,114,57,35,750,751,5,20,0,0,
  	751,781,3,114,57,34,752,753,5,21,0,0,753,781,3,114,57,33,754,755,5,22,
  	0,0,755,781,3,114,57,32,756,757,5,23,0,0,757,781,3,114,57,31,758,759,
  	5,24,0,0,759,781,3,114,57,30,760,761,5,25,0,0,761,781,3,114,57,29,762,
  	763,5,108,0,0,763,781,3,114,57,28,764,765,5,106,0,0,765,766,5,7,0,0,766,
  	767,3,114,57,0,767,768,5,8,0,0,768,781,1,0,0,0,769,781,3,52,26,0,770,
  	781,5,90,0,0,771,781,3,144,72,0,772,781,5,103,0,0,773,781,3,128,64,0,
  	774,781,3,98,49,0,775,781,3,118,59,0,776,777,5,7,0,0,777,778,3,112,56,
  	0,778,779,5,8,0,0,779,781,1,0,0,0,780,728,1,0,0,0,780,730,1,0,0,0,780,
  	735,1,0,0,0,780,739,1,0,0,0,780,741,1,0,0,0,780,744,1,0,0,0,780,746,1,
  	0,0,0,780,748,1,0,0,0,780,750,1,0,0,0,780,752,1,0,0,0,780,754,1,0,0,0,
  	780,756,1,0,0,0,780,758,1,0,0,0,780,760,1,0,0,0,780,762,1,0,0,0,780,764,
  	1,0,0,0,780,769,1,0,0,0,780,770,1,0,0,0,780,771,1,0,0,0,780,772,1,0,0,
  	0,780,773,1,0,0,0,780,774,1,0,0,0,780,775,1,0,0,0,780,776,1,0,0,0,781,
  	869,1,0,0,0,782,783,10,46,0,0,783,784,5,16,0,0,784,868,3,114,57,47,785,
  	786,10,27,0,0,786,787,5,29,0,0,787,868,3,114,57,27,788,789,10,26,0,0,
  	789,790,7,0,0,0,790,868,3,114,57,27,791,792,10,25,0,0,792,793,7,1,0,0,
  	793,868,3,114,57,26,794,795,10,24,0,0,795,796,5,30,0,0,796,868,3,114,
  	57,25,797,798,10,23,0,0,798,799,7,2,0,0,799,868,3,114,57,24,800,801,10,
  	22,0,0,801,802,7,3,0,0,802,868,3,114,57,23,803,804,10,21,0,0,804,805,
  	5,74,0,0,805,868,3,114,57,22,806,807,10,20,0,0,807,808,5,96,0,0,808,868,
  	3,114,57,21,809,810,10,19,0,0,810,811,7,4,0,0,811,868,3,114,57,20,812,
  	813,10,18,0,0,813,814,5,43,0,0,814,868,3,114,57,19,815,816,10,17,0,0,
  	816,817,5,44,0,0,817,868,3,114,57,18,818,819,10,16,0,0,819,820,5,45,0,
  	0,820,868,3,114,57,17,821,822,10,15,0,0,822,823,5,46,0,0,823,868,3,114,
  	57,16,824,825,10,14,0,0,825,826,5,47,0,0,826,868,3,114,57,15,827,828,
  	10,13,0,0,828,829,5,15,0,0,829,830,3,114,57,0,830,831,5,17,0,0,831,832,
  	3,114,57,14,832,868,1,0,0,0,833,834,10,12,0,0,834,835,5,14,0,0,835,868,
  	3,114,57,12,836,837,10,11,0,0,837,838,3,126,63,0,838,839,3,114,57,11,
  	839,868,1,0,0,0,840,842,10,45,0,0,841,843,5,16,0,0,842,841,1,0,0,0,842,
  	843,1,0,0,0,843,844,1,0,0,0,844,845,5,5,0,0,845,846,3,112,56,0,846,847,
  	5,6,0,0,847,868,1,0,0,0,848,850,10,44,0,0,849,851,5,15,0,0,850,849,1,
  	0,0,0,850,851,1,0,0,0,851,852,1,0,0,0,852,854,5,19,0,0,853,855,5,31,0,
  	0,854,853,1,0,0,0,854,855,1,0,0,0,855,856,1,0,0,0,856,868,3,142,71,0,
  	857,858,10,41,0,0,858,868,3,108,54,0,859,860,10,39,0,0,860,861,4,57,30,
  	0,861,868,5,20,0,0,862,863,10,38,0,0,863,864,4,57,32,0,864,868,5,21,0,
  	0,865,866,10,9,0,0,866,868,3,130,65,0,867,782,1,0,0,0,867,785,1,0,0,0,
  	867,788,1,0,0,0,867,791,1,0,0,0,867,794,1,0,0,0,867,797,1,0,0,0,867,800,
  	1,0,0,0,867,803,1,0,0,0,867,806,1,0,0,0,867,809,1,0,0,0,867,812,1,0,0,
  	0,867,815,1,0,0,0,867,818,1,0,0,0,867,821,1,0,0,0,867,824,1,0,0,0,867,
  	827,1,0,0,0,867,833,1,0,0,0,867,836,1,0,0,0,867,840,1,0,0,0,867,848,1,
  	0,0,0,867,857,1,0,0,0,867,859,1,0,0,0,867,862,1,0,0,0,867,865,1,0,0,0,
  	868,871,1,0,0,0,869,867,1,0,0,0,869,870,1,0,0,0,870,115,1,0,0,0,871,869,
  	1,0,0,0,872,876,3,144,72,0,873,876,3,98,49,0,874,876,3,118,59,0,875,872,
  	1,0,0,0,875,873,1,0,0,0,875,874,1,0,0,0,876,117,1,0,0,0,877,889,5,9,0,
  	0,878,883,3,104,52,0,879,880,5,13,0,0,880,882,3,104,52,0,881,879,1,0,
  	0,0,882,885,1,0,0,0,883,881,1,0,0,0,883,884,1,0,0,0,884,887,1,0,0,0,885,
  	883,1,0,0,0,886,888,5,13,0,0,887,886,1,0,0,0,887,888,1,0,0,0,888,890,
  	1,0,0,0,889,878,1,0,0,0,889,890,1,0,0,0,890,891,1,0,0,0,891,892,5,11,
  	0,0,892,119,1,0,0,0,893,915,3,78,39,0,894,896,5,107,0,0,895,894,1,0,0,
  	0,895,896,1,0,0,0,896,897,1,0,0,0,897,899,5,89,0,0,898,900,5,26,0,0,899,
  	898,1,0,0,0,899,900,1,0,0,0,900,901,1,0,0,0,901,903,5,7,0,0,902,904,3,
  	88,44,0,903,902,1,0,0,0,903,904,1,0,0,0,904,905,1,0,0,0,905,906,5,8,0,
  	0,906,915,3,94,47,0,907,909,5,107,0,0,908,907,1,0,0,0,908,909,1,0,0,0,
  	909,910,1,0,0,0,910,911,3,122,61,0,911,912,5,60,0,0,912,913,3,124,62,
  	0,913,915,1,0,0,0,914,893,1,0,0,0,914,895,1,0,0,0,914,908,1,0,0,0,915,
  	121,1,0,0,0,916,923,3,144,72,0,917,919,5,7,0,0,918,920,3,88,44,0,919,
  	918,1,0,0,0,919,920,1,0,0,0,920,921,1,0,0,0,921,923,5,8,0,0,922,916,1,
  	0,0,0,922,917,1,0,0,0,923,123,1,0,0,0,924,927,3,114,57,0,925,927,3,94,
  	47,0,926,924,1,0,0,0,926,925,1,0,0,0,927,125,1,0,0,0,928,929,7,5,0,0,
  	929,127,1,0,0,0,930,938,5,61,0,0,931,938,5,62,0,0,932,938,5,120,0,0,933,
  	938,3,130,65,0,934,938,5,4,0,0,935,938,3,134,67,0,936,938,3,136,68,0,
  	937,930,1,0,0,0,937,931,1,0,0,0,937,932,1,0,0,0,937,933,1,0,0,0,937,934,
  	1,0,0,0,937,935,1,0,0,0,937,936,1,0,0,0,938,129,1,0,0,0,939,943,5,121,
  	0,0,940,942,3,132,66,0,941,940,1,0,0,0,942,945,1,0,0,0,943,941,1,0,0,
  	0,943,944,1,0,0,0,944,946,1,0,0,0,945,943,1,0,0,0,946,947,5,121,0,0,947,
  	131,1,0,0,0,948,954,5,128,0,0,949,950,5,127,0,0,950,951,3,114,57,0,951,
  	952,5,10,0,0,952,954,1,0,0,0,953,948,1,0,0,0,953,949,1,0,0,0,954,133,
  	1,0,0,0,955,956,7,6,0,0,956,135,1,0,0,0,957,958,7,7,0,0,958,137,1,0,0,
  	0,959,960,4,69,34,0,960,961,3,144,72,0,961,962,3,106,53,0,962,139,1,0,
  	0,0,963,964,4,70,35,0,964,965,3,144,72,0,965,966,3,106,53,0,966,141,1,
  	0,0,0,967,970,3,144,72,0,968,970,3,146,73,0,969,967,1,0,0,0,969,968,1,
  	0,0,0,970,143,1,0,0,0,971,972,7,8,0,0,972,145,1,0,0,0,973,977,3,148,74,
  	0,974,977,5,61,0,0,975,977,5,62,0,0,976,973,1,0,0,0,976,974,1,0,0,0,976,
  	975,1,0,0,0,977,147,1,0,0,0,978,1025,5,72,0,0,979,1025,5,73,0,0,980,1025,
  	5,74,0,0,981,1025,5,75,0,0,982,1025,5,76,0,0,983,1025,5,77,0,0,984,1025,
  	5,78,0,0,985,1025,5,79,0,0,986,1025,5,80,0,0,987,1025,5,81,0,0,988,1025,
  	5,82,0,0,989,1025,5,83,0,0,990,1025,5,84,0,0,991,1025,5,85,0,0,992,1025,
  	5,86,0,0,993,1025,5,87,0,0,994,1025,5,88,0,0,995,1025,5,89,0,0,996,1025,
  	5,90,0,0,997,1025,5,91,0,0,998,1025,5,92,0,0,999,1025,5,93,0,0,1000,1025,
  	5,94,0,0,1001,1025,5,95,0,0,1002,1025,5,96,0,0,1003,1025,5,97,0,0,1004,
  	1025,5,100,0,0,1005,1025,5,101,0,0,1006,1025,5,102,0,0,1007,1025,5,103,
  	0,0,1008,1025,5,104,0,0,1009,1025,5,105,0,0,1010,1025,5,106,0,0,1011,
  	1025,5,110,0,0,1012,1025,3,150,75,0,1013,1025,5,113,0,0,1014,1025,5,114,
  	0,0,1015,1025,5,115,0,0,1016,1025,5,116,0,0,1017,1025,5,117,0,0,1018,
  	1025,5,118,0,0,1019,1025,5,109,0,0,1020,1025,5,107,0,0,1021,1025,5,108,
  	0,0,1022,1025,5,99,0,0,1023,1025,5,98,0,0,1024,978,1,0,0,0,1024,979,1,
  	0,0,0,1024,980,1,0,0,0,1024,981,1,0,0,0,1024,982,1,0,0,0,1024,983,1,0,
  	0,0,1024,984,1,0,0,0,1024,985,1,0,0,0,1024,986,1,0,0,0,1024,987,1,0,0,
  	0,1024,988,1,0,0,0,1024,989,1,0,0,0,1024,990,1,0,0,0,1024,991,1,0,0,0,
  	1024,992,1,0,0,0,1024,993,1,0,0,0,1024,994,1,0,0,0,1024,995,1,0,0,0,1024,
  	996,1,0,0,0,1024,997,1,0,0,0,1024,998,1,0,0,0,1024,999,1,0,0,0,1024,1000,
  	1,0,0,0,1024,1001,1,0,0,0,1024,1002,1,0,0,0,1024,1003,1,0,0,0,1024,1004,
  	1,0,0,0,1024,1005,1,0,0,0,1024,1006,1,0,0,0,1024,1007,1,0,0,0,1024,1008,
  	1,0,0,0,1024,1009,1,0,0,0,1024,1010,1,0,0,0,1024,1011,1,0,0,0,1024,1012,
  	1,0,0,0,1024,1013,1,0,0,0,1024,1014,1,0,0,0,1024,1015,1,0,0,0,1024,1016,
  	1,0,0,0,1024,1017,1,0,0,0,1024,1018,1,0,0,0,1024,1019,1,0,0,0,1024,1020,
  	1,0,0,0,1024,1021,1,0,0,0,1024,1022,1,0,0,0,1024,1023,1,0,0,0,1025,149,
  	1,0,0,0,1026,1027,7,9,0,0,1027,151,1,0,0,0,1028,1033,5,12,0,0,1029,1033,
  	5,0,0,1,1030,1033,4,76,36,0,1031,1033,4,76,37,0,1032,1028,1,0,0,0,1032,
  	1029,1,0,0,0,1032,1030,1,0,0,0,1032,1031,1,0,0,0,1033,153,1,0,0,0,113,
  	155,158,184,188,195,201,205,212,220,225,227,236,240,248,253,262,270,274,
  	279,290,296,311,331,335,339,347,356,361,369,374,379,386,393,400,418,422,
  	424,431,437,442,457,460,465,468,479,483,488,499,505,514,516,525,529,535,
  	538,541,546,552,555,563,566,571,576,583,588,591,596,603,610,619,623,628,
  	633,639,643,658,661,666,683,686,695,703,707,709,714,718,725,732,780,842,
  	850,854,867,869,875,883,887,889,895,899,903,908,914,919,922,926,937,943,
  	953,969,976,1024,1032
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  myparserParserStaticData = staticData.release();
}

}

myParser::myParser(TokenStream *input) : myParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

myParser::myParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : myParserBase(input) {
  myParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *myparserParserStaticData->atn, myparserParserStaticData->decisionToDFA, myparserParserStaticData->sharedContextCache, options);
}

myParser::~myParser() {
  delete _interpreter;
}

const atn::ATN& myParser::getATN() const {
  return *myparserParserStaticData->atn;
}

std::string myParser::getGrammarFileName() const {
  return "myParser.g4";
}

const std::vector<std::string>& myParser::getRuleNames() const {
  return myparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& myParser::getVocabulary() const {
  return myparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView myParser::getSerializedATN() const {
  return myparserParserStaticData->serializedATN;
}


//----------------- ProgramContext ------------------------------------------------------------------

myParser::ProgramContext::ProgramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ProgramContext::EOF() {
  return getToken(myParser::EOF, 0);
}

tree::TerminalNode* myParser::ProgramContext::HashBangLine() {
  return getToken(myParser::HashBangLine, 0);
}

myParser::SourceElementsContext* myParser::ProgramContext::sourceElements() {
  return getRuleContext<myParser::SourceElementsContext>(0);
}


size_t myParser::ProgramContext::getRuleIndex() const {
  return myParser::RuleProgram;
}

void myParser::ProgramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProgram(this);
}

void myParser::ProgramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProgram(this);
}

myParser::ProgramContext* myParser::program() {
  ProgramContext *_localctx = _tracker.createInstance<ProgramContext>(_ctx, getState());
  enterRule(_localctx, 0, myParser::RuleProgram);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(155);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx)) {
    case 1: {
      setState(154);
      match(myParser::HashBangLine);
      break;
    }

    default:
      break;
    }
    setState(158);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx)) {
    case 1: {
      setState(157);
      sourceElements();
      break;
    }

    default:
      break;
    }
    setState(160);
    match(myParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SourceElementContext ------------------------------------------------------------------

myParser::SourceElementContext::SourceElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::StatementContext* myParser::SourceElementContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}


size_t myParser::SourceElementContext::getRuleIndex() const {
  return myParser::RuleSourceElement;
}

void myParser::SourceElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSourceElement(this);
}

void myParser::SourceElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSourceElement(this);
}

myParser::SourceElementContext* myParser::sourceElement() {
  SourceElementContext *_localctx = _tracker.createInstance<SourceElementContext>(_ctx, getState());
  enterRule(_localctx, 2, myParser::RuleSourceElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(162);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

myParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::BlockContext* myParser::StatementContext::block() {
  return getRuleContext<myParser::BlockContext>(0);
}

myParser::VariableStatementContext* myParser::StatementContext::variableStatement() {
  return getRuleContext<myParser::VariableStatementContext>(0);
}

myParser::ImportStatementContext* myParser::StatementContext::importStatement() {
  return getRuleContext<myParser::ImportStatementContext>(0);
}

myParser::ExportStatementContext* myParser::StatementContext::exportStatement() {
  return getRuleContext<myParser::ExportStatementContext>(0);
}

myParser::EmptyStatement_Context* myParser::StatementContext::emptyStatement_() {
  return getRuleContext<myParser::EmptyStatement_Context>(0);
}

myParser::ClassDeclarationContext* myParser::StatementContext::classDeclaration() {
  return getRuleContext<myParser::ClassDeclarationContext>(0);
}

myParser::ExpressionStatementContext* myParser::StatementContext::expressionStatement() {
  return getRuleContext<myParser::ExpressionStatementContext>(0);
}

myParser::IfStatementContext* myParser::StatementContext::ifStatement() {
  return getRuleContext<myParser::IfStatementContext>(0);
}

myParser::IterationStatementContext* myParser::StatementContext::iterationStatement() {
  return getRuleContext<myParser::IterationStatementContext>(0);
}

myParser::ContinueStatementContext* myParser::StatementContext::continueStatement() {
  return getRuleContext<myParser::ContinueStatementContext>(0);
}

myParser::BreakStatementContext* myParser::StatementContext::breakStatement() {
  return getRuleContext<myParser::BreakStatementContext>(0);
}

myParser::ReturnStatementContext* myParser::StatementContext::returnStatement() {
  return getRuleContext<myParser::ReturnStatementContext>(0);
}

myParser::YieldStatementContext* myParser::StatementContext::yieldStatement() {
  return getRuleContext<myParser::YieldStatementContext>(0);
}

myParser::WithStatementContext* myParser::StatementContext::withStatement() {
  return getRuleContext<myParser::WithStatementContext>(0);
}

myParser::LabelledStatementContext* myParser::StatementContext::labelledStatement() {
  return getRuleContext<myParser::LabelledStatementContext>(0);
}

myParser::SwitchStatementContext* myParser::StatementContext::switchStatement() {
  return getRuleContext<myParser::SwitchStatementContext>(0);
}

myParser::ThrowStatementContext* myParser::StatementContext::throwStatement() {
  return getRuleContext<myParser::ThrowStatementContext>(0);
}

myParser::TryStatementContext* myParser::StatementContext::tryStatement() {
  return getRuleContext<myParser::TryStatementContext>(0);
}

myParser::DebuggerStatementContext* myParser::StatementContext::debuggerStatement() {
  return getRuleContext<myParser::DebuggerStatementContext>(0);
}

myParser::FunctionDeclarationContext* myParser::StatementContext::functionDeclaration() {
  return getRuleContext<myParser::FunctionDeclarationContext>(0);
}


size_t myParser::StatementContext::getRuleIndex() const {
  return myParser::RuleStatement;
}

void myParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void myParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}

myParser::StatementContext* myParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 4, myParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(184);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(164);
      block();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(165);
      variableStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(166);
      importStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(167);
      exportStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(168);
      emptyStatement_();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(169);
      classDeclaration();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(170);
      expressionStatement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(171);
      ifStatement();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(172);
      iterationStatement();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(173);
      continueStatement();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(174);
      breakStatement();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(175);
      returnStatement();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(176);
      yieldStatement();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(177);
      withStatement();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(178);
      labelledStatement();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(179);
      switchStatement();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(180);
      throwStatement();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(181);
      tryStatement();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(182);
      debuggerStatement();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(183);
      functionDeclaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContext ------------------------------------------------------------------

myParser::BlockContext::BlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::BlockContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

tree::TerminalNode* myParser::BlockContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

myParser::StatementListContext* myParser::BlockContext::statementList() {
  return getRuleContext<myParser::StatementListContext>(0);
}


size_t myParser::BlockContext::getRuleIndex() const {
  return myParser::RuleBlock;
}

void myParser::BlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock(this);
}

void myParser::BlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock(this);
}

myParser::BlockContext* myParser::block() {
  BlockContext *_localctx = _tracker.createInstance<BlockContext>(_ctx, getState());
  enterRule(_localctx, 6, myParser::RuleBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(186);
    match(myParser::OpenBrace);
    setState(188);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx)) {
    case 1: {
      setState(187);
      statementList();
      break;
    }

    default:
      break;
    }
    setState(190);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementListContext ------------------------------------------------------------------

myParser::StatementListContext::StatementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::StatementContext *> myParser::StatementListContext::statement() {
  return getRuleContexts<myParser::StatementContext>();
}

myParser::StatementContext* myParser::StatementListContext::statement(size_t i) {
  return getRuleContext<myParser::StatementContext>(i);
}


size_t myParser::StatementListContext::getRuleIndex() const {
  return myParser::RuleStatementList;
}

void myParser::StatementListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatementList(this);
}

void myParser::StatementListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatementList(this);
}

myParser::StatementListContext* myParser::statementList() {
  StatementListContext *_localctx = _tracker.createInstance<StatementListContext>(_ctx, getState());
  enterRule(_localctx, 8, myParser::RuleStatementList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(193); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(192);
              statement();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(195); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportStatementContext ------------------------------------------------------------------

myParser::ImportStatementContext::ImportStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ImportStatementContext::Import() {
  return getToken(myParser::Import, 0);
}

myParser::ImportFromBlockContext* myParser::ImportStatementContext::importFromBlock() {
  return getRuleContext<myParser::ImportFromBlockContext>(0);
}


size_t myParser::ImportStatementContext::getRuleIndex() const {
  return myParser::RuleImportStatement;
}

void myParser::ImportStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportStatement(this);
}

void myParser::ImportStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportStatement(this);
}

myParser::ImportStatementContext* myParser::importStatement() {
  ImportStatementContext *_localctx = _tracker.createInstance<ImportStatementContext>(_ctx, getState());
  enterRule(_localctx, 10, myParser::RuleImportStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(197);
    match(myParser::Import);
    setState(198);
    importFromBlock();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportFromBlockContext ------------------------------------------------------------------

myParser::ImportFromBlockContext::ImportFromBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ImportFromContext* myParser::ImportFromBlockContext::importFrom() {
  return getRuleContext<myParser::ImportFromContext>(0);
}

myParser::EosContext* myParser::ImportFromBlockContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}

myParser::ImportNamespaceContext* myParser::ImportFromBlockContext::importNamespace() {
  return getRuleContext<myParser::ImportNamespaceContext>(0);
}

myParser::ModuleItemsContext* myParser::ImportFromBlockContext::moduleItems() {
  return getRuleContext<myParser::ModuleItemsContext>(0);
}

myParser::ImportDefaultContext* myParser::ImportFromBlockContext::importDefault() {
  return getRuleContext<myParser::ImportDefaultContext>(0);
}

tree::TerminalNode* myParser::ImportFromBlockContext::StringLiteral() {
  return getToken(myParser::StringLiteral, 0);
}


size_t myParser::ImportFromBlockContext::getRuleIndex() const {
  return myParser::RuleImportFromBlock;
}

void myParser::ImportFromBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportFromBlock(this);
}

void myParser::ImportFromBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportFromBlock(this);
}

myParser::ImportFromBlockContext* myParser::importFromBlock() {
  ImportFromBlockContext *_localctx = _tracker.createInstance<ImportFromBlockContext>(_ctx, getState());
  enterRule(_localctx, 12, myParser::RuleImportFromBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(212);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::OpenBrace:
      case myParser::Multiply:
      case myParser::NullLiteral:
      case myParser::BooleanLiteral:
      case myParser::Break:
      case myParser::Do:
      case myParser::Instanceof:
      case myParser::Typeof:
      case myParser::Case:
      case myParser::Else:
      case myParser::New:
      case myParser::Var:
      case myParser::Catch:
      case myParser::Finally:
      case myParser::Return:
      case myParser::Void:
      case myParser::Continue:
      case myParser::For:
      case myParser::Switch:
      case myParser::While:
      case myParser::Debugger:
      case myParser::Function_:
      case myParser::This:
      case myParser::With:
      case myParser::Default:
      case myParser::If:
      case myParser::Throw:
      case myParser::Delete:
      case myParser::In:
      case myParser::Try:
      case myParser::As:
      case myParser::From:
      case myParser::Class:
      case myParser::Enum:
      case myParser::Extends:
      case myParser::Super:
      case myParser::Const:
      case myParser::Export:
      case myParser::Import:
      case myParser::Async:
      case myParser::Await:
      case myParser::Yield:
      case myParser::Implements:
      case myParser::StrictLet:
      case myParser::NonStrictLet:
      case myParser::Private:
      case myParser::Public:
      case myParser::Interface:
      case myParser::Package:
      case myParser::Protected:
      case myParser::Static:
      case myParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(201);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
        case 1: {
          setState(200);
          importDefault();
          break;
        }

        default:
          break;
        }
        setState(205);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case myParser::Multiply:
          case myParser::NullLiteral:
          case myParser::BooleanLiteral:
          case myParser::Break:
          case myParser::Do:
          case myParser::Instanceof:
          case myParser::Typeof:
          case myParser::Case:
          case myParser::Else:
          case myParser::New:
          case myParser::Var:
          case myParser::Catch:
          case myParser::Finally:
          case myParser::Return:
          case myParser::Void:
          case myParser::Continue:
          case myParser::For:
          case myParser::Switch:
          case myParser::While:
          case myParser::Debugger:
          case myParser::Function_:
          case myParser::This:
          case myParser::With:
          case myParser::Default:
          case myParser::If:
          case myParser::Throw:
          case myParser::Delete:
          case myParser::In:
          case myParser::Try:
          case myParser::As:
          case myParser::From:
          case myParser::Class:
          case myParser::Enum:
          case myParser::Extends:
          case myParser::Super:
          case myParser::Const:
          case myParser::Export:
          case myParser::Import:
          case myParser::Async:
          case myParser::Await:
          case myParser::Yield:
          case myParser::Implements:
          case myParser::StrictLet:
          case myParser::NonStrictLet:
          case myParser::Private:
          case myParser::Public:
          case myParser::Interface:
          case myParser::Package:
          case myParser::Protected:
          case myParser::Static:
          case myParser::Identifier: {
            setState(203);
            importNamespace();
            break;
          }

          case myParser::OpenBrace: {
            setState(204);
            moduleItems();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(207);
        importFrom();
        setState(208);
        eos();
        break;
      }

      case myParser::StringLiteral: {
        enterOuterAlt(_localctx, 2);
        setState(210);
        match(myParser::StringLiteral);
        setState(211);
        eos();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleItemsContext ------------------------------------------------------------------

myParser::ModuleItemsContext::ModuleItemsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ModuleItemsContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

tree::TerminalNode* myParser::ModuleItemsContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

std::vector<myParser::AliasNameContext *> myParser::ModuleItemsContext::aliasName() {
  return getRuleContexts<myParser::AliasNameContext>();
}

myParser::AliasNameContext* myParser::ModuleItemsContext::aliasName(size_t i) {
  return getRuleContext<myParser::AliasNameContext>(i);
}

std::vector<tree::TerminalNode *> myParser::ModuleItemsContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::ModuleItemsContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::ModuleItemsContext::getRuleIndex() const {
  return myParser::RuleModuleItems;
}

void myParser::ModuleItemsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModuleItems(this);
}

void myParser::ModuleItemsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModuleItems(this);
}

myParser::ModuleItemsContext* myParser::moduleItems() {
  ModuleItemsContext *_localctx = _tracker.createInstance<ModuleItemsContext>(_ctx, getState());
  enterRule(_localctx, 14, myParser::RuleModuleItems);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(214);
    match(myParser::OpenBrace);
    setState(220);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(215);
        aliasName();
        setState(216);
        match(myParser::Comma); 
      }
      setState(222);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx);
    }
    setState(227);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 61) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 61)) & 576460752303421443) != 0)) {
      setState(223);
      aliasName();
      setState(225);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::Comma) {
        setState(224);
        match(myParser::Comma);
      }
    }
    setState(229);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportDefaultContext ------------------------------------------------------------------

myParser::ImportDefaultContext::ImportDefaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::AliasNameContext* myParser::ImportDefaultContext::aliasName() {
  return getRuleContext<myParser::AliasNameContext>(0);
}

tree::TerminalNode* myParser::ImportDefaultContext::Comma() {
  return getToken(myParser::Comma, 0);
}


size_t myParser::ImportDefaultContext::getRuleIndex() const {
  return myParser::RuleImportDefault;
}

void myParser::ImportDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportDefault(this);
}

void myParser::ImportDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportDefault(this);
}

myParser::ImportDefaultContext* myParser::importDefault() {
  ImportDefaultContext *_localctx = _tracker.createInstance<ImportDefaultContext>(_ctx, getState());
  enterRule(_localctx, 16, myParser::RuleImportDefault);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(231);
    aliasName();
    setState(232);
    match(myParser::Comma);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportNamespaceContext ------------------------------------------------------------------

myParser::ImportNamespaceContext::ImportNamespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ImportNamespaceContext::Multiply() {
  return getToken(myParser::Multiply, 0);
}

std::vector<myParser::IdentifierNameContext *> myParser::ImportNamespaceContext::identifierName() {
  return getRuleContexts<myParser::IdentifierNameContext>();
}

myParser::IdentifierNameContext* myParser::ImportNamespaceContext::identifierName(size_t i) {
  return getRuleContext<myParser::IdentifierNameContext>(i);
}

tree::TerminalNode* myParser::ImportNamespaceContext::As() {
  return getToken(myParser::As, 0);
}


size_t myParser::ImportNamespaceContext::getRuleIndex() const {
  return myParser::RuleImportNamespace;
}

void myParser::ImportNamespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportNamespace(this);
}

void myParser::ImportNamespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportNamespace(this);
}

myParser::ImportNamespaceContext* myParser::importNamespace() {
  ImportNamespaceContext *_localctx = _tracker.createInstance<ImportNamespaceContext>(_ctx, getState());
  enterRule(_localctx, 18, myParser::RuleImportNamespace);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(236);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Multiply: {
        setState(234);
        match(myParser::Multiply);
        break;
      }

      case myParser::NullLiteral:
      case myParser::BooleanLiteral:
      case myParser::Break:
      case myParser::Do:
      case myParser::Instanceof:
      case myParser::Typeof:
      case myParser::Case:
      case myParser::Else:
      case myParser::New:
      case myParser::Var:
      case myParser::Catch:
      case myParser::Finally:
      case myParser::Return:
      case myParser::Void:
      case myParser::Continue:
      case myParser::For:
      case myParser::Switch:
      case myParser::While:
      case myParser::Debugger:
      case myParser::Function_:
      case myParser::This:
      case myParser::With:
      case myParser::Default:
      case myParser::If:
      case myParser::Throw:
      case myParser::Delete:
      case myParser::In:
      case myParser::Try:
      case myParser::As:
      case myParser::From:
      case myParser::Class:
      case myParser::Enum:
      case myParser::Extends:
      case myParser::Super:
      case myParser::Const:
      case myParser::Export:
      case myParser::Import:
      case myParser::Async:
      case myParser::Await:
      case myParser::Yield:
      case myParser::Implements:
      case myParser::StrictLet:
      case myParser::NonStrictLet:
      case myParser::Private:
      case myParser::Public:
      case myParser::Interface:
      case myParser::Package:
      case myParser::Protected:
      case myParser::Static:
      case myParser::Identifier: {
        setState(235);
        identifierName();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(240);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::As) {
      setState(238);
      match(myParser::As);
      setState(239);
      identifierName();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportFromContext ------------------------------------------------------------------

myParser::ImportFromContext::ImportFromContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ImportFromContext::From() {
  return getToken(myParser::From, 0);
}

tree::TerminalNode* myParser::ImportFromContext::StringLiteral() {
  return getToken(myParser::StringLiteral, 0);
}


size_t myParser::ImportFromContext::getRuleIndex() const {
  return myParser::RuleImportFrom;
}

void myParser::ImportFromContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportFrom(this);
}

void myParser::ImportFromContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportFrom(this);
}

myParser::ImportFromContext* myParser::importFrom() {
  ImportFromContext *_localctx = _tracker.createInstance<ImportFromContext>(_ctx, getState());
  enterRule(_localctx, 20, myParser::RuleImportFrom);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(242);
    match(myParser::From);
    setState(243);
    match(myParser::StringLiteral);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AliasNameContext ------------------------------------------------------------------

myParser::AliasNameContext::AliasNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::IdentifierNameContext *> myParser::AliasNameContext::identifierName() {
  return getRuleContexts<myParser::IdentifierNameContext>();
}

myParser::IdentifierNameContext* myParser::AliasNameContext::identifierName(size_t i) {
  return getRuleContext<myParser::IdentifierNameContext>(i);
}

tree::TerminalNode* myParser::AliasNameContext::As() {
  return getToken(myParser::As, 0);
}


size_t myParser::AliasNameContext::getRuleIndex() const {
  return myParser::RuleAliasName;
}

void myParser::AliasNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAliasName(this);
}

void myParser::AliasNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAliasName(this);
}

myParser::AliasNameContext* myParser::aliasName() {
  AliasNameContext *_localctx = _tracker.createInstance<AliasNameContext>(_ctx, getState());
  enterRule(_localctx, 22, myParser::RuleAliasName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(245);
    identifierName();
    setState(248);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::As) {
      setState(246);
      match(myParser::As);
      setState(247);
      identifierName();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExportStatementContext ------------------------------------------------------------------

myParser::ExportStatementContext::ExportStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t myParser::ExportStatementContext::getRuleIndex() const {
  return myParser::RuleExportStatement;
}

void myParser::ExportStatementContext::copyFrom(ExportStatementContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ExportDefaultDeclarationContext ------------------------------------------------------------------

tree::TerminalNode* myParser::ExportDefaultDeclarationContext::Export() {
  return getToken(myParser::Export, 0);
}

tree::TerminalNode* myParser::ExportDefaultDeclarationContext::Default() {
  return getToken(myParser::Default, 0);
}

myParser::SingleExpressionContext* myParser::ExportDefaultDeclarationContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::EosContext* myParser::ExportDefaultDeclarationContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}

myParser::ExportDefaultDeclarationContext::ExportDefaultDeclarationContext(ExportStatementContext *ctx) { copyFrom(ctx); }

void myParser::ExportDefaultDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExportDefaultDeclaration(this);
}
void myParser::ExportDefaultDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExportDefaultDeclaration(this);
}
//----------------- ExportDeclarationContext ------------------------------------------------------------------

tree::TerminalNode* myParser::ExportDeclarationContext::Export() {
  return getToken(myParser::Export, 0);
}

myParser::EosContext* myParser::ExportDeclarationContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}

myParser::ExportFromBlockContext* myParser::ExportDeclarationContext::exportFromBlock() {
  return getRuleContext<myParser::ExportFromBlockContext>(0);
}

myParser::DeclarationContext* myParser::ExportDeclarationContext::declaration() {
  return getRuleContext<myParser::DeclarationContext>(0);
}

myParser::ExportDeclarationContext::ExportDeclarationContext(ExportStatementContext *ctx) { copyFrom(ctx); }

void myParser::ExportDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExportDeclaration(this);
}
void myParser::ExportDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExportDeclaration(this);
}
myParser::ExportStatementContext* myParser::exportStatement() {
  ExportStatementContext *_localctx = _tracker.createInstance<ExportStatementContext>(_ctx, getState());
  enterRule(_localctx, 24, myParser::RuleExportStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(262);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<myParser::ExportDeclarationContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(250);
      match(myParser::Export);
      setState(253);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {
      case 1: {
        setState(251);
        exportFromBlock();
        break;
      }

      case 2: {
        setState(252);
        declaration();
        break;
      }

      default:
        break;
      }
      setState(255);
      eos();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<myParser::ExportDefaultDeclarationContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(257);
      match(myParser::Export);
      setState(258);
      match(myParser::Default);
      setState(259);
      singleExpression(0);
      setState(260);
      eos();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExportFromBlockContext ------------------------------------------------------------------

myParser::ExportFromBlockContext::ExportFromBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ImportNamespaceContext* myParser::ExportFromBlockContext::importNamespace() {
  return getRuleContext<myParser::ImportNamespaceContext>(0);
}

myParser::ImportFromContext* myParser::ExportFromBlockContext::importFrom() {
  return getRuleContext<myParser::ImportFromContext>(0);
}

myParser::EosContext* myParser::ExportFromBlockContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}

myParser::ModuleItemsContext* myParser::ExportFromBlockContext::moduleItems() {
  return getRuleContext<myParser::ModuleItemsContext>(0);
}


size_t myParser::ExportFromBlockContext::getRuleIndex() const {
  return myParser::RuleExportFromBlock;
}

void myParser::ExportFromBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExportFromBlock(this);
}

void myParser::ExportFromBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExportFromBlock(this);
}

myParser::ExportFromBlockContext* myParser::exportFromBlock() {
  ExportFromBlockContext *_localctx = _tracker.createInstance<ExportFromBlockContext>(_ctx, getState());
  enterRule(_localctx, 26, myParser::RuleExportFromBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(274);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Multiply:
      case myParser::NullLiteral:
      case myParser::BooleanLiteral:
      case myParser::Break:
      case myParser::Do:
      case myParser::Instanceof:
      case myParser::Typeof:
      case myParser::Case:
      case myParser::Else:
      case myParser::New:
      case myParser::Var:
      case myParser::Catch:
      case myParser::Finally:
      case myParser::Return:
      case myParser::Void:
      case myParser::Continue:
      case myParser::For:
      case myParser::Switch:
      case myParser::While:
      case myParser::Debugger:
      case myParser::Function_:
      case myParser::This:
      case myParser::With:
      case myParser::Default:
      case myParser::If:
      case myParser::Throw:
      case myParser::Delete:
      case myParser::In:
      case myParser::Try:
      case myParser::As:
      case myParser::From:
      case myParser::Class:
      case myParser::Enum:
      case myParser::Extends:
      case myParser::Super:
      case myParser::Const:
      case myParser::Export:
      case myParser::Import:
      case myParser::Async:
      case myParser::Await:
      case myParser::Yield:
      case myParser::Implements:
      case myParser::StrictLet:
      case myParser::NonStrictLet:
      case myParser::Private:
      case myParser::Public:
      case myParser::Interface:
      case myParser::Package:
      case myParser::Protected:
      case myParser::Static:
      case myParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(264);
        importNamespace();
        setState(265);
        importFrom();
        setState(266);
        eos();
        break;
      }

      case myParser::OpenBrace: {
        enterOuterAlt(_localctx, 2);
        setState(268);
        moduleItems();
        setState(270);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx)) {
        case 1: {
          setState(269);
          importFrom();
          break;
        }

        default:
          break;
        }
        setState(272);
        eos();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclarationContext ------------------------------------------------------------------

myParser::DeclarationContext::DeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::VariableStatementContext* myParser::DeclarationContext::variableStatement() {
  return getRuleContext<myParser::VariableStatementContext>(0);
}

myParser::ClassDeclarationContext* myParser::DeclarationContext::classDeclaration() {
  return getRuleContext<myParser::ClassDeclarationContext>(0);
}

myParser::FunctionDeclarationContext* myParser::DeclarationContext::functionDeclaration() {
  return getRuleContext<myParser::FunctionDeclarationContext>(0);
}


size_t myParser::DeclarationContext::getRuleIndex() const {
  return myParser::RuleDeclaration;
}

void myParser::DeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclaration(this);
}

void myParser::DeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclaration(this);
}

myParser::DeclarationContext* myParser::declaration() {
  DeclarationContext *_localctx = _tracker.createInstance<DeclarationContext>(_ctx, getState());
  enterRule(_localctx, 28, myParser::RuleDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(279);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Var:
      case myParser::Const:
      case myParser::StrictLet:
      case myParser::NonStrictLet: {
        enterOuterAlt(_localctx, 1);
        setState(276);
        variableStatement();
        break;
      }

      case myParser::Class: {
        enterOuterAlt(_localctx, 2);
        setState(277);
        classDeclaration();
        break;
      }

      case myParser::Function_:
      case myParser::Async: {
        enterOuterAlt(_localctx, 3);
        setState(278);
        functionDeclaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableStatementContext ------------------------------------------------------------------

myParser::VariableStatementContext::VariableStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::VariableDeclarationListContext* myParser::VariableStatementContext::variableDeclarationList() {
  return getRuleContext<myParser::VariableDeclarationListContext>(0);
}

myParser::EosContext* myParser::VariableStatementContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}


size_t myParser::VariableStatementContext::getRuleIndex() const {
  return myParser::RuleVariableStatement;
}

void myParser::VariableStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableStatement(this);
}

void myParser::VariableStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableStatement(this);
}

myParser::VariableStatementContext* myParser::variableStatement() {
  VariableStatementContext *_localctx = _tracker.createInstance<VariableStatementContext>(_ctx, getState());
  enterRule(_localctx, 30, myParser::RuleVariableStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(281);
    variableDeclarationList();
    setState(282);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationListContext ------------------------------------------------------------------

myParser::VariableDeclarationListContext::VariableDeclarationListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::VarModifierContext* myParser::VariableDeclarationListContext::varModifier() {
  return getRuleContext<myParser::VarModifierContext>(0);
}

std::vector<myParser::VariableDeclarationContext *> myParser::VariableDeclarationListContext::variableDeclaration() {
  return getRuleContexts<myParser::VariableDeclarationContext>();
}

myParser::VariableDeclarationContext* myParser::VariableDeclarationListContext::variableDeclaration(size_t i) {
  return getRuleContext<myParser::VariableDeclarationContext>(i);
}

std::vector<tree::TerminalNode *> myParser::VariableDeclarationListContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::VariableDeclarationListContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::VariableDeclarationListContext::getRuleIndex() const {
  return myParser::RuleVariableDeclarationList;
}

void myParser::VariableDeclarationListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclarationList(this);
}

void myParser::VariableDeclarationListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclarationList(this);
}

myParser::VariableDeclarationListContext* myParser::variableDeclarationList() {
  VariableDeclarationListContext *_localctx = _tracker.createInstance<VariableDeclarationListContext>(_ctx, getState());
  enterRule(_localctx, 32, myParser::RuleVariableDeclarationList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(284);
    varModifier();
    setState(285);
    variableDeclaration();
    setState(290);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(286);
        match(myParser::Comma);
        setState(287);
        variableDeclaration(); 
      }
      setState(292);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationContext ------------------------------------------------------------------

myParser::VariableDeclarationContext::VariableDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::AssignableContext* myParser::VariableDeclarationContext::assignable() {
  return getRuleContext<myParser::AssignableContext>(0);
}

tree::TerminalNode* myParser::VariableDeclarationContext::Assign() {
  return getToken(myParser::Assign, 0);
}

myParser::SingleExpressionContext* myParser::VariableDeclarationContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}


size_t myParser::VariableDeclarationContext::getRuleIndex() const {
  return myParser::RuleVariableDeclaration;
}

void myParser::VariableDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclaration(this);
}

void myParser::VariableDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclaration(this);
}

myParser::VariableDeclarationContext* myParser::variableDeclaration() {
  VariableDeclarationContext *_localctx = _tracker.createInstance<VariableDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 34, myParser::RuleVariableDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(293);
    assignable();
    setState(296);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
    case 1: {
      setState(294);
      match(myParser::Assign);
      setState(295);
      singleExpression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmptyStatement_Context ------------------------------------------------------------------

myParser::EmptyStatement_Context::EmptyStatement_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::EmptyStatement_Context::SemiColon() {
  return getToken(myParser::SemiColon, 0);
}


size_t myParser::EmptyStatement_Context::getRuleIndex() const {
  return myParser::RuleEmptyStatement_;
}

void myParser::EmptyStatement_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmptyStatement_(this);
}

void myParser::EmptyStatement_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmptyStatement_(this);
}

myParser::EmptyStatement_Context* myParser::emptyStatement_() {
  EmptyStatement_Context *_localctx = _tracker.createInstance<EmptyStatement_Context>(_ctx, getState());
  enterRule(_localctx, 36, myParser::RuleEmptyStatement_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(298);
    match(myParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionStatementContext ------------------------------------------------------------------

myParser::ExpressionStatementContext::ExpressionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionSequenceContext* myParser::ExpressionStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

myParser::EosContext* myParser::ExpressionStatementContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}


size_t myParser::ExpressionStatementContext::getRuleIndex() const {
  return myParser::RuleExpressionStatement;
}

void myParser::ExpressionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionStatement(this);
}

void myParser::ExpressionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionStatement(this);
}

myParser::ExpressionStatementContext* myParser::expressionStatement() {
  ExpressionStatementContext *_localctx = _tracker.createInstance<ExpressionStatementContext>(_ctx, getState());
  enterRule(_localctx, 38, myParser::RuleExpressionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(300);

    if (!(this.notOpenBraceAndNotFunction())) throw FailedPredicateException(this, "this.notOpenBraceAndNotFunction()");
    setState(301);
    expressionSequence();
    setState(302);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStatementContext ------------------------------------------------------------------

myParser::IfStatementContext::IfStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::IfStatementContext::If() {
  return getToken(myParser::If, 0);
}

tree::TerminalNode* myParser::IfStatementContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

myParser::ExpressionSequenceContext* myParser::IfStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::IfStatementContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

std::vector<myParser::StatementContext *> myParser::IfStatementContext::statement() {
  return getRuleContexts<myParser::StatementContext>();
}

myParser::StatementContext* myParser::IfStatementContext::statement(size_t i) {
  return getRuleContext<myParser::StatementContext>(i);
}

tree::TerminalNode* myParser::IfStatementContext::Else() {
  return getToken(myParser::Else, 0);
}


size_t myParser::IfStatementContext::getRuleIndex() const {
  return myParser::RuleIfStatement;
}

void myParser::IfStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfStatement(this);
}

void myParser::IfStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfStatement(this);
}

myParser::IfStatementContext* myParser::ifStatement() {
  IfStatementContext *_localctx = _tracker.createInstance<IfStatementContext>(_ctx, getState());
  enterRule(_localctx, 40, myParser::RuleIfStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(304);
    match(myParser::If);
    setState(305);
    match(myParser::OpenParen);
    setState(306);
    expressionSequence();
    setState(307);
    match(myParser::CloseParen);
    setState(308);
    statement();
    setState(311);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
    case 1: {
      setState(309);
      match(myParser::Else);
      setState(310);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IterationStatementContext ------------------------------------------------------------------

myParser::IterationStatementContext::IterationStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t myParser::IterationStatementContext::getRuleIndex() const {
  return myParser::RuleIterationStatement;
}

void myParser::IterationStatementContext::copyFrom(IterationStatementContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- DoStatementContext ------------------------------------------------------------------

tree::TerminalNode* myParser::DoStatementContext::Do() {
  return getToken(myParser::Do, 0);
}

myParser::StatementContext* myParser::DoStatementContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}

tree::TerminalNode* myParser::DoStatementContext::While() {
  return getToken(myParser::While, 0);
}

tree::TerminalNode* myParser::DoStatementContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

myParser::ExpressionSequenceContext* myParser::DoStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::DoStatementContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::EosContext* myParser::DoStatementContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}

myParser::DoStatementContext::DoStatementContext(IterationStatementContext *ctx) { copyFrom(ctx); }

void myParser::DoStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoStatement(this);
}
void myParser::DoStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoStatement(this);
}
//----------------- WhileStatementContext ------------------------------------------------------------------

tree::TerminalNode* myParser::WhileStatementContext::While() {
  return getToken(myParser::While, 0);
}

tree::TerminalNode* myParser::WhileStatementContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

myParser::ExpressionSequenceContext* myParser::WhileStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::WhileStatementContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::StatementContext* myParser::WhileStatementContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}

myParser::WhileStatementContext::WhileStatementContext(IterationStatementContext *ctx) { copyFrom(ctx); }

void myParser::WhileStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhileStatement(this);
}
void myParser::WhileStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhileStatement(this);
}
//----------------- ForStatementContext ------------------------------------------------------------------

tree::TerminalNode* myParser::ForStatementContext::For() {
  return getToken(myParser::For, 0);
}

tree::TerminalNode* myParser::ForStatementContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

std::vector<tree::TerminalNode *> myParser::ForStatementContext::SemiColon() {
  return getTokens(myParser::SemiColon);
}

tree::TerminalNode* myParser::ForStatementContext::SemiColon(size_t i) {
  return getToken(myParser::SemiColon, i);
}

tree::TerminalNode* myParser::ForStatementContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::StatementContext* myParser::ForStatementContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}

std::vector<myParser::ExpressionSequenceContext *> myParser::ForStatementContext::expressionSequence() {
  return getRuleContexts<myParser::ExpressionSequenceContext>();
}

myParser::ExpressionSequenceContext* myParser::ForStatementContext::expressionSequence(size_t i) {
  return getRuleContext<myParser::ExpressionSequenceContext>(i);
}

myParser::VariableDeclarationListContext* myParser::ForStatementContext::variableDeclarationList() {
  return getRuleContext<myParser::VariableDeclarationListContext>(0);
}

myParser::ForStatementContext::ForStatementContext(IterationStatementContext *ctx) { copyFrom(ctx); }

void myParser::ForStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForStatement(this);
}
void myParser::ForStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForStatement(this);
}
//----------------- ForInStatementContext ------------------------------------------------------------------

tree::TerminalNode* myParser::ForInStatementContext::For() {
  return getToken(myParser::For, 0);
}

tree::TerminalNode* myParser::ForInStatementContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::ForInStatementContext::In() {
  return getToken(myParser::In, 0);
}

myParser::ExpressionSequenceContext* myParser::ForInStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::ForInStatementContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::StatementContext* myParser::ForInStatementContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}

myParser::SingleExpressionContext* myParser::ForInStatementContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::VariableDeclarationListContext* myParser::ForInStatementContext::variableDeclarationList() {
  return getRuleContext<myParser::VariableDeclarationListContext>(0);
}

myParser::ForInStatementContext::ForInStatementContext(IterationStatementContext *ctx) { copyFrom(ctx); }

void myParser::ForInStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForInStatement(this);
}
void myParser::ForInStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForInStatement(this);
}
//----------------- ForOfStatementContext ------------------------------------------------------------------

tree::TerminalNode* myParser::ForOfStatementContext::For() {
  return getToken(myParser::For, 0);
}

tree::TerminalNode* myParser::ForOfStatementContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

myParser::IdentifierContext* myParser::ForOfStatementContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::ExpressionSequenceContext* myParser::ForOfStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::ForOfStatementContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::StatementContext* myParser::ForOfStatementContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}

myParser::SingleExpressionContext* myParser::ForOfStatementContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::VariableDeclarationListContext* myParser::ForOfStatementContext::variableDeclarationList() {
  return getRuleContext<myParser::VariableDeclarationListContext>(0);
}

tree::TerminalNode* myParser::ForOfStatementContext::Await() {
  return getToken(myParser::Await, 0);
}

myParser::ForOfStatementContext::ForOfStatementContext(IterationStatementContext *ctx) { copyFrom(ctx); }

void myParser::ForOfStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForOfStatement(this);
}
void myParser::ForOfStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForOfStatement(this);
}
myParser::IterationStatementContext* myParser::iterationStatement() {
  IterationStatementContext *_localctx = _tracker.createInstance<IterationStatementContext>(_ctx, getState());
  enterRule(_localctx, 42, myParser::RuleIterationStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(369);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<myParser::DoStatementContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(313);
      match(myParser::Do);
      setState(314);
      statement();
      setState(315);
      match(myParser::While);
      setState(316);
      match(myParser::OpenParen);
      setState(317);
      expressionSequence();
      setState(318);
      match(myParser::CloseParen);
      setState(319);
      eos();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<myParser::WhileStatementContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(321);
      match(myParser::While);
      setState(322);
      match(myParser::OpenParen);
      setState(323);
      expressionSequence();
      setState(324);
      match(myParser::CloseParen);
      setState(325);
      statement();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<myParser::ForStatementContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(327);
      match(myParser::For);
      setState(328);
      match(myParser::OpenParen);
      setState(331);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx)) {
      case 1: {
        setState(329);
        expressionSequence();
        break;
      }

      case 2: {
        setState(330);
        variableDeclarationList();
        break;
      }

      default:
        break;
      }
      setState(333);
      match(myParser::SemiColon);
      setState(335);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -2305843009147632976) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 252549645531105535) != 0)) {
        setState(334);
        expressionSequence();
      }
      setState(337);
      match(myParser::SemiColon);
      setState(339);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -2305843009147632976) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 252549645531105535) != 0)) {
        setState(338);
        expressionSequence();
      }
      setState(341);
      match(myParser::CloseParen);
      setState(342);
      statement();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<myParser::ForInStatementContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(343);
      match(myParser::For);
      setState(344);
      match(myParser::OpenParen);
      setState(347);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
      case 1: {
        setState(345);
        singleExpression(0);
        break;
      }

      case 2: {
        setState(346);
        variableDeclarationList();
        break;
      }

      default:
        break;
      }
      setState(349);
      match(myParser::In);
      setState(350);
      expressionSequence();
      setState(351);
      match(myParser::CloseParen);
      setState(352);
      statement();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<myParser::ForOfStatementContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(354);
      match(myParser::For);
      setState(356);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::Await) {
        setState(355);
        match(myParser::Await);
      }
      setState(358);
      match(myParser::OpenParen);
      setState(361);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
      case 1: {
        setState(359);
        singleExpression(0);
        break;
      }

      case 2: {
        setState(360);
        variableDeclarationList();
        break;
      }

      default:
        break;
      }
      setState(363);
      identifier();
      setState(364);

      if (!(this.p("of"))) throw FailedPredicateException(this, "this.p(\"of\")");
      setState(365);
      expressionSequence();
      setState(366);
      match(myParser::CloseParen);
      setState(367);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarModifierContext ------------------------------------------------------------------

myParser::VarModifierContext::VarModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::VarModifierContext::Var() {
  return getToken(myParser::Var, 0);
}

myParser::Let_Context* myParser::VarModifierContext::let_() {
  return getRuleContext<myParser::Let_Context>(0);
}

tree::TerminalNode* myParser::VarModifierContext::Const() {
  return getToken(myParser::Const, 0);
}


size_t myParser::VarModifierContext::getRuleIndex() const {
  return myParser::RuleVarModifier;
}

void myParser::VarModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarModifier(this);
}

void myParser::VarModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarModifier(this);
}

myParser::VarModifierContext* myParser::varModifier() {
  VarModifierContext *_localctx = _tracker.createInstance<VarModifierContext>(_ctx, getState());
  enterRule(_localctx, 44, myParser::RuleVarModifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(374);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Var: {
        enterOuterAlt(_localctx, 1);
        setState(371);
        match(myParser::Var);
        break;
      }

      case myParser::StrictLet:
      case myParser::NonStrictLet: {
        enterOuterAlt(_localctx, 2);
        setState(372);
        let_();
        break;
      }

      case myParser::Const: {
        enterOuterAlt(_localctx, 3);
        setState(373);
        match(myParser::Const);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ContinueStatementContext ------------------------------------------------------------------

myParser::ContinueStatementContext::ContinueStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ContinueStatementContext::Continue() {
  return getToken(myParser::Continue, 0);
}

myParser::EosContext* myParser::ContinueStatementContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}

myParser::IdentifierContext* myParser::ContinueStatementContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}


size_t myParser::ContinueStatementContext::getRuleIndex() const {
  return myParser::RuleContinueStatement;
}

void myParser::ContinueStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContinueStatement(this);
}

void myParser::ContinueStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContinueStatement(this);
}

myParser::ContinueStatementContext* myParser::continueStatement() {
  ContinueStatementContext *_localctx = _tracker.createInstance<ContinueStatementContext>(_ctx, getState());
  enterRule(_localctx, 46, myParser::RuleContinueStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(376);
    match(myParser::Continue);
    setState(379);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
    case 1: {
      setState(377);

      if (!(this.notLineTerminator())) throw FailedPredicateException(this, "this.notLineTerminator()");
      setState(378);
      identifier();
      break;
    }

    default:
      break;
    }
    setState(381);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BreakStatementContext ------------------------------------------------------------------

myParser::BreakStatementContext::BreakStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::BreakStatementContext::Break() {
  return getToken(myParser::Break, 0);
}

myParser::EosContext* myParser::BreakStatementContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}

myParser::IdentifierContext* myParser::BreakStatementContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}


size_t myParser::BreakStatementContext::getRuleIndex() const {
  return myParser::RuleBreakStatement;
}

void myParser::BreakStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBreakStatement(this);
}

void myParser::BreakStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBreakStatement(this);
}

myParser::BreakStatementContext* myParser::breakStatement() {
  BreakStatementContext *_localctx = _tracker.createInstance<BreakStatementContext>(_ctx, getState());
  enterRule(_localctx, 48, myParser::RuleBreakStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(383);
    match(myParser::Break);
    setState(386);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
    case 1: {
      setState(384);

      if (!(this.notLineTerminator())) throw FailedPredicateException(this, "this.notLineTerminator()");
      setState(385);
      identifier();
      break;
    }

    default:
      break;
    }
    setState(388);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnStatementContext ------------------------------------------------------------------

myParser::ReturnStatementContext::ReturnStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ReturnStatementContext::Return() {
  return getToken(myParser::Return, 0);
}

myParser::EosContext* myParser::ReturnStatementContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}

myParser::ExpressionSequenceContext* myParser::ReturnStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}


size_t myParser::ReturnStatementContext::getRuleIndex() const {
  return myParser::RuleReturnStatement;
}

void myParser::ReturnStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnStatement(this);
}

void myParser::ReturnStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnStatement(this);
}

myParser::ReturnStatementContext* myParser::returnStatement() {
  ReturnStatementContext *_localctx = _tracker.createInstance<ReturnStatementContext>(_ctx, getState());
  enterRule(_localctx, 50, myParser::RuleReturnStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(390);
    match(myParser::Return);
    setState(393);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
    case 1: {
      setState(391);

      if (!(this.notLineTerminator())) throw FailedPredicateException(this, "this.notLineTerminator()");
      setState(392);
      expressionSequence();
      break;
    }

    default:
      break;
    }
    setState(395);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- YieldStatementContext ------------------------------------------------------------------

myParser::YieldStatementContext::YieldStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::YieldStatementContext::Yield() {
  return getToken(myParser::Yield, 0);
}

myParser::EosContext* myParser::YieldStatementContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}

myParser::ExpressionSequenceContext* myParser::YieldStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}


size_t myParser::YieldStatementContext::getRuleIndex() const {
  return myParser::RuleYieldStatement;
}

void myParser::YieldStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterYieldStatement(this);
}

void myParser::YieldStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitYieldStatement(this);
}

myParser::YieldStatementContext* myParser::yieldStatement() {
  YieldStatementContext *_localctx = _tracker.createInstance<YieldStatementContext>(_ctx, getState());
  enterRule(_localctx, 52, myParser::RuleYieldStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(397);
    match(myParser::Yield);
    setState(400);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {
    case 1: {
      setState(398);

      if (!(this.notLineTerminator())) throw FailedPredicateException(this, "this.notLineTerminator()");
      setState(399);
      expressionSequence();
      break;
    }

    default:
      break;
    }
    setState(402);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WithStatementContext ------------------------------------------------------------------

myParser::WithStatementContext::WithStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::WithStatementContext::With() {
  return getToken(myParser::With, 0);
}

tree::TerminalNode* myParser::WithStatementContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

myParser::ExpressionSequenceContext* myParser::WithStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::WithStatementContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::StatementContext* myParser::WithStatementContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}


size_t myParser::WithStatementContext::getRuleIndex() const {
  return myParser::RuleWithStatement;
}

void myParser::WithStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWithStatement(this);
}

void myParser::WithStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWithStatement(this);
}

myParser::WithStatementContext* myParser::withStatement() {
  WithStatementContext *_localctx = _tracker.createInstance<WithStatementContext>(_ctx, getState());
  enterRule(_localctx, 54, myParser::RuleWithStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(404);
    match(myParser::With);
    setState(405);
    match(myParser::OpenParen);
    setState(406);
    expressionSequence();
    setState(407);
    match(myParser::CloseParen);
    setState(408);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SwitchStatementContext ------------------------------------------------------------------

myParser::SwitchStatementContext::SwitchStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::SwitchStatementContext::Switch() {
  return getToken(myParser::Switch, 0);
}

tree::TerminalNode* myParser::SwitchStatementContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

myParser::ExpressionSequenceContext* myParser::SwitchStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::SwitchStatementContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::CaseBlockContext* myParser::SwitchStatementContext::caseBlock() {
  return getRuleContext<myParser::CaseBlockContext>(0);
}


size_t myParser::SwitchStatementContext::getRuleIndex() const {
  return myParser::RuleSwitchStatement;
}

void myParser::SwitchStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitchStatement(this);
}

void myParser::SwitchStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitchStatement(this);
}

myParser::SwitchStatementContext* myParser::switchStatement() {
  SwitchStatementContext *_localctx = _tracker.createInstance<SwitchStatementContext>(_ctx, getState());
  enterRule(_localctx, 56, myParser::RuleSwitchStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(410);
    match(myParser::Switch);
    setState(411);
    match(myParser::OpenParen);
    setState(412);
    expressionSequence();
    setState(413);
    match(myParser::CloseParen);
    setState(414);
    caseBlock();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseBlockContext ------------------------------------------------------------------

myParser::CaseBlockContext::CaseBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::CaseBlockContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

tree::TerminalNode* myParser::CaseBlockContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

std::vector<myParser::CaseClausesContext *> myParser::CaseBlockContext::caseClauses() {
  return getRuleContexts<myParser::CaseClausesContext>();
}

myParser::CaseClausesContext* myParser::CaseBlockContext::caseClauses(size_t i) {
  return getRuleContext<myParser::CaseClausesContext>(i);
}

myParser::DefaultClauseContext* myParser::CaseBlockContext::defaultClause() {
  return getRuleContext<myParser::DefaultClauseContext>(0);
}


size_t myParser::CaseBlockContext::getRuleIndex() const {
  return myParser::RuleCaseBlock;
}

void myParser::CaseBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseBlock(this);
}

void myParser::CaseBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseBlock(this);
}

myParser::CaseBlockContext* myParser::caseBlock() {
  CaseBlockContext *_localctx = _tracker.createInstance<CaseBlockContext>(_ctx, getState());
  enterRule(_localctx, 58, myParser::RuleCaseBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(416);
    match(myParser::OpenBrace);
    setState(418);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Case) {
      setState(417);
      caseClauses();
    }
    setState(424);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Default) {
      setState(420);
      defaultClause();
      setState(422);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::Case) {
        setState(421);
        caseClauses();
      }
    }
    setState(426);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseClausesContext ------------------------------------------------------------------

myParser::CaseClausesContext::CaseClausesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::CaseClauseContext *> myParser::CaseClausesContext::caseClause() {
  return getRuleContexts<myParser::CaseClauseContext>();
}

myParser::CaseClauseContext* myParser::CaseClausesContext::caseClause(size_t i) {
  return getRuleContext<myParser::CaseClauseContext>(i);
}


size_t myParser::CaseClausesContext::getRuleIndex() const {
  return myParser::RuleCaseClauses;
}

void myParser::CaseClausesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseClauses(this);
}

void myParser::CaseClausesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseClauses(this);
}

myParser::CaseClausesContext* myParser::caseClauses() {
  CaseClausesContext *_localctx = _tracker.createInstance<CaseClausesContext>(_ctx, getState());
  enterRule(_localctx, 60, myParser::RuleCaseClauses);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(429); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(428);
      caseClause();
      setState(431); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == myParser::Case);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseClauseContext ------------------------------------------------------------------

myParser::CaseClauseContext::CaseClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::CaseClauseContext::Case() {
  return getToken(myParser::Case, 0);
}

myParser::ExpressionSequenceContext* myParser::CaseClauseContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::CaseClauseContext::Colon() {
  return getToken(myParser::Colon, 0);
}

myParser::StatementListContext* myParser::CaseClauseContext::statementList() {
  return getRuleContext<myParser::StatementListContext>(0);
}


size_t myParser::CaseClauseContext::getRuleIndex() const {
  return myParser::RuleCaseClause;
}

void myParser::CaseClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseClause(this);
}

void myParser::CaseClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseClause(this);
}

myParser::CaseClauseContext* myParser::caseClause() {
  CaseClauseContext *_localctx = _tracker.createInstance<CaseClauseContext>(_ctx, getState());
  enterRule(_localctx, 62, myParser::RuleCaseClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(433);
    match(myParser::Case);
    setState(434);
    expressionSequence();
    setState(435);
    match(myParser::Colon);
    setState(437);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx)) {
    case 1: {
      setState(436);
      statementList();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultClauseContext ------------------------------------------------------------------

myParser::DefaultClauseContext::DefaultClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::DefaultClauseContext::Default() {
  return getToken(myParser::Default, 0);
}

tree::TerminalNode* myParser::DefaultClauseContext::Colon() {
  return getToken(myParser::Colon, 0);
}

myParser::StatementListContext* myParser::DefaultClauseContext::statementList() {
  return getRuleContext<myParser::StatementListContext>(0);
}


size_t myParser::DefaultClauseContext::getRuleIndex() const {
  return myParser::RuleDefaultClause;
}

void myParser::DefaultClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultClause(this);
}

void myParser::DefaultClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultClause(this);
}

myParser::DefaultClauseContext* myParser::defaultClause() {
  DefaultClauseContext *_localctx = _tracker.createInstance<DefaultClauseContext>(_ctx, getState());
  enterRule(_localctx, 64, myParser::RuleDefaultClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(439);
    match(myParser::Default);
    setState(440);
    match(myParser::Colon);
    setState(442);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx)) {
    case 1: {
      setState(441);
      statementList();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelledStatementContext ------------------------------------------------------------------

myParser::LabelledStatementContext::LabelledStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::LabelledStatementContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

tree::TerminalNode* myParser::LabelledStatementContext::Colon() {
  return getToken(myParser::Colon, 0);
}

myParser::StatementContext* myParser::LabelledStatementContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}


size_t myParser::LabelledStatementContext::getRuleIndex() const {
  return myParser::RuleLabelledStatement;
}

void myParser::LabelledStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabelledStatement(this);
}

void myParser::LabelledStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabelledStatement(this);
}

myParser::LabelledStatementContext* myParser::labelledStatement() {
  LabelledStatementContext *_localctx = _tracker.createInstance<LabelledStatementContext>(_ctx, getState());
  enterRule(_localctx, 66, myParser::RuleLabelledStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(444);
    identifier();
    setState(445);
    match(myParser::Colon);
    setState(446);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThrowStatementContext ------------------------------------------------------------------

myParser::ThrowStatementContext::ThrowStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ThrowStatementContext::Throw() {
  return getToken(myParser::Throw, 0);
}

myParser::ExpressionSequenceContext* myParser::ThrowStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

myParser::EosContext* myParser::ThrowStatementContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}


size_t myParser::ThrowStatementContext::getRuleIndex() const {
  return myParser::RuleThrowStatement;
}

void myParser::ThrowStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrowStatement(this);
}

void myParser::ThrowStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrowStatement(this);
}

myParser::ThrowStatementContext* myParser::throwStatement() {
  ThrowStatementContext *_localctx = _tracker.createInstance<ThrowStatementContext>(_ctx, getState());
  enterRule(_localctx, 68, myParser::RuleThrowStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(448);
    match(myParser::Throw);
    setState(449);

    if (!(this.notLineTerminator())) throw FailedPredicateException(this, "this.notLineTerminator()");
    setState(450);
    expressionSequence();
    setState(451);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TryStatementContext ------------------------------------------------------------------

myParser::TryStatementContext::TryStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TryStatementContext::Try() {
  return getToken(myParser::Try, 0);
}

myParser::BlockContext* myParser::TryStatementContext::block() {
  return getRuleContext<myParser::BlockContext>(0);
}

myParser::CatchProductionContext* myParser::TryStatementContext::catchProduction() {
  return getRuleContext<myParser::CatchProductionContext>(0);
}

myParser::FinallyProductionContext* myParser::TryStatementContext::finallyProduction() {
  return getRuleContext<myParser::FinallyProductionContext>(0);
}


size_t myParser::TryStatementContext::getRuleIndex() const {
  return myParser::RuleTryStatement;
}

void myParser::TryStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTryStatement(this);
}

void myParser::TryStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTryStatement(this);
}

myParser::TryStatementContext* myParser::tryStatement() {
  TryStatementContext *_localctx = _tracker.createInstance<TryStatementContext>(_ctx, getState());
  enterRule(_localctx, 70, myParser::RuleTryStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(453);
    match(myParser::Try);
    setState(454);
    block();
    setState(460);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Catch: {
        setState(455);
        catchProduction();
        setState(457);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
        case 1: {
          setState(456);
          finallyProduction();
          break;
        }

        default:
          break;
        }
        break;
      }

      case myParser::Finally: {
        setState(459);
        finallyProduction();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CatchProductionContext ------------------------------------------------------------------

myParser::CatchProductionContext::CatchProductionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::CatchProductionContext::Catch() {
  return getToken(myParser::Catch, 0);
}

myParser::BlockContext* myParser::CatchProductionContext::block() {
  return getRuleContext<myParser::BlockContext>(0);
}

tree::TerminalNode* myParser::CatchProductionContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::CatchProductionContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::AssignableContext* myParser::CatchProductionContext::assignable() {
  return getRuleContext<myParser::AssignableContext>(0);
}


size_t myParser::CatchProductionContext::getRuleIndex() const {
  return myParser::RuleCatchProduction;
}

void myParser::CatchProductionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCatchProduction(this);
}

void myParser::CatchProductionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCatchProduction(this);
}

myParser::CatchProductionContext* myParser::catchProduction() {
  CatchProductionContext *_localctx = _tracker.createInstance<CatchProductionContext>(_ctx, getState());
  enterRule(_localctx, 72, myParser::RuleCatchProduction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(462);
    match(myParser::Catch);
    setState(468);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::OpenParen) {
      setState(463);
      match(myParser::OpenParen);
      setState(465);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::OpenBracket

      || _la == myParser::OpenBrace || ((((_la - 107) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 107)) & 4129) != 0)) {
        setState(464);
        assignable();
      }
      setState(467);
      match(myParser::CloseParen);
    }
    setState(470);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FinallyProductionContext ------------------------------------------------------------------

myParser::FinallyProductionContext::FinallyProductionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::FinallyProductionContext::Finally() {
  return getToken(myParser::Finally, 0);
}

myParser::BlockContext* myParser::FinallyProductionContext::block() {
  return getRuleContext<myParser::BlockContext>(0);
}


size_t myParser::FinallyProductionContext::getRuleIndex() const {
  return myParser::RuleFinallyProduction;
}

void myParser::FinallyProductionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFinallyProduction(this);
}

void myParser::FinallyProductionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFinallyProduction(this);
}

myParser::FinallyProductionContext* myParser::finallyProduction() {
  FinallyProductionContext *_localctx = _tracker.createInstance<FinallyProductionContext>(_ctx, getState());
  enterRule(_localctx, 74, myParser::RuleFinallyProduction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(472);
    match(myParser::Finally);
    setState(473);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DebuggerStatementContext ------------------------------------------------------------------

myParser::DebuggerStatementContext::DebuggerStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::DebuggerStatementContext::Debugger() {
  return getToken(myParser::Debugger, 0);
}

myParser::EosContext* myParser::DebuggerStatementContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}


size_t myParser::DebuggerStatementContext::getRuleIndex() const {
  return myParser::RuleDebuggerStatement;
}

void myParser::DebuggerStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDebuggerStatement(this);
}

void myParser::DebuggerStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDebuggerStatement(this);
}

myParser::DebuggerStatementContext* myParser::debuggerStatement() {
  DebuggerStatementContext *_localctx = _tracker.createInstance<DebuggerStatementContext>(_ctx, getState());
  enterRule(_localctx, 76, myParser::RuleDebuggerStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(475);
    match(myParser::Debugger);
    setState(476);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDeclarationContext ------------------------------------------------------------------

myParser::FunctionDeclarationContext::FunctionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::FunctionDeclarationContext::Function_() {
  return getToken(myParser::Function_, 0);
}

myParser::IdentifierContext* myParser::FunctionDeclarationContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

tree::TerminalNode* myParser::FunctionDeclarationContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::FunctionDeclarationContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::FunctionBodyContext* myParser::FunctionDeclarationContext::functionBody() {
  return getRuleContext<myParser::FunctionBodyContext>(0);
}

tree::TerminalNode* myParser::FunctionDeclarationContext::Async() {
  return getToken(myParser::Async, 0);
}

tree::TerminalNode* myParser::FunctionDeclarationContext::Multiply() {
  return getToken(myParser::Multiply, 0);
}

myParser::FormalParameterListContext* myParser::FunctionDeclarationContext::formalParameterList() {
  return getRuleContext<myParser::FormalParameterListContext>(0);
}


size_t myParser::FunctionDeclarationContext::getRuleIndex() const {
  return myParser::RuleFunctionDeclaration;
}

void myParser::FunctionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionDeclaration(this);
}

void myParser::FunctionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionDeclaration(this);
}

myParser::FunctionDeclarationContext* myParser::functionDeclaration() {
  FunctionDeclarationContext *_localctx = _tracker.createInstance<FunctionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 78, myParser::RuleFunctionDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(479);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Async) {
      setState(478);
      match(myParser::Async);
    }
    setState(481);
    match(myParser::Function_);
    setState(483);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Multiply) {
      setState(482);
      match(myParser::Multiply);
    }
    setState(485);
    identifier();
    setState(486);
    match(myParser::OpenParen);
    setState(488);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 262688) != 0) || ((((_la - 107) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 107)) & 4129) != 0)) {
      setState(487);
      formalParameterList();
    }
    setState(490);
    match(myParser::CloseParen);
    setState(491);
    functionBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassDeclarationContext ------------------------------------------------------------------

myParser::ClassDeclarationContext::ClassDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ClassDeclarationContext::Class() {
  return getToken(myParser::Class, 0);
}

myParser::IdentifierContext* myParser::ClassDeclarationContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::ClassTailContext* myParser::ClassDeclarationContext::classTail() {
  return getRuleContext<myParser::ClassTailContext>(0);
}


size_t myParser::ClassDeclarationContext::getRuleIndex() const {
  return myParser::RuleClassDeclaration;
}

void myParser::ClassDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassDeclaration(this);
}

void myParser::ClassDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassDeclaration(this);
}

myParser::ClassDeclarationContext* myParser::classDeclaration() {
  ClassDeclarationContext *_localctx = _tracker.createInstance<ClassDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 80, myParser::RuleClassDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(493);
    match(myParser::Class);
    setState(494);
    identifier();
    setState(495);
    classTail();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassTailContext ------------------------------------------------------------------

myParser::ClassTailContext::ClassTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ClassTailContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

tree::TerminalNode* myParser::ClassTailContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

tree::TerminalNode* myParser::ClassTailContext::Extends() {
  return getToken(myParser::Extends, 0);
}

myParser::SingleExpressionContext* myParser::ClassTailContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

std::vector<myParser::ClassElementContext *> myParser::ClassTailContext::classElement() {
  return getRuleContexts<myParser::ClassElementContext>();
}

myParser::ClassElementContext* myParser::ClassTailContext::classElement(size_t i) {
  return getRuleContext<myParser::ClassElementContext>(i);
}


size_t myParser::ClassTailContext::getRuleIndex() const {
  return myParser::RuleClassTail;
}

void myParser::ClassTailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassTail(this);
}

void myParser::ClassTailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassTail(this);
}

myParser::ClassTailContext* myParser::classTail() {
  ClassTailContext *_localctx = _tracker.createInstance<ClassTailContext>(_ctx, getState());
  enterRule(_localctx, 82, myParser::RuleClassTail);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(499);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Extends) {
      setState(497);
      match(myParser::Extends);
      setState(498);
      singleExpression(0);
    }
    setState(501);
    match(myParser::OpenBrace);
    setState(505);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(502);
        classElement(); 
      }
      setState(507);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx);
    }
    setState(508);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassElementContext ------------------------------------------------------------------

myParser::ClassElementContext::ClassElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::MethodDefinitionContext* myParser::ClassElementContext::methodDefinition() {
  return getRuleContext<myParser::MethodDefinitionContext>(0);
}

myParser::AssignableContext* myParser::ClassElementContext::assignable() {
  return getRuleContext<myParser::AssignableContext>(0);
}

tree::TerminalNode* myParser::ClassElementContext::Assign() {
  return getToken(myParser::Assign, 0);
}

myParser::ObjectLiteralContext* myParser::ClassElementContext::objectLiteral() {
  return getRuleContext<myParser::ObjectLiteralContext>(0);
}

tree::TerminalNode* myParser::ClassElementContext::SemiColon() {
  return getToken(myParser::SemiColon, 0);
}

std::vector<tree::TerminalNode *> myParser::ClassElementContext::Static() {
  return getTokens(myParser::Static);
}

tree::TerminalNode* myParser::ClassElementContext::Static(size_t i) {
  return getToken(myParser::Static, i);
}

std::vector<myParser::IdentifierContext *> myParser::ClassElementContext::identifier() {
  return getRuleContexts<myParser::IdentifierContext>();
}

myParser::IdentifierContext* myParser::ClassElementContext::identifier(size_t i) {
  return getRuleContext<myParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> myParser::ClassElementContext::Async() {
  return getTokens(myParser::Async);
}

tree::TerminalNode* myParser::ClassElementContext::Async(size_t i) {
  return getToken(myParser::Async, i);
}

myParser::EmptyStatement_Context* myParser::ClassElementContext::emptyStatement_() {
  return getRuleContext<myParser::EmptyStatement_Context>(0);
}

myParser::PropertyNameContext* myParser::ClassElementContext::propertyName() {
  return getRuleContext<myParser::PropertyNameContext>(0);
}

myParser::SingleExpressionContext* myParser::ClassElementContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::ClassElementContext::Hashtag() {
  return getToken(myParser::Hashtag, 0);
}


size_t myParser::ClassElementContext::getRuleIndex() const {
  return myParser::RuleClassElement;
}

void myParser::ClassElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassElement(this);
}

void myParser::ClassElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassElement(this);
}

myParser::ClassElementContext* myParser::classElement() {
  ClassElementContext *_localctx = _tracker.createInstance<ClassElementContext>(_ctx, getState());
  enterRule(_localctx, 84, myParser::RuleClassElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(535);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(516);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(514);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
          case 1: {
            setState(510);
            match(myParser::Static);
            break;
          }

          case 2: {
            setState(511);

            if (!(this.n("static"))) throw FailedPredicateException(this, "this.n(\"static\")");
            setState(512);
            identifier();
            break;
          }

          case 3: {
            setState(513);
            match(myParser::Async);
            break;
          }

          default:
            break;
          } 
        }
        setState(518);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx);
      }
      setState(525);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
      case 1: {
        setState(519);
        methodDefinition();
        break;
      }

      case 2: {
        setState(520);
        assignable();
        setState(521);
        match(myParser::Assign);
        setState(522);
        objectLiteral();
        setState(523);
        match(myParser::SemiColon);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(527);
      emptyStatement_();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(529);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::Hashtag) {
        setState(528);
        match(myParser::Hashtag);
      }
      setState(531);
      propertyName();
      setState(532);
      match(myParser::Assign);
      setState(533);
      singleExpression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MethodDefinitionContext ------------------------------------------------------------------

myParser::MethodDefinitionContext::MethodDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::PropertyNameContext* myParser::MethodDefinitionContext::propertyName() {
  return getRuleContext<myParser::PropertyNameContext>(0);
}

tree::TerminalNode* myParser::MethodDefinitionContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::MethodDefinitionContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::FunctionBodyContext* myParser::MethodDefinitionContext::functionBody() {
  return getRuleContext<myParser::FunctionBodyContext>(0);
}

tree::TerminalNode* myParser::MethodDefinitionContext::Multiply() {
  return getToken(myParser::Multiply, 0);
}

tree::TerminalNode* myParser::MethodDefinitionContext::Hashtag() {
  return getToken(myParser::Hashtag, 0);
}

myParser::FormalParameterListContext* myParser::MethodDefinitionContext::formalParameterList() {
  return getRuleContext<myParser::FormalParameterListContext>(0);
}

myParser::GetterContext* myParser::MethodDefinitionContext::getter() {
  return getRuleContext<myParser::GetterContext>(0);
}

myParser::SetterContext* myParser::MethodDefinitionContext::setter() {
  return getRuleContext<myParser::SetterContext>(0);
}


size_t myParser::MethodDefinitionContext::getRuleIndex() const {
  return myParser::RuleMethodDefinition;
}

void myParser::MethodDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMethodDefinition(this);
}

void myParser::MethodDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMethodDefinition(this);
}

myParser::MethodDefinitionContext* myParser::methodDefinition() {
  MethodDefinitionContext *_localctx = _tracker.createInstance<MethodDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 86, myParser::RuleMethodDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(576);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(538);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::Multiply) {
        setState(537);
        match(myParser::Multiply);
      }
      setState(541);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::Hashtag) {
        setState(540);
        match(myParser::Hashtag);
      }
      setState(543);
      propertyName();
      setState(544);
      match(myParser::OpenParen);
      setState(546);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 262688) != 0) || ((((_la - 107) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 107)) & 4129) != 0)) {
        setState(545);
        formalParameterList();
      }
      setState(548);
      match(myParser::CloseParen);
      setState(549);
      functionBody();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(552);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
      case 1: {
        setState(551);
        match(myParser::Multiply);
        break;
      }

      default:
        break;
      }
      setState(555);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
      case 1: {
        setState(554);
        match(myParser::Hashtag);
        break;
      }

      default:
        break;
      }
      setState(557);
      getter();
      setState(558);
      match(myParser::OpenParen);
      setState(559);
      match(myParser::CloseParen);
      setState(560);
      functionBody();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(563);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
      case 1: {
        setState(562);
        match(myParser::Multiply);
        break;
      }

      default:
        break;
      }
      setState(566);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {
      case 1: {
        setState(565);
        match(myParser::Hashtag);
        break;
      }

      default:
        break;
      }
      setState(568);
      setter();
      setState(569);
      match(myParser::OpenParen);
      setState(571);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 262688) != 0) || ((((_la - 107) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 107)) & 4129) != 0)) {
        setState(570);
        formalParameterList();
      }
      setState(573);
      match(myParser::CloseParen);
      setState(574);
      functionBody();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FormalParameterListContext ------------------------------------------------------------------

myParser::FormalParameterListContext::FormalParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::FormalParameterArgContext *> myParser::FormalParameterListContext::formalParameterArg() {
  return getRuleContexts<myParser::FormalParameterArgContext>();
}

myParser::FormalParameterArgContext* myParser::FormalParameterListContext::formalParameterArg(size_t i) {
  return getRuleContext<myParser::FormalParameterArgContext>(i);
}

std::vector<tree::TerminalNode *> myParser::FormalParameterListContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::FormalParameterListContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}

myParser::LastFormalParameterArgContext* myParser::FormalParameterListContext::lastFormalParameterArg() {
  return getRuleContext<myParser::LastFormalParameterArgContext>(0);
}


size_t myParser::FormalParameterListContext::getRuleIndex() const {
  return myParser::RuleFormalParameterList;
}

void myParser::FormalParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFormalParameterList(this);
}

void myParser::FormalParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFormalParameterList(this);
}

myParser::FormalParameterListContext* myParser::formalParameterList() {
  FormalParameterListContext *_localctx = _tracker.createInstance<FormalParameterListContext>(_ctx, getState());
  enterRule(_localctx, 88, myParser::RuleFormalParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(591);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::OpenBracket:
      case myParser::OpenBrace:
      case myParser::Async:
      case myParser::NonStrictLet:
      case myParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(578);
        formalParameterArg();
        setState(583);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(579);
            match(myParser::Comma);
            setState(580);
            formalParameterArg(); 
          }
          setState(585);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx);
        }
        setState(588);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::Comma) {
          setState(586);
          match(myParser::Comma);
          setState(587);
          lastFormalParameterArg();
        }
        break;
      }

      case myParser::Ellipsis: {
        enterOuterAlt(_localctx, 2);
        setState(590);
        lastFormalParameterArg();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FormalParameterArgContext ------------------------------------------------------------------

myParser::FormalParameterArgContext::FormalParameterArgContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::AssignableContext* myParser::FormalParameterArgContext::assignable() {
  return getRuleContext<myParser::AssignableContext>(0);
}

tree::TerminalNode* myParser::FormalParameterArgContext::Assign() {
  return getToken(myParser::Assign, 0);
}

myParser::SingleExpressionContext* myParser::FormalParameterArgContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}


size_t myParser::FormalParameterArgContext::getRuleIndex() const {
  return myParser::RuleFormalParameterArg;
}

void myParser::FormalParameterArgContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFormalParameterArg(this);
}

void myParser::FormalParameterArgContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFormalParameterArg(this);
}

myParser::FormalParameterArgContext* myParser::formalParameterArg() {
  FormalParameterArgContext *_localctx = _tracker.createInstance<FormalParameterArgContext>(_ctx, getState());
  enterRule(_localctx, 90, myParser::RuleFormalParameterArg);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(593);
    assignable();
    setState(596);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Assign) {
      setState(594);
      match(myParser::Assign);
      setState(595);
      singleExpression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LastFormalParameterArgContext ------------------------------------------------------------------

myParser::LastFormalParameterArgContext::LastFormalParameterArgContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::LastFormalParameterArgContext::Ellipsis() {
  return getToken(myParser::Ellipsis, 0);
}

myParser::SingleExpressionContext* myParser::LastFormalParameterArgContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}


size_t myParser::LastFormalParameterArgContext::getRuleIndex() const {
  return myParser::RuleLastFormalParameterArg;
}

void myParser::LastFormalParameterArgContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLastFormalParameterArg(this);
}

void myParser::LastFormalParameterArgContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLastFormalParameterArg(this);
}

myParser::LastFormalParameterArgContext* myParser::lastFormalParameterArg() {
  LastFormalParameterArgContext *_localctx = _tracker.createInstance<LastFormalParameterArgContext>(_ctx, getState());
  enterRule(_localctx, 92, myParser::RuleLastFormalParameterArg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(598);
    match(myParser::Ellipsis);
    setState(599);
    singleExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionBodyContext ------------------------------------------------------------------

myParser::FunctionBodyContext::FunctionBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::FunctionBodyContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

tree::TerminalNode* myParser::FunctionBodyContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

myParser::SourceElementsContext* myParser::FunctionBodyContext::sourceElements() {
  return getRuleContext<myParser::SourceElementsContext>(0);
}


size_t myParser::FunctionBodyContext::getRuleIndex() const {
  return myParser::RuleFunctionBody;
}

void myParser::FunctionBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionBody(this);
}

void myParser::FunctionBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionBody(this);
}

myParser::FunctionBodyContext* myParser::functionBody() {
  FunctionBodyContext *_localctx = _tracker.createInstance<FunctionBodyContext>(_ctx, getState());
  enterRule(_localctx, 94, myParser::RuleFunctionBody);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(601);
    match(myParser::OpenBrace);
    setState(603);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx)) {
    case 1: {
      setState(602);
      sourceElements();
      break;
    }

    default:
      break;
    }
    setState(605);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SourceElementsContext ------------------------------------------------------------------

myParser::SourceElementsContext::SourceElementsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::SourceElementContext *> myParser::SourceElementsContext::sourceElement() {
  return getRuleContexts<myParser::SourceElementContext>();
}

myParser::SourceElementContext* myParser::SourceElementsContext::sourceElement(size_t i) {
  return getRuleContext<myParser::SourceElementContext>(i);
}


size_t myParser::SourceElementsContext::getRuleIndex() const {
  return myParser::RuleSourceElements;
}

void myParser::SourceElementsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSourceElements(this);
}

void myParser::SourceElementsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSourceElements(this);
}

myParser::SourceElementsContext* myParser::sourceElements() {
  SourceElementsContext *_localctx = _tracker.createInstance<SourceElementsContext>(_ctx, getState());
  enterRule(_localctx, 96, myParser::RuleSourceElements);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(608); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(607);
              sourceElement();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(610); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 68, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayLiteralContext ------------------------------------------------------------------

myParser::ArrayLiteralContext::ArrayLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ArrayLiteralContext::OpenBracket() {
  return getToken(myParser::OpenBracket, 0);
}

myParser::ElementListContext* myParser::ArrayLiteralContext::elementList() {
  return getRuleContext<myParser::ElementListContext>(0);
}

tree::TerminalNode* myParser::ArrayLiteralContext::CloseBracket() {
  return getToken(myParser::CloseBracket, 0);
}


size_t myParser::ArrayLiteralContext::getRuleIndex() const {
  return myParser::RuleArrayLiteral;
}

void myParser::ArrayLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayLiteral(this);
}

void myParser::ArrayLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayLiteral(this);
}

myParser::ArrayLiteralContext* myParser::arrayLiteral() {
  ArrayLiteralContext *_localctx = _tracker.createInstance<ArrayLiteralContext>(_ctx, getState());
  enterRule(_localctx, 98, myParser::RuleArrayLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(612);
    match(myParser::OpenBracket);
    setState(613);
    elementList();
    setState(614);
    match(myParser::CloseBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementListContext ------------------------------------------------------------------

myParser::ElementListContext::ElementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> myParser::ElementListContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::ElementListContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}

std::vector<myParser::ArrayElementContext *> myParser::ElementListContext::arrayElement() {
  return getRuleContexts<myParser::ArrayElementContext>();
}

myParser::ArrayElementContext* myParser::ElementListContext::arrayElement(size_t i) {
  return getRuleContext<myParser::ArrayElementContext>(i);
}


size_t myParser::ElementListContext::getRuleIndex() const {
  return myParser::RuleElementList;
}

void myParser::ElementListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElementList(this);
}

void myParser::ElementListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElementList(this);
}

myParser::ElementListContext* myParser::elementList() {
  ElementListContext *_localctx = _tracker.createInstance<ElementListContext>(_ctx, getState());
  enterRule(_localctx, 100, myParser::RuleElementList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(619);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(616);
        match(myParser::Comma); 
      }
      setState(621);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx);
    }
    setState(623);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -2305843009147370832) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 252549645531105535) != 0)) {
      setState(622);
      arrayElement();
    }
    setState(633);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(626); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(625);
          match(myParser::Comma);
          setState(628); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == myParser::Comma);
        setState(630);
        arrayElement(); 
      }
      setState(635);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx);
    }
    setState(639);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::Comma) {
      setState(636);
      match(myParser::Comma);
      setState(641);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayElementContext ------------------------------------------------------------------

myParser::ArrayElementContext::ArrayElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SingleExpressionContext* myParser::ArrayElementContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::ArrayElementContext::Ellipsis() {
  return getToken(myParser::Ellipsis, 0);
}


size_t myParser::ArrayElementContext::getRuleIndex() const {
  return myParser::RuleArrayElement;
}

void myParser::ArrayElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayElement(this);
}

void myParser::ArrayElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayElement(this);
}

myParser::ArrayElementContext* myParser::arrayElement() {
  ArrayElementContext *_localctx = _tracker.createInstance<ArrayElementContext>(_ctx, getState());
  enterRule(_localctx, 102, myParser::RuleArrayElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(643);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Ellipsis) {
      setState(642);
      match(myParser::Ellipsis);
    }
    setState(645);
    singleExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyAssignmentContext ------------------------------------------------------------------

myParser::PropertyAssignmentContext::PropertyAssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t myParser::PropertyAssignmentContext::getRuleIndex() const {
  return myParser::RulePropertyAssignment;
}

void myParser::PropertyAssignmentContext::copyFrom(PropertyAssignmentContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PropertyExpressionAssignmentContext ------------------------------------------------------------------

myParser::PropertyNameContext* myParser::PropertyExpressionAssignmentContext::propertyName() {
  return getRuleContext<myParser::PropertyNameContext>(0);
}

tree::TerminalNode* myParser::PropertyExpressionAssignmentContext::Colon() {
  return getToken(myParser::Colon, 0);
}

myParser::SingleExpressionContext* myParser::PropertyExpressionAssignmentContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::PropertyExpressionAssignmentContext::PropertyExpressionAssignmentContext(PropertyAssignmentContext *ctx) { copyFrom(ctx); }

void myParser::PropertyExpressionAssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyExpressionAssignment(this);
}
void myParser::PropertyExpressionAssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyExpressionAssignment(this);
}
//----------------- ComputedPropertyExpressionAssignmentContext ------------------------------------------------------------------

tree::TerminalNode* myParser::ComputedPropertyExpressionAssignmentContext::OpenBracket() {
  return getToken(myParser::OpenBracket, 0);
}

std::vector<myParser::SingleExpressionContext *> myParser::ComputedPropertyExpressionAssignmentContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::ComputedPropertyExpressionAssignmentContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::ComputedPropertyExpressionAssignmentContext::CloseBracket() {
  return getToken(myParser::CloseBracket, 0);
}

tree::TerminalNode* myParser::ComputedPropertyExpressionAssignmentContext::Colon() {
  return getToken(myParser::Colon, 0);
}

myParser::ComputedPropertyExpressionAssignmentContext::ComputedPropertyExpressionAssignmentContext(PropertyAssignmentContext *ctx) { copyFrom(ctx); }

void myParser::ComputedPropertyExpressionAssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComputedPropertyExpressionAssignment(this);
}
void myParser::ComputedPropertyExpressionAssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComputedPropertyExpressionAssignment(this);
}
//----------------- PropertyShorthandContext ------------------------------------------------------------------

myParser::SingleExpressionContext* myParser::PropertyShorthandContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::PropertyShorthandContext::Ellipsis() {
  return getToken(myParser::Ellipsis, 0);
}

myParser::PropertyShorthandContext::PropertyShorthandContext(PropertyAssignmentContext *ctx) { copyFrom(ctx); }

void myParser::PropertyShorthandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyShorthand(this);
}
void myParser::PropertyShorthandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyShorthand(this);
}
//----------------- PropertySetterContext ------------------------------------------------------------------

myParser::SetterContext* myParser::PropertySetterContext::setter() {
  return getRuleContext<myParser::SetterContext>(0);
}

tree::TerminalNode* myParser::PropertySetterContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

myParser::FormalParameterArgContext* myParser::PropertySetterContext::formalParameterArg() {
  return getRuleContext<myParser::FormalParameterArgContext>(0);
}

tree::TerminalNode* myParser::PropertySetterContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::FunctionBodyContext* myParser::PropertySetterContext::functionBody() {
  return getRuleContext<myParser::FunctionBodyContext>(0);
}

myParser::PropertySetterContext::PropertySetterContext(PropertyAssignmentContext *ctx) { copyFrom(ctx); }

void myParser::PropertySetterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertySetter(this);
}
void myParser::PropertySetterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertySetter(this);
}
//----------------- PropertyGetterContext ------------------------------------------------------------------

myParser::GetterContext* myParser::PropertyGetterContext::getter() {
  return getRuleContext<myParser::GetterContext>(0);
}

tree::TerminalNode* myParser::PropertyGetterContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::PropertyGetterContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::FunctionBodyContext* myParser::PropertyGetterContext::functionBody() {
  return getRuleContext<myParser::FunctionBodyContext>(0);
}

myParser::PropertyGetterContext::PropertyGetterContext(PropertyAssignmentContext *ctx) { copyFrom(ctx); }

void myParser::PropertyGetterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyGetter(this);
}
void myParser::PropertyGetterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyGetter(this);
}
//----------------- FunctionPropertyContext ------------------------------------------------------------------

myParser::PropertyNameContext* myParser::FunctionPropertyContext::propertyName() {
  return getRuleContext<myParser::PropertyNameContext>(0);
}

tree::TerminalNode* myParser::FunctionPropertyContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::FunctionPropertyContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::FunctionBodyContext* myParser::FunctionPropertyContext::functionBody() {
  return getRuleContext<myParser::FunctionBodyContext>(0);
}

tree::TerminalNode* myParser::FunctionPropertyContext::Async() {
  return getToken(myParser::Async, 0);
}

tree::TerminalNode* myParser::FunctionPropertyContext::Multiply() {
  return getToken(myParser::Multiply, 0);
}

myParser::FormalParameterListContext* myParser::FunctionPropertyContext::formalParameterList() {
  return getRuleContext<myParser::FormalParameterListContext>(0);
}

myParser::FunctionPropertyContext::FunctionPropertyContext(PropertyAssignmentContext *ctx) { copyFrom(ctx); }

void myParser::FunctionPropertyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionProperty(this);
}
void myParser::FunctionPropertyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionProperty(this);
}
myParser::PropertyAssignmentContext* myParser::propertyAssignment() {
  PropertyAssignmentContext *_localctx = _tracker.createInstance<PropertyAssignmentContext>(_ctx, getState());
  enterRule(_localctx, 104, myParser::RulePropertyAssignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(686);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<myParser::PropertyExpressionAssignmentContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(647);
      propertyName();
      setState(648);
      match(myParser::Colon);
      setState(649);
      singleExpression(0);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<myParser::ComputedPropertyExpressionAssignmentContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(651);
      match(myParser::OpenBracket);
      setState(652);
      singleExpression(0);
      setState(653);
      match(myParser::CloseBracket);
      setState(654);
      match(myParser::Colon);
      setState(655);
      singleExpression(0);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<myParser::FunctionPropertyContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(658);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
      case 1: {
        setState(657);
        match(myParser::Async);
        break;
      }

      default:
        break;
      }
      setState(661);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::Multiply) {
        setState(660);
        match(myParser::Multiply);
      }
      setState(663);
      propertyName();
      setState(664);
      match(myParser::OpenParen);
      setState(666);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 262688) != 0) || ((((_la - 107) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 107)) & 4129) != 0)) {
        setState(665);
        formalParameterList();
      }
      setState(668);
      match(myParser::CloseParen);
      setState(669);
      functionBody();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<myParser::PropertyGetterContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(671);
      getter();
      setState(672);
      match(myParser::OpenParen);
      setState(673);
      match(myParser::CloseParen);
      setState(674);
      functionBody();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<myParser::PropertySetterContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(676);
      setter();
      setState(677);
      match(myParser::OpenParen);
      setState(678);
      formalParameterArg();
      setState(679);
      match(myParser::CloseParen);
      setState(680);
      functionBody();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<myParser::PropertyShorthandContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(683);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::Ellipsis) {
        setState(682);
        match(myParser::Ellipsis);
      }
      setState(685);
      singleExpression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyNameContext ------------------------------------------------------------------

myParser::PropertyNameContext::PropertyNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierNameContext* myParser::PropertyNameContext::identifierName() {
  return getRuleContext<myParser::IdentifierNameContext>(0);
}

tree::TerminalNode* myParser::PropertyNameContext::StringLiteral() {
  return getToken(myParser::StringLiteral, 0);
}

myParser::NumericLiteralContext* myParser::PropertyNameContext::numericLiteral() {
  return getRuleContext<myParser::NumericLiteralContext>(0);
}

tree::TerminalNode* myParser::PropertyNameContext::OpenBracket() {
  return getToken(myParser::OpenBracket, 0);
}

myParser::SingleExpressionContext* myParser::PropertyNameContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::PropertyNameContext::CloseBracket() {
  return getToken(myParser::CloseBracket, 0);
}


size_t myParser::PropertyNameContext::getRuleIndex() const {
  return myParser::RulePropertyName;
}

void myParser::PropertyNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyName(this);
}

void myParser::PropertyNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyName(this);
}

myParser::PropertyNameContext* myParser::propertyName() {
  PropertyNameContext *_localctx = _tracker.createInstance<PropertyNameContext>(_ctx, getState());
  enterRule(_localctx, 106, myParser::RulePropertyName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(695);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::NullLiteral:
      case myParser::BooleanLiteral:
      case myParser::Break:
      case myParser::Do:
      case myParser::Instanceof:
      case myParser::Typeof:
      case myParser::Case:
      case myParser::Else:
      case myParser::New:
      case myParser::Var:
      case myParser::Catch:
      case myParser::Finally:
      case myParser::Return:
      case myParser::Void:
      case myParser::Continue:
      case myParser::For:
      case myParser::Switch:
      case myParser::While:
      case myParser::Debugger:
      case myParser::Function_:
      case myParser::This:
      case myParser::With:
      case myParser::Default:
      case myParser::If:
      case myParser::Throw:
      case myParser::Delete:
      case myParser::In:
      case myParser::Try:
      case myParser::As:
      case myParser::From:
      case myParser::Class:
      case myParser::Enum:
      case myParser::Extends:
      case myParser::Super:
      case myParser::Const:
      case myParser::Export:
      case myParser::Import:
      case myParser::Async:
      case myParser::Await:
      case myParser::Yield:
      case myParser::Implements:
      case myParser::StrictLet:
      case myParser::NonStrictLet:
      case myParser::Private:
      case myParser::Public:
      case myParser::Interface:
      case myParser::Package:
      case myParser::Protected:
      case myParser::Static:
      case myParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(688);
        identifierName();
        break;
      }

      case myParser::StringLiteral: {
        enterOuterAlt(_localctx, 2);
        setState(689);
        match(myParser::StringLiteral);
        break;
      }

      case myParser::DecimalLiteral:
      case myParser::HexIntegerLiteral:
      case myParser::OctalIntegerLiteral:
      case myParser::OctalIntegerLiteral2:
      case myParser::BinaryIntegerLiteral: {
        enterOuterAlt(_localctx, 3);
        setState(690);
        numericLiteral();
        break;
      }

      case myParser::OpenBracket: {
        enterOuterAlt(_localctx, 4);
        setState(691);
        match(myParser::OpenBracket);
        setState(692);
        singleExpression(0);
        setState(693);
        match(myParser::CloseBracket);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentsContext ------------------------------------------------------------------

myParser::ArgumentsContext::ArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ArgumentsContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::ArgumentsContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

std::vector<myParser::ArgumentContext *> myParser::ArgumentsContext::argument() {
  return getRuleContexts<myParser::ArgumentContext>();
}

myParser::ArgumentContext* myParser::ArgumentsContext::argument(size_t i) {
  return getRuleContext<myParser::ArgumentContext>(i);
}

std::vector<tree::TerminalNode *> myParser::ArgumentsContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::ArgumentsContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::ArgumentsContext::getRuleIndex() const {
  return myParser::RuleArguments;
}

void myParser::ArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArguments(this);
}

void myParser::ArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArguments(this);
}

myParser::ArgumentsContext* myParser::arguments() {
  ArgumentsContext *_localctx = _tracker.createInstance<ArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 108, myParser::RuleArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(697);
    match(myParser::OpenParen);
    setState(709);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -2305843009147370832) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 252549645531105535) != 0)) {
      setState(698);
      argument();
      setState(703);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(699);
          match(myParser::Comma);
          setState(700);
          argument(); 
        }
        setState(705);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx);
      }
      setState(707);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::Comma) {
        setState(706);
        match(myParser::Comma);
      }
    }
    setState(711);
    match(myParser::CloseParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentContext ------------------------------------------------------------------

myParser::ArgumentContext::ArgumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SingleExpressionContext* myParser::ArgumentContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::IdentifierContext* myParser::ArgumentContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

tree::TerminalNode* myParser::ArgumentContext::Ellipsis() {
  return getToken(myParser::Ellipsis, 0);
}


size_t myParser::ArgumentContext::getRuleIndex() const {
  return myParser::RuleArgument;
}

void myParser::ArgumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgument(this);
}

void myParser::ArgumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgument(this);
}

myParser::ArgumentContext* myParser::argument() {
  ArgumentContext *_localctx = _tracker.createInstance<ArgumentContext>(_ctx, getState());
  enterRule(_localctx, 110, myParser::RuleArgument);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(714);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Ellipsis) {
      setState(713);
      match(myParser::Ellipsis);
    }
    setState(718);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx)) {
    case 1: {
      setState(716);
      singleExpression(0);
      break;
    }

    case 2: {
      setState(717);
      identifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionSequenceContext ------------------------------------------------------------------

myParser::ExpressionSequenceContext::ExpressionSequenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::SingleExpressionContext *> myParser::ExpressionSequenceContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::ExpressionSequenceContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

std::vector<tree::TerminalNode *> myParser::ExpressionSequenceContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::ExpressionSequenceContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::ExpressionSequenceContext::getRuleIndex() const {
  return myParser::RuleExpressionSequence;
}

void myParser::ExpressionSequenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionSequence(this);
}

void myParser::ExpressionSequenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionSequence(this);
}

myParser::ExpressionSequenceContext* myParser::expressionSequence() {
  ExpressionSequenceContext *_localctx = _tracker.createInstance<ExpressionSequenceContext>(_ctx, getState());
  enterRule(_localctx, 112, myParser::RuleExpressionSequence);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(720);
    singleExpression(0);
    setState(725);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(721);
        match(myParser::Comma);
        setState(722);
        singleExpression(0); 
      }
      setState(727);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SingleExpressionContext ------------------------------------------------------------------

myParser::SingleExpressionContext::SingleExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t myParser::SingleExpressionContext::getRuleIndex() const {
  return myParser::RuleSingleExpression;
}

void myParser::SingleExpressionContext::copyFrom(SingleExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- TemplateStringExpressionContext ------------------------------------------------------------------

myParser::SingleExpressionContext* myParser::TemplateStringExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::TemplateStringLiteralContext* myParser::TemplateStringExpressionContext::templateStringLiteral() {
  return getRuleContext<myParser::TemplateStringLiteralContext>(0);
}

myParser::TemplateStringExpressionContext::TemplateStringExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::TemplateStringExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemplateStringExpression(this);
}
void myParser::TemplateStringExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemplateStringExpression(this);
}
//----------------- TernaryExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::TernaryExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::TernaryExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::TernaryExpressionContext::QuestionMark() {
  return getToken(myParser::QuestionMark, 0);
}

tree::TerminalNode* myParser::TernaryExpressionContext::Colon() {
  return getToken(myParser::Colon, 0);
}

myParser::TernaryExpressionContext::TernaryExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::TernaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTernaryExpression(this);
}
void myParser::TernaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTernaryExpression(this);
}
//----------------- LogicalAndExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::LogicalAndExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::LogicalAndExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::LogicalAndExpressionContext::And() {
  return getToken(myParser::And, 0);
}

myParser::LogicalAndExpressionContext::LogicalAndExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::LogicalAndExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalAndExpression(this);
}
void myParser::LogicalAndExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalAndExpression(this);
}
//----------------- PowerExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::PowerExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::PowerExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::PowerExpressionContext::Power() {
  return getToken(myParser::Power, 0);
}

myParser::PowerExpressionContext::PowerExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::PowerExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPowerExpression(this);
}
void myParser::PowerExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPowerExpression(this);
}
//----------------- PreIncrementExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::PreIncrementExpressionContext::PlusPlus() {
  return getToken(myParser::PlusPlus, 0);
}

myParser::SingleExpressionContext* myParser::PreIncrementExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::PreIncrementExpressionContext::PreIncrementExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::PreIncrementExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreIncrementExpression(this);
}
void myParser::PreIncrementExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreIncrementExpression(this);
}
//----------------- ObjectLiteralExpressionContext ------------------------------------------------------------------

myParser::ObjectLiteralContext* myParser::ObjectLiteralExpressionContext::objectLiteral() {
  return getRuleContext<myParser::ObjectLiteralContext>(0);
}

myParser::ObjectLiteralExpressionContext::ObjectLiteralExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::ObjectLiteralExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectLiteralExpression(this);
}
void myParser::ObjectLiteralExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectLiteralExpression(this);
}
//----------------- MetaExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::MetaExpressionContext::New() {
  return getToken(myParser::New, 0);
}

tree::TerminalNode* myParser::MetaExpressionContext::Dot() {
  return getToken(myParser::Dot, 0);
}

myParser::IdentifierContext* myParser::MetaExpressionContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::MetaExpressionContext::MetaExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::MetaExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMetaExpression(this);
}
void myParser::MetaExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMetaExpression(this);
}
//----------------- InExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::InExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::InExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::InExpressionContext::In() {
  return getToken(myParser::In, 0);
}

myParser::InExpressionContext::InExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::InExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInExpression(this);
}
void myParser::InExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInExpression(this);
}
//----------------- LogicalOrExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::LogicalOrExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::LogicalOrExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::LogicalOrExpressionContext::Or() {
  return getToken(myParser::Or, 0);
}

myParser::LogicalOrExpressionContext::LogicalOrExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::LogicalOrExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalOrExpression(this);
}
void myParser::LogicalOrExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalOrExpression(this);
}
//----------------- OptionalChainExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::OptionalChainExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::OptionalChainExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::OptionalChainExpressionContext::QuestionMarkDot() {
  return getToken(myParser::QuestionMarkDot, 0);
}

myParser::OptionalChainExpressionContext::OptionalChainExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::OptionalChainExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionalChainExpression(this);
}
void myParser::OptionalChainExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionalChainExpression(this);
}
//----------------- NotExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::NotExpressionContext::Not() {
  return getToken(myParser::Not, 0);
}

myParser::SingleExpressionContext* myParser::NotExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::NotExpressionContext::NotExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::NotExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNotExpression(this);
}
void myParser::NotExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNotExpression(this);
}
//----------------- PreDecreaseExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::PreDecreaseExpressionContext::MinusMinus() {
  return getToken(myParser::MinusMinus, 0);
}

myParser::SingleExpressionContext* myParser::PreDecreaseExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::PreDecreaseExpressionContext::PreDecreaseExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::PreDecreaseExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreDecreaseExpression(this);
}
void myParser::PreDecreaseExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreDecreaseExpression(this);
}
//----------------- ArgumentsExpressionContext ------------------------------------------------------------------

myParser::SingleExpressionContext* myParser::ArgumentsExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::ArgumentsContext* myParser::ArgumentsExpressionContext::arguments() {
  return getRuleContext<myParser::ArgumentsContext>(0);
}

myParser::ArgumentsExpressionContext::ArgumentsExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::ArgumentsExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgumentsExpression(this);
}
void myParser::ArgumentsExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgumentsExpression(this);
}
//----------------- AwaitExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::AwaitExpressionContext::Await() {
  return getToken(myParser::Await, 0);
}

myParser::SingleExpressionContext* myParser::AwaitExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::AwaitExpressionContext::AwaitExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::AwaitExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAwaitExpression(this);
}
void myParser::AwaitExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAwaitExpression(this);
}
//----------------- ThisExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::ThisExpressionContext::This() {
  return getToken(myParser::This, 0);
}

myParser::ThisExpressionContext::ThisExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::ThisExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThisExpression(this);
}
void myParser::ThisExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThisExpression(this);
}
//----------------- FunctionExpressionContext ------------------------------------------------------------------

myParser::AnonymousFunctionContext* myParser::FunctionExpressionContext::anonymousFunction() {
  return getRuleContext<myParser::AnonymousFunctionContext>(0);
}

myParser::FunctionExpressionContext::FunctionExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::FunctionExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionExpression(this);
}
void myParser::FunctionExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionExpression(this);
}
//----------------- UnaryMinusExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::UnaryMinusExpressionContext::Minus() {
  return getToken(myParser::Minus, 0);
}

myParser::SingleExpressionContext* myParser::UnaryMinusExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::UnaryMinusExpressionContext::UnaryMinusExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::UnaryMinusExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryMinusExpression(this);
}
void myParser::UnaryMinusExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryMinusExpression(this);
}
//----------------- AssignmentExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::AssignmentExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::AssignmentExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::AssignmentExpressionContext::Assign() {
  return getToken(myParser::Assign, 0);
}

myParser::AssignmentExpressionContext::AssignmentExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::AssignmentExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentExpression(this);
}
void myParser::AssignmentExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentExpression(this);
}
//----------------- PostDecreaseExpressionContext ------------------------------------------------------------------

myParser::SingleExpressionContext* myParser::PostDecreaseExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::PostDecreaseExpressionContext::MinusMinus() {
  return getToken(myParser::MinusMinus, 0);
}

myParser::PostDecreaseExpressionContext::PostDecreaseExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::PostDecreaseExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostDecreaseExpression(this);
}
void myParser::PostDecreaseExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostDecreaseExpression(this);
}
//----------------- TypeofExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::TypeofExpressionContext::Typeof() {
  return getToken(myParser::Typeof, 0);
}

myParser::SingleExpressionContext* myParser::TypeofExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::TypeofExpressionContext::TypeofExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::TypeofExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeofExpression(this);
}
void myParser::TypeofExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeofExpression(this);
}
//----------------- InstanceofExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::InstanceofExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::InstanceofExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::InstanceofExpressionContext::Instanceof() {
  return getToken(myParser::Instanceof, 0);
}

myParser::InstanceofExpressionContext::InstanceofExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::InstanceofExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInstanceofExpression(this);
}
void myParser::InstanceofExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInstanceofExpression(this);
}
//----------------- UnaryPlusExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::UnaryPlusExpressionContext::Plus() {
  return getToken(myParser::Plus, 0);
}

myParser::SingleExpressionContext* myParser::UnaryPlusExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::UnaryPlusExpressionContext::UnaryPlusExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::UnaryPlusExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryPlusExpression(this);
}
void myParser::UnaryPlusExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryPlusExpression(this);
}
//----------------- DeleteExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::DeleteExpressionContext::Delete() {
  return getToken(myParser::Delete, 0);
}

myParser::SingleExpressionContext* myParser::DeleteExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::DeleteExpressionContext::DeleteExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::DeleteExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeleteExpression(this);
}
void myParser::DeleteExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeleteExpression(this);
}
//----------------- ImportExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::ImportExpressionContext::Import() {
  return getToken(myParser::Import, 0);
}

tree::TerminalNode* myParser::ImportExpressionContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

myParser::SingleExpressionContext* myParser::ImportExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::ImportExpressionContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::ImportExpressionContext::ImportExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::ImportExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportExpression(this);
}
void myParser::ImportExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportExpression(this);
}
//----------------- EqualityExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::EqualityExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::EqualityExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::EqualityExpressionContext::Equals_() {
  return getToken(myParser::Equals_, 0);
}

tree::TerminalNode* myParser::EqualityExpressionContext::NotEquals() {
  return getToken(myParser::NotEquals, 0);
}

tree::TerminalNode* myParser::EqualityExpressionContext::IdentityEquals() {
  return getToken(myParser::IdentityEquals, 0);
}

tree::TerminalNode* myParser::EqualityExpressionContext::IdentityNotEquals() {
  return getToken(myParser::IdentityNotEquals, 0);
}

myParser::EqualityExpressionContext::EqualityExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::EqualityExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEqualityExpression(this);
}
void myParser::EqualityExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEqualityExpression(this);
}
//----------------- BitXOrExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::BitXOrExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::BitXOrExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::BitXOrExpressionContext::BitXOr() {
  return getToken(myParser::BitXOr, 0);
}

myParser::BitXOrExpressionContext::BitXOrExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::BitXOrExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitXOrExpression(this);
}
void myParser::BitXOrExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitXOrExpression(this);
}
//----------------- SuperExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::SuperExpressionContext::Super() {
  return getToken(myParser::Super, 0);
}

myParser::SuperExpressionContext::SuperExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::SuperExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSuperExpression(this);
}
void myParser::SuperExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSuperExpression(this);
}
//----------------- MultiplicativeExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::MultiplicativeExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::MultiplicativeExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::MultiplicativeExpressionContext::Multiply() {
  return getToken(myParser::Multiply, 0);
}

tree::TerminalNode* myParser::MultiplicativeExpressionContext::Divide() {
  return getToken(myParser::Divide, 0);
}

tree::TerminalNode* myParser::MultiplicativeExpressionContext::Modulus() {
  return getToken(myParser::Modulus, 0);
}

myParser::MultiplicativeExpressionContext::MultiplicativeExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::MultiplicativeExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiplicativeExpression(this);
}
void myParser::MultiplicativeExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiplicativeExpression(this);
}
//----------------- BitShiftExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::BitShiftExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::BitShiftExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::BitShiftExpressionContext::LeftShiftArithmetic() {
  return getToken(myParser::LeftShiftArithmetic, 0);
}

tree::TerminalNode* myParser::BitShiftExpressionContext::RightShiftArithmetic() {
  return getToken(myParser::RightShiftArithmetic, 0);
}

tree::TerminalNode* myParser::BitShiftExpressionContext::RightShiftLogical() {
  return getToken(myParser::RightShiftLogical, 0);
}

myParser::BitShiftExpressionContext::BitShiftExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::BitShiftExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitShiftExpression(this);
}
void myParser::BitShiftExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitShiftExpression(this);
}
//----------------- ParenthesizedExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::ParenthesizedExpressionContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

myParser::ExpressionSequenceContext* myParser::ParenthesizedExpressionContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::ParenthesizedExpressionContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::ParenthesizedExpressionContext::ParenthesizedExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::ParenthesizedExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParenthesizedExpression(this);
}
void myParser::ParenthesizedExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParenthesizedExpression(this);
}
//----------------- AdditiveExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::AdditiveExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::AdditiveExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::AdditiveExpressionContext::Plus() {
  return getToken(myParser::Plus, 0);
}

tree::TerminalNode* myParser::AdditiveExpressionContext::Minus() {
  return getToken(myParser::Minus, 0);
}

myParser::AdditiveExpressionContext::AdditiveExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::AdditiveExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAdditiveExpression(this);
}
void myParser::AdditiveExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAdditiveExpression(this);
}
//----------------- RelationalExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::RelationalExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::RelationalExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::RelationalExpressionContext::LessThan() {
  return getToken(myParser::LessThan, 0);
}

tree::TerminalNode* myParser::RelationalExpressionContext::MoreThan() {
  return getToken(myParser::MoreThan, 0);
}

tree::TerminalNode* myParser::RelationalExpressionContext::LessThanEquals() {
  return getToken(myParser::LessThanEquals, 0);
}

tree::TerminalNode* myParser::RelationalExpressionContext::GreaterThanEquals() {
  return getToken(myParser::GreaterThanEquals, 0);
}

myParser::RelationalExpressionContext::RelationalExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::RelationalExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelationalExpression(this);
}
void myParser::RelationalExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelationalExpression(this);
}
//----------------- PostIncrementExpressionContext ------------------------------------------------------------------

myParser::SingleExpressionContext* myParser::PostIncrementExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::PostIncrementExpressionContext::PlusPlus() {
  return getToken(myParser::PlusPlus, 0);
}

myParser::PostIncrementExpressionContext::PostIncrementExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::PostIncrementExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostIncrementExpression(this);
}
void myParser::PostIncrementExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostIncrementExpression(this);
}
//----------------- YieldExpressionContext ------------------------------------------------------------------

myParser::YieldStatementContext* myParser::YieldExpressionContext::yieldStatement() {
  return getRuleContext<myParser::YieldStatementContext>(0);
}

myParser::YieldExpressionContext::YieldExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::YieldExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterYieldExpression(this);
}
void myParser::YieldExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitYieldExpression(this);
}
//----------------- BitNotExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::BitNotExpressionContext::BitNot() {
  return getToken(myParser::BitNot, 0);
}

myParser::SingleExpressionContext* myParser::BitNotExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::BitNotExpressionContext::BitNotExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::BitNotExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitNotExpression(this);
}
void myParser::BitNotExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitNotExpression(this);
}
//----------------- NewExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::NewExpressionContext::New() {
  return getToken(myParser::New, 0);
}

myParser::SingleExpressionContext* myParser::NewExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::ArgumentsContext* myParser::NewExpressionContext::arguments() {
  return getRuleContext<myParser::ArgumentsContext>(0);
}

myParser::NewExpressionContext::NewExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::NewExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNewExpression(this);
}
void myParser::NewExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNewExpression(this);
}
//----------------- LiteralExpressionContext ------------------------------------------------------------------

myParser::LiteralContext* myParser::LiteralExpressionContext::literal() {
  return getRuleContext<myParser::LiteralContext>(0);
}

myParser::LiteralExpressionContext::LiteralExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::LiteralExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteralExpression(this);
}
void myParser::LiteralExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteralExpression(this);
}
//----------------- ArrayLiteralExpressionContext ------------------------------------------------------------------

myParser::ArrayLiteralContext* myParser::ArrayLiteralExpressionContext::arrayLiteral() {
  return getRuleContext<myParser::ArrayLiteralContext>(0);
}

myParser::ArrayLiteralExpressionContext::ArrayLiteralExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::ArrayLiteralExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayLiteralExpression(this);
}
void myParser::ArrayLiteralExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayLiteralExpression(this);
}
//----------------- MemberDotExpressionContext ------------------------------------------------------------------

myParser::SingleExpressionContext* myParser::MemberDotExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::MemberDotExpressionContext::Dot() {
  return getToken(myParser::Dot, 0);
}

myParser::IdentifierNameContext* myParser::MemberDotExpressionContext::identifierName() {
  return getRuleContext<myParser::IdentifierNameContext>(0);
}

tree::TerminalNode* myParser::MemberDotExpressionContext::QuestionMark() {
  return getToken(myParser::QuestionMark, 0);
}

tree::TerminalNode* myParser::MemberDotExpressionContext::Hashtag() {
  return getToken(myParser::Hashtag, 0);
}

myParser::MemberDotExpressionContext::MemberDotExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::MemberDotExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemberDotExpression(this);
}
void myParser::MemberDotExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemberDotExpression(this);
}
//----------------- ClassExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::ClassExpressionContext::Class() {
  return getToken(myParser::Class, 0);
}

myParser::ClassTailContext* myParser::ClassExpressionContext::classTail() {
  return getRuleContext<myParser::ClassTailContext>(0);
}

myParser::IdentifierContext* myParser::ClassExpressionContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::ClassExpressionContext::ClassExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::ClassExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassExpression(this);
}
void myParser::ClassExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassExpression(this);
}
//----------------- MemberIndexExpressionContext ------------------------------------------------------------------

myParser::SingleExpressionContext* myParser::MemberIndexExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::MemberIndexExpressionContext::OpenBracket() {
  return getToken(myParser::OpenBracket, 0);
}

myParser::ExpressionSequenceContext* myParser::MemberIndexExpressionContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::MemberIndexExpressionContext::CloseBracket() {
  return getToken(myParser::CloseBracket, 0);
}

tree::TerminalNode* myParser::MemberIndexExpressionContext::QuestionMarkDot() {
  return getToken(myParser::QuestionMarkDot, 0);
}

myParser::MemberIndexExpressionContext::MemberIndexExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::MemberIndexExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemberIndexExpression(this);
}
void myParser::MemberIndexExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemberIndexExpression(this);
}
//----------------- IdentifierExpressionContext ------------------------------------------------------------------

myParser::IdentifierContext* myParser::IdentifierExpressionContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::IdentifierExpressionContext::IdentifierExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::IdentifierExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierExpression(this);
}
void myParser::IdentifierExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierExpression(this);
}
//----------------- BitAndExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::BitAndExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::BitAndExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::BitAndExpressionContext::BitAnd() {
  return getToken(myParser::BitAnd, 0);
}

myParser::BitAndExpressionContext::BitAndExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::BitAndExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitAndExpression(this);
}
void myParser::BitAndExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitAndExpression(this);
}
//----------------- BitOrExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::BitOrExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::BitOrExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::BitOrExpressionContext::BitOr() {
  return getToken(myParser::BitOr, 0);
}

myParser::BitOrExpressionContext::BitOrExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::BitOrExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitOrExpression(this);
}
void myParser::BitOrExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitOrExpression(this);
}
//----------------- AssignmentOperatorExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::AssignmentOperatorExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::AssignmentOperatorExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

myParser::AssignmentOperatorContext* myParser::AssignmentOperatorExpressionContext::assignmentOperator() {
  return getRuleContext<myParser::AssignmentOperatorContext>(0);
}

myParser::AssignmentOperatorExpressionContext::AssignmentOperatorExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::AssignmentOperatorExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentOperatorExpression(this);
}
void myParser::AssignmentOperatorExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentOperatorExpression(this);
}
//----------------- VoidExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::VoidExpressionContext::Void() {
  return getToken(myParser::Void, 0);
}

myParser::SingleExpressionContext* myParser::VoidExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::VoidExpressionContext::VoidExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::VoidExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVoidExpression(this);
}
void myParser::VoidExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVoidExpression(this);
}
//----------------- CoalesceExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::CoalesceExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::CoalesceExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::CoalesceExpressionContext::NullCoalesce() {
  return getToken(myParser::NullCoalesce, 0);
}

myParser::CoalesceExpressionContext::CoalesceExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::CoalesceExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCoalesceExpression(this);
}
void myParser::CoalesceExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCoalesceExpression(this);
}

myParser::SingleExpressionContext* myParser::singleExpression() {
   return singleExpression(0);
}

myParser::SingleExpressionContext* myParser::singleExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  myParser::SingleExpressionContext *_localctx = _tracker.createInstance<SingleExpressionContext>(_ctx, parentState);
  myParser::SingleExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 114;
  enterRecursionRule(_localctx, 114, myParser::RuleSingleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(780);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<FunctionExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(729);
      anonymousFunction();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<ClassExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(730);
      match(myParser::Class);
      setState(732);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 107) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 107)) & 4129) != 0)) {
        setState(731);
        identifier();
      }
      setState(734);
      classTail();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<NewExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(735);
      match(myParser::New);
      setState(736);
      singleExpression(0);
      setState(737);
      arguments();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<NewExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(739);
      match(myParser::New);
      setState(740);
      singleExpression(42);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<MetaExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(741);
      match(myParser::New);
      setState(742);
      match(myParser::Dot);
      setState(743);
      identifier();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<DeleteExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(744);
      match(myParser::Delete);
      setState(745);
      singleExpression(37);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<VoidExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(746);
      match(myParser::Void);
      setState(747);
      singleExpression(36);
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<TypeofExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(748);
      match(myParser::Typeof);
      setState(749);
      singleExpression(35);
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<PreIncrementExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(750);
      match(myParser::PlusPlus);
      setState(751);
      singleExpression(34);
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<PreDecreaseExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(752);
      match(myParser::MinusMinus);
      setState(753);
      singleExpression(33);
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<UnaryPlusExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(754);
      match(myParser::Plus);
      setState(755);
      singleExpression(32);
      break;
    }

    case 12: {
      _localctx = _tracker.createInstance<UnaryMinusExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(756);
      match(myParser::Minus);
      setState(757);
      singleExpression(31);
      break;
    }

    case 13: {
      _localctx = _tracker.createInstance<BitNotExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(758);
      match(myParser::BitNot);
      setState(759);
      singleExpression(30);
      break;
    }

    case 14: {
      _localctx = _tracker.createInstance<NotExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(760);
      match(myParser::Not);
      setState(761);
      singleExpression(29);
      break;
    }

    case 15: {
      _localctx = _tracker.createInstance<AwaitExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(762);
      match(myParser::Await);
      setState(763);
      singleExpression(28);
      break;
    }

    case 16: {
      _localctx = _tracker.createInstance<ImportExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(764);
      match(myParser::Import);
      setState(765);
      match(myParser::OpenParen);
      setState(766);
      singleExpression(0);
      setState(767);
      match(myParser::CloseParen);
      break;
    }

    case 17: {
      _localctx = _tracker.createInstance<YieldExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(769);
      yieldStatement();
      break;
    }

    case 18: {
      _localctx = _tracker.createInstance<ThisExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(770);
      match(myParser::This);
      break;
    }

    case 19: {
      _localctx = _tracker.createInstance<IdentifierExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(771);
      identifier();
      break;
    }

    case 20: {
      _localctx = _tracker.createInstance<SuperExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(772);
      match(myParser::Super);
      break;
    }

    case 21: {
      _localctx = _tracker.createInstance<LiteralExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(773);
      literal();
      break;
    }

    case 22: {
      _localctx = _tracker.createInstance<ArrayLiteralExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(774);
      arrayLiteral();
      break;
    }

    case 23: {
      _localctx = _tracker.createInstance<ObjectLiteralExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(775);
      objectLiteral();
      break;
    }

    case 24: {
      _localctx = _tracker.createInstance<ParenthesizedExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(776);
      match(myParser::OpenParen);
      setState(777);
      expressionSequence();
      setState(778);
      match(myParser::CloseParen);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(869);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(867);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 92, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<OptionalChainExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(782);

          if (!(precpred(_ctx, 46))) throw FailedPredicateException(this, "precpred(_ctx, 46)");
          setState(783);
          match(myParser::QuestionMarkDot);
          setState(784);
          singleExpression(47);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<PowerExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(785);

          if (!(precpred(_ctx, 27))) throw FailedPredicateException(this, "precpred(_ctx, 27)");
          setState(786);
          match(myParser::Power);
          setState(787);
          singleExpression(27);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<MultiplicativeExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(788);

          if (!(precpred(_ctx, 26))) throw FailedPredicateException(this, "precpred(_ctx, 26)");
          setState(789);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 469762048) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(790);
          singleExpression(27);
          break;
        }

        case 4: {
          auto newContext = _tracker.createInstance<AdditiveExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(791);

          if (!(precpred(_ctx, 25))) throw FailedPredicateException(this, "precpred(_ctx, 25)");
          setState(792);
          _la = _input->LA(1);
          if (!(_la == myParser::Plus

          || _la == myParser::Minus)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(793);
          singleExpression(26);
          break;
        }

        case 5: {
          auto newContext = _tracker.createInstance<CoalesceExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(794);

          if (!(precpred(_ctx, 24))) throw FailedPredicateException(this, "precpred(_ctx, 24)");
          setState(795);
          match(myParser::NullCoalesce);
          setState(796);
          singleExpression(25);
          break;
        }

        case 6: {
          auto newContext = _tracker.createInstance<BitShiftExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(797);

          if (!(precpred(_ctx, 23))) throw FailedPredicateException(this, "precpred(_ctx, 23)");
          setState(798);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 30064771072) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(799);
          singleExpression(24);
          break;
        }

        case 7: {
          auto newContext = _tracker.createInstance<RelationalExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(800);

          if (!(precpred(_ctx, 22))) throw FailedPredicateException(this, "precpred(_ctx, 22)");
          setState(801);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 515396075520) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(802);
          singleExpression(23);
          break;
        }

        case 8: {
          auto newContext = _tracker.createInstance<InstanceofExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(803);

          if (!(precpred(_ctx, 21))) throw FailedPredicateException(this, "precpred(_ctx, 21)");
          setState(804);
          match(myParser::Instanceof);
          setState(805);
          singleExpression(22);
          break;
        }

        case 9: {
          auto newContext = _tracker.createInstance<InExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(806);

          if (!(precpred(_ctx, 20))) throw FailedPredicateException(this, "precpred(_ctx, 20)");
          setState(807);
          match(myParser::In);
          setState(808);
          singleExpression(21);
          break;
        }

        case 10: {
          auto newContext = _tracker.createInstance<EqualityExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(809);

          if (!(precpred(_ctx, 19))) throw FailedPredicateException(this, "precpred(_ctx, 19)");
          setState(810);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 8246337208320) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(811);
          singleExpression(20);
          break;
        }

        case 11: {
          auto newContext = _tracker.createInstance<BitAndExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(812);

          if (!(precpred(_ctx, 18))) throw FailedPredicateException(this, "precpred(_ctx, 18)");
          setState(813);
          match(myParser::BitAnd);
          setState(814);
          singleExpression(19);
          break;
        }

        case 12: {
          auto newContext = _tracker.createInstance<BitXOrExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(815);

          if (!(precpred(_ctx, 17))) throw FailedPredicateException(this, "precpred(_ctx, 17)");
          setState(816);
          match(myParser::BitXOr);
          setState(817);
          singleExpression(18);
          break;
        }

        case 13: {
          auto newContext = _tracker.createInstance<BitOrExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(818);

          if (!(precpred(_ctx, 16))) throw FailedPredicateException(this, "precpred(_ctx, 16)");
          setState(819);
          match(myParser::BitOr);
          setState(820);
          singleExpression(17);
          break;
        }

        case 14: {
          auto newContext = _tracker.createInstance<LogicalAndExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(821);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(822);
          match(myParser::And);
          setState(823);
          singleExpression(16);
          break;
        }

        case 15: {
          auto newContext = _tracker.createInstance<LogicalOrExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(824);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(825);
          match(myParser::Or);
          setState(826);
          singleExpression(15);
          break;
        }

        case 16: {
          auto newContext = _tracker.createInstance<TernaryExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(827);

          if (!(precpred(_ctx, 13))) throw FailedPredicateException(this, "precpred(_ctx, 13)");
          setState(828);
          match(myParser::QuestionMark);
          setState(829);
          singleExpression(0);
          setState(830);
          match(myParser::Colon);
          setState(831);
          singleExpression(14);
          break;
        }

        case 17: {
          auto newContext = _tracker.createInstance<AssignmentExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(833);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(834);
          match(myParser::Assign);
          setState(835);
          singleExpression(12);
          break;
        }

        case 18: {
          auto newContext = _tracker.createInstance<AssignmentOperatorExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(836);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(837);
          assignmentOperator();
          setState(838);
          singleExpression(11);
          break;
        }

        case 19: {
          auto newContext = _tracker.createInstance<MemberIndexExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(840);

          if (!(precpred(_ctx, 45))) throw FailedPredicateException(this, "precpred(_ctx, 45)");
          setState(842);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == myParser::QuestionMarkDot) {
            setState(841);
            match(myParser::QuestionMarkDot);
          }
          setState(844);
          match(myParser::OpenBracket);
          setState(845);
          expressionSequence();
          setState(846);
          match(myParser::CloseBracket);
          break;
        }

        case 20: {
          auto newContext = _tracker.createInstance<MemberDotExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(848);

          if (!(precpred(_ctx, 44))) throw FailedPredicateException(this, "precpred(_ctx, 44)");
          setState(850);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == myParser::QuestionMark) {
            setState(849);
            match(myParser::QuestionMark);
          }
          setState(852);
          match(myParser::Dot);
          setState(854);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == myParser::Hashtag) {
            setState(853);
            match(myParser::Hashtag);
          }
          setState(856);
          identifierName();
          break;
        }

        case 21: {
          auto newContext = _tracker.createInstance<ArgumentsExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(857);

          if (!(precpred(_ctx, 41))) throw FailedPredicateException(this, "precpred(_ctx, 41)");
          setState(858);
          arguments();
          break;
        }

        case 22: {
          auto newContext = _tracker.createInstance<PostIncrementExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(859);

          if (!(precpred(_ctx, 39))) throw FailedPredicateException(this, "precpred(_ctx, 39)");
          setState(860);

          if (!(this.notLineTerminator())) throw FailedPredicateException(this, "this.notLineTerminator()");
          setState(861);
          match(myParser::PlusPlus);
          break;
        }

        case 23: {
          auto newContext = _tracker.createInstance<PostDecreaseExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(862);

          if (!(precpred(_ctx, 38))) throw FailedPredicateException(this, "precpred(_ctx, 38)");
          setState(863);

          if (!(this.notLineTerminator())) throw FailedPredicateException(this, "this.notLineTerminator()");
          setState(864);
          match(myParser::MinusMinus);
          break;
        }

        case 24: {
          auto newContext = _tracker.createInstance<TemplateStringExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(865);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(866);
          templateStringLiteral();
          break;
        }

        default:
          break;
        } 
      }
      setState(871);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- AssignableContext ------------------------------------------------------------------

myParser::AssignableContext::AssignableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::AssignableContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::ArrayLiteralContext* myParser::AssignableContext::arrayLiteral() {
  return getRuleContext<myParser::ArrayLiteralContext>(0);
}

myParser::ObjectLiteralContext* myParser::AssignableContext::objectLiteral() {
  return getRuleContext<myParser::ObjectLiteralContext>(0);
}


size_t myParser::AssignableContext::getRuleIndex() const {
  return myParser::RuleAssignable;
}

void myParser::AssignableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignable(this);
}

void myParser::AssignableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignable(this);
}

myParser::AssignableContext* myParser::assignable() {
  AssignableContext *_localctx = _tracker.createInstance<AssignableContext>(_ctx, getState());
  enterRule(_localctx, 116, myParser::RuleAssignable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(875);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Async:
      case myParser::NonStrictLet:
      case myParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(872);
        identifier();
        break;
      }

      case myParser::OpenBracket: {
        enterOuterAlt(_localctx, 2);
        setState(873);
        arrayLiteral();
        break;
      }

      case myParser::OpenBrace: {
        enterOuterAlt(_localctx, 3);
        setState(874);
        objectLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectLiteralContext ------------------------------------------------------------------

myParser::ObjectLiteralContext::ObjectLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ObjectLiteralContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

tree::TerminalNode* myParser::ObjectLiteralContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

std::vector<myParser::PropertyAssignmentContext *> myParser::ObjectLiteralContext::propertyAssignment() {
  return getRuleContexts<myParser::PropertyAssignmentContext>();
}

myParser::PropertyAssignmentContext* myParser::ObjectLiteralContext::propertyAssignment(size_t i) {
  return getRuleContext<myParser::PropertyAssignmentContext>(i);
}

std::vector<tree::TerminalNode *> myParser::ObjectLiteralContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::ObjectLiteralContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::ObjectLiteralContext::getRuleIndex() const {
  return myParser::RuleObjectLiteral;
}

void myParser::ObjectLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectLiteral(this);
}

void myParser::ObjectLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectLiteral(this);
}

myParser::ObjectLiteralContext* myParser::objectLiteral() {
  ObjectLiteralContext *_localctx = _tracker.createInstance<ObjectLiteralContext>(_ctx, getState());
  enterRule(_localctx, 118, myParser::RuleObjectLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(877);
    match(myParser::OpenBrace);
    setState(889);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx)) {
    case 1: {
      setState(878);
      propertyAssignment();
      setState(883);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(879);
          match(myParser::Comma);
          setState(880);
          propertyAssignment(); 
        }
        setState(885);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx);
      }
      setState(887);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::Comma) {
        setState(886);
        match(myParser::Comma);
      }
      break;
    }

    default:
      break;
    }
    setState(891);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnonymousFunctionContext ------------------------------------------------------------------

myParser::AnonymousFunctionContext::AnonymousFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t myParser::AnonymousFunctionContext::getRuleIndex() const {
  return myParser::RuleAnonymousFunction;
}

void myParser::AnonymousFunctionContext::copyFrom(AnonymousFunctionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- AnonymousFunctionDeclContext ------------------------------------------------------------------

tree::TerminalNode* myParser::AnonymousFunctionDeclContext::Function_() {
  return getToken(myParser::Function_, 0);
}

tree::TerminalNode* myParser::AnonymousFunctionDeclContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::AnonymousFunctionDeclContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::FunctionBodyContext* myParser::AnonymousFunctionDeclContext::functionBody() {
  return getRuleContext<myParser::FunctionBodyContext>(0);
}

tree::TerminalNode* myParser::AnonymousFunctionDeclContext::Async() {
  return getToken(myParser::Async, 0);
}

tree::TerminalNode* myParser::AnonymousFunctionDeclContext::Multiply() {
  return getToken(myParser::Multiply, 0);
}

myParser::FormalParameterListContext* myParser::AnonymousFunctionDeclContext::formalParameterList() {
  return getRuleContext<myParser::FormalParameterListContext>(0);
}

myParser::AnonymousFunctionDeclContext::AnonymousFunctionDeclContext(AnonymousFunctionContext *ctx) { copyFrom(ctx); }

void myParser::AnonymousFunctionDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnonymousFunctionDecl(this);
}
void myParser::AnonymousFunctionDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnonymousFunctionDecl(this);
}
//----------------- ArrowFunctionContext ------------------------------------------------------------------

myParser::ArrowFunctionParametersContext* myParser::ArrowFunctionContext::arrowFunctionParameters() {
  return getRuleContext<myParser::ArrowFunctionParametersContext>(0);
}

tree::TerminalNode* myParser::ArrowFunctionContext::ARROW() {
  return getToken(myParser::ARROW, 0);
}

myParser::ArrowFunctionBodyContext* myParser::ArrowFunctionContext::arrowFunctionBody() {
  return getRuleContext<myParser::ArrowFunctionBodyContext>(0);
}

tree::TerminalNode* myParser::ArrowFunctionContext::Async() {
  return getToken(myParser::Async, 0);
}

myParser::ArrowFunctionContext::ArrowFunctionContext(AnonymousFunctionContext *ctx) { copyFrom(ctx); }

void myParser::ArrowFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrowFunction(this);
}
void myParser::ArrowFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrowFunction(this);
}
//----------------- FunctionDeclContext ------------------------------------------------------------------

myParser::FunctionDeclarationContext* myParser::FunctionDeclContext::functionDeclaration() {
  return getRuleContext<myParser::FunctionDeclarationContext>(0);
}

myParser::FunctionDeclContext::FunctionDeclContext(AnonymousFunctionContext *ctx) { copyFrom(ctx); }

void myParser::FunctionDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionDecl(this);
}
void myParser::FunctionDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionDecl(this);
}
myParser::AnonymousFunctionContext* myParser::anonymousFunction() {
  AnonymousFunctionContext *_localctx = _tracker.createInstance<AnonymousFunctionContext>(_ctx, getState());
  enterRule(_localctx, 120, myParser::RuleAnonymousFunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(914);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<myParser::FunctionDeclContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(893);
      functionDeclaration();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<myParser::AnonymousFunctionDeclContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(895);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::Async) {
        setState(894);
        match(myParser::Async);
      }
      setState(897);
      match(myParser::Function_);
      setState(899);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::Multiply) {
        setState(898);
        match(myParser::Multiply);
      }
      setState(901);
      match(myParser::OpenParen);
      setState(903);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 262688) != 0) || ((((_la - 107) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 107)) & 4129) != 0)) {
        setState(902);
        formalParameterList();
      }
      setState(905);
      match(myParser::CloseParen);
      setState(906);
      functionBody();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<myParser::ArrowFunctionContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(908);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx)) {
      case 1: {
        setState(907);
        match(myParser::Async);
        break;
      }

      default:
        break;
      }
      setState(910);
      arrowFunctionParameters();
      setState(911);
      match(myParser::ARROW);
      setState(912);
      arrowFunctionBody();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrowFunctionParametersContext ------------------------------------------------------------------

myParser::ArrowFunctionParametersContext::ArrowFunctionParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::ArrowFunctionParametersContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

tree::TerminalNode* myParser::ArrowFunctionParametersContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::ArrowFunctionParametersContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::FormalParameterListContext* myParser::ArrowFunctionParametersContext::formalParameterList() {
  return getRuleContext<myParser::FormalParameterListContext>(0);
}


size_t myParser::ArrowFunctionParametersContext::getRuleIndex() const {
  return myParser::RuleArrowFunctionParameters;
}

void myParser::ArrowFunctionParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrowFunctionParameters(this);
}

void myParser::ArrowFunctionParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrowFunctionParameters(this);
}

myParser::ArrowFunctionParametersContext* myParser::arrowFunctionParameters() {
  ArrowFunctionParametersContext *_localctx = _tracker.createInstance<ArrowFunctionParametersContext>(_ctx, getState());
  enterRule(_localctx, 122, myParser::RuleArrowFunctionParameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(922);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Async:
      case myParser::NonStrictLet:
      case myParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(916);
        identifier();
        break;
      }

      case myParser::OpenParen: {
        enterOuterAlt(_localctx, 2);
        setState(917);
        match(myParser::OpenParen);
        setState(919);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 262688) != 0) || ((((_la - 107) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 107)) & 4129) != 0)) {
          setState(918);
          formalParameterList();
        }
        setState(921);
        match(myParser::CloseParen);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrowFunctionBodyContext ------------------------------------------------------------------

myParser::ArrowFunctionBodyContext::ArrowFunctionBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SingleExpressionContext* myParser::ArrowFunctionBodyContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::FunctionBodyContext* myParser::ArrowFunctionBodyContext::functionBody() {
  return getRuleContext<myParser::FunctionBodyContext>(0);
}


size_t myParser::ArrowFunctionBodyContext::getRuleIndex() const {
  return myParser::RuleArrowFunctionBody;
}

void myParser::ArrowFunctionBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrowFunctionBody(this);
}

void myParser::ArrowFunctionBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrowFunctionBody(this);
}

myParser::ArrowFunctionBodyContext* myParser::arrowFunctionBody() {
  ArrowFunctionBodyContext *_localctx = _tracker.createInstance<ArrowFunctionBodyContext>(_ctx, getState());
  enterRule(_localctx, 124, myParser::RuleArrowFunctionBody);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(926);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 105, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(924);
      singleExpression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(925);
      functionBody();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentOperatorContext ------------------------------------------------------------------

myParser::AssignmentOperatorContext::AssignmentOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::AssignmentOperatorContext::MultiplyAssign() {
  return getToken(myParser::MultiplyAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::DivideAssign() {
  return getToken(myParser::DivideAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::ModulusAssign() {
  return getToken(myParser::ModulusAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::PlusAssign() {
  return getToken(myParser::PlusAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::MinusAssign() {
  return getToken(myParser::MinusAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::LeftShiftArithmeticAssign() {
  return getToken(myParser::LeftShiftArithmeticAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::RightShiftArithmeticAssign() {
  return getToken(myParser::RightShiftArithmeticAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::RightShiftLogicalAssign() {
  return getToken(myParser::RightShiftLogicalAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::BitAndAssign() {
  return getToken(myParser::BitAndAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::BitXorAssign() {
  return getToken(myParser::BitXorAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::BitOrAssign() {
  return getToken(myParser::BitOrAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::PowerAssign() {
  return getToken(myParser::PowerAssign, 0);
}


size_t myParser::AssignmentOperatorContext::getRuleIndex() const {
  return myParser::RuleAssignmentOperator;
}

void myParser::AssignmentOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentOperator(this);
}

void myParser::AssignmentOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentOperator(this);
}

myParser::AssignmentOperatorContext* myParser::assignmentOperator() {
  AssignmentOperatorContext *_localctx = _tracker.createInstance<AssignmentOperatorContext>(_ctx, getState());
  enterRule(_localctx, 126, myParser::RuleAssignmentOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(928);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1152640029630136320) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

myParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::LiteralContext::NullLiteral() {
  return getToken(myParser::NullLiteral, 0);
}

tree::TerminalNode* myParser::LiteralContext::BooleanLiteral() {
  return getToken(myParser::BooleanLiteral, 0);
}

tree::TerminalNode* myParser::LiteralContext::StringLiteral() {
  return getToken(myParser::StringLiteral, 0);
}

myParser::TemplateStringLiteralContext* myParser::LiteralContext::templateStringLiteral() {
  return getRuleContext<myParser::TemplateStringLiteralContext>(0);
}

tree::TerminalNode* myParser::LiteralContext::RegularExpressionLiteral() {
  return getToken(myParser::RegularExpressionLiteral, 0);
}

myParser::NumericLiteralContext* myParser::LiteralContext::numericLiteral() {
  return getRuleContext<myParser::NumericLiteralContext>(0);
}

myParser::BigintLiteralContext* myParser::LiteralContext::bigintLiteral() {
  return getRuleContext<myParser::BigintLiteralContext>(0);
}


size_t myParser::LiteralContext::getRuleIndex() const {
  return myParser::RuleLiteral;
}

void myParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void myParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}

myParser::LiteralContext* myParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 128, myParser::RuleLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(937);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::NullLiteral: {
        enterOuterAlt(_localctx, 1);
        setState(930);
        match(myParser::NullLiteral);
        break;
      }

      case myParser::BooleanLiteral: {
        enterOuterAlt(_localctx, 2);
        setState(931);
        match(myParser::BooleanLiteral);
        break;
      }

      case myParser::StringLiteral: {
        enterOuterAlt(_localctx, 3);
        setState(932);
        match(myParser::StringLiteral);
        break;
      }

      case myParser::BackTick: {
        enterOuterAlt(_localctx, 4);
        setState(933);
        templateStringLiteral();
        break;
      }

      case myParser::RegularExpressionLiteral: {
        enterOuterAlt(_localctx, 5);
        setState(934);
        match(myParser::RegularExpressionLiteral);
        break;
      }

      case myParser::DecimalLiteral:
      case myParser::HexIntegerLiteral:
      case myParser::OctalIntegerLiteral:
      case myParser::OctalIntegerLiteral2:
      case myParser::BinaryIntegerLiteral: {
        enterOuterAlt(_localctx, 6);
        setState(935);
        numericLiteral();
        break;
      }

      case myParser::BigHexIntegerLiteral:
      case myParser::BigOctalIntegerLiteral:
      case myParser::BigBinaryIntegerLiteral:
      case myParser::BigDecimalIntegerLiteral: {
        enterOuterAlt(_localctx, 7);
        setState(936);
        bigintLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemplateStringLiteralContext ------------------------------------------------------------------

myParser::TemplateStringLiteralContext::TemplateStringLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> myParser::TemplateStringLiteralContext::BackTick() {
  return getTokens(myParser::BackTick);
}

tree::TerminalNode* myParser::TemplateStringLiteralContext::BackTick(size_t i) {
  return getToken(myParser::BackTick, i);
}

std::vector<myParser::TemplateStringAtomContext *> myParser::TemplateStringLiteralContext::templateStringAtom() {
  return getRuleContexts<myParser::TemplateStringAtomContext>();
}

myParser::TemplateStringAtomContext* myParser::TemplateStringLiteralContext::templateStringAtom(size_t i) {
  return getRuleContext<myParser::TemplateStringAtomContext>(i);
}


size_t myParser::TemplateStringLiteralContext::getRuleIndex() const {
  return myParser::RuleTemplateStringLiteral;
}

void myParser::TemplateStringLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemplateStringLiteral(this);
}

void myParser::TemplateStringLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemplateStringLiteral(this);
}

myParser::TemplateStringLiteralContext* myParser::templateStringLiteral() {
  TemplateStringLiteralContext *_localctx = _tracker.createInstance<TemplateStringLiteralContext>(_ctx, getState());
  enterRule(_localctx, 130, myParser::RuleTemplateStringLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(939);
    match(myParser::BackTick);
    setState(943);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::TemplateStringStartExpression

    || _la == myParser::TemplateStringAtom) {
      setState(940);
      templateStringAtom();
      setState(945);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(946);
    match(myParser::BackTick);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemplateStringAtomContext ------------------------------------------------------------------

myParser::TemplateStringAtomContext::TemplateStringAtomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TemplateStringAtomContext::TemplateStringAtom() {
  return getToken(myParser::TemplateStringAtom, 0);
}

tree::TerminalNode* myParser::TemplateStringAtomContext::TemplateStringStartExpression() {
  return getToken(myParser::TemplateStringStartExpression, 0);
}

myParser::SingleExpressionContext* myParser::TemplateStringAtomContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::TemplateStringAtomContext::TemplateCloseBrace() {
  return getToken(myParser::TemplateCloseBrace, 0);
}


size_t myParser::TemplateStringAtomContext::getRuleIndex() const {
  return myParser::RuleTemplateStringAtom;
}

void myParser::TemplateStringAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemplateStringAtom(this);
}

void myParser::TemplateStringAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemplateStringAtom(this);
}

myParser::TemplateStringAtomContext* myParser::templateStringAtom() {
  TemplateStringAtomContext *_localctx = _tracker.createInstance<TemplateStringAtomContext>(_ctx, getState());
  enterRule(_localctx, 132, myParser::RuleTemplateStringAtom);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(953);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::TemplateStringAtom: {
        enterOuterAlt(_localctx, 1);
        setState(948);
        match(myParser::TemplateStringAtom);
        break;
      }

      case myParser::TemplateStringStartExpression: {
        enterOuterAlt(_localctx, 2);
        setState(949);
        match(myParser::TemplateStringStartExpression);
        setState(950);
        singleExpression(0);
        setState(951);
        match(myParser::TemplateCloseBrace);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericLiteralContext ------------------------------------------------------------------

myParser::NumericLiteralContext::NumericLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::NumericLiteralContext::DecimalLiteral() {
  return getToken(myParser::DecimalLiteral, 0);
}

tree::TerminalNode* myParser::NumericLiteralContext::HexIntegerLiteral() {
  return getToken(myParser::HexIntegerLiteral, 0);
}

tree::TerminalNode* myParser::NumericLiteralContext::OctalIntegerLiteral() {
  return getToken(myParser::OctalIntegerLiteral, 0);
}

tree::TerminalNode* myParser::NumericLiteralContext::OctalIntegerLiteral2() {
  return getToken(myParser::OctalIntegerLiteral2, 0);
}

tree::TerminalNode* myParser::NumericLiteralContext::BinaryIntegerLiteral() {
  return getToken(myParser::BinaryIntegerLiteral, 0);
}


size_t myParser::NumericLiteralContext::getRuleIndex() const {
  return myParser::RuleNumericLiteral;
}

void myParser::NumericLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericLiteral(this);
}

void myParser::NumericLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericLiteral(this);
}

myParser::NumericLiteralContext* myParser::numericLiteral() {
  NumericLiteralContext *_localctx = _tracker.createInstance<NumericLiteralContext>(_ctx, getState());
  enterRule(_localctx, 134, myParser::RuleNumericLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(955);
    _la = _input->LA(1);
    if (!(((((_la - 63) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 63)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BigintLiteralContext ------------------------------------------------------------------

myParser::BigintLiteralContext::BigintLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::BigintLiteralContext::BigDecimalIntegerLiteral() {
  return getToken(myParser::BigDecimalIntegerLiteral, 0);
}

tree::TerminalNode* myParser::BigintLiteralContext::BigHexIntegerLiteral() {
  return getToken(myParser::BigHexIntegerLiteral, 0);
}

tree::TerminalNode* myParser::BigintLiteralContext::BigOctalIntegerLiteral() {
  return getToken(myParser::BigOctalIntegerLiteral, 0);
}

tree::TerminalNode* myParser::BigintLiteralContext::BigBinaryIntegerLiteral() {
  return getToken(myParser::BigBinaryIntegerLiteral, 0);
}


size_t myParser::BigintLiteralContext::getRuleIndex() const {
  return myParser::RuleBigintLiteral;
}

void myParser::BigintLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBigintLiteral(this);
}

void myParser::BigintLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBigintLiteral(this);
}

myParser::BigintLiteralContext* myParser::bigintLiteral() {
  BigintLiteralContext *_localctx = _tracker.createInstance<BigintLiteralContext>(_ctx, getState());
  enterRule(_localctx, 136, myParser::RuleBigintLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(957);
    _la = _input->LA(1);
    if (!(((((_la - 68) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 68)) & 15) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GetterContext ------------------------------------------------------------------

myParser::GetterContext::GetterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::GetterContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::PropertyNameContext* myParser::GetterContext::propertyName() {
  return getRuleContext<myParser::PropertyNameContext>(0);
}


size_t myParser::GetterContext::getRuleIndex() const {
  return myParser::RuleGetter;
}

void myParser::GetterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGetter(this);
}

void myParser::GetterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGetter(this);
}

myParser::GetterContext* myParser::getter() {
  GetterContext *_localctx = _tracker.createInstance<GetterContext>(_ctx, getState());
  enterRule(_localctx, 138, myParser::RuleGetter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(959);

    if (!(this.n("get"))) throw FailedPredicateException(this, "this.n(\"get\")");
    setState(960);
    identifier();
    setState(961);
    propertyName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetterContext ------------------------------------------------------------------

myParser::SetterContext::SetterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::SetterContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::PropertyNameContext* myParser::SetterContext::propertyName() {
  return getRuleContext<myParser::PropertyNameContext>(0);
}


size_t myParser::SetterContext::getRuleIndex() const {
  return myParser::RuleSetter;
}

void myParser::SetterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetter(this);
}

void myParser::SetterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetter(this);
}

myParser::SetterContext* myParser::setter() {
  SetterContext *_localctx = _tracker.createInstance<SetterContext>(_ctx, getState());
  enterRule(_localctx, 140, myParser::RuleSetter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(963);

    if (!(this.n("set"))) throw FailedPredicateException(this, "this.n(\"set\")");
    setState(964);
    identifier();
    setState(965);
    propertyName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierNameContext ------------------------------------------------------------------

myParser::IdentifierNameContext::IdentifierNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::IdentifierNameContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::ReservedWordContext* myParser::IdentifierNameContext::reservedWord() {
  return getRuleContext<myParser::ReservedWordContext>(0);
}


size_t myParser::IdentifierNameContext::getRuleIndex() const {
  return myParser::RuleIdentifierName;
}

void myParser::IdentifierNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierName(this);
}

void myParser::IdentifierNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierName(this);
}

myParser::IdentifierNameContext* myParser::identifierName() {
  IdentifierNameContext *_localctx = _tracker.createInstance<IdentifierNameContext>(_ctx, getState());
  enterRule(_localctx, 142, myParser::RuleIdentifierName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(969);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(967);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(968);
      reservedWord();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

myParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::IdentifierContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

tree::TerminalNode* myParser::IdentifierContext::NonStrictLet() {
  return getToken(myParser::NonStrictLet, 0);
}

tree::TerminalNode* myParser::IdentifierContext::Async() {
  return getToken(myParser::Async, 0);
}


size_t myParser::IdentifierContext::getRuleIndex() const {
  return myParser::RuleIdentifier;
}

void myParser::IdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier(this);
}

void myParser::IdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier(this);
}

myParser::IdentifierContext* myParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 144, myParser::RuleIdentifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(971);
    _la = _input->LA(1);
    if (!(((((_la - 107) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 107)) & 4129) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReservedWordContext ------------------------------------------------------------------

myParser::ReservedWordContext::ReservedWordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::KeywordContext* myParser::ReservedWordContext::keyword() {
  return getRuleContext<myParser::KeywordContext>(0);
}

tree::TerminalNode* myParser::ReservedWordContext::NullLiteral() {
  return getToken(myParser::NullLiteral, 0);
}

tree::TerminalNode* myParser::ReservedWordContext::BooleanLiteral() {
  return getToken(myParser::BooleanLiteral, 0);
}


size_t myParser::ReservedWordContext::getRuleIndex() const {
  return myParser::RuleReservedWord;
}

void myParser::ReservedWordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReservedWord(this);
}

void myParser::ReservedWordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReservedWord(this);
}

myParser::ReservedWordContext* myParser::reservedWord() {
  ReservedWordContext *_localctx = _tracker.createInstance<ReservedWordContext>(_ctx, getState());
  enterRule(_localctx, 146, myParser::RuleReservedWord);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(976);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Break:
      case myParser::Do:
      case myParser::Instanceof:
      case myParser::Typeof:
      case myParser::Case:
      case myParser::Else:
      case myParser::New:
      case myParser::Var:
      case myParser::Catch:
      case myParser::Finally:
      case myParser::Return:
      case myParser::Void:
      case myParser::Continue:
      case myParser::For:
      case myParser::Switch:
      case myParser::While:
      case myParser::Debugger:
      case myParser::Function_:
      case myParser::This:
      case myParser::With:
      case myParser::Default:
      case myParser::If:
      case myParser::Throw:
      case myParser::Delete:
      case myParser::In:
      case myParser::Try:
      case myParser::As:
      case myParser::From:
      case myParser::Class:
      case myParser::Enum:
      case myParser::Extends:
      case myParser::Super:
      case myParser::Const:
      case myParser::Export:
      case myParser::Import:
      case myParser::Async:
      case myParser::Await:
      case myParser::Yield:
      case myParser::Implements:
      case myParser::StrictLet:
      case myParser::NonStrictLet:
      case myParser::Private:
      case myParser::Public:
      case myParser::Interface:
      case myParser::Package:
      case myParser::Protected:
      case myParser::Static: {
        enterOuterAlt(_localctx, 1);
        setState(973);
        keyword();
        break;
      }

      case myParser::NullLiteral: {
        enterOuterAlt(_localctx, 2);
        setState(974);
        match(myParser::NullLiteral);
        break;
      }

      case myParser::BooleanLiteral: {
        enterOuterAlt(_localctx, 3);
        setState(975);
        match(myParser::BooleanLiteral);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeywordContext ------------------------------------------------------------------

myParser::KeywordContext::KeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::KeywordContext::Break() {
  return getToken(myParser::Break, 0);
}

tree::TerminalNode* myParser::KeywordContext::Do() {
  return getToken(myParser::Do, 0);
}

tree::TerminalNode* myParser::KeywordContext::Instanceof() {
  return getToken(myParser::Instanceof, 0);
}

tree::TerminalNode* myParser::KeywordContext::Typeof() {
  return getToken(myParser::Typeof, 0);
}

tree::TerminalNode* myParser::KeywordContext::Case() {
  return getToken(myParser::Case, 0);
}

tree::TerminalNode* myParser::KeywordContext::Else() {
  return getToken(myParser::Else, 0);
}

tree::TerminalNode* myParser::KeywordContext::New() {
  return getToken(myParser::New, 0);
}

tree::TerminalNode* myParser::KeywordContext::Var() {
  return getToken(myParser::Var, 0);
}

tree::TerminalNode* myParser::KeywordContext::Catch() {
  return getToken(myParser::Catch, 0);
}

tree::TerminalNode* myParser::KeywordContext::Finally() {
  return getToken(myParser::Finally, 0);
}

tree::TerminalNode* myParser::KeywordContext::Return() {
  return getToken(myParser::Return, 0);
}

tree::TerminalNode* myParser::KeywordContext::Void() {
  return getToken(myParser::Void, 0);
}

tree::TerminalNode* myParser::KeywordContext::Continue() {
  return getToken(myParser::Continue, 0);
}

tree::TerminalNode* myParser::KeywordContext::For() {
  return getToken(myParser::For, 0);
}

tree::TerminalNode* myParser::KeywordContext::Switch() {
  return getToken(myParser::Switch, 0);
}

tree::TerminalNode* myParser::KeywordContext::While() {
  return getToken(myParser::While, 0);
}

tree::TerminalNode* myParser::KeywordContext::Debugger() {
  return getToken(myParser::Debugger, 0);
}

tree::TerminalNode* myParser::KeywordContext::Function_() {
  return getToken(myParser::Function_, 0);
}

tree::TerminalNode* myParser::KeywordContext::This() {
  return getToken(myParser::This, 0);
}

tree::TerminalNode* myParser::KeywordContext::With() {
  return getToken(myParser::With, 0);
}

tree::TerminalNode* myParser::KeywordContext::Default() {
  return getToken(myParser::Default, 0);
}

tree::TerminalNode* myParser::KeywordContext::If() {
  return getToken(myParser::If, 0);
}

tree::TerminalNode* myParser::KeywordContext::Throw() {
  return getToken(myParser::Throw, 0);
}

tree::TerminalNode* myParser::KeywordContext::Delete() {
  return getToken(myParser::Delete, 0);
}

tree::TerminalNode* myParser::KeywordContext::In() {
  return getToken(myParser::In, 0);
}

tree::TerminalNode* myParser::KeywordContext::Try() {
  return getToken(myParser::Try, 0);
}

tree::TerminalNode* myParser::KeywordContext::Class() {
  return getToken(myParser::Class, 0);
}

tree::TerminalNode* myParser::KeywordContext::Enum() {
  return getToken(myParser::Enum, 0);
}

tree::TerminalNode* myParser::KeywordContext::Extends() {
  return getToken(myParser::Extends, 0);
}

tree::TerminalNode* myParser::KeywordContext::Super() {
  return getToken(myParser::Super, 0);
}

tree::TerminalNode* myParser::KeywordContext::Const() {
  return getToken(myParser::Const, 0);
}

tree::TerminalNode* myParser::KeywordContext::Export() {
  return getToken(myParser::Export, 0);
}

tree::TerminalNode* myParser::KeywordContext::Import() {
  return getToken(myParser::Import, 0);
}

tree::TerminalNode* myParser::KeywordContext::Implements() {
  return getToken(myParser::Implements, 0);
}

myParser::Let_Context* myParser::KeywordContext::let_() {
  return getRuleContext<myParser::Let_Context>(0);
}

tree::TerminalNode* myParser::KeywordContext::Private() {
  return getToken(myParser::Private, 0);
}

tree::TerminalNode* myParser::KeywordContext::Public() {
  return getToken(myParser::Public, 0);
}

tree::TerminalNode* myParser::KeywordContext::Interface() {
  return getToken(myParser::Interface, 0);
}

tree::TerminalNode* myParser::KeywordContext::Package() {
  return getToken(myParser::Package, 0);
}

tree::TerminalNode* myParser::KeywordContext::Protected() {
  return getToken(myParser::Protected, 0);
}

tree::TerminalNode* myParser::KeywordContext::Static() {
  return getToken(myParser::Static, 0);
}

tree::TerminalNode* myParser::KeywordContext::Yield() {
  return getToken(myParser::Yield, 0);
}

tree::TerminalNode* myParser::KeywordContext::Async() {
  return getToken(myParser::Async, 0);
}

tree::TerminalNode* myParser::KeywordContext::Await() {
  return getToken(myParser::Await, 0);
}

tree::TerminalNode* myParser::KeywordContext::From() {
  return getToken(myParser::From, 0);
}

tree::TerminalNode* myParser::KeywordContext::As() {
  return getToken(myParser::As, 0);
}


size_t myParser::KeywordContext::getRuleIndex() const {
  return myParser::RuleKeyword;
}

void myParser::KeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword(this);
}

void myParser::KeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword(this);
}

myParser::KeywordContext* myParser::keyword() {
  KeywordContext *_localctx = _tracker.createInstance<KeywordContext>(_ctx, getState());
  enterRule(_localctx, 148, myParser::RuleKeyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1024);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Break: {
        enterOuterAlt(_localctx, 1);
        setState(978);
        match(myParser::Break);
        break;
      }

      case myParser::Do: {
        enterOuterAlt(_localctx, 2);
        setState(979);
        match(myParser::Do);
        break;
      }

      case myParser::Instanceof: {
        enterOuterAlt(_localctx, 3);
        setState(980);
        match(myParser::Instanceof);
        break;
      }

      case myParser::Typeof: {
        enterOuterAlt(_localctx, 4);
        setState(981);
        match(myParser::Typeof);
        break;
      }

      case myParser::Case: {
        enterOuterAlt(_localctx, 5);
        setState(982);
        match(myParser::Case);
        break;
      }

      case myParser::Else: {
        enterOuterAlt(_localctx, 6);
        setState(983);
        match(myParser::Else);
        break;
      }

      case myParser::New: {
        enterOuterAlt(_localctx, 7);
        setState(984);
        match(myParser::New);
        break;
      }

      case myParser::Var: {
        enterOuterAlt(_localctx, 8);
        setState(985);
        match(myParser::Var);
        break;
      }

      case myParser::Catch: {
        enterOuterAlt(_localctx, 9);
        setState(986);
        match(myParser::Catch);
        break;
      }

      case myParser::Finally: {
        enterOuterAlt(_localctx, 10);
        setState(987);
        match(myParser::Finally);
        break;
      }

      case myParser::Return: {
        enterOuterAlt(_localctx, 11);
        setState(988);
        match(myParser::Return);
        break;
      }

      case myParser::Void: {
        enterOuterAlt(_localctx, 12);
        setState(989);
        match(myParser::Void);
        break;
      }

      case myParser::Continue: {
        enterOuterAlt(_localctx, 13);
        setState(990);
        match(myParser::Continue);
        break;
      }

      case myParser::For: {
        enterOuterAlt(_localctx, 14);
        setState(991);
        match(myParser::For);
        break;
      }

      case myParser::Switch: {
        enterOuterAlt(_localctx, 15);
        setState(992);
        match(myParser::Switch);
        break;
      }

      case myParser::While: {
        enterOuterAlt(_localctx, 16);
        setState(993);
        match(myParser::While);
        break;
      }

      case myParser::Debugger: {
        enterOuterAlt(_localctx, 17);
        setState(994);
        match(myParser::Debugger);
        break;
      }

      case myParser::Function_: {
        enterOuterAlt(_localctx, 18);
        setState(995);
        match(myParser::Function_);
        break;
      }

      case myParser::This: {
        enterOuterAlt(_localctx, 19);
        setState(996);
        match(myParser::This);
        break;
      }

      case myParser::With: {
        enterOuterAlt(_localctx, 20);
        setState(997);
        match(myParser::With);
        break;
      }

      case myParser::Default: {
        enterOuterAlt(_localctx, 21);
        setState(998);
        match(myParser::Default);
        break;
      }

      case myParser::If: {
        enterOuterAlt(_localctx, 22);
        setState(999);
        match(myParser::If);
        break;
      }

      case myParser::Throw: {
        enterOuterAlt(_localctx, 23);
        setState(1000);
        match(myParser::Throw);
        break;
      }

      case myParser::Delete: {
        enterOuterAlt(_localctx, 24);
        setState(1001);
        match(myParser::Delete);
        break;
      }

      case myParser::In: {
        enterOuterAlt(_localctx, 25);
        setState(1002);
        match(myParser::In);
        break;
      }

      case myParser::Try: {
        enterOuterAlt(_localctx, 26);
        setState(1003);
        match(myParser::Try);
        break;
      }

      case myParser::Class: {
        enterOuterAlt(_localctx, 27);
        setState(1004);
        match(myParser::Class);
        break;
      }

      case myParser::Enum: {
        enterOuterAlt(_localctx, 28);
        setState(1005);
        match(myParser::Enum);
        break;
      }

      case myParser::Extends: {
        enterOuterAlt(_localctx, 29);
        setState(1006);
        match(myParser::Extends);
        break;
      }

      case myParser::Super: {
        enterOuterAlt(_localctx, 30);
        setState(1007);
        match(myParser::Super);
        break;
      }

      case myParser::Const: {
        enterOuterAlt(_localctx, 31);
        setState(1008);
        match(myParser::Const);
        break;
      }

      case myParser::Export: {
        enterOuterAlt(_localctx, 32);
        setState(1009);
        match(myParser::Export);
        break;
      }

      case myParser::Import: {
        enterOuterAlt(_localctx, 33);
        setState(1010);
        match(myParser::Import);
        break;
      }

      case myParser::Implements: {
        enterOuterAlt(_localctx, 34);
        setState(1011);
        match(myParser::Implements);
        break;
      }

      case myParser::StrictLet:
      case myParser::NonStrictLet: {
        enterOuterAlt(_localctx, 35);
        setState(1012);
        let_();
        break;
      }

      case myParser::Private: {
        enterOuterAlt(_localctx, 36);
        setState(1013);
        match(myParser::Private);
        break;
      }

      case myParser::Public: {
        enterOuterAlt(_localctx, 37);
        setState(1014);
        match(myParser::Public);
        break;
      }

      case myParser::Interface: {
        enterOuterAlt(_localctx, 38);
        setState(1015);
        match(myParser::Interface);
        break;
      }

      case myParser::Package: {
        enterOuterAlt(_localctx, 39);
        setState(1016);
        match(myParser::Package);
        break;
      }

      case myParser::Protected: {
        enterOuterAlt(_localctx, 40);
        setState(1017);
        match(myParser::Protected);
        break;
      }

      case myParser::Static: {
        enterOuterAlt(_localctx, 41);
        setState(1018);
        match(myParser::Static);
        break;
      }

      case myParser::Yield: {
        enterOuterAlt(_localctx, 42);
        setState(1019);
        match(myParser::Yield);
        break;
      }

      case myParser::Async: {
        enterOuterAlt(_localctx, 43);
        setState(1020);
        match(myParser::Async);
        break;
      }

      case myParser::Await: {
        enterOuterAlt(_localctx, 44);
        setState(1021);
        match(myParser::Await);
        break;
      }

      case myParser::From: {
        enterOuterAlt(_localctx, 45);
        setState(1022);
        match(myParser::From);
        break;
      }

      case myParser::As: {
        enterOuterAlt(_localctx, 46);
        setState(1023);
        match(myParser::As);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Let_Context ------------------------------------------------------------------

myParser::Let_Context::Let_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Let_Context::NonStrictLet() {
  return getToken(myParser::NonStrictLet, 0);
}

tree::TerminalNode* myParser::Let_Context::StrictLet() {
  return getToken(myParser::StrictLet, 0);
}


size_t myParser::Let_Context::getRuleIndex() const {
  return myParser::RuleLet_;
}

void myParser::Let_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLet_(this);
}

void myParser::Let_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLet_(this);
}

myParser::Let_Context* myParser::let_() {
  Let_Context *_localctx = _tracker.createInstance<Let_Context>(_ctx, getState());
  enterRule(_localctx, 150, myParser::RuleLet_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1026);
    _la = _input->LA(1);
    if (!(_la == myParser::StrictLet

    || _la == myParser::NonStrictLet)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EosContext ------------------------------------------------------------------

myParser::EosContext::EosContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::EosContext::SemiColon() {
  return getToken(myParser::SemiColon, 0);
}

tree::TerminalNode* myParser::EosContext::EOF() {
  return getToken(myParser::EOF, 0);
}


size_t myParser::EosContext::getRuleIndex() const {
  return myParser::RuleEos;
}

void myParser::EosContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEos(this);
}

void myParser::EosContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEos(this);
}

myParser::EosContext* myParser::eos() {
  EosContext *_localctx = _tracker.createInstance<EosContext>(_ctx, getState());
  enterRule(_localctx, 152, myParser::RuleEos);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1032);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 112, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1028);
      match(myParser::SemiColon);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1029);
      match(myParser::EOF);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1030);

      if (!(this.lineTerminatorAhead())) throw FailedPredicateException(this, "this.lineTerminatorAhead()");
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1031);

      if (!(this.closeBrace())) throw FailedPredicateException(this, "this.closeBrace()");
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool myParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 19: return expressionStatementSempred(antlrcpp::downCast<ExpressionStatementContext *>(context), predicateIndex);
    case 21: return iterationStatementSempred(antlrcpp::downCast<IterationStatementContext *>(context), predicateIndex);
    case 23: return continueStatementSempred(antlrcpp::downCast<ContinueStatementContext *>(context), predicateIndex);
    case 24: return breakStatementSempred(antlrcpp::downCast<BreakStatementContext *>(context), predicateIndex);
    case 25: return returnStatementSempred(antlrcpp::downCast<ReturnStatementContext *>(context), predicateIndex);
    case 26: return yieldStatementSempred(antlrcpp::downCast<YieldStatementContext *>(context), predicateIndex);
    case 34: return throwStatementSempred(antlrcpp::downCast<ThrowStatementContext *>(context), predicateIndex);
    case 42: return classElementSempred(antlrcpp::downCast<ClassElementContext *>(context), predicateIndex);
    case 57: return singleExpressionSempred(antlrcpp::downCast<SingleExpressionContext *>(context), predicateIndex);
    case 69: return getterSempred(antlrcpp::downCast<GetterContext *>(context), predicateIndex);
    case 70: return setterSempred(antlrcpp::downCast<SetterContext *>(context), predicateIndex);
    case 76: return eosSempred(antlrcpp::downCast<EosContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool myParser::expressionStatementSempred(ExpressionStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return this.notOpenBraceAndNotFunction();

  default:
    break;
  }
  return true;
}

bool myParser::iterationStatementSempred(IterationStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return this.p("of");

  default:
    break;
  }
  return true;
}

bool myParser::continueStatementSempred(ContinueStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 2: return this.notLineTerminator();

  default:
    break;
  }
  return true;
}

bool myParser::breakStatementSempred(BreakStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 3: return this.notLineTerminator();

  default:
    break;
  }
  return true;
}

bool myParser::returnStatementSempred(ReturnStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 4: return this.notLineTerminator();

  default:
    break;
  }
  return true;
}

bool myParser::yieldStatementSempred(YieldStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 5: return this.notLineTerminator();

  default:
    break;
  }
  return true;
}

bool myParser::throwStatementSempred(ThrowStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 6: return this.notLineTerminator();

  default:
    break;
  }
  return true;
}

bool myParser::classElementSempred(ClassElementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 7: return this.n("static");

  default:
    break;
  }
  return true;
}

bool myParser::singleExpressionSempred(SingleExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 8: return precpred(_ctx, 46);
    case 9: return precpred(_ctx, 27);
    case 10: return precpred(_ctx, 26);
    case 11: return precpred(_ctx, 25);
    case 12: return precpred(_ctx, 24);
    case 13: return precpred(_ctx, 23);
    case 14: return precpred(_ctx, 22);
    case 15: return precpred(_ctx, 21);
    case 16: return precpred(_ctx, 20);
    case 17: return precpred(_ctx, 19);
    case 18: return precpred(_ctx, 18);
    case 19: return precpred(_ctx, 17);
    case 20: return precpred(_ctx, 16);
    case 21: return precpred(_ctx, 15);
    case 22: return precpred(_ctx, 14);
    case 23: return precpred(_ctx, 13);
    case 24: return precpred(_ctx, 12);
    case 25: return precpred(_ctx, 11);
    case 26: return precpred(_ctx, 45);
    case 27: return precpred(_ctx, 44);
    case 28: return precpred(_ctx, 41);
    case 29: return precpred(_ctx, 39);
    case 30: return this.notLineTerminator();
    case 31: return precpred(_ctx, 38);
    case 32: return this.notLineTerminator();
    case 33: return precpred(_ctx, 9);

  default:
    break;
  }
  return true;
}

bool myParser::getterSempred(GetterContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 34: return this.n("get");

  default:
    break;
  }
  return true;
}

bool myParser::setterSempred(SetterContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 35: return this.n("set");

  default:
    break;
  }
  return true;
}

bool myParser::eosSempred(EosContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 36: return this.lineTerminatorAhead();
    case 37: return this.closeBrace();

  default:
    break;
  }
  return true;
}

void myParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  myparserParserInitialize();
#else
  ::antlr4::internal::call_once(myparserParserOnceFlag, myparserParserInitialize);
#endif
}

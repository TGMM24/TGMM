
// Generated from vba.g4 by ANTLR 4.13.0


#include "vbaListener.h"

#include "vbaParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct VbaParserStaticData final {
  VbaParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  VbaParserStaticData(const VbaParserStaticData&) = delete;
  VbaParserStaticData(VbaParserStaticData&&) = delete;
  VbaParserStaticData& operator=(const VbaParserStaticData&) = delete;
  VbaParserStaticData& operator=(VbaParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag vbaParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
VbaParserStaticData *vbaParserStaticData = nullptr;

void vbaParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (vbaParserStaticData != nullptr) {
    return;
  }
#else
  assert(vbaParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<VbaParserStaticData>(
    std::vector<std::string>{
      "startRule", "module", "moduleHeader", "moduleConfig", "moduleConfigElement", 
      "moduleAttributes", "moduleDeclarations", "moduleOption", "moduleDeclarationsElement", 
      "macroStmt", "moduleBody", "moduleBodyElement", "attributeStmt", "block", 
      "blockStmt", "appactivateStmt", "beepStmt", "chdirStmt", "chdriveStmt", 
      "closeStmt", "constStmt", "constSubStmt", "dateStmt", "declareStmt", 
      "deftypeStmt", "deleteSettingStmt", "doLoopStmt", "endStmt", "enumerationStmt", 
      "enumerationStmt_Constant", "eraseStmt", "errorStmt", "eventStmt", 
      "exitStmt", "filecopyStmt", "forEachStmt", "forNextStmt", "functionStmt", 
      "getStmt", "goSubStmt", "goToStmt", "ifThenElseStmt", "ifBlockStmt", 
      "ifConditionStmt", "ifElseIfBlockStmt", "ifElseBlockStmt", "implementsStmt", 
      "inputStmt", "killStmt", "letStmt", "lineInputStmt", "loadStmt", "lockStmt", 
      "lsetStmt", "macroConstStmt", "macroIfThenElseStmt", "macroIfBlockStmt", 
      "macroElseIfBlockStmt", "macroElseBlockStmt", "midStmt", "mkdirStmt", 
      "nameStmt", "onErrorStmt", "onGoToStmt", "onGoSubStmt", "openStmt", 
      "outputList", "outputList_Expression", "printStmt", "propertyGetStmt", 
      "propertySetStmt", "propertyLetStmt", "putStmt", "raiseEventStmt", 
      "randomizeStmt", "redimStmt", "redimSubStmt", "resetStmt", "resumeStmt", 
      "returnStmt", "rmdirStmt", "rsetStmt", "savepictureStmt", "saveSettingStmt", 
      "seekStmt", "selectCaseStmt", "sC_Selection", "sC_Case", "sC_Cond", 
      "sendkeysStmt", "setattrStmt", "setStmt", "stopStmt", "subStmt", "timeStmt", 
      "typeStmt", "typeStmt_Element", "typeOfStmt", "unloadStmt", "unlockStmt", 
      "valueStmt", "variableStmt", "variableListStmt", "variableSubStmt", 
      "whileWendStmt", "widthStmt", "withStmt", "writeStmt", "fileNumber", 
      "explicitCallStmt", "eCS_ProcedureCall", "eCS_MemberProcedureCall", 
      "implicitCallStmt_InBlock", "iCS_B_MemberProcedureCall", "iCS_B_ProcedureCall", 
      "implicitCallStmt_InStmt", "iCS_S_VariableOrProcedureCall", "iCS_S_ProcedureOrArrayCall", 
      "iCS_S_MembersCall", "iCS_S_MemberCall", "iCS_S_DictionaryCall", "argsCall", 
      "argCall", "dictionaryCallStmt", "argList", "arg", "argDefaultValue", 
      "subscripts", "subscript_", "ambiguousIdentifier", "asTypeClause", 
      "baseType", "certainIdentifier", "comparisonOperator", "complexType", 
      "fieldLength", "letterrange", "lineLabel", "literal", "type_", "typeHint", 
      "visibility", "ambiguousKeyword", "remComment", "comment", "endOfLine", 
      "endOfStatement"
    },
    std::vector<std::string>{
      "", "','", "';'", "'#'", "'.'", "'!'", "'%'", "'@'", "'$'", "'ACCESS'", 
      "'ADDRESSOF'", "'ALIAS'", "'AND'", "'ATTRIBUTE'", "'APPACTIVATE'", 
      "'APPEND'", "'AS'", "'BEGIN'", "'BEEP'", "'BINARY'", "'BOOLEAN'", 
      "'BYVAL'", "'BYREF'", "'BYTE'", "'CALL'", "'CASE'", "'CHDIR'", "'CHDRIVE'", 
      "'CLASS'", "'CLOSE'", "'COLLECTION'", "'CONST'", "'DATABASE'", "'DATE'", 
      "'DECLARE'", "'DEFBOOL'", "'DEFBYTE'", "'DEFDATE'", "'DEFDBL'", "'DEFDEC'", 
      "'DEFCUR'", "'DEFINT'", "'DEFLNG'", "'DEFOBJ'", "'DEFSNG'", "'DEFSTR'", 
      "'DEFVAR'", "'DELETESETTING'", "'DIM'", "'DO'", "'DOUBLE'", "'EACH'", 
      "'ELSE'", "'ELSEIF'", "", "", "", "", "", "", "", "", "'END'", "'ENUM'", 
      "'EQV'", "'ERASE'", "'ERROR'", "'EVENT'", "", "", "", "", "", "'FALSE'", 
      "'FILECOPY'", "'FRIEND'", "'FOR'", "'FUNCTION'", "'GET'", "'GLOBAL'", 
      "'GOSUB'", "'GOTO'", "'IF'", "'IMP'", "'IMPLEMENTS'", "'IN'", "'INPUT'", 
      "'IS'", "'INTEGER'", "'KILL'", "'LOAD'", "'LOCK'", "'LONG'", "'LOOP'", 
      "'LEN'", "'LET'", "'LIB'", "'LIKE'", "", "", "", "", "'LSET'", "'#CONST'", 
      "'#IF'", "'#ELSEIF'", "'#ELSE'", "", "'ME'", "'MID'", "'MKDIR'", "'MOD'", 
      "'NAME'", "'NEXT'", "'NEW'", "'NOT'", "'NOTHING'", "'NULL'", "'ON'", 
      "", "", "'OPEN'", "'OPTIONAL'", "", "", "", "", "'OR'", "'OUTPUT'", 
      "'PARAMARRAY'", "'PRESERVE'", "'PRINT'", "'PRIVATE'", "", "", "", 
      "'PTRSAFE'", "'PUBLIC'", "'PUT'", "'RANDOM'", "'RANDOMIZE'", "'RAISEEVENT'", 
      "'READ'", "", "'REDIM'", "'REM'", "'RESET'", "'RESUME'", "'RETURN'", 
      "'RMDIR'", "'RSET'", "'SAVEPICTURE'", "'SAVESETTING'", "'SEEK'", "'SELECT'", 
      "'SENDKEYS'", "'SET'", "'SETATTR'", "'SHARED'", "'SINGLE'", "'SPC'", 
      "'STATIC'", "'STEP'", "'STOP'", "'STRING'", "'SUB'", "'TAB'", "'TEXT'", 
      "'THEN'", "'TIME'", "'TO'", "'TRUE'", "'TYPE'", "'TYPEOF'", "'UNLOAD'", 
      "'UNLOCK'", "'UNTIL'", "'VARIANT'", "'VERSION'", "'WEND'", "'WHILE'", 
      "'WIDTH'", "'WITH'", "'WITHEVENTS'", "'WRITE'", "'XOR'", "'&'", "':='", 
      "", "'='", "'>='", "'>'", "'<='", "'('", "'<'", "'-'", "'-='", "'*'", 
      "'<>'", "'+'", "'+='", "'^'", "')'", "'['", "']'", "", "", "", "", 
      "", "", "", "", "", "", "", "'''", "':'", "'_'"
    },
    std::vector<std::string>{
      "", "", "", "", "", "", "", "", "", "ACCESS", "ADDRESSOF", "ALIAS", 
      "AND", "ATTRIBUTE", "APPACTIVATE", "APPEND", "AS", "BEGIN", "BEEP", 
      "BINARY", "BOOLEAN", "BYVAL", "BYREF", "BYTE", "CALL", "CASE", "CHDIR", 
      "CHDRIVE", "CLASS", "CLOSE", "COLLECTION", "CONST", "DATABASE", "DATE", 
      "DECLARE", "DEFBOOL", "DEFBYTE", "DEFDATE", "DEFDBL", "DEFDEC", "DEFCUR", 
      "DEFINT", "DEFLNG", "DEFOBJ", "DEFSNG", "DEFSTR", "DEFVAR", "DELETESETTING", 
      "DIM", "DO", "DOUBLE", "EACH", "ELSE", "ELSEIF", "END_ENUM", "END_FUNCTION", 
      "END_IF", "END_PROPERTY", "END_SELECT", "END_SUB", "END_TYPE", "END_WITH", 
      "END", "ENUM", "EQV", "ERASE", "ERROR", "EVENT", "EXIT_DO", "EXIT_FOR", 
      "EXIT_FUNCTION", "EXIT_PROPERTY", "EXIT_SUB", "FALSE", "FILECOPY", 
      "FRIEND", "FOR", "FUNCTION", "GET", "GLOBAL", "GOSUB", "GOTO", "IF", 
      "IMP", "IMPLEMENTS", "IN", "INPUT", "IS", "INTEGER", "KILL", "LOAD", 
      "LOCK", "LONG", "LOOP", "LEN", "LET", "LIB", "LIKE", "LINE_INPUT", 
      "LOCK_READ", "LOCK_WRITE", "LOCK_READ_WRITE", "LSET", "MACRO_CONST", 
      "MACRO_IF", "MACRO_ELSEIF", "MACRO_ELSE", "MACRO_END_IF", "ME", "MID", 
      "MKDIR", "MOD", "NAME", "NEXT", "NEW", "NOT", "NOTHING", "NULL_", 
      "ON", "ON_ERROR", "ON_LOCAL_ERROR", "OPEN", "OPTIONAL", "OPTION_BASE", 
      "OPTION_EXPLICIT", "OPTION_COMPARE", "OPTION_PRIVATE_MODULE", "OR", 
      "OUTPUT", "PARAMARRAY", "PRESERVE", "PRINT", "PRIVATE", "PROPERTY_GET", 
      "PROPERTY_LET", "PROPERTY_SET", "PTRSAFE", "PUBLIC", "PUT", "RANDOM", 
      "RANDOMIZE", "RAISEEVENT", "READ", "READ_WRITE", "REDIM", "REM", "RESET", 
      "RESUME", "RETURN", "RMDIR", "RSET", "SAVEPICTURE", "SAVESETTING", 
      "SEEK", "SELECT", "SENDKEYS", "SET", "SETATTR", "SHARED", "SINGLE", 
      "SPC", "STATIC", "STEP", "STOP", "STRING", "SUB", "TAB", "TEXT", "THEN", 
      "TIME", "TO", "TRUE", "TYPE", "TYPEOF", "UNLOAD", "UNLOCK", "UNTIL", 
      "VARIANT", "VERSION", "WEND", "WHILE", "WIDTH", "WITH", "WITHEVENTS", 
      "WRITE", "XOR", "AMPERSAND", "ASSIGN", "DIV", "EQ", "GEQ", "GT", "LEQ", 
      "LPAREN", "LT", "MINUS", "MINUS_EQ", "MULT", "NEQ", "PLUS", "PLUS_EQ", 
      "POW", "RPAREN", "L_SQUARE_BRACKET", "R_SQUARE_BRACKET", "STRINGLITERAL", 
      "OCTLITERAL", "HEXLITERAL", "SHORTLITERAL", "INTEGERLITERAL", "DOUBLELITERAL", 
      "DATELITERAL", "LINE_CONTINUATION", "NEWLINE", "REMCOMMENT", "COMMENT", 
      "SINGLEQUOTE", "COLON", "UNDERSCORE", "WS", "IDENTIFIER"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,220,2574,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,
  	7,134,2,135,7,135,2,136,7,136,2,137,7,137,2,138,7,138,2,139,7,139,2,140,
  	7,140,2,141,7,141,2,142,7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,
  	7,146,1,0,1,0,1,0,1,1,3,1,299,8,1,1,1,5,1,302,8,1,10,1,12,1,305,9,1,1,
  	1,1,1,5,1,309,8,1,10,1,12,1,312,9,1,3,1,314,8,1,1,1,3,1,317,8,1,1,1,5,
  	1,320,8,1,10,1,12,1,323,9,1,1,1,3,1,326,8,1,1,1,5,1,329,8,1,10,1,12,1,
  	332,9,1,1,1,3,1,335,8,1,1,1,5,1,338,8,1,10,1,12,1,341,9,1,1,1,3,1,344,
  	8,1,1,1,5,1,347,8,1,10,1,12,1,350,9,1,1,1,3,1,353,8,1,1,2,1,2,1,2,1,2,
  	1,2,1,2,1,3,1,3,5,3,363,8,3,10,3,12,3,366,9,3,1,3,4,3,369,8,3,11,3,12,
  	3,370,1,3,1,3,1,4,1,4,3,4,377,8,4,1,4,1,4,3,4,381,8,4,1,4,1,4,5,4,385,
  	8,4,10,4,12,4,388,9,4,1,5,1,5,4,5,392,8,5,11,5,12,5,393,4,5,396,8,5,11,
  	5,12,5,397,1,6,1,6,4,6,402,8,6,11,6,12,6,403,1,6,1,6,5,6,408,8,6,10,6,
  	12,6,411,9,6,1,6,5,6,414,8,6,10,6,12,6,417,9,6,1,7,1,7,1,7,1,7,1,7,1,
  	7,1,7,1,7,3,7,427,8,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,3,8,439,
  	8,8,1,9,1,9,3,9,443,8,9,1,10,1,10,4,10,447,8,10,11,10,12,10,448,1,10,
  	1,10,5,10,453,8,10,10,10,12,10,456,9,10,1,10,5,10,459,8,10,10,10,12,10,
  	462,9,10,1,11,1,11,1,11,1,11,1,11,1,11,3,11,470,8,11,1,12,1,12,1,12,1,
  	12,3,12,476,8,12,1,12,1,12,3,12,480,8,12,1,12,1,12,3,12,484,8,12,1,12,
  	1,12,3,12,488,8,12,1,12,5,12,491,8,12,10,12,12,12,494,9,12,1,13,1,13,
  	1,13,1,13,5,13,500,8,13,10,13,12,13,503,9,13,1,13,1,13,1,14,1,14,1,14,
  	1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,
  	1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,
  	1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,
  	1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,
  	1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,3,14,575,8,14,1,15,1,15,
  	1,15,1,15,3,15,581,8,15,1,15,1,15,3,15,585,8,15,1,15,3,15,588,8,15,1,
  	16,1,16,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,18,1,19,1,19,1,19,1,19,3,
  	19,604,8,19,1,19,1,19,3,19,608,8,19,1,19,5,19,611,8,19,10,19,12,19,614,
  	9,19,3,19,616,8,19,1,20,1,20,1,20,3,20,621,8,20,1,20,1,20,1,20,1,20,3,
  	20,627,8,20,1,20,1,20,3,20,631,8,20,1,20,5,20,634,8,20,10,20,12,20,637,
  	9,20,1,21,1,21,3,21,641,8,21,1,21,1,21,3,21,645,8,21,1,21,3,21,648,8,
  	21,1,21,1,21,3,21,652,8,21,1,21,1,21,1,22,1,22,3,22,658,8,22,1,22,1,22,
  	3,22,662,8,22,1,22,1,22,1,23,1,23,1,23,3,23,669,8,23,1,23,1,23,1,23,1,
  	23,3,23,675,8,23,1,23,1,23,3,23,679,8,23,1,23,3,23,682,8,23,1,23,1,23,
  	1,23,3,23,687,8,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,3,23,697,8,
  	23,1,23,3,23,700,8,23,1,23,3,23,703,8,23,1,23,1,23,3,23,707,8,23,1,24,
  	1,24,1,24,1,24,3,24,713,8,24,1,24,1,24,3,24,717,8,24,1,24,5,24,720,8,
  	24,10,24,12,24,723,9,24,1,25,1,25,1,25,1,25,3,25,729,8,25,1,25,1,25,3,
  	25,733,8,25,1,25,1,25,3,25,737,8,25,1,25,1,25,3,25,741,8,25,1,25,3,25,
  	744,8,25,1,26,1,26,1,26,3,26,749,8,26,1,26,1,26,1,26,1,26,1,26,1,26,1,
  	26,1,26,1,26,3,26,760,8,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,
  	26,1,26,1,26,3,26,773,8,26,1,27,1,27,1,28,1,28,1,28,3,28,780,8,28,1,28,
  	1,28,1,28,1,28,1,28,5,28,787,8,28,10,28,12,28,790,9,28,1,28,1,28,1,29,
  	1,29,3,29,796,8,29,1,29,1,29,3,29,800,8,29,1,29,3,29,803,8,29,1,29,1,
  	29,1,30,1,30,1,30,1,30,1,30,3,30,812,8,30,1,30,5,30,815,8,30,10,30,12,
  	30,818,9,30,1,31,1,31,1,31,1,31,1,32,1,32,1,32,3,32,827,8,32,1,32,1,32,
  	1,32,1,32,3,32,833,8,32,1,32,1,32,1,33,1,33,1,34,1,34,1,34,1,34,3,34,
  	843,8,34,1,34,1,34,3,34,847,8,34,1,34,1,34,1,35,1,35,1,35,1,35,1,35,1,
  	35,3,35,857,8,35,1,35,1,35,1,35,1,35,1,35,1,35,3,35,865,8,35,1,35,1,35,
  	1,35,3,35,870,8,35,1,36,1,36,1,36,1,36,3,36,876,8,36,1,36,1,36,3,36,880,
  	8,36,1,36,3,36,883,8,36,1,36,1,36,3,36,887,8,36,1,36,1,36,1,36,1,36,1,
  	36,1,36,1,36,1,36,1,36,3,36,898,8,36,1,36,1,36,3,36,902,8,36,1,36,1,36,
  	1,36,3,36,907,8,36,1,37,1,37,1,37,3,37,912,8,37,1,37,1,37,3,37,916,8,
  	37,1,37,1,37,3,37,920,8,37,1,37,1,37,3,37,924,8,37,1,37,3,37,927,8,37,
  	1,37,3,37,930,8,37,1,37,3,37,933,8,37,1,37,3,37,936,8,37,1,37,1,37,3,
  	37,940,8,37,1,37,1,37,1,38,1,38,1,38,1,38,3,38,948,8,38,1,38,1,38,3,38,
  	952,8,38,1,38,3,38,955,8,38,1,38,3,38,958,8,38,1,38,1,38,3,38,962,8,38,
  	1,38,1,38,1,39,1,39,1,39,1,39,1,40,1,40,1,40,1,40,1,41,1,41,1,41,1,41,
  	1,41,1,41,1,41,1,41,1,41,1,41,1,41,3,41,985,8,41,1,41,1,41,5,41,989,8,
  	41,10,41,12,41,992,9,41,1,41,3,41,995,8,41,1,41,1,41,3,41,999,8,41,1,
  	42,1,42,1,42,1,42,1,42,1,42,1,42,3,42,1008,8,42,1,43,1,43,1,44,1,44,1,
  	44,1,44,1,44,1,44,1,44,3,44,1019,8,44,1,45,1,45,1,45,3,45,1024,8,45,1,
  	46,1,46,1,46,1,46,1,47,1,47,1,47,1,47,3,47,1034,8,47,1,47,1,47,3,47,1038,
  	8,47,1,47,4,47,1041,8,47,11,47,12,47,1042,1,48,1,48,1,48,1,48,1,49,1,
  	49,3,49,1051,8,49,1,49,1,49,3,49,1055,8,49,1,49,1,49,3,49,1059,8,49,1,
  	49,1,49,1,50,1,50,1,50,1,50,3,50,1067,8,50,1,50,1,50,3,50,1071,8,50,1,
  	50,1,50,1,51,1,51,1,51,1,51,1,52,1,52,1,52,1,52,3,52,1083,8,52,1,52,1,
  	52,3,52,1087,8,52,1,52,1,52,1,52,1,52,1,52,3,52,1094,8,52,3,52,1096,8,
  	52,1,53,1,53,1,53,1,53,3,53,1102,8,53,1,53,1,53,3,53,1106,8,53,1,53,1,
  	53,1,54,1,54,3,54,1112,8,54,1,54,1,54,3,54,1116,8,54,1,54,1,54,3,54,1120,
  	8,54,1,54,1,54,1,55,1,55,5,55,1126,8,55,10,55,12,55,1129,9,55,1,55,3,
  	55,1132,8,55,1,55,1,55,1,56,1,56,3,56,1138,8,56,1,56,1,56,1,56,1,56,1,
  	56,1,56,1,56,5,56,1147,8,56,10,56,12,56,1150,9,56,1,57,1,57,3,57,1154,
  	8,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,5,57,1163,8,57,10,57,12,57,1166,
  	9,57,1,58,1,58,1,58,1,58,1,58,5,58,1173,8,58,10,58,12,58,1176,9,58,1,
  	59,1,59,3,59,1180,8,59,1,59,1,59,3,59,1184,8,59,1,59,1,59,3,59,1188,8,
  	59,1,59,1,59,1,60,1,60,1,60,1,60,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,
  	61,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,3,62,1212,8,62,1,63,1,63,1,
  	63,1,63,1,63,1,63,1,63,1,63,3,63,1222,8,63,1,63,1,63,3,63,1226,8,63,1,
  	63,5,63,1229,8,63,10,63,12,63,1232,9,63,1,64,1,64,1,64,1,64,1,64,1,64,
  	1,64,1,64,3,64,1242,8,64,1,64,1,64,3,64,1246,8,64,1,64,5,64,1249,8,64,
  	10,64,12,64,1252,9,64,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,
  	65,1,65,3,65,1265,8,65,1,65,1,65,3,65,1269,8,65,1,65,1,65,1,65,1,65,1,
  	65,1,65,1,65,3,65,1278,8,65,1,65,1,65,3,65,1282,8,65,1,65,3,65,1285,8,
  	65,1,66,1,66,3,66,1289,8,66,1,66,1,66,3,66,1293,8,66,1,66,3,66,1296,8,
  	66,5,66,1298,8,66,10,66,12,66,1301,9,66,1,66,3,66,1304,8,66,1,66,3,66,
  	1307,8,66,1,66,1,66,3,66,1311,8,66,1,66,3,66,1314,8,66,4,66,1316,8,66,
  	11,66,12,66,1317,3,66,1320,8,66,1,67,1,67,1,67,3,67,1325,8,67,1,67,1,
  	67,3,67,1329,8,67,1,67,1,67,3,67,1333,8,67,1,67,1,67,3,67,1337,8,67,3,
  	67,1339,8,67,1,68,1,68,1,68,1,68,3,68,1345,8,68,1,68,1,68,3,68,1349,8,
  	68,1,68,3,68,1352,8,68,1,69,1,69,1,69,3,69,1357,8,69,1,69,1,69,3,69,1361,
  	8,69,1,69,1,69,1,69,1,69,3,69,1367,8,69,1,69,3,69,1370,8,69,1,69,3,69,
  	1373,8,69,1,69,1,69,3,69,1377,8,69,1,69,1,69,3,69,1381,8,69,1,69,1,69,
  	1,70,1,70,1,70,3,70,1388,8,70,1,70,1,70,3,70,1392,8,70,1,70,1,70,1,70,
  	1,70,3,70,1398,8,70,1,70,3,70,1401,8,70,1,70,1,70,3,70,1405,8,70,1,70,
  	1,70,1,71,1,71,1,71,3,71,1412,8,71,1,71,1,71,3,71,1416,8,71,1,71,1,71,
  	1,71,1,71,3,71,1422,8,71,1,71,3,71,1425,8,71,1,71,1,71,3,71,1429,8,71,
  	1,71,1,71,1,72,1,72,1,72,1,72,3,72,1437,8,72,1,72,1,72,3,72,1441,8,72,
  	1,72,3,72,1444,8,72,1,72,3,72,1447,8,72,1,72,1,72,3,72,1451,8,72,1,72,
  	1,72,1,73,1,73,1,73,1,73,3,73,1459,8,73,1,73,1,73,3,73,1463,8,73,1,73,
  	1,73,3,73,1467,8,73,3,73,1469,8,73,1,73,3,73,1472,8,73,1,74,1,74,1,74,
  	3,74,1477,8,74,1,75,1,75,1,75,1,75,3,75,1483,8,75,1,75,1,75,3,75,1487,
  	8,75,1,75,1,75,3,75,1491,8,75,1,75,5,75,1494,8,75,10,75,12,75,1497,9,
  	75,1,76,1,76,3,76,1501,8,76,1,76,1,76,3,76,1505,8,76,1,76,1,76,3,76,1509,
  	8,76,1,76,1,76,1,76,3,76,1514,8,76,1,77,1,77,1,78,1,78,1,78,1,78,3,78,
  	1522,8,78,3,78,1524,8,78,1,79,1,79,1,80,1,80,1,80,1,80,1,81,1,81,1,81,
  	1,81,3,81,1536,8,81,1,81,1,81,3,81,1540,8,81,1,81,1,81,1,82,1,82,1,82,
  	1,82,3,82,1548,8,82,1,82,1,82,3,82,1552,8,82,1,82,1,82,1,83,1,83,1,83,
  	1,83,3,83,1560,8,83,1,83,1,83,3,83,1564,8,83,1,83,1,83,3,83,1568,8,83,
  	1,83,1,83,3,83,1572,8,83,1,83,1,83,3,83,1576,8,83,1,83,1,83,3,83,1580,
  	8,83,1,83,1,83,1,84,1,84,1,84,1,84,3,84,1588,8,84,1,84,1,84,3,84,1592,
  	8,84,1,84,1,84,1,85,1,85,1,85,1,85,1,85,1,85,1,85,5,85,1603,8,85,10,85,
  	12,85,1606,9,85,1,85,1,85,1,86,1,86,3,86,1612,8,86,1,86,1,86,3,86,1616,
  	8,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,3,86,1627,8,86,1,87,
  	1,87,1,87,1,87,1,87,3,87,1634,8,87,1,88,1,88,1,88,3,88,1639,8,88,1,88,
  	1,88,3,88,1643,8,88,1,88,5,88,1646,8,88,10,88,12,88,1649,9,88,3,88,1651,
  	8,88,1,89,1,89,1,89,1,89,3,89,1657,8,89,1,89,1,89,3,89,1661,8,89,1,89,
  	3,89,1664,8,89,1,90,1,90,1,90,1,90,3,90,1670,8,90,1,90,1,90,3,90,1674,
  	8,90,1,90,1,90,1,91,1,91,1,91,1,91,3,91,1682,8,91,1,91,1,91,3,91,1686,
  	8,91,1,91,1,91,1,92,1,92,1,93,1,93,1,93,3,93,1695,8,93,1,93,1,93,3,93,
  	1699,8,93,1,93,1,93,3,93,1703,8,93,1,93,1,93,3,93,1707,8,93,1,93,3,93,
  	1710,8,93,1,93,1,93,3,93,1714,8,93,1,93,1,93,1,94,1,94,3,94,1720,8,94,
  	1,94,1,94,3,94,1724,8,94,1,94,1,94,1,95,1,95,1,95,3,95,1731,8,95,1,95,
  	1,95,1,95,1,95,1,95,5,95,1738,8,95,10,95,12,95,1741,9,95,1,95,1,95,1,
  	96,1,96,3,96,1747,8,96,1,96,1,96,3,96,1751,8,96,1,96,3,96,1754,8,96,1,
  	96,3,96,1757,8,96,1,96,3,96,1760,8,96,1,96,1,96,3,96,1764,8,96,1,96,1,
  	96,1,97,1,97,1,97,1,97,1,97,1,97,1,97,3,97,1775,8,97,1,98,1,98,1,98,1,
  	98,1,99,1,99,1,99,1,99,3,99,1785,8,99,1,99,1,99,3,99,1789,8,99,1,99,1,
  	99,1,99,1,99,1,99,3,99,1796,8,99,3,99,1798,8,99,1,100,1,100,1,100,1,100,
  	1,100,3,100,1805,8,100,1,100,1,100,3,100,1809,8,100,1,100,1,100,3,100,
  	1813,8,100,1,100,5,100,1816,8,100,10,100,12,100,1819,9,100,1,100,1,100,
  	1,100,1,100,3,100,1825,8,100,1,100,1,100,1,100,1,100,1,100,3,100,1832,
  	8,100,1,100,1,100,1,100,3,100,1837,8,100,1,100,1,100,3,100,1841,8,100,
  	1,100,1,100,1,100,1,100,3,100,1847,8,100,1,100,1,100,1,100,3,100,1852,
  	8,100,1,100,1,100,1,100,3,100,1857,8,100,1,100,3,100,1860,8,100,1,100,
  	1,100,3,100,1864,8,100,1,100,1,100,3,100,1868,8,100,1,100,1,100,1,100,
  	3,100,1873,8,100,1,100,1,100,3,100,1877,8,100,1,100,1,100,1,100,3,100,
  	1882,8,100,1,100,1,100,3,100,1886,8,100,1,100,1,100,1,100,3,100,1891,
  	8,100,1,100,1,100,3,100,1895,8,100,1,100,1,100,1,100,3,100,1900,8,100,
  	1,100,1,100,3,100,1904,8,100,1,100,1,100,1,100,3,100,1909,8,100,1,100,
  	1,100,3,100,1913,8,100,1,100,1,100,1,100,3,100,1918,8,100,1,100,1,100,
  	3,100,1922,8,100,1,100,1,100,1,100,3,100,1927,8,100,1,100,1,100,3,100,
  	1931,8,100,1,100,1,100,1,100,3,100,1936,8,100,1,100,1,100,3,100,1940,
  	8,100,1,100,1,100,1,100,3,100,1945,8,100,1,100,1,100,3,100,1949,8,100,
  	1,100,1,100,1,100,3,100,1954,8,100,1,100,1,100,3,100,1958,8,100,1,100,
  	5,100,1961,8,100,10,100,12,100,1964,9,100,1,101,1,101,1,101,3,101,1969,
  	8,101,1,101,1,101,1,101,3,101,1974,8,101,1,101,1,101,1,102,1,102,3,102,
  	1980,8,102,1,102,1,102,3,102,1984,8,102,1,102,5,102,1987,8,102,10,102,
  	12,102,1990,9,102,1,103,1,103,3,103,1994,8,103,1,103,1,103,3,103,1998,
  	8,103,1,103,1,103,3,103,2002,8,103,3,103,2004,8,103,1,103,1,103,3,103,
  	2008,8,103,3,103,2010,8,103,1,103,3,103,2013,8,103,1,103,1,103,3,103,
  	2017,8,103,1,104,1,104,1,104,1,104,1,104,3,104,2024,8,104,1,104,1,104,
  	1,105,1,105,1,105,1,105,3,105,2032,8,105,1,105,1,105,3,105,2036,8,105,
  	1,105,1,105,1,106,1,106,1,106,1,106,1,106,1,106,3,106,2046,8,106,1,106,
  	1,106,3,106,2050,8,106,1,106,1,106,1,107,1,107,1,107,1,107,3,107,2058,
  	8,107,1,107,1,107,3,107,2062,8,107,1,107,3,107,2065,8,107,1,108,3,108,
  	2068,8,108,1,108,1,108,1,109,1,109,3,109,2074,8,109,1,110,1,110,1,110,
  	1,110,3,110,2080,8,110,1,110,3,110,2083,8,110,1,110,1,110,3,110,2087,
  	8,110,1,110,1,110,3,110,2091,8,110,1,110,1,110,3,110,2095,8,110,1,110,
  	3,110,2098,8,110,1,110,1,110,1,110,1,110,5,110,2104,8,110,10,110,12,110,
  	2107,9,110,1,111,1,111,1,111,3,111,2112,8,111,1,111,1,111,1,111,3,111,
  	2117,8,111,1,111,3,111,2120,8,111,1,111,1,111,3,111,2124,8,111,1,111,
  	1,111,3,111,2128,8,111,1,111,1,111,3,111,2132,8,111,1,111,3,111,2135,
  	8,111,1,111,1,111,1,111,1,111,5,111,2141,8,111,10,111,12,111,2144,9,111,
  	1,112,1,112,3,112,2148,8,112,1,113,3,113,2151,8,113,1,113,1,113,1,113,
  	3,113,2156,8,113,1,113,1,113,3,113,2160,8,113,1,113,3,113,2163,8,113,
  	1,113,3,113,2166,8,113,1,113,1,113,1,113,1,113,5,113,2172,8,113,10,113,
  	12,113,2175,9,113,1,114,1,114,1,114,3,114,2180,8,114,1,114,3,114,2183,
  	8,114,1,114,1,114,1,114,1,114,5,114,2189,8,114,10,114,12,114,2192,9,114,
  	1,115,1,115,1,115,1,115,3,115,2198,8,115,1,116,1,116,3,116,2202,8,116,
  	1,116,3,116,2205,8,116,1,116,3,116,2208,8,116,1,116,1,116,1,116,1,116,
  	5,116,2214,8,116,10,116,12,116,2217,9,116,1,117,1,117,3,117,2221,8,117,
  	1,117,3,117,2224,8,117,1,117,3,117,2227,8,117,1,117,1,117,3,117,2231,
  	8,117,1,117,1,117,3,117,2235,8,117,3,117,2237,8,117,1,117,1,117,3,117,
  	2241,8,117,1,117,3,117,2244,8,117,1,117,1,117,1,117,1,117,5,117,2250,
  	8,117,10,117,12,117,2253,9,117,1,118,1,118,3,118,2257,8,118,1,118,4,118,
  	2260,8,118,11,118,12,118,2261,1,118,3,118,2265,8,118,1,118,3,118,2268,
  	8,118,1,118,1,118,1,118,1,118,5,118,2274,8,118,10,118,12,118,2277,9,118,
  	1,119,3,119,2280,8,119,1,119,1,119,3,119,2284,8,119,1,119,1,119,3,119,
  	2288,8,119,1,120,1,120,1,121,3,121,2293,8,121,1,121,3,121,2296,8,121,
  	1,121,1,121,3,121,2300,8,121,5,121,2302,8,121,10,121,12,121,2305,9,121,
  	1,121,1,121,3,121,2309,8,121,1,121,1,121,3,121,2313,8,121,1,121,3,121,
  	2316,8,121,5,121,2318,8,121,10,121,12,121,2321,9,121,1,122,3,122,2324,
  	8,122,1,122,1,122,3,122,2328,8,122,1,122,3,122,2331,8,122,1,122,1,122,
  	1,123,1,123,1,123,3,123,2338,8,123,1,124,1,124,3,124,2342,8,124,1,124,
  	1,124,3,124,2346,8,124,1,124,1,124,3,124,2350,8,124,1,124,5,124,2353,
  	8,124,10,124,12,124,2356,9,124,3,124,2358,8,124,1,124,3,124,2361,8,124,
  	1,124,1,124,1,125,1,125,3,125,2367,8,125,1,125,1,125,3,125,2371,8,125,
  	1,125,1,125,3,125,2375,8,125,1,125,1,125,3,125,2379,8,125,1,125,3,125,
  	2382,8,125,1,125,1,125,3,125,2386,8,125,1,125,3,125,2389,8,125,1,125,
  	3,125,2392,8,125,1,125,3,125,2395,8,125,1,125,3,125,2398,8,125,1,125,
  	3,125,2401,8,125,1,126,1,126,3,126,2405,8,126,1,126,1,126,1,127,1,127,
  	3,127,2411,8,127,1,127,1,127,3,127,2415,8,127,1,127,5,127,2418,8,127,
  	10,127,12,127,2421,9,127,1,128,1,128,1,128,1,128,1,128,3,128,2428,8,128,
  	1,128,1,128,1,129,1,129,4,129,2434,8,129,11,129,12,129,2435,1,130,1,130,
  	3,130,2440,8,130,1,130,1,130,3,130,2444,8,130,1,130,1,130,3,130,2448,
  	8,130,1,130,3,130,2451,8,130,1,131,1,131,1,131,1,131,1,131,1,131,1,131,
  	1,131,1,131,1,131,3,131,2463,8,131,1,131,1,131,3,131,2467,8,131,1,131,
  	3,131,2470,8,131,1,131,3,131,2473,8,131,1,132,1,132,1,132,5,132,2478,
  	8,132,10,132,12,132,2481,9,132,1,132,1,132,1,132,4,132,2486,8,132,11,
  	132,12,132,2487,3,132,2490,8,132,1,133,1,133,1,134,1,134,1,134,5,134,
  	2497,8,134,10,134,12,134,2500,9,134,1,135,1,135,3,135,2504,8,135,1,135,
  	1,135,3,135,2508,8,135,1,136,1,136,3,136,2512,8,136,1,136,1,136,3,136,
  	2516,8,136,1,136,3,136,2519,8,136,1,137,1,137,1,137,1,138,1,138,1,139,
  	1,139,3,139,2528,8,139,1,139,3,139,2531,8,139,1,139,1,139,3,139,2535,
  	8,139,1,139,3,139,2538,8,139,1,140,1,140,1,141,1,141,1,142,1,142,1,143,
  	1,143,1,144,1,144,1,145,3,145,2551,8,145,1,145,1,145,1,145,3,145,2556,
  	8,145,1,145,3,145,2559,8,145,1,146,1,146,3,146,2563,8,146,1,146,1,146,
  	3,146,2567,8,146,5,146,2569,8,146,10,146,12,146,2572,9,146,1,146,1,816,
  	1,200,147,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,
  	44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,
  	90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,
  	128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,
  	164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,
  	200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,
  	236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,
  	272,274,276,278,280,282,284,286,288,290,292,0,21,3,0,19,19,32,32,167,
  	167,1,0,35,46,2,0,176,176,180,180,1,0,68,72,3,0,189,189,196,196,200,200,
  	1,0,119,120,5,0,15,15,19,19,86,86,128,128,139,139,2,0,142,143,184,184,
  	2,0,99,101,158,158,1,0,1,2,2,0,160,160,166,166,2,0,188,188,197,197,2,
  	0,195,195,199,199,5,0,87,87,97,97,189,192,194,194,198,198,1,0,4,5,2,0,
  	21,22,129,129,1,0,21,22,4,0,73,73,116,117,171,171,205,211,3,0,3,3,5,8,
  	186,186,4,0,75,75,79,79,132,132,137,137,9,0,9,53,62,67,73,97,102,102,
  	108,118,121,122,127,132,137,142,144,185,2977,0,294,1,0,0,0,2,298,1,0,
  	0,0,4,354,1,0,0,0,6,360,1,0,0,0,8,374,1,0,0,0,10,395,1,0,0,0,12,399,1,
  	0,0,0,14,426,1,0,0,0,16,438,1,0,0,0,18,442,1,0,0,0,20,444,1,0,0,0,22,
  	469,1,0,0,0,24,471,1,0,0,0,26,495,1,0,0,0,28,574,1,0,0,0,30,576,1,0,0,
  	0,32,589,1,0,0,0,34,591,1,0,0,0,36,595,1,0,0,0,38,599,1,0,0,0,40,620,
  	1,0,0,0,42,638,1,0,0,0,44,655,1,0,0,0,46,668,1,0,0,0,48,708,1,0,0,0,50,
  	724,1,0,0,0,52,772,1,0,0,0,54,774,1,0,0,0,56,779,1,0,0,0,58,793,1,0,0,
  	0,60,806,1,0,0,0,62,819,1,0,0,0,64,826,1,0,0,0,66,836,1,0,0,0,68,838,
  	1,0,0,0,70,850,1,0,0,0,72,871,1,0,0,0,74,911,1,0,0,0,76,943,1,0,0,0,78,
  	965,1,0,0,0,80,969,1,0,0,0,82,998,1,0,0,0,84,1000,1,0,0,0,86,1009,1,0,
  	0,0,88,1011,1,0,0,0,90,1020,1,0,0,0,92,1025,1,0,0,0,94,1029,1,0,0,0,96,
  	1044,1,0,0,0,98,1050,1,0,0,0,100,1062,1,0,0,0,102,1074,1,0,0,0,104,1078,
  	1,0,0,0,106,1097,1,0,0,0,108,1109,1,0,0,0,110,1123,1,0,0,0,112,1135,1,
  	0,0,0,114,1151,1,0,0,0,116,1167,1,0,0,0,118,1177,1,0,0,0,120,1191,1,0,
  	0,0,122,1195,1,0,0,0,124,1203,1,0,0,0,126,1213,1,0,0,0,128,1233,1,0,0,
  	0,130,1253,1,0,0,0,132,1319,1,0,0,0,134,1338,1,0,0,0,136,1340,1,0,0,0,
  	138,1356,1,0,0,0,140,1387,1,0,0,0,142,1411,1,0,0,0,144,1432,1,0,0,0,146,
  	1454,1,0,0,0,148,1473,1,0,0,0,150,1478,1,0,0,0,152,1498,1,0,0,0,154,1515,
  	1,0,0,0,156,1517,1,0,0,0,158,1525,1,0,0,0,160,1527,1,0,0,0,162,1531,1,
  	0,0,0,164,1543,1,0,0,0,166,1555,1,0,0,0,168,1583,1,0,0,0,170,1595,1,0,
  	0,0,172,1626,1,0,0,0,174,1628,1,0,0,0,176,1650,1,0,0,0,178,1652,1,0,0,
  	0,180,1665,1,0,0,0,182,1677,1,0,0,0,184,1689,1,0,0,0,186,1694,1,0,0,0,
  	188,1717,1,0,0,0,190,1730,1,0,0,0,192,1744,1,0,0,0,194,1767,1,0,0,0,196,
  	1776,1,0,0,0,198,1780,1,0,0,0,200,1859,1,0,0,0,202,1968,1,0,0,0,204,1977,
  	1,0,0,0,206,1991,1,0,0,0,208,2018,1,0,0,0,210,2027,1,0,0,0,212,2039,1,
  	0,0,0,214,2053,1,0,0,0,216,2067,1,0,0,0,218,2073,1,0,0,0,220,2075,1,0,
  	0,0,222,2108,1,0,0,0,224,2147,1,0,0,0,226,2150,1,0,0,0,228,2176,1,0,0,
  	0,230,2197,1,0,0,0,232,2199,1,0,0,0,234,2220,1,0,0,0,236,2256,1,0,0,0,
  	238,2279,1,0,0,0,240,2289,1,0,0,0,242,2303,1,0,0,0,244,2323,1,0,0,0,246,
  	2334,1,0,0,0,248,2339,1,0,0,0,250,2366,1,0,0,0,252,2402,1,0,0,0,254,2408,
  	1,0,0,0,256,2427,1,0,0,0,258,2433,1,0,0,0,260,2437,1,0,0,0,262,2472,1,
  	0,0,0,264,2489,1,0,0,0,266,2491,1,0,0,0,268,2493,1,0,0,0,270,2501,1,0,
  	0,0,272,2509,1,0,0,0,274,2520,1,0,0,0,276,2523,1,0,0,0,278,2527,1,0,0,
  	0,280,2539,1,0,0,0,282,2541,1,0,0,0,284,2543,1,0,0,0,286,2545,1,0,0,0,
  	288,2547,1,0,0,0,290,2550,1,0,0,0,292,2570,1,0,0,0,294,295,3,2,1,0,295,
  	296,5,0,0,1,296,1,1,0,0,0,297,299,5,219,0,0,298,297,1,0,0,0,298,299,1,
  	0,0,0,299,303,1,0,0,0,300,302,3,290,145,0,301,300,1,0,0,0,302,305,1,0,
  	0,0,303,301,1,0,0,0,303,304,1,0,0,0,304,313,1,0,0,0,305,303,1,0,0,0,306,
  	310,3,4,2,0,307,309,3,290,145,0,308,307,1,0,0,0,309,312,1,0,0,0,310,308,
  	1,0,0,0,310,311,1,0,0,0,311,314,1,0,0,0,312,310,1,0,0,0,313,306,1,0,0,
  	0,313,314,1,0,0,0,314,316,1,0,0,0,315,317,3,6,3,0,316,315,1,0,0,0,316,
  	317,1,0,0,0,317,321,1,0,0,0,318,320,3,290,145,0,319,318,1,0,0,0,320,323,
  	1,0,0,0,321,319,1,0,0,0,321,322,1,0,0,0,322,325,1,0,0,0,323,321,1,0,0,
  	0,324,326,3,10,5,0,325,324,1,0,0,0,325,326,1,0,0,0,326,330,1,0,0,0,327,
  	329,3,290,145,0,328,327,1,0,0,0,329,332,1,0,0,0,330,328,1,0,0,0,330,331,
  	1,0,0,0,331,334,1,0,0,0,332,330,1,0,0,0,333,335,3,12,6,0,334,333,1,0,
  	0,0,334,335,1,0,0,0,335,339,1,0,0,0,336,338,3,290,145,0,337,336,1,0,0,
  	0,338,341,1,0,0,0,339,337,1,0,0,0,339,340,1,0,0,0,340,343,1,0,0,0,341,
  	339,1,0,0,0,342,344,3,20,10,0,343,342,1,0,0,0,343,344,1,0,0,0,344,348,
  	1,0,0,0,345,347,3,290,145,0,346,345,1,0,0,0,347,350,1,0,0,0,348,346,1,
  	0,0,0,348,349,1,0,0,0,349,352,1,0,0,0,350,348,1,0,0,0,351,353,5,219,0,
  	0,352,351,1,0,0,0,352,353,1,0,0,0,353,3,1,0,0,0,354,355,5,178,0,0,355,
  	356,5,219,0,0,356,357,5,210,0,0,357,358,5,219,0,0,358,359,5,28,0,0,359,
  	5,1,0,0,0,360,364,5,17,0,0,361,363,3,290,145,0,362,361,1,0,0,0,363,366,
  	1,0,0,0,364,362,1,0,0,0,364,365,1,0,0,0,365,368,1,0,0,0,366,364,1,0,0,
  	0,367,369,3,8,4,0,368,367,1,0,0,0,369,370,1,0,0,0,370,368,1,0,0,0,370,
  	371,1,0,0,0,371,372,1,0,0,0,372,373,5,62,0,0,373,7,1,0,0,0,374,376,3,
  	258,129,0,375,377,5,219,0,0,376,375,1,0,0,0,376,377,1,0,0,0,377,378,1,
  	0,0,0,378,380,5,189,0,0,379,381,5,219,0,0,380,379,1,0,0,0,380,381,1,0,
  	0,0,381,382,1,0,0,0,382,386,3,276,138,0,383,385,3,290,145,0,384,383,1,
  	0,0,0,385,388,1,0,0,0,386,384,1,0,0,0,386,387,1,0,0,0,387,9,1,0,0,0,388,
  	386,1,0,0,0,389,391,3,24,12,0,390,392,3,290,145,0,391,390,1,0,0,0,392,
  	393,1,0,0,0,393,391,1,0,0,0,393,394,1,0,0,0,394,396,1,0,0,0,395,389,1,
  	0,0,0,396,397,1,0,0,0,397,395,1,0,0,0,397,398,1,0,0,0,398,11,1,0,0,0,
  	399,409,3,16,8,0,400,402,3,290,145,0,401,400,1,0,0,0,402,403,1,0,0,0,
  	403,401,1,0,0,0,403,404,1,0,0,0,404,405,1,0,0,0,405,406,3,16,8,0,406,
  	408,1,0,0,0,407,401,1,0,0,0,408,411,1,0,0,0,409,407,1,0,0,0,409,410,1,
  	0,0,0,410,415,1,0,0,0,411,409,1,0,0,0,412,414,3,290,145,0,413,412,1,0,
  	0,0,414,417,1,0,0,0,415,413,1,0,0,0,415,416,1,0,0,0,416,13,1,0,0,0,417,
  	415,1,0,0,0,418,419,5,123,0,0,419,420,5,219,0,0,420,427,5,208,0,0,421,
  	422,5,125,0,0,422,423,5,219,0,0,423,427,7,0,0,0,424,427,5,124,0,0,425,
  	427,5,126,0,0,426,418,1,0,0,0,426,421,1,0,0,0,426,424,1,0,0,0,426,425,
  	1,0,0,0,427,15,1,0,0,0,428,439,3,288,144,0,429,439,3,46,23,0,430,439,
  	3,56,28,0,431,439,3,64,32,0,432,439,3,40,20,0,433,439,3,92,46,0,434,439,
  	3,202,101,0,435,439,3,14,7,0,436,439,3,190,95,0,437,439,3,18,9,0,438,
  	428,1,0,0,0,438,429,1,0,0,0,438,430,1,0,0,0,438,431,1,0,0,0,438,432,1,
  	0,0,0,438,433,1,0,0,0,438,434,1,0,0,0,438,435,1,0,0,0,438,436,1,0,0,0,
  	438,437,1,0,0,0,439,17,1,0,0,0,440,443,3,108,54,0,441,443,3,110,55,0,
  	442,440,1,0,0,0,442,441,1,0,0,0,443,19,1,0,0,0,444,454,3,22,11,0,445,
  	447,3,290,145,0,446,445,1,0,0,0,447,448,1,0,0,0,448,446,1,0,0,0,448,449,
  	1,0,0,0,449,450,1,0,0,0,450,451,3,22,11,0,451,453,1,0,0,0,452,446,1,0,
  	0,0,453,456,1,0,0,0,454,452,1,0,0,0,454,455,1,0,0,0,455,460,1,0,0,0,456,
  	454,1,0,0,0,457,459,3,290,145,0,458,457,1,0,0,0,459,462,1,0,0,0,460,458,
  	1,0,0,0,460,461,1,0,0,0,461,21,1,0,0,0,462,460,1,0,0,0,463,470,3,74,37,
  	0,464,470,3,138,69,0,465,470,3,140,70,0,466,470,3,142,71,0,467,470,3,
  	186,93,0,468,470,3,18,9,0,469,463,1,0,0,0,469,464,1,0,0,0,469,465,1,0,
  	0,0,469,466,1,0,0,0,469,467,1,0,0,0,469,468,1,0,0,0,470,23,1,0,0,0,471,
  	472,5,13,0,0,472,473,5,219,0,0,473,475,3,230,115,0,474,476,5,219,0,0,
  	475,474,1,0,0,0,475,476,1,0,0,0,476,477,1,0,0,0,477,479,5,189,0,0,478,
  	480,5,219,0,0,479,478,1,0,0,0,479,480,1,0,0,0,480,481,1,0,0,0,481,492,
  	3,276,138,0,482,484,5,219,0,0,483,482,1,0,0,0,483,484,1,0,0,0,484,485,
  	1,0,0,0,485,487,5,1,0,0,486,488,5,219,0,0,487,486,1,0,0,0,487,488,1,0,
  	0,0,488,489,1,0,0,0,489,491,3,276,138,0,490,483,1,0,0,0,491,494,1,0,0,
  	0,492,490,1,0,0,0,492,493,1,0,0,0,493,25,1,0,0,0,494,492,1,0,0,0,495,
  	501,3,28,14,0,496,497,3,292,146,0,497,498,3,28,14,0,498,500,1,0,0,0,499,
  	496,1,0,0,0,500,503,1,0,0,0,501,499,1,0,0,0,501,502,1,0,0,0,502,504,1,
  	0,0,0,503,501,1,0,0,0,504,505,3,292,146,0,505,27,1,0,0,0,506,575,3,274,
  	137,0,507,575,3,30,15,0,508,575,3,24,12,0,509,575,3,32,16,0,510,575,3,
  	34,17,0,511,575,3,36,18,0,512,575,3,38,19,0,513,575,3,40,20,0,514,575,
  	3,44,22,0,515,575,3,50,25,0,516,575,3,48,24,0,517,575,3,52,26,0,518,575,
  	3,54,27,0,519,575,3,60,30,0,520,575,3,62,31,0,521,575,3,66,33,0,522,575,
  	3,218,109,0,523,575,3,68,34,0,524,575,3,70,35,0,525,575,3,72,36,0,526,
  	575,3,76,38,0,527,575,3,78,39,0,528,575,3,80,40,0,529,575,3,82,41,0,530,
  	575,3,92,46,0,531,575,3,94,47,0,532,575,3,96,48,0,533,575,3,98,49,0,534,
  	575,3,100,50,0,535,575,3,102,51,0,536,575,3,104,52,0,537,575,3,106,53,
  	0,538,575,3,18,9,0,539,575,3,118,59,0,540,575,3,120,60,0,541,575,3,122,
  	61,0,542,575,3,124,62,0,543,575,3,126,63,0,544,575,3,128,64,0,545,575,
  	3,130,65,0,546,575,3,136,68,0,547,575,3,144,72,0,548,575,3,146,73,0,549,
  	575,3,148,74,0,550,575,3,150,75,0,551,575,3,154,77,0,552,575,3,156,78,
  	0,553,575,3,158,79,0,554,575,3,160,80,0,555,575,3,162,81,0,556,575,3,
  	164,82,0,557,575,3,166,83,0,558,575,3,168,84,0,559,575,3,170,85,0,560,
  	575,3,178,89,0,561,575,3,180,90,0,562,575,3,182,91,0,563,575,3,184,92,
  	0,564,575,3,188,94,0,565,575,3,196,98,0,566,575,3,198,99,0,567,575,3,
  	202,101,0,568,575,3,208,104,0,569,575,3,210,105,0,570,575,3,212,106,0,
  	571,575,3,214,107,0,572,575,3,224,112,0,573,575,3,230,115,0,574,506,1,
  	0,0,0,574,507,1,0,0,0,574,508,1,0,0,0,574,509,1,0,0,0,574,510,1,0,0,0,
  	574,511,1,0,0,0,574,512,1,0,0,0,574,513,1,0,0,0,574,514,1,0,0,0,574,515,
  	1,0,0,0,574,516,1,0,0,0,574,517,1,0,0,0,574,518,1,0,0,0,574,519,1,0,0,
  	0,574,520,1,0,0,0,574,521,1,0,0,0,574,522,1,0,0,0,574,523,1,0,0,0,574,
  	524,1,0,0,0,574,525,1,0,0,0,574,526,1,0,0,0,574,527,1,0,0,0,574,528,1,
  	0,0,0,574,529,1,0,0,0,574,530,1,0,0,0,574,531,1,0,0,0,574,532,1,0,0,0,
  	574,533,1,0,0,0,574,534,1,0,0,0,574,535,1,0,0,0,574,536,1,0,0,0,574,537,
  	1,0,0,0,574,538,1,0,0,0,574,539,1,0,0,0,574,540,1,0,0,0,574,541,1,0,0,
  	0,574,542,1,0,0,0,574,543,1,0,0,0,574,544,1,0,0,0,574,545,1,0,0,0,574,
  	546,1,0,0,0,574,547,1,0,0,0,574,548,1,0,0,0,574,549,1,0,0,0,574,550,1,
  	0,0,0,574,551,1,0,0,0,574,552,1,0,0,0,574,553,1,0,0,0,574,554,1,0,0,0,
  	574,555,1,0,0,0,574,556,1,0,0,0,574,557,1,0,0,0,574,558,1,0,0,0,574,559,
  	1,0,0,0,574,560,1,0,0,0,574,561,1,0,0,0,574,562,1,0,0,0,574,563,1,0,0,
  	0,574,564,1,0,0,0,574,565,1,0,0,0,574,566,1,0,0,0,574,567,1,0,0,0,574,
  	568,1,0,0,0,574,569,1,0,0,0,574,570,1,0,0,0,574,571,1,0,0,0,574,572,1,
  	0,0,0,574,573,1,0,0,0,575,29,1,0,0,0,576,577,5,14,0,0,577,578,5,219,0,
  	0,578,587,3,200,100,0,579,581,5,219,0,0,580,579,1,0,0,0,580,581,1,0,0,
  	0,581,582,1,0,0,0,582,584,5,1,0,0,583,585,5,219,0,0,584,583,1,0,0,0,584,
  	585,1,0,0,0,585,586,1,0,0,0,586,588,3,200,100,0,587,580,1,0,0,0,587,588,
  	1,0,0,0,588,31,1,0,0,0,589,590,5,18,0,0,590,33,1,0,0,0,591,592,5,26,0,
  	0,592,593,5,219,0,0,593,594,3,200,100,0,594,35,1,0,0,0,595,596,5,27,0,
  	0,596,597,5,219,0,0,597,598,3,200,100,0,598,37,1,0,0,0,599,615,5,29,0,
  	0,600,601,5,219,0,0,601,612,3,216,108,0,602,604,5,219,0,0,603,602,1,0,
  	0,0,603,604,1,0,0,0,604,605,1,0,0,0,605,607,5,1,0,0,606,608,5,219,0,0,
  	607,606,1,0,0,0,607,608,1,0,0,0,608,609,1,0,0,0,609,611,3,216,108,0,610,
  	603,1,0,0,0,611,614,1,0,0,0,612,610,1,0,0,0,612,613,1,0,0,0,613,616,1,
  	0,0,0,614,612,1,0,0,0,615,600,1,0,0,0,615,616,1,0,0,0,616,39,1,0,0,0,
  	617,618,3,282,141,0,618,619,5,219,0,0,619,621,1,0,0,0,620,617,1,0,0,0,
  	620,621,1,0,0,0,621,622,1,0,0,0,622,623,5,31,0,0,623,624,5,219,0,0,624,
  	635,3,42,21,0,625,627,5,219,0,0,626,625,1,0,0,0,626,627,1,0,0,0,627,628,
  	1,0,0,0,628,630,5,1,0,0,629,631,5,219,0,0,630,629,1,0,0,0,630,631,1,0,
  	0,0,631,632,1,0,0,0,632,634,3,42,21,0,633,626,1,0,0,0,634,637,1,0,0,0,
  	635,633,1,0,0,0,635,636,1,0,0,0,636,41,1,0,0,0,637,635,1,0,0,0,638,640,
  	3,258,129,0,639,641,3,280,140,0,640,639,1,0,0,0,640,641,1,0,0,0,641,644,
  	1,0,0,0,642,643,5,219,0,0,643,645,3,260,130,0,644,642,1,0,0,0,644,645,
  	1,0,0,0,645,647,1,0,0,0,646,648,5,219,0,0,647,646,1,0,0,0,647,648,1,0,
  	0,0,648,649,1,0,0,0,649,651,5,189,0,0,650,652,5,219,0,0,651,650,1,0,0,
  	0,651,652,1,0,0,0,652,653,1,0,0,0,653,654,3,200,100,0,654,43,1,0,0,0,
  	655,657,5,33,0,0,656,658,5,219,0,0,657,656,1,0,0,0,657,658,1,0,0,0,658,
  	659,1,0,0,0,659,661,5,189,0,0,660,662,5,219,0,0,661,660,1,0,0,0,661,662,
  	1,0,0,0,662,663,1,0,0,0,663,664,3,200,100,0,664,45,1,0,0,0,665,666,3,
  	282,141,0,666,667,5,219,0,0,667,669,1,0,0,0,668,665,1,0,0,0,668,669,1,
  	0,0,0,669,670,1,0,0,0,670,671,5,34,0,0,671,674,5,219,0,0,672,673,5,136,
  	0,0,673,675,5,219,0,0,674,672,1,0,0,0,674,675,1,0,0,0,675,681,1,0,0,0,
  	676,678,5,77,0,0,677,679,3,280,140,0,678,677,1,0,0,0,678,679,1,0,0,0,
  	679,682,1,0,0,0,680,682,5,165,0,0,681,676,1,0,0,0,681,680,1,0,0,0,682,
  	683,1,0,0,0,683,684,5,219,0,0,684,686,3,258,129,0,685,687,3,280,140,0,
  	686,685,1,0,0,0,686,687,1,0,0,0,687,688,1,0,0,0,688,689,5,219,0,0,689,
  	690,5,96,0,0,690,691,5,219,0,0,691,696,5,205,0,0,692,693,5,219,0,0,693,
  	694,5,11,0,0,694,695,5,219,0,0,695,697,5,205,0,0,696,692,1,0,0,0,696,
  	697,1,0,0,0,697,702,1,0,0,0,698,700,5,219,0,0,699,698,1,0,0,0,699,700,
  	1,0,0,0,700,701,1,0,0,0,701,703,3,248,124,0,702,699,1,0,0,0,702,703,1,
  	0,0,0,703,706,1,0,0,0,704,705,5,219,0,0,705,707,3,260,130,0,706,704,1,
  	0,0,0,706,707,1,0,0,0,707,47,1,0,0,0,708,709,7,1,0,0,709,710,5,219,0,
  	0,710,721,3,272,136,0,711,713,5,219,0,0,712,711,1,0,0,0,712,713,1,0,0,
  	0,713,714,1,0,0,0,714,716,5,1,0,0,715,717,5,219,0,0,716,715,1,0,0,0,716,
  	717,1,0,0,0,717,718,1,0,0,0,718,720,3,272,136,0,719,712,1,0,0,0,720,723,
  	1,0,0,0,721,719,1,0,0,0,721,722,1,0,0,0,722,49,1,0,0,0,723,721,1,0,0,
  	0,724,725,5,47,0,0,725,726,5,219,0,0,726,728,3,200,100,0,727,729,5,219,
  	0,0,728,727,1,0,0,0,728,729,1,0,0,0,729,730,1,0,0,0,730,732,5,1,0,0,731,
  	733,5,219,0,0,732,731,1,0,0,0,732,733,1,0,0,0,733,734,1,0,0,0,734,743,
  	3,200,100,0,735,737,5,219,0,0,736,735,1,0,0,0,736,737,1,0,0,0,737,738,
  	1,0,0,0,738,740,5,1,0,0,739,741,5,219,0,0,740,739,1,0,0,0,740,741,1,0,
  	0,0,741,742,1,0,0,0,742,744,3,200,100,0,743,736,1,0,0,0,743,744,1,0,0,
  	0,744,51,1,0,0,0,745,746,5,49,0,0,746,748,3,292,146,0,747,749,3,26,13,
  	0,748,747,1,0,0,0,748,749,1,0,0,0,749,750,1,0,0,0,750,751,5,93,0,0,751,
  	773,1,0,0,0,752,753,5,49,0,0,753,754,5,219,0,0,754,755,7,2,0,0,755,756,
  	5,219,0,0,756,757,3,200,100,0,757,759,3,292,146,0,758,760,3,26,13,0,759,
  	758,1,0,0,0,759,760,1,0,0,0,760,761,1,0,0,0,761,762,5,93,0,0,762,773,
  	1,0,0,0,763,764,5,49,0,0,764,765,3,292,146,0,765,766,3,26,13,0,766,767,
  	5,93,0,0,767,768,5,219,0,0,768,769,7,2,0,0,769,770,5,219,0,0,770,771,
  	3,200,100,0,771,773,1,0,0,0,772,745,1,0,0,0,772,752,1,0,0,0,772,763,1,
  	0,0,0,773,53,1,0,0,0,774,775,5,62,0,0,775,55,1,0,0,0,776,777,3,282,141,
  	0,777,778,5,219,0,0,778,780,1,0,0,0,779,776,1,0,0,0,779,780,1,0,0,0,780,
  	781,1,0,0,0,781,782,5,63,0,0,782,783,5,219,0,0,783,784,3,258,129,0,784,
  	788,3,292,146,0,785,787,3,58,29,0,786,785,1,0,0,0,787,790,1,0,0,0,788,
  	786,1,0,0,0,788,789,1,0,0,0,789,791,1,0,0,0,790,788,1,0,0,0,791,792,5,
  	54,0,0,792,57,1,0,0,0,793,802,3,258,129,0,794,796,5,219,0,0,795,794,1,
  	0,0,0,795,796,1,0,0,0,796,797,1,0,0,0,797,799,5,189,0,0,798,800,5,219,
  	0,0,799,798,1,0,0,0,799,800,1,0,0,0,800,801,1,0,0,0,801,803,3,200,100,
  	0,802,795,1,0,0,0,802,803,1,0,0,0,803,804,1,0,0,0,804,805,3,292,146,0,
  	805,59,1,0,0,0,806,807,5,65,0,0,807,808,5,219,0,0,808,816,3,200,100,0,
  	809,811,5,1,0,0,810,812,5,219,0,0,811,810,1,0,0,0,811,812,1,0,0,0,812,
  	813,1,0,0,0,813,815,3,200,100,0,814,809,1,0,0,0,815,818,1,0,0,0,816,817,
  	1,0,0,0,816,814,1,0,0,0,817,61,1,0,0,0,818,816,1,0,0,0,819,820,5,66,0,
  	0,820,821,5,219,0,0,821,822,3,200,100,0,822,63,1,0,0,0,823,824,3,282,
  	141,0,824,825,5,219,0,0,825,827,1,0,0,0,826,823,1,0,0,0,826,827,1,0,0,
  	0,827,828,1,0,0,0,828,829,5,67,0,0,829,830,5,219,0,0,830,832,3,258,129,
  	0,831,833,5,219,0,0,832,831,1,0,0,0,832,833,1,0,0,0,833,834,1,0,0,0,834,
  	835,3,248,124,0,835,65,1,0,0,0,836,837,7,3,0,0,837,67,1,0,0,0,838,839,
  	5,74,0,0,839,840,5,219,0,0,840,842,3,200,100,0,841,843,5,219,0,0,842,
  	841,1,0,0,0,842,843,1,0,0,0,843,844,1,0,0,0,844,846,5,1,0,0,845,847,5,
  	219,0,0,846,845,1,0,0,0,846,847,1,0,0,0,847,848,1,0,0,0,848,849,3,200,
  	100,0,849,69,1,0,0,0,850,851,5,76,0,0,851,852,5,219,0,0,852,853,5,51,
  	0,0,853,854,5,219,0,0,854,856,3,258,129,0,855,857,3,280,140,0,856,855,
  	1,0,0,0,856,857,1,0,0,0,857,858,1,0,0,0,858,859,5,219,0,0,859,860,5,85,
  	0,0,860,861,5,219,0,0,861,862,3,200,100,0,862,864,3,292,146,0,863,865,
  	3,26,13,0,864,863,1,0,0,0,864,865,1,0,0,0,865,866,1,0,0,0,866,869,5,113,
  	0,0,867,868,5,219,0,0,868,870,3,258,129,0,869,867,1,0,0,0,869,870,1,0,
  	0,0,870,71,1,0,0,0,871,872,5,76,0,0,872,873,5,219,0,0,873,875,3,258,129,
  	0,874,876,3,280,140,0,875,874,1,0,0,0,875,876,1,0,0,0,876,879,1,0,0,0,
  	877,878,5,219,0,0,878,880,3,260,130,0,879,877,1,0,0,0,879,880,1,0,0,0,
  	880,882,1,0,0,0,881,883,5,219,0,0,882,881,1,0,0,0,882,883,1,0,0,0,883,
  	884,1,0,0,0,884,886,5,189,0,0,885,887,5,219,0,0,886,885,1,0,0,0,886,887,
  	1,0,0,0,887,888,1,0,0,0,888,889,3,200,100,0,889,890,5,219,0,0,890,891,
  	5,170,0,0,891,892,5,219,0,0,892,897,3,200,100,0,893,894,5,219,0,0,894,
  	895,5,162,0,0,895,896,5,219,0,0,896,898,3,200,100,0,897,893,1,0,0,0,897,
  	898,1,0,0,0,898,899,1,0,0,0,899,901,3,292,146,0,900,902,3,26,13,0,901,
  	900,1,0,0,0,901,902,1,0,0,0,902,903,1,0,0,0,903,906,5,113,0,0,904,905,
  	5,219,0,0,905,907,3,258,129,0,906,904,1,0,0,0,906,907,1,0,0,0,907,73,
  	1,0,0,0,908,909,3,282,141,0,909,910,5,219,0,0,910,912,1,0,0,0,911,908,
  	1,0,0,0,911,912,1,0,0,0,912,915,1,0,0,0,913,914,5,161,0,0,914,916,5,219,
  	0,0,915,913,1,0,0,0,915,916,1,0,0,0,916,917,1,0,0,0,917,919,5,77,0,0,
  	918,920,5,219,0,0,919,918,1,0,0,0,919,920,1,0,0,0,920,921,1,0,0,0,921,
  	923,3,258,129,0,922,924,3,280,140,0,923,922,1,0,0,0,923,924,1,0,0,0,924,
  	929,1,0,0,0,925,927,5,219,0,0,926,925,1,0,0,0,926,927,1,0,0,0,927,928,
  	1,0,0,0,928,930,3,248,124,0,929,926,1,0,0,0,929,930,1,0,0,0,930,935,1,
  	0,0,0,931,933,5,219,0,0,932,931,1,0,0,0,932,933,1,0,0,0,933,934,1,0,0,
  	0,934,936,3,260,130,0,935,932,1,0,0,0,935,936,1,0,0,0,936,937,1,0,0,0,
  	937,939,3,292,146,0,938,940,3,26,13,0,939,938,1,0,0,0,939,940,1,0,0,0,
  	940,941,1,0,0,0,941,942,5,55,0,0,942,75,1,0,0,0,943,944,5,78,0,0,944,
  	945,5,219,0,0,945,947,3,216,108,0,946,948,5,219,0,0,947,946,1,0,0,0,947,
  	948,1,0,0,0,948,949,1,0,0,0,949,951,5,1,0,0,950,952,5,219,0,0,951,950,
  	1,0,0,0,951,952,1,0,0,0,952,954,1,0,0,0,953,955,3,200,100,0,954,953,1,
  	0,0,0,954,955,1,0,0,0,955,957,1,0,0,0,956,958,5,219,0,0,957,956,1,0,0,
  	0,957,958,1,0,0,0,958,959,1,0,0,0,959,961,5,1,0,0,960,962,5,219,0,0,961,
  	960,1,0,0,0,961,962,1,0,0,0,962,963,1,0,0,0,963,964,3,200,100,0,964,77,
  	1,0,0,0,965,966,5,80,0,0,966,967,5,219,0,0,967,968,3,200,100,0,968,79,
  	1,0,0,0,969,970,5,81,0,0,970,971,5,219,0,0,971,972,3,200,100,0,972,81,
  	1,0,0,0,973,974,5,82,0,0,974,975,5,219,0,0,975,976,3,86,43,0,976,977,
  	5,219,0,0,977,978,5,168,0,0,978,979,5,219,0,0,979,984,3,28,14,0,980,981,
  	5,219,0,0,981,982,5,52,0,0,982,983,5,219,0,0,983,985,3,28,14,0,984,980,
  	1,0,0,0,984,985,1,0,0,0,985,999,1,0,0,0,986,990,3,84,42,0,987,989,3,88,
  	44,0,988,987,1,0,0,0,989,992,1,0,0,0,990,988,1,0,0,0,990,991,1,0,0,0,
  	991,994,1,0,0,0,992,990,1,0,0,0,993,995,3,90,45,0,994,993,1,0,0,0,994,
  	995,1,0,0,0,995,996,1,0,0,0,996,997,5,56,0,0,997,999,1,0,0,0,998,973,
  	1,0,0,0,998,986,1,0,0,0,999,83,1,0,0,0,1000,1001,5,82,0,0,1001,1002,5,
  	219,0,0,1002,1003,3,86,43,0,1003,1004,5,219,0,0,1004,1005,5,168,0,0,1005,
  	1007,3,292,146,0,1006,1008,3,26,13,0,1007,1006,1,0,0,0,1007,1008,1,0,
  	0,0,1008,85,1,0,0,0,1009,1010,3,200,100,0,1010,87,1,0,0,0,1011,1012,5,
  	53,0,0,1012,1013,5,219,0,0,1013,1014,3,86,43,0,1014,1015,5,219,0,0,1015,
  	1016,5,168,0,0,1016,1018,3,292,146,0,1017,1019,3,26,13,0,1018,1017,1,
  	0,0,0,1018,1019,1,0,0,0,1019,89,1,0,0,0,1020,1021,5,52,0,0,1021,1023,
  	3,292,146,0,1022,1024,3,26,13,0,1023,1022,1,0,0,0,1023,1024,1,0,0,0,1024,
  	91,1,0,0,0,1025,1026,5,84,0,0,1026,1027,5,219,0,0,1027,1028,3,258,129,
  	0,1028,93,1,0,0,0,1029,1030,5,86,0,0,1030,1031,5,219,0,0,1031,1040,3,
  	216,108,0,1032,1034,5,219,0,0,1033,1032,1,0,0,0,1033,1034,1,0,0,0,1034,
  	1035,1,0,0,0,1035,1037,5,1,0,0,1036,1038,5,219,0,0,1037,1036,1,0,0,0,
  	1037,1038,1,0,0,0,1038,1039,1,0,0,0,1039,1041,3,200,100,0,1040,1033,1,
  	0,0,0,1041,1042,1,0,0,0,1042,1040,1,0,0,0,1042,1043,1,0,0,0,1043,95,1,
  	0,0,0,1044,1045,5,89,0,0,1045,1046,5,219,0,0,1046,1047,3,200,100,0,1047,
  	97,1,0,0,0,1048,1049,5,95,0,0,1049,1051,5,219,0,0,1050,1048,1,0,0,0,1050,
  	1051,1,0,0,0,1051,1052,1,0,0,0,1052,1054,3,230,115,0,1053,1055,5,219,
  	0,0,1054,1053,1,0,0,0,1054,1055,1,0,0,0,1055,1056,1,0,0,0,1056,1058,7,
  	4,0,0,1057,1059,5,219,0,0,1058,1057,1,0,0,0,1058,1059,1,0,0,0,1059,1060,
  	1,0,0,0,1060,1061,3,200,100,0,1061,99,1,0,0,0,1062,1063,5,98,0,0,1063,
  	1064,5,219,0,0,1064,1066,3,216,108,0,1065,1067,5,219,0,0,1066,1065,1,
  	0,0,0,1066,1067,1,0,0,0,1067,1068,1,0,0,0,1068,1070,5,1,0,0,1069,1071,
  	5,219,0,0,1070,1069,1,0,0,0,1070,1071,1,0,0,0,1071,1072,1,0,0,0,1072,
  	1073,3,200,100,0,1073,101,1,0,0,0,1074,1075,5,90,0,0,1075,1076,5,219,
  	0,0,1076,1077,3,200,100,0,1077,103,1,0,0,0,1078,1079,5,91,0,0,1079,1080,
  	5,219,0,0,1080,1095,3,200,100,0,1081,1083,5,219,0,0,1082,1081,1,0,0,0,
  	1082,1083,1,0,0,0,1083,1084,1,0,0,0,1084,1086,5,1,0,0,1085,1087,5,219,
  	0,0,1086,1085,1,0,0,0,1086,1087,1,0,0,0,1087,1088,1,0,0,0,1088,1093,3,
  	200,100,0,1089,1090,5,219,0,0,1090,1091,5,170,0,0,1091,1092,5,219,0,0,
  	1092,1094,3,200,100,0,1093,1089,1,0,0,0,1093,1094,1,0,0,0,1094,1096,1,
  	0,0,0,1095,1082,1,0,0,0,1095,1096,1,0,0,0,1096,105,1,0,0,0,1097,1098,
  	5,102,0,0,1098,1099,5,219,0,0,1099,1101,3,230,115,0,1100,1102,5,219,0,
  	0,1101,1100,1,0,0,0,1101,1102,1,0,0,0,1102,1103,1,0,0,0,1103,1105,5,189,
  	0,0,1104,1106,5,219,0,0,1105,1104,1,0,0,0,1105,1106,1,0,0,0,1106,1107,
  	1,0,0,0,1107,1108,3,200,100,0,1108,107,1,0,0,0,1109,1111,5,103,0,0,1110,
  	1112,5,219,0,0,1111,1110,1,0,0,0,1111,1112,1,0,0,0,1112,1113,1,0,0,0,
  	1113,1115,3,258,129,0,1114,1116,5,219,0,0,1115,1114,1,0,0,0,1115,1116,
  	1,0,0,0,1116,1117,1,0,0,0,1117,1119,5,189,0,0,1118,1120,5,219,0,0,1119,
  	1118,1,0,0,0,1119,1120,1,0,0,0,1120,1121,1,0,0,0,1121,1122,3,200,100,
  	0,1122,109,1,0,0,0,1123,1127,3,112,56,0,1124,1126,3,114,57,0,1125,1124,
  	1,0,0,0,1126,1129,1,0,0,0,1127,1125,1,0,0,0,1127,1128,1,0,0,0,1128,1131,
  	1,0,0,0,1129,1127,1,0,0,0,1130,1132,3,116,58,0,1131,1130,1,0,0,0,1131,
  	1132,1,0,0,0,1132,1133,1,0,0,0,1133,1134,5,107,0,0,1134,111,1,0,0,0,1135,
  	1137,5,104,0,0,1136,1138,5,219,0,0,1137,1136,1,0,0,0,1137,1138,1,0,0,
  	0,1138,1139,1,0,0,0,1139,1140,3,86,43,0,1140,1141,5,219,0,0,1141,1142,
  	5,168,0,0,1142,1148,3,292,146,0,1143,1147,3,12,6,0,1144,1147,3,20,10,
  	0,1145,1147,3,26,13,0,1146,1143,1,0,0,0,1146,1144,1,0,0,0,1146,1145,1,
  	0,0,0,1147,1150,1,0,0,0,1148,1146,1,0,0,0,1148,1149,1,0,0,0,1149,113,
  	1,0,0,0,1150,1148,1,0,0,0,1151,1153,5,105,0,0,1152,1154,5,219,0,0,1153,
  	1152,1,0,0,0,1153,1154,1,0,0,0,1154,1155,1,0,0,0,1155,1156,3,86,43,0,
  	1156,1157,5,219,0,0,1157,1158,5,168,0,0,1158,1164,3,292,146,0,1159,1163,
  	3,12,6,0,1160,1163,3,20,10,0,1161,1163,3,26,13,0,1162,1159,1,0,0,0,1162,
  	1160,1,0,0,0,1162,1161,1,0,0,0,1163,1166,1,0,0,0,1164,1162,1,0,0,0,1164,
  	1165,1,0,0,0,1165,115,1,0,0,0,1166,1164,1,0,0,0,1167,1168,5,106,0,0,1168,
  	1174,3,292,146,0,1169,1173,3,12,6,0,1170,1173,3,20,10,0,1171,1173,3,26,
  	13,0,1172,1169,1,0,0,0,1172,1170,1,0,0,0,1172,1171,1,0,0,0,1173,1176,
  	1,0,0,0,1174,1172,1,0,0,0,1174,1175,1,0,0,0,1175,117,1,0,0,0,1176,1174,
  	1,0,0,0,1177,1179,5,109,0,0,1178,1180,5,219,0,0,1179,1178,1,0,0,0,1179,
  	1180,1,0,0,0,1180,1181,1,0,0,0,1181,1183,5,193,0,0,1182,1184,5,219,0,
  	0,1183,1182,1,0,0,0,1183,1184,1,0,0,0,1184,1185,1,0,0,0,1185,1187,3,242,
  	121,0,1186,1188,5,219,0,0,1187,1186,1,0,0,0,1187,1188,1,0,0,0,1188,1189,
  	1,0,0,0,1189,1190,5,202,0,0,1190,119,1,0,0,0,1191,1192,5,110,0,0,1192,
  	1193,5,219,0,0,1193,1194,3,200,100,0,1194,121,1,0,0,0,1195,1196,5,112,
  	0,0,1196,1197,5,219,0,0,1197,1198,3,200,100,0,1198,1199,5,219,0,0,1199,
  	1200,5,16,0,0,1200,1201,5,219,0,0,1201,1202,3,200,100,0,1202,123,1,0,
  	0,0,1203,1204,7,5,0,0,1204,1211,5,219,0,0,1205,1206,5,81,0,0,1206,1207,
  	5,219,0,0,1207,1212,3,200,100,0,1208,1209,5,147,0,0,1209,1210,5,219,0,
  	0,1210,1212,5,113,0,0,1211,1205,1,0,0,0,1211,1208,1,0,0,0,1212,125,1,
  	0,0,0,1213,1214,5,118,0,0,1214,1215,5,219,0,0,1215,1216,3,200,100,0,1216,
  	1217,5,219,0,0,1217,1218,5,81,0,0,1218,1219,5,219,0,0,1219,1230,3,200,
  	100,0,1220,1222,5,219,0,0,1221,1220,1,0,0,0,1221,1222,1,0,0,0,1222,1223,
  	1,0,0,0,1223,1225,5,1,0,0,1224,1226,5,219,0,0,1225,1224,1,0,0,0,1225,
  	1226,1,0,0,0,1226,1227,1,0,0,0,1227,1229,3,200,100,0,1228,1221,1,0,0,
  	0,1229,1232,1,0,0,0,1230,1228,1,0,0,0,1230,1231,1,0,0,0,1231,127,1,0,
  	0,0,1232,1230,1,0,0,0,1233,1234,5,118,0,0,1234,1235,5,219,0,0,1235,1236,
  	3,200,100,0,1236,1237,5,219,0,0,1237,1238,5,80,0,0,1238,1239,5,219,0,
  	0,1239,1250,3,200,100,0,1240,1242,5,219,0,0,1241,1240,1,0,0,0,1241,1242,
  	1,0,0,0,1242,1243,1,0,0,0,1243,1245,5,1,0,0,1244,1246,5,219,0,0,1245,
  	1244,1,0,0,0,1245,1246,1,0,0,0,1246,1247,1,0,0,0,1247,1249,3,200,100,
  	0,1248,1241,1,0,0,0,1249,1252,1,0,0,0,1250,1248,1,0,0,0,1250,1251,1,0,
  	0,0,1251,129,1,0,0,0,1252,1250,1,0,0,0,1253,1254,5,121,0,0,1254,1255,
  	5,219,0,0,1255,1256,3,200,100,0,1256,1257,5,219,0,0,1257,1258,5,76,0,
  	0,1258,1259,5,219,0,0,1259,1264,7,6,0,0,1260,1261,5,219,0,0,1261,1262,
  	5,9,0,0,1262,1263,5,219,0,0,1263,1265,7,7,0,0,1264,1260,1,0,0,0,1264,
  	1265,1,0,0,0,1265,1268,1,0,0,0,1266,1267,5,219,0,0,1267,1269,7,8,0,0,
  	1268,1266,1,0,0,0,1268,1269,1,0,0,0,1269,1270,1,0,0,0,1270,1271,5,219,
  	0,0,1271,1272,5,16,0,0,1272,1273,5,219,0,0,1273,1284,3,216,108,0,1274,
  	1275,5,219,0,0,1275,1277,5,94,0,0,1276,1278,5,219,0,0,1277,1276,1,0,0,
  	0,1277,1278,1,0,0,0,1278,1279,1,0,0,0,1279,1281,5,189,0,0,1280,1282,5,
  	219,0,0,1281,1280,1,0,0,0,1281,1282,1,0,0,0,1282,1283,1,0,0,0,1283,1285,
  	3,200,100,0,1284,1274,1,0,0,0,1284,1285,1,0,0,0,1285,131,1,0,0,0,1286,
  	1299,3,134,67,0,1287,1289,5,219,0,0,1288,1287,1,0,0,0,1288,1289,1,0,0,
  	0,1289,1290,1,0,0,0,1290,1292,7,9,0,0,1291,1293,5,219,0,0,1292,1291,1,
  	0,0,0,1292,1293,1,0,0,0,1293,1295,1,0,0,0,1294,1296,3,134,67,0,1295,1294,
  	1,0,0,0,1295,1296,1,0,0,0,1296,1298,1,0,0,0,1297,1288,1,0,0,0,1298,1301,
  	1,0,0,0,1299,1297,1,0,0,0,1299,1300,1,0,0,0,1300,1320,1,0,0,0,1301,1299,
  	1,0,0,0,1302,1304,3,134,67,0,1303,1302,1,0,0,0,1303,1304,1,0,0,0,1304,
  	1315,1,0,0,0,1305,1307,5,219,0,0,1306,1305,1,0,0,0,1306,1307,1,0,0,0,
  	1307,1308,1,0,0,0,1308,1310,7,9,0,0,1309,1311,5,219,0,0,1310,1309,1,0,
  	0,0,1310,1311,1,0,0,0,1311,1313,1,0,0,0,1312,1314,3,134,67,0,1313,1312,
  	1,0,0,0,1313,1314,1,0,0,0,1314,1316,1,0,0,0,1315,1306,1,0,0,0,1316,1317,
  	1,0,0,0,1317,1315,1,0,0,0,1317,1318,1,0,0,0,1318,1320,1,0,0,0,1319,1286,
  	1,0,0,0,1319,1303,1,0,0,0,1320,133,1,0,0,0,1321,1339,3,200,100,0,1322,
  	1336,7,10,0,0,1323,1325,5,219,0,0,1324,1323,1,0,0,0,1324,1325,1,0,0,0,
  	1325,1326,1,0,0,0,1326,1328,5,193,0,0,1327,1329,5,219,0,0,1328,1327,1,
  	0,0,0,1328,1329,1,0,0,0,1329,1330,1,0,0,0,1330,1332,3,242,121,0,1331,
  	1333,5,219,0,0,1332,1331,1,0,0,0,1332,1333,1,0,0,0,1333,1334,1,0,0,0,
  	1334,1335,5,202,0,0,1335,1337,1,0,0,0,1336,1324,1,0,0,0,1336,1337,1,0,
  	0,0,1337,1339,1,0,0,0,1338,1321,1,0,0,0,1338,1322,1,0,0,0,1339,135,1,
  	0,0,0,1340,1341,5,131,0,0,1341,1342,5,219,0,0,1342,1344,3,216,108,0,1343,
  	1345,5,219,0,0,1344,1343,1,0,0,0,1344,1345,1,0,0,0,1345,1346,1,0,0,0,
  	1346,1351,5,1,0,0,1347,1349,5,219,0,0,1348,1347,1,0,0,0,1348,1349,1,0,
  	0,0,1349,1350,1,0,0,0,1350,1352,3,132,66,0,1351,1348,1,0,0,0,1351,1352,
  	1,0,0,0,1352,137,1,0,0,0,1353,1354,3,282,141,0,1354,1355,5,219,0,0,1355,
  	1357,1,0,0,0,1356,1353,1,0,0,0,1356,1357,1,0,0,0,1357,1360,1,0,0,0,1358,
  	1359,5,161,0,0,1359,1361,5,219,0,0,1360,1358,1,0,0,0,1360,1361,1,0,0,
  	0,1361,1362,1,0,0,0,1362,1363,5,133,0,0,1363,1364,5,219,0,0,1364,1366,
  	3,258,129,0,1365,1367,3,280,140,0,1366,1365,1,0,0,0,1366,1367,1,0,0,0,
  	1367,1372,1,0,0,0,1368,1370,5,219,0,0,1369,1368,1,0,0,0,1369,1370,1,0,
  	0,0,1370,1371,1,0,0,0,1371,1373,3,248,124,0,1372,1369,1,0,0,0,1372,1373,
  	1,0,0,0,1373,1376,1,0,0,0,1374,1375,5,219,0,0,1375,1377,3,260,130,0,1376,
  	1374,1,0,0,0,1376,1377,1,0,0,0,1377,1378,1,0,0,0,1378,1380,3,292,146,
  	0,1379,1381,3,26,13,0,1380,1379,1,0,0,0,1380,1381,1,0,0,0,1381,1382,1,
  	0,0,0,1382,1383,5,57,0,0,1383,139,1,0,0,0,1384,1385,3,282,141,0,1385,
  	1386,5,219,0,0,1386,1388,1,0,0,0,1387,1384,1,0,0,0,1387,1388,1,0,0,0,
  	1388,1391,1,0,0,0,1389,1390,5,161,0,0,1390,1392,5,219,0,0,1391,1389,1,
  	0,0,0,1391,1392,1,0,0,0,1392,1393,1,0,0,0,1393,1394,5,135,0,0,1394,1395,
  	5,219,0,0,1395,1400,3,258,129,0,1396,1398,5,219,0,0,1397,1396,1,0,0,0,
  	1397,1398,1,0,0,0,1398,1399,1,0,0,0,1399,1401,3,248,124,0,1400,1397,1,
  	0,0,0,1400,1401,1,0,0,0,1401,1402,1,0,0,0,1402,1404,3,292,146,0,1403,
  	1405,3,26,13,0,1404,1403,1,0,0,0,1404,1405,1,0,0,0,1405,1406,1,0,0,0,
  	1406,1407,5,57,0,0,1407,141,1,0,0,0,1408,1409,3,282,141,0,1409,1410,5,
  	219,0,0,1410,1412,1,0,0,0,1411,1408,1,0,0,0,1411,1412,1,0,0,0,1412,1415,
  	1,0,0,0,1413,1414,5,161,0,0,1414,1416,5,219,0,0,1415,1413,1,0,0,0,1415,
  	1416,1,0,0,0,1416,1417,1,0,0,0,1417,1418,5,134,0,0,1418,1419,5,219,0,
  	0,1419,1424,3,258,129,0,1420,1422,5,219,0,0,1421,1420,1,0,0,0,1421,1422,
  	1,0,0,0,1422,1423,1,0,0,0,1423,1425,3,248,124,0,1424,1421,1,0,0,0,1424,
  	1425,1,0,0,0,1425,1426,1,0,0,0,1426,1428,3,292,146,0,1427,1429,3,26,13,
  	0,1428,1427,1,0,0,0,1428,1429,1,0,0,0,1429,1430,1,0,0,0,1430,1431,5,57,
  	0,0,1431,143,1,0,0,0,1432,1433,5,138,0,0,1433,1434,5,219,0,0,1434,1436,
  	3,216,108,0,1435,1437,5,219,0,0,1436,1435,1,0,0,0,1436,1437,1,0,0,0,1437,
  	1438,1,0,0,0,1438,1440,5,1,0,0,1439,1441,5,219,0,0,1440,1439,1,0,0,0,
  	1440,1441,1,0,0,0,1441,1443,1,0,0,0,1442,1444,3,200,100,0,1443,1442,1,
  	0,0,0,1443,1444,1,0,0,0,1444,1446,1,0,0,0,1445,1447,5,219,0,0,1446,1445,
  	1,0,0,0,1446,1447,1,0,0,0,1447,1448,1,0,0,0,1448,1450,5,1,0,0,1449,1451,
  	5,219,0,0,1450,1449,1,0,0,0,1450,1451,1,0,0,0,1451,1452,1,0,0,0,1452,
  	1453,3,200,100,0,1453,145,1,0,0,0,1454,1455,5,141,0,0,1455,1456,5,219,
  	0,0,1456,1471,3,258,129,0,1457,1459,5,219,0,0,1458,1457,1,0,0,0,1458,
  	1459,1,0,0,0,1459,1460,1,0,0,0,1460,1462,5,193,0,0,1461,1463,5,219,0,
  	0,1462,1461,1,0,0,0,1462,1463,1,0,0,0,1463,1468,1,0,0,0,1464,1466,3,242,
  	121,0,1465,1467,5,219,0,0,1466,1465,1,0,0,0,1466,1467,1,0,0,0,1467,1469,
  	1,0,0,0,1468,1464,1,0,0,0,1468,1469,1,0,0,0,1469,1470,1,0,0,0,1470,1472,
  	5,202,0,0,1471,1458,1,0,0,0,1471,1472,1,0,0,0,1472,147,1,0,0,0,1473,1476,
  	5,140,0,0,1474,1475,5,219,0,0,1475,1477,3,200,100,0,1476,1474,1,0,0,0,
  	1476,1477,1,0,0,0,1477,149,1,0,0,0,1478,1479,5,144,0,0,1479,1482,5,219,
  	0,0,1480,1481,5,130,0,0,1481,1483,5,219,0,0,1482,1480,1,0,0,0,1482,1483,
  	1,0,0,0,1483,1484,1,0,0,0,1484,1495,3,152,76,0,1485,1487,5,219,0,0,1486,
  	1485,1,0,0,0,1486,1487,1,0,0,0,1487,1488,1,0,0,0,1488,1490,5,1,0,0,1489,
  	1491,5,219,0,0,1490,1489,1,0,0,0,1490,1491,1,0,0,0,1491,1492,1,0,0,0,
  	1492,1494,3,152,76,0,1493,1486,1,0,0,0,1494,1497,1,0,0,0,1495,1493,1,
  	0,0,0,1495,1496,1,0,0,0,1496,151,1,0,0,0,1497,1495,1,0,0,0,1498,1500,
  	3,230,115,0,1499,1501,5,219,0,0,1500,1499,1,0,0,0,1500,1501,1,0,0,0,1501,
  	1502,1,0,0,0,1502,1504,5,193,0,0,1503,1505,5,219,0,0,1504,1503,1,0,0,
  	0,1504,1505,1,0,0,0,1505,1506,1,0,0,0,1506,1508,3,254,127,0,1507,1509,
  	5,219,0,0,1508,1507,1,0,0,0,1508,1509,1,0,0,0,1509,1510,1,0,0,0,1510,
  	1513,5,202,0,0,1511,1512,5,219,0,0,1512,1514,3,260,130,0,1513,1511,1,
  	0,0,0,1513,1514,1,0,0,0,1514,153,1,0,0,0,1515,1516,5,146,0,0,1516,155,
  	1,0,0,0,1517,1523,5,147,0,0,1518,1521,5,219,0,0,1519,1522,5,113,0,0,1520,
  	1522,3,258,129,0,1521,1519,1,0,0,0,1521,1520,1,0,0,0,1522,1524,1,0,0,
  	0,1523,1518,1,0,0,0,1523,1524,1,0,0,0,1524,157,1,0,0,0,1525,1526,5,148,
  	0,0,1526,159,1,0,0,0,1527,1528,5,149,0,0,1528,1529,5,219,0,0,1529,1530,
  	3,200,100,0,1530,161,1,0,0,0,1531,1532,5,150,0,0,1532,1533,5,219,0,0,
  	1533,1535,3,230,115,0,1534,1536,5,219,0,0,1535,1534,1,0,0,0,1535,1536,
  	1,0,0,0,1536,1537,1,0,0,0,1537,1539,5,189,0,0,1538,1540,5,219,0,0,1539,
  	1538,1,0,0,0,1539,1540,1,0,0,0,1540,1541,1,0,0,0,1541,1542,3,200,100,
  	0,1542,163,1,0,0,0,1543,1544,5,151,0,0,1544,1545,5,219,0,0,1545,1547,
  	3,200,100,0,1546,1548,5,219,0,0,1547,1546,1,0,0,0,1547,1548,1,0,0,0,1548,
  	1549,1,0,0,0,1549,1551,5,1,0,0,1550,1552,5,219,0,0,1551,1550,1,0,0,0,
  	1551,1552,1,0,0,0,1552,1553,1,0,0,0,1553,1554,3,200,100,0,1554,165,1,
  	0,0,0,1555,1556,5,152,0,0,1556,1557,5,219,0,0,1557,1559,3,200,100,0,1558,
  	1560,5,219,0,0,1559,1558,1,0,0,0,1559,1560,1,0,0,0,1560,1561,1,0,0,0,
  	1561,1563,5,1,0,0,1562,1564,5,219,0,0,1563,1562,1,0,0,0,1563,1564,1,0,
  	0,0,1564,1565,1,0,0,0,1565,1567,3,200,100,0,1566,1568,5,219,0,0,1567,
  	1566,1,0,0,0,1567,1568,1,0,0,0,1568,1569,1,0,0,0,1569,1571,5,1,0,0,1570,
  	1572,5,219,0,0,1571,1570,1,0,0,0,1571,1572,1,0,0,0,1572,1573,1,0,0,0,
  	1573,1575,3,200,100,0,1574,1576,5,219,0,0,1575,1574,1,0,0,0,1575,1576,
  	1,0,0,0,1576,1577,1,0,0,0,1577,1579,5,1,0,0,1578,1580,5,219,0,0,1579,
  	1578,1,0,0,0,1579,1580,1,0,0,0,1580,1581,1,0,0,0,1581,1582,3,200,100,
  	0,1582,167,1,0,0,0,1583,1584,5,153,0,0,1584,1585,5,219,0,0,1585,1587,
  	3,216,108,0,1586,1588,5,219,0,0,1587,1586,1,0,0,0,1587,1588,1,0,0,0,1588,
  	1589,1,0,0,0,1589,1591,5,1,0,0,1590,1592,5,219,0,0,1591,1590,1,0,0,0,
  	1591,1592,1,0,0,0,1592,1593,1,0,0,0,1593,1594,3,200,100,0,1594,169,1,
  	0,0,0,1595,1596,5,154,0,0,1596,1597,5,219,0,0,1597,1598,5,25,0,0,1598,
  	1599,5,219,0,0,1599,1600,3,200,100,0,1600,1604,3,292,146,0,1601,1603,
  	3,174,87,0,1602,1601,1,0,0,0,1603,1606,1,0,0,0,1604,1602,1,0,0,0,1604,
  	1605,1,0,0,0,1605,1607,1,0,0,0,1606,1604,1,0,0,0,1607,1608,5,58,0,0,1608,
  	171,1,0,0,0,1609,1611,5,87,0,0,1610,1612,5,219,0,0,1611,1610,1,0,0,0,
  	1611,1612,1,0,0,0,1612,1613,1,0,0,0,1613,1615,3,266,133,0,1614,1616,5,
  	219,0,0,1615,1614,1,0,0,0,1615,1616,1,0,0,0,1616,1617,1,0,0,0,1617,1618,
  	3,200,100,0,1618,1627,1,0,0,0,1619,1620,3,200,100,0,1620,1621,5,219,0,
  	0,1621,1622,5,170,0,0,1622,1623,5,219,0,0,1623,1624,3,200,100,0,1624,
  	1627,1,0,0,0,1625,1627,3,200,100,0,1626,1609,1,0,0,0,1626,1619,1,0,0,
  	0,1626,1625,1,0,0,0,1627,173,1,0,0,0,1628,1629,5,25,0,0,1629,1630,5,219,
  	0,0,1630,1631,3,176,88,0,1631,1633,3,292,146,0,1632,1634,3,26,13,0,1633,
  	1632,1,0,0,0,1633,1634,1,0,0,0,1634,175,1,0,0,0,1635,1651,5,52,0,0,1636,
  	1647,3,172,86,0,1637,1639,5,219,0,0,1638,1637,1,0,0,0,1638,1639,1,0,0,
  	0,1639,1640,1,0,0,0,1640,1642,5,1,0,0,1641,1643,5,219,0,0,1642,1641,1,
  	0,0,0,1642,1643,1,0,0,0,1643,1644,1,0,0,0,1644,1646,3,172,86,0,1645,1638,
  	1,0,0,0,1646,1649,1,0,0,0,1647,1645,1,0,0,0,1647,1648,1,0,0,0,1648,1651,
  	1,0,0,0,1649,1647,1,0,0,0,1650,1635,1,0,0,0,1650,1636,1,0,0,0,1651,177,
  	1,0,0,0,1652,1653,5,155,0,0,1653,1654,5,219,0,0,1654,1663,3,200,100,0,
  	1655,1657,5,219,0,0,1656,1655,1,0,0,0,1656,1657,1,0,0,0,1657,1658,1,0,
  	0,0,1658,1660,5,1,0,0,1659,1661,5,219,0,0,1660,1659,1,0,0,0,1660,1661,
  	1,0,0,0,1661,1662,1,0,0,0,1662,1664,3,200,100,0,1663,1656,1,0,0,0,1663,
  	1664,1,0,0,0,1664,179,1,0,0,0,1665,1666,5,157,0,0,1666,1667,5,219,0,0,
  	1667,1669,3,200,100,0,1668,1670,5,219,0,0,1669,1668,1,0,0,0,1669,1670,
  	1,0,0,0,1670,1671,1,0,0,0,1671,1673,5,1,0,0,1672,1674,5,219,0,0,1673,
  	1672,1,0,0,0,1673,1674,1,0,0,0,1674,1675,1,0,0,0,1675,1676,3,200,100,
  	0,1676,181,1,0,0,0,1677,1678,5,156,0,0,1678,1679,5,219,0,0,1679,1681,
  	3,230,115,0,1680,1682,5,219,0,0,1681,1680,1,0,0,0,1681,1682,1,0,0,0,1682,
  	1683,1,0,0,0,1683,1685,5,189,0,0,1684,1686,5,219,0,0,1685,1684,1,0,0,
  	0,1685,1686,1,0,0,0,1686,1687,1,0,0,0,1687,1688,3,200,100,0,1688,183,
  	1,0,0,0,1689,1690,5,163,0,0,1690,185,1,0,0,0,1691,1692,3,282,141,0,1692,
  	1693,5,219,0,0,1693,1695,1,0,0,0,1694,1691,1,0,0,0,1694,1695,1,0,0,0,
  	1695,1698,1,0,0,0,1696,1697,5,161,0,0,1697,1699,5,219,0,0,1698,1696,1,
  	0,0,0,1698,1699,1,0,0,0,1699,1700,1,0,0,0,1700,1702,5,165,0,0,1701,1703,
  	5,219,0,0,1702,1701,1,0,0,0,1702,1703,1,0,0,0,1703,1704,1,0,0,0,1704,
  	1709,3,258,129,0,1705,1707,5,219,0,0,1706,1705,1,0,0,0,1706,1707,1,0,
  	0,0,1707,1708,1,0,0,0,1708,1710,3,248,124,0,1709,1706,1,0,0,0,1709,1710,
  	1,0,0,0,1710,1711,1,0,0,0,1711,1713,3,292,146,0,1712,1714,3,26,13,0,1713,
  	1712,1,0,0,0,1713,1714,1,0,0,0,1714,1715,1,0,0,0,1715,1716,5,59,0,0,1716,
  	187,1,0,0,0,1717,1719,5,169,0,0,1718,1720,5,219,0,0,1719,1718,1,0,0,0,
  	1719,1720,1,0,0,0,1720,1721,1,0,0,0,1721,1723,5,189,0,0,1722,1724,5,219,
  	0,0,1723,1722,1,0,0,0,1723,1724,1,0,0,0,1724,1725,1,0,0,0,1725,1726,3,
  	200,100,0,1726,189,1,0,0,0,1727,1728,3,282,141,0,1728,1729,5,219,0,0,
  	1729,1731,1,0,0,0,1730,1727,1,0,0,0,1730,1731,1,0,0,0,1731,1732,1,0,0,
  	0,1732,1733,5,172,0,0,1733,1734,5,219,0,0,1734,1735,3,258,129,0,1735,
  	1739,3,292,146,0,1736,1738,3,192,96,0,1737,1736,1,0,0,0,1738,1741,1,0,
  	0,0,1739,1737,1,0,0,0,1739,1740,1,0,0,0,1740,1742,1,0,0,0,1741,1739,1,
  	0,0,0,1742,1743,5,60,0,0,1743,191,1,0,0,0,1744,1759,3,258,129,0,1745,
  	1747,5,219,0,0,1746,1745,1,0,0,0,1746,1747,1,0,0,0,1747,1748,1,0,0,0,
  	1748,1753,5,193,0,0,1749,1751,5,219,0,0,1750,1749,1,0,0,0,1750,1751,1,
  	0,0,0,1751,1752,1,0,0,0,1752,1754,3,254,127,0,1753,1750,1,0,0,0,1753,
  	1754,1,0,0,0,1754,1756,1,0,0,0,1755,1757,5,219,0,0,1756,1755,1,0,0,0,
  	1756,1757,1,0,0,0,1757,1758,1,0,0,0,1758,1760,5,202,0,0,1759,1746,1,0,
  	0,0,1759,1760,1,0,0,0,1760,1763,1,0,0,0,1761,1762,5,219,0,0,1762,1764,
  	3,260,130,0,1763,1761,1,0,0,0,1763,1764,1,0,0,0,1764,1765,1,0,0,0,1765,
  	1766,3,292,146,0,1766,193,1,0,0,0,1767,1768,5,173,0,0,1768,1769,5,219,
  	0,0,1769,1774,3,200,100,0,1770,1771,5,219,0,0,1771,1772,5,87,0,0,1772,
  	1773,5,219,0,0,1773,1775,3,278,139,0,1774,1770,1,0,0,0,1774,1775,1,0,
  	0,0,1775,195,1,0,0,0,1776,1777,5,174,0,0,1777,1778,5,219,0,0,1778,1779,
  	3,200,100,0,1779,197,1,0,0,0,1780,1781,5,175,0,0,1781,1782,5,219,0,0,
  	1782,1797,3,216,108,0,1783,1785,5,219,0,0,1784,1783,1,0,0,0,1784,1785,
  	1,0,0,0,1785,1786,1,0,0,0,1786,1788,5,1,0,0,1787,1789,5,219,0,0,1788,
  	1787,1,0,0,0,1788,1789,1,0,0,0,1789,1790,1,0,0,0,1790,1795,3,200,100,
  	0,1791,1792,5,219,0,0,1792,1793,5,170,0,0,1793,1794,5,219,0,0,1794,1796,
  	3,200,100,0,1795,1791,1,0,0,0,1795,1796,1,0,0,0,1796,1798,1,0,0,0,1797,
  	1784,1,0,0,0,1797,1798,1,0,0,0,1798,199,1,0,0,0,1799,1800,6,100,-1,0,
  	1800,1860,3,276,138,0,1801,1860,3,230,115,0,1802,1804,5,193,0,0,1803,
  	1805,5,219,0,0,1804,1803,1,0,0,0,1804,1805,1,0,0,0,1805,1806,1,0,0,0,
  	1806,1817,3,200,100,0,1807,1809,5,219,0,0,1808,1807,1,0,0,0,1808,1809,
  	1,0,0,0,1809,1810,1,0,0,0,1810,1812,5,1,0,0,1811,1813,5,219,0,0,1812,
  	1811,1,0,0,0,1812,1813,1,0,0,0,1813,1814,1,0,0,0,1814,1816,3,200,100,
  	0,1815,1808,1,0,0,0,1816,1819,1,0,0,0,1817,1815,1,0,0,0,1817,1818,1,0,
  	0,0,1818,1820,1,0,0,0,1819,1817,1,0,0,0,1820,1821,5,202,0,0,1821,1860,
  	1,0,0,0,1822,1824,5,114,0,0,1823,1825,5,219,0,0,1824,1823,1,0,0,0,1824,
  	1825,1,0,0,0,1825,1826,1,0,0,0,1826,1860,3,200,100,19,1827,1860,3,194,
  	97,0,1828,1860,3,118,59,0,1829,1831,5,10,0,0,1830,1832,5,219,0,0,1831,
  	1830,1,0,0,0,1831,1832,1,0,0,0,1832,1833,1,0,0,0,1833,1860,3,200,100,
  	16,1834,1836,3,230,115,0,1835,1837,5,219,0,0,1836,1835,1,0,0,0,1836,1837,
  	1,0,0,0,1837,1838,1,0,0,0,1838,1840,5,187,0,0,1839,1841,5,219,0,0,1840,
  	1839,1,0,0,0,1840,1841,1,0,0,0,1841,1842,1,0,0,0,1842,1843,3,200,100,
  	15,1843,1860,1,0,0,0,1844,1846,5,195,0,0,1845,1847,5,219,0,0,1846,1845,
  	1,0,0,0,1846,1847,1,0,0,0,1847,1848,1,0,0,0,1848,1860,3,200,100,13,1849,
  	1851,5,199,0,0,1850,1852,5,219,0,0,1851,1850,1,0,0,0,1851,1852,1,0,0,
  	0,1852,1853,1,0,0,0,1853,1860,3,200,100,12,1854,1856,5,115,0,0,1855,1857,
  	5,219,0,0,1856,1855,1,0,0,0,1856,1857,1,0,0,0,1857,1858,1,0,0,0,1858,
  	1860,3,200,100,6,1859,1799,1,0,0,0,1859,1801,1,0,0,0,1859,1802,1,0,0,
  	0,1859,1822,1,0,0,0,1859,1827,1,0,0,0,1859,1828,1,0,0,0,1859,1829,1,0,
  	0,0,1859,1834,1,0,0,0,1859,1844,1,0,0,0,1859,1849,1,0,0,0,1859,1854,1,
  	0,0,0,1860,1962,1,0,0,0,1861,1863,10,14,0,0,1862,1864,5,219,0,0,1863,
  	1862,1,0,0,0,1863,1864,1,0,0,0,1864,1865,1,0,0,0,1865,1867,5,201,0,0,
  	1866,1868,5,219,0,0,1867,1866,1,0,0,0,1867,1868,1,0,0,0,1868,1869,1,0,
  	0,0,1869,1961,3,200,100,15,1870,1872,10,11,0,0,1871,1873,5,219,0,0,1872,
  	1871,1,0,0,0,1872,1873,1,0,0,0,1873,1874,1,0,0,0,1874,1876,7,11,0,0,1875,
  	1877,5,219,0,0,1876,1875,1,0,0,0,1876,1877,1,0,0,0,1877,1878,1,0,0,0,
  	1878,1961,3,200,100,12,1879,1881,10,10,0,0,1880,1882,5,219,0,0,1881,1880,
  	1,0,0,0,1881,1882,1,0,0,0,1882,1883,1,0,0,0,1883,1885,5,111,0,0,1884,
  	1886,5,219,0,0,1885,1884,1,0,0,0,1885,1886,1,0,0,0,1886,1887,1,0,0,0,
  	1887,1961,3,200,100,11,1888,1890,10,9,0,0,1889,1891,5,219,0,0,1890,1889,
  	1,0,0,0,1890,1891,1,0,0,0,1891,1892,1,0,0,0,1892,1894,7,12,0,0,1893,1895,
  	5,219,0,0,1894,1893,1,0,0,0,1894,1895,1,0,0,0,1895,1896,1,0,0,0,1896,
  	1961,3,200,100,10,1897,1899,10,8,0,0,1898,1900,5,219,0,0,1899,1898,1,
  	0,0,0,1899,1900,1,0,0,0,1900,1901,1,0,0,0,1901,1903,5,186,0,0,1902,1904,
  	5,219,0,0,1903,1902,1,0,0,0,1903,1904,1,0,0,0,1904,1905,1,0,0,0,1905,
  	1961,3,200,100,9,1906,1908,10,7,0,0,1907,1909,5,219,0,0,1908,1907,1,0,
  	0,0,1908,1909,1,0,0,0,1909,1910,1,0,0,0,1910,1912,7,13,0,0,1911,1913,
  	5,219,0,0,1912,1911,1,0,0,0,1912,1913,1,0,0,0,1913,1914,1,0,0,0,1914,
  	1961,3,200,100,8,1915,1917,10,5,0,0,1916,1918,5,219,0,0,1917,1916,1,0,
  	0,0,1917,1918,1,0,0,0,1918,1919,1,0,0,0,1919,1921,5,12,0,0,1920,1922,
  	5,219,0,0,1921,1920,1,0,0,0,1921,1922,1,0,0,0,1922,1923,1,0,0,0,1923,
  	1961,3,200,100,6,1924,1926,10,4,0,0,1925,1927,5,219,0,0,1926,1925,1,0,
  	0,0,1926,1927,1,0,0,0,1927,1928,1,0,0,0,1928,1930,5,127,0,0,1929,1931,
  	5,219,0,0,1930,1929,1,0,0,0,1930,1931,1,0,0,0,1931,1932,1,0,0,0,1932,
  	1961,3,200,100,5,1933,1935,10,3,0,0,1934,1936,5,219,0,0,1935,1934,1,0,
  	0,0,1935,1936,1,0,0,0,1936,1937,1,0,0,0,1937,1939,5,185,0,0,1938,1940,
  	5,219,0,0,1939,1938,1,0,0,0,1939,1940,1,0,0,0,1940,1941,1,0,0,0,1941,
  	1961,3,200,100,4,1942,1944,10,2,0,0,1943,1945,5,219,0,0,1944,1943,1,0,
  	0,0,1944,1945,1,0,0,0,1945,1946,1,0,0,0,1946,1948,5,64,0,0,1947,1949,
  	5,219,0,0,1948,1947,1,0,0,0,1948,1949,1,0,0,0,1949,1950,1,0,0,0,1950,
  	1961,3,200,100,3,1951,1953,10,1,0,0,1952,1954,5,219,0,0,1953,1952,1,0,
  	0,0,1953,1954,1,0,0,0,1954,1955,1,0,0,0,1955,1957,5,83,0,0,1956,1958,
  	5,219,0,0,1957,1956,1,0,0,0,1957,1958,1,0,0,0,1958,1959,1,0,0,0,1959,
  	1961,3,200,100,2,1960,1861,1,0,0,0,1960,1870,1,0,0,0,1960,1879,1,0,0,
  	0,1960,1888,1,0,0,0,1960,1897,1,0,0,0,1960,1906,1,0,0,0,1960,1915,1,0,
  	0,0,1960,1924,1,0,0,0,1960,1933,1,0,0,0,1960,1942,1,0,0,0,1960,1951,1,
  	0,0,0,1961,1964,1,0,0,0,1962,1960,1,0,0,0,1962,1963,1,0,0,0,1963,201,
  	1,0,0,0,1964,1962,1,0,0,0,1965,1969,5,48,0,0,1966,1969,5,161,0,0,1967,
  	1969,3,282,141,0,1968,1965,1,0,0,0,1968,1966,1,0,0,0,1968,1967,1,0,0,
  	0,1969,1970,1,0,0,0,1970,1973,5,219,0,0,1971,1972,5,183,0,0,1972,1974,
  	5,219,0,0,1973,1971,1,0,0,0,1973,1974,1,0,0,0,1974,1975,1,0,0,0,1975,
  	1976,3,204,102,0,1976,203,1,0,0,0,1977,1988,3,206,103,0,1978,1980,5,219,
  	0,0,1979,1978,1,0,0,0,1979,1980,1,0,0,0,1980,1981,1,0,0,0,1981,1983,5,
  	1,0,0,1982,1984,5,219,0,0,1983,1982,1,0,0,0,1983,1984,1,0,0,0,1984,1985,
  	1,0,0,0,1985,1987,3,206,103,0,1986,1979,1,0,0,0,1987,1990,1,0,0,0,1988,
  	1986,1,0,0,0,1988,1989,1,0,0,0,1989,205,1,0,0,0,1990,1988,1,0,0,0,1991,
  	2009,3,258,129,0,1992,1994,5,219,0,0,1993,1992,1,0,0,0,1993,1994,1,0,
  	0,0,1994,1995,1,0,0,0,1995,1997,5,193,0,0,1996,1998,5,219,0,0,1997,1996,
  	1,0,0,0,1997,1998,1,0,0,0,1998,2003,1,0,0,0,1999,2001,3,254,127,0,2000,
  	2002,5,219,0,0,2001,2000,1,0,0,0,2001,2002,1,0,0,0,2002,2004,1,0,0,0,
  	2003,1999,1,0,0,0,2003,2004,1,0,0,0,2004,2005,1,0,0,0,2005,2007,5,202,
  	0,0,2006,2008,5,219,0,0,2007,2006,1,0,0,0,2007,2008,1,0,0,0,2008,2010,
  	1,0,0,0,2009,1993,1,0,0,0,2009,2010,1,0,0,0,2010,2012,1,0,0,0,2011,2013,
  	3,280,140,0,2012,2011,1,0,0,0,2012,2013,1,0,0,0,2013,2016,1,0,0,0,2014,
  	2015,5,219,0,0,2015,2017,3,260,130,0,2016,2014,1,0,0,0,2016,2017,1,0,
  	0,0,2017,207,1,0,0,0,2018,2019,5,180,0,0,2019,2020,5,219,0,0,2020,2021,
  	3,200,100,0,2021,2023,3,292,146,0,2022,2024,3,26,13,0,2023,2022,1,0,0,
  	0,2023,2024,1,0,0,0,2024,2025,1,0,0,0,2025,2026,5,179,0,0,2026,209,1,
  	0,0,0,2027,2028,5,181,0,0,2028,2029,5,219,0,0,2029,2031,3,216,108,0,2030,
  	2032,5,219,0,0,2031,2030,1,0,0,0,2031,2032,1,0,0,0,2032,2033,1,0,0,0,
  	2033,2035,5,1,0,0,2034,2036,5,219,0,0,2035,2034,1,0,0,0,2035,2036,1,0,
  	0,0,2036,2037,1,0,0,0,2037,2038,3,200,100,0,2038,211,1,0,0,0,2039,2040,
  	5,182,0,0,2040,2045,5,219,0,0,2041,2046,3,230,115,0,2042,2043,5,114,0,
  	0,2043,2044,5,219,0,0,2044,2046,3,278,139,0,2045,2041,1,0,0,0,2045,2042,
  	1,0,0,0,2046,2047,1,0,0,0,2047,2049,3,292,146,0,2048,2050,3,26,13,0,2049,
  	2048,1,0,0,0,2049,2050,1,0,0,0,2050,2051,1,0,0,0,2051,2052,5,61,0,0,2052,
  	213,1,0,0,0,2053,2054,5,184,0,0,2054,2055,5,219,0,0,2055,2057,3,216,108,
  	0,2056,2058,5,219,0,0,2057,2056,1,0,0,0,2057,2058,1,0,0,0,2058,2059,1,
  	0,0,0,2059,2064,5,1,0,0,2060,2062,5,219,0,0,2061,2060,1,0,0,0,2061,2062,
  	1,0,0,0,2062,2063,1,0,0,0,2063,2065,3,132,66,0,2064,2061,1,0,0,0,2064,
  	2065,1,0,0,0,2065,215,1,0,0,0,2066,2068,5,3,0,0,2067,2066,1,0,0,0,2067,
  	2068,1,0,0,0,2068,2069,1,0,0,0,2069,2070,3,200,100,0,2070,217,1,0,0,0,
  	2071,2074,3,220,110,0,2072,2074,3,222,111,0,2073,2071,1,0,0,0,2073,2072,
  	1,0,0,0,2074,219,1,0,0,0,2075,2076,5,24,0,0,2076,2077,5,219,0,0,2077,
  	2079,3,258,129,0,2078,2080,3,280,140,0,2079,2078,1,0,0,0,2079,2080,1,
  	0,0,0,2080,2094,1,0,0,0,2081,2083,5,219,0,0,2082,2081,1,0,0,0,2082,2083,
  	1,0,0,0,2083,2084,1,0,0,0,2084,2086,5,193,0,0,2085,2087,5,219,0,0,2086,
  	2085,1,0,0,0,2086,2087,1,0,0,0,2087,2088,1,0,0,0,2088,2090,3,242,121,
  	0,2089,2091,5,219,0,0,2090,2089,1,0,0,0,2090,2091,1,0,0,0,2091,2092,1,
  	0,0,0,2092,2093,5,202,0,0,2093,2095,1,0,0,0,2094,2082,1,0,0,0,2094,2095,
  	1,0,0,0,2095,2105,1,0,0,0,2096,2098,5,219,0,0,2097,2096,1,0,0,0,2097,
  	2098,1,0,0,0,2098,2099,1,0,0,0,2099,2100,5,193,0,0,2100,2101,3,254,127,
  	0,2101,2102,5,202,0,0,2102,2104,1,0,0,0,2103,2097,1,0,0,0,2104,2107,1,
  	0,0,0,2105,2103,1,0,0,0,2105,2106,1,0,0,0,2106,221,1,0,0,0,2107,2105,
  	1,0,0,0,2108,2109,5,24,0,0,2109,2111,5,219,0,0,2110,2112,3,230,115,0,
  	2111,2110,1,0,0,0,2111,2112,1,0,0,0,2112,2113,1,0,0,0,2113,2114,5,4,0,
  	0,2114,2116,3,258,129,0,2115,2117,3,280,140,0,2116,2115,1,0,0,0,2116,
  	2117,1,0,0,0,2117,2131,1,0,0,0,2118,2120,5,219,0,0,2119,2118,1,0,0,0,
  	2119,2120,1,0,0,0,2120,2121,1,0,0,0,2121,2123,5,193,0,0,2122,2124,5,219,
  	0,0,2123,2122,1,0,0,0,2123,2124,1,0,0,0,2124,2125,1,0,0,0,2125,2127,3,
  	242,121,0,2126,2128,5,219,0,0,2127,2126,1,0,0,0,2127,2128,1,0,0,0,2128,
  	2129,1,0,0,0,2129,2130,5,202,0,0,2130,2132,1,0,0,0,2131,2119,1,0,0,0,
  	2131,2132,1,0,0,0,2132,2142,1,0,0,0,2133,2135,5,219,0,0,2134,2133,1,0,
  	0,0,2134,2135,1,0,0,0,2135,2136,1,0,0,0,2136,2137,5,193,0,0,2137,2138,
  	3,254,127,0,2138,2139,5,202,0,0,2139,2141,1,0,0,0,2140,2134,1,0,0,0,2141,
  	2144,1,0,0,0,2142,2140,1,0,0,0,2142,2143,1,0,0,0,2143,223,1,0,0,0,2144,
  	2142,1,0,0,0,2145,2148,3,226,113,0,2146,2148,3,228,114,0,2147,2145,1,
  	0,0,0,2147,2146,1,0,0,0,2148,225,1,0,0,0,2149,2151,3,230,115,0,2150,2149,
  	1,0,0,0,2150,2151,1,0,0,0,2151,2152,1,0,0,0,2152,2153,5,4,0,0,2153,2155,
  	3,258,129,0,2154,2156,3,280,140,0,2155,2154,1,0,0,0,2155,2156,1,0,0,0,
  	2156,2159,1,0,0,0,2157,2158,5,219,0,0,2158,2160,3,242,121,0,2159,2157,
  	1,0,0,0,2159,2160,1,0,0,0,2160,2162,1,0,0,0,2161,2163,3,246,123,0,2162,
  	2161,1,0,0,0,2162,2163,1,0,0,0,2163,2173,1,0,0,0,2164,2166,5,219,0,0,
  	2165,2164,1,0,0,0,2165,2166,1,0,0,0,2166,2167,1,0,0,0,2167,2168,5,193,
  	0,0,2168,2169,3,254,127,0,2169,2170,5,202,0,0,2170,2172,1,0,0,0,2171,
  	2165,1,0,0,0,2172,2175,1,0,0,0,2173,2171,1,0,0,0,2173,2174,1,0,0,0,2174,
  	227,1,0,0,0,2175,2173,1,0,0,0,2176,2179,3,264,132,0,2177,2178,5,219,0,
  	0,2178,2180,3,242,121,0,2179,2177,1,0,0,0,2179,2180,1,0,0,0,2180,2190,
  	1,0,0,0,2181,2183,5,219,0,0,2182,2181,1,0,0,0,2182,2183,1,0,0,0,2183,
  	2184,1,0,0,0,2184,2185,5,193,0,0,2185,2186,3,254,127,0,2186,2187,5,202,
  	0,0,2187,2189,1,0,0,0,2188,2182,1,0,0,0,2189,2192,1,0,0,0,2190,2188,1,
  	0,0,0,2190,2191,1,0,0,0,2191,229,1,0,0,0,2192,2190,1,0,0,0,2193,2198,
  	3,236,118,0,2194,2198,3,232,116,0,2195,2198,3,234,117,0,2196,2198,3,240,
  	120,0,2197,2193,1,0,0,0,2197,2194,1,0,0,0,2197,2195,1,0,0,0,2197,2196,
  	1,0,0,0,2198,231,1,0,0,0,2199,2201,3,258,129,0,2200,2202,3,280,140,0,
  	2201,2200,1,0,0,0,2201,2202,1,0,0,0,2202,2204,1,0,0,0,2203,2205,3,246,
  	123,0,2204,2203,1,0,0,0,2204,2205,1,0,0,0,2205,2215,1,0,0,0,2206,2208,
  	5,219,0,0,2207,2206,1,0,0,0,2207,2208,1,0,0,0,2208,2209,1,0,0,0,2209,
  	2210,5,193,0,0,2210,2211,3,254,127,0,2211,2212,5,202,0,0,2212,2214,1,
  	0,0,0,2213,2207,1,0,0,0,2214,2217,1,0,0,0,2215,2213,1,0,0,0,2215,2216,
  	1,0,0,0,2216,233,1,0,0,0,2217,2215,1,0,0,0,2218,2221,3,258,129,0,2219,
  	2221,3,262,131,0,2220,2218,1,0,0,0,2220,2219,1,0,0,0,2221,2223,1,0,0,
  	0,2222,2224,3,280,140,0,2223,2222,1,0,0,0,2223,2224,1,0,0,0,2224,2226,
  	1,0,0,0,2225,2227,5,219,0,0,2226,2225,1,0,0,0,2226,2227,1,0,0,0,2227,
  	2228,1,0,0,0,2228,2230,5,193,0,0,2229,2231,5,219,0,0,2230,2229,1,0,0,
  	0,2230,2231,1,0,0,0,2231,2236,1,0,0,0,2232,2234,3,242,121,0,2233,2235,
  	5,219,0,0,2234,2233,1,0,0,0,2234,2235,1,0,0,0,2235,2237,1,0,0,0,2236,
  	2232,1,0,0,0,2236,2237,1,0,0,0,2237,2238,1,0,0,0,2238,2240,5,202,0,0,
  	2239,2241,3,246,123,0,2240,2239,1,0,0,0,2240,2241,1,0,0,0,2241,2251,1,
  	0,0,0,2242,2244,5,219,0,0,2243,2242,1,0,0,0,2243,2244,1,0,0,0,2244,2245,
  	1,0,0,0,2245,2246,5,193,0,0,2246,2247,3,254,127,0,2247,2248,5,202,0,0,
  	2248,2250,1,0,0,0,2249,2243,1,0,0,0,2250,2253,1,0,0,0,2251,2249,1,0,0,
  	0,2251,2252,1,0,0,0,2252,235,1,0,0,0,2253,2251,1,0,0,0,2254,2257,3,232,
  	116,0,2255,2257,3,234,117,0,2256,2254,1,0,0,0,2256,2255,1,0,0,0,2256,
  	2257,1,0,0,0,2257,2259,1,0,0,0,2258,2260,3,238,119,0,2259,2258,1,0,0,
  	0,2260,2261,1,0,0,0,2261,2259,1,0,0,0,2261,2262,1,0,0,0,2262,2264,1,0,
  	0,0,2263,2265,3,246,123,0,2264,2263,1,0,0,0,2264,2265,1,0,0,0,2265,2275,
  	1,0,0,0,2266,2268,5,219,0,0,2267,2266,1,0,0,0,2267,2268,1,0,0,0,2268,
  	2269,1,0,0,0,2269,2270,5,193,0,0,2270,2271,3,254,127,0,2271,2272,5,202,
  	0,0,2272,2274,1,0,0,0,2273,2267,1,0,0,0,2274,2277,1,0,0,0,2275,2273,1,
  	0,0,0,2275,2276,1,0,0,0,2276,237,1,0,0,0,2277,2275,1,0,0,0,2278,2280,
  	5,212,0,0,2279,2278,1,0,0,0,2279,2280,1,0,0,0,2280,2281,1,0,0,0,2281,
  	2283,7,14,0,0,2282,2284,5,212,0,0,2283,2282,1,0,0,0,2283,2284,1,0,0,0,
  	2284,2287,1,0,0,0,2285,2288,3,232,116,0,2286,2288,3,234,117,0,2287,2285,
  	1,0,0,0,2287,2286,1,0,0,0,2288,239,1,0,0,0,2289,2290,3,246,123,0,2290,
  	241,1,0,0,0,2291,2293,3,244,122,0,2292,2291,1,0,0,0,2292,2293,1,0,0,0,
  	2293,2295,1,0,0,0,2294,2296,5,219,0,0,2295,2294,1,0,0,0,2295,2296,1,0,
  	0,0,2296,2297,1,0,0,0,2297,2299,7,9,0,0,2298,2300,5,219,0,0,2299,2298,
  	1,0,0,0,2299,2300,1,0,0,0,2300,2302,1,0,0,0,2301,2292,1,0,0,0,2302,2305,
  	1,0,0,0,2303,2301,1,0,0,0,2303,2304,1,0,0,0,2304,2306,1,0,0,0,2305,2303,
  	1,0,0,0,2306,2319,3,244,122,0,2307,2309,5,219,0,0,2308,2307,1,0,0,0,2308,
  	2309,1,0,0,0,2309,2310,1,0,0,0,2310,2312,7,9,0,0,2311,2313,5,219,0,0,
  	2312,2311,1,0,0,0,2312,2313,1,0,0,0,2313,2315,1,0,0,0,2314,2316,3,244,
  	122,0,2315,2314,1,0,0,0,2315,2316,1,0,0,0,2316,2318,1,0,0,0,2317,2308,
  	1,0,0,0,2318,2321,1,0,0,0,2319,2317,1,0,0,0,2319,2320,1,0,0,0,2320,243,
  	1,0,0,0,2321,2319,1,0,0,0,2322,2324,5,193,0,0,2323,2322,1,0,0,0,2323,
  	2324,1,0,0,0,2324,2327,1,0,0,0,2325,2326,7,15,0,0,2326,2328,5,219,0,0,
  	2327,2325,1,0,0,0,2327,2328,1,0,0,0,2328,2330,1,0,0,0,2329,2331,5,202,
  	0,0,2330,2329,1,0,0,0,2330,2331,1,0,0,0,2331,2332,1,0,0,0,2332,2333,3,
  	200,100,0,2333,245,1,0,0,0,2334,2335,5,5,0,0,2335,2337,3,258,129,0,2336,
  	2338,3,280,140,0,2337,2336,1,0,0,0,2337,2338,1,0,0,0,2338,247,1,0,0,0,
  	2339,2357,5,193,0,0,2340,2342,5,219,0,0,2341,2340,1,0,0,0,2341,2342,1,
  	0,0,0,2342,2343,1,0,0,0,2343,2354,3,250,125,0,2344,2346,5,219,0,0,2345,
  	2344,1,0,0,0,2345,2346,1,0,0,0,2346,2347,1,0,0,0,2347,2349,5,1,0,0,2348,
  	2350,5,219,0,0,2349,2348,1,0,0,0,2349,2350,1,0,0,0,2350,2351,1,0,0,0,
  	2351,2353,3,250,125,0,2352,2345,1,0,0,0,2353,2356,1,0,0,0,2354,2352,1,
  	0,0,0,2354,2355,1,0,0,0,2355,2358,1,0,0,0,2356,2354,1,0,0,0,2357,2341,
  	1,0,0,0,2357,2358,1,0,0,0,2358,2360,1,0,0,0,2359,2361,5,219,0,0,2360,
  	2359,1,0,0,0,2360,2361,1,0,0,0,2361,2362,1,0,0,0,2362,2363,5,202,0,0,
  	2363,249,1,0,0,0,2364,2365,5,122,0,0,2365,2367,5,219,0,0,2366,2364,1,
  	0,0,0,2366,2367,1,0,0,0,2367,2370,1,0,0,0,2368,2369,7,16,0,0,2369,2371,
  	5,219,0,0,2370,2368,1,0,0,0,2370,2371,1,0,0,0,2371,2374,1,0,0,0,2372,
  	2373,5,129,0,0,2373,2375,5,219,0,0,2374,2372,1,0,0,0,2374,2375,1,0,0,
  	0,2375,2376,1,0,0,0,2376,2378,3,258,129,0,2377,2379,3,280,140,0,2378,
  	2377,1,0,0,0,2378,2379,1,0,0,0,2379,2388,1,0,0,0,2380,2382,5,219,0,0,
  	2381,2380,1,0,0,0,2381,2382,1,0,0,0,2382,2383,1,0,0,0,2383,2385,5,193,
  	0,0,2384,2386,5,219,0,0,2385,2384,1,0,0,0,2385,2386,1,0,0,0,2386,2387,
  	1,0,0,0,2387,2389,5,202,0,0,2388,2381,1,0,0,0,2388,2389,1,0,0,0,2389,
  	2394,1,0,0,0,2390,2392,5,219,0,0,2391,2390,1,0,0,0,2391,2392,1,0,0,0,
  	2392,2393,1,0,0,0,2393,2395,3,260,130,0,2394,2391,1,0,0,0,2394,2395,1,
  	0,0,0,2395,2400,1,0,0,0,2396,2398,5,219,0,0,2397,2396,1,0,0,0,2397,2398,
  	1,0,0,0,2398,2399,1,0,0,0,2399,2401,3,252,126,0,2400,2397,1,0,0,0,2400,
  	2401,1,0,0,0,2401,251,1,0,0,0,2402,2404,5,189,0,0,2403,2405,5,219,0,0,
  	2404,2403,1,0,0,0,2404,2405,1,0,0,0,2405,2406,1,0,0,0,2406,2407,3,200,
  	100,0,2407,253,1,0,0,0,2408,2419,3,256,128,0,2409,2411,5,219,0,0,2410,
  	2409,1,0,0,0,2410,2411,1,0,0,0,2411,2412,1,0,0,0,2412,2414,5,1,0,0,2413,
  	2415,5,219,0,0,2414,2413,1,0,0,0,2414,2415,1,0,0,0,2415,2416,1,0,0,0,
  	2416,2418,3,256,128,0,2417,2410,1,0,0,0,2418,2421,1,0,0,0,2419,2417,1,
  	0,0,0,2419,2420,1,0,0,0,2420,255,1,0,0,0,2421,2419,1,0,0,0,2422,2423,
  	3,200,100,0,2423,2424,5,219,0,0,2424,2425,5,170,0,0,2425,2426,5,219,0,
  	0,2426,2428,1,0,0,0,2427,2422,1,0,0,0,2427,2428,1,0,0,0,2428,2429,1,0,
  	0,0,2429,2430,3,200,100,0,2430,257,1,0,0,0,2431,2434,5,220,0,0,2432,2434,
  	3,284,142,0,2433,2431,1,0,0,0,2433,2432,1,0,0,0,2434,2435,1,0,0,0,2435,
  	2433,1,0,0,0,2435,2436,1,0,0,0,2436,259,1,0,0,0,2437,2439,5,16,0,0,2438,
  	2440,5,219,0,0,2439,2438,1,0,0,0,2439,2440,1,0,0,0,2440,2443,1,0,0,0,
  	2441,2442,5,114,0,0,2442,2444,5,219,0,0,2443,2441,1,0,0,0,2443,2444,1,
  	0,0,0,2444,2445,1,0,0,0,2445,2450,3,278,139,0,2446,2448,5,219,0,0,2447,
  	2446,1,0,0,0,2447,2448,1,0,0,0,2448,2449,1,0,0,0,2449,2451,3,270,135,
  	0,2450,2447,1,0,0,0,2450,2451,1,0,0,0,2451,261,1,0,0,0,2452,2473,5,20,
  	0,0,2453,2473,5,23,0,0,2454,2473,5,30,0,0,2455,2473,5,33,0,0,2456,2473,
  	5,50,0,0,2457,2473,5,88,0,0,2458,2473,5,92,0,0,2459,2473,5,159,0,0,2460,
  	2469,5,164,0,0,2461,2463,5,219,0,0,2462,2461,1,0,0,0,2462,2463,1,0,0,
  	0,2463,2464,1,0,0,0,2464,2466,5,197,0,0,2465,2467,5,219,0,0,2466,2465,
  	1,0,0,0,2466,2467,1,0,0,0,2467,2468,1,0,0,0,2468,2470,3,200,100,0,2469,
  	2462,1,0,0,0,2469,2470,1,0,0,0,2470,2473,1,0,0,0,2471,2473,5,177,0,0,
  	2472,2452,1,0,0,0,2472,2453,1,0,0,0,2472,2454,1,0,0,0,2472,2455,1,0,0,
  	0,2472,2456,1,0,0,0,2472,2457,1,0,0,0,2472,2458,1,0,0,0,2472,2459,1,0,
  	0,0,2472,2460,1,0,0,0,2472,2471,1,0,0,0,2473,263,1,0,0,0,2474,2479,5,
  	220,0,0,2475,2478,3,284,142,0,2476,2478,5,220,0,0,2477,2475,1,0,0,0,2477,
  	2476,1,0,0,0,2478,2481,1,0,0,0,2479,2477,1,0,0,0,2479,2480,1,0,0,0,2480,
  	2490,1,0,0,0,2481,2479,1,0,0,0,2482,2485,3,284,142,0,2483,2486,3,284,
  	142,0,2484,2486,5,220,0,0,2485,2483,1,0,0,0,2485,2484,1,0,0,0,2486,2487,
  	1,0,0,0,2487,2485,1,0,0,0,2487,2488,1,0,0,0,2488,2490,1,0,0,0,2489,2474,
  	1,0,0,0,2489,2482,1,0,0,0,2490,265,1,0,0,0,2491,2492,7,13,0,0,2492,267,
  	1,0,0,0,2493,2498,3,258,129,0,2494,2495,7,14,0,0,2495,2497,3,258,129,
  	0,2496,2494,1,0,0,0,2497,2500,1,0,0,0,2498,2496,1,0,0,0,2498,2499,1,0,
  	0,0,2499,269,1,0,0,0,2500,2498,1,0,0,0,2501,2503,5,197,0,0,2502,2504,
  	5,219,0,0,2503,2502,1,0,0,0,2503,2504,1,0,0,0,2504,2507,1,0,0,0,2505,
  	2508,5,209,0,0,2506,2508,3,258,129,0,2507,2505,1,0,0,0,2507,2506,1,0,
  	0,0,2508,271,1,0,0,0,2509,2518,3,264,132,0,2510,2512,5,219,0,0,2511,2510,
  	1,0,0,0,2511,2512,1,0,0,0,2512,2513,1,0,0,0,2513,2515,5,195,0,0,2514,
  	2516,5,219,0,0,2515,2514,1,0,0,0,2515,2516,1,0,0,0,2516,2517,1,0,0,0,
  	2517,2519,3,264,132,0,2518,2511,1,0,0,0,2518,2519,1,0,0,0,2519,273,1,
  	0,0,0,2520,2521,3,258,129,0,2521,2522,5,217,0,0,2522,275,1,0,0,0,2523,
  	2524,7,17,0,0,2524,277,1,0,0,0,2525,2528,3,262,131,0,2526,2528,3,268,
  	134,0,2527,2525,1,0,0,0,2527,2526,1,0,0,0,2528,2537,1,0,0,0,2529,2531,
  	5,219,0,0,2530,2529,1,0,0,0,2530,2531,1,0,0,0,2531,2532,1,0,0,0,2532,
  	2534,5,193,0,0,2533,2535,5,219,0,0,2534,2533,1,0,0,0,2534,2535,1,0,0,
  	0,2535,2536,1,0,0,0,2536,2538,5,202,0,0,2537,2530,1,0,0,0,2537,2538,1,
  	0,0,0,2538,279,1,0,0,0,2539,2540,7,18,0,0,2540,281,1,0,0,0,2541,2542,
  	7,19,0,0,2542,283,1,0,0,0,2543,2544,7,20,0,0,2544,285,1,0,0,0,2545,2546,
  	5,214,0,0,2546,287,1,0,0,0,2547,2548,5,215,0,0,2548,289,1,0,0,0,2549,
  	2551,5,219,0,0,2550,2549,1,0,0,0,2550,2551,1,0,0,0,2551,2555,1,0,0,0,
  	2552,2556,5,213,0,0,2553,2556,3,288,144,0,2554,2556,3,286,143,0,2555,
  	2552,1,0,0,0,2555,2553,1,0,0,0,2555,2554,1,0,0,0,2556,2558,1,0,0,0,2557,
  	2559,5,219,0,0,2558,2557,1,0,0,0,2558,2559,1,0,0,0,2559,291,1,0,0,0,2560,
  	2569,3,290,145,0,2561,2563,5,219,0,0,2562,2561,1,0,0,0,2562,2563,1,0,
  	0,0,2563,2564,1,0,0,0,2564,2566,5,217,0,0,2565,2567,5,219,0,0,2566,2565,
  	1,0,0,0,2566,2567,1,0,0,0,2567,2569,1,0,0,0,2568,2560,1,0,0,0,2568,2562,
  	1,0,0,0,2569,2572,1,0,0,0,2570,2568,1,0,0,0,2570,2571,1,0,0,0,2571,293,
  	1,0,0,0,2572,2570,1,0,0,0,435,298,303,310,313,316,321,325,330,334,339,
  	343,348,352,364,370,376,380,386,393,397,403,409,415,426,438,442,448,454,
  	460,469,475,479,483,487,492,501,574,580,584,587,603,607,612,615,620,626,
  	630,635,640,644,647,651,657,661,668,674,678,681,686,696,699,702,706,712,
  	716,721,728,732,736,740,743,748,759,772,779,788,795,799,802,811,816,826,
  	832,842,846,856,864,869,875,879,882,886,897,901,906,911,915,919,923,926,
  	929,932,935,939,947,951,954,957,961,984,990,994,998,1007,1018,1023,1033,
  	1037,1042,1050,1054,1058,1066,1070,1082,1086,1093,1095,1101,1105,1111,
  	1115,1119,1127,1131,1137,1146,1148,1153,1162,1164,1172,1174,1179,1183,
  	1187,1211,1221,1225,1230,1241,1245,1250,1264,1268,1277,1281,1284,1288,
  	1292,1295,1299,1303,1306,1310,1313,1317,1319,1324,1328,1332,1336,1338,
  	1344,1348,1351,1356,1360,1366,1369,1372,1376,1380,1387,1391,1397,1400,
  	1404,1411,1415,1421,1424,1428,1436,1440,1443,1446,1450,1458,1462,1466,
  	1468,1471,1476,1482,1486,1490,1495,1500,1504,1508,1513,1521,1523,1535,
  	1539,1547,1551,1559,1563,1567,1571,1575,1579,1587,1591,1604,1611,1615,
  	1626,1633,1638,1642,1647,1650,1656,1660,1663,1669,1673,1681,1685,1694,
  	1698,1702,1706,1709,1713,1719,1723,1730,1739,1746,1750,1753,1756,1759,
  	1763,1774,1784,1788,1795,1797,1804,1808,1812,1817,1824,1831,1836,1840,
  	1846,1851,1856,1859,1863,1867,1872,1876,1881,1885,1890,1894,1899,1903,
  	1908,1912,1917,1921,1926,1930,1935,1939,1944,1948,1953,1957,1960,1962,
  	1968,1973,1979,1983,1988,1993,1997,2001,2003,2007,2009,2012,2016,2023,
  	2031,2035,2045,2049,2057,2061,2064,2067,2073,2079,2082,2086,2090,2094,
  	2097,2105,2111,2116,2119,2123,2127,2131,2134,2142,2147,2150,2155,2159,
  	2162,2165,2173,2179,2182,2190,2197,2201,2204,2207,2215,2220,2223,2226,
  	2230,2234,2236,2240,2243,2251,2256,2261,2264,2267,2275,2279,2283,2287,
  	2292,2295,2299,2303,2308,2312,2315,2319,2323,2327,2330,2337,2341,2345,
  	2349,2354,2357,2360,2366,2370,2374,2378,2381,2385,2388,2391,2394,2397,
  	2400,2404,2410,2414,2419,2427,2433,2435,2439,2443,2447,2450,2462,2466,
  	2469,2472,2477,2479,2485,2487,2489,2498,2503,2507,2511,2515,2518,2527,
  	2530,2534,2537,2550,2555,2558,2562,2566,2568,2570
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  vbaParserStaticData = staticData.release();
}

}

vbaParser::vbaParser(TokenStream *input) : vbaParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

vbaParser::vbaParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  vbaParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *vbaParserStaticData->atn, vbaParserStaticData->decisionToDFA, vbaParserStaticData->sharedContextCache, options);
}

vbaParser::~vbaParser() {
  delete _interpreter;
}

const atn::ATN& vbaParser::getATN() const {
  return *vbaParserStaticData->atn;
}

std::string vbaParser::getGrammarFileName() const {
  return "vba.g4";
}

const std::vector<std::string>& vbaParser::getRuleNames() const {
  return vbaParserStaticData->ruleNames;
}

const dfa::Vocabulary& vbaParser::getVocabulary() const {
  return vbaParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView vbaParser::getSerializedATN() const {
  return vbaParserStaticData->serializedATN;
}


//----------------- StartRuleContext ------------------------------------------------------------------

vbaParser::StartRuleContext::StartRuleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::ModuleContext* vbaParser::StartRuleContext::module() {
  return getRuleContext<vbaParser::ModuleContext>(0);
}

tree::TerminalNode* vbaParser::StartRuleContext::EOF() {
  return getToken(vbaParser::EOF, 0);
}


size_t vbaParser::StartRuleContext::getRuleIndex() const {
  return vbaParser::RuleStartRule;
}

void vbaParser::StartRuleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStartRule(this);
}

void vbaParser::StartRuleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStartRule(this);
}

vbaParser::StartRuleContext* vbaParser::startRule() {
  StartRuleContext *_localctx = _tracker.createInstance<StartRuleContext>(_ctx, getState());
  enterRule(_localctx, 0, vbaParser::RuleStartRule);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(294);
    module();
    setState(295);
    match(vbaParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleContext ------------------------------------------------------------------

vbaParser::ModuleContext::ModuleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> vbaParser::ModuleContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::ModuleContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

std::vector<vbaParser::EndOfLineContext *> vbaParser::ModuleContext::endOfLine() {
  return getRuleContexts<vbaParser::EndOfLineContext>();
}

vbaParser::EndOfLineContext* vbaParser::ModuleContext::endOfLine(size_t i) {
  return getRuleContext<vbaParser::EndOfLineContext>(i);
}

vbaParser::ModuleHeaderContext* vbaParser::ModuleContext::moduleHeader() {
  return getRuleContext<vbaParser::ModuleHeaderContext>(0);
}

vbaParser::ModuleConfigContext* vbaParser::ModuleContext::moduleConfig() {
  return getRuleContext<vbaParser::ModuleConfigContext>(0);
}

vbaParser::ModuleAttributesContext* vbaParser::ModuleContext::moduleAttributes() {
  return getRuleContext<vbaParser::ModuleAttributesContext>(0);
}

vbaParser::ModuleDeclarationsContext* vbaParser::ModuleContext::moduleDeclarations() {
  return getRuleContext<vbaParser::ModuleDeclarationsContext>(0);
}

vbaParser::ModuleBodyContext* vbaParser::ModuleContext::moduleBody() {
  return getRuleContext<vbaParser::ModuleBodyContext>(0);
}


size_t vbaParser::ModuleContext::getRuleIndex() const {
  return vbaParser::RuleModule;
}

void vbaParser::ModuleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule(this);
}

void vbaParser::ModuleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule(this);
}

vbaParser::ModuleContext* vbaParser::module() {
  ModuleContext *_localctx = _tracker.createInstance<ModuleContext>(_ctx, getState());
  enterRule(_localctx, 2, vbaParser::RuleModule);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(298);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx)) {
    case 1: {
      setState(297);
      match(vbaParser::WS);
      break;
    }

    default:
      break;
    }
    setState(303);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(300);
        endOfLine(); 
      }
      setState(305);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx);
    }
    setState(313);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::VERSION) {
      setState(306);
      moduleHeader();
      setState(310);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(307);
          endOfLine(); 
        }
        setState(312);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx);
      }
    }
    setState(316);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::BEGIN) {
      setState(315);
      moduleConfig();
    }
    setState(321);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(318);
        endOfLine(); 
      }
      setState(323);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx);
    }
    setState(325);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::ATTRIBUTE) {
      setState(324);
      moduleAttributes();
    }
    setState(330);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(327);
        endOfLine(); 
      }
      setState(332);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx);
    }
    setState(334);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx)) {
    case 1: {
      setState(333);
      moduleDeclarations();
      break;
    }

    default:
      break;
    }
    setState(339);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(336);
        endOfLine(); 
      }
      setState(341);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    }
    setState(343);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 75) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 75)) & 6773413840370532373) != 0) || _la == vbaParser::STATIC

    || _la == vbaParser::SUB) {
      setState(342);
      moduleBody();
    }
    setState(348);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(345);
        endOfLine(); 
      }
      setState(350);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx);
    }
    setState(352);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(351);
      match(vbaParser::WS);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleHeaderContext ------------------------------------------------------------------

vbaParser::ModuleHeaderContext::ModuleHeaderContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::ModuleHeaderContext::VERSION() {
  return getToken(vbaParser::VERSION, 0);
}

std::vector<tree::TerminalNode *> vbaParser::ModuleHeaderContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::ModuleHeaderContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

tree::TerminalNode* vbaParser::ModuleHeaderContext::DOUBLELITERAL() {
  return getToken(vbaParser::DOUBLELITERAL, 0);
}

tree::TerminalNode* vbaParser::ModuleHeaderContext::CLASS() {
  return getToken(vbaParser::CLASS, 0);
}


size_t vbaParser::ModuleHeaderContext::getRuleIndex() const {
  return vbaParser::RuleModuleHeader;
}

void vbaParser::ModuleHeaderContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModuleHeader(this);
}

void vbaParser::ModuleHeaderContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModuleHeader(this);
}

vbaParser::ModuleHeaderContext* vbaParser::moduleHeader() {
  ModuleHeaderContext *_localctx = _tracker.createInstance<ModuleHeaderContext>(_ctx, getState());
  enterRule(_localctx, 4, vbaParser::RuleModuleHeader);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(354);
    match(vbaParser::VERSION);
    setState(355);
    match(vbaParser::WS);
    setState(356);
    match(vbaParser::DOUBLELITERAL);
    setState(357);
    match(vbaParser::WS);
    setState(358);
    match(vbaParser::CLASS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleConfigContext ------------------------------------------------------------------

vbaParser::ModuleConfigContext::ModuleConfigContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::ModuleConfigContext::BEGIN() {
  return getToken(vbaParser::BEGIN, 0);
}

tree::TerminalNode* vbaParser::ModuleConfigContext::END() {
  return getToken(vbaParser::END, 0);
}

std::vector<vbaParser::EndOfLineContext *> vbaParser::ModuleConfigContext::endOfLine() {
  return getRuleContexts<vbaParser::EndOfLineContext>();
}

vbaParser::EndOfLineContext* vbaParser::ModuleConfigContext::endOfLine(size_t i) {
  return getRuleContext<vbaParser::EndOfLineContext>(i);
}

std::vector<vbaParser::ModuleConfigElementContext *> vbaParser::ModuleConfigContext::moduleConfigElement() {
  return getRuleContexts<vbaParser::ModuleConfigElementContext>();
}

vbaParser::ModuleConfigElementContext* vbaParser::ModuleConfigContext::moduleConfigElement(size_t i) {
  return getRuleContext<vbaParser::ModuleConfigElementContext>(i);
}


size_t vbaParser::ModuleConfigContext::getRuleIndex() const {
  return vbaParser::RuleModuleConfig;
}

void vbaParser::ModuleConfigContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModuleConfig(this);
}

void vbaParser::ModuleConfigContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModuleConfig(this);
}

vbaParser::ModuleConfigContext* vbaParser::moduleConfig() {
  ModuleConfigContext *_localctx = _tracker.createInstance<ModuleConfigContext>(_ctx, getState());
  enterRule(_localctx, 6, vbaParser::RuleModuleConfig);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(360);
    match(vbaParser::BEGIN);
    setState(364);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 213) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 213)) & 71) != 0)) {
      setState(361);
      endOfLine();
      setState(366);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(368); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(367);
              moduleConfigElement();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(370); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(372);
    match(vbaParser::END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleConfigElementContext ------------------------------------------------------------------

vbaParser::ModuleConfigElementContext::ModuleConfigElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::AmbiguousIdentifierContext* vbaParser::ModuleConfigElementContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

tree::TerminalNode* vbaParser::ModuleConfigElementContext::EQ() {
  return getToken(vbaParser::EQ, 0);
}

vbaParser::LiteralContext* vbaParser::ModuleConfigElementContext::literal() {
  return getRuleContext<vbaParser::LiteralContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::ModuleConfigElementContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::ModuleConfigElementContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

std::vector<vbaParser::EndOfLineContext *> vbaParser::ModuleConfigElementContext::endOfLine() {
  return getRuleContexts<vbaParser::EndOfLineContext>();
}

vbaParser::EndOfLineContext* vbaParser::ModuleConfigElementContext::endOfLine(size_t i) {
  return getRuleContext<vbaParser::EndOfLineContext>(i);
}


size_t vbaParser::ModuleConfigElementContext::getRuleIndex() const {
  return vbaParser::RuleModuleConfigElement;
}

void vbaParser::ModuleConfigElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModuleConfigElement(this);
}

void vbaParser::ModuleConfigElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModuleConfigElement(this);
}

vbaParser::ModuleConfigElementContext* vbaParser::moduleConfigElement() {
  ModuleConfigElementContext *_localctx = _tracker.createInstance<ModuleConfigElementContext>(_ctx, getState());
  enterRule(_localctx, 8, vbaParser::RuleModuleConfigElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(374);
    ambiguousIdentifier();
    setState(376);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(375);
      match(vbaParser::WS);
    }
    setState(378);
    match(vbaParser::EQ);
    setState(380);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(379);
      match(vbaParser::WS);
    }
    setState(382);
    literal();
    setState(386);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 213) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 213)) & 71) != 0)) {
      setState(383);
      endOfLine();
      setState(388);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleAttributesContext ------------------------------------------------------------------

vbaParser::ModuleAttributesContext::ModuleAttributesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<vbaParser::AttributeStmtContext *> vbaParser::ModuleAttributesContext::attributeStmt() {
  return getRuleContexts<vbaParser::AttributeStmtContext>();
}

vbaParser::AttributeStmtContext* vbaParser::ModuleAttributesContext::attributeStmt(size_t i) {
  return getRuleContext<vbaParser::AttributeStmtContext>(i);
}

std::vector<vbaParser::EndOfLineContext *> vbaParser::ModuleAttributesContext::endOfLine() {
  return getRuleContexts<vbaParser::EndOfLineContext>();
}

vbaParser::EndOfLineContext* vbaParser::ModuleAttributesContext::endOfLine(size_t i) {
  return getRuleContext<vbaParser::EndOfLineContext>(i);
}


size_t vbaParser::ModuleAttributesContext::getRuleIndex() const {
  return vbaParser::RuleModuleAttributes;
}

void vbaParser::ModuleAttributesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModuleAttributes(this);
}

void vbaParser::ModuleAttributesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModuleAttributes(this);
}

vbaParser::ModuleAttributesContext* vbaParser::moduleAttributes() {
  ModuleAttributesContext *_localctx = _tracker.createInstance<ModuleAttributesContext>(_ctx, getState());
  enterRule(_localctx, 10, vbaParser::RuleModuleAttributes);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(395); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(389);
      attributeStmt();
      setState(391); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(390);
                endOfLine();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(393); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(397); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == vbaParser::ATTRIBUTE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleDeclarationsContext ------------------------------------------------------------------

vbaParser::ModuleDeclarationsContext::ModuleDeclarationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<vbaParser::ModuleDeclarationsElementContext *> vbaParser::ModuleDeclarationsContext::moduleDeclarationsElement() {
  return getRuleContexts<vbaParser::ModuleDeclarationsElementContext>();
}

vbaParser::ModuleDeclarationsElementContext* vbaParser::ModuleDeclarationsContext::moduleDeclarationsElement(size_t i) {
  return getRuleContext<vbaParser::ModuleDeclarationsElementContext>(i);
}

std::vector<vbaParser::EndOfLineContext *> vbaParser::ModuleDeclarationsContext::endOfLine() {
  return getRuleContexts<vbaParser::EndOfLineContext>();
}

vbaParser::EndOfLineContext* vbaParser::ModuleDeclarationsContext::endOfLine(size_t i) {
  return getRuleContext<vbaParser::EndOfLineContext>(i);
}


size_t vbaParser::ModuleDeclarationsContext::getRuleIndex() const {
  return vbaParser::RuleModuleDeclarations;
}

void vbaParser::ModuleDeclarationsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModuleDeclarations(this);
}

void vbaParser::ModuleDeclarationsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModuleDeclarations(this);
}

vbaParser::ModuleDeclarationsContext* vbaParser::moduleDeclarations() {
  ModuleDeclarationsContext *_localctx = _tracker.createInstance<ModuleDeclarationsContext>(_ctx, getState());
  enterRule(_localctx, 12, vbaParser::RuleModuleDeclarations);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(399);
    moduleDeclarationsElement();
    setState(409);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(401); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(400);
                  endOfLine();
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(403); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        setState(405);
        moduleDeclarationsElement(); 
      }
      setState(411);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx);
    }
    setState(415);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(412);
        endOfLine(); 
      }
      setState(417);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleOptionContext ------------------------------------------------------------------

vbaParser::ModuleOptionContext::ModuleOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t vbaParser::ModuleOptionContext::getRuleIndex() const {
  return vbaParser::RuleModuleOption;
}

void vbaParser::ModuleOptionContext::copyFrom(ModuleOptionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- OptionExplicitStmtContext ------------------------------------------------------------------

tree::TerminalNode* vbaParser::OptionExplicitStmtContext::OPTION_EXPLICIT() {
  return getToken(vbaParser::OPTION_EXPLICIT, 0);
}

vbaParser::OptionExplicitStmtContext::OptionExplicitStmtContext(ModuleOptionContext *ctx) { copyFrom(ctx); }

void vbaParser::OptionExplicitStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionExplicitStmt(this);
}
void vbaParser::OptionExplicitStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionExplicitStmt(this);
}
//----------------- OptionBaseStmtContext ------------------------------------------------------------------

tree::TerminalNode* vbaParser::OptionBaseStmtContext::OPTION_BASE() {
  return getToken(vbaParser::OPTION_BASE, 0);
}

tree::TerminalNode* vbaParser::OptionBaseStmtContext::WS() {
  return getToken(vbaParser::WS, 0);
}

tree::TerminalNode* vbaParser::OptionBaseStmtContext::SHORTLITERAL() {
  return getToken(vbaParser::SHORTLITERAL, 0);
}

vbaParser::OptionBaseStmtContext::OptionBaseStmtContext(ModuleOptionContext *ctx) { copyFrom(ctx); }

void vbaParser::OptionBaseStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionBaseStmt(this);
}
void vbaParser::OptionBaseStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionBaseStmt(this);
}
//----------------- OptionPrivateModuleStmtContext ------------------------------------------------------------------

tree::TerminalNode* vbaParser::OptionPrivateModuleStmtContext::OPTION_PRIVATE_MODULE() {
  return getToken(vbaParser::OPTION_PRIVATE_MODULE, 0);
}

vbaParser::OptionPrivateModuleStmtContext::OptionPrivateModuleStmtContext(ModuleOptionContext *ctx) { copyFrom(ctx); }

void vbaParser::OptionPrivateModuleStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionPrivateModuleStmt(this);
}
void vbaParser::OptionPrivateModuleStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionPrivateModuleStmt(this);
}
//----------------- OptionCompareStmtContext ------------------------------------------------------------------

tree::TerminalNode* vbaParser::OptionCompareStmtContext::OPTION_COMPARE() {
  return getToken(vbaParser::OPTION_COMPARE, 0);
}

tree::TerminalNode* vbaParser::OptionCompareStmtContext::WS() {
  return getToken(vbaParser::WS, 0);
}

tree::TerminalNode* vbaParser::OptionCompareStmtContext::BINARY() {
  return getToken(vbaParser::BINARY, 0);
}

tree::TerminalNode* vbaParser::OptionCompareStmtContext::TEXT() {
  return getToken(vbaParser::TEXT, 0);
}

tree::TerminalNode* vbaParser::OptionCompareStmtContext::DATABASE() {
  return getToken(vbaParser::DATABASE, 0);
}

vbaParser::OptionCompareStmtContext::OptionCompareStmtContext(ModuleOptionContext *ctx) { copyFrom(ctx); }

void vbaParser::OptionCompareStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionCompareStmt(this);
}
void vbaParser::OptionCompareStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionCompareStmt(this);
}
vbaParser::ModuleOptionContext* vbaParser::moduleOption() {
  ModuleOptionContext *_localctx = _tracker.createInstance<ModuleOptionContext>(_ctx, getState());
  enterRule(_localctx, 14, vbaParser::RuleModuleOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(426);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case vbaParser::OPTION_BASE: {
        _localctx = _tracker.createInstance<vbaParser::OptionBaseStmtContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(418);
        match(vbaParser::OPTION_BASE);
        setState(419);
        match(vbaParser::WS);
        setState(420);
        match(vbaParser::SHORTLITERAL);
        break;
      }

      case vbaParser::OPTION_COMPARE: {
        _localctx = _tracker.createInstance<vbaParser::OptionCompareStmtContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(421);
        match(vbaParser::OPTION_COMPARE);
        setState(422);
        match(vbaParser::WS);
        setState(423);
        _la = _input->LA(1);
        if (!(_la == vbaParser::BINARY

        || _la == vbaParser::DATABASE || _la == vbaParser::TEXT)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case vbaParser::OPTION_EXPLICIT: {
        _localctx = _tracker.createInstance<vbaParser::OptionExplicitStmtContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(424);
        match(vbaParser::OPTION_EXPLICIT);
        break;
      }

      case vbaParser::OPTION_PRIVATE_MODULE: {
        _localctx = _tracker.createInstance<vbaParser::OptionPrivateModuleStmtContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(425);
        match(vbaParser::OPTION_PRIVATE_MODULE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleDeclarationsElementContext ------------------------------------------------------------------

vbaParser::ModuleDeclarationsElementContext::ModuleDeclarationsElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::CommentContext* vbaParser::ModuleDeclarationsElementContext::comment() {
  return getRuleContext<vbaParser::CommentContext>(0);
}

vbaParser::DeclareStmtContext* vbaParser::ModuleDeclarationsElementContext::declareStmt() {
  return getRuleContext<vbaParser::DeclareStmtContext>(0);
}

vbaParser::EnumerationStmtContext* vbaParser::ModuleDeclarationsElementContext::enumerationStmt() {
  return getRuleContext<vbaParser::EnumerationStmtContext>(0);
}

vbaParser::EventStmtContext* vbaParser::ModuleDeclarationsElementContext::eventStmt() {
  return getRuleContext<vbaParser::EventStmtContext>(0);
}

vbaParser::ConstStmtContext* vbaParser::ModuleDeclarationsElementContext::constStmt() {
  return getRuleContext<vbaParser::ConstStmtContext>(0);
}

vbaParser::ImplementsStmtContext* vbaParser::ModuleDeclarationsElementContext::implementsStmt() {
  return getRuleContext<vbaParser::ImplementsStmtContext>(0);
}

vbaParser::VariableStmtContext* vbaParser::ModuleDeclarationsElementContext::variableStmt() {
  return getRuleContext<vbaParser::VariableStmtContext>(0);
}

vbaParser::ModuleOptionContext* vbaParser::ModuleDeclarationsElementContext::moduleOption() {
  return getRuleContext<vbaParser::ModuleOptionContext>(0);
}

vbaParser::TypeStmtContext* vbaParser::ModuleDeclarationsElementContext::typeStmt() {
  return getRuleContext<vbaParser::TypeStmtContext>(0);
}

vbaParser::MacroStmtContext* vbaParser::ModuleDeclarationsElementContext::macroStmt() {
  return getRuleContext<vbaParser::MacroStmtContext>(0);
}


size_t vbaParser::ModuleDeclarationsElementContext::getRuleIndex() const {
  return vbaParser::RuleModuleDeclarationsElement;
}

void vbaParser::ModuleDeclarationsElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModuleDeclarationsElement(this);
}

void vbaParser::ModuleDeclarationsElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModuleDeclarationsElement(this);
}

vbaParser::ModuleDeclarationsElementContext* vbaParser::moduleDeclarationsElement() {
  ModuleDeclarationsElementContext *_localctx = _tracker.createInstance<ModuleDeclarationsElementContext>(_ctx, getState());
  enterRule(_localctx, 16, vbaParser::RuleModuleDeclarationsElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(438);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(428);
      comment();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(429);
      declareStmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(430);
      enumerationStmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(431);
      eventStmt();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(432);
      constStmt();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(433);
      implementsStmt();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(434);
      variableStmt();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(435);
      moduleOption();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(436);
      typeStmt();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(437);
      macroStmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MacroStmtContext ------------------------------------------------------------------

vbaParser::MacroStmtContext::MacroStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::MacroConstStmtContext* vbaParser::MacroStmtContext::macroConstStmt() {
  return getRuleContext<vbaParser::MacroConstStmtContext>(0);
}

vbaParser::MacroIfThenElseStmtContext* vbaParser::MacroStmtContext::macroIfThenElseStmt() {
  return getRuleContext<vbaParser::MacroIfThenElseStmtContext>(0);
}


size_t vbaParser::MacroStmtContext::getRuleIndex() const {
  return vbaParser::RuleMacroStmt;
}

void vbaParser::MacroStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMacroStmt(this);
}

void vbaParser::MacroStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMacroStmt(this);
}

vbaParser::MacroStmtContext* vbaParser::macroStmt() {
  MacroStmtContext *_localctx = _tracker.createInstance<MacroStmtContext>(_ctx, getState());
  enterRule(_localctx, 18, vbaParser::RuleMacroStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(442);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case vbaParser::MACRO_CONST: {
        enterOuterAlt(_localctx, 1);
        setState(440);
        macroConstStmt();
        break;
      }

      case vbaParser::MACRO_IF: {
        enterOuterAlt(_localctx, 2);
        setState(441);
        macroIfThenElseStmt();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleBodyContext ------------------------------------------------------------------

vbaParser::ModuleBodyContext::ModuleBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<vbaParser::ModuleBodyElementContext *> vbaParser::ModuleBodyContext::moduleBodyElement() {
  return getRuleContexts<vbaParser::ModuleBodyElementContext>();
}

vbaParser::ModuleBodyElementContext* vbaParser::ModuleBodyContext::moduleBodyElement(size_t i) {
  return getRuleContext<vbaParser::ModuleBodyElementContext>(i);
}

std::vector<vbaParser::EndOfLineContext *> vbaParser::ModuleBodyContext::endOfLine() {
  return getRuleContexts<vbaParser::EndOfLineContext>();
}

vbaParser::EndOfLineContext* vbaParser::ModuleBodyContext::endOfLine(size_t i) {
  return getRuleContext<vbaParser::EndOfLineContext>(i);
}


size_t vbaParser::ModuleBodyContext::getRuleIndex() const {
  return vbaParser::RuleModuleBody;
}

void vbaParser::ModuleBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModuleBody(this);
}

void vbaParser::ModuleBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModuleBody(this);
}

vbaParser::ModuleBodyContext* vbaParser::moduleBody() {
  ModuleBodyContext *_localctx = _tracker.createInstance<ModuleBodyContext>(_ctx, getState());
  enterRule(_localctx, 20, vbaParser::RuleModuleBody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(444);
    moduleBodyElement();
    setState(454);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(446); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(445);
          endOfLine();
          setState(448); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (((((_la - 213) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 213)) & 71) != 0));
        setState(450);
        moduleBodyElement(); 
      }
      setState(456);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx);
    }
    setState(460);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(457);
        endOfLine(); 
      }
      setState(462);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleBodyElementContext ------------------------------------------------------------------

vbaParser::ModuleBodyElementContext::ModuleBodyElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::FunctionStmtContext* vbaParser::ModuleBodyElementContext::functionStmt() {
  return getRuleContext<vbaParser::FunctionStmtContext>(0);
}

vbaParser::PropertyGetStmtContext* vbaParser::ModuleBodyElementContext::propertyGetStmt() {
  return getRuleContext<vbaParser::PropertyGetStmtContext>(0);
}

vbaParser::PropertySetStmtContext* vbaParser::ModuleBodyElementContext::propertySetStmt() {
  return getRuleContext<vbaParser::PropertySetStmtContext>(0);
}

vbaParser::PropertyLetStmtContext* vbaParser::ModuleBodyElementContext::propertyLetStmt() {
  return getRuleContext<vbaParser::PropertyLetStmtContext>(0);
}

vbaParser::SubStmtContext* vbaParser::ModuleBodyElementContext::subStmt() {
  return getRuleContext<vbaParser::SubStmtContext>(0);
}

vbaParser::MacroStmtContext* vbaParser::ModuleBodyElementContext::macroStmt() {
  return getRuleContext<vbaParser::MacroStmtContext>(0);
}


size_t vbaParser::ModuleBodyElementContext::getRuleIndex() const {
  return vbaParser::RuleModuleBodyElement;
}

void vbaParser::ModuleBodyElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModuleBodyElement(this);
}

void vbaParser::ModuleBodyElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModuleBodyElement(this);
}

vbaParser::ModuleBodyElementContext* vbaParser::moduleBodyElement() {
  ModuleBodyElementContext *_localctx = _tracker.createInstance<ModuleBodyElementContext>(_ctx, getState());
  enterRule(_localctx, 22, vbaParser::RuleModuleBodyElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(469);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(463);
      functionStmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(464);
      propertyGetStmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(465);
      propertySetStmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(466);
      propertyLetStmt();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(467);
      subStmt();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(468);
      macroStmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeStmtContext ------------------------------------------------------------------

vbaParser::AttributeStmtContext::AttributeStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::AttributeStmtContext::ATTRIBUTE() {
  return getToken(vbaParser::ATTRIBUTE, 0);
}

std::vector<tree::TerminalNode *> vbaParser::AttributeStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::AttributeStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::ImplicitCallStmt_InStmtContext* vbaParser::AttributeStmtContext::implicitCallStmt_InStmt() {
  return getRuleContext<vbaParser::ImplicitCallStmt_InStmtContext>(0);
}

tree::TerminalNode* vbaParser::AttributeStmtContext::EQ() {
  return getToken(vbaParser::EQ, 0);
}

std::vector<vbaParser::LiteralContext *> vbaParser::AttributeStmtContext::literal() {
  return getRuleContexts<vbaParser::LiteralContext>();
}

vbaParser::LiteralContext* vbaParser::AttributeStmtContext::literal(size_t i) {
  return getRuleContext<vbaParser::LiteralContext>(i);
}


size_t vbaParser::AttributeStmtContext::getRuleIndex() const {
  return vbaParser::RuleAttributeStmt;
}

void vbaParser::AttributeStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeStmt(this);
}

void vbaParser::AttributeStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeStmt(this);
}

vbaParser::AttributeStmtContext* vbaParser::attributeStmt() {
  AttributeStmtContext *_localctx = _tracker.createInstance<AttributeStmtContext>(_ctx, getState());
  enterRule(_localctx, 24, vbaParser::RuleAttributeStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(471);
    match(vbaParser::ATTRIBUTE);
    setState(472);
    match(vbaParser::WS);
    setState(473);
    implicitCallStmt_InStmt();
    setState(475);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(474);
      match(vbaParser::WS);
    }
    setState(477);
    match(vbaParser::EQ);
    setState(479);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(478);
      match(vbaParser::WS);
    }
    setState(481);
    literal();
    setState(492);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(483);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(482);
          match(vbaParser::WS);
        }
        setState(485);
        match(vbaParser::T__0);
        setState(487);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(486);
          match(vbaParser::WS);
        }
        setState(489);
        literal(); 
      }
      setState(494);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContext ------------------------------------------------------------------

vbaParser::BlockContext::BlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<vbaParser::BlockStmtContext *> vbaParser::BlockContext::blockStmt() {
  return getRuleContexts<vbaParser::BlockStmtContext>();
}

vbaParser::BlockStmtContext* vbaParser::BlockContext::blockStmt(size_t i) {
  return getRuleContext<vbaParser::BlockStmtContext>(i);
}

std::vector<vbaParser::EndOfStatementContext *> vbaParser::BlockContext::endOfStatement() {
  return getRuleContexts<vbaParser::EndOfStatementContext>();
}

vbaParser::EndOfStatementContext* vbaParser::BlockContext::endOfStatement(size_t i) {
  return getRuleContext<vbaParser::EndOfStatementContext>(i);
}


size_t vbaParser::BlockContext::getRuleIndex() const {
  return vbaParser::RuleBlock;
}

void vbaParser::BlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock(this);
}

void vbaParser::BlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock(this);
}

vbaParser::BlockContext* vbaParser::block() {
  BlockContext *_localctx = _tracker.createInstance<BlockContext>(_ctx, getState());
  enterRule(_localctx, 26, vbaParser::RuleBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(495);
    blockStmt();
    setState(501);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(496);
        endOfStatement();
        setState(497);
        blockStmt(); 
      }
      setState(503);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx);
    }
    setState(504);
    endOfStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockStmtContext ------------------------------------------------------------------

vbaParser::BlockStmtContext::BlockStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::LineLabelContext* vbaParser::BlockStmtContext::lineLabel() {
  return getRuleContext<vbaParser::LineLabelContext>(0);
}

vbaParser::AppactivateStmtContext* vbaParser::BlockStmtContext::appactivateStmt() {
  return getRuleContext<vbaParser::AppactivateStmtContext>(0);
}

vbaParser::AttributeStmtContext* vbaParser::BlockStmtContext::attributeStmt() {
  return getRuleContext<vbaParser::AttributeStmtContext>(0);
}

vbaParser::BeepStmtContext* vbaParser::BlockStmtContext::beepStmt() {
  return getRuleContext<vbaParser::BeepStmtContext>(0);
}

vbaParser::ChdirStmtContext* vbaParser::BlockStmtContext::chdirStmt() {
  return getRuleContext<vbaParser::ChdirStmtContext>(0);
}

vbaParser::ChdriveStmtContext* vbaParser::BlockStmtContext::chdriveStmt() {
  return getRuleContext<vbaParser::ChdriveStmtContext>(0);
}

vbaParser::CloseStmtContext* vbaParser::BlockStmtContext::closeStmt() {
  return getRuleContext<vbaParser::CloseStmtContext>(0);
}

vbaParser::ConstStmtContext* vbaParser::BlockStmtContext::constStmt() {
  return getRuleContext<vbaParser::ConstStmtContext>(0);
}

vbaParser::DateStmtContext* vbaParser::BlockStmtContext::dateStmt() {
  return getRuleContext<vbaParser::DateStmtContext>(0);
}

vbaParser::DeleteSettingStmtContext* vbaParser::BlockStmtContext::deleteSettingStmt() {
  return getRuleContext<vbaParser::DeleteSettingStmtContext>(0);
}

vbaParser::DeftypeStmtContext* vbaParser::BlockStmtContext::deftypeStmt() {
  return getRuleContext<vbaParser::DeftypeStmtContext>(0);
}

vbaParser::DoLoopStmtContext* vbaParser::BlockStmtContext::doLoopStmt() {
  return getRuleContext<vbaParser::DoLoopStmtContext>(0);
}

vbaParser::EndStmtContext* vbaParser::BlockStmtContext::endStmt() {
  return getRuleContext<vbaParser::EndStmtContext>(0);
}

vbaParser::EraseStmtContext* vbaParser::BlockStmtContext::eraseStmt() {
  return getRuleContext<vbaParser::EraseStmtContext>(0);
}

vbaParser::ErrorStmtContext* vbaParser::BlockStmtContext::errorStmt() {
  return getRuleContext<vbaParser::ErrorStmtContext>(0);
}

vbaParser::ExitStmtContext* vbaParser::BlockStmtContext::exitStmt() {
  return getRuleContext<vbaParser::ExitStmtContext>(0);
}

vbaParser::ExplicitCallStmtContext* vbaParser::BlockStmtContext::explicitCallStmt() {
  return getRuleContext<vbaParser::ExplicitCallStmtContext>(0);
}

vbaParser::FilecopyStmtContext* vbaParser::BlockStmtContext::filecopyStmt() {
  return getRuleContext<vbaParser::FilecopyStmtContext>(0);
}

vbaParser::ForEachStmtContext* vbaParser::BlockStmtContext::forEachStmt() {
  return getRuleContext<vbaParser::ForEachStmtContext>(0);
}

vbaParser::ForNextStmtContext* vbaParser::BlockStmtContext::forNextStmt() {
  return getRuleContext<vbaParser::ForNextStmtContext>(0);
}

vbaParser::GetStmtContext* vbaParser::BlockStmtContext::getStmt() {
  return getRuleContext<vbaParser::GetStmtContext>(0);
}

vbaParser::GoSubStmtContext* vbaParser::BlockStmtContext::goSubStmt() {
  return getRuleContext<vbaParser::GoSubStmtContext>(0);
}

vbaParser::GoToStmtContext* vbaParser::BlockStmtContext::goToStmt() {
  return getRuleContext<vbaParser::GoToStmtContext>(0);
}

vbaParser::IfThenElseStmtContext* vbaParser::BlockStmtContext::ifThenElseStmt() {
  return getRuleContext<vbaParser::IfThenElseStmtContext>(0);
}

vbaParser::ImplementsStmtContext* vbaParser::BlockStmtContext::implementsStmt() {
  return getRuleContext<vbaParser::ImplementsStmtContext>(0);
}

vbaParser::InputStmtContext* vbaParser::BlockStmtContext::inputStmt() {
  return getRuleContext<vbaParser::InputStmtContext>(0);
}

vbaParser::KillStmtContext* vbaParser::BlockStmtContext::killStmt() {
  return getRuleContext<vbaParser::KillStmtContext>(0);
}

vbaParser::LetStmtContext* vbaParser::BlockStmtContext::letStmt() {
  return getRuleContext<vbaParser::LetStmtContext>(0);
}

vbaParser::LineInputStmtContext* vbaParser::BlockStmtContext::lineInputStmt() {
  return getRuleContext<vbaParser::LineInputStmtContext>(0);
}

vbaParser::LoadStmtContext* vbaParser::BlockStmtContext::loadStmt() {
  return getRuleContext<vbaParser::LoadStmtContext>(0);
}

vbaParser::LockStmtContext* vbaParser::BlockStmtContext::lockStmt() {
  return getRuleContext<vbaParser::LockStmtContext>(0);
}

vbaParser::LsetStmtContext* vbaParser::BlockStmtContext::lsetStmt() {
  return getRuleContext<vbaParser::LsetStmtContext>(0);
}

vbaParser::MacroStmtContext* vbaParser::BlockStmtContext::macroStmt() {
  return getRuleContext<vbaParser::MacroStmtContext>(0);
}

vbaParser::MidStmtContext* vbaParser::BlockStmtContext::midStmt() {
  return getRuleContext<vbaParser::MidStmtContext>(0);
}

vbaParser::MkdirStmtContext* vbaParser::BlockStmtContext::mkdirStmt() {
  return getRuleContext<vbaParser::MkdirStmtContext>(0);
}

vbaParser::NameStmtContext* vbaParser::BlockStmtContext::nameStmt() {
  return getRuleContext<vbaParser::NameStmtContext>(0);
}

vbaParser::OnErrorStmtContext* vbaParser::BlockStmtContext::onErrorStmt() {
  return getRuleContext<vbaParser::OnErrorStmtContext>(0);
}

vbaParser::OnGoToStmtContext* vbaParser::BlockStmtContext::onGoToStmt() {
  return getRuleContext<vbaParser::OnGoToStmtContext>(0);
}

vbaParser::OnGoSubStmtContext* vbaParser::BlockStmtContext::onGoSubStmt() {
  return getRuleContext<vbaParser::OnGoSubStmtContext>(0);
}

vbaParser::OpenStmtContext* vbaParser::BlockStmtContext::openStmt() {
  return getRuleContext<vbaParser::OpenStmtContext>(0);
}

vbaParser::PrintStmtContext* vbaParser::BlockStmtContext::printStmt() {
  return getRuleContext<vbaParser::PrintStmtContext>(0);
}

vbaParser::PutStmtContext* vbaParser::BlockStmtContext::putStmt() {
  return getRuleContext<vbaParser::PutStmtContext>(0);
}

vbaParser::RaiseEventStmtContext* vbaParser::BlockStmtContext::raiseEventStmt() {
  return getRuleContext<vbaParser::RaiseEventStmtContext>(0);
}

vbaParser::RandomizeStmtContext* vbaParser::BlockStmtContext::randomizeStmt() {
  return getRuleContext<vbaParser::RandomizeStmtContext>(0);
}

vbaParser::RedimStmtContext* vbaParser::BlockStmtContext::redimStmt() {
  return getRuleContext<vbaParser::RedimStmtContext>(0);
}

vbaParser::ResetStmtContext* vbaParser::BlockStmtContext::resetStmt() {
  return getRuleContext<vbaParser::ResetStmtContext>(0);
}

vbaParser::ResumeStmtContext* vbaParser::BlockStmtContext::resumeStmt() {
  return getRuleContext<vbaParser::ResumeStmtContext>(0);
}

vbaParser::ReturnStmtContext* vbaParser::BlockStmtContext::returnStmt() {
  return getRuleContext<vbaParser::ReturnStmtContext>(0);
}

vbaParser::RmdirStmtContext* vbaParser::BlockStmtContext::rmdirStmt() {
  return getRuleContext<vbaParser::RmdirStmtContext>(0);
}

vbaParser::RsetStmtContext* vbaParser::BlockStmtContext::rsetStmt() {
  return getRuleContext<vbaParser::RsetStmtContext>(0);
}

vbaParser::SavepictureStmtContext* vbaParser::BlockStmtContext::savepictureStmt() {
  return getRuleContext<vbaParser::SavepictureStmtContext>(0);
}

vbaParser::SaveSettingStmtContext* vbaParser::BlockStmtContext::saveSettingStmt() {
  return getRuleContext<vbaParser::SaveSettingStmtContext>(0);
}

vbaParser::SeekStmtContext* vbaParser::BlockStmtContext::seekStmt() {
  return getRuleContext<vbaParser::SeekStmtContext>(0);
}

vbaParser::SelectCaseStmtContext* vbaParser::BlockStmtContext::selectCaseStmt() {
  return getRuleContext<vbaParser::SelectCaseStmtContext>(0);
}

vbaParser::SendkeysStmtContext* vbaParser::BlockStmtContext::sendkeysStmt() {
  return getRuleContext<vbaParser::SendkeysStmtContext>(0);
}

vbaParser::SetattrStmtContext* vbaParser::BlockStmtContext::setattrStmt() {
  return getRuleContext<vbaParser::SetattrStmtContext>(0);
}

vbaParser::SetStmtContext* vbaParser::BlockStmtContext::setStmt() {
  return getRuleContext<vbaParser::SetStmtContext>(0);
}

vbaParser::StopStmtContext* vbaParser::BlockStmtContext::stopStmt() {
  return getRuleContext<vbaParser::StopStmtContext>(0);
}

vbaParser::TimeStmtContext* vbaParser::BlockStmtContext::timeStmt() {
  return getRuleContext<vbaParser::TimeStmtContext>(0);
}

vbaParser::UnloadStmtContext* vbaParser::BlockStmtContext::unloadStmt() {
  return getRuleContext<vbaParser::UnloadStmtContext>(0);
}

vbaParser::UnlockStmtContext* vbaParser::BlockStmtContext::unlockStmt() {
  return getRuleContext<vbaParser::UnlockStmtContext>(0);
}

vbaParser::VariableStmtContext* vbaParser::BlockStmtContext::variableStmt() {
  return getRuleContext<vbaParser::VariableStmtContext>(0);
}

vbaParser::WhileWendStmtContext* vbaParser::BlockStmtContext::whileWendStmt() {
  return getRuleContext<vbaParser::WhileWendStmtContext>(0);
}

vbaParser::WidthStmtContext* vbaParser::BlockStmtContext::widthStmt() {
  return getRuleContext<vbaParser::WidthStmtContext>(0);
}

vbaParser::WithStmtContext* vbaParser::BlockStmtContext::withStmt() {
  return getRuleContext<vbaParser::WithStmtContext>(0);
}

vbaParser::WriteStmtContext* vbaParser::BlockStmtContext::writeStmt() {
  return getRuleContext<vbaParser::WriteStmtContext>(0);
}

vbaParser::ImplicitCallStmt_InBlockContext* vbaParser::BlockStmtContext::implicitCallStmt_InBlock() {
  return getRuleContext<vbaParser::ImplicitCallStmt_InBlockContext>(0);
}

vbaParser::ImplicitCallStmt_InStmtContext* vbaParser::BlockStmtContext::implicitCallStmt_InStmt() {
  return getRuleContext<vbaParser::ImplicitCallStmt_InStmtContext>(0);
}


size_t vbaParser::BlockStmtContext::getRuleIndex() const {
  return vbaParser::RuleBlockStmt;
}

void vbaParser::BlockStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlockStmt(this);
}

void vbaParser::BlockStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlockStmt(this);
}

vbaParser::BlockStmtContext* vbaParser::blockStmt() {
  BlockStmtContext *_localctx = _tracker.createInstance<BlockStmtContext>(_ctx, getState());
  enterRule(_localctx, 28, vbaParser::RuleBlockStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(574);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(506);
      lineLabel();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(507);
      appactivateStmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(508);
      attributeStmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(509);
      beepStmt();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(510);
      chdirStmt();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(511);
      chdriveStmt();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(512);
      closeStmt();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(513);
      constStmt();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(514);
      dateStmt();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(515);
      deleteSettingStmt();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(516);
      deftypeStmt();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(517);
      doLoopStmt();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(518);
      endStmt();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(519);
      eraseStmt();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(520);
      errorStmt();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(521);
      exitStmt();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(522);
      explicitCallStmt();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(523);
      filecopyStmt();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(524);
      forEachStmt();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(525);
      forNextStmt();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(526);
      getStmt();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(527);
      goSubStmt();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(528);
      goToStmt();
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(529);
      ifThenElseStmt();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(530);
      implementsStmt();
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(531);
      inputStmt();
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(532);
      killStmt();
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(533);
      letStmt();
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(534);
      lineInputStmt();
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(535);
      loadStmt();
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(536);
      lockStmt();
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(537);
      lsetStmt();
      break;
    }

    case 33: {
      enterOuterAlt(_localctx, 33);
      setState(538);
      macroStmt();
      break;
    }

    case 34: {
      enterOuterAlt(_localctx, 34);
      setState(539);
      midStmt();
      break;
    }

    case 35: {
      enterOuterAlt(_localctx, 35);
      setState(540);
      mkdirStmt();
      break;
    }

    case 36: {
      enterOuterAlt(_localctx, 36);
      setState(541);
      nameStmt();
      break;
    }

    case 37: {
      enterOuterAlt(_localctx, 37);
      setState(542);
      onErrorStmt();
      break;
    }

    case 38: {
      enterOuterAlt(_localctx, 38);
      setState(543);
      onGoToStmt();
      break;
    }

    case 39: {
      enterOuterAlt(_localctx, 39);
      setState(544);
      onGoSubStmt();
      break;
    }

    case 40: {
      enterOuterAlt(_localctx, 40);
      setState(545);
      openStmt();
      break;
    }

    case 41: {
      enterOuterAlt(_localctx, 41);
      setState(546);
      printStmt();
      break;
    }

    case 42: {
      enterOuterAlt(_localctx, 42);
      setState(547);
      putStmt();
      break;
    }

    case 43: {
      enterOuterAlt(_localctx, 43);
      setState(548);
      raiseEventStmt();
      break;
    }

    case 44: {
      enterOuterAlt(_localctx, 44);
      setState(549);
      randomizeStmt();
      break;
    }

    case 45: {
      enterOuterAlt(_localctx, 45);
      setState(550);
      redimStmt();
      break;
    }

    case 46: {
      enterOuterAlt(_localctx, 46);
      setState(551);
      resetStmt();
      break;
    }

    case 47: {
      enterOuterAlt(_localctx, 47);
      setState(552);
      resumeStmt();
      break;
    }

    case 48: {
      enterOuterAlt(_localctx, 48);
      setState(553);
      returnStmt();
      break;
    }

    case 49: {
      enterOuterAlt(_localctx, 49);
      setState(554);
      rmdirStmt();
      break;
    }

    case 50: {
      enterOuterAlt(_localctx, 50);
      setState(555);
      rsetStmt();
      break;
    }

    case 51: {
      enterOuterAlt(_localctx, 51);
      setState(556);
      savepictureStmt();
      break;
    }

    case 52: {
      enterOuterAlt(_localctx, 52);
      setState(557);
      saveSettingStmt();
      break;
    }

    case 53: {
      enterOuterAlt(_localctx, 53);
      setState(558);
      seekStmt();
      break;
    }

    case 54: {
      enterOuterAlt(_localctx, 54);
      setState(559);
      selectCaseStmt();
      break;
    }

    case 55: {
      enterOuterAlt(_localctx, 55);
      setState(560);
      sendkeysStmt();
      break;
    }

    case 56: {
      enterOuterAlt(_localctx, 56);
      setState(561);
      setattrStmt();
      break;
    }

    case 57: {
      enterOuterAlt(_localctx, 57);
      setState(562);
      setStmt();
      break;
    }

    case 58: {
      enterOuterAlt(_localctx, 58);
      setState(563);
      stopStmt();
      break;
    }

    case 59: {
      enterOuterAlt(_localctx, 59);
      setState(564);
      timeStmt();
      break;
    }

    case 60: {
      enterOuterAlt(_localctx, 60);
      setState(565);
      unloadStmt();
      break;
    }

    case 61: {
      enterOuterAlt(_localctx, 61);
      setState(566);
      unlockStmt();
      break;
    }

    case 62: {
      enterOuterAlt(_localctx, 62);
      setState(567);
      variableStmt();
      break;
    }

    case 63: {
      enterOuterAlt(_localctx, 63);
      setState(568);
      whileWendStmt();
      break;
    }

    case 64: {
      enterOuterAlt(_localctx, 64);
      setState(569);
      widthStmt();
      break;
    }

    case 65: {
      enterOuterAlt(_localctx, 65);
      setState(570);
      withStmt();
      break;
    }

    case 66: {
      enterOuterAlt(_localctx, 66);
      setState(571);
      writeStmt();
      break;
    }

    case 67: {
      enterOuterAlt(_localctx, 67);
      setState(572);
      implicitCallStmt_InBlock();
      break;
    }

    case 68: {
      enterOuterAlt(_localctx, 68);
      setState(573);
      implicitCallStmt_InStmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AppactivateStmtContext ------------------------------------------------------------------

vbaParser::AppactivateStmtContext::AppactivateStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::AppactivateStmtContext::APPACTIVATE() {
  return getToken(vbaParser::APPACTIVATE, 0);
}

std::vector<tree::TerminalNode *> vbaParser::AppactivateStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::AppactivateStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

std::vector<vbaParser::ValueStmtContext *> vbaParser::AppactivateStmtContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::AppactivateStmtContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}


size_t vbaParser::AppactivateStmtContext::getRuleIndex() const {
  return vbaParser::RuleAppactivateStmt;
}

void vbaParser::AppactivateStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAppactivateStmt(this);
}

void vbaParser::AppactivateStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAppactivateStmt(this);
}

vbaParser::AppactivateStmtContext* vbaParser::appactivateStmt() {
  AppactivateStmtContext *_localctx = _tracker.createInstance<AppactivateStmtContext>(_ctx, getState());
  enterRule(_localctx, 30, vbaParser::RuleAppactivateStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(576);
    match(vbaParser::APPACTIVATE);
    setState(577);
    match(vbaParser::WS);
    setState(578);
    valueStmt(0);
    setState(587);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx)) {
    case 1: {
      setState(580);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(579);
        match(vbaParser::WS);
      }
      setState(582);
      match(vbaParser::T__0);
      setState(584);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(583);
        match(vbaParser::WS);
      }
      setState(586);
      valueStmt(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BeepStmtContext ------------------------------------------------------------------

vbaParser::BeepStmtContext::BeepStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::BeepStmtContext::BEEP() {
  return getToken(vbaParser::BEEP, 0);
}


size_t vbaParser::BeepStmtContext::getRuleIndex() const {
  return vbaParser::RuleBeepStmt;
}

void vbaParser::BeepStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBeepStmt(this);
}

void vbaParser::BeepStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBeepStmt(this);
}

vbaParser::BeepStmtContext* vbaParser::beepStmt() {
  BeepStmtContext *_localctx = _tracker.createInstance<BeepStmtContext>(_ctx, getState());
  enterRule(_localctx, 32, vbaParser::RuleBeepStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(589);
    match(vbaParser::BEEP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChdirStmtContext ------------------------------------------------------------------

vbaParser::ChdirStmtContext::ChdirStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::ChdirStmtContext::CHDIR() {
  return getToken(vbaParser::CHDIR, 0);
}

tree::TerminalNode* vbaParser::ChdirStmtContext::WS() {
  return getToken(vbaParser::WS, 0);
}

vbaParser::ValueStmtContext* vbaParser::ChdirStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}


size_t vbaParser::ChdirStmtContext::getRuleIndex() const {
  return vbaParser::RuleChdirStmt;
}

void vbaParser::ChdirStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChdirStmt(this);
}

void vbaParser::ChdirStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChdirStmt(this);
}

vbaParser::ChdirStmtContext* vbaParser::chdirStmt() {
  ChdirStmtContext *_localctx = _tracker.createInstance<ChdirStmtContext>(_ctx, getState());
  enterRule(_localctx, 34, vbaParser::RuleChdirStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(591);
    match(vbaParser::CHDIR);
    setState(592);
    match(vbaParser::WS);
    setState(593);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChdriveStmtContext ------------------------------------------------------------------

vbaParser::ChdriveStmtContext::ChdriveStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::ChdriveStmtContext::CHDRIVE() {
  return getToken(vbaParser::CHDRIVE, 0);
}

tree::TerminalNode* vbaParser::ChdriveStmtContext::WS() {
  return getToken(vbaParser::WS, 0);
}

vbaParser::ValueStmtContext* vbaParser::ChdriveStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}


size_t vbaParser::ChdriveStmtContext::getRuleIndex() const {
  return vbaParser::RuleChdriveStmt;
}

void vbaParser::ChdriveStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChdriveStmt(this);
}

void vbaParser::ChdriveStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChdriveStmt(this);
}

vbaParser::ChdriveStmtContext* vbaParser::chdriveStmt() {
  ChdriveStmtContext *_localctx = _tracker.createInstance<ChdriveStmtContext>(_ctx, getState());
  enterRule(_localctx, 36, vbaParser::RuleChdriveStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(595);
    match(vbaParser::CHDRIVE);
    setState(596);
    match(vbaParser::WS);
    setState(597);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CloseStmtContext ------------------------------------------------------------------

vbaParser::CloseStmtContext::CloseStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::CloseStmtContext::CLOSE() {
  return getToken(vbaParser::CLOSE, 0);
}

std::vector<tree::TerminalNode *> vbaParser::CloseStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::CloseStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

std::vector<vbaParser::FileNumberContext *> vbaParser::CloseStmtContext::fileNumber() {
  return getRuleContexts<vbaParser::FileNumberContext>();
}

vbaParser::FileNumberContext* vbaParser::CloseStmtContext::fileNumber(size_t i) {
  return getRuleContext<vbaParser::FileNumberContext>(i);
}


size_t vbaParser::CloseStmtContext::getRuleIndex() const {
  return vbaParser::RuleCloseStmt;
}

void vbaParser::CloseStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCloseStmt(this);
}

void vbaParser::CloseStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCloseStmt(this);
}

vbaParser::CloseStmtContext* vbaParser::closeStmt() {
  CloseStmtContext *_localctx = _tracker.createInstance<CloseStmtContext>(_ctx, getState());
  enterRule(_localctx, 38, vbaParser::RuleCloseStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(599);
    match(vbaParser::CLOSE);
    setState(615);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
    case 1: {
      setState(600);
      match(vbaParser::WS);
      setState(601);
      fileNumber();
      setState(612);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(603);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(602);
            match(vbaParser::WS);
          }
          setState(605);
          match(vbaParser::T__0);
          setState(607);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(606);
            match(vbaParser::WS);
          }
          setState(609);
          fileNumber(); 
        }
        setState(614);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstStmtContext ------------------------------------------------------------------

vbaParser::ConstStmtContext::ConstStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::ConstStmtContext::CONST() {
  return getToken(vbaParser::CONST, 0);
}

std::vector<tree::TerminalNode *> vbaParser::ConstStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::ConstStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

std::vector<vbaParser::ConstSubStmtContext *> vbaParser::ConstStmtContext::constSubStmt() {
  return getRuleContexts<vbaParser::ConstSubStmtContext>();
}

vbaParser::ConstSubStmtContext* vbaParser::ConstStmtContext::constSubStmt(size_t i) {
  return getRuleContext<vbaParser::ConstSubStmtContext>(i);
}

vbaParser::VisibilityContext* vbaParser::ConstStmtContext::visibility() {
  return getRuleContext<vbaParser::VisibilityContext>(0);
}


size_t vbaParser::ConstStmtContext::getRuleIndex() const {
  return vbaParser::RuleConstStmt;
}

void vbaParser::ConstStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstStmt(this);
}

void vbaParser::ConstStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstStmt(this);
}

vbaParser::ConstStmtContext* vbaParser::constStmt() {
  ConstStmtContext *_localctx = _tracker.createInstance<ConstStmtContext>(_ctx, getState());
  enterRule(_localctx, 40, vbaParser::RuleConstStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(620);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 75) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 75)) & 4755801206503243793) != 0)) {
      setState(617);
      visibility();
      setState(618);
      match(vbaParser::WS);
    }
    setState(622);
    match(vbaParser::CONST);
    setState(623);
    match(vbaParser::WS);
    setState(624);
    constSubStmt();
    setState(635);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(626);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(625);
          match(vbaParser::WS);
        }
        setState(628);
        match(vbaParser::T__0);
        setState(630);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(629);
          match(vbaParser::WS);
        }
        setState(632);
        constSubStmt(); 
      }
      setState(637);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstSubStmtContext ------------------------------------------------------------------

vbaParser::ConstSubStmtContext::ConstSubStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::AmbiguousIdentifierContext* vbaParser::ConstSubStmtContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

tree::TerminalNode* vbaParser::ConstSubStmtContext::EQ() {
  return getToken(vbaParser::EQ, 0);
}

vbaParser::ValueStmtContext* vbaParser::ConstSubStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

vbaParser::TypeHintContext* vbaParser::ConstSubStmtContext::typeHint() {
  return getRuleContext<vbaParser::TypeHintContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::ConstSubStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::ConstSubStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::AsTypeClauseContext* vbaParser::ConstSubStmtContext::asTypeClause() {
  return getRuleContext<vbaParser::AsTypeClauseContext>(0);
}


size_t vbaParser::ConstSubStmtContext::getRuleIndex() const {
  return vbaParser::RuleConstSubStmt;
}

void vbaParser::ConstSubStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstSubStmt(this);
}

void vbaParser::ConstSubStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstSubStmt(this);
}

vbaParser::ConstSubStmtContext* vbaParser::constSubStmt() {
  ConstSubStmtContext *_localctx = _tracker.createInstance<ConstSubStmtContext>(_ctx, getState());
  enterRule(_localctx, 42, vbaParser::RuleConstSubStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(638);
    ambiguousIdentifier();
    setState(640);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 488) != 0) || _la == vbaParser::AMPERSAND) {
      setState(639);
      typeHint();
    }
    setState(644);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
    case 1: {
      setState(642);
      match(vbaParser::WS);
      setState(643);
      asTypeClause();
      break;
    }

    default:
      break;
    }
    setState(647);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(646);
      match(vbaParser::WS);
    }
    setState(649);
    match(vbaParser::EQ);
    setState(651);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(650);
      match(vbaParser::WS);
    }
    setState(653);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DateStmtContext ------------------------------------------------------------------

vbaParser::DateStmtContext::DateStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::DateStmtContext::DATE() {
  return getToken(vbaParser::DATE, 0);
}

tree::TerminalNode* vbaParser::DateStmtContext::EQ() {
  return getToken(vbaParser::EQ, 0);
}

vbaParser::ValueStmtContext* vbaParser::DateStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::DateStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::DateStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}


size_t vbaParser::DateStmtContext::getRuleIndex() const {
  return vbaParser::RuleDateStmt;
}

void vbaParser::DateStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDateStmt(this);
}

void vbaParser::DateStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDateStmt(this);
}

vbaParser::DateStmtContext* vbaParser::dateStmt() {
  DateStmtContext *_localctx = _tracker.createInstance<DateStmtContext>(_ctx, getState());
  enterRule(_localctx, 44, vbaParser::RuleDateStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(655);
    match(vbaParser::DATE);
    setState(657);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(656);
      match(vbaParser::WS);
    }
    setState(659);
    match(vbaParser::EQ);
    setState(661);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(660);
      match(vbaParser::WS);
    }
    setState(663);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclareStmtContext ------------------------------------------------------------------

vbaParser::DeclareStmtContext::DeclareStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::DeclareStmtContext::DECLARE() {
  return getToken(vbaParser::DECLARE, 0);
}

std::vector<tree::TerminalNode *> vbaParser::DeclareStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::DeclareStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::AmbiguousIdentifierContext* vbaParser::DeclareStmtContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

tree::TerminalNode* vbaParser::DeclareStmtContext::LIB() {
  return getToken(vbaParser::LIB, 0);
}

std::vector<tree::TerminalNode *> vbaParser::DeclareStmtContext::STRINGLITERAL() {
  return getTokens(vbaParser::STRINGLITERAL);
}

tree::TerminalNode* vbaParser::DeclareStmtContext::STRINGLITERAL(size_t i) {
  return getToken(vbaParser::STRINGLITERAL, i);
}

tree::TerminalNode* vbaParser::DeclareStmtContext::SUB() {
  return getToken(vbaParser::SUB, 0);
}

vbaParser::VisibilityContext* vbaParser::DeclareStmtContext::visibility() {
  return getRuleContext<vbaParser::VisibilityContext>(0);
}

tree::TerminalNode* vbaParser::DeclareStmtContext::PTRSAFE() {
  return getToken(vbaParser::PTRSAFE, 0);
}

std::vector<vbaParser::TypeHintContext *> vbaParser::DeclareStmtContext::typeHint() {
  return getRuleContexts<vbaParser::TypeHintContext>();
}

vbaParser::TypeHintContext* vbaParser::DeclareStmtContext::typeHint(size_t i) {
  return getRuleContext<vbaParser::TypeHintContext>(i);
}

tree::TerminalNode* vbaParser::DeclareStmtContext::ALIAS() {
  return getToken(vbaParser::ALIAS, 0);
}

vbaParser::ArgListContext* vbaParser::DeclareStmtContext::argList() {
  return getRuleContext<vbaParser::ArgListContext>(0);
}

vbaParser::AsTypeClauseContext* vbaParser::DeclareStmtContext::asTypeClause() {
  return getRuleContext<vbaParser::AsTypeClauseContext>(0);
}

tree::TerminalNode* vbaParser::DeclareStmtContext::FUNCTION() {
  return getToken(vbaParser::FUNCTION, 0);
}


size_t vbaParser::DeclareStmtContext::getRuleIndex() const {
  return vbaParser::RuleDeclareStmt;
}

void vbaParser::DeclareStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclareStmt(this);
}

void vbaParser::DeclareStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclareStmt(this);
}

vbaParser::DeclareStmtContext* vbaParser::declareStmt() {
  DeclareStmtContext *_localctx = _tracker.createInstance<DeclareStmtContext>(_ctx, getState());
  enterRule(_localctx, 46, vbaParser::RuleDeclareStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(668);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 75) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 75)) & 4755801206503243793) != 0)) {
      setState(665);
      visibility();
      setState(666);
      match(vbaParser::WS);
    }
    setState(670);
    match(vbaParser::DECLARE);
    setState(671);
    match(vbaParser::WS);
    setState(674);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::PTRSAFE) {
      setState(672);
      match(vbaParser::PTRSAFE);
      setState(673);
      match(vbaParser::WS);
    }
    setState(681);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case vbaParser::FUNCTION: {
        setState(676);
        match(vbaParser::FUNCTION);
        setState(678);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 488) != 0) || _la == vbaParser::AMPERSAND) {
          setState(677);
          typeHint();
        }
        break;
      }

      case vbaParser::SUB: {
        setState(680);
        match(vbaParser::SUB);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(683);
    match(vbaParser::WS);
    setState(684);
    ambiguousIdentifier();
    setState(686);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 488) != 0) || _la == vbaParser::AMPERSAND) {
      setState(685);
      typeHint();
    }
    setState(688);
    match(vbaParser::WS);
    setState(689);
    match(vbaParser::LIB);
    setState(690);
    match(vbaParser::WS);
    setState(691);
    match(vbaParser::STRINGLITERAL);
    setState(696);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
    case 1: {
      setState(692);
      match(vbaParser::WS);
      setState(693);
      match(vbaParser::ALIAS);
      setState(694);
      match(vbaParser::WS);
      setState(695);
      match(vbaParser::STRINGLITERAL);
      break;
    }

    default:
      break;
    }
    setState(702);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx)) {
    case 1: {
      setState(699);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(698);
        match(vbaParser::WS);
      }
      setState(701);
      argList();
      break;
    }

    default:
      break;
    }
    setState(706);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
    case 1: {
      setState(704);
      match(vbaParser::WS);
      setState(705);
      asTypeClause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeftypeStmtContext ------------------------------------------------------------------

vbaParser::DeftypeStmtContext::DeftypeStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> vbaParser::DeftypeStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::DeftypeStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

std::vector<vbaParser::LetterrangeContext *> vbaParser::DeftypeStmtContext::letterrange() {
  return getRuleContexts<vbaParser::LetterrangeContext>();
}

vbaParser::LetterrangeContext* vbaParser::DeftypeStmtContext::letterrange(size_t i) {
  return getRuleContext<vbaParser::LetterrangeContext>(i);
}

tree::TerminalNode* vbaParser::DeftypeStmtContext::DEFBOOL() {
  return getToken(vbaParser::DEFBOOL, 0);
}

tree::TerminalNode* vbaParser::DeftypeStmtContext::DEFBYTE() {
  return getToken(vbaParser::DEFBYTE, 0);
}

tree::TerminalNode* vbaParser::DeftypeStmtContext::DEFINT() {
  return getToken(vbaParser::DEFINT, 0);
}

tree::TerminalNode* vbaParser::DeftypeStmtContext::DEFLNG() {
  return getToken(vbaParser::DEFLNG, 0);
}

tree::TerminalNode* vbaParser::DeftypeStmtContext::DEFCUR() {
  return getToken(vbaParser::DEFCUR, 0);
}

tree::TerminalNode* vbaParser::DeftypeStmtContext::DEFSNG() {
  return getToken(vbaParser::DEFSNG, 0);
}

tree::TerminalNode* vbaParser::DeftypeStmtContext::DEFDBL() {
  return getToken(vbaParser::DEFDBL, 0);
}

tree::TerminalNode* vbaParser::DeftypeStmtContext::DEFDEC() {
  return getToken(vbaParser::DEFDEC, 0);
}

tree::TerminalNode* vbaParser::DeftypeStmtContext::DEFDATE() {
  return getToken(vbaParser::DEFDATE, 0);
}

tree::TerminalNode* vbaParser::DeftypeStmtContext::DEFSTR() {
  return getToken(vbaParser::DEFSTR, 0);
}

tree::TerminalNode* vbaParser::DeftypeStmtContext::DEFOBJ() {
  return getToken(vbaParser::DEFOBJ, 0);
}

tree::TerminalNode* vbaParser::DeftypeStmtContext::DEFVAR() {
  return getToken(vbaParser::DEFVAR, 0);
}


size_t vbaParser::DeftypeStmtContext::getRuleIndex() const {
  return vbaParser::RuleDeftypeStmt;
}

void vbaParser::DeftypeStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeftypeStmt(this);
}

void vbaParser::DeftypeStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeftypeStmt(this);
}

vbaParser::DeftypeStmtContext* vbaParser::deftypeStmt() {
  DeftypeStmtContext *_localctx = _tracker.createInstance<DeftypeStmtContext>(_ctx, getState());
  enterRule(_localctx, 48, vbaParser::RuleDeftypeStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(708);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 140703128616960) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(709);
    match(vbaParser::WS);
    setState(710);
    letterrange();
    setState(721);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(712);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(711);
          match(vbaParser::WS);
        }
        setState(714);
        match(vbaParser::T__0);
        setState(716);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(715);
          match(vbaParser::WS);
        }
        setState(718);
        letterrange(); 
      }
      setState(723);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeleteSettingStmtContext ------------------------------------------------------------------

vbaParser::DeleteSettingStmtContext::DeleteSettingStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::DeleteSettingStmtContext::DELETESETTING() {
  return getToken(vbaParser::DELETESETTING, 0);
}

std::vector<tree::TerminalNode *> vbaParser::DeleteSettingStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::DeleteSettingStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

std::vector<vbaParser::ValueStmtContext *> vbaParser::DeleteSettingStmtContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::DeleteSettingStmtContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}


size_t vbaParser::DeleteSettingStmtContext::getRuleIndex() const {
  return vbaParser::RuleDeleteSettingStmt;
}

void vbaParser::DeleteSettingStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeleteSettingStmt(this);
}

void vbaParser::DeleteSettingStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeleteSettingStmt(this);
}

vbaParser::DeleteSettingStmtContext* vbaParser::deleteSettingStmt() {
  DeleteSettingStmtContext *_localctx = _tracker.createInstance<DeleteSettingStmtContext>(_ctx, getState());
  enterRule(_localctx, 50, vbaParser::RuleDeleteSettingStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(724);
    match(vbaParser::DELETESETTING);
    setState(725);
    match(vbaParser::WS);
    setState(726);
    valueStmt(0);
    setState(728);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(727);
      match(vbaParser::WS);
    }
    setState(730);
    match(vbaParser::T__0);
    setState(732);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(731);
      match(vbaParser::WS);
    }
    setState(734);
    valueStmt(0);
    setState(743);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx)) {
    case 1: {
      setState(736);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(735);
        match(vbaParser::WS);
      }
      setState(738);
      match(vbaParser::T__0);
      setState(740);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(739);
        match(vbaParser::WS);
      }
      setState(742);
      valueStmt(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DoLoopStmtContext ------------------------------------------------------------------

vbaParser::DoLoopStmtContext::DoLoopStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::DoLoopStmtContext::DO() {
  return getToken(vbaParser::DO, 0);
}

vbaParser::EndOfStatementContext* vbaParser::DoLoopStmtContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

tree::TerminalNode* vbaParser::DoLoopStmtContext::LOOP() {
  return getToken(vbaParser::LOOP, 0);
}

vbaParser::BlockContext* vbaParser::DoLoopStmtContext::block() {
  return getRuleContext<vbaParser::BlockContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::DoLoopStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::DoLoopStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::ValueStmtContext* vbaParser::DoLoopStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

tree::TerminalNode* vbaParser::DoLoopStmtContext::WHILE() {
  return getToken(vbaParser::WHILE, 0);
}

tree::TerminalNode* vbaParser::DoLoopStmtContext::UNTIL() {
  return getToken(vbaParser::UNTIL, 0);
}


size_t vbaParser::DoLoopStmtContext::getRuleIndex() const {
  return vbaParser::RuleDoLoopStmt;
}

void vbaParser::DoLoopStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoLoopStmt(this);
}

void vbaParser::DoLoopStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoLoopStmt(this);
}

vbaParser::DoLoopStmtContext* vbaParser::doLoopStmt() {
  DoLoopStmtContext *_localctx = _tracker.createInstance<DoLoopStmtContext>(_ctx, getState());
  enterRule(_localctx, 52, vbaParser::RuleDoLoopStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(772);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(745);
      match(vbaParser::DO);
      setState(746);
      endOfStatement();
      setState(748);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx)) {
      case 1: {
        setState(747);
        block();
        break;
      }

      default:
        break;
      }
      setState(750);
      match(vbaParser::LOOP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(752);
      match(vbaParser::DO);
      setState(753);
      match(vbaParser::WS);
      setState(754);
      _la = _input->LA(1);
      if (!(_la == vbaParser::UNTIL

      || _la == vbaParser::WHILE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(755);
      match(vbaParser::WS);
      setState(756);
      valueStmt(0);
      setState(757);
      endOfStatement();
      setState(759);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
      case 1: {
        setState(758);
        block();
        break;
      }

      default:
        break;
      }
      setState(761);
      match(vbaParser::LOOP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(763);
      match(vbaParser::DO);
      setState(764);
      endOfStatement();
      setState(765);
      block();
      setState(766);
      match(vbaParser::LOOP);
      setState(767);
      match(vbaParser::WS);
      setState(768);
      _la = _input->LA(1);
      if (!(_la == vbaParser::UNTIL

      || _la == vbaParser::WHILE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(769);
      match(vbaParser::WS);
      setState(770);
      valueStmt(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EndStmtContext ------------------------------------------------------------------

vbaParser::EndStmtContext::EndStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::EndStmtContext::END() {
  return getToken(vbaParser::END, 0);
}


size_t vbaParser::EndStmtContext::getRuleIndex() const {
  return vbaParser::RuleEndStmt;
}

void vbaParser::EndStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEndStmt(this);
}

void vbaParser::EndStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEndStmt(this);
}

vbaParser::EndStmtContext* vbaParser::endStmt() {
  EndStmtContext *_localctx = _tracker.createInstance<EndStmtContext>(_ctx, getState());
  enterRule(_localctx, 54, vbaParser::RuleEndStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(774);
    match(vbaParser::END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumerationStmtContext ------------------------------------------------------------------

vbaParser::EnumerationStmtContext::EnumerationStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::EnumerationStmtContext::ENUM() {
  return getToken(vbaParser::ENUM, 0);
}

std::vector<tree::TerminalNode *> vbaParser::EnumerationStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::EnumerationStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::AmbiguousIdentifierContext* vbaParser::EnumerationStmtContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

vbaParser::EndOfStatementContext* vbaParser::EnumerationStmtContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

tree::TerminalNode* vbaParser::EnumerationStmtContext::END_ENUM() {
  return getToken(vbaParser::END_ENUM, 0);
}

vbaParser::VisibilityContext* vbaParser::EnumerationStmtContext::visibility() {
  return getRuleContext<vbaParser::VisibilityContext>(0);
}

std::vector<vbaParser::EnumerationStmt_ConstantContext *> vbaParser::EnumerationStmtContext::enumerationStmt_Constant() {
  return getRuleContexts<vbaParser::EnumerationStmt_ConstantContext>();
}

vbaParser::EnumerationStmt_ConstantContext* vbaParser::EnumerationStmtContext::enumerationStmt_Constant(size_t i) {
  return getRuleContext<vbaParser::EnumerationStmt_ConstantContext>(i);
}


size_t vbaParser::EnumerationStmtContext::getRuleIndex() const {
  return vbaParser::RuleEnumerationStmt;
}

void vbaParser::EnumerationStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumerationStmt(this);
}

void vbaParser::EnumerationStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumerationStmt(this);
}

vbaParser::EnumerationStmtContext* vbaParser::enumerationStmt() {
  EnumerationStmtContext *_localctx = _tracker.createInstance<EnumerationStmtContext>(_ctx, getState());
  enterRule(_localctx, 56, vbaParser::RuleEnumerationStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(779);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 75) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 75)) & 4755801206503243793) != 0)) {
      setState(776);
      visibility();
      setState(777);
      match(vbaParser::WS);
    }
    setState(781);
    match(vbaParser::ENUM);
    setState(782);
    match(vbaParser::WS);
    setState(783);
    ambiguousIdentifier();
    setState(784);
    endOfStatement();
    setState(788);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4593671619917906432) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -8755014975736513009) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 288230376151678495) != 0) || _la == vbaParser::IDENTIFIER) {
      setState(785);
      enumerationStmt_Constant();
      setState(790);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(791);
    match(vbaParser::END_ENUM);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumerationStmt_ConstantContext ------------------------------------------------------------------

vbaParser::EnumerationStmt_ConstantContext::EnumerationStmt_ConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::AmbiguousIdentifierContext* vbaParser::EnumerationStmt_ConstantContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

vbaParser::EndOfStatementContext* vbaParser::EnumerationStmt_ConstantContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

tree::TerminalNode* vbaParser::EnumerationStmt_ConstantContext::EQ() {
  return getToken(vbaParser::EQ, 0);
}

vbaParser::ValueStmtContext* vbaParser::EnumerationStmt_ConstantContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::EnumerationStmt_ConstantContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::EnumerationStmt_ConstantContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}


size_t vbaParser::EnumerationStmt_ConstantContext::getRuleIndex() const {
  return vbaParser::RuleEnumerationStmt_Constant;
}

void vbaParser::EnumerationStmt_ConstantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumerationStmt_Constant(this);
}

void vbaParser::EnumerationStmt_ConstantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumerationStmt_Constant(this);
}

vbaParser::EnumerationStmt_ConstantContext* vbaParser::enumerationStmt_Constant() {
  EnumerationStmt_ConstantContext *_localctx = _tracker.createInstance<EnumerationStmt_ConstantContext>(_ctx, getState());
  enterRule(_localctx, 58, vbaParser::RuleEnumerationStmt_Constant);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(793);
    ambiguousIdentifier();
    setState(802);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx)) {
    case 1: {
      setState(795);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(794);
        match(vbaParser::WS);
      }
      setState(797);
      match(vbaParser::EQ);
      setState(799);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(798);
        match(vbaParser::WS);
      }
      setState(801);
      valueStmt(0);
      break;
    }

    default:
      break;
    }
    setState(804);
    endOfStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EraseStmtContext ------------------------------------------------------------------

vbaParser::EraseStmtContext::EraseStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::EraseStmtContext::ERASE() {
  return getToken(vbaParser::ERASE, 0);
}

std::vector<tree::TerminalNode *> vbaParser::EraseStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::EraseStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

std::vector<vbaParser::ValueStmtContext *> vbaParser::EraseStmtContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::EraseStmtContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}


size_t vbaParser::EraseStmtContext::getRuleIndex() const {
  return vbaParser::RuleEraseStmt;
}

void vbaParser::EraseStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEraseStmt(this);
}

void vbaParser::EraseStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEraseStmt(this);
}

vbaParser::EraseStmtContext* vbaParser::eraseStmt() {
  EraseStmtContext *_localctx = _tracker.createInstance<EraseStmtContext>(_ctx, getState());
  enterRule(_localctx, 60, vbaParser::RuleEraseStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(806);
    match(vbaParser::ERASE);
    setState(807);
    match(vbaParser::WS);
    setState(808);
    valueStmt(0);
    setState(816);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(809);
        match(vbaParser::T__0);
        setState(811);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(810);
          match(vbaParser::WS);
        }
        setState(813);
        valueStmt(0); 
      }
      setState(818);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ErrorStmtContext ------------------------------------------------------------------

vbaParser::ErrorStmtContext::ErrorStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::ErrorStmtContext::ERROR() {
  return getToken(vbaParser::ERROR, 0);
}

tree::TerminalNode* vbaParser::ErrorStmtContext::WS() {
  return getToken(vbaParser::WS, 0);
}

vbaParser::ValueStmtContext* vbaParser::ErrorStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}


size_t vbaParser::ErrorStmtContext::getRuleIndex() const {
  return vbaParser::RuleErrorStmt;
}

void vbaParser::ErrorStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterErrorStmt(this);
}

void vbaParser::ErrorStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitErrorStmt(this);
}

vbaParser::ErrorStmtContext* vbaParser::errorStmt() {
  ErrorStmtContext *_localctx = _tracker.createInstance<ErrorStmtContext>(_ctx, getState());
  enterRule(_localctx, 62, vbaParser::RuleErrorStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(819);
    match(vbaParser::ERROR);
    setState(820);
    match(vbaParser::WS);
    setState(821);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EventStmtContext ------------------------------------------------------------------

vbaParser::EventStmtContext::EventStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::EventStmtContext::EVENT() {
  return getToken(vbaParser::EVENT, 0);
}

std::vector<tree::TerminalNode *> vbaParser::EventStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::EventStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::AmbiguousIdentifierContext* vbaParser::EventStmtContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

vbaParser::ArgListContext* vbaParser::EventStmtContext::argList() {
  return getRuleContext<vbaParser::ArgListContext>(0);
}

vbaParser::VisibilityContext* vbaParser::EventStmtContext::visibility() {
  return getRuleContext<vbaParser::VisibilityContext>(0);
}


size_t vbaParser::EventStmtContext::getRuleIndex() const {
  return vbaParser::RuleEventStmt;
}

void vbaParser::EventStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEventStmt(this);
}

void vbaParser::EventStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEventStmt(this);
}

vbaParser::EventStmtContext* vbaParser::eventStmt() {
  EventStmtContext *_localctx = _tracker.createInstance<EventStmtContext>(_ctx, getState());
  enterRule(_localctx, 64, vbaParser::RuleEventStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(826);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 75) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 75)) & 4755801206503243793) != 0)) {
      setState(823);
      visibility();
      setState(824);
      match(vbaParser::WS);
    }
    setState(828);
    match(vbaParser::EVENT);
    setState(829);
    match(vbaParser::WS);
    setState(830);
    ambiguousIdentifier();
    setState(832);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(831);
      match(vbaParser::WS);
    }
    setState(834);
    argList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExitStmtContext ------------------------------------------------------------------

vbaParser::ExitStmtContext::ExitStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::ExitStmtContext::EXIT_DO() {
  return getToken(vbaParser::EXIT_DO, 0);
}

tree::TerminalNode* vbaParser::ExitStmtContext::EXIT_FOR() {
  return getToken(vbaParser::EXIT_FOR, 0);
}

tree::TerminalNode* vbaParser::ExitStmtContext::EXIT_FUNCTION() {
  return getToken(vbaParser::EXIT_FUNCTION, 0);
}

tree::TerminalNode* vbaParser::ExitStmtContext::EXIT_PROPERTY() {
  return getToken(vbaParser::EXIT_PROPERTY, 0);
}

tree::TerminalNode* vbaParser::ExitStmtContext::EXIT_SUB() {
  return getToken(vbaParser::EXIT_SUB, 0);
}


size_t vbaParser::ExitStmtContext::getRuleIndex() const {
  return vbaParser::RuleExitStmt;
}

void vbaParser::ExitStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExitStmt(this);
}

void vbaParser::ExitStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExitStmt(this);
}

vbaParser::ExitStmtContext* vbaParser::exitStmt() {
  ExitStmtContext *_localctx = _tracker.createInstance<ExitStmtContext>(_ctx, getState());
  enterRule(_localctx, 66, vbaParser::RuleExitStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(836);
    _la = _input->LA(1);
    if (!(((((_la - 68) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 68)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilecopyStmtContext ------------------------------------------------------------------

vbaParser::FilecopyStmtContext::FilecopyStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::FilecopyStmtContext::FILECOPY() {
  return getToken(vbaParser::FILECOPY, 0);
}

std::vector<tree::TerminalNode *> vbaParser::FilecopyStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::FilecopyStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

std::vector<vbaParser::ValueStmtContext *> vbaParser::FilecopyStmtContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::FilecopyStmtContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}


size_t vbaParser::FilecopyStmtContext::getRuleIndex() const {
  return vbaParser::RuleFilecopyStmt;
}

void vbaParser::FilecopyStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilecopyStmt(this);
}

void vbaParser::FilecopyStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilecopyStmt(this);
}

vbaParser::FilecopyStmtContext* vbaParser::filecopyStmt() {
  FilecopyStmtContext *_localctx = _tracker.createInstance<FilecopyStmtContext>(_ctx, getState());
  enterRule(_localctx, 68, vbaParser::RuleFilecopyStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(838);
    match(vbaParser::FILECOPY);
    setState(839);
    match(vbaParser::WS);
    setState(840);
    valueStmt(0);
    setState(842);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(841);
      match(vbaParser::WS);
    }
    setState(844);
    match(vbaParser::T__0);
    setState(846);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(845);
      match(vbaParser::WS);
    }
    setState(848);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForEachStmtContext ------------------------------------------------------------------

vbaParser::ForEachStmtContext::ForEachStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::ForEachStmtContext::FOR() {
  return getToken(vbaParser::FOR, 0);
}

std::vector<tree::TerminalNode *> vbaParser::ForEachStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::ForEachStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

tree::TerminalNode* vbaParser::ForEachStmtContext::EACH() {
  return getToken(vbaParser::EACH, 0);
}

std::vector<vbaParser::AmbiguousIdentifierContext *> vbaParser::ForEachStmtContext::ambiguousIdentifier() {
  return getRuleContexts<vbaParser::AmbiguousIdentifierContext>();
}

vbaParser::AmbiguousIdentifierContext* vbaParser::ForEachStmtContext::ambiguousIdentifier(size_t i) {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(i);
}

tree::TerminalNode* vbaParser::ForEachStmtContext::IN() {
  return getToken(vbaParser::IN, 0);
}

vbaParser::ValueStmtContext* vbaParser::ForEachStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

vbaParser::EndOfStatementContext* vbaParser::ForEachStmtContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

tree::TerminalNode* vbaParser::ForEachStmtContext::NEXT() {
  return getToken(vbaParser::NEXT, 0);
}

vbaParser::TypeHintContext* vbaParser::ForEachStmtContext::typeHint() {
  return getRuleContext<vbaParser::TypeHintContext>(0);
}

vbaParser::BlockContext* vbaParser::ForEachStmtContext::block() {
  return getRuleContext<vbaParser::BlockContext>(0);
}


size_t vbaParser::ForEachStmtContext::getRuleIndex() const {
  return vbaParser::RuleForEachStmt;
}

void vbaParser::ForEachStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForEachStmt(this);
}

void vbaParser::ForEachStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForEachStmt(this);
}

vbaParser::ForEachStmtContext* vbaParser::forEachStmt() {
  ForEachStmtContext *_localctx = _tracker.createInstance<ForEachStmtContext>(_ctx, getState());
  enterRule(_localctx, 70, vbaParser::RuleForEachStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(850);
    match(vbaParser::FOR);
    setState(851);
    match(vbaParser::WS);
    setState(852);
    match(vbaParser::EACH);
    setState(853);
    match(vbaParser::WS);
    setState(854);
    ambiguousIdentifier();
    setState(856);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 488) != 0) || _la == vbaParser::AMPERSAND) {
      setState(855);
      typeHint();
    }
    setState(858);
    match(vbaParser::WS);
    setState(859);
    match(vbaParser::IN);
    setState(860);
    match(vbaParser::WS);
    setState(861);
    valueStmt(0);
    setState(862);
    endOfStatement();
    setState(864);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
    case 1: {
      setState(863);
      block();
      break;
    }

    default:
      break;
    }
    setState(866);
    match(vbaParser::NEXT);
    setState(869);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx)) {
    case 1: {
      setState(867);
      match(vbaParser::WS);
      setState(868);
      ambiguousIdentifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForNextStmtContext ------------------------------------------------------------------

vbaParser::ForNextStmtContext::ForNextStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::ForNextStmtContext::FOR() {
  return getToken(vbaParser::FOR, 0);
}

std::vector<tree::TerminalNode *> vbaParser::ForNextStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::ForNextStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

std::vector<vbaParser::AmbiguousIdentifierContext *> vbaParser::ForNextStmtContext::ambiguousIdentifier() {
  return getRuleContexts<vbaParser::AmbiguousIdentifierContext>();
}

vbaParser::AmbiguousIdentifierContext* vbaParser::ForNextStmtContext::ambiguousIdentifier(size_t i) {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(i);
}

tree::TerminalNode* vbaParser::ForNextStmtContext::EQ() {
  return getToken(vbaParser::EQ, 0);
}

std::vector<vbaParser::ValueStmtContext *> vbaParser::ForNextStmtContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::ForNextStmtContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

tree::TerminalNode* vbaParser::ForNextStmtContext::TO() {
  return getToken(vbaParser::TO, 0);
}

vbaParser::EndOfStatementContext* vbaParser::ForNextStmtContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

tree::TerminalNode* vbaParser::ForNextStmtContext::NEXT() {
  return getToken(vbaParser::NEXT, 0);
}

vbaParser::TypeHintContext* vbaParser::ForNextStmtContext::typeHint() {
  return getRuleContext<vbaParser::TypeHintContext>(0);
}

vbaParser::AsTypeClauseContext* vbaParser::ForNextStmtContext::asTypeClause() {
  return getRuleContext<vbaParser::AsTypeClauseContext>(0);
}

tree::TerminalNode* vbaParser::ForNextStmtContext::STEP() {
  return getToken(vbaParser::STEP, 0);
}

vbaParser::BlockContext* vbaParser::ForNextStmtContext::block() {
  return getRuleContext<vbaParser::BlockContext>(0);
}


size_t vbaParser::ForNextStmtContext::getRuleIndex() const {
  return vbaParser::RuleForNextStmt;
}

void vbaParser::ForNextStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForNextStmt(this);
}

void vbaParser::ForNextStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForNextStmt(this);
}

vbaParser::ForNextStmtContext* vbaParser::forNextStmt() {
  ForNextStmtContext *_localctx = _tracker.createInstance<ForNextStmtContext>(_ctx, getState());
  enterRule(_localctx, 72, vbaParser::RuleForNextStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(871);
    match(vbaParser::FOR);
    setState(872);
    match(vbaParser::WS);
    setState(873);
    ambiguousIdentifier();
    setState(875);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 488) != 0) || _la == vbaParser::AMPERSAND) {
      setState(874);
      typeHint();
    }
    setState(879);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx)) {
    case 1: {
      setState(877);
      match(vbaParser::WS);
      setState(878);
      asTypeClause();
      break;
    }

    default:
      break;
    }
    setState(882);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(881);
      match(vbaParser::WS);
    }
    setState(884);
    match(vbaParser::EQ);
    setState(886);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(885);
      match(vbaParser::WS);
    }
    setState(888);
    valueStmt(0);
    setState(889);
    match(vbaParser::WS);
    setState(890);
    match(vbaParser::TO);
    setState(891);
    match(vbaParser::WS);
    setState(892);
    valueStmt(0);
    setState(897);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 92, _ctx)) {
    case 1: {
      setState(893);
      match(vbaParser::WS);
      setState(894);
      match(vbaParser::STEP);
      setState(895);
      match(vbaParser::WS);
      setState(896);
      valueStmt(0);
      break;
    }

    default:
      break;
    }
    setState(899);
    endOfStatement();
    setState(901);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx)) {
    case 1: {
      setState(900);
      block();
      break;
    }

    default:
      break;
    }
    setState(903);
    match(vbaParser::NEXT);
    setState(906);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx)) {
    case 1: {
      setState(904);
      match(vbaParser::WS);
      setState(905);
      ambiguousIdentifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionStmtContext ------------------------------------------------------------------

vbaParser::FunctionStmtContext::FunctionStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::FunctionStmtContext::FUNCTION() {
  return getToken(vbaParser::FUNCTION, 0);
}

vbaParser::AmbiguousIdentifierContext* vbaParser::FunctionStmtContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

vbaParser::EndOfStatementContext* vbaParser::FunctionStmtContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

tree::TerminalNode* vbaParser::FunctionStmtContext::END_FUNCTION() {
  return getToken(vbaParser::END_FUNCTION, 0);
}

vbaParser::VisibilityContext* vbaParser::FunctionStmtContext::visibility() {
  return getRuleContext<vbaParser::VisibilityContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::FunctionStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::FunctionStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

tree::TerminalNode* vbaParser::FunctionStmtContext::STATIC() {
  return getToken(vbaParser::STATIC, 0);
}

vbaParser::TypeHintContext* vbaParser::FunctionStmtContext::typeHint() {
  return getRuleContext<vbaParser::TypeHintContext>(0);
}

vbaParser::ArgListContext* vbaParser::FunctionStmtContext::argList() {
  return getRuleContext<vbaParser::ArgListContext>(0);
}

vbaParser::AsTypeClauseContext* vbaParser::FunctionStmtContext::asTypeClause() {
  return getRuleContext<vbaParser::AsTypeClauseContext>(0);
}

vbaParser::BlockContext* vbaParser::FunctionStmtContext::block() {
  return getRuleContext<vbaParser::BlockContext>(0);
}


size_t vbaParser::FunctionStmtContext::getRuleIndex() const {
  return vbaParser::RuleFunctionStmt;
}

void vbaParser::FunctionStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionStmt(this);
}

void vbaParser::FunctionStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionStmt(this);
}

vbaParser::FunctionStmtContext* vbaParser::functionStmt() {
  FunctionStmtContext *_localctx = _tracker.createInstance<FunctionStmtContext>(_ctx, getState());
  enterRule(_localctx, 74, vbaParser::RuleFunctionStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(911);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 75) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 75)) & 4755801206503243793) != 0)) {
      setState(908);
      visibility();
      setState(909);
      match(vbaParser::WS);
    }
    setState(915);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::STATIC) {
      setState(913);
      match(vbaParser::STATIC);
      setState(914);
      match(vbaParser::WS);
    }
    setState(917);
    match(vbaParser::FUNCTION);
    setState(919);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(918);
      match(vbaParser::WS);
    }
    setState(921);
    ambiguousIdentifier();
    setState(923);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx)) {
    case 1: {
      setState(922);
      typeHint();
      break;
    }

    default:
      break;
    }
    setState(929);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx)) {
    case 1: {
      setState(926);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(925);
        match(vbaParser::WS);
      }
      setState(928);
      argList();
      break;
    }

    default:
      break;
    }
    setState(935);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx)) {
    case 1: {
      setState(932);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(931);
        match(vbaParser::WS);
      }
      setState(934);
      asTypeClause();
      break;
    }

    default:
      break;
    }
    setState(937);
    endOfStatement();
    setState(939);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4593671619917906384) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -8646926918232309761) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 288230376151678495) != 0) || _la == vbaParser::LINE_CONTINUATION

    || _la == vbaParser::IDENTIFIER) {
      setState(938);
      block();
    }
    setState(941);
    match(vbaParser::END_FUNCTION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GetStmtContext ------------------------------------------------------------------

vbaParser::GetStmtContext::GetStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::GetStmtContext::GET() {
  return getToken(vbaParser::GET, 0);
}

std::vector<tree::TerminalNode *> vbaParser::GetStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::GetStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::FileNumberContext* vbaParser::GetStmtContext::fileNumber() {
  return getRuleContext<vbaParser::FileNumberContext>(0);
}

std::vector<vbaParser::ValueStmtContext *> vbaParser::GetStmtContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::GetStmtContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}


size_t vbaParser::GetStmtContext::getRuleIndex() const {
  return vbaParser::RuleGetStmt;
}

void vbaParser::GetStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGetStmt(this);
}

void vbaParser::GetStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGetStmt(this);
}

vbaParser::GetStmtContext* vbaParser::getStmt() {
  GetStmtContext *_localctx = _tracker.createInstance<GetStmtContext>(_ctx, getState());
  enterRule(_localctx, 76, vbaParser::RuleGetStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(943);
    match(vbaParser::GET);
    setState(944);
    match(vbaParser::WS);
    setState(945);
    fileNumber();
    setState(947);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(946);
      match(vbaParser::WS);
    }
    setState(949);
    match(vbaParser::T__0);
    setState(951);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 105, _ctx)) {
    case 1: {
      setState(950);
      match(vbaParser::WS);
      break;
    }

    default:
      break;
    }
    setState(954);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4593671619917906384) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -8755014975736513009) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 288230376151678495) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & 135262277) != 0)) {
      setState(953);
      valueStmt(0);
    }
    setState(957);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(956);
      match(vbaParser::WS);
    }
    setState(959);
    match(vbaParser::T__0);
    setState(961);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(960);
      match(vbaParser::WS);
    }
    setState(963);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GoSubStmtContext ------------------------------------------------------------------

vbaParser::GoSubStmtContext::GoSubStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::GoSubStmtContext::GOSUB() {
  return getToken(vbaParser::GOSUB, 0);
}

tree::TerminalNode* vbaParser::GoSubStmtContext::WS() {
  return getToken(vbaParser::WS, 0);
}

vbaParser::ValueStmtContext* vbaParser::GoSubStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}


size_t vbaParser::GoSubStmtContext::getRuleIndex() const {
  return vbaParser::RuleGoSubStmt;
}

void vbaParser::GoSubStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGoSubStmt(this);
}

void vbaParser::GoSubStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGoSubStmt(this);
}

vbaParser::GoSubStmtContext* vbaParser::goSubStmt() {
  GoSubStmtContext *_localctx = _tracker.createInstance<GoSubStmtContext>(_ctx, getState());
  enterRule(_localctx, 78, vbaParser::RuleGoSubStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(965);
    match(vbaParser::GOSUB);
    setState(966);
    match(vbaParser::WS);
    setState(967);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GoToStmtContext ------------------------------------------------------------------

vbaParser::GoToStmtContext::GoToStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::GoToStmtContext::GOTO() {
  return getToken(vbaParser::GOTO, 0);
}

tree::TerminalNode* vbaParser::GoToStmtContext::WS() {
  return getToken(vbaParser::WS, 0);
}

vbaParser::ValueStmtContext* vbaParser::GoToStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}


size_t vbaParser::GoToStmtContext::getRuleIndex() const {
  return vbaParser::RuleGoToStmt;
}

void vbaParser::GoToStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGoToStmt(this);
}

void vbaParser::GoToStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGoToStmt(this);
}

vbaParser::GoToStmtContext* vbaParser::goToStmt() {
  GoToStmtContext *_localctx = _tracker.createInstance<GoToStmtContext>(_ctx, getState());
  enterRule(_localctx, 80, vbaParser::RuleGoToStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(969);
    match(vbaParser::GOTO);
    setState(970);
    match(vbaParser::WS);
    setState(971);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfThenElseStmtContext ------------------------------------------------------------------

vbaParser::IfThenElseStmtContext::IfThenElseStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t vbaParser::IfThenElseStmtContext::getRuleIndex() const {
  return vbaParser::RuleIfThenElseStmt;
}

void vbaParser::IfThenElseStmtContext::copyFrom(IfThenElseStmtContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- BlockIfThenElseContext ------------------------------------------------------------------

vbaParser::IfBlockStmtContext* vbaParser::BlockIfThenElseContext::ifBlockStmt() {
  return getRuleContext<vbaParser::IfBlockStmtContext>(0);
}

tree::TerminalNode* vbaParser::BlockIfThenElseContext::END_IF() {
  return getToken(vbaParser::END_IF, 0);
}

std::vector<vbaParser::IfElseIfBlockStmtContext *> vbaParser::BlockIfThenElseContext::ifElseIfBlockStmt() {
  return getRuleContexts<vbaParser::IfElseIfBlockStmtContext>();
}

vbaParser::IfElseIfBlockStmtContext* vbaParser::BlockIfThenElseContext::ifElseIfBlockStmt(size_t i) {
  return getRuleContext<vbaParser::IfElseIfBlockStmtContext>(i);
}

vbaParser::IfElseBlockStmtContext* vbaParser::BlockIfThenElseContext::ifElseBlockStmt() {
  return getRuleContext<vbaParser::IfElseBlockStmtContext>(0);
}

vbaParser::BlockIfThenElseContext::BlockIfThenElseContext(IfThenElseStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::BlockIfThenElseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlockIfThenElse(this);
}
void vbaParser::BlockIfThenElseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlockIfThenElse(this);
}
//----------------- InlineIfThenElseContext ------------------------------------------------------------------

tree::TerminalNode* vbaParser::InlineIfThenElseContext::IF() {
  return getToken(vbaParser::IF, 0);
}

std::vector<tree::TerminalNode *> vbaParser::InlineIfThenElseContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::InlineIfThenElseContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::IfConditionStmtContext* vbaParser::InlineIfThenElseContext::ifConditionStmt() {
  return getRuleContext<vbaParser::IfConditionStmtContext>(0);
}

tree::TerminalNode* vbaParser::InlineIfThenElseContext::THEN() {
  return getToken(vbaParser::THEN, 0);
}

std::vector<vbaParser::BlockStmtContext *> vbaParser::InlineIfThenElseContext::blockStmt() {
  return getRuleContexts<vbaParser::BlockStmtContext>();
}

vbaParser::BlockStmtContext* vbaParser::InlineIfThenElseContext::blockStmt(size_t i) {
  return getRuleContext<vbaParser::BlockStmtContext>(i);
}

tree::TerminalNode* vbaParser::InlineIfThenElseContext::ELSE() {
  return getToken(vbaParser::ELSE, 0);
}

vbaParser::InlineIfThenElseContext::InlineIfThenElseContext(IfThenElseStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::InlineIfThenElseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInlineIfThenElse(this);
}
void vbaParser::InlineIfThenElseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInlineIfThenElse(this);
}
vbaParser::IfThenElseStmtContext* vbaParser::ifThenElseStmt() {
  IfThenElseStmtContext *_localctx = _tracker.createInstance<IfThenElseStmtContext>(_ctx, getState());
  enterRule(_localctx, 82, vbaParser::RuleIfThenElseStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(998);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 112, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<vbaParser::InlineIfThenElseContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(973);
      match(vbaParser::IF);
      setState(974);
      match(vbaParser::WS);
      setState(975);
      ifConditionStmt();
      setState(976);
      match(vbaParser::WS);
      setState(977);
      match(vbaParser::THEN);
      setState(978);
      match(vbaParser::WS);
      setState(979);
      blockStmt();
      setState(984);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx)) {
      case 1: {
        setState(980);
        match(vbaParser::WS);
        setState(981);
        match(vbaParser::ELSE);
        setState(982);
        match(vbaParser::WS);
        setState(983);
        blockStmt();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<vbaParser::BlockIfThenElseContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(986);
      ifBlockStmt();
      setState(990);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == vbaParser::ELSEIF) {
        setState(987);
        ifElseIfBlockStmt();
        setState(992);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(994);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::ELSE) {
        setState(993);
        ifElseBlockStmt();
      }
      setState(996);
      match(vbaParser::END_IF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfBlockStmtContext ------------------------------------------------------------------

vbaParser::IfBlockStmtContext::IfBlockStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::IfBlockStmtContext::IF() {
  return getToken(vbaParser::IF, 0);
}

std::vector<tree::TerminalNode *> vbaParser::IfBlockStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::IfBlockStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::IfConditionStmtContext* vbaParser::IfBlockStmtContext::ifConditionStmt() {
  return getRuleContext<vbaParser::IfConditionStmtContext>(0);
}

tree::TerminalNode* vbaParser::IfBlockStmtContext::THEN() {
  return getToken(vbaParser::THEN, 0);
}

vbaParser::EndOfStatementContext* vbaParser::IfBlockStmtContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

vbaParser::BlockContext* vbaParser::IfBlockStmtContext::block() {
  return getRuleContext<vbaParser::BlockContext>(0);
}


size_t vbaParser::IfBlockStmtContext::getRuleIndex() const {
  return vbaParser::RuleIfBlockStmt;
}

void vbaParser::IfBlockStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfBlockStmt(this);
}

void vbaParser::IfBlockStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfBlockStmt(this);
}

vbaParser::IfBlockStmtContext* vbaParser::ifBlockStmt() {
  IfBlockStmtContext *_localctx = _tracker.createInstance<IfBlockStmtContext>(_ctx, getState());
  enterRule(_localctx, 84, vbaParser::RuleIfBlockStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1000);
    match(vbaParser::IF);
    setState(1001);
    match(vbaParser::WS);
    setState(1002);
    ifConditionStmt();
    setState(1003);
    match(vbaParser::WS);
    setState(1004);
    match(vbaParser::THEN);
    setState(1005);
    endOfStatement();
    setState(1007);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx)) {
    case 1: {
      setState(1006);
      block();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfConditionStmtContext ------------------------------------------------------------------

vbaParser::IfConditionStmtContext::IfConditionStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::ValueStmtContext* vbaParser::IfConditionStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}


size_t vbaParser::IfConditionStmtContext::getRuleIndex() const {
  return vbaParser::RuleIfConditionStmt;
}

void vbaParser::IfConditionStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfConditionStmt(this);
}

void vbaParser::IfConditionStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfConditionStmt(this);
}

vbaParser::IfConditionStmtContext* vbaParser::ifConditionStmt() {
  IfConditionStmtContext *_localctx = _tracker.createInstance<IfConditionStmtContext>(_ctx, getState());
  enterRule(_localctx, 86, vbaParser::RuleIfConditionStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1009);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfElseIfBlockStmtContext ------------------------------------------------------------------

vbaParser::IfElseIfBlockStmtContext::IfElseIfBlockStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::IfElseIfBlockStmtContext::ELSEIF() {
  return getToken(vbaParser::ELSEIF, 0);
}

std::vector<tree::TerminalNode *> vbaParser::IfElseIfBlockStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::IfElseIfBlockStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::IfConditionStmtContext* vbaParser::IfElseIfBlockStmtContext::ifConditionStmt() {
  return getRuleContext<vbaParser::IfConditionStmtContext>(0);
}

tree::TerminalNode* vbaParser::IfElseIfBlockStmtContext::THEN() {
  return getToken(vbaParser::THEN, 0);
}

vbaParser::EndOfStatementContext* vbaParser::IfElseIfBlockStmtContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

vbaParser::BlockContext* vbaParser::IfElseIfBlockStmtContext::block() {
  return getRuleContext<vbaParser::BlockContext>(0);
}


size_t vbaParser::IfElseIfBlockStmtContext::getRuleIndex() const {
  return vbaParser::RuleIfElseIfBlockStmt;
}

void vbaParser::IfElseIfBlockStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfElseIfBlockStmt(this);
}

void vbaParser::IfElseIfBlockStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfElseIfBlockStmt(this);
}

vbaParser::IfElseIfBlockStmtContext* vbaParser::ifElseIfBlockStmt() {
  IfElseIfBlockStmtContext *_localctx = _tracker.createInstance<IfElseIfBlockStmtContext>(_ctx, getState());
  enterRule(_localctx, 88, vbaParser::RuleIfElseIfBlockStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1011);
    match(vbaParser::ELSEIF);
    setState(1012);
    match(vbaParser::WS);
    setState(1013);
    ifConditionStmt();
    setState(1014);
    match(vbaParser::WS);
    setState(1015);
    match(vbaParser::THEN);
    setState(1016);
    endOfStatement();
    setState(1018);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx)) {
    case 1: {
      setState(1017);
      block();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfElseBlockStmtContext ------------------------------------------------------------------

vbaParser::IfElseBlockStmtContext::IfElseBlockStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::IfElseBlockStmtContext::ELSE() {
  return getToken(vbaParser::ELSE, 0);
}

vbaParser::EndOfStatementContext* vbaParser::IfElseBlockStmtContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

vbaParser::BlockContext* vbaParser::IfElseBlockStmtContext::block() {
  return getRuleContext<vbaParser::BlockContext>(0);
}


size_t vbaParser::IfElseBlockStmtContext::getRuleIndex() const {
  return vbaParser::RuleIfElseBlockStmt;
}

void vbaParser::IfElseBlockStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfElseBlockStmt(this);
}

void vbaParser::IfElseBlockStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfElseBlockStmt(this);
}

vbaParser::IfElseBlockStmtContext* vbaParser::ifElseBlockStmt() {
  IfElseBlockStmtContext *_localctx = _tracker.createInstance<IfElseBlockStmtContext>(_ctx, getState());
  enterRule(_localctx, 90, vbaParser::RuleIfElseBlockStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1020);
    match(vbaParser::ELSE);
    setState(1021);
    endOfStatement();
    setState(1023);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4593671619917906384) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -8646926918232309761) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 288230376151678495) != 0) || _la == vbaParser::LINE_CONTINUATION

    || _la == vbaParser::IDENTIFIER) {
      setState(1022);
      block();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImplementsStmtContext ------------------------------------------------------------------

vbaParser::ImplementsStmtContext::ImplementsStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::ImplementsStmtContext::IMPLEMENTS() {
  return getToken(vbaParser::IMPLEMENTS, 0);
}

tree::TerminalNode* vbaParser::ImplementsStmtContext::WS() {
  return getToken(vbaParser::WS, 0);
}

vbaParser::AmbiguousIdentifierContext* vbaParser::ImplementsStmtContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}


size_t vbaParser::ImplementsStmtContext::getRuleIndex() const {
  return vbaParser::RuleImplementsStmt;
}

void vbaParser::ImplementsStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImplementsStmt(this);
}

void vbaParser::ImplementsStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImplementsStmt(this);
}

vbaParser::ImplementsStmtContext* vbaParser::implementsStmt() {
  ImplementsStmtContext *_localctx = _tracker.createInstance<ImplementsStmtContext>(_ctx, getState());
  enterRule(_localctx, 92, vbaParser::RuleImplementsStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1025);
    match(vbaParser::IMPLEMENTS);
    setState(1026);
    match(vbaParser::WS);
    setState(1027);
    ambiguousIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InputStmtContext ------------------------------------------------------------------

vbaParser::InputStmtContext::InputStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::InputStmtContext::INPUT() {
  return getToken(vbaParser::INPUT, 0);
}

std::vector<tree::TerminalNode *> vbaParser::InputStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::InputStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::FileNumberContext* vbaParser::InputStmtContext::fileNumber() {
  return getRuleContext<vbaParser::FileNumberContext>(0);
}

std::vector<vbaParser::ValueStmtContext *> vbaParser::InputStmtContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::InputStmtContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}


size_t vbaParser::InputStmtContext::getRuleIndex() const {
  return vbaParser::RuleInputStmt;
}

void vbaParser::InputStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInputStmt(this);
}

void vbaParser::InputStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInputStmt(this);
}

vbaParser::InputStmtContext* vbaParser::inputStmt() {
  InputStmtContext *_localctx = _tracker.createInstance<InputStmtContext>(_ctx, getState());
  enterRule(_localctx, 94, vbaParser::RuleInputStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1029);
    match(vbaParser::INPUT);
    setState(1030);
    match(vbaParser::WS);
    setState(1031);
    fileNumber();
    setState(1040); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1033);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == vbaParser::WS) {
                setState(1032);
                match(vbaParser::WS);
              }
              setState(1035);
              match(vbaParser::T__0);
              setState(1037);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == vbaParser::WS) {
                setState(1036);
                match(vbaParser::WS);
              }
              setState(1039);
              valueStmt(0);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1042); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KillStmtContext ------------------------------------------------------------------

vbaParser::KillStmtContext::KillStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::KillStmtContext::KILL() {
  return getToken(vbaParser::KILL, 0);
}

tree::TerminalNode* vbaParser::KillStmtContext::WS() {
  return getToken(vbaParser::WS, 0);
}

vbaParser::ValueStmtContext* vbaParser::KillStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}


size_t vbaParser::KillStmtContext::getRuleIndex() const {
  return vbaParser::RuleKillStmt;
}

void vbaParser::KillStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKillStmt(this);
}

void vbaParser::KillStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKillStmt(this);
}

vbaParser::KillStmtContext* vbaParser::killStmt() {
  KillStmtContext *_localctx = _tracker.createInstance<KillStmtContext>(_ctx, getState());
  enterRule(_localctx, 96, vbaParser::RuleKillStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1044);
    match(vbaParser::KILL);
    setState(1045);
    match(vbaParser::WS);
    setState(1046);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LetStmtContext ------------------------------------------------------------------

vbaParser::LetStmtContext::LetStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::ImplicitCallStmt_InStmtContext* vbaParser::LetStmtContext::implicitCallStmt_InStmt() {
  return getRuleContext<vbaParser::ImplicitCallStmt_InStmtContext>(0);
}

vbaParser::ValueStmtContext* vbaParser::LetStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

tree::TerminalNode* vbaParser::LetStmtContext::EQ() {
  return getToken(vbaParser::EQ, 0);
}

tree::TerminalNode* vbaParser::LetStmtContext::PLUS_EQ() {
  return getToken(vbaParser::PLUS_EQ, 0);
}

tree::TerminalNode* vbaParser::LetStmtContext::MINUS_EQ() {
  return getToken(vbaParser::MINUS_EQ, 0);
}

tree::TerminalNode* vbaParser::LetStmtContext::LET() {
  return getToken(vbaParser::LET, 0);
}

std::vector<tree::TerminalNode *> vbaParser::LetStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::LetStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}


size_t vbaParser::LetStmtContext::getRuleIndex() const {
  return vbaParser::RuleLetStmt;
}

void vbaParser::LetStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLetStmt(this);
}

void vbaParser::LetStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLetStmt(this);
}

vbaParser::LetStmtContext* vbaParser::letStmt() {
  LetStmtContext *_localctx = _tracker.createInstance<LetStmtContext>(_ctx, getState());
  enterRule(_localctx, 98, vbaParser::RuleLetStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1050);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 119, _ctx)) {
    case 1: {
      setState(1048);
      match(vbaParser::LET);
      setState(1049);
      match(vbaParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1052);
    implicitCallStmt_InStmt();
    setState(1054);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1053);
      match(vbaParser::WS);
    }
    setState(1056);
    _la = _input->LA(1);
    if (!(((((_la - 189) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 189)) & 2177) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1058);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1057);
      match(vbaParser::WS);
    }
    setState(1060);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LineInputStmtContext ------------------------------------------------------------------

vbaParser::LineInputStmtContext::LineInputStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::LineInputStmtContext::LINE_INPUT() {
  return getToken(vbaParser::LINE_INPUT, 0);
}

std::vector<tree::TerminalNode *> vbaParser::LineInputStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::LineInputStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::FileNumberContext* vbaParser::LineInputStmtContext::fileNumber() {
  return getRuleContext<vbaParser::FileNumberContext>(0);
}

vbaParser::ValueStmtContext* vbaParser::LineInputStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}


size_t vbaParser::LineInputStmtContext::getRuleIndex() const {
  return vbaParser::RuleLineInputStmt;
}

void vbaParser::LineInputStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLineInputStmt(this);
}

void vbaParser::LineInputStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLineInputStmt(this);
}

vbaParser::LineInputStmtContext* vbaParser::lineInputStmt() {
  LineInputStmtContext *_localctx = _tracker.createInstance<LineInputStmtContext>(_ctx, getState());
  enterRule(_localctx, 100, vbaParser::RuleLineInputStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1062);
    match(vbaParser::LINE_INPUT);
    setState(1063);
    match(vbaParser::WS);
    setState(1064);
    fileNumber();
    setState(1066);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1065);
      match(vbaParser::WS);
    }
    setState(1068);
    match(vbaParser::T__0);
    setState(1070);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1069);
      match(vbaParser::WS);
    }
    setState(1072);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadStmtContext ------------------------------------------------------------------

vbaParser::LoadStmtContext::LoadStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::LoadStmtContext::LOAD() {
  return getToken(vbaParser::LOAD, 0);
}

tree::TerminalNode* vbaParser::LoadStmtContext::WS() {
  return getToken(vbaParser::WS, 0);
}

vbaParser::ValueStmtContext* vbaParser::LoadStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}


size_t vbaParser::LoadStmtContext::getRuleIndex() const {
  return vbaParser::RuleLoadStmt;
}

void vbaParser::LoadStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoadStmt(this);
}

void vbaParser::LoadStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoadStmt(this);
}

vbaParser::LoadStmtContext* vbaParser::loadStmt() {
  LoadStmtContext *_localctx = _tracker.createInstance<LoadStmtContext>(_ctx, getState());
  enterRule(_localctx, 102, vbaParser::RuleLoadStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1074);
    match(vbaParser::LOAD);
    setState(1075);
    match(vbaParser::WS);
    setState(1076);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockStmtContext ------------------------------------------------------------------

vbaParser::LockStmtContext::LockStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::LockStmtContext::LOCK() {
  return getToken(vbaParser::LOCK, 0);
}

std::vector<tree::TerminalNode *> vbaParser::LockStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::LockStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

std::vector<vbaParser::ValueStmtContext *> vbaParser::LockStmtContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::LockStmtContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

tree::TerminalNode* vbaParser::LockStmtContext::TO() {
  return getToken(vbaParser::TO, 0);
}


size_t vbaParser::LockStmtContext::getRuleIndex() const {
  return vbaParser::RuleLockStmt;
}

void vbaParser::LockStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockStmt(this);
}

void vbaParser::LockStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockStmt(this);
}

vbaParser::LockStmtContext* vbaParser::lockStmt() {
  LockStmtContext *_localctx = _tracker.createInstance<LockStmtContext>(_ctx, getState());
  enterRule(_localctx, 104, vbaParser::RuleLockStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1078);
    match(vbaParser::LOCK);
    setState(1079);
    match(vbaParser::WS);
    setState(1080);
    valueStmt(0);
    setState(1095);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx)) {
    case 1: {
      setState(1082);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1081);
        match(vbaParser::WS);
      }
      setState(1084);
      match(vbaParser::T__0);
      setState(1086);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1085);
        match(vbaParser::WS);
      }
      setState(1088);
      valueStmt(0);
      setState(1093);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx)) {
      case 1: {
        setState(1089);
        match(vbaParser::WS);
        setState(1090);
        match(vbaParser::TO);
        setState(1091);
        match(vbaParser::WS);
        setState(1092);
        valueStmt(0);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LsetStmtContext ------------------------------------------------------------------

vbaParser::LsetStmtContext::LsetStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::LsetStmtContext::LSET() {
  return getToken(vbaParser::LSET, 0);
}

std::vector<tree::TerminalNode *> vbaParser::LsetStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::LsetStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::ImplicitCallStmt_InStmtContext* vbaParser::LsetStmtContext::implicitCallStmt_InStmt() {
  return getRuleContext<vbaParser::ImplicitCallStmt_InStmtContext>(0);
}

tree::TerminalNode* vbaParser::LsetStmtContext::EQ() {
  return getToken(vbaParser::EQ, 0);
}

vbaParser::ValueStmtContext* vbaParser::LsetStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}


size_t vbaParser::LsetStmtContext::getRuleIndex() const {
  return vbaParser::RuleLsetStmt;
}

void vbaParser::LsetStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLsetStmt(this);
}

void vbaParser::LsetStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLsetStmt(this);
}

vbaParser::LsetStmtContext* vbaParser::lsetStmt() {
  LsetStmtContext *_localctx = _tracker.createInstance<LsetStmtContext>(_ctx, getState());
  enterRule(_localctx, 106, vbaParser::RuleLsetStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1097);
    match(vbaParser::LSET);
    setState(1098);
    match(vbaParser::WS);
    setState(1099);
    implicitCallStmt_InStmt();
    setState(1101);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1100);
      match(vbaParser::WS);
    }
    setState(1103);
    match(vbaParser::EQ);
    setState(1105);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1104);
      match(vbaParser::WS);
    }
    setState(1107);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MacroConstStmtContext ------------------------------------------------------------------

vbaParser::MacroConstStmtContext::MacroConstStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::MacroConstStmtContext::MACRO_CONST() {
  return getToken(vbaParser::MACRO_CONST, 0);
}

vbaParser::AmbiguousIdentifierContext* vbaParser::MacroConstStmtContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

tree::TerminalNode* vbaParser::MacroConstStmtContext::EQ() {
  return getToken(vbaParser::EQ, 0);
}

vbaParser::ValueStmtContext* vbaParser::MacroConstStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::MacroConstStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::MacroConstStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}


size_t vbaParser::MacroConstStmtContext::getRuleIndex() const {
  return vbaParser::RuleMacroConstStmt;
}

void vbaParser::MacroConstStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMacroConstStmt(this);
}

void vbaParser::MacroConstStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMacroConstStmt(this);
}

vbaParser::MacroConstStmtContext* vbaParser::macroConstStmt() {
  MacroConstStmtContext *_localctx = _tracker.createInstance<MacroConstStmtContext>(_ctx, getState());
  enterRule(_localctx, 108, vbaParser::RuleMacroConstStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1109);
    match(vbaParser::MACRO_CONST);
    setState(1111);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1110);
      match(vbaParser::WS);
    }
    setState(1113);
    ambiguousIdentifier();
    setState(1115);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1114);
      match(vbaParser::WS);
    }
    setState(1117);
    match(vbaParser::EQ);
    setState(1119);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1118);
      match(vbaParser::WS);
    }
    setState(1121);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MacroIfThenElseStmtContext ------------------------------------------------------------------

vbaParser::MacroIfThenElseStmtContext::MacroIfThenElseStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::MacroIfBlockStmtContext* vbaParser::MacroIfThenElseStmtContext::macroIfBlockStmt() {
  return getRuleContext<vbaParser::MacroIfBlockStmtContext>(0);
}

tree::TerminalNode* vbaParser::MacroIfThenElseStmtContext::MACRO_END_IF() {
  return getToken(vbaParser::MACRO_END_IF, 0);
}

std::vector<vbaParser::MacroElseIfBlockStmtContext *> vbaParser::MacroIfThenElseStmtContext::macroElseIfBlockStmt() {
  return getRuleContexts<vbaParser::MacroElseIfBlockStmtContext>();
}

vbaParser::MacroElseIfBlockStmtContext* vbaParser::MacroIfThenElseStmtContext::macroElseIfBlockStmt(size_t i) {
  return getRuleContext<vbaParser::MacroElseIfBlockStmtContext>(i);
}

vbaParser::MacroElseBlockStmtContext* vbaParser::MacroIfThenElseStmtContext::macroElseBlockStmt() {
  return getRuleContext<vbaParser::MacroElseBlockStmtContext>(0);
}


size_t vbaParser::MacroIfThenElseStmtContext::getRuleIndex() const {
  return vbaParser::RuleMacroIfThenElseStmt;
}

void vbaParser::MacroIfThenElseStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMacroIfThenElseStmt(this);
}

void vbaParser::MacroIfThenElseStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMacroIfThenElseStmt(this);
}

vbaParser::MacroIfThenElseStmtContext* vbaParser::macroIfThenElseStmt() {
  MacroIfThenElseStmtContext *_localctx = _tracker.createInstance<MacroIfThenElseStmtContext>(_ctx, getState());
  enterRule(_localctx, 110, vbaParser::RuleMacroIfThenElseStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1123);
    macroIfBlockStmt();
    setState(1127);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == vbaParser::MACRO_ELSEIF) {
      setState(1124);
      macroElseIfBlockStmt();
      setState(1129);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1131);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::MACRO_ELSE) {
      setState(1130);
      macroElseBlockStmt();
    }
    setState(1133);
    match(vbaParser::MACRO_END_IF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MacroIfBlockStmtContext ------------------------------------------------------------------

vbaParser::MacroIfBlockStmtContext::MacroIfBlockStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::MacroIfBlockStmtContext::MACRO_IF() {
  return getToken(vbaParser::MACRO_IF, 0);
}

vbaParser::IfConditionStmtContext* vbaParser::MacroIfBlockStmtContext::ifConditionStmt() {
  return getRuleContext<vbaParser::IfConditionStmtContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::MacroIfBlockStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::MacroIfBlockStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

tree::TerminalNode* vbaParser::MacroIfBlockStmtContext::THEN() {
  return getToken(vbaParser::THEN, 0);
}

vbaParser::EndOfStatementContext* vbaParser::MacroIfBlockStmtContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

std::vector<vbaParser::ModuleDeclarationsContext *> vbaParser::MacroIfBlockStmtContext::moduleDeclarations() {
  return getRuleContexts<vbaParser::ModuleDeclarationsContext>();
}

vbaParser::ModuleDeclarationsContext* vbaParser::MacroIfBlockStmtContext::moduleDeclarations(size_t i) {
  return getRuleContext<vbaParser::ModuleDeclarationsContext>(i);
}

std::vector<vbaParser::ModuleBodyContext *> vbaParser::MacroIfBlockStmtContext::moduleBody() {
  return getRuleContexts<vbaParser::ModuleBodyContext>();
}

vbaParser::ModuleBodyContext* vbaParser::MacroIfBlockStmtContext::moduleBody(size_t i) {
  return getRuleContext<vbaParser::ModuleBodyContext>(i);
}

std::vector<vbaParser::BlockContext *> vbaParser::MacroIfBlockStmtContext::block() {
  return getRuleContexts<vbaParser::BlockContext>();
}

vbaParser::BlockContext* vbaParser::MacroIfBlockStmtContext::block(size_t i) {
  return getRuleContext<vbaParser::BlockContext>(i);
}


size_t vbaParser::MacroIfBlockStmtContext::getRuleIndex() const {
  return vbaParser::RuleMacroIfBlockStmt;
}

void vbaParser::MacroIfBlockStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMacroIfBlockStmt(this);
}

void vbaParser::MacroIfBlockStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMacroIfBlockStmt(this);
}

vbaParser::MacroIfBlockStmtContext* vbaParser::macroIfBlockStmt() {
  MacroIfBlockStmtContext *_localctx = _tracker.createInstance<MacroIfBlockStmtContext>(_ctx, getState());
  enterRule(_localctx, 112, vbaParser::RuleMacroIfBlockStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1135);
    match(vbaParser::MACRO_IF);
    setState(1137);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1136);
      match(vbaParser::WS);
    }
    setState(1139);
    ifConditionStmt();
    setState(1140);
    match(vbaParser::WS);
    setState(1141);
    match(vbaParser::THEN);
    setState(1142);
    endOfStatement();
    setState(1148);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4593671619917906384) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -15633680957441) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 288230376151678719) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & 265) != 0)) {
      setState(1146);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx)) {
      case 1: {
        setState(1143);
        moduleDeclarations();
        break;
      }

      case 2: {
        setState(1144);
        moduleBody();
        break;
      }

      case 3: {
        setState(1145);
        block();
        break;
      }

      default:
        break;
      }
      setState(1150);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MacroElseIfBlockStmtContext ------------------------------------------------------------------

vbaParser::MacroElseIfBlockStmtContext::MacroElseIfBlockStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::MacroElseIfBlockStmtContext::MACRO_ELSEIF() {
  return getToken(vbaParser::MACRO_ELSEIF, 0);
}

vbaParser::IfConditionStmtContext* vbaParser::MacroElseIfBlockStmtContext::ifConditionStmt() {
  return getRuleContext<vbaParser::IfConditionStmtContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::MacroElseIfBlockStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::MacroElseIfBlockStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

tree::TerminalNode* vbaParser::MacroElseIfBlockStmtContext::THEN() {
  return getToken(vbaParser::THEN, 0);
}

vbaParser::EndOfStatementContext* vbaParser::MacroElseIfBlockStmtContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

std::vector<vbaParser::ModuleDeclarationsContext *> vbaParser::MacroElseIfBlockStmtContext::moduleDeclarations() {
  return getRuleContexts<vbaParser::ModuleDeclarationsContext>();
}

vbaParser::ModuleDeclarationsContext* vbaParser::MacroElseIfBlockStmtContext::moduleDeclarations(size_t i) {
  return getRuleContext<vbaParser::ModuleDeclarationsContext>(i);
}

std::vector<vbaParser::ModuleBodyContext *> vbaParser::MacroElseIfBlockStmtContext::moduleBody() {
  return getRuleContexts<vbaParser::ModuleBodyContext>();
}

vbaParser::ModuleBodyContext* vbaParser::MacroElseIfBlockStmtContext::moduleBody(size_t i) {
  return getRuleContext<vbaParser::ModuleBodyContext>(i);
}

std::vector<vbaParser::BlockContext *> vbaParser::MacroElseIfBlockStmtContext::block() {
  return getRuleContexts<vbaParser::BlockContext>();
}

vbaParser::BlockContext* vbaParser::MacroElseIfBlockStmtContext::block(size_t i) {
  return getRuleContext<vbaParser::BlockContext>(i);
}


size_t vbaParser::MacroElseIfBlockStmtContext::getRuleIndex() const {
  return vbaParser::RuleMacroElseIfBlockStmt;
}

void vbaParser::MacroElseIfBlockStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMacroElseIfBlockStmt(this);
}

void vbaParser::MacroElseIfBlockStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMacroElseIfBlockStmt(this);
}

vbaParser::MacroElseIfBlockStmtContext* vbaParser::macroElseIfBlockStmt() {
  MacroElseIfBlockStmtContext *_localctx = _tracker.createInstance<MacroElseIfBlockStmtContext>(_ctx, getState());
  enterRule(_localctx, 114, vbaParser::RuleMacroElseIfBlockStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1151);
    match(vbaParser::MACRO_ELSEIF);
    setState(1153);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1152);
      match(vbaParser::WS);
    }
    setState(1155);
    ifConditionStmt();
    setState(1156);
    match(vbaParser::WS);
    setState(1157);
    match(vbaParser::THEN);
    setState(1158);
    endOfStatement();
    setState(1164);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4593671619917906384) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -15633680957441) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 288230376151678719) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & 265) != 0)) {
      setState(1162);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 139, _ctx)) {
      case 1: {
        setState(1159);
        moduleDeclarations();
        break;
      }

      case 2: {
        setState(1160);
        moduleBody();
        break;
      }

      case 3: {
        setState(1161);
        block();
        break;
      }

      default:
        break;
      }
      setState(1166);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MacroElseBlockStmtContext ------------------------------------------------------------------

vbaParser::MacroElseBlockStmtContext::MacroElseBlockStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::MacroElseBlockStmtContext::MACRO_ELSE() {
  return getToken(vbaParser::MACRO_ELSE, 0);
}

vbaParser::EndOfStatementContext* vbaParser::MacroElseBlockStmtContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

std::vector<vbaParser::ModuleDeclarationsContext *> vbaParser::MacroElseBlockStmtContext::moduleDeclarations() {
  return getRuleContexts<vbaParser::ModuleDeclarationsContext>();
}

vbaParser::ModuleDeclarationsContext* vbaParser::MacroElseBlockStmtContext::moduleDeclarations(size_t i) {
  return getRuleContext<vbaParser::ModuleDeclarationsContext>(i);
}

std::vector<vbaParser::ModuleBodyContext *> vbaParser::MacroElseBlockStmtContext::moduleBody() {
  return getRuleContexts<vbaParser::ModuleBodyContext>();
}

vbaParser::ModuleBodyContext* vbaParser::MacroElseBlockStmtContext::moduleBody(size_t i) {
  return getRuleContext<vbaParser::ModuleBodyContext>(i);
}

std::vector<vbaParser::BlockContext *> vbaParser::MacroElseBlockStmtContext::block() {
  return getRuleContexts<vbaParser::BlockContext>();
}

vbaParser::BlockContext* vbaParser::MacroElseBlockStmtContext::block(size_t i) {
  return getRuleContext<vbaParser::BlockContext>(i);
}


size_t vbaParser::MacroElseBlockStmtContext::getRuleIndex() const {
  return vbaParser::RuleMacroElseBlockStmt;
}

void vbaParser::MacroElseBlockStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMacroElseBlockStmt(this);
}

void vbaParser::MacroElseBlockStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMacroElseBlockStmt(this);
}

vbaParser::MacroElseBlockStmtContext* vbaParser::macroElseBlockStmt() {
  MacroElseBlockStmtContext *_localctx = _tracker.createInstance<MacroElseBlockStmtContext>(_ctx, getState());
  enterRule(_localctx, 116, vbaParser::RuleMacroElseBlockStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1167);
    match(vbaParser::MACRO_ELSE);
    setState(1168);
    endOfStatement();
    setState(1174);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4593671619917906384) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -15633680957441) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 288230376151678719) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & 265) != 0)) {
      setState(1172);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx)) {
      case 1: {
        setState(1169);
        moduleDeclarations();
        break;
      }

      case 2: {
        setState(1170);
        moduleBody();
        break;
      }

      case 3: {
        setState(1171);
        block();
        break;
      }

      default:
        break;
      }
      setState(1176);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MidStmtContext ------------------------------------------------------------------

vbaParser::MidStmtContext::MidStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::MidStmtContext::MID() {
  return getToken(vbaParser::MID, 0);
}

tree::TerminalNode* vbaParser::MidStmtContext::LPAREN() {
  return getToken(vbaParser::LPAREN, 0);
}

vbaParser::ArgsCallContext* vbaParser::MidStmtContext::argsCall() {
  return getRuleContext<vbaParser::ArgsCallContext>(0);
}

tree::TerminalNode* vbaParser::MidStmtContext::RPAREN() {
  return getToken(vbaParser::RPAREN, 0);
}

std::vector<tree::TerminalNode *> vbaParser::MidStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::MidStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}


size_t vbaParser::MidStmtContext::getRuleIndex() const {
  return vbaParser::RuleMidStmt;
}

void vbaParser::MidStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMidStmt(this);
}

void vbaParser::MidStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMidStmt(this);
}

vbaParser::MidStmtContext* vbaParser::midStmt() {
  MidStmtContext *_localctx = _tracker.createInstance<MidStmtContext>(_ctx, getState());
  enterRule(_localctx, 118, vbaParser::RuleMidStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1177);
    match(vbaParser::MID);
    setState(1179);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1178);
      match(vbaParser::WS);
    }
    setState(1181);
    match(vbaParser::LPAREN);
    setState(1183);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx)) {
    case 1: {
      setState(1182);
      match(vbaParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1185);
    argsCall();
    setState(1187);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1186);
      match(vbaParser::WS);
    }
    setState(1189);
    match(vbaParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MkdirStmtContext ------------------------------------------------------------------

vbaParser::MkdirStmtContext::MkdirStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::MkdirStmtContext::MKDIR() {
  return getToken(vbaParser::MKDIR, 0);
}

tree::TerminalNode* vbaParser::MkdirStmtContext::WS() {
  return getToken(vbaParser::WS, 0);
}

vbaParser::ValueStmtContext* vbaParser::MkdirStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}


size_t vbaParser::MkdirStmtContext::getRuleIndex() const {
  return vbaParser::RuleMkdirStmt;
}

void vbaParser::MkdirStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMkdirStmt(this);
}

void vbaParser::MkdirStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMkdirStmt(this);
}

vbaParser::MkdirStmtContext* vbaParser::mkdirStmt() {
  MkdirStmtContext *_localctx = _tracker.createInstance<MkdirStmtContext>(_ctx, getState());
  enterRule(_localctx, 120, vbaParser::RuleMkdirStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1191);
    match(vbaParser::MKDIR);
    setState(1192);
    match(vbaParser::WS);
    setState(1193);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameStmtContext ------------------------------------------------------------------

vbaParser::NameStmtContext::NameStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::NameStmtContext::NAME() {
  return getToken(vbaParser::NAME, 0);
}

std::vector<tree::TerminalNode *> vbaParser::NameStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::NameStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

std::vector<vbaParser::ValueStmtContext *> vbaParser::NameStmtContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::NameStmtContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

tree::TerminalNode* vbaParser::NameStmtContext::AS() {
  return getToken(vbaParser::AS, 0);
}


size_t vbaParser::NameStmtContext::getRuleIndex() const {
  return vbaParser::RuleNameStmt;
}

void vbaParser::NameStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNameStmt(this);
}

void vbaParser::NameStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNameStmt(this);
}

vbaParser::NameStmtContext* vbaParser::nameStmt() {
  NameStmtContext *_localctx = _tracker.createInstance<NameStmtContext>(_ctx, getState());
  enterRule(_localctx, 122, vbaParser::RuleNameStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1195);
    match(vbaParser::NAME);
    setState(1196);
    match(vbaParser::WS);
    setState(1197);
    valueStmt(0);
    setState(1198);
    match(vbaParser::WS);
    setState(1199);
    match(vbaParser::AS);
    setState(1200);
    match(vbaParser::WS);
    setState(1201);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnErrorStmtContext ------------------------------------------------------------------

vbaParser::OnErrorStmtContext::OnErrorStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> vbaParser::OnErrorStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::OnErrorStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

tree::TerminalNode* vbaParser::OnErrorStmtContext::ON_ERROR() {
  return getToken(vbaParser::ON_ERROR, 0);
}

tree::TerminalNode* vbaParser::OnErrorStmtContext::ON_LOCAL_ERROR() {
  return getToken(vbaParser::ON_LOCAL_ERROR, 0);
}

tree::TerminalNode* vbaParser::OnErrorStmtContext::GOTO() {
  return getToken(vbaParser::GOTO, 0);
}

vbaParser::ValueStmtContext* vbaParser::OnErrorStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

tree::TerminalNode* vbaParser::OnErrorStmtContext::RESUME() {
  return getToken(vbaParser::RESUME, 0);
}

tree::TerminalNode* vbaParser::OnErrorStmtContext::NEXT() {
  return getToken(vbaParser::NEXT, 0);
}


size_t vbaParser::OnErrorStmtContext::getRuleIndex() const {
  return vbaParser::RuleOnErrorStmt;
}

void vbaParser::OnErrorStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnErrorStmt(this);
}

void vbaParser::OnErrorStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnErrorStmt(this);
}

vbaParser::OnErrorStmtContext* vbaParser::onErrorStmt() {
  OnErrorStmtContext *_localctx = _tracker.createInstance<OnErrorStmtContext>(_ctx, getState());
  enterRule(_localctx, 124, vbaParser::RuleOnErrorStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1203);
    _la = _input->LA(1);
    if (!(_la == vbaParser::ON_ERROR

    || _la == vbaParser::ON_LOCAL_ERROR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1204);
    match(vbaParser::WS);
    setState(1211);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case vbaParser::GOTO: {
        setState(1205);
        match(vbaParser::GOTO);
        setState(1206);
        match(vbaParser::WS);
        setState(1207);
        valueStmt(0);
        break;
      }

      case vbaParser::RESUME: {
        setState(1208);
        match(vbaParser::RESUME);
        setState(1209);
        match(vbaParser::WS);
        setState(1210);
        match(vbaParser::NEXT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnGoToStmtContext ------------------------------------------------------------------

vbaParser::OnGoToStmtContext::OnGoToStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::OnGoToStmtContext::ON() {
  return getToken(vbaParser::ON, 0);
}

std::vector<tree::TerminalNode *> vbaParser::OnGoToStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::OnGoToStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

std::vector<vbaParser::ValueStmtContext *> vbaParser::OnGoToStmtContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::OnGoToStmtContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

tree::TerminalNode* vbaParser::OnGoToStmtContext::GOTO() {
  return getToken(vbaParser::GOTO, 0);
}


size_t vbaParser::OnGoToStmtContext::getRuleIndex() const {
  return vbaParser::RuleOnGoToStmt;
}

void vbaParser::OnGoToStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnGoToStmt(this);
}

void vbaParser::OnGoToStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnGoToStmt(this);
}

vbaParser::OnGoToStmtContext* vbaParser::onGoToStmt() {
  OnGoToStmtContext *_localctx = _tracker.createInstance<OnGoToStmtContext>(_ctx, getState());
  enterRule(_localctx, 126, vbaParser::RuleOnGoToStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1213);
    match(vbaParser::ON);
    setState(1214);
    match(vbaParser::WS);
    setState(1215);
    valueStmt(0);
    setState(1216);
    match(vbaParser::WS);
    setState(1217);
    match(vbaParser::GOTO);
    setState(1218);
    match(vbaParser::WS);
    setState(1219);
    valueStmt(0);
    setState(1230);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 149, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1221);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(1220);
          match(vbaParser::WS);
        }
        setState(1223);
        match(vbaParser::T__0);
        setState(1225);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(1224);
          match(vbaParser::WS);
        }
        setState(1227);
        valueStmt(0); 
      }
      setState(1232);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 149, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnGoSubStmtContext ------------------------------------------------------------------

vbaParser::OnGoSubStmtContext::OnGoSubStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::OnGoSubStmtContext::ON() {
  return getToken(vbaParser::ON, 0);
}

std::vector<tree::TerminalNode *> vbaParser::OnGoSubStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::OnGoSubStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

std::vector<vbaParser::ValueStmtContext *> vbaParser::OnGoSubStmtContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::OnGoSubStmtContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

tree::TerminalNode* vbaParser::OnGoSubStmtContext::GOSUB() {
  return getToken(vbaParser::GOSUB, 0);
}


size_t vbaParser::OnGoSubStmtContext::getRuleIndex() const {
  return vbaParser::RuleOnGoSubStmt;
}

void vbaParser::OnGoSubStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnGoSubStmt(this);
}

void vbaParser::OnGoSubStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnGoSubStmt(this);
}

vbaParser::OnGoSubStmtContext* vbaParser::onGoSubStmt() {
  OnGoSubStmtContext *_localctx = _tracker.createInstance<OnGoSubStmtContext>(_ctx, getState());
  enterRule(_localctx, 128, vbaParser::RuleOnGoSubStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1233);
    match(vbaParser::ON);
    setState(1234);
    match(vbaParser::WS);
    setState(1235);
    valueStmt(0);
    setState(1236);
    match(vbaParser::WS);
    setState(1237);
    match(vbaParser::GOSUB);
    setState(1238);
    match(vbaParser::WS);
    setState(1239);
    valueStmt(0);
    setState(1250);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 152, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1241);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(1240);
          match(vbaParser::WS);
        }
        setState(1243);
        match(vbaParser::T__0);
        setState(1245);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(1244);
          match(vbaParser::WS);
        }
        setState(1247);
        valueStmt(0); 
      }
      setState(1252);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 152, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OpenStmtContext ------------------------------------------------------------------

vbaParser::OpenStmtContext::OpenStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::OpenStmtContext::OPEN() {
  return getToken(vbaParser::OPEN, 0);
}

std::vector<tree::TerminalNode *> vbaParser::OpenStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::OpenStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

std::vector<vbaParser::ValueStmtContext *> vbaParser::OpenStmtContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::OpenStmtContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

tree::TerminalNode* vbaParser::OpenStmtContext::FOR() {
  return getToken(vbaParser::FOR, 0);
}

tree::TerminalNode* vbaParser::OpenStmtContext::AS() {
  return getToken(vbaParser::AS, 0);
}

vbaParser::FileNumberContext* vbaParser::OpenStmtContext::fileNumber() {
  return getRuleContext<vbaParser::FileNumberContext>(0);
}

tree::TerminalNode* vbaParser::OpenStmtContext::APPEND() {
  return getToken(vbaParser::APPEND, 0);
}

tree::TerminalNode* vbaParser::OpenStmtContext::BINARY() {
  return getToken(vbaParser::BINARY, 0);
}

tree::TerminalNode* vbaParser::OpenStmtContext::INPUT() {
  return getToken(vbaParser::INPUT, 0);
}

tree::TerminalNode* vbaParser::OpenStmtContext::OUTPUT() {
  return getToken(vbaParser::OUTPUT, 0);
}

tree::TerminalNode* vbaParser::OpenStmtContext::RANDOM() {
  return getToken(vbaParser::RANDOM, 0);
}

tree::TerminalNode* vbaParser::OpenStmtContext::ACCESS() {
  return getToken(vbaParser::ACCESS, 0);
}

tree::TerminalNode* vbaParser::OpenStmtContext::LEN() {
  return getToken(vbaParser::LEN, 0);
}

tree::TerminalNode* vbaParser::OpenStmtContext::EQ() {
  return getToken(vbaParser::EQ, 0);
}

tree::TerminalNode* vbaParser::OpenStmtContext::READ() {
  return getToken(vbaParser::READ, 0);
}

tree::TerminalNode* vbaParser::OpenStmtContext::WRITE() {
  return getToken(vbaParser::WRITE, 0);
}

tree::TerminalNode* vbaParser::OpenStmtContext::READ_WRITE() {
  return getToken(vbaParser::READ_WRITE, 0);
}

tree::TerminalNode* vbaParser::OpenStmtContext::SHARED() {
  return getToken(vbaParser::SHARED, 0);
}

tree::TerminalNode* vbaParser::OpenStmtContext::LOCK_READ() {
  return getToken(vbaParser::LOCK_READ, 0);
}

tree::TerminalNode* vbaParser::OpenStmtContext::LOCK_WRITE() {
  return getToken(vbaParser::LOCK_WRITE, 0);
}

tree::TerminalNode* vbaParser::OpenStmtContext::LOCK_READ_WRITE() {
  return getToken(vbaParser::LOCK_READ_WRITE, 0);
}


size_t vbaParser::OpenStmtContext::getRuleIndex() const {
  return vbaParser::RuleOpenStmt;
}

void vbaParser::OpenStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpenStmt(this);
}

void vbaParser::OpenStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpenStmt(this);
}

vbaParser::OpenStmtContext* vbaParser::openStmt() {
  OpenStmtContext *_localctx = _tracker.createInstance<OpenStmtContext>(_ctx, getState());
  enterRule(_localctx, 130, vbaParser::RuleOpenStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1253);
    match(vbaParser::OPEN);
    setState(1254);
    match(vbaParser::WS);
    setState(1255);
    valueStmt(0);
    setState(1256);
    match(vbaParser::WS);
    setState(1257);
    match(vbaParser::FOR);
    setState(1258);
    match(vbaParser::WS);
    setState(1259);
    _la = _input->LA(1);
    if (!(_la == vbaParser::APPEND

    || _la == vbaParser::BINARY || ((((_la - 86) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 86)) & 9011597301252097) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1264);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 153, _ctx)) {
    case 1: {
      setState(1260);
      match(vbaParser::WS);
      setState(1261);
      match(vbaParser::ACCESS);
      setState(1262);
      match(vbaParser::WS);
      setState(1263);
      _la = _input->LA(1);
      if (!(((((_la - 142) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 142)) & 4398046511107) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(1268);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx)) {
    case 1: {
      setState(1266);
      match(vbaParser::WS);
      setState(1267);
      _la = _input->LA(1);
      if (!(((((_la - 99) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 99)) & 576460752303423495) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(1270);
    match(vbaParser::WS);
    setState(1271);
    match(vbaParser::AS);
    setState(1272);
    match(vbaParser::WS);
    setState(1273);
    fileNumber();
    setState(1284);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 157, _ctx)) {
    case 1: {
      setState(1274);
      match(vbaParser::WS);
      setState(1275);
      match(vbaParser::LEN);
      setState(1277);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1276);
        match(vbaParser::WS);
      }
      setState(1279);
      match(vbaParser::EQ);
      setState(1281);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1280);
        match(vbaParser::WS);
      }
      setState(1283);
      valueStmt(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OutputListContext ------------------------------------------------------------------

vbaParser::OutputListContext::OutputListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<vbaParser::OutputList_ExpressionContext *> vbaParser::OutputListContext::outputList_Expression() {
  return getRuleContexts<vbaParser::OutputList_ExpressionContext>();
}

vbaParser::OutputList_ExpressionContext* vbaParser::OutputListContext::outputList_Expression(size_t i) {
  return getRuleContext<vbaParser::OutputList_ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> vbaParser::OutputListContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::OutputListContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}


size_t vbaParser::OutputListContext::getRuleIndex() const {
  return vbaParser::RuleOutputList;
}

void vbaParser::OutputListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOutputList(this);
}

void vbaParser::OutputListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOutputList(this);
}

vbaParser::OutputListContext* vbaParser::outputList() {
  OutputListContext *_localctx = _tracker.createInstance<OutputListContext>(_ctx, getState());
  enterRule(_localctx, 132, vbaParser::RuleOutputList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1319);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1286);
      outputList_Expression();
      setState(1299);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1288);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1287);
            match(vbaParser::WS);
          }
          setState(1290);
          _la = _input->LA(1);
          if (!(_la == vbaParser::T__0

          || _la == vbaParser::T__1)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1292);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 159, _ctx)) {
          case 1: {
            setState(1291);
            match(vbaParser::WS);
            break;
          }

          default:
            break;
          }
          setState(1295);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 160, _ctx)) {
          case 1: {
            setState(1294);
            outputList_Expression();
            break;
          }

          default:
            break;
          } 
        }
        setState(1301);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1303);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -4593671619917906384) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & -8755014975736513009) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & 288230376151678495) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & 135262277) != 0)) {
        setState(1302);
        outputList_Expression();
      }
      setState(1315); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(1306);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == vbaParser::WS) {
                  setState(1305);
                  match(vbaParser::WS);
                }
                setState(1308);
                _la = _input->LA(1);
                if (!(_la == vbaParser::T__0

                || _la == vbaParser::T__1)) {
                _errHandler->recoverInline(this);
                }
                else {
                  _errHandler->reportMatch(this);
                  consume();
                }
                setState(1310);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx)) {
                case 1: {
                  setState(1309);
                  match(vbaParser::WS);
                  break;
                }

                default:
                  break;
                }
                setState(1313);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx)) {
                case 1: {
                  setState(1312);
                  outputList_Expression();
                  break;
                }

                default:
                  break;
                }
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(1317); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 166, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OutputList_ExpressionContext ------------------------------------------------------------------

vbaParser::OutputList_ExpressionContext::OutputList_ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::ValueStmtContext* vbaParser::OutputList_ExpressionContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

tree::TerminalNode* vbaParser::OutputList_ExpressionContext::SPC() {
  return getToken(vbaParser::SPC, 0);
}

tree::TerminalNode* vbaParser::OutputList_ExpressionContext::TAB() {
  return getToken(vbaParser::TAB, 0);
}

tree::TerminalNode* vbaParser::OutputList_ExpressionContext::LPAREN() {
  return getToken(vbaParser::LPAREN, 0);
}

vbaParser::ArgsCallContext* vbaParser::OutputList_ExpressionContext::argsCall() {
  return getRuleContext<vbaParser::ArgsCallContext>(0);
}

tree::TerminalNode* vbaParser::OutputList_ExpressionContext::RPAREN() {
  return getToken(vbaParser::RPAREN, 0);
}

std::vector<tree::TerminalNode *> vbaParser::OutputList_ExpressionContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::OutputList_ExpressionContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}


size_t vbaParser::OutputList_ExpressionContext::getRuleIndex() const {
  return vbaParser::RuleOutputList_Expression;
}

void vbaParser::OutputList_ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOutputList_Expression(this);
}

void vbaParser::OutputList_ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOutputList_Expression(this);
}

vbaParser::OutputList_ExpressionContext* vbaParser::outputList_Expression() {
  OutputList_ExpressionContext *_localctx = _tracker.createInstance<OutputList_ExpressionContext>(_ctx, getState());
  enterRule(_localctx, 134, vbaParser::RuleOutputList_Expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1338);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1321);
      valueStmt(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1322);
      _la = _input->LA(1);
      if (!(_la == vbaParser::SPC

      || _la == vbaParser::TAB)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1336);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 171, _ctx)) {
      case 1: {
        setState(1324);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(1323);
          match(vbaParser::WS);
        }
        setState(1326);
        match(vbaParser::LPAREN);
        setState(1328);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx)) {
        case 1: {
          setState(1327);
          match(vbaParser::WS);
          break;
        }

        default:
          break;
        }
        setState(1330);
        argsCall();
        setState(1332);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(1331);
          match(vbaParser::WS);
        }
        setState(1334);
        match(vbaParser::RPAREN);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrintStmtContext ------------------------------------------------------------------

vbaParser::PrintStmtContext::PrintStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::PrintStmtContext::PRINT() {
  return getToken(vbaParser::PRINT, 0);
}

std::vector<tree::TerminalNode *> vbaParser::PrintStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::PrintStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::FileNumberContext* vbaParser::PrintStmtContext::fileNumber() {
  return getRuleContext<vbaParser::FileNumberContext>(0);
}

vbaParser::OutputListContext* vbaParser::PrintStmtContext::outputList() {
  return getRuleContext<vbaParser::OutputListContext>(0);
}


size_t vbaParser::PrintStmtContext::getRuleIndex() const {
  return vbaParser::RulePrintStmt;
}

void vbaParser::PrintStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrintStmt(this);
}

void vbaParser::PrintStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrintStmt(this);
}

vbaParser::PrintStmtContext* vbaParser::printStmt() {
  PrintStmtContext *_localctx = _tracker.createInstance<PrintStmtContext>(_ctx, getState());
  enterRule(_localctx, 136, vbaParser::RulePrintStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1340);
    match(vbaParser::PRINT);
    setState(1341);
    match(vbaParser::WS);
    setState(1342);
    fileNumber();
    setState(1344);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1343);
      match(vbaParser::WS);
    }
    setState(1346);
    match(vbaParser::T__0);
    setState(1351);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 175, _ctx)) {
    case 1: {
      setState(1348);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 174, _ctx)) {
      case 1: {
        setState(1347);
        match(vbaParser::WS);
        break;
      }

      default:
        break;
      }
      setState(1350);
      outputList();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyGetStmtContext ------------------------------------------------------------------

vbaParser::PropertyGetStmtContext::PropertyGetStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::PropertyGetStmtContext::PROPERTY_GET() {
  return getToken(vbaParser::PROPERTY_GET, 0);
}

std::vector<tree::TerminalNode *> vbaParser::PropertyGetStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::PropertyGetStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::AmbiguousIdentifierContext* vbaParser::PropertyGetStmtContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

vbaParser::EndOfStatementContext* vbaParser::PropertyGetStmtContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

tree::TerminalNode* vbaParser::PropertyGetStmtContext::END_PROPERTY() {
  return getToken(vbaParser::END_PROPERTY, 0);
}

vbaParser::VisibilityContext* vbaParser::PropertyGetStmtContext::visibility() {
  return getRuleContext<vbaParser::VisibilityContext>(0);
}

tree::TerminalNode* vbaParser::PropertyGetStmtContext::STATIC() {
  return getToken(vbaParser::STATIC, 0);
}

vbaParser::TypeHintContext* vbaParser::PropertyGetStmtContext::typeHint() {
  return getRuleContext<vbaParser::TypeHintContext>(0);
}

vbaParser::ArgListContext* vbaParser::PropertyGetStmtContext::argList() {
  return getRuleContext<vbaParser::ArgListContext>(0);
}

vbaParser::AsTypeClauseContext* vbaParser::PropertyGetStmtContext::asTypeClause() {
  return getRuleContext<vbaParser::AsTypeClauseContext>(0);
}

vbaParser::BlockContext* vbaParser::PropertyGetStmtContext::block() {
  return getRuleContext<vbaParser::BlockContext>(0);
}


size_t vbaParser::PropertyGetStmtContext::getRuleIndex() const {
  return vbaParser::RulePropertyGetStmt;
}

void vbaParser::PropertyGetStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyGetStmt(this);
}

void vbaParser::PropertyGetStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyGetStmt(this);
}

vbaParser::PropertyGetStmtContext* vbaParser::propertyGetStmt() {
  PropertyGetStmtContext *_localctx = _tracker.createInstance<PropertyGetStmtContext>(_ctx, getState());
  enterRule(_localctx, 138, vbaParser::RulePropertyGetStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1356);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 75) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 75)) & 4755801206503243793) != 0)) {
      setState(1353);
      visibility();
      setState(1354);
      match(vbaParser::WS);
    }
    setState(1360);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::STATIC) {
      setState(1358);
      match(vbaParser::STATIC);
      setState(1359);
      match(vbaParser::WS);
    }
    setState(1362);
    match(vbaParser::PROPERTY_GET);
    setState(1363);
    match(vbaParser::WS);
    setState(1364);
    ambiguousIdentifier();
    setState(1366);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 178, _ctx)) {
    case 1: {
      setState(1365);
      typeHint();
      break;
    }

    default:
      break;
    }
    setState(1372);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 180, _ctx)) {
    case 1: {
      setState(1369);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1368);
        match(vbaParser::WS);
      }
      setState(1371);
      argList();
      break;
    }

    default:
      break;
    }
    setState(1376);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 181, _ctx)) {
    case 1: {
      setState(1374);
      match(vbaParser::WS);
      setState(1375);
      asTypeClause();
      break;
    }

    default:
      break;
    }
    setState(1378);
    endOfStatement();
    setState(1380);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4593671619917906384) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -8646926918232309761) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 288230376151678495) != 0) || _la == vbaParser::LINE_CONTINUATION

    || _la == vbaParser::IDENTIFIER) {
      setState(1379);
      block();
    }
    setState(1382);
    match(vbaParser::END_PROPERTY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertySetStmtContext ------------------------------------------------------------------

vbaParser::PropertySetStmtContext::PropertySetStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::PropertySetStmtContext::PROPERTY_SET() {
  return getToken(vbaParser::PROPERTY_SET, 0);
}

std::vector<tree::TerminalNode *> vbaParser::PropertySetStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::PropertySetStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::AmbiguousIdentifierContext* vbaParser::PropertySetStmtContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

vbaParser::EndOfStatementContext* vbaParser::PropertySetStmtContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

tree::TerminalNode* vbaParser::PropertySetStmtContext::END_PROPERTY() {
  return getToken(vbaParser::END_PROPERTY, 0);
}

vbaParser::VisibilityContext* vbaParser::PropertySetStmtContext::visibility() {
  return getRuleContext<vbaParser::VisibilityContext>(0);
}

tree::TerminalNode* vbaParser::PropertySetStmtContext::STATIC() {
  return getToken(vbaParser::STATIC, 0);
}

vbaParser::ArgListContext* vbaParser::PropertySetStmtContext::argList() {
  return getRuleContext<vbaParser::ArgListContext>(0);
}

vbaParser::BlockContext* vbaParser::PropertySetStmtContext::block() {
  return getRuleContext<vbaParser::BlockContext>(0);
}


size_t vbaParser::PropertySetStmtContext::getRuleIndex() const {
  return vbaParser::RulePropertySetStmt;
}

void vbaParser::PropertySetStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertySetStmt(this);
}

void vbaParser::PropertySetStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertySetStmt(this);
}

vbaParser::PropertySetStmtContext* vbaParser::propertySetStmt() {
  PropertySetStmtContext *_localctx = _tracker.createInstance<PropertySetStmtContext>(_ctx, getState());
  enterRule(_localctx, 140, vbaParser::RulePropertySetStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1387);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 75) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 75)) & 4755801206503243793) != 0)) {
      setState(1384);
      visibility();
      setState(1385);
      match(vbaParser::WS);
    }
    setState(1391);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::STATIC) {
      setState(1389);
      match(vbaParser::STATIC);
      setState(1390);
      match(vbaParser::WS);
    }
    setState(1393);
    match(vbaParser::PROPERTY_SET);
    setState(1394);
    match(vbaParser::WS);
    setState(1395);
    ambiguousIdentifier();
    setState(1400);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 186, _ctx)) {
    case 1: {
      setState(1397);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1396);
        match(vbaParser::WS);
      }
      setState(1399);
      argList();
      break;
    }

    default:
      break;
    }
    setState(1402);
    endOfStatement();
    setState(1404);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4593671619917906384) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -8646926918232309761) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 288230376151678495) != 0) || _la == vbaParser::LINE_CONTINUATION

    || _la == vbaParser::IDENTIFIER) {
      setState(1403);
      block();
    }
    setState(1406);
    match(vbaParser::END_PROPERTY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyLetStmtContext ------------------------------------------------------------------

vbaParser::PropertyLetStmtContext::PropertyLetStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::PropertyLetStmtContext::PROPERTY_LET() {
  return getToken(vbaParser::PROPERTY_LET, 0);
}

std::vector<tree::TerminalNode *> vbaParser::PropertyLetStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::PropertyLetStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::AmbiguousIdentifierContext* vbaParser::PropertyLetStmtContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

vbaParser::EndOfStatementContext* vbaParser::PropertyLetStmtContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

tree::TerminalNode* vbaParser::PropertyLetStmtContext::END_PROPERTY() {
  return getToken(vbaParser::END_PROPERTY, 0);
}

vbaParser::VisibilityContext* vbaParser::PropertyLetStmtContext::visibility() {
  return getRuleContext<vbaParser::VisibilityContext>(0);
}

tree::TerminalNode* vbaParser::PropertyLetStmtContext::STATIC() {
  return getToken(vbaParser::STATIC, 0);
}

vbaParser::ArgListContext* vbaParser::PropertyLetStmtContext::argList() {
  return getRuleContext<vbaParser::ArgListContext>(0);
}

vbaParser::BlockContext* vbaParser::PropertyLetStmtContext::block() {
  return getRuleContext<vbaParser::BlockContext>(0);
}


size_t vbaParser::PropertyLetStmtContext::getRuleIndex() const {
  return vbaParser::RulePropertyLetStmt;
}

void vbaParser::PropertyLetStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyLetStmt(this);
}

void vbaParser::PropertyLetStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyLetStmt(this);
}

vbaParser::PropertyLetStmtContext* vbaParser::propertyLetStmt() {
  PropertyLetStmtContext *_localctx = _tracker.createInstance<PropertyLetStmtContext>(_ctx, getState());
  enterRule(_localctx, 142, vbaParser::RulePropertyLetStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1411);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 75) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 75)) & 4755801206503243793) != 0)) {
      setState(1408);
      visibility();
      setState(1409);
      match(vbaParser::WS);
    }
    setState(1415);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::STATIC) {
      setState(1413);
      match(vbaParser::STATIC);
      setState(1414);
      match(vbaParser::WS);
    }
    setState(1417);
    match(vbaParser::PROPERTY_LET);
    setState(1418);
    match(vbaParser::WS);
    setState(1419);
    ambiguousIdentifier();
    setState(1424);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 191, _ctx)) {
    case 1: {
      setState(1421);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1420);
        match(vbaParser::WS);
      }
      setState(1423);
      argList();
      break;
    }

    default:
      break;
    }
    setState(1426);
    endOfStatement();
    setState(1428);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4593671619917906384) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -8646926918232309761) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 288230376151678495) != 0) || _la == vbaParser::LINE_CONTINUATION

    || _la == vbaParser::IDENTIFIER) {
      setState(1427);
      block();
    }
    setState(1430);
    match(vbaParser::END_PROPERTY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PutStmtContext ------------------------------------------------------------------

vbaParser::PutStmtContext::PutStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::PutStmtContext::PUT() {
  return getToken(vbaParser::PUT, 0);
}

std::vector<tree::TerminalNode *> vbaParser::PutStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::PutStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::FileNumberContext* vbaParser::PutStmtContext::fileNumber() {
  return getRuleContext<vbaParser::FileNumberContext>(0);
}

std::vector<vbaParser::ValueStmtContext *> vbaParser::PutStmtContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::PutStmtContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}


size_t vbaParser::PutStmtContext::getRuleIndex() const {
  return vbaParser::RulePutStmt;
}

void vbaParser::PutStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPutStmt(this);
}

void vbaParser::PutStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPutStmt(this);
}

vbaParser::PutStmtContext* vbaParser::putStmt() {
  PutStmtContext *_localctx = _tracker.createInstance<PutStmtContext>(_ctx, getState());
  enterRule(_localctx, 144, vbaParser::RulePutStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1432);
    match(vbaParser::PUT);
    setState(1433);
    match(vbaParser::WS);
    setState(1434);
    fileNumber();
    setState(1436);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1435);
      match(vbaParser::WS);
    }
    setState(1438);
    match(vbaParser::T__0);
    setState(1440);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 194, _ctx)) {
    case 1: {
      setState(1439);
      match(vbaParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1443);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4593671619917906384) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -8755014975736513009) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 288230376151678495) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & 135262277) != 0)) {
      setState(1442);
      valueStmt(0);
    }
    setState(1446);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1445);
      match(vbaParser::WS);
    }
    setState(1448);
    match(vbaParser::T__0);
    setState(1450);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1449);
      match(vbaParser::WS);
    }
    setState(1452);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RaiseEventStmtContext ------------------------------------------------------------------

vbaParser::RaiseEventStmtContext::RaiseEventStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::RaiseEventStmtContext::RAISEEVENT() {
  return getToken(vbaParser::RAISEEVENT, 0);
}

std::vector<tree::TerminalNode *> vbaParser::RaiseEventStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::RaiseEventStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::AmbiguousIdentifierContext* vbaParser::RaiseEventStmtContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

tree::TerminalNode* vbaParser::RaiseEventStmtContext::LPAREN() {
  return getToken(vbaParser::LPAREN, 0);
}

tree::TerminalNode* vbaParser::RaiseEventStmtContext::RPAREN() {
  return getToken(vbaParser::RPAREN, 0);
}

vbaParser::ArgsCallContext* vbaParser::RaiseEventStmtContext::argsCall() {
  return getRuleContext<vbaParser::ArgsCallContext>(0);
}


size_t vbaParser::RaiseEventStmtContext::getRuleIndex() const {
  return vbaParser::RuleRaiseEventStmt;
}

void vbaParser::RaiseEventStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRaiseEventStmt(this);
}

void vbaParser::RaiseEventStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRaiseEventStmt(this);
}

vbaParser::RaiseEventStmtContext* vbaParser::raiseEventStmt() {
  RaiseEventStmtContext *_localctx = _tracker.createInstance<RaiseEventStmtContext>(_ctx, getState());
  enterRule(_localctx, 146, vbaParser::RuleRaiseEventStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1454);
    match(vbaParser::RAISEEVENT);
    setState(1455);
    match(vbaParser::WS);
    setState(1456);
    ambiguousIdentifier();
    setState(1471);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 202, _ctx)) {
    case 1: {
      setState(1458);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1457);
        match(vbaParser::WS);
      }
      setState(1460);
      match(vbaParser::LPAREN);
      setState(1462);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 199, _ctx)) {
      case 1: {
        setState(1461);
        match(vbaParser::WS);
        break;
      }

      default:
        break;
      }
      setState(1468);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 201, _ctx)) {
      case 1: {
        setState(1464);
        argsCall();
        setState(1466);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(1465);
          match(vbaParser::WS);
        }
        break;
      }

      default:
        break;
      }
      setState(1470);
      match(vbaParser::RPAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RandomizeStmtContext ------------------------------------------------------------------

vbaParser::RandomizeStmtContext::RandomizeStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::RandomizeStmtContext::RANDOMIZE() {
  return getToken(vbaParser::RANDOMIZE, 0);
}

tree::TerminalNode* vbaParser::RandomizeStmtContext::WS() {
  return getToken(vbaParser::WS, 0);
}

vbaParser::ValueStmtContext* vbaParser::RandomizeStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}


size_t vbaParser::RandomizeStmtContext::getRuleIndex() const {
  return vbaParser::RuleRandomizeStmt;
}

void vbaParser::RandomizeStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRandomizeStmt(this);
}

void vbaParser::RandomizeStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRandomizeStmt(this);
}

vbaParser::RandomizeStmtContext* vbaParser::randomizeStmt() {
  RandomizeStmtContext *_localctx = _tracker.createInstance<RandomizeStmtContext>(_ctx, getState());
  enterRule(_localctx, 148, vbaParser::RuleRandomizeStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1473);
    match(vbaParser::RANDOMIZE);
    setState(1476);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 203, _ctx)) {
    case 1: {
      setState(1474);
      match(vbaParser::WS);
      setState(1475);
      valueStmt(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RedimStmtContext ------------------------------------------------------------------

vbaParser::RedimStmtContext::RedimStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::RedimStmtContext::REDIM() {
  return getToken(vbaParser::REDIM, 0);
}

std::vector<tree::TerminalNode *> vbaParser::RedimStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::RedimStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

std::vector<vbaParser::RedimSubStmtContext *> vbaParser::RedimStmtContext::redimSubStmt() {
  return getRuleContexts<vbaParser::RedimSubStmtContext>();
}

vbaParser::RedimSubStmtContext* vbaParser::RedimStmtContext::redimSubStmt(size_t i) {
  return getRuleContext<vbaParser::RedimSubStmtContext>(i);
}

tree::TerminalNode* vbaParser::RedimStmtContext::PRESERVE() {
  return getToken(vbaParser::PRESERVE, 0);
}


size_t vbaParser::RedimStmtContext::getRuleIndex() const {
  return vbaParser::RuleRedimStmt;
}

void vbaParser::RedimStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRedimStmt(this);
}

void vbaParser::RedimStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRedimStmt(this);
}

vbaParser::RedimStmtContext* vbaParser::redimStmt() {
  RedimStmtContext *_localctx = _tracker.createInstance<RedimStmtContext>(_ctx, getState());
  enterRule(_localctx, 150, vbaParser::RuleRedimStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1478);
    match(vbaParser::REDIM);
    setState(1479);
    match(vbaParser::WS);
    setState(1482);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 204, _ctx)) {
    case 1: {
      setState(1480);
      match(vbaParser::PRESERVE);
      setState(1481);
      match(vbaParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1484);
    redimSubStmt();
    setState(1495);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 207, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1486);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(1485);
          match(vbaParser::WS);
        }
        setState(1488);
        match(vbaParser::T__0);
        setState(1490);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(1489);
          match(vbaParser::WS);
        }
        setState(1492);
        redimSubStmt(); 
      }
      setState(1497);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 207, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RedimSubStmtContext ------------------------------------------------------------------

vbaParser::RedimSubStmtContext::RedimSubStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::ImplicitCallStmt_InStmtContext* vbaParser::RedimSubStmtContext::implicitCallStmt_InStmt() {
  return getRuleContext<vbaParser::ImplicitCallStmt_InStmtContext>(0);
}

tree::TerminalNode* vbaParser::RedimSubStmtContext::LPAREN() {
  return getToken(vbaParser::LPAREN, 0);
}

vbaParser::SubscriptsContext* vbaParser::RedimSubStmtContext::subscripts() {
  return getRuleContext<vbaParser::SubscriptsContext>(0);
}

tree::TerminalNode* vbaParser::RedimSubStmtContext::RPAREN() {
  return getToken(vbaParser::RPAREN, 0);
}

std::vector<tree::TerminalNode *> vbaParser::RedimSubStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::RedimSubStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::AsTypeClauseContext* vbaParser::RedimSubStmtContext::asTypeClause() {
  return getRuleContext<vbaParser::AsTypeClauseContext>(0);
}


size_t vbaParser::RedimSubStmtContext::getRuleIndex() const {
  return vbaParser::RuleRedimSubStmt;
}

void vbaParser::RedimSubStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRedimSubStmt(this);
}

void vbaParser::RedimSubStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRedimSubStmt(this);
}

vbaParser::RedimSubStmtContext* vbaParser::redimSubStmt() {
  RedimSubStmtContext *_localctx = _tracker.createInstance<RedimSubStmtContext>(_ctx, getState());
  enterRule(_localctx, 152, vbaParser::RuleRedimSubStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1498);
    implicitCallStmt_InStmt();
    setState(1500);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1499);
      match(vbaParser::WS);
    }
    setState(1502);
    match(vbaParser::LPAREN);
    setState(1504);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1503);
      match(vbaParser::WS);
    }
    setState(1506);
    subscripts();
    setState(1508);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1507);
      match(vbaParser::WS);
    }
    setState(1510);
    match(vbaParser::RPAREN);
    setState(1513);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 211, _ctx)) {
    case 1: {
      setState(1511);
      match(vbaParser::WS);
      setState(1512);
      asTypeClause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResetStmtContext ------------------------------------------------------------------

vbaParser::ResetStmtContext::ResetStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::ResetStmtContext::RESET() {
  return getToken(vbaParser::RESET, 0);
}


size_t vbaParser::ResetStmtContext::getRuleIndex() const {
  return vbaParser::RuleResetStmt;
}

void vbaParser::ResetStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResetStmt(this);
}

void vbaParser::ResetStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResetStmt(this);
}

vbaParser::ResetStmtContext* vbaParser::resetStmt() {
  ResetStmtContext *_localctx = _tracker.createInstance<ResetStmtContext>(_ctx, getState());
  enterRule(_localctx, 154, vbaParser::RuleResetStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1515);
    match(vbaParser::RESET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResumeStmtContext ------------------------------------------------------------------

vbaParser::ResumeStmtContext::ResumeStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::ResumeStmtContext::RESUME() {
  return getToken(vbaParser::RESUME, 0);
}

tree::TerminalNode* vbaParser::ResumeStmtContext::WS() {
  return getToken(vbaParser::WS, 0);
}

tree::TerminalNode* vbaParser::ResumeStmtContext::NEXT() {
  return getToken(vbaParser::NEXT, 0);
}

vbaParser::AmbiguousIdentifierContext* vbaParser::ResumeStmtContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}


size_t vbaParser::ResumeStmtContext::getRuleIndex() const {
  return vbaParser::RuleResumeStmt;
}

void vbaParser::ResumeStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResumeStmt(this);
}

void vbaParser::ResumeStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResumeStmt(this);
}

vbaParser::ResumeStmtContext* vbaParser::resumeStmt() {
  ResumeStmtContext *_localctx = _tracker.createInstance<ResumeStmtContext>(_ctx, getState());
  enterRule(_localctx, 156, vbaParser::RuleResumeStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1517);
    match(vbaParser::RESUME);
    setState(1523);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 213, _ctx)) {
    case 1: {
      setState(1518);
      match(vbaParser::WS);
      setState(1521);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 212, _ctx)) {
      case 1: {
        setState(1519);
        match(vbaParser::NEXT);
        break;
      }

      case 2: {
        setState(1520);
        ambiguousIdentifier();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnStmtContext ------------------------------------------------------------------

vbaParser::ReturnStmtContext::ReturnStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::ReturnStmtContext::RETURN() {
  return getToken(vbaParser::RETURN, 0);
}


size_t vbaParser::ReturnStmtContext::getRuleIndex() const {
  return vbaParser::RuleReturnStmt;
}

void vbaParser::ReturnStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnStmt(this);
}

void vbaParser::ReturnStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnStmt(this);
}

vbaParser::ReturnStmtContext* vbaParser::returnStmt() {
  ReturnStmtContext *_localctx = _tracker.createInstance<ReturnStmtContext>(_ctx, getState());
  enterRule(_localctx, 158, vbaParser::RuleReturnStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1525);
    match(vbaParser::RETURN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RmdirStmtContext ------------------------------------------------------------------

vbaParser::RmdirStmtContext::RmdirStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::RmdirStmtContext::RMDIR() {
  return getToken(vbaParser::RMDIR, 0);
}

tree::TerminalNode* vbaParser::RmdirStmtContext::WS() {
  return getToken(vbaParser::WS, 0);
}

vbaParser::ValueStmtContext* vbaParser::RmdirStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}


size_t vbaParser::RmdirStmtContext::getRuleIndex() const {
  return vbaParser::RuleRmdirStmt;
}

void vbaParser::RmdirStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRmdirStmt(this);
}

void vbaParser::RmdirStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRmdirStmt(this);
}

vbaParser::RmdirStmtContext* vbaParser::rmdirStmt() {
  RmdirStmtContext *_localctx = _tracker.createInstance<RmdirStmtContext>(_ctx, getState());
  enterRule(_localctx, 160, vbaParser::RuleRmdirStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1527);
    match(vbaParser::RMDIR);
    setState(1528);
    match(vbaParser::WS);
    setState(1529);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RsetStmtContext ------------------------------------------------------------------

vbaParser::RsetStmtContext::RsetStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::RsetStmtContext::RSET() {
  return getToken(vbaParser::RSET, 0);
}

std::vector<tree::TerminalNode *> vbaParser::RsetStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::RsetStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::ImplicitCallStmt_InStmtContext* vbaParser::RsetStmtContext::implicitCallStmt_InStmt() {
  return getRuleContext<vbaParser::ImplicitCallStmt_InStmtContext>(0);
}

tree::TerminalNode* vbaParser::RsetStmtContext::EQ() {
  return getToken(vbaParser::EQ, 0);
}

vbaParser::ValueStmtContext* vbaParser::RsetStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}


size_t vbaParser::RsetStmtContext::getRuleIndex() const {
  return vbaParser::RuleRsetStmt;
}

void vbaParser::RsetStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRsetStmt(this);
}

void vbaParser::RsetStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRsetStmt(this);
}

vbaParser::RsetStmtContext* vbaParser::rsetStmt() {
  RsetStmtContext *_localctx = _tracker.createInstance<RsetStmtContext>(_ctx, getState());
  enterRule(_localctx, 162, vbaParser::RuleRsetStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1531);
    match(vbaParser::RSET);
    setState(1532);
    match(vbaParser::WS);
    setState(1533);
    implicitCallStmt_InStmt();
    setState(1535);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1534);
      match(vbaParser::WS);
    }
    setState(1537);
    match(vbaParser::EQ);
    setState(1539);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1538);
      match(vbaParser::WS);
    }
    setState(1541);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SavepictureStmtContext ------------------------------------------------------------------

vbaParser::SavepictureStmtContext::SavepictureStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::SavepictureStmtContext::SAVEPICTURE() {
  return getToken(vbaParser::SAVEPICTURE, 0);
}

std::vector<tree::TerminalNode *> vbaParser::SavepictureStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::SavepictureStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

std::vector<vbaParser::ValueStmtContext *> vbaParser::SavepictureStmtContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::SavepictureStmtContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}


size_t vbaParser::SavepictureStmtContext::getRuleIndex() const {
  return vbaParser::RuleSavepictureStmt;
}

void vbaParser::SavepictureStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSavepictureStmt(this);
}

void vbaParser::SavepictureStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSavepictureStmt(this);
}

vbaParser::SavepictureStmtContext* vbaParser::savepictureStmt() {
  SavepictureStmtContext *_localctx = _tracker.createInstance<SavepictureStmtContext>(_ctx, getState());
  enterRule(_localctx, 164, vbaParser::RuleSavepictureStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1543);
    match(vbaParser::SAVEPICTURE);
    setState(1544);
    match(vbaParser::WS);
    setState(1545);
    valueStmt(0);
    setState(1547);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1546);
      match(vbaParser::WS);
    }
    setState(1549);
    match(vbaParser::T__0);
    setState(1551);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1550);
      match(vbaParser::WS);
    }
    setState(1553);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SaveSettingStmtContext ------------------------------------------------------------------

vbaParser::SaveSettingStmtContext::SaveSettingStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::SaveSettingStmtContext::SAVESETTING() {
  return getToken(vbaParser::SAVESETTING, 0);
}

std::vector<tree::TerminalNode *> vbaParser::SaveSettingStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::SaveSettingStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

std::vector<vbaParser::ValueStmtContext *> vbaParser::SaveSettingStmtContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::SaveSettingStmtContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}


size_t vbaParser::SaveSettingStmtContext::getRuleIndex() const {
  return vbaParser::RuleSaveSettingStmt;
}

void vbaParser::SaveSettingStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSaveSettingStmt(this);
}

void vbaParser::SaveSettingStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSaveSettingStmt(this);
}

vbaParser::SaveSettingStmtContext* vbaParser::saveSettingStmt() {
  SaveSettingStmtContext *_localctx = _tracker.createInstance<SaveSettingStmtContext>(_ctx, getState());
  enterRule(_localctx, 166, vbaParser::RuleSaveSettingStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1555);
    match(vbaParser::SAVESETTING);
    setState(1556);
    match(vbaParser::WS);
    setState(1557);
    valueStmt(0);
    setState(1559);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1558);
      match(vbaParser::WS);
    }
    setState(1561);
    match(vbaParser::T__0);
    setState(1563);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1562);
      match(vbaParser::WS);
    }
    setState(1565);
    valueStmt(0);
    setState(1567);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1566);
      match(vbaParser::WS);
    }
    setState(1569);
    match(vbaParser::T__0);
    setState(1571);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1570);
      match(vbaParser::WS);
    }
    setState(1573);
    valueStmt(0);
    setState(1575);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1574);
      match(vbaParser::WS);
    }
    setState(1577);
    match(vbaParser::T__0);
    setState(1579);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1578);
      match(vbaParser::WS);
    }
    setState(1581);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SeekStmtContext ------------------------------------------------------------------

vbaParser::SeekStmtContext::SeekStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::SeekStmtContext::SEEK() {
  return getToken(vbaParser::SEEK, 0);
}

std::vector<tree::TerminalNode *> vbaParser::SeekStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::SeekStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::FileNumberContext* vbaParser::SeekStmtContext::fileNumber() {
  return getRuleContext<vbaParser::FileNumberContext>(0);
}

vbaParser::ValueStmtContext* vbaParser::SeekStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}


size_t vbaParser::SeekStmtContext::getRuleIndex() const {
  return vbaParser::RuleSeekStmt;
}

void vbaParser::SeekStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSeekStmt(this);
}

void vbaParser::SeekStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSeekStmt(this);
}

vbaParser::SeekStmtContext* vbaParser::seekStmt() {
  SeekStmtContext *_localctx = _tracker.createInstance<SeekStmtContext>(_ctx, getState());
  enterRule(_localctx, 168, vbaParser::RuleSeekStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1583);
    match(vbaParser::SEEK);
    setState(1584);
    match(vbaParser::WS);
    setState(1585);
    fileNumber();
    setState(1587);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1586);
      match(vbaParser::WS);
    }
    setState(1589);
    match(vbaParser::T__0);
    setState(1591);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1590);
      match(vbaParser::WS);
    }
    setState(1593);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectCaseStmtContext ------------------------------------------------------------------

vbaParser::SelectCaseStmtContext::SelectCaseStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::SelectCaseStmtContext::SELECT() {
  return getToken(vbaParser::SELECT, 0);
}

std::vector<tree::TerminalNode *> vbaParser::SelectCaseStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::SelectCaseStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

tree::TerminalNode* vbaParser::SelectCaseStmtContext::CASE() {
  return getToken(vbaParser::CASE, 0);
}

vbaParser::ValueStmtContext* vbaParser::SelectCaseStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

vbaParser::EndOfStatementContext* vbaParser::SelectCaseStmtContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

tree::TerminalNode* vbaParser::SelectCaseStmtContext::END_SELECT() {
  return getToken(vbaParser::END_SELECT, 0);
}

std::vector<vbaParser::SC_CaseContext *> vbaParser::SelectCaseStmtContext::sC_Case() {
  return getRuleContexts<vbaParser::SC_CaseContext>();
}

vbaParser::SC_CaseContext* vbaParser::SelectCaseStmtContext::sC_Case(size_t i) {
  return getRuleContext<vbaParser::SC_CaseContext>(i);
}


size_t vbaParser::SelectCaseStmtContext::getRuleIndex() const {
  return vbaParser::RuleSelectCaseStmt;
}

void vbaParser::SelectCaseStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectCaseStmt(this);
}

void vbaParser::SelectCaseStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectCaseStmt(this);
}

vbaParser::SelectCaseStmtContext* vbaParser::selectCaseStmt() {
  SelectCaseStmtContext *_localctx = _tracker.createInstance<SelectCaseStmtContext>(_ctx, getState());
  enterRule(_localctx, 170, vbaParser::RuleSelectCaseStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1595);
    match(vbaParser::SELECT);
    setState(1596);
    match(vbaParser::WS);
    setState(1597);
    match(vbaParser::CASE);
    setState(1598);
    match(vbaParser::WS);
    setState(1599);
    valueStmt(0);
    setState(1600);
    endOfStatement();
    setState(1604);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == vbaParser::CASE) {
      setState(1601);
      sC_Case();
      setState(1606);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1607);
    match(vbaParser::END_SELECT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SC_SelectionContext ------------------------------------------------------------------

vbaParser::SC_SelectionContext::SC_SelectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t vbaParser::SC_SelectionContext::getRuleIndex() const {
  return vbaParser::RuleSC_Selection;
}

void vbaParser::SC_SelectionContext::copyFrom(SC_SelectionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- CaseCondValueContext ------------------------------------------------------------------

vbaParser::ValueStmtContext* vbaParser::CaseCondValueContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

vbaParser::CaseCondValueContext::CaseCondValueContext(SC_SelectionContext *ctx) { copyFrom(ctx); }

void vbaParser::CaseCondValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseCondValue(this);
}
void vbaParser::CaseCondValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseCondValue(this);
}
//----------------- CaseCondToContext ------------------------------------------------------------------

std::vector<vbaParser::ValueStmtContext *> vbaParser::CaseCondToContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::CaseCondToContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

std::vector<tree::TerminalNode *> vbaParser::CaseCondToContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::CaseCondToContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

tree::TerminalNode* vbaParser::CaseCondToContext::TO() {
  return getToken(vbaParser::TO, 0);
}

vbaParser::CaseCondToContext::CaseCondToContext(SC_SelectionContext *ctx) { copyFrom(ctx); }

void vbaParser::CaseCondToContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseCondTo(this);
}
void vbaParser::CaseCondToContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseCondTo(this);
}
//----------------- CaseCondIsContext ------------------------------------------------------------------

tree::TerminalNode* vbaParser::CaseCondIsContext::IS() {
  return getToken(vbaParser::IS, 0);
}

vbaParser::ComparisonOperatorContext* vbaParser::CaseCondIsContext::comparisonOperator() {
  return getRuleContext<vbaParser::ComparisonOperatorContext>(0);
}

vbaParser::ValueStmtContext* vbaParser::CaseCondIsContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::CaseCondIsContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::CaseCondIsContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::CaseCondIsContext::CaseCondIsContext(SC_SelectionContext *ctx) { copyFrom(ctx); }

void vbaParser::CaseCondIsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseCondIs(this);
}
void vbaParser::CaseCondIsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseCondIs(this);
}
vbaParser::SC_SelectionContext* vbaParser::sC_Selection() {
  SC_SelectionContext *_localctx = _tracker.createInstance<SC_SelectionContext>(_ctx, getState());
  enterRule(_localctx, 172, vbaParser::RuleSC_Selection);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1626);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 229, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<vbaParser::CaseCondIsContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(1609);
      match(vbaParser::IS);
      setState(1611);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1610);
        match(vbaParser::WS);
      }
      setState(1613);
      comparisonOperator();
      setState(1615);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1614);
        match(vbaParser::WS);
      }
      setState(1617);
      valueStmt(0);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<vbaParser::CaseCondToContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(1619);
      valueStmt(0);
      setState(1620);
      match(vbaParser::WS);
      setState(1621);
      match(vbaParser::TO);
      setState(1622);
      match(vbaParser::WS);
      setState(1623);
      valueStmt(0);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<vbaParser::CaseCondValueContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(1625);
      valueStmt(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SC_CaseContext ------------------------------------------------------------------

vbaParser::SC_CaseContext::SC_CaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::SC_CaseContext::CASE() {
  return getToken(vbaParser::CASE, 0);
}

tree::TerminalNode* vbaParser::SC_CaseContext::WS() {
  return getToken(vbaParser::WS, 0);
}

vbaParser::SC_CondContext* vbaParser::SC_CaseContext::sC_Cond() {
  return getRuleContext<vbaParser::SC_CondContext>(0);
}

vbaParser::EndOfStatementContext* vbaParser::SC_CaseContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

vbaParser::BlockContext* vbaParser::SC_CaseContext::block() {
  return getRuleContext<vbaParser::BlockContext>(0);
}


size_t vbaParser::SC_CaseContext::getRuleIndex() const {
  return vbaParser::RuleSC_Case;
}

void vbaParser::SC_CaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSC_Case(this);
}

void vbaParser::SC_CaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSC_Case(this);
}

vbaParser::SC_CaseContext* vbaParser::sC_Case() {
  SC_CaseContext *_localctx = _tracker.createInstance<SC_CaseContext>(_ctx, getState());
  enterRule(_localctx, 174, vbaParser::RuleSC_Case);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1628);
    match(vbaParser::CASE);
    setState(1629);
    match(vbaParser::WS);
    setState(1630);
    sC_Cond();
    setState(1631);
    endOfStatement();
    setState(1633);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 230, _ctx)) {
    case 1: {
      setState(1632);
      block();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SC_CondContext ------------------------------------------------------------------

vbaParser::SC_CondContext::SC_CondContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t vbaParser::SC_CondContext::getRuleIndex() const {
  return vbaParser::RuleSC_Cond;
}

void vbaParser::SC_CondContext::copyFrom(SC_CondContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- CaseCondSelectionContext ------------------------------------------------------------------

std::vector<vbaParser::SC_SelectionContext *> vbaParser::CaseCondSelectionContext::sC_Selection() {
  return getRuleContexts<vbaParser::SC_SelectionContext>();
}

vbaParser::SC_SelectionContext* vbaParser::CaseCondSelectionContext::sC_Selection(size_t i) {
  return getRuleContext<vbaParser::SC_SelectionContext>(i);
}

std::vector<tree::TerminalNode *> vbaParser::CaseCondSelectionContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::CaseCondSelectionContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::CaseCondSelectionContext::CaseCondSelectionContext(SC_CondContext *ctx) { copyFrom(ctx); }

void vbaParser::CaseCondSelectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseCondSelection(this);
}
void vbaParser::CaseCondSelectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseCondSelection(this);
}
//----------------- CaseCondElseContext ------------------------------------------------------------------

tree::TerminalNode* vbaParser::CaseCondElseContext::ELSE() {
  return getToken(vbaParser::ELSE, 0);
}

vbaParser::CaseCondElseContext::CaseCondElseContext(SC_CondContext *ctx) { copyFrom(ctx); }

void vbaParser::CaseCondElseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseCondElse(this);
}
void vbaParser::CaseCondElseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseCondElse(this);
}
vbaParser::SC_CondContext* vbaParser::sC_Cond() {
  SC_CondContext *_localctx = _tracker.createInstance<SC_CondContext>(_ctx, getState());
  enterRule(_localctx, 176, vbaParser::RuleSC_Cond);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1650);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 234, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<vbaParser::CaseCondElseContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(1635);
      match(vbaParser::ELSE);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<vbaParser::CaseCondSelectionContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(1636);
      sC_Selection();
      setState(1647);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 233, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1638);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1637);
            match(vbaParser::WS);
          }
          setState(1640);
          match(vbaParser::T__0);
          setState(1642);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1641);
            match(vbaParser::WS);
          }
          setState(1644);
          sC_Selection(); 
        }
        setState(1649);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 233, _ctx);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SendkeysStmtContext ------------------------------------------------------------------

vbaParser::SendkeysStmtContext::SendkeysStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::SendkeysStmtContext::SENDKEYS() {
  return getToken(vbaParser::SENDKEYS, 0);
}

std::vector<tree::TerminalNode *> vbaParser::SendkeysStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::SendkeysStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

std::vector<vbaParser::ValueStmtContext *> vbaParser::SendkeysStmtContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::SendkeysStmtContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}


size_t vbaParser::SendkeysStmtContext::getRuleIndex() const {
  return vbaParser::RuleSendkeysStmt;
}

void vbaParser::SendkeysStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSendkeysStmt(this);
}

void vbaParser::SendkeysStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSendkeysStmt(this);
}

vbaParser::SendkeysStmtContext* vbaParser::sendkeysStmt() {
  SendkeysStmtContext *_localctx = _tracker.createInstance<SendkeysStmtContext>(_ctx, getState());
  enterRule(_localctx, 178, vbaParser::RuleSendkeysStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1652);
    match(vbaParser::SENDKEYS);
    setState(1653);
    match(vbaParser::WS);
    setState(1654);
    valueStmt(0);
    setState(1663);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx)) {
    case 1: {
      setState(1656);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1655);
        match(vbaParser::WS);
      }
      setState(1658);
      match(vbaParser::T__0);
      setState(1660);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1659);
        match(vbaParser::WS);
      }
      setState(1662);
      valueStmt(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetattrStmtContext ------------------------------------------------------------------

vbaParser::SetattrStmtContext::SetattrStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::SetattrStmtContext::SETATTR() {
  return getToken(vbaParser::SETATTR, 0);
}

std::vector<tree::TerminalNode *> vbaParser::SetattrStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::SetattrStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

std::vector<vbaParser::ValueStmtContext *> vbaParser::SetattrStmtContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::SetattrStmtContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}


size_t vbaParser::SetattrStmtContext::getRuleIndex() const {
  return vbaParser::RuleSetattrStmt;
}

void vbaParser::SetattrStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetattrStmt(this);
}

void vbaParser::SetattrStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetattrStmt(this);
}

vbaParser::SetattrStmtContext* vbaParser::setattrStmt() {
  SetattrStmtContext *_localctx = _tracker.createInstance<SetattrStmtContext>(_ctx, getState());
  enterRule(_localctx, 180, vbaParser::RuleSetattrStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1665);
    match(vbaParser::SETATTR);
    setState(1666);
    match(vbaParser::WS);
    setState(1667);
    valueStmt(0);
    setState(1669);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1668);
      match(vbaParser::WS);
    }
    setState(1671);
    match(vbaParser::T__0);
    setState(1673);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1672);
      match(vbaParser::WS);
    }
    setState(1675);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetStmtContext ------------------------------------------------------------------

vbaParser::SetStmtContext::SetStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::SetStmtContext::SET() {
  return getToken(vbaParser::SET, 0);
}

std::vector<tree::TerminalNode *> vbaParser::SetStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::SetStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::ImplicitCallStmt_InStmtContext* vbaParser::SetStmtContext::implicitCallStmt_InStmt() {
  return getRuleContext<vbaParser::ImplicitCallStmt_InStmtContext>(0);
}

tree::TerminalNode* vbaParser::SetStmtContext::EQ() {
  return getToken(vbaParser::EQ, 0);
}

vbaParser::ValueStmtContext* vbaParser::SetStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}


size_t vbaParser::SetStmtContext::getRuleIndex() const {
  return vbaParser::RuleSetStmt;
}

void vbaParser::SetStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetStmt(this);
}

void vbaParser::SetStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetStmt(this);
}

vbaParser::SetStmtContext* vbaParser::setStmt() {
  SetStmtContext *_localctx = _tracker.createInstance<SetStmtContext>(_ctx, getState());
  enterRule(_localctx, 182, vbaParser::RuleSetStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1677);
    match(vbaParser::SET);
    setState(1678);
    match(vbaParser::WS);
    setState(1679);
    implicitCallStmt_InStmt();
    setState(1681);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1680);
      match(vbaParser::WS);
    }
    setState(1683);
    match(vbaParser::EQ);
    setState(1685);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1684);
      match(vbaParser::WS);
    }
    setState(1687);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StopStmtContext ------------------------------------------------------------------

vbaParser::StopStmtContext::StopStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::StopStmtContext::STOP() {
  return getToken(vbaParser::STOP, 0);
}


size_t vbaParser::StopStmtContext::getRuleIndex() const {
  return vbaParser::RuleStopStmt;
}

void vbaParser::StopStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStopStmt(this);
}

void vbaParser::StopStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStopStmt(this);
}

vbaParser::StopStmtContext* vbaParser::stopStmt() {
  StopStmtContext *_localctx = _tracker.createInstance<StopStmtContext>(_ctx, getState());
  enterRule(_localctx, 184, vbaParser::RuleStopStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1689);
    match(vbaParser::STOP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubStmtContext ------------------------------------------------------------------

vbaParser::SubStmtContext::SubStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::SubStmtContext::SUB() {
  return getToken(vbaParser::SUB, 0);
}

vbaParser::AmbiguousIdentifierContext* vbaParser::SubStmtContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

vbaParser::EndOfStatementContext* vbaParser::SubStmtContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

tree::TerminalNode* vbaParser::SubStmtContext::END_SUB() {
  return getToken(vbaParser::END_SUB, 0);
}

vbaParser::VisibilityContext* vbaParser::SubStmtContext::visibility() {
  return getRuleContext<vbaParser::VisibilityContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::SubStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::SubStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

tree::TerminalNode* vbaParser::SubStmtContext::STATIC() {
  return getToken(vbaParser::STATIC, 0);
}

vbaParser::ArgListContext* vbaParser::SubStmtContext::argList() {
  return getRuleContext<vbaParser::ArgListContext>(0);
}

vbaParser::BlockContext* vbaParser::SubStmtContext::block() {
  return getRuleContext<vbaParser::BlockContext>(0);
}


size_t vbaParser::SubStmtContext::getRuleIndex() const {
  return vbaParser::RuleSubStmt;
}

void vbaParser::SubStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubStmt(this);
}

void vbaParser::SubStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubStmt(this);
}

vbaParser::SubStmtContext* vbaParser::subStmt() {
  SubStmtContext *_localctx = _tracker.createInstance<SubStmtContext>(_ctx, getState());
  enterRule(_localctx, 186, vbaParser::RuleSubStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1694);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 75) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 75)) & 4755801206503243793) != 0)) {
      setState(1691);
      visibility();
      setState(1692);
      match(vbaParser::WS);
    }
    setState(1698);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::STATIC) {
      setState(1696);
      match(vbaParser::STATIC);
      setState(1697);
      match(vbaParser::WS);
    }
    setState(1700);
    match(vbaParser::SUB);
    setState(1702);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1701);
      match(vbaParser::WS);
    }
    setState(1704);
    ambiguousIdentifier();
    setState(1709);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 246, _ctx)) {
    case 1: {
      setState(1706);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1705);
        match(vbaParser::WS);
      }
      setState(1708);
      argList();
      break;
    }

    default:
      break;
    }
    setState(1711);
    endOfStatement();
    setState(1713);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4593671619917906384) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -8646926918232309761) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 288230376151678495) != 0) || _la == vbaParser::LINE_CONTINUATION

    || _la == vbaParser::IDENTIFIER) {
      setState(1712);
      block();
    }
    setState(1715);
    match(vbaParser::END_SUB);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TimeStmtContext ------------------------------------------------------------------

vbaParser::TimeStmtContext::TimeStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::TimeStmtContext::TIME() {
  return getToken(vbaParser::TIME, 0);
}

tree::TerminalNode* vbaParser::TimeStmtContext::EQ() {
  return getToken(vbaParser::EQ, 0);
}

vbaParser::ValueStmtContext* vbaParser::TimeStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::TimeStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::TimeStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}


size_t vbaParser::TimeStmtContext::getRuleIndex() const {
  return vbaParser::RuleTimeStmt;
}

void vbaParser::TimeStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimeStmt(this);
}

void vbaParser::TimeStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimeStmt(this);
}

vbaParser::TimeStmtContext* vbaParser::timeStmt() {
  TimeStmtContext *_localctx = _tracker.createInstance<TimeStmtContext>(_ctx, getState());
  enterRule(_localctx, 188, vbaParser::RuleTimeStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1717);
    match(vbaParser::TIME);
    setState(1719);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1718);
      match(vbaParser::WS);
    }
    setState(1721);
    match(vbaParser::EQ);
    setState(1723);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(1722);
      match(vbaParser::WS);
    }
    setState(1725);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeStmtContext ------------------------------------------------------------------

vbaParser::TypeStmtContext::TypeStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::TypeStmtContext::TYPE() {
  return getToken(vbaParser::TYPE, 0);
}

std::vector<tree::TerminalNode *> vbaParser::TypeStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::TypeStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::AmbiguousIdentifierContext* vbaParser::TypeStmtContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

vbaParser::EndOfStatementContext* vbaParser::TypeStmtContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

tree::TerminalNode* vbaParser::TypeStmtContext::END_TYPE() {
  return getToken(vbaParser::END_TYPE, 0);
}

vbaParser::VisibilityContext* vbaParser::TypeStmtContext::visibility() {
  return getRuleContext<vbaParser::VisibilityContext>(0);
}

std::vector<vbaParser::TypeStmt_ElementContext *> vbaParser::TypeStmtContext::typeStmt_Element() {
  return getRuleContexts<vbaParser::TypeStmt_ElementContext>();
}

vbaParser::TypeStmt_ElementContext* vbaParser::TypeStmtContext::typeStmt_Element(size_t i) {
  return getRuleContext<vbaParser::TypeStmt_ElementContext>(i);
}


size_t vbaParser::TypeStmtContext::getRuleIndex() const {
  return vbaParser::RuleTypeStmt;
}

void vbaParser::TypeStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeStmt(this);
}

void vbaParser::TypeStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeStmt(this);
}

vbaParser::TypeStmtContext* vbaParser::typeStmt() {
  TypeStmtContext *_localctx = _tracker.createInstance<TypeStmtContext>(_ctx, getState());
  enterRule(_localctx, 190, vbaParser::RuleTypeStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1730);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 75) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 75)) & 4755801206503243793) != 0)) {
      setState(1727);
      visibility();
      setState(1728);
      match(vbaParser::WS);
    }
    setState(1732);
    match(vbaParser::TYPE);
    setState(1733);
    match(vbaParser::WS);
    setState(1734);
    ambiguousIdentifier();
    setState(1735);
    endOfStatement();
    setState(1739);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4593671619917906432) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -8755014975736513009) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 288230376151678495) != 0) || _la == vbaParser::IDENTIFIER) {
      setState(1736);
      typeStmt_Element();
      setState(1741);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1742);
    match(vbaParser::END_TYPE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeStmt_ElementContext ------------------------------------------------------------------

vbaParser::TypeStmt_ElementContext::TypeStmt_ElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::AmbiguousIdentifierContext* vbaParser::TypeStmt_ElementContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

vbaParser::EndOfStatementContext* vbaParser::TypeStmt_ElementContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

tree::TerminalNode* vbaParser::TypeStmt_ElementContext::LPAREN() {
  return getToken(vbaParser::LPAREN, 0);
}

tree::TerminalNode* vbaParser::TypeStmt_ElementContext::RPAREN() {
  return getToken(vbaParser::RPAREN, 0);
}

std::vector<tree::TerminalNode *> vbaParser::TypeStmt_ElementContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::TypeStmt_ElementContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::AsTypeClauseContext* vbaParser::TypeStmt_ElementContext::asTypeClause() {
  return getRuleContext<vbaParser::AsTypeClauseContext>(0);
}

vbaParser::SubscriptsContext* vbaParser::TypeStmt_ElementContext::subscripts() {
  return getRuleContext<vbaParser::SubscriptsContext>(0);
}


size_t vbaParser::TypeStmt_ElementContext::getRuleIndex() const {
  return vbaParser::RuleTypeStmt_Element;
}

void vbaParser::TypeStmt_ElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeStmt_Element(this);
}

void vbaParser::TypeStmt_ElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeStmt_Element(this);
}

vbaParser::TypeStmt_ElementContext* vbaParser::typeStmt_Element() {
  TypeStmt_ElementContext *_localctx = _tracker.createInstance<TypeStmt_ElementContext>(_ctx, getState());
  enterRule(_localctx, 192, vbaParser::RuleTypeStmt_Element);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1744);
    ambiguousIdentifier();
    setState(1759);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 256, _ctx)) {
    case 1: {
      setState(1746);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1745);
        match(vbaParser::WS);
      }
      setState(1748);
      match(vbaParser::LPAREN);
      setState(1753);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 254, _ctx)) {
      case 1: {
        setState(1750);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(1749);
          match(vbaParser::WS);
        }
        setState(1752);
        subscripts();
        break;
      }

      default:
        break;
      }
      setState(1756);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1755);
        match(vbaParser::WS);
      }
      setState(1758);
      match(vbaParser::RPAREN);
      break;
    }

    default:
      break;
    }
    setState(1763);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 257, _ctx)) {
    case 1: {
      setState(1761);
      match(vbaParser::WS);
      setState(1762);
      asTypeClause();
      break;
    }

    default:
      break;
    }
    setState(1765);
    endOfStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeOfStmtContext ------------------------------------------------------------------

vbaParser::TypeOfStmtContext::TypeOfStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::TypeOfStmtContext::TYPEOF() {
  return getToken(vbaParser::TYPEOF, 0);
}

std::vector<tree::TerminalNode *> vbaParser::TypeOfStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::TypeOfStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::ValueStmtContext* vbaParser::TypeOfStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

tree::TerminalNode* vbaParser::TypeOfStmtContext::IS() {
  return getToken(vbaParser::IS, 0);
}

vbaParser::Type_Context* vbaParser::TypeOfStmtContext::type_() {
  return getRuleContext<vbaParser::Type_Context>(0);
}


size_t vbaParser::TypeOfStmtContext::getRuleIndex() const {
  return vbaParser::RuleTypeOfStmt;
}

void vbaParser::TypeOfStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeOfStmt(this);
}

void vbaParser::TypeOfStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeOfStmt(this);
}

vbaParser::TypeOfStmtContext* vbaParser::typeOfStmt() {
  TypeOfStmtContext *_localctx = _tracker.createInstance<TypeOfStmtContext>(_ctx, getState());
  enterRule(_localctx, 194, vbaParser::RuleTypeOfStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1767);
    match(vbaParser::TYPEOF);
    setState(1768);
    match(vbaParser::WS);
    setState(1769);
    valueStmt(0);
    setState(1774);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 258, _ctx)) {
    case 1: {
      setState(1770);
      match(vbaParser::WS);
      setState(1771);
      match(vbaParser::IS);
      setState(1772);
      match(vbaParser::WS);
      setState(1773);
      type_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnloadStmtContext ------------------------------------------------------------------

vbaParser::UnloadStmtContext::UnloadStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::UnloadStmtContext::UNLOAD() {
  return getToken(vbaParser::UNLOAD, 0);
}

tree::TerminalNode* vbaParser::UnloadStmtContext::WS() {
  return getToken(vbaParser::WS, 0);
}

vbaParser::ValueStmtContext* vbaParser::UnloadStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}


size_t vbaParser::UnloadStmtContext::getRuleIndex() const {
  return vbaParser::RuleUnloadStmt;
}

void vbaParser::UnloadStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnloadStmt(this);
}

void vbaParser::UnloadStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnloadStmt(this);
}

vbaParser::UnloadStmtContext* vbaParser::unloadStmt() {
  UnloadStmtContext *_localctx = _tracker.createInstance<UnloadStmtContext>(_ctx, getState());
  enterRule(_localctx, 196, vbaParser::RuleUnloadStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1776);
    match(vbaParser::UNLOAD);
    setState(1777);
    match(vbaParser::WS);
    setState(1778);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnlockStmtContext ------------------------------------------------------------------

vbaParser::UnlockStmtContext::UnlockStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::UnlockStmtContext::UNLOCK() {
  return getToken(vbaParser::UNLOCK, 0);
}

std::vector<tree::TerminalNode *> vbaParser::UnlockStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::UnlockStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::FileNumberContext* vbaParser::UnlockStmtContext::fileNumber() {
  return getRuleContext<vbaParser::FileNumberContext>(0);
}

std::vector<vbaParser::ValueStmtContext *> vbaParser::UnlockStmtContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::UnlockStmtContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

tree::TerminalNode* vbaParser::UnlockStmtContext::TO() {
  return getToken(vbaParser::TO, 0);
}


size_t vbaParser::UnlockStmtContext::getRuleIndex() const {
  return vbaParser::RuleUnlockStmt;
}

void vbaParser::UnlockStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnlockStmt(this);
}

void vbaParser::UnlockStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnlockStmt(this);
}

vbaParser::UnlockStmtContext* vbaParser::unlockStmt() {
  UnlockStmtContext *_localctx = _tracker.createInstance<UnlockStmtContext>(_ctx, getState());
  enterRule(_localctx, 198, vbaParser::RuleUnlockStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1780);
    match(vbaParser::UNLOCK);
    setState(1781);
    match(vbaParser::WS);
    setState(1782);
    fileNumber();
    setState(1797);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 262, _ctx)) {
    case 1: {
      setState(1784);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1783);
        match(vbaParser::WS);
      }
      setState(1786);
      match(vbaParser::T__0);
      setState(1788);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1787);
        match(vbaParser::WS);
      }
      setState(1790);
      valueStmt(0);
      setState(1795);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 261, _ctx)) {
      case 1: {
        setState(1791);
        match(vbaParser::WS);
        setState(1792);
        match(vbaParser::TO);
        setState(1793);
        match(vbaParser::WS);
        setState(1794);
        valueStmt(0);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueStmtContext ------------------------------------------------------------------

vbaParser::ValueStmtContext::ValueStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t vbaParser::ValueStmtContext::getRuleIndex() const {
  return vbaParser::RuleValueStmt;
}

void vbaParser::ValueStmtContext::copyFrom(ValueStmtContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- VsAssignContext ------------------------------------------------------------------

vbaParser::ImplicitCallStmt_InStmtContext* vbaParser::VsAssignContext::implicitCallStmt_InStmt() {
  return getRuleContext<vbaParser::ImplicitCallStmt_InStmtContext>(0);
}

tree::TerminalNode* vbaParser::VsAssignContext::ASSIGN() {
  return getToken(vbaParser::ASSIGN, 0);
}

vbaParser::ValueStmtContext* vbaParser::VsAssignContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::VsAssignContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::VsAssignContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::VsAssignContext::VsAssignContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsAssignContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsAssign(this);
}
void vbaParser::VsAssignContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsAssign(this);
}
//----------------- VsPlusContext ------------------------------------------------------------------

tree::TerminalNode* vbaParser::VsPlusContext::PLUS() {
  return getToken(vbaParser::PLUS, 0);
}

vbaParser::ValueStmtContext* vbaParser::VsPlusContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

tree::TerminalNode* vbaParser::VsPlusContext::WS() {
  return getToken(vbaParser::WS, 0);
}

vbaParser::VsPlusContext::VsPlusContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsPlusContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsPlus(this);
}
void vbaParser::VsPlusContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsPlus(this);
}
//----------------- VsNotContext ------------------------------------------------------------------

tree::TerminalNode* vbaParser::VsNotContext::NOT() {
  return getToken(vbaParser::NOT, 0);
}

vbaParser::ValueStmtContext* vbaParser::VsNotContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

tree::TerminalNode* vbaParser::VsNotContext::WS() {
  return getToken(vbaParser::WS, 0);
}

vbaParser::VsNotContext::VsNotContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsNotContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsNot(this);
}
void vbaParser::VsNotContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsNot(this);
}
//----------------- VsStructContext ------------------------------------------------------------------

tree::TerminalNode* vbaParser::VsStructContext::LPAREN() {
  return getToken(vbaParser::LPAREN, 0);
}

std::vector<vbaParser::ValueStmtContext *> vbaParser::VsStructContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::VsStructContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

tree::TerminalNode* vbaParser::VsStructContext::RPAREN() {
  return getToken(vbaParser::RPAREN, 0);
}

std::vector<tree::TerminalNode *> vbaParser::VsStructContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::VsStructContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::VsStructContext::VsStructContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsStructContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsStruct(this);
}
void vbaParser::VsStructContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsStruct(this);
}
//----------------- VsTypeOfContext ------------------------------------------------------------------

vbaParser::TypeOfStmtContext* vbaParser::VsTypeOfContext::typeOfStmt() {
  return getRuleContext<vbaParser::TypeOfStmtContext>(0);
}

vbaParser::VsTypeOfContext::VsTypeOfContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsTypeOfContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsTypeOf(this);
}
void vbaParser::VsTypeOfContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsTypeOf(this);
}
//----------------- VsICSContext ------------------------------------------------------------------

vbaParser::ImplicitCallStmt_InStmtContext* vbaParser::VsICSContext::implicitCallStmt_InStmt() {
  return getRuleContext<vbaParser::ImplicitCallStmt_InStmtContext>(0);
}

vbaParser::VsICSContext::VsICSContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsICSContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsICS(this);
}
void vbaParser::VsICSContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsICS(this);
}
//----------------- VsRelationalContext ------------------------------------------------------------------

std::vector<vbaParser::ValueStmtContext *> vbaParser::VsRelationalContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::VsRelationalContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

tree::TerminalNode* vbaParser::VsRelationalContext::IS() {
  return getToken(vbaParser::IS, 0);
}

tree::TerminalNode* vbaParser::VsRelationalContext::LIKE() {
  return getToken(vbaParser::LIKE, 0);
}

tree::TerminalNode* vbaParser::VsRelationalContext::GEQ() {
  return getToken(vbaParser::GEQ, 0);
}

tree::TerminalNode* vbaParser::VsRelationalContext::LEQ() {
  return getToken(vbaParser::LEQ, 0);
}

tree::TerminalNode* vbaParser::VsRelationalContext::GT() {
  return getToken(vbaParser::GT, 0);
}

tree::TerminalNode* vbaParser::VsRelationalContext::LT() {
  return getToken(vbaParser::LT, 0);
}

tree::TerminalNode* vbaParser::VsRelationalContext::NEQ() {
  return getToken(vbaParser::NEQ, 0);
}

tree::TerminalNode* vbaParser::VsRelationalContext::EQ() {
  return getToken(vbaParser::EQ, 0);
}

std::vector<tree::TerminalNode *> vbaParser::VsRelationalContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::VsRelationalContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::VsRelationalContext::VsRelationalContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsRelationalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsRelational(this);
}
void vbaParser::VsRelationalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsRelational(this);
}
//----------------- VsAddMinusContext ------------------------------------------------------------------

std::vector<vbaParser::ValueStmtContext *> vbaParser::VsAddMinusContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::VsAddMinusContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

tree::TerminalNode* vbaParser::VsAddMinusContext::PLUS() {
  return getToken(vbaParser::PLUS, 0);
}

tree::TerminalNode* vbaParser::VsAddMinusContext::MINUS() {
  return getToken(vbaParser::MINUS, 0);
}

std::vector<tree::TerminalNode *> vbaParser::VsAddMinusContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::VsAddMinusContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::VsAddMinusContext::VsAddMinusContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsAddMinusContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsAddMinus(this);
}
void vbaParser::VsAddMinusContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsAddMinus(this);
}
//----------------- VsXorContext ------------------------------------------------------------------

std::vector<vbaParser::ValueStmtContext *> vbaParser::VsXorContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::VsXorContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

tree::TerminalNode* vbaParser::VsXorContext::XOR() {
  return getToken(vbaParser::XOR, 0);
}

std::vector<tree::TerminalNode *> vbaParser::VsXorContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::VsXorContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::VsXorContext::VsXorContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsXorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsXor(this);
}
void vbaParser::VsXorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsXor(this);
}
//----------------- VsDivMultContext ------------------------------------------------------------------

std::vector<vbaParser::ValueStmtContext *> vbaParser::VsDivMultContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::VsDivMultContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

tree::TerminalNode* vbaParser::VsDivMultContext::DIV() {
  return getToken(vbaParser::DIV, 0);
}

tree::TerminalNode* vbaParser::VsDivMultContext::MULT() {
  return getToken(vbaParser::MULT, 0);
}

std::vector<tree::TerminalNode *> vbaParser::VsDivMultContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::VsDivMultContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::VsDivMultContext::VsDivMultContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsDivMultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsDivMult(this);
}
void vbaParser::VsDivMultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsDivMult(this);
}
//----------------- VsAndContext ------------------------------------------------------------------

std::vector<vbaParser::ValueStmtContext *> vbaParser::VsAndContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::VsAndContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

tree::TerminalNode* vbaParser::VsAndContext::AND() {
  return getToken(vbaParser::AND, 0);
}

std::vector<tree::TerminalNode *> vbaParser::VsAndContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::VsAndContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::VsAndContext::VsAndContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsAndContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsAnd(this);
}
void vbaParser::VsAndContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsAnd(this);
}
//----------------- VsPowContext ------------------------------------------------------------------

std::vector<vbaParser::ValueStmtContext *> vbaParser::VsPowContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::VsPowContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

tree::TerminalNode* vbaParser::VsPowContext::POW() {
  return getToken(vbaParser::POW, 0);
}

std::vector<tree::TerminalNode *> vbaParser::VsPowContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::VsPowContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::VsPowContext::VsPowContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsPowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsPow(this);
}
void vbaParser::VsPowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsPow(this);
}
//----------------- VsModContext ------------------------------------------------------------------

std::vector<vbaParser::ValueStmtContext *> vbaParser::VsModContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::VsModContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

tree::TerminalNode* vbaParser::VsModContext::MOD() {
  return getToken(vbaParser::MOD, 0);
}

std::vector<tree::TerminalNode *> vbaParser::VsModContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::VsModContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::VsModContext::VsModContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsModContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsMod(this);
}
void vbaParser::VsModContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsMod(this);
}
//----------------- VsAmpContext ------------------------------------------------------------------

std::vector<vbaParser::ValueStmtContext *> vbaParser::VsAmpContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::VsAmpContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

tree::TerminalNode* vbaParser::VsAmpContext::AMPERSAND() {
  return getToken(vbaParser::AMPERSAND, 0);
}

std::vector<tree::TerminalNode *> vbaParser::VsAmpContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::VsAmpContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::VsAmpContext::VsAmpContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsAmpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsAmp(this);
}
void vbaParser::VsAmpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsAmp(this);
}
//----------------- VsAddressOfContext ------------------------------------------------------------------

tree::TerminalNode* vbaParser::VsAddressOfContext::ADDRESSOF() {
  return getToken(vbaParser::ADDRESSOF, 0);
}

vbaParser::ValueStmtContext* vbaParser::VsAddressOfContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

tree::TerminalNode* vbaParser::VsAddressOfContext::WS() {
  return getToken(vbaParser::WS, 0);
}

vbaParser::VsAddressOfContext::VsAddressOfContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsAddressOfContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsAddressOf(this);
}
void vbaParser::VsAddressOfContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsAddressOf(this);
}
//----------------- VsNewContext ------------------------------------------------------------------

tree::TerminalNode* vbaParser::VsNewContext::NEW() {
  return getToken(vbaParser::NEW, 0);
}

vbaParser::ValueStmtContext* vbaParser::VsNewContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

tree::TerminalNode* vbaParser::VsNewContext::WS() {
  return getToken(vbaParser::WS, 0);
}

vbaParser::VsNewContext::VsNewContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsNewContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsNew(this);
}
void vbaParser::VsNewContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsNew(this);
}
//----------------- VsOrContext ------------------------------------------------------------------

std::vector<vbaParser::ValueStmtContext *> vbaParser::VsOrContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::VsOrContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

tree::TerminalNode* vbaParser::VsOrContext::OR() {
  return getToken(vbaParser::OR, 0);
}

std::vector<tree::TerminalNode *> vbaParser::VsOrContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::VsOrContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::VsOrContext::VsOrContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsOrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsOr(this);
}
void vbaParser::VsOrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsOr(this);
}
//----------------- VsLiteralContext ------------------------------------------------------------------

vbaParser::LiteralContext* vbaParser::VsLiteralContext::literal() {
  return getRuleContext<vbaParser::LiteralContext>(0);
}

vbaParser::VsLiteralContext::VsLiteralContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsLiteral(this);
}
void vbaParser::VsLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsLiteral(this);
}
//----------------- VsEqvContext ------------------------------------------------------------------

std::vector<vbaParser::ValueStmtContext *> vbaParser::VsEqvContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::VsEqvContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

tree::TerminalNode* vbaParser::VsEqvContext::EQV() {
  return getToken(vbaParser::EQV, 0);
}

std::vector<tree::TerminalNode *> vbaParser::VsEqvContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::VsEqvContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::VsEqvContext::VsEqvContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsEqvContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsEqv(this);
}
void vbaParser::VsEqvContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsEqv(this);
}
//----------------- VsNegationContext ------------------------------------------------------------------

tree::TerminalNode* vbaParser::VsNegationContext::MINUS() {
  return getToken(vbaParser::MINUS, 0);
}

vbaParser::ValueStmtContext* vbaParser::VsNegationContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

tree::TerminalNode* vbaParser::VsNegationContext::WS() {
  return getToken(vbaParser::WS, 0);
}

vbaParser::VsNegationContext::VsNegationContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsNegationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsNegation(this);
}
void vbaParser::VsNegationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsNegation(this);
}
//----------------- VsImpContext ------------------------------------------------------------------

std::vector<vbaParser::ValueStmtContext *> vbaParser::VsImpContext::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::VsImpContext::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

tree::TerminalNode* vbaParser::VsImpContext::IMP() {
  return getToken(vbaParser::IMP, 0);
}

std::vector<tree::TerminalNode *> vbaParser::VsImpContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::VsImpContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::VsImpContext::VsImpContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsImpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsImp(this);
}
void vbaParser::VsImpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsImp(this);
}
//----------------- VsMidContext ------------------------------------------------------------------

vbaParser::MidStmtContext* vbaParser::VsMidContext::midStmt() {
  return getRuleContext<vbaParser::MidStmtContext>(0);
}

vbaParser::VsMidContext::VsMidContext(ValueStmtContext *ctx) { copyFrom(ctx); }

void vbaParser::VsMidContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVsMid(this);
}
void vbaParser::VsMidContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVsMid(this);
}

vbaParser::ValueStmtContext* vbaParser::valueStmt() {
   return valueStmt(0);
}

vbaParser::ValueStmtContext* vbaParser::valueStmt(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  vbaParser::ValueStmtContext *_localctx = _tracker.createInstance<ValueStmtContext>(_ctx, parentState);
  vbaParser::ValueStmtContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 200;
  enterRecursionRule(_localctx, 200, vbaParser::RuleValueStmt, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1859);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 274, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<VsLiteralContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(1800);
      literal();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<VsICSContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1801);
      implicitCallStmt_InStmt();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<VsStructContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1802);
      match(vbaParser::LPAREN);
      setState(1804);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1803);
        match(vbaParser::WS);
      }
      setState(1806);
      valueStmt(0);
      setState(1817);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == vbaParser::T__0 || _la == vbaParser::WS) {
        setState(1808);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(1807);
          match(vbaParser::WS);
        }
        setState(1810);
        match(vbaParser::T__0);
        setState(1812);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(1811);
          match(vbaParser::WS);
        }
        setState(1814);
        valueStmt(0);
        setState(1819);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1820);
      match(vbaParser::RPAREN);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<VsNewContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1822);
      match(vbaParser::NEW);
      setState(1824);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1823);
        match(vbaParser::WS);
      }
      setState(1826);
      valueStmt(19);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<VsTypeOfContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1827);
      typeOfStmt();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<VsMidContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1828);
      midStmt();
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<VsAddressOfContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1829);
      match(vbaParser::ADDRESSOF);
      setState(1831);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1830);
        match(vbaParser::WS);
      }
      setState(1833);
      valueStmt(16);
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<VsAssignContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1834);
      implicitCallStmt_InStmt();
      setState(1836);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1835);
        match(vbaParser::WS);
      }
      setState(1838);
      match(vbaParser::ASSIGN);
      setState(1840);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1839);
        match(vbaParser::WS);
      }
      setState(1842);
      valueStmt(15);
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<VsNegationContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1844);
      match(vbaParser::MINUS);
      setState(1846);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1845);
        match(vbaParser::WS);
      }
      setState(1848);
      valueStmt(13);
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<VsPlusContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1849);
      match(vbaParser::PLUS);
      setState(1851);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1850);
        match(vbaParser::WS);
      }
      setState(1853);
      valueStmt(12);
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<VsNotContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1854);
      match(vbaParser::NOT);
      setState(1856);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1855);
        match(vbaParser::WS);
      }
      setState(1858);
      valueStmt(6);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(1962);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 298, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(1960);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 297, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<VsPowContext>(_tracker.createInstance<ValueStmtContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleValueStmt);
          setState(1861);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(1863);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1862);
            match(vbaParser::WS);
          }
          setState(1865);
          match(vbaParser::POW);
          setState(1867);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1866);
            match(vbaParser::WS);
          }
          setState(1869);
          valueStmt(15);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<VsDivMultContext>(_tracker.createInstance<ValueStmtContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleValueStmt);
          setState(1870);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(1872);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1871);
            match(vbaParser::WS);
          }
          setState(1874);
          _la = _input->LA(1);
          if (!(_la == vbaParser::DIV

          || _la == vbaParser::MULT)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1876);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1875);
            match(vbaParser::WS);
          }
          setState(1878);
          valueStmt(12);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<VsModContext>(_tracker.createInstance<ValueStmtContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleValueStmt);
          setState(1879);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(1881);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1880);
            match(vbaParser::WS);
          }
          setState(1883);
          match(vbaParser::MOD);
          setState(1885);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1884);
            match(vbaParser::WS);
          }
          setState(1887);
          valueStmt(11);
          break;
        }

        case 4: {
          auto newContext = _tracker.createInstance<VsAddMinusContext>(_tracker.createInstance<ValueStmtContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleValueStmt);
          setState(1888);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(1890);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1889);
            match(vbaParser::WS);
          }
          setState(1892);
          _la = _input->LA(1);
          if (!(_la == vbaParser::MINUS

          || _la == vbaParser::PLUS)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1894);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1893);
            match(vbaParser::WS);
          }
          setState(1896);
          valueStmt(10);
          break;
        }

        case 5: {
          auto newContext = _tracker.createInstance<VsAmpContext>(_tracker.createInstance<ValueStmtContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleValueStmt);
          setState(1897);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(1899);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1898);
            match(vbaParser::WS);
          }
          setState(1901);
          match(vbaParser::AMPERSAND);
          setState(1903);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1902);
            match(vbaParser::WS);
          }
          setState(1905);
          valueStmt(9);
          break;
        }

        case 6: {
          auto newContext = _tracker.createInstance<VsRelationalContext>(_tracker.createInstance<ValueStmtContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleValueStmt);
          setState(1906);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(1908);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1907);
            match(vbaParser::WS);
          }
          setState(1910);
          _la = _input->LA(1);
          if (!(_la == vbaParser::IS

          || _la == vbaParser::LIKE || ((((_la - 189) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 189)) & 559) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1912);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1911);
            match(vbaParser::WS);
          }
          setState(1914);
          valueStmt(8);
          break;
        }

        case 7: {
          auto newContext = _tracker.createInstance<VsAndContext>(_tracker.createInstance<ValueStmtContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleValueStmt);
          setState(1915);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(1917);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1916);
            match(vbaParser::WS);
          }
          setState(1919);
          match(vbaParser::AND);
          setState(1921);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1920);
            match(vbaParser::WS);
          }
          setState(1923);
          valueStmt(6);
          break;
        }

        case 8: {
          auto newContext = _tracker.createInstance<VsOrContext>(_tracker.createInstance<ValueStmtContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleValueStmt);
          setState(1924);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(1926);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1925);
            match(vbaParser::WS);
          }
          setState(1928);
          match(vbaParser::OR);
          setState(1930);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1929);
            match(vbaParser::WS);
          }
          setState(1932);
          valueStmt(5);
          break;
        }

        case 9: {
          auto newContext = _tracker.createInstance<VsXorContext>(_tracker.createInstance<ValueStmtContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleValueStmt);
          setState(1933);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(1935);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1934);
            match(vbaParser::WS);
          }
          setState(1937);
          match(vbaParser::XOR);
          setState(1939);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1938);
            match(vbaParser::WS);
          }
          setState(1941);
          valueStmt(4);
          break;
        }

        case 10: {
          auto newContext = _tracker.createInstance<VsEqvContext>(_tracker.createInstance<ValueStmtContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleValueStmt);
          setState(1942);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(1944);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1943);
            match(vbaParser::WS);
          }
          setState(1946);
          match(vbaParser::EQV);
          setState(1948);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1947);
            match(vbaParser::WS);
          }
          setState(1950);
          valueStmt(3);
          break;
        }

        case 11: {
          auto newContext = _tracker.createInstance<VsImpContext>(_tracker.createInstance<ValueStmtContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleValueStmt);
          setState(1951);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(1953);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1952);
            match(vbaParser::WS);
          }
          setState(1955);
          match(vbaParser::IMP);
          setState(1957);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(1956);
            match(vbaParser::WS);
          }
          setState(1959);
          valueStmt(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(1964);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 298, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- VariableStmtContext ------------------------------------------------------------------

vbaParser::VariableStmtContext::VariableStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> vbaParser::VariableStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::VariableStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::VariableListStmtContext* vbaParser::VariableStmtContext::variableListStmt() {
  return getRuleContext<vbaParser::VariableListStmtContext>(0);
}

tree::TerminalNode* vbaParser::VariableStmtContext::DIM() {
  return getToken(vbaParser::DIM, 0);
}

tree::TerminalNode* vbaParser::VariableStmtContext::STATIC() {
  return getToken(vbaParser::STATIC, 0);
}

vbaParser::VisibilityContext* vbaParser::VariableStmtContext::visibility() {
  return getRuleContext<vbaParser::VisibilityContext>(0);
}

tree::TerminalNode* vbaParser::VariableStmtContext::WITHEVENTS() {
  return getToken(vbaParser::WITHEVENTS, 0);
}


size_t vbaParser::VariableStmtContext::getRuleIndex() const {
  return vbaParser::RuleVariableStmt;
}

void vbaParser::VariableStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableStmt(this);
}

void vbaParser::VariableStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableStmt(this);
}

vbaParser::VariableStmtContext* vbaParser::variableStmt() {
  VariableStmtContext *_localctx = _tracker.createInstance<VariableStmtContext>(_ctx, getState());
  enterRule(_localctx, 202, vbaParser::RuleVariableStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1968);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case vbaParser::DIM: {
        setState(1965);
        match(vbaParser::DIM);
        break;
      }

      case vbaParser::STATIC: {
        setState(1966);
        match(vbaParser::STATIC);
        break;
      }

      case vbaParser::FRIEND:
      case vbaParser::GLOBAL:
      case vbaParser::PRIVATE:
      case vbaParser::PUBLIC: {
        setState(1967);
        visibility();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1970);
    match(vbaParser::WS);
    setState(1973);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 300, _ctx)) {
    case 1: {
      setState(1971);
      match(vbaParser::WITHEVENTS);
      setState(1972);
      match(vbaParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1975);
    variableListStmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableListStmtContext ------------------------------------------------------------------

vbaParser::VariableListStmtContext::VariableListStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<vbaParser::VariableSubStmtContext *> vbaParser::VariableListStmtContext::variableSubStmt() {
  return getRuleContexts<vbaParser::VariableSubStmtContext>();
}

vbaParser::VariableSubStmtContext* vbaParser::VariableListStmtContext::variableSubStmt(size_t i) {
  return getRuleContext<vbaParser::VariableSubStmtContext>(i);
}

std::vector<tree::TerminalNode *> vbaParser::VariableListStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::VariableListStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}


size_t vbaParser::VariableListStmtContext::getRuleIndex() const {
  return vbaParser::RuleVariableListStmt;
}

void vbaParser::VariableListStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableListStmt(this);
}

void vbaParser::VariableListStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableListStmt(this);
}

vbaParser::VariableListStmtContext* vbaParser::variableListStmt() {
  VariableListStmtContext *_localctx = _tracker.createInstance<VariableListStmtContext>(_ctx, getState());
  enterRule(_localctx, 204, vbaParser::RuleVariableListStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1977);
    variableSubStmt();
    setState(1988);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 303, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1979);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(1978);
          match(vbaParser::WS);
        }
        setState(1981);
        match(vbaParser::T__0);
        setState(1983);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(1982);
          match(vbaParser::WS);
        }
        setState(1985);
        variableSubStmt(); 
      }
      setState(1990);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 303, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableSubStmtContext ------------------------------------------------------------------

vbaParser::VariableSubStmtContext::VariableSubStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::AmbiguousIdentifierContext* vbaParser::VariableSubStmtContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

tree::TerminalNode* vbaParser::VariableSubStmtContext::LPAREN() {
  return getToken(vbaParser::LPAREN, 0);
}

tree::TerminalNode* vbaParser::VariableSubStmtContext::RPAREN() {
  return getToken(vbaParser::RPAREN, 0);
}

vbaParser::TypeHintContext* vbaParser::VariableSubStmtContext::typeHint() {
  return getRuleContext<vbaParser::TypeHintContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::VariableSubStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::VariableSubStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::AsTypeClauseContext* vbaParser::VariableSubStmtContext::asTypeClause() {
  return getRuleContext<vbaParser::AsTypeClauseContext>(0);
}

vbaParser::SubscriptsContext* vbaParser::VariableSubStmtContext::subscripts() {
  return getRuleContext<vbaParser::SubscriptsContext>(0);
}


size_t vbaParser::VariableSubStmtContext::getRuleIndex() const {
  return vbaParser::RuleVariableSubStmt;
}

void vbaParser::VariableSubStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableSubStmt(this);
}

void vbaParser::VariableSubStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableSubStmt(this);
}

vbaParser::VariableSubStmtContext* vbaParser::variableSubStmt() {
  VariableSubStmtContext *_localctx = _tracker.createInstance<VariableSubStmtContext>(_ctx, getState());
  enterRule(_localctx, 206, vbaParser::RuleVariableSubStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1991);
    ambiguousIdentifier();
    setState(2009);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 309, _ctx)) {
    case 1: {
      setState(1993);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1992);
        match(vbaParser::WS);
      }
      setState(1995);
      match(vbaParser::LPAREN);
      setState(1997);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(1996);
        match(vbaParser::WS);
      }
      setState(2003);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -4593671619917906384) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & -8755014975736513009) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & 288230376151678495) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & 135262277) != 0)) {
        setState(1999);
        subscripts();
        setState(2001);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(2000);
          match(vbaParser::WS);
        }
      }
      setState(2005);
      match(vbaParser::RPAREN);
      setState(2007);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 308, _ctx)) {
      case 1: {
        setState(2006);
        match(vbaParser::WS);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    setState(2012);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 310, _ctx)) {
    case 1: {
      setState(2011);
      typeHint();
      break;
    }

    default:
      break;
    }
    setState(2016);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 311, _ctx)) {
    case 1: {
      setState(2014);
      match(vbaParser::WS);
      setState(2015);
      asTypeClause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhileWendStmtContext ------------------------------------------------------------------

vbaParser::WhileWendStmtContext::WhileWendStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::WhileWendStmtContext::WHILE() {
  return getToken(vbaParser::WHILE, 0);
}

tree::TerminalNode* vbaParser::WhileWendStmtContext::WS() {
  return getToken(vbaParser::WS, 0);
}

vbaParser::ValueStmtContext* vbaParser::WhileWendStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

vbaParser::EndOfStatementContext* vbaParser::WhileWendStmtContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

tree::TerminalNode* vbaParser::WhileWendStmtContext::WEND() {
  return getToken(vbaParser::WEND, 0);
}

vbaParser::BlockContext* vbaParser::WhileWendStmtContext::block() {
  return getRuleContext<vbaParser::BlockContext>(0);
}


size_t vbaParser::WhileWendStmtContext::getRuleIndex() const {
  return vbaParser::RuleWhileWendStmt;
}

void vbaParser::WhileWendStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhileWendStmt(this);
}

void vbaParser::WhileWendStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhileWendStmt(this);
}

vbaParser::WhileWendStmtContext* vbaParser::whileWendStmt() {
  WhileWendStmtContext *_localctx = _tracker.createInstance<WhileWendStmtContext>(_ctx, getState());
  enterRule(_localctx, 208, vbaParser::RuleWhileWendStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2018);
    match(vbaParser::WHILE);
    setState(2019);
    match(vbaParser::WS);
    setState(2020);
    valueStmt(0);
    setState(2021);
    endOfStatement();
    setState(2023);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 312, _ctx)) {
    case 1: {
      setState(2022);
      block();
      break;
    }

    default:
      break;
    }
    setState(2025);
    match(vbaParser::WEND);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WidthStmtContext ------------------------------------------------------------------

vbaParser::WidthStmtContext::WidthStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::WidthStmtContext::WIDTH() {
  return getToken(vbaParser::WIDTH, 0);
}

std::vector<tree::TerminalNode *> vbaParser::WidthStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::WidthStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::FileNumberContext* vbaParser::WidthStmtContext::fileNumber() {
  return getRuleContext<vbaParser::FileNumberContext>(0);
}

vbaParser::ValueStmtContext* vbaParser::WidthStmtContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}


size_t vbaParser::WidthStmtContext::getRuleIndex() const {
  return vbaParser::RuleWidthStmt;
}

void vbaParser::WidthStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWidthStmt(this);
}

void vbaParser::WidthStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWidthStmt(this);
}

vbaParser::WidthStmtContext* vbaParser::widthStmt() {
  WidthStmtContext *_localctx = _tracker.createInstance<WidthStmtContext>(_ctx, getState());
  enterRule(_localctx, 210, vbaParser::RuleWidthStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2027);
    match(vbaParser::WIDTH);
    setState(2028);
    match(vbaParser::WS);
    setState(2029);
    fileNumber();
    setState(2031);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(2030);
      match(vbaParser::WS);
    }
    setState(2033);
    match(vbaParser::T__0);
    setState(2035);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(2034);
      match(vbaParser::WS);
    }
    setState(2037);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WithStmtContext ------------------------------------------------------------------

vbaParser::WithStmtContext::WithStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::WithStmtContext::WITH() {
  return getToken(vbaParser::WITH, 0);
}

std::vector<tree::TerminalNode *> vbaParser::WithStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::WithStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::EndOfStatementContext* vbaParser::WithStmtContext::endOfStatement() {
  return getRuleContext<vbaParser::EndOfStatementContext>(0);
}

tree::TerminalNode* vbaParser::WithStmtContext::END_WITH() {
  return getToken(vbaParser::END_WITH, 0);
}

vbaParser::ImplicitCallStmt_InStmtContext* vbaParser::WithStmtContext::implicitCallStmt_InStmt() {
  return getRuleContext<vbaParser::ImplicitCallStmt_InStmtContext>(0);
}

vbaParser::BlockContext* vbaParser::WithStmtContext::block() {
  return getRuleContext<vbaParser::BlockContext>(0);
}

tree::TerminalNode* vbaParser::WithStmtContext::NEW() {
  return getToken(vbaParser::NEW, 0);
}

vbaParser::Type_Context* vbaParser::WithStmtContext::type_() {
  return getRuleContext<vbaParser::Type_Context>(0);
}


size_t vbaParser::WithStmtContext::getRuleIndex() const {
  return vbaParser::RuleWithStmt;
}

void vbaParser::WithStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWithStmt(this);
}

void vbaParser::WithStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWithStmt(this);
}

vbaParser::WithStmtContext* vbaParser::withStmt() {
  WithStmtContext *_localctx = _tracker.createInstance<WithStmtContext>(_ctx, getState());
  enterRule(_localctx, 212, vbaParser::RuleWithStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2039);
    match(vbaParser::WITH);
    setState(2040);
    match(vbaParser::WS);
    setState(2045);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 315, _ctx)) {
    case 1: {
      setState(2041);
      implicitCallStmt_InStmt();
      break;
    }

    case 2: {
      setState(2042);
      match(vbaParser::NEW);
      setState(2043);
      match(vbaParser::WS);
      setState(2044);
      type_();
      break;
    }

    default:
      break;
    }
    setState(2047);
    endOfStatement();
    setState(2049);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4593671619917906384) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -8646926918232309761) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 288230376151678495) != 0) || _la == vbaParser::LINE_CONTINUATION

    || _la == vbaParser::IDENTIFIER) {
      setState(2048);
      block();
    }
    setState(2051);
    match(vbaParser::END_WITH);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WriteStmtContext ------------------------------------------------------------------

vbaParser::WriteStmtContext::WriteStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::WriteStmtContext::WRITE() {
  return getToken(vbaParser::WRITE, 0);
}

std::vector<tree::TerminalNode *> vbaParser::WriteStmtContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::WriteStmtContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::FileNumberContext* vbaParser::WriteStmtContext::fileNumber() {
  return getRuleContext<vbaParser::FileNumberContext>(0);
}

vbaParser::OutputListContext* vbaParser::WriteStmtContext::outputList() {
  return getRuleContext<vbaParser::OutputListContext>(0);
}


size_t vbaParser::WriteStmtContext::getRuleIndex() const {
  return vbaParser::RuleWriteStmt;
}

void vbaParser::WriteStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWriteStmt(this);
}

void vbaParser::WriteStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWriteStmt(this);
}

vbaParser::WriteStmtContext* vbaParser::writeStmt() {
  WriteStmtContext *_localctx = _tracker.createInstance<WriteStmtContext>(_ctx, getState());
  enterRule(_localctx, 214, vbaParser::RuleWriteStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2053);
    match(vbaParser::WRITE);
    setState(2054);
    match(vbaParser::WS);
    setState(2055);
    fileNumber();
    setState(2057);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(2056);
      match(vbaParser::WS);
    }
    setState(2059);
    match(vbaParser::T__0);
    setState(2064);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 319, _ctx)) {
    case 1: {
      setState(2061);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 318, _ctx)) {
      case 1: {
        setState(2060);
        match(vbaParser::WS);
        break;
      }

      default:
        break;
      }
      setState(2063);
      outputList();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FileNumberContext ------------------------------------------------------------------

vbaParser::FileNumberContext::FileNumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::ValueStmtContext* vbaParser::FileNumberContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}


size_t vbaParser::FileNumberContext::getRuleIndex() const {
  return vbaParser::RuleFileNumber;
}

void vbaParser::FileNumberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFileNumber(this);
}

void vbaParser::FileNumberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFileNumber(this);
}

vbaParser::FileNumberContext* vbaParser::fileNumber() {
  FileNumberContext *_localctx = _tracker.createInstance<FileNumberContext>(_ctx, getState());
  enterRule(_localctx, 216, vbaParser::RuleFileNumber);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2067);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::T__2) {
      setState(2066);
      match(vbaParser::T__2);
    }
    setState(2069);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplicitCallStmtContext ------------------------------------------------------------------

vbaParser::ExplicitCallStmtContext::ExplicitCallStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::ECS_ProcedureCallContext* vbaParser::ExplicitCallStmtContext::eCS_ProcedureCall() {
  return getRuleContext<vbaParser::ECS_ProcedureCallContext>(0);
}

vbaParser::ECS_MemberProcedureCallContext* vbaParser::ExplicitCallStmtContext::eCS_MemberProcedureCall() {
  return getRuleContext<vbaParser::ECS_MemberProcedureCallContext>(0);
}


size_t vbaParser::ExplicitCallStmtContext::getRuleIndex() const {
  return vbaParser::RuleExplicitCallStmt;
}

void vbaParser::ExplicitCallStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplicitCallStmt(this);
}

void vbaParser::ExplicitCallStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplicitCallStmt(this);
}

vbaParser::ExplicitCallStmtContext* vbaParser::explicitCallStmt() {
  ExplicitCallStmtContext *_localctx = _tracker.createInstance<ExplicitCallStmtContext>(_ctx, getState());
  enterRule(_localctx, 218, vbaParser::RuleExplicitCallStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2073);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 321, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2071);
      eCS_ProcedureCall();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2072);
      eCS_MemberProcedureCall();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ECS_ProcedureCallContext ------------------------------------------------------------------

vbaParser::ECS_ProcedureCallContext::ECS_ProcedureCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::ECS_ProcedureCallContext::CALL() {
  return getToken(vbaParser::CALL, 0);
}

std::vector<tree::TerminalNode *> vbaParser::ECS_ProcedureCallContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::ECS_ProcedureCallContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::AmbiguousIdentifierContext* vbaParser::ECS_ProcedureCallContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

vbaParser::TypeHintContext* vbaParser::ECS_ProcedureCallContext::typeHint() {
  return getRuleContext<vbaParser::TypeHintContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::ECS_ProcedureCallContext::LPAREN() {
  return getTokens(vbaParser::LPAREN);
}

tree::TerminalNode* vbaParser::ECS_ProcedureCallContext::LPAREN(size_t i) {
  return getToken(vbaParser::LPAREN, i);
}

vbaParser::ArgsCallContext* vbaParser::ECS_ProcedureCallContext::argsCall() {
  return getRuleContext<vbaParser::ArgsCallContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::ECS_ProcedureCallContext::RPAREN() {
  return getTokens(vbaParser::RPAREN);
}

tree::TerminalNode* vbaParser::ECS_ProcedureCallContext::RPAREN(size_t i) {
  return getToken(vbaParser::RPAREN, i);
}

std::vector<vbaParser::SubscriptsContext *> vbaParser::ECS_ProcedureCallContext::subscripts() {
  return getRuleContexts<vbaParser::SubscriptsContext>();
}

vbaParser::SubscriptsContext* vbaParser::ECS_ProcedureCallContext::subscripts(size_t i) {
  return getRuleContext<vbaParser::SubscriptsContext>(i);
}


size_t vbaParser::ECS_ProcedureCallContext::getRuleIndex() const {
  return vbaParser::RuleECS_ProcedureCall;
}

void vbaParser::ECS_ProcedureCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterECS_ProcedureCall(this);
}

void vbaParser::ECS_ProcedureCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitECS_ProcedureCall(this);
}

vbaParser::ECS_ProcedureCallContext* vbaParser::eCS_ProcedureCall() {
  ECS_ProcedureCallContext *_localctx = _tracker.createInstance<ECS_ProcedureCallContext>(_ctx, getState());
  enterRule(_localctx, 220, vbaParser::RuleECS_ProcedureCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2075);
    match(vbaParser::CALL);
    setState(2076);
    match(vbaParser::WS);
    setState(2077);
    ambiguousIdentifier();
    setState(2079);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 322, _ctx)) {
    case 1: {
      setState(2078);
      typeHint();
      break;
    }

    default:
      break;
    }
    setState(2094);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 326, _ctx)) {
    case 1: {
      setState(2082);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(2081);
        match(vbaParser::WS);
      }
      setState(2084);
      match(vbaParser::LPAREN);
      setState(2086);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 324, _ctx)) {
      case 1: {
        setState(2085);
        match(vbaParser::WS);
        break;
      }

      default:
        break;
      }
      setState(2088);
      argsCall();
      setState(2090);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(2089);
        match(vbaParser::WS);
      }
      setState(2092);
      match(vbaParser::RPAREN);
      break;
    }

    default:
      break;
    }
    setState(2105);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 328, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2097);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(2096);
          match(vbaParser::WS);
        }
        setState(2099);
        match(vbaParser::LPAREN);
        setState(2100);
        subscripts();
        setState(2101);
        match(vbaParser::RPAREN); 
      }
      setState(2107);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 328, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ECS_MemberProcedureCallContext ------------------------------------------------------------------

vbaParser::ECS_MemberProcedureCallContext::ECS_MemberProcedureCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::ECS_MemberProcedureCallContext::CALL() {
  return getToken(vbaParser::CALL, 0);
}

std::vector<tree::TerminalNode *> vbaParser::ECS_MemberProcedureCallContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::ECS_MemberProcedureCallContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::AmbiguousIdentifierContext* vbaParser::ECS_MemberProcedureCallContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

vbaParser::ImplicitCallStmt_InStmtContext* vbaParser::ECS_MemberProcedureCallContext::implicitCallStmt_InStmt() {
  return getRuleContext<vbaParser::ImplicitCallStmt_InStmtContext>(0);
}

vbaParser::TypeHintContext* vbaParser::ECS_MemberProcedureCallContext::typeHint() {
  return getRuleContext<vbaParser::TypeHintContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::ECS_MemberProcedureCallContext::LPAREN() {
  return getTokens(vbaParser::LPAREN);
}

tree::TerminalNode* vbaParser::ECS_MemberProcedureCallContext::LPAREN(size_t i) {
  return getToken(vbaParser::LPAREN, i);
}

vbaParser::ArgsCallContext* vbaParser::ECS_MemberProcedureCallContext::argsCall() {
  return getRuleContext<vbaParser::ArgsCallContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::ECS_MemberProcedureCallContext::RPAREN() {
  return getTokens(vbaParser::RPAREN);
}

tree::TerminalNode* vbaParser::ECS_MemberProcedureCallContext::RPAREN(size_t i) {
  return getToken(vbaParser::RPAREN, i);
}

std::vector<vbaParser::SubscriptsContext *> vbaParser::ECS_MemberProcedureCallContext::subscripts() {
  return getRuleContexts<vbaParser::SubscriptsContext>();
}

vbaParser::SubscriptsContext* vbaParser::ECS_MemberProcedureCallContext::subscripts(size_t i) {
  return getRuleContext<vbaParser::SubscriptsContext>(i);
}


size_t vbaParser::ECS_MemberProcedureCallContext::getRuleIndex() const {
  return vbaParser::RuleECS_MemberProcedureCall;
}

void vbaParser::ECS_MemberProcedureCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterECS_MemberProcedureCall(this);
}

void vbaParser::ECS_MemberProcedureCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitECS_MemberProcedureCall(this);
}

vbaParser::ECS_MemberProcedureCallContext* vbaParser::eCS_MemberProcedureCall() {
  ECS_MemberProcedureCallContext *_localctx = _tracker.createInstance<ECS_MemberProcedureCallContext>(_ctx, getState());
  enterRule(_localctx, 222, vbaParser::RuleECS_MemberProcedureCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2108);
    match(vbaParser::CALL);
    setState(2109);
    match(vbaParser::WS);
    setState(2111);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 329, _ctx)) {
    case 1: {
      setState(2110);
      implicitCallStmt_InStmt();
      break;
    }

    default:
      break;
    }
    setState(2113);
    match(vbaParser::T__3);
    setState(2114);
    ambiguousIdentifier();
    setState(2116);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 330, _ctx)) {
    case 1: {
      setState(2115);
      typeHint();
      break;
    }

    default:
      break;
    }
    setState(2131);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 334, _ctx)) {
    case 1: {
      setState(2119);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(2118);
        match(vbaParser::WS);
      }
      setState(2121);
      match(vbaParser::LPAREN);
      setState(2123);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 332, _ctx)) {
      case 1: {
        setState(2122);
        match(vbaParser::WS);
        break;
      }

      default:
        break;
      }
      setState(2125);
      argsCall();
      setState(2127);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(2126);
        match(vbaParser::WS);
      }
      setState(2129);
      match(vbaParser::RPAREN);
      break;
    }

    default:
      break;
    }
    setState(2142);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 336, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2134);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(2133);
          match(vbaParser::WS);
        }
        setState(2136);
        match(vbaParser::LPAREN);
        setState(2137);
        subscripts();
        setState(2138);
        match(vbaParser::RPAREN); 
      }
      setState(2144);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 336, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImplicitCallStmt_InBlockContext ------------------------------------------------------------------

vbaParser::ImplicitCallStmt_InBlockContext::ImplicitCallStmt_InBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::ICS_B_MemberProcedureCallContext* vbaParser::ImplicitCallStmt_InBlockContext::iCS_B_MemberProcedureCall() {
  return getRuleContext<vbaParser::ICS_B_MemberProcedureCallContext>(0);
}

vbaParser::ICS_B_ProcedureCallContext* vbaParser::ImplicitCallStmt_InBlockContext::iCS_B_ProcedureCall() {
  return getRuleContext<vbaParser::ICS_B_ProcedureCallContext>(0);
}


size_t vbaParser::ImplicitCallStmt_InBlockContext::getRuleIndex() const {
  return vbaParser::RuleImplicitCallStmt_InBlock;
}

void vbaParser::ImplicitCallStmt_InBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImplicitCallStmt_InBlock(this);
}

void vbaParser::ImplicitCallStmt_InBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImplicitCallStmt_InBlock(this);
}

vbaParser::ImplicitCallStmt_InBlockContext* vbaParser::implicitCallStmt_InBlock() {
  ImplicitCallStmt_InBlockContext *_localctx = _tracker.createInstance<ImplicitCallStmt_InBlockContext>(_ctx, getState());
  enterRule(_localctx, 224, vbaParser::RuleImplicitCallStmt_InBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2147);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 337, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2145);
      iCS_B_MemberProcedureCall();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2146);
      iCS_B_ProcedureCall();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ICS_B_MemberProcedureCallContext ------------------------------------------------------------------

vbaParser::ICS_B_MemberProcedureCallContext::ICS_B_MemberProcedureCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::AmbiguousIdentifierContext* vbaParser::ICS_B_MemberProcedureCallContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

vbaParser::ImplicitCallStmt_InStmtContext* vbaParser::ICS_B_MemberProcedureCallContext::implicitCallStmt_InStmt() {
  return getRuleContext<vbaParser::ImplicitCallStmt_InStmtContext>(0);
}

vbaParser::TypeHintContext* vbaParser::ICS_B_MemberProcedureCallContext::typeHint() {
  return getRuleContext<vbaParser::TypeHintContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::ICS_B_MemberProcedureCallContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::ICS_B_MemberProcedureCallContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::ArgsCallContext* vbaParser::ICS_B_MemberProcedureCallContext::argsCall() {
  return getRuleContext<vbaParser::ArgsCallContext>(0);
}

vbaParser::DictionaryCallStmtContext* vbaParser::ICS_B_MemberProcedureCallContext::dictionaryCallStmt() {
  return getRuleContext<vbaParser::DictionaryCallStmtContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::ICS_B_MemberProcedureCallContext::LPAREN() {
  return getTokens(vbaParser::LPAREN);
}

tree::TerminalNode* vbaParser::ICS_B_MemberProcedureCallContext::LPAREN(size_t i) {
  return getToken(vbaParser::LPAREN, i);
}

std::vector<vbaParser::SubscriptsContext *> vbaParser::ICS_B_MemberProcedureCallContext::subscripts() {
  return getRuleContexts<vbaParser::SubscriptsContext>();
}

vbaParser::SubscriptsContext* vbaParser::ICS_B_MemberProcedureCallContext::subscripts(size_t i) {
  return getRuleContext<vbaParser::SubscriptsContext>(i);
}

std::vector<tree::TerminalNode *> vbaParser::ICS_B_MemberProcedureCallContext::RPAREN() {
  return getTokens(vbaParser::RPAREN);
}

tree::TerminalNode* vbaParser::ICS_B_MemberProcedureCallContext::RPAREN(size_t i) {
  return getToken(vbaParser::RPAREN, i);
}


size_t vbaParser::ICS_B_MemberProcedureCallContext::getRuleIndex() const {
  return vbaParser::RuleICS_B_MemberProcedureCall;
}

void vbaParser::ICS_B_MemberProcedureCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterICS_B_MemberProcedureCall(this);
}

void vbaParser::ICS_B_MemberProcedureCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitICS_B_MemberProcedureCall(this);
}

vbaParser::ICS_B_MemberProcedureCallContext* vbaParser::iCS_B_MemberProcedureCall() {
  ICS_B_MemberProcedureCallContext *_localctx = _tracker.createInstance<ICS_B_MemberProcedureCallContext>(_ctx, getState());
  enterRule(_localctx, 226, vbaParser::RuleICS_B_MemberProcedureCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2150);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 338, _ctx)) {
    case 1: {
      setState(2149);
      implicitCallStmt_InStmt();
      break;
    }

    default:
      break;
    }
    setState(2152);
    match(vbaParser::T__3);
    setState(2153);
    ambiguousIdentifier();
    setState(2155);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 339, _ctx)) {
    case 1: {
      setState(2154);
      typeHint();
      break;
    }

    default:
      break;
    }
    setState(2159);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 340, _ctx)) {
    case 1: {
      setState(2157);
      match(vbaParser::WS);
      setState(2158);
      argsCall();
      break;
    }

    default:
      break;
    }
    setState(2162);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 341, _ctx)) {
    case 1: {
      setState(2161);
      dictionaryCallStmt();
      break;
    }

    default:
      break;
    }
    setState(2173);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 343, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2165);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(2164);
          match(vbaParser::WS);
        }
        setState(2167);
        match(vbaParser::LPAREN);
        setState(2168);
        subscripts();
        setState(2169);
        match(vbaParser::RPAREN); 
      }
      setState(2175);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 343, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ICS_B_ProcedureCallContext ------------------------------------------------------------------

vbaParser::ICS_B_ProcedureCallContext::ICS_B_ProcedureCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::CertainIdentifierContext* vbaParser::ICS_B_ProcedureCallContext::certainIdentifier() {
  return getRuleContext<vbaParser::CertainIdentifierContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::ICS_B_ProcedureCallContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::ICS_B_ProcedureCallContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::ArgsCallContext* vbaParser::ICS_B_ProcedureCallContext::argsCall() {
  return getRuleContext<vbaParser::ArgsCallContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::ICS_B_ProcedureCallContext::LPAREN() {
  return getTokens(vbaParser::LPAREN);
}

tree::TerminalNode* vbaParser::ICS_B_ProcedureCallContext::LPAREN(size_t i) {
  return getToken(vbaParser::LPAREN, i);
}

std::vector<vbaParser::SubscriptsContext *> vbaParser::ICS_B_ProcedureCallContext::subscripts() {
  return getRuleContexts<vbaParser::SubscriptsContext>();
}

vbaParser::SubscriptsContext* vbaParser::ICS_B_ProcedureCallContext::subscripts(size_t i) {
  return getRuleContext<vbaParser::SubscriptsContext>(i);
}

std::vector<tree::TerminalNode *> vbaParser::ICS_B_ProcedureCallContext::RPAREN() {
  return getTokens(vbaParser::RPAREN);
}

tree::TerminalNode* vbaParser::ICS_B_ProcedureCallContext::RPAREN(size_t i) {
  return getToken(vbaParser::RPAREN, i);
}


size_t vbaParser::ICS_B_ProcedureCallContext::getRuleIndex() const {
  return vbaParser::RuleICS_B_ProcedureCall;
}

void vbaParser::ICS_B_ProcedureCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterICS_B_ProcedureCall(this);
}

void vbaParser::ICS_B_ProcedureCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitICS_B_ProcedureCall(this);
}

vbaParser::ICS_B_ProcedureCallContext* vbaParser::iCS_B_ProcedureCall() {
  ICS_B_ProcedureCallContext *_localctx = _tracker.createInstance<ICS_B_ProcedureCallContext>(_ctx, getState());
  enterRule(_localctx, 228, vbaParser::RuleICS_B_ProcedureCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2176);
    certainIdentifier();
    setState(2179);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 344, _ctx)) {
    case 1: {
      setState(2177);
      match(vbaParser::WS);
      setState(2178);
      argsCall();
      break;
    }

    default:
      break;
    }
    setState(2190);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 346, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2182);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(2181);
          match(vbaParser::WS);
        }
        setState(2184);
        match(vbaParser::LPAREN);
        setState(2185);
        subscripts();
        setState(2186);
        match(vbaParser::RPAREN); 
      }
      setState(2192);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 346, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImplicitCallStmt_InStmtContext ------------------------------------------------------------------

vbaParser::ImplicitCallStmt_InStmtContext::ImplicitCallStmt_InStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::ICS_S_MembersCallContext* vbaParser::ImplicitCallStmt_InStmtContext::iCS_S_MembersCall() {
  return getRuleContext<vbaParser::ICS_S_MembersCallContext>(0);
}

vbaParser::ICS_S_VariableOrProcedureCallContext* vbaParser::ImplicitCallStmt_InStmtContext::iCS_S_VariableOrProcedureCall() {
  return getRuleContext<vbaParser::ICS_S_VariableOrProcedureCallContext>(0);
}

vbaParser::ICS_S_ProcedureOrArrayCallContext* vbaParser::ImplicitCallStmt_InStmtContext::iCS_S_ProcedureOrArrayCall() {
  return getRuleContext<vbaParser::ICS_S_ProcedureOrArrayCallContext>(0);
}

vbaParser::ICS_S_DictionaryCallContext* vbaParser::ImplicitCallStmt_InStmtContext::iCS_S_DictionaryCall() {
  return getRuleContext<vbaParser::ICS_S_DictionaryCallContext>(0);
}


size_t vbaParser::ImplicitCallStmt_InStmtContext::getRuleIndex() const {
  return vbaParser::RuleImplicitCallStmt_InStmt;
}

void vbaParser::ImplicitCallStmt_InStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImplicitCallStmt_InStmt(this);
}

void vbaParser::ImplicitCallStmt_InStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImplicitCallStmt_InStmt(this);
}

vbaParser::ImplicitCallStmt_InStmtContext* vbaParser::implicitCallStmt_InStmt() {
  ImplicitCallStmt_InStmtContext *_localctx = _tracker.createInstance<ImplicitCallStmt_InStmtContext>(_ctx, getState());
  enterRule(_localctx, 230, vbaParser::RuleImplicitCallStmt_InStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2197);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 347, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2193);
      iCS_S_MembersCall();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2194);
      iCS_S_VariableOrProcedureCall();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2195);
      iCS_S_ProcedureOrArrayCall();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2196);
      iCS_S_DictionaryCall();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ICS_S_VariableOrProcedureCallContext ------------------------------------------------------------------

vbaParser::ICS_S_VariableOrProcedureCallContext::ICS_S_VariableOrProcedureCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::AmbiguousIdentifierContext* vbaParser::ICS_S_VariableOrProcedureCallContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

vbaParser::TypeHintContext* vbaParser::ICS_S_VariableOrProcedureCallContext::typeHint() {
  return getRuleContext<vbaParser::TypeHintContext>(0);
}

vbaParser::DictionaryCallStmtContext* vbaParser::ICS_S_VariableOrProcedureCallContext::dictionaryCallStmt() {
  return getRuleContext<vbaParser::DictionaryCallStmtContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::ICS_S_VariableOrProcedureCallContext::LPAREN() {
  return getTokens(vbaParser::LPAREN);
}

tree::TerminalNode* vbaParser::ICS_S_VariableOrProcedureCallContext::LPAREN(size_t i) {
  return getToken(vbaParser::LPAREN, i);
}

std::vector<vbaParser::SubscriptsContext *> vbaParser::ICS_S_VariableOrProcedureCallContext::subscripts() {
  return getRuleContexts<vbaParser::SubscriptsContext>();
}

vbaParser::SubscriptsContext* vbaParser::ICS_S_VariableOrProcedureCallContext::subscripts(size_t i) {
  return getRuleContext<vbaParser::SubscriptsContext>(i);
}

std::vector<tree::TerminalNode *> vbaParser::ICS_S_VariableOrProcedureCallContext::RPAREN() {
  return getTokens(vbaParser::RPAREN);
}

tree::TerminalNode* vbaParser::ICS_S_VariableOrProcedureCallContext::RPAREN(size_t i) {
  return getToken(vbaParser::RPAREN, i);
}

std::vector<tree::TerminalNode *> vbaParser::ICS_S_VariableOrProcedureCallContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::ICS_S_VariableOrProcedureCallContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}


size_t vbaParser::ICS_S_VariableOrProcedureCallContext::getRuleIndex() const {
  return vbaParser::RuleICS_S_VariableOrProcedureCall;
}

void vbaParser::ICS_S_VariableOrProcedureCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterICS_S_VariableOrProcedureCall(this);
}

void vbaParser::ICS_S_VariableOrProcedureCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitICS_S_VariableOrProcedureCall(this);
}

vbaParser::ICS_S_VariableOrProcedureCallContext* vbaParser::iCS_S_VariableOrProcedureCall() {
  ICS_S_VariableOrProcedureCallContext *_localctx = _tracker.createInstance<ICS_S_VariableOrProcedureCallContext>(_ctx, getState());
  enterRule(_localctx, 232, vbaParser::RuleICS_S_VariableOrProcedureCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2199);
    ambiguousIdentifier();
    setState(2201);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 348, _ctx)) {
    case 1: {
      setState(2200);
      typeHint();
      break;
    }

    default:
      break;
    }
    setState(2204);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 349, _ctx)) {
    case 1: {
      setState(2203);
      dictionaryCallStmt();
      break;
    }

    default:
      break;
    }
    setState(2215);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 351, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2207);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(2206);
          match(vbaParser::WS);
        }
        setState(2209);
        match(vbaParser::LPAREN);
        setState(2210);
        subscripts();
        setState(2211);
        match(vbaParser::RPAREN); 
      }
      setState(2217);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 351, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ICS_S_ProcedureOrArrayCallContext ------------------------------------------------------------------

vbaParser::ICS_S_ProcedureOrArrayCallContext::ICS_S_ProcedureOrArrayCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> vbaParser::ICS_S_ProcedureOrArrayCallContext::LPAREN() {
  return getTokens(vbaParser::LPAREN);
}

tree::TerminalNode* vbaParser::ICS_S_ProcedureOrArrayCallContext::LPAREN(size_t i) {
  return getToken(vbaParser::LPAREN, i);
}

std::vector<tree::TerminalNode *> vbaParser::ICS_S_ProcedureOrArrayCallContext::RPAREN() {
  return getTokens(vbaParser::RPAREN);
}

tree::TerminalNode* vbaParser::ICS_S_ProcedureOrArrayCallContext::RPAREN(size_t i) {
  return getToken(vbaParser::RPAREN, i);
}

vbaParser::AmbiguousIdentifierContext* vbaParser::ICS_S_ProcedureOrArrayCallContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

vbaParser::BaseTypeContext* vbaParser::ICS_S_ProcedureOrArrayCallContext::baseType() {
  return getRuleContext<vbaParser::BaseTypeContext>(0);
}

vbaParser::TypeHintContext* vbaParser::ICS_S_ProcedureOrArrayCallContext::typeHint() {
  return getRuleContext<vbaParser::TypeHintContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::ICS_S_ProcedureOrArrayCallContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::ICS_S_ProcedureOrArrayCallContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

vbaParser::ArgsCallContext* vbaParser::ICS_S_ProcedureOrArrayCallContext::argsCall() {
  return getRuleContext<vbaParser::ArgsCallContext>(0);
}

vbaParser::DictionaryCallStmtContext* vbaParser::ICS_S_ProcedureOrArrayCallContext::dictionaryCallStmt() {
  return getRuleContext<vbaParser::DictionaryCallStmtContext>(0);
}

std::vector<vbaParser::SubscriptsContext *> vbaParser::ICS_S_ProcedureOrArrayCallContext::subscripts() {
  return getRuleContexts<vbaParser::SubscriptsContext>();
}

vbaParser::SubscriptsContext* vbaParser::ICS_S_ProcedureOrArrayCallContext::subscripts(size_t i) {
  return getRuleContext<vbaParser::SubscriptsContext>(i);
}


size_t vbaParser::ICS_S_ProcedureOrArrayCallContext::getRuleIndex() const {
  return vbaParser::RuleICS_S_ProcedureOrArrayCall;
}

void vbaParser::ICS_S_ProcedureOrArrayCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterICS_S_ProcedureOrArrayCall(this);
}

void vbaParser::ICS_S_ProcedureOrArrayCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitICS_S_ProcedureOrArrayCall(this);
}

vbaParser::ICS_S_ProcedureOrArrayCallContext* vbaParser::iCS_S_ProcedureOrArrayCall() {
  ICS_S_ProcedureOrArrayCallContext *_localctx = _tracker.createInstance<ICS_S_ProcedureOrArrayCallContext>(_ctx, getState());
  enterRule(_localctx, 234, vbaParser::RuleICS_S_ProcedureOrArrayCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2220);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 352, _ctx)) {
    case 1: {
      setState(2218);
      ambiguousIdentifier();
      break;
    }

    case 2: {
      setState(2219);
      baseType();
      break;
    }

    default:
      break;
    }
    setState(2223);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 488) != 0) || _la == vbaParser::AMPERSAND) {
      setState(2222);
      typeHint();
    }
    setState(2226);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(2225);
      match(vbaParser::WS);
    }
    setState(2228);
    match(vbaParser::LPAREN);
    setState(2230);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 355, _ctx)) {
    case 1: {
      setState(2229);
      match(vbaParser::WS);
      break;
    }

    default:
      break;
    }
    setState(2236);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 357, _ctx)) {
    case 1: {
      setState(2232);
      argsCall();
      setState(2234);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(2233);
        match(vbaParser::WS);
      }
      break;
    }

    default:
      break;
    }
    setState(2238);
    match(vbaParser::RPAREN);
    setState(2240);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 358, _ctx)) {
    case 1: {
      setState(2239);
      dictionaryCallStmt();
      break;
    }

    default:
      break;
    }
    setState(2251);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 360, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2243);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(2242);
          match(vbaParser::WS);
        }
        setState(2245);
        match(vbaParser::LPAREN);
        setState(2246);
        subscripts();
        setState(2247);
        match(vbaParser::RPAREN); 
      }
      setState(2253);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 360, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ICS_S_MembersCallContext ------------------------------------------------------------------

vbaParser::ICS_S_MembersCallContext::ICS_S_MembersCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::ICS_S_VariableOrProcedureCallContext* vbaParser::ICS_S_MembersCallContext::iCS_S_VariableOrProcedureCall() {
  return getRuleContext<vbaParser::ICS_S_VariableOrProcedureCallContext>(0);
}

vbaParser::ICS_S_ProcedureOrArrayCallContext* vbaParser::ICS_S_MembersCallContext::iCS_S_ProcedureOrArrayCall() {
  return getRuleContext<vbaParser::ICS_S_ProcedureOrArrayCallContext>(0);
}

std::vector<vbaParser::ICS_S_MemberCallContext *> vbaParser::ICS_S_MembersCallContext::iCS_S_MemberCall() {
  return getRuleContexts<vbaParser::ICS_S_MemberCallContext>();
}

vbaParser::ICS_S_MemberCallContext* vbaParser::ICS_S_MembersCallContext::iCS_S_MemberCall(size_t i) {
  return getRuleContext<vbaParser::ICS_S_MemberCallContext>(i);
}

vbaParser::DictionaryCallStmtContext* vbaParser::ICS_S_MembersCallContext::dictionaryCallStmt() {
  return getRuleContext<vbaParser::DictionaryCallStmtContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::ICS_S_MembersCallContext::LPAREN() {
  return getTokens(vbaParser::LPAREN);
}

tree::TerminalNode* vbaParser::ICS_S_MembersCallContext::LPAREN(size_t i) {
  return getToken(vbaParser::LPAREN, i);
}

std::vector<vbaParser::SubscriptsContext *> vbaParser::ICS_S_MembersCallContext::subscripts() {
  return getRuleContexts<vbaParser::SubscriptsContext>();
}

vbaParser::SubscriptsContext* vbaParser::ICS_S_MembersCallContext::subscripts(size_t i) {
  return getRuleContext<vbaParser::SubscriptsContext>(i);
}

std::vector<tree::TerminalNode *> vbaParser::ICS_S_MembersCallContext::RPAREN() {
  return getTokens(vbaParser::RPAREN);
}

tree::TerminalNode* vbaParser::ICS_S_MembersCallContext::RPAREN(size_t i) {
  return getToken(vbaParser::RPAREN, i);
}

std::vector<tree::TerminalNode *> vbaParser::ICS_S_MembersCallContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::ICS_S_MembersCallContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}


size_t vbaParser::ICS_S_MembersCallContext::getRuleIndex() const {
  return vbaParser::RuleICS_S_MembersCall;
}

void vbaParser::ICS_S_MembersCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterICS_S_MembersCall(this);
}

void vbaParser::ICS_S_MembersCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitICS_S_MembersCall(this);
}

vbaParser::ICS_S_MembersCallContext* vbaParser::iCS_S_MembersCall() {
  ICS_S_MembersCallContext *_localctx = _tracker.createInstance<ICS_S_MembersCallContext>(_ctx, getState());
  enterRule(_localctx, 236, vbaParser::RuleICS_S_MembersCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2256);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 361, _ctx)) {
    case 1: {
      setState(2254);
      iCS_S_VariableOrProcedureCall();
      break;
    }

    case 2: {
      setState(2255);
      iCS_S_ProcedureOrArrayCall();
      break;
    }

    default:
      break;
    }
    setState(2259); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(2258);
              iCS_S_MemberCall();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(2261); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 362, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(2264);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 363, _ctx)) {
    case 1: {
      setState(2263);
      dictionaryCallStmt();
      break;
    }

    default:
      break;
    }
    setState(2275);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 365, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2267);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(2266);
          match(vbaParser::WS);
        }
        setState(2269);
        match(vbaParser::LPAREN);
        setState(2270);
        subscripts();
        setState(2271);
        match(vbaParser::RPAREN); 
      }
      setState(2277);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 365, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ICS_S_MemberCallContext ------------------------------------------------------------------

vbaParser::ICS_S_MemberCallContext::ICS_S_MemberCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::ICS_S_VariableOrProcedureCallContext* vbaParser::ICS_S_MemberCallContext::iCS_S_VariableOrProcedureCall() {
  return getRuleContext<vbaParser::ICS_S_VariableOrProcedureCallContext>(0);
}

vbaParser::ICS_S_ProcedureOrArrayCallContext* vbaParser::ICS_S_MemberCallContext::iCS_S_ProcedureOrArrayCall() {
  return getRuleContext<vbaParser::ICS_S_ProcedureOrArrayCallContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::ICS_S_MemberCallContext::LINE_CONTINUATION() {
  return getTokens(vbaParser::LINE_CONTINUATION);
}

tree::TerminalNode* vbaParser::ICS_S_MemberCallContext::LINE_CONTINUATION(size_t i) {
  return getToken(vbaParser::LINE_CONTINUATION, i);
}


size_t vbaParser::ICS_S_MemberCallContext::getRuleIndex() const {
  return vbaParser::RuleICS_S_MemberCall;
}

void vbaParser::ICS_S_MemberCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterICS_S_MemberCall(this);
}

void vbaParser::ICS_S_MemberCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitICS_S_MemberCall(this);
}

vbaParser::ICS_S_MemberCallContext* vbaParser::iCS_S_MemberCall() {
  ICS_S_MemberCallContext *_localctx = _tracker.createInstance<ICS_S_MemberCallContext>(_ctx, getState());
  enterRule(_localctx, 238, vbaParser::RuleICS_S_MemberCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2279);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::LINE_CONTINUATION) {
      setState(2278);
      match(vbaParser::LINE_CONTINUATION);
    }
    setState(2281);
    _la = _input->LA(1);
    if (!(_la == vbaParser::T__3

    || _la == vbaParser::T__4)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2283);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::LINE_CONTINUATION) {
      setState(2282);
      match(vbaParser::LINE_CONTINUATION);
    }
    setState(2287);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 368, _ctx)) {
    case 1: {
      setState(2285);
      iCS_S_VariableOrProcedureCall();
      break;
    }

    case 2: {
      setState(2286);
      iCS_S_ProcedureOrArrayCall();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ICS_S_DictionaryCallContext ------------------------------------------------------------------

vbaParser::ICS_S_DictionaryCallContext::ICS_S_DictionaryCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::DictionaryCallStmtContext* vbaParser::ICS_S_DictionaryCallContext::dictionaryCallStmt() {
  return getRuleContext<vbaParser::DictionaryCallStmtContext>(0);
}


size_t vbaParser::ICS_S_DictionaryCallContext::getRuleIndex() const {
  return vbaParser::RuleICS_S_DictionaryCall;
}

void vbaParser::ICS_S_DictionaryCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterICS_S_DictionaryCall(this);
}

void vbaParser::ICS_S_DictionaryCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitICS_S_DictionaryCall(this);
}

vbaParser::ICS_S_DictionaryCallContext* vbaParser::iCS_S_DictionaryCall() {
  ICS_S_DictionaryCallContext *_localctx = _tracker.createInstance<ICS_S_DictionaryCallContext>(_ctx, getState());
  enterRule(_localctx, 240, vbaParser::RuleICS_S_DictionaryCall);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2289);
    dictionaryCallStmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgsCallContext ------------------------------------------------------------------

vbaParser::ArgsCallContext::ArgsCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<vbaParser::ArgCallContext *> vbaParser::ArgsCallContext::argCall() {
  return getRuleContexts<vbaParser::ArgCallContext>();
}

vbaParser::ArgCallContext* vbaParser::ArgsCallContext::argCall(size_t i) {
  return getRuleContext<vbaParser::ArgCallContext>(i);
}

std::vector<tree::TerminalNode *> vbaParser::ArgsCallContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::ArgsCallContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}


size_t vbaParser::ArgsCallContext::getRuleIndex() const {
  return vbaParser::RuleArgsCall;
}

void vbaParser::ArgsCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgsCall(this);
}

void vbaParser::ArgsCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgsCall(this);
}

vbaParser::ArgsCallContext* vbaParser::argsCall() {
  ArgsCallContext *_localctx = _tracker.createInstance<ArgsCallContext>(_ctx, getState());
  enterRule(_localctx, 242, vbaParser::RuleArgsCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2303);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 372, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2292);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & -4593671619917906384) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & -8755014975736513009) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 128)) & 288230376151678495) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 193)) & 135262789) != 0)) {
          setState(2291);
          argCall();
        }
        setState(2295);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(2294);
          match(vbaParser::WS);
        }
        setState(2297);
        _la = _input->LA(1);
        if (!(_la == vbaParser::T__0

        || _la == vbaParser::T__1)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2299);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 371, _ctx)) {
        case 1: {
          setState(2298);
          match(vbaParser::WS);
          break;
        }

        default:
          break;
        } 
      }
      setState(2305);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 372, _ctx);
    }
    setState(2306);
    argCall();
    setState(2319);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 376, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2308);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(2307);
          match(vbaParser::WS);
        }
        setState(2310);
        _la = _input->LA(1);
        if (!(_la == vbaParser::T__0

        || _la == vbaParser::T__1)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2312);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 374, _ctx)) {
        case 1: {
          setState(2311);
          match(vbaParser::WS);
          break;
        }

        default:
          break;
        }
        setState(2315);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 375, _ctx)) {
        case 1: {
          setState(2314);
          argCall();
          break;
        }

        default:
          break;
        } 
      }
      setState(2321);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 376, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgCallContext ------------------------------------------------------------------

vbaParser::ArgCallContext::ArgCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::ValueStmtContext* vbaParser::ArgCallContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

tree::TerminalNode* vbaParser::ArgCallContext::LPAREN() {
  return getToken(vbaParser::LPAREN, 0);
}

tree::TerminalNode* vbaParser::ArgCallContext::WS() {
  return getToken(vbaParser::WS, 0);
}

tree::TerminalNode* vbaParser::ArgCallContext::RPAREN() {
  return getToken(vbaParser::RPAREN, 0);
}

tree::TerminalNode* vbaParser::ArgCallContext::BYVAL() {
  return getToken(vbaParser::BYVAL, 0);
}

tree::TerminalNode* vbaParser::ArgCallContext::BYREF() {
  return getToken(vbaParser::BYREF, 0);
}

tree::TerminalNode* vbaParser::ArgCallContext::PARAMARRAY() {
  return getToken(vbaParser::PARAMARRAY, 0);
}


size_t vbaParser::ArgCallContext::getRuleIndex() const {
  return vbaParser::RuleArgCall;
}

void vbaParser::ArgCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgCall(this);
}

void vbaParser::ArgCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgCall(this);
}

vbaParser::ArgCallContext* vbaParser::argCall() {
  ArgCallContext *_localctx = _tracker.createInstance<ArgCallContext>(_ctx, getState());
  enterRule(_localctx, 244, vbaParser::RuleArgCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2323);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 377, _ctx)) {
    case 1: {
      setState(2322);
      match(vbaParser::LPAREN);
      break;
    }

    default:
      break;
    }
    setState(2327);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 378, _ctx)) {
    case 1: {
      setState(2325);
      _la = _input->LA(1);
      if (!(_la == vbaParser::BYVAL

      || _la == vbaParser::BYREF || _la == vbaParser::PARAMARRAY)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2326);
      match(vbaParser::WS);
      break;
    }

    default:
      break;
    }
    setState(2330);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::RPAREN) {
      setState(2329);
      match(vbaParser::RPAREN);
    }
    setState(2332);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DictionaryCallStmtContext ------------------------------------------------------------------

vbaParser::DictionaryCallStmtContext::DictionaryCallStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::AmbiguousIdentifierContext* vbaParser::DictionaryCallStmtContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

vbaParser::TypeHintContext* vbaParser::DictionaryCallStmtContext::typeHint() {
  return getRuleContext<vbaParser::TypeHintContext>(0);
}


size_t vbaParser::DictionaryCallStmtContext::getRuleIndex() const {
  return vbaParser::RuleDictionaryCallStmt;
}

void vbaParser::DictionaryCallStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDictionaryCallStmt(this);
}

void vbaParser::DictionaryCallStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDictionaryCallStmt(this);
}

vbaParser::DictionaryCallStmtContext* vbaParser::dictionaryCallStmt() {
  DictionaryCallStmtContext *_localctx = _tracker.createInstance<DictionaryCallStmtContext>(_ctx, getState());
  enterRule(_localctx, 246, vbaParser::RuleDictionaryCallStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2334);
    match(vbaParser::T__4);
    setState(2335);
    ambiguousIdentifier();
    setState(2337);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 380, _ctx)) {
    case 1: {
      setState(2336);
      typeHint();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgListContext ------------------------------------------------------------------

vbaParser::ArgListContext::ArgListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::ArgListContext::LPAREN() {
  return getToken(vbaParser::LPAREN, 0);
}

tree::TerminalNode* vbaParser::ArgListContext::RPAREN() {
  return getToken(vbaParser::RPAREN, 0);
}

std::vector<vbaParser::ArgContext *> vbaParser::ArgListContext::arg() {
  return getRuleContexts<vbaParser::ArgContext>();
}

vbaParser::ArgContext* vbaParser::ArgListContext::arg(size_t i) {
  return getRuleContext<vbaParser::ArgContext>(i);
}

std::vector<tree::TerminalNode *> vbaParser::ArgListContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::ArgListContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}


size_t vbaParser::ArgListContext::getRuleIndex() const {
  return vbaParser::RuleArgList;
}

void vbaParser::ArgListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgList(this);
}

void vbaParser::ArgListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgList(this);
}

vbaParser::ArgListContext* vbaParser::argList() {
  ArgListContext *_localctx = _tracker.createInstance<ArgListContext>(_ctx, getState());
  enterRule(_localctx, 248, vbaParser::RuleArgList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2339);
    match(vbaParser::LPAREN);
    setState(2357);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 385, _ctx)) {
    case 1: {
      setState(2341);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(2340);
        match(vbaParser::WS);
      }
      setState(2343);
      arg();
      setState(2354);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 384, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2345);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(2344);
            match(vbaParser::WS);
          }
          setState(2347);
          match(vbaParser::T__0);
          setState(2349);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(2348);
            match(vbaParser::WS);
          }
          setState(2351);
          arg(); 
        }
        setState(2356);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 384, _ctx);
      }
      break;
    }

    default:
      break;
    }
    setState(2360);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(2359);
      match(vbaParser::WS);
    }
    setState(2362);
    match(vbaParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgContext ------------------------------------------------------------------

vbaParser::ArgContext::ArgContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::AmbiguousIdentifierContext* vbaParser::ArgContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

tree::TerminalNode* vbaParser::ArgContext::OPTIONAL() {
  return getToken(vbaParser::OPTIONAL, 0);
}

std::vector<tree::TerminalNode *> vbaParser::ArgContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::ArgContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

tree::TerminalNode* vbaParser::ArgContext::PARAMARRAY() {
  return getToken(vbaParser::PARAMARRAY, 0);
}

vbaParser::TypeHintContext* vbaParser::ArgContext::typeHint() {
  return getRuleContext<vbaParser::TypeHintContext>(0);
}

tree::TerminalNode* vbaParser::ArgContext::LPAREN() {
  return getToken(vbaParser::LPAREN, 0);
}

tree::TerminalNode* vbaParser::ArgContext::RPAREN() {
  return getToken(vbaParser::RPAREN, 0);
}

vbaParser::AsTypeClauseContext* vbaParser::ArgContext::asTypeClause() {
  return getRuleContext<vbaParser::AsTypeClauseContext>(0);
}

vbaParser::ArgDefaultValueContext* vbaParser::ArgContext::argDefaultValue() {
  return getRuleContext<vbaParser::ArgDefaultValueContext>(0);
}

tree::TerminalNode* vbaParser::ArgContext::BYVAL() {
  return getToken(vbaParser::BYVAL, 0);
}

tree::TerminalNode* vbaParser::ArgContext::BYREF() {
  return getToken(vbaParser::BYREF, 0);
}


size_t vbaParser::ArgContext::getRuleIndex() const {
  return vbaParser::RuleArg;
}

void vbaParser::ArgContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArg(this);
}

void vbaParser::ArgContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArg(this);
}

vbaParser::ArgContext* vbaParser::arg() {
  ArgContext *_localctx = _tracker.createInstance<ArgContext>(_ctx, getState());
  enterRule(_localctx, 250, vbaParser::RuleArg);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2366);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 387, _ctx)) {
    case 1: {
      setState(2364);
      match(vbaParser::OPTIONAL);
      setState(2365);
      match(vbaParser::WS);
      break;
    }

    default:
      break;
    }
    setState(2370);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 388, _ctx)) {
    case 1: {
      setState(2368);
      _la = _input->LA(1);
      if (!(_la == vbaParser::BYVAL

      || _la == vbaParser::BYREF)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2369);
      match(vbaParser::WS);
      break;
    }

    default:
      break;
    }
    setState(2374);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 389, _ctx)) {
    case 1: {
      setState(2372);
      match(vbaParser::PARAMARRAY);
      setState(2373);
      match(vbaParser::WS);
      break;
    }

    default:
      break;
    }
    setState(2376);
    ambiguousIdentifier();
    setState(2378);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 488) != 0) || _la == vbaParser::AMPERSAND) {
      setState(2377);
      typeHint();
    }
    setState(2388);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 393, _ctx)) {
    case 1: {
      setState(2381);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(2380);
        match(vbaParser::WS);
      }
      setState(2383);
      match(vbaParser::LPAREN);
      setState(2385);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(2384);
        match(vbaParser::WS);
      }
      setState(2387);
      match(vbaParser::RPAREN);
      break;
    }

    default:
      break;
    }
    setState(2394);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 395, _ctx)) {
    case 1: {
      setState(2391);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(2390);
        match(vbaParser::WS);
      }
      setState(2393);
      asTypeClause();
      break;
    }

    default:
      break;
    }
    setState(2400);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 397, _ctx)) {
    case 1: {
      setState(2397);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(2396);
        match(vbaParser::WS);
      }
      setState(2399);
      argDefaultValue();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgDefaultValueContext ------------------------------------------------------------------

vbaParser::ArgDefaultValueContext::ArgDefaultValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::ArgDefaultValueContext::EQ() {
  return getToken(vbaParser::EQ, 0);
}

vbaParser::ValueStmtContext* vbaParser::ArgDefaultValueContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

tree::TerminalNode* vbaParser::ArgDefaultValueContext::WS() {
  return getToken(vbaParser::WS, 0);
}


size_t vbaParser::ArgDefaultValueContext::getRuleIndex() const {
  return vbaParser::RuleArgDefaultValue;
}

void vbaParser::ArgDefaultValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgDefaultValue(this);
}

void vbaParser::ArgDefaultValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgDefaultValue(this);
}

vbaParser::ArgDefaultValueContext* vbaParser::argDefaultValue() {
  ArgDefaultValueContext *_localctx = _tracker.createInstance<ArgDefaultValueContext>(_ctx, getState());
  enterRule(_localctx, 252, vbaParser::RuleArgDefaultValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2402);
    match(vbaParser::EQ);
    setState(2404);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(2403);
      match(vbaParser::WS);
    }
    setState(2406);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubscriptsContext ------------------------------------------------------------------

vbaParser::SubscriptsContext::SubscriptsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<vbaParser::Subscript_Context *> vbaParser::SubscriptsContext::subscript_() {
  return getRuleContexts<vbaParser::Subscript_Context>();
}

vbaParser::Subscript_Context* vbaParser::SubscriptsContext::subscript_(size_t i) {
  return getRuleContext<vbaParser::Subscript_Context>(i);
}

std::vector<tree::TerminalNode *> vbaParser::SubscriptsContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::SubscriptsContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}


size_t vbaParser::SubscriptsContext::getRuleIndex() const {
  return vbaParser::RuleSubscripts;
}

void vbaParser::SubscriptsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubscripts(this);
}

void vbaParser::SubscriptsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubscripts(this);
}

vbaParser::SubscriptsContext* vbaParser::subscripts() {
  SubscriptsContext *_localctx = _tracker.createInstance<SubscriptsContext>(_ctx, getState());
  enterRule(_localctx, 254, vbaParser::RuleSubscripts);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2408);
    subscript_();
    setState(2419);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 401, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2410);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(2409);
          match(vbaParser::WS);
        }
        setState(2412);
        match(vbaParser::T__0);
        setState(2414);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == vbaParser::WS) {
          setState(2413);
          match(vbaParser::WS);
        }
        setState(2416);
        subscript_(); 
      }
      setState(2421);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 401, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subscript_Context ------------------------------------------------------------------

vbaParser::Subscript_Context::Subscript_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<vbaParser::ValueStmtContext *> vbaParser::Subscript_Context::valueStmt() {
  return getRuleContexts<vbaParser::ValueStmtContext>();
}

vbaParser::ValueStmtContext* vbaParser::Subscript_Context::valueStmt(size_t i) {
  return getRuleContext<vbaParser::ValueStmtContext>(i);
}

std::vector<tree::TerminalNode *> vbaParser::Subscript_Context::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::Subscript_Context::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

tree::TerminalNode* vbaParser::Subscript_Context::TO() {
  return getToken(vbaParser::TO, 0);
}


size_t vbaParser::Subscript_Context::getRuleIndex() const {
  return vbaParser::RuleSubscript_;
}

void vbaParser::Subscript_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubscript_(this);
}

void vbaParser::Subscript_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubscript_(this);
}

vbaParser::Subscript_Context* vbaParser::subscript_() {
  Subscript_Context *_localctx = _tracker.createInstance<Subscript_Context>(_ctx, getState());
  enterRule(_localctx, 256, vbaParser::RuleSubscript_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2427);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 402, _ctx)) {
    case 1: {
      setState(2422);
      valueStmt(0);
      setState(2423);
      match(vbaParser::WS);
      setState(2424);
      match(vbaParser::TO);
      setState(2425);
      match(vbaParser::WS);
      break;
    }

    default:
      break;
    }
    setState(2429);
    valueStmt(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AmbiguousIdentifierContext ------------------------------------------------------------------

vbaParser::AmbiguousIdentifierContext::AmbiguousIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> vbaParser::AmbiguousIdentifierContext::IDENTIFIER() {
  return getTokens(vbaParser::IDENTIFIER);
}

tree::TerminalNode* vbaParser::AmbiguousIdentifierContext::IDENTIFIER(size_t i) {
  return getToken(vbaParser::IDENTIFIER, i);
}

std::vector<vbaParser::AmbiguousKeywordContext *> vbaParser::AmbiguousIdentifierContext::ambiguousKeyword() {
  return getRuleContexts<vbaParser::AmbiguousKeywordContext>();
}

vbaParser::AmbiguousKeywordContext* vbaParser::AmbiguousIdentifierContext::ambiguousKeyword(size_t i) {
  return getRuleContext<vbaParser::AmbiguousKeywordContext>(i);
}


size_t vbaParser::AmbiguousIdentifierContext::getRuleIndex() const {
  return vbaParser::RuleAmbiguousIdentifier;
}

void vbaParser::AmbiguousIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAmbiguousIdentifier(this);
}

void vbaParser::AmbiguousIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAmbiguousIdentifier(this);
}

vbaParser::AmbiguousIdentifierContext* vbaParser::ambiguousIdentifier() {
  AmbiguousIdentifierContext *_localctx = _tracker.createInstance<AmbiguousIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 258, vbaParser::RuleAmbiguousIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2433); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(2433);
              _errHandler->sync(this);
              switch (_input->LA(1)) {
                case vbaParser::IDENTIFIER: {
                  setState(2431);
                  match(vbaParser::IDENTIFIER);
                  break;
                }

                case vbaParser::ACCESS:
                case vbaParser::ADDRESSOF:
                case vbaParser::ALIAS:
                case vbaParser::AND:
                case vbaParser::ATTRIBUTE:
                case vbaParser::APPACTIVATE:
                case vbaParser::APPEND:
                case vbaParser::AS:
                case vbaParser::BEGIN:
                case vbaParser::BEEP:
                case vbaParser::BINARY:
                case vbaParser::BOOLEAN:
                case vbaParser::BYVAL:
                case vbaParser::BYREF:
                case vbaParser::BYTE:
                case vbaParser::CALL:
                case vbaParser::CASE:
                case vbaParser::CHDIR:
                case vbaParser::CHDRIVE:
                case vbaParser::CLASS:
                case vbaParser::CLOSE:
                case vbaParser::COLLECTION:
                case vbaParser::CONST:
                case vbaParser::DATABASE:
                case vbaParser::DATE:
                case vbaParser::DECLARE:
                case vbaParser::DEFBOOL:
                case vbaParser::DEFBYTE:
                case vbaParser::DEFDATE:
                case vbaParser::DEFDBL:
                case vbaParser::DEFDEC:
                case vbaParser::DEFCUR:
                case vbaParser::DEFINT:
                case vbaParser::DEFLNG:
                case vbaParser::DEFOBJ:
                case vbaParser::DEFSNG:
                case vbaParser::DEFSTR:
                case vbaParser::DEFVAR:
                case vbaParser::DELETESETTING:
                case vbaParser::DIM:
                case vbaParser::DO:
                case vbaParser::DOUBLE:
                case vbaParser::EACH:
                case vbaParser::ELSE:
                case vbaParser::ELSEIF:
                case vbaParser::END:
                case vbaParser::ENUM:
                case vbaParser::EQV:
                case vbaParser::ERASE:
                case vbaParser::ERROR:
                case vbaParser::EVENT:
                case vbaParser::FALSE:
                case vbaParser::FILECOPY:
                case vbaParser::FRIEND:
                case vbaParser::FOR:
                case vbaParser::FUNCTION:
                case vbaParser::GET:
                case vbaParser::GLOBAL:
                case vbaParser::GOSUB:
                case vbaParser::GOTO:
                case vbaParser::IF:
                case vbaParser::IMP:
                case vbaParser::IMPLEMENTS:
                case vbaParser::IN:
                case vbaParser::INPUT:
                case vbaParser::IS:
                case vbaParser::INTEGER:
                case vbaParser::KILL:
                case vbaParser::LOAD:
                case vbaParser::LOCK:
                case vbaParser::LONG:
                case vbaParser::LOOP:
                case vbaParser::LEN:
                case vbaParser::LET:
                case vbaParser::LIB:
                case vbaParser::LIKE:
                case vbaParser::LSET:
                case vbaParser::ME:
                case vbaParser::MID:
                case vbaParser::MKDIR:
                case vbaParser::MOD:
                case vbaParser::NAME:
                case vbaParser::NEXT:
                case vbaParser::NEW:
                case vbaParser::NOT:
                case vbaParser::NOTHING:
                case vbaParser::NULL_:
                case vbaParser::ON:
                case vbaParser::OPEN:
                case vbaParser::OPTIONAL:
                case vbaParser::OR:
                case vbaParser::OUTPUT:
                case vbaParser::PARAMARRAY:
                case vbaParser::PRESERVE:
                case vbaParser::PRINT:
                case vbaParser::PRIVATE:
                case vbaParser::PUBLIC:
                case vbaParser::PUT:
                case vbaParser::RANDOM:
                case vbaParser::RANDOMIZE:
                case vbaParser::RAISEEVENT:
                case vbaParser::READ:
                case vbaParser::REDIM:
                case vbaParser::REM:
                case vbaParser::RESET:
                case vbaParser::RESUME:
                case vbaParser::RETURN:
                case vbaParser::RMDIR:
                case vbaParser::RSET:
                case vbaParser::SAVEPICTURE:
                case vbaParser::SAVESETTING:
                case vbaParser::SEEK:
                case vbaParser::SELECT:
                case vbaParser::SENDKEYS:
                case vbaParser::SET:
                case vbaParser::SETATTR:
                case vbaParser::SHARED:
                case vbaParser::SINGLE:
                case vbaParser::SPC:
                case vbaParser::STATIC:
                case vbaParser::STEP:
                case vbaParser::STOP:
                case vbaParser::STRING:
                case vbaParser::SUB:
                case vbaParser::TAB:
                case vbaParser::TEXT:
                case vbaParser::THEN:
                case vbaParser::TIME:
                case vbaParser::TO:
                case vbaParser::TRUE:
                case vbaParser::TYPE:
                case vbaParser::TYPEOF:
                case vbaParser::UNLOAD:
                case vbaParser::UNLOCK:
                case vbaParser::UNTIL:
                case vbaParser::VARIANT:
                case vbaParser::VERSION:
                case vbaParser::WEND:
                case vbaParser::WHILE:
                case vbaParser::WIDTH:
                case vbaParser::WITH:
                case vbaParser::WITHEVENTS:
                case vbaParser::WRITE:
                case vbaParser::XOR: {
                  setState(2432);
                  ambiguousKeyword();
                  break;
                }

              default:
                throw NoViableAltException(this);
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(2435); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 404, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AsTypeClauseContext ------------------------------------------------------------------

vbaParser::AsTypeClauseContext::AsTypeClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::AsTypeClauseContext::AS() {
  return getToken(vbaParser::AS, 0);
}

vbaParser::Type_Context* vbaParser::AsTypeClauseContext::type_() {
  return getRuleContext<vbaParser::Type_Context>(0);
}

std::vector<tree::TerminalNode *> vbaParser::AsTypeClauseContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::AsTypeClauseContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

tree::TerminalNode* vbaParser::AsTypeClauseContext::NEW() {
  return getToken(vbaParser::NEW, 0);
}

vbaParser::FieldLengthContext* vbaParser::AsTypeClauseContext::fieldLength() {
  return getRuleContext<vbaParser::FieldLengthContext>(0);
}


size_t vbaParser::AsTypeClauseContext::getRuleIndex() const {
  return vbaParser::RuleAsTypeClause;
}

void vbaParser::AsTypeClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAsTypeClause(this);
}

void vbaParser::AsTypeClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAsTypeClause(this);
}

vbaParser::AsTypeClauseContext* vbaParser::asTypeClause() {
  AsTypeClauseContext *_localctx = _tracker.createInstance<AsTypeClauseContext>(_ctx, getState());
  enterRule(_localctx, 260, vbaParser::RuleAsTypeClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2437);
    match(vbaParser::AS);
    setState(2439);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(2438);
      match(vbaParser::WS);
    }
    setState(2443);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 406, _ctx)) {
    case 1: {
      setState(2441);
      match(vbaParser::NEW);
      setState(2442);
      match(vbaParser::WS);
      break;
    }

    default:
      break;
    }
    setState(2445);
    type_();
    setState(2450);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 408, _ctx)) {
    case 1: {
      setState(2447);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(2446);
        match(vbaParser::WS);
      }
      setState(2449);
      fieldLength();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BaseTypeContext ------------------------------------------------------------------

vbaParser::BaseTypeContext::BaseTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::BaseTypeContext::BOOLEAN() {
  return getToken(vbaParser::BOOLEAN, 0);
}

tree::TerminalNode* vbaParser::BaseTypeContext::BYTE() {
  return getToken(vbaParser::BYTE, 0);
}

tree::TerminalNode* vbaParser::BaseTypeContext::COLLECTION() {
  return getToken(vbaParser::COLLECTION, 0);
}

tree::TerminalNode* vbaParser::BaseTypeContext::DATE() {
  return getToken(vbaParser::DATE, 0);
}

tree::TerminalNode* vbaParser::BaseTypeContext::DOUBLE() {
  return getToken(vbaParser::DOUBLE, 0);
}

tree::TerminalNode* vbaParser::BaseTypeContext::INTEGER() {
  return getToken(vbaParser::INTEGER, 0);
}

tree::TerminalNode* vbaParser::BaseTypeContext::LONG() {
  return getToken(vbaParser::LONG, 0);
}

tree::TerminalNode* vbaParser::BaseTypeContext::SINGLE() {
  return getToken(vbaParser::SINGLE, 0);
}

tree::TerminalNode* vbaParser::BaseTypeContext::STRING() {
  return getToken(vbaParser::STRING, 0);
}

tree::TerminalNode* vbaParser::BaseTypeContext::MULT() {
  return getToken(vbaParser::MULT, 0);
}

vbaParser::ValueStmtContext* vbaParser::BaseTypeContext::valueStmt() {
  return getRuleContext<vbaParser::ValueStmtContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::BaseTypeContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::BaseTypeContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}

tree::TerminalNode* vbaParser::BaseTypeContext::VARIANT() {
  return getToken(vbaParser::VARIANT, 0);
}


size_t vbaParser::BaseTypeContext::getRuleIndex() const {
  return vbaParser::RuleBaseType;
}

void vbaParser::BaseTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBaseType(this);
}

void vbaParser::BaseTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBaseType(this);
}

vbaParser::BaseTypeContext* vbaParser::baseType() {
  BaseTypeContext *_localctx = _tracker.createInstance<BaseTypeContext>(_ctx, getState());
  enterRule(_localctx, 262, vbaParser::RuleBaseType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2472);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case vbaParser::BOOLEAN: {
        enterOuterAlt(_localctx, 1);
        setState(2452);
        match(vbaParser::BOOLEAN);
        break;
      }

      case vbaParser::BYTE: {
        enterOuterAlt(_localctx, 2);
        setState(2453);
        match(vbaParser::BYTE);
        break;
      }

      case vbaParser::COLLECTION: {
        enterOuterAlt(_localctx, 3);
        setState(2454);
        match(vbaParser::COLLECTION);
        break;
      }

      case vbaParser::DATE: {
        enterOuterAlt(_localctx, 4);
        setState(2455);
        match(vbaParser::DATE);
        break;
      }

      case vbaParser::DOUBLE: {
        enterOuterAlt(_localctx, 5);
        setState(2456);
        match(vbaParser::DOUBLE);
        break;
      }

      case vbaParser::INTEGER: {
        enterOuterAlt(_localctx, 6);
        setState(2457);
        match(vbaParser::INTEGER);
        break;
      }

      case vbaParser::LONG: {
        enterOuterAlt(_localctx, 7);
        setState(2458);
        match(vbaParser::LONG);
        break;
      }

      case vbaParser::SINGLE: {
        enterOuterAlt(_localctx, 8);
        setState(2459);
        match(vbaParser::SINGLE);
        break;
      }

      case vbaParser::STRING: {
        enterOuterAlt(_localctx, 9);
        setState(2460);
        match(vbaParser::STRING);
        setState(2469);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 411, _ctx)) {
        case 1: {
          setState(2462);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(2461);
            match(vbaParser::WS);
          }
          setState(2464);
          match(vbaParser::MULT);
          setState(2466);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(2465);
            match(vbaParser::WS);
          }
          setState(2468);
          valueStmt(0);
          break;
        }

        default:
          break;
        }
        break;
      }

      case vbaParser::VARIANT: {
        enterOuterAlt(_localctx, 10);
        setState(2471);
        match(vbaParser::VARIANT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CertainIdentifierContext ------------------------------------------------------------------

vbaParser::CertainIdentifierContext::CertainIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> vbaParser::CertainIdentifierContext::IDENTIFIER() {
  return getTokens(vbaParser::IDENTIFIER);
}

tree::TerminalNode* vbaParser::CertainIdentifierContext::IDENTIFIER(size_t i) {
  return getToken(vbaParser::IDENTIFIER, i);
}

std::vector<vbaParser::AmbiguousKeywordContext *> vbaParser::CertainIdentifierContext::ambiguousKeyword() {
  return getRuleContexts<vbaParser::AmbiguousKeywordContext>();
}

vbaParser::AmbiguousKeywordContext* vbaParser::CertainIdentifierContext::ambiguousKeyword(size_t i) {
  return getRuleContext<vbaParser::AmbiguousKeywordContext>(i);
}


size_t vbaParser::CertainIdentifierContext::getRuleIndex() const {
  return vbaParser::RuleCertainIdentifier;
}

void vbaParser::CertainIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCertainIdentifier(this);
}

void vbaParser::CertainIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCertainIdentifier(this);
}

vbaParser::CertainIdentifierContext* vbaParser::certainIdentifier() {
  CertainIdentifierContext *_localctx = _tracker.createInstance<CertainIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 264, vbaParser::RuleCertainIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(2489);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case vbaParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(2474);
        match(vbaParser::IDENTIFIER);
        setState(2479);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 414, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2477);
            _errHandler->sync(this);
            switch (_input->LA(1)) {
              case vbaParser::ACCESS:
              case vbaParser::ADDRESSOF:
              case vbaParser::ALIAS:
              case vbaParser::AND:
              case vbaParser::ATTRIBUTE:
              case vbaParser::APPACTIVATE:
              case vbaParser::APPEND:
              case vbaParser::AS:
              case vbaParser::BEGIN:
              case vbaParser::BEEP:
              case vbaParser::BINARY:
              case vbaParser::BOOLEAN:
              case vbaParser::BYVAL:
              case vbaParser::BYREF:
              case vbaParser::BYTE:
              case vbaParser::CALL:
              case vbaParser::CASE:
              case vbaParser::CHDIR:
              case vbaParser::CHDRIVE:
              case vbaParser::CLASS:
              case vbaParser::CLOSE:
              case vbaParser::COLLECTION:
              case vbaParser::CONST:
              case vbaParser::DATABASE:
              case vbaParser::DATE:
              case vbaParser::DECLARE:
              case vbaParser::DEFBOOL:
              case vbaParser::DEFBYTE:
              case vbaParser::DEFDATE:
              case vbaParser::DEFDBL:
              case vbaParser::DEFDEC:
              case vbaParser::DEFCUR:
              case vbaParser::DEFINT:
              case vbaParser::DEFLNG:
              case vbaParser::DEFOBJ:
              case vbaParser::DEFSNG:
              case vbaParser::DEFSTR:
              case vbaParser::DEFVAR:
              case vbaParser::DELETESETTING:
              case vbaParser::DIM:
              case vbaParser::DO:
              case vbaParser::DOUBLE:
              case vbaParser::EACH:
              case vbaParser::ELSE:
              case vbaParser::ELSEIF:
              case vbaParser::END:
              case vbaParser::ENUM:
              case vbaParser::EQV:
              case vbaParser::ERASE:
              case vbaParser::ERROR:
              case vbaParser::EVENT:
              case vbaParser::FALSE:
              case vbaParser::FILECOPY:
              case vbaParser::FRIEND:
              case vbaParser::FOR:
              case vbaParser::FUNCTION:
              case vbaParser::GET:
              case vbaParser::GLOBAL:
              case vbaParser::GOSUB:
              case vbaParser::GOTO:
              case vbaParser::IF:
              case vbaParser::IMP:
              case vbaParser::IMPLEMENTS:
              case vbaParser::IN:
              case vbaParser::INPUT:
              case vbaParser::IS:
              case vbaParser::INTEGER:
              case vbaParser::KILL:
              case vbaParser::LOAD:
              case vbaParser::LOCK:
              case vbaParser::LONG:
              case vbaParser::LOOP:
              case vbaParser::LEN:
              case vbaParser::LET:
              case vbaParser::LIB:
              case vbaParser::LIKE:
              case vbaParser::LSET:
              case vbaParser::ME:
              case vbaParser::MID:
              case vbaParser::MKDIR:
              case vbaParser::MOD:
              case vbaParser::NAME:
              case vbaParser::NEXT:
              case vbaParser::NEW:
              case vbaParser::NOT:
              case vbaParser::NOTHING:
              case vbaParser::NULL_:
              case vbaParser::ON:
              case vbaParser::OPEN:
              case vbaParser::OPTIONAL:
              case vbaParser::OR:
              case vbaParser::OUTPUT:
              case vbaParser::PARAMARRAY:
              case vbaParser::PRESERVE:
              case vbaParser::PRINT:
              case vbaParser::PRIVATE:
              case vbaParser::PUBLIC:
              case vbaParser::PUT:
              case vbaParser::RANDOM:
              case vbaParser::RANDOMIZE:
              case vbaParser::RAISEEVENT:
              case vbaParser::READ:
              case vbaParser::REDIM:
              case vbaParser::REM:
              case vbaParser::RESET:
              case vbaParser::RESUME:
              case vbaParser::RETURN:
              case vbaParser::RMDIR:
              case vbaParser::RSET:
              case vbaParser::SAVEPICTURE:
              case vbaParser::SAVESETTING:
              case vbaParser::SEEK:
              case vbaParser::SELECT:
              case vbaParser::SENDKEYS:
              case vbaParser::SET:
              case vbaParser::SETATTR:
              case vbaParser::SHARED:
              case vbaParser::SINGLE:
              case vbaParser::SPC:
              case vbaParser::STATIC:
              case vbaParser::STEP:
              case vbaParser::STOP:
              case vbaParser::STRING:
              case vbaParser::SUB:
              case vbaParser::TAB:
              case vbaParser::TEXT:
              case vbaParser::THEN:
              case vbaParser::TIME:
              case vbaParser::TO:
              case vbaParser::TRUE:
              case vbaParser::TYPE:
              case vbaParser::TYPEOF:
              case vbaParser::UNLOAD:
              case vbaParser::UNLOCK:
              case vbaParser::UNTIL:
              case vbaParser::VARIANT:
              case vbaParser::VERSION:
              case vbaParser::WEND:
              case vbaParser::WHILE:
              case vbaParser::WIDTH:
              case vbaParser::WITH:
              case vbaParser::WITHEVENTS:
              case vbaParser::WRITE:
              case vbaParser::XOR: {
                setState(2475);
                ambiguousKeyword();
                break;
              }

              case vbaParser::IDENTIFIER: {
                setState(2476);
                match(vbaParser::IDENTIFIER);
                break;
              }

            default:
              throw NoViableAltException(this);
            } 
          }
          setState(2481);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 414, _ctx);
        }
        break;
      }

      case vbaParser::ACCESS:
      case vbaParser::ADDRESSOF:
      case vbaParser::ALIAS:
      case vbaParser::AND:
      case vbaParser::ATTRIBUTE:
      case vbaParser::APPACTIVATE:
      case vbaParser::APPEND:
      case vbaParser::AS:
      case vbaParser::BEGIN:
      case vbaParser::BEEP:
      case vbaParser::BINARY:
      case vbaParser::BOOLEAN:
      case vbaParser::BYVAL:
      case vbaParser::BYREF:
      case vbaParser::BYTE:
      case vbaParser::CALL:
      case vbaParser::CASE:
      case vbaParser::CHDIR:
      case vbaParser::CHDRIVE:
      case vbaParser::CLASS:
      case vbaParser::CLOSE:
      case vbaParser::COLLECTION:
      case vbaParser::CONST:
      case vbaParser::DATABASE:
      case vbaParser::DATE:
      case vbaParser::DECLARE:
      case vbaParser::DEFBOOL:
      case vbaParser::DEFBYTE:
      case vbaParser::DEFDATE:
      case vbaParser::DEFDBL:
      case vbaParser::DEFDEC:
      case vbaParser::DEFCUR:
      case vbaParser::DEFINT:
      case vbaParser::DEFLNG:
      case vbaParser::DEFOBJ:
      case vbaParser::DEFSNG:
      case vbaParser::DEFSTR:
      case vbaParser::DEFVAR:
      case vbaParser::DELETESETTING:
      case vbaParser::DIM:
      case vbaParser::DO:
      case vbaParser::DOUBLE:
      case vbaParser::EACH:
      case vbaParser::ELSE:
      case vbaParser::ELSEIF:
      case vbaParser::END:
      case vbaParser::ENUM:
      case vbaParser::EQV:
      case vbaParser::ERASE:
      case vbaParser::ERROR:
      case vbaParser::EVENT:
      case vbaParser::FALSE:
      case vbaParser::FILECOPY:
      case vbaParser::FRIEND:
      case vbaParser::FOR:
      case vbaParser::FUNCTION:
      case vbaParser::GET:
      case vbaParser::GLOBAL:
      case vbaParser::GOSUB:
      case vbaParser::GOTO:
      case vbaParser::IF:
      case vbaParser::IMP:
      case vbaParser::IMPLEMENTS:
      case vbaParser::IN:
      case vbaParser::INPUT:
      case vbaParser::IS:
      case vbaParser::INTEGER:
      case vbaParser::KILL:
      case vbaParser::LOAD:
      case vbaParser::LOCK:
      case vbaParser::LONG:
      case vbaParser::LOOP:
      case vbaParser::LEN:
      case vbaParser::LET:
      case vbaParser::LIB:
      case vbaParser::LIKE:
      case vbaParser::LSET:
      case vbaParser::ME:
      case vbaParser::MID:
      case vbaParser::MKDIR:
      case vbaParser::MOD:
      case vbaParser::NAME:
      case vbaParser::NEXT:
      case vbaParser::NEW:
      case vbaParser::NOT:
      case vbaParser::NOTHING:
      case vbaParser::NULL_:
      case vbaParser::ON:
      case vbaParser::OPEN:
      case vbaParser::OPTIONAL:
      case vbaParser::OR:
      case vbaParser::OUTPUT:
      case vbaParser::PARAMARRAY:
      case vbaParser::PRESERVE:
      case vbaParser::PRINT:
      case vbaParser::PRIVATE:
      case vbaParser::PUBLIC:
      case vbaParser::PUT:
      case vbaParser::RANDOM:
      case vbaParser::RANDOMIZE:
      case vbaParser::RAISEEVENT:
      case vbaParser::READ:
      case vbaParser::REDIM:
      case vbaParser::REM:
      case vbaParser::RESET:
      case vbaParser::RESUME:
      case vbaParser::RETURN:
      case vbaParser::RMDIR:
      case vbaParser::RSET:
      case vbaParser::SAVEPICTURE:
      case vbaParser::SAVESETTING:
      case vbaParser::SEEK:
      case vbaParser::SELECT:
      case vbaParser::SENDKEYS:
      case vbaParser::SET:
      case vbaParser::SETATTR:
      case vbaParser::SHARED:
      case vbaParser::SINGLE:
      case vbaParser::SPC:
      case vbaParser::STATIC:
      case vbaParser::STEP:
      case vbaParser::STOP:
      case vbaParser::STRING:
      case vbaParser::SUB:
      case vbaParser::TAB:
      case vbaParser::TEXT:
      case vbaParser::THEN:
      case vbaParser::TIME:
      case vbaParser::TO:
      case vbaParser::TRUE:
      case vbaParser::TYPE:
      case vbaParser::TYPEOF:
      case vbaParser::UNLOAD:
      case vbaParser::UNLOCK:
      case vbaParser::UNTIL:
      case vbaParser::VARIANT:
      case vbaParser::VERSION:
      case vbaParser::WEND:
      case vbaParser::WHILE:
      case vbaParser::WIDTH:
      case vbaParser::WITH:
      case vbaParser::WITHEVENTS:
      case vbaParser::WRITE:
      case vbaParser::XOR: {
        enterOuterAlt(_localctx, 2);
        setState(2482);
        ambiguousKeyword();
        setState(2485); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(2485);
                  _errHandler->sync(this);
                  switch (_input->LA(1)) {
                    case vbaParser::ACCESS:
                    case vbaParser::ADDRESSOF:
                    case vbaParser::ALIAS:
                    case vbaParser::AND:
                    case vbaParser::ATTRIBUTE:
                    case vbaParser::APPACTIVATE:
                    case vbaParser::APPEND:
                    case vbaParser::AS:
                    case vbaParser::BEGIN:
                    case vbaParser::BEEP:
                    case vbaParser::BINARY:
                    case vbaParser::BOOLEAN:
                    case vbaParser::BYVAL:
                    case vbaParser::BYREF:
                    case vbaParser::BYTE:
                    case vbaParser::CALL:
                    case vbaParser::CASE:
                    case vbaParser::CHDIR:
                    case vbaParser::CHDRIVE:
                    case vbaParser::CLASS:
                    case vbaParser::CLOSE:
                    case vbaParser::COLLECTION:
                    case vbaParser::CONST:
                    case vbaParser::DATABASE:
                    case vbaParser::DATE:
                    case vbaParser::DECLARE:
                    case vbaParser::DEFBOOL:
                    case vbaParser::DEFBYTE:
                    case vbaParser::DEFDATE:
                    case vbaParser::DEFDBL:
                    case vbaParser::DEFDEC:
                    case vbaParser::DEFCUR:
                    case vbaParser::DEFINT:
                    case vbaParser::DEFLNG:
                    case vbaParser::DEFOBJ:
                    case vbaParser::DEFSNG:
                    case vbaParser::DEFSTR:
                    case vbaParser::DEFVAR:
                    case vbaParser::DELETESETTING:
                    case vbaParser::DIM:
                    case vbaParser::DO:
                    case vbaParser::DOUBLE:
                    case vbaParser::EACH:
                    case vbaParser::ELSE:
                    case vbaParser::ELSEIF:
                    case vbaParser::END:
                    case vbaParser::ENUM:
                    case vbaParser::EQV:
                    case vbaParser::ERASE:
                    case vbaParser::ERROR:
                    case vbaParser::EVENT:
                    case vbaParser::FALSE:
                    case vbaParser::FILECOPY:
                    case vbaParser::FRIEND:
                    case vbaParser::FOR:
                    case vbaParser::FUNCTION:
                    case vbaParser::GET:
                    case vbaParser::GLOBAL:
                    case vbaParser::GOSUB:
                    case vbaParser::GOTO:
                    case vbaParser::IF:
                    case vbaParser::IMP:
                    case vbaParser::IMPLEMENTS:
                    case vbaParser::IN:
                    case vbaParser::INPUT:
                    case vbaParser::IS:
                    case vbaParser::INTEGER:
                    case vbaParser::KILL:
                    case vbaParser::LOAD:
                    case vbaParser::LOCK:
                    case vbaParser::LONG:
                    case vbaParser::LOOP:
                    case vbaParser::LEN:
                    case vbaParser::LET:
                    case vbaParser::LIB:
                    case vbaParser::LIKE:
                    case vbaParser::LSET:
                    case vbaParser::ME:
                    case vbaParser::MID:
                    case vbaParser::MKDIR:
                    case vbaParser::MOD:
                    case vbaParser::NAME:
                    case vbaParser::NEXT:
                    case vbaParser::NEW:
                    case vbaParser::NOT:
                    case vbaParser::NOTHING:
                    case vbaParser::NULL_:
                    case vbaParser::ON:
                    case vbaParser::OPEN:
                    case vbaParser::OPTIONAL:
                    case vbaParser::OR:
                    case vbaParser::OUTPUT:
                    case vbaParser::PARAMARRAY:
                    case vbaParser::PRESERVE:
                    case vbaParser::PRINT:
                    case vbaParser::PRIVATE:
                    case vbaParser::PUBLIC:
                    case vbaParser::PUT:
                    case vbaParser::RANDOM:
                    case vbaParser::RANDOMIZE:
                    case vbaParser::RAISEEVENT:
                    case vbaParser::READ:
                    case vbaParser::REDIM:
                    case vbaParser::REM:
                    case vbaParser::RESET:
                    case vbaParser::RESUME:
                    case vbaParser::RETURN:
                    case vbaParser::RMDIR:
                    case vbaParser::RSET:
                    case vbaParser::SAVEPICTURE:
                    case vbaParser::SAVESETTING:
                    case vbaParser::SEEK:
                    case vbaParser::SELECT:
                    case vbaParser::SENDKEYS:
                    case vbaParser::SET:
                    case vbaParser::SETATTR:
                    case vbaParser::SHARED:
                    case vbaParser::SINGLE:
                    case vbaParser::SPC:
                    case vbaParser::STATIC:
                    case vbaParser::STEP:
                    case vbaParser::STOP:
                    case vbaParser::STRING:
                    case vbaParser::SUB:
                    case vbaParser::TAB:
                    case vbaParser::TEXT:
                    case vbaParser::THEN:
                    case vbaParser::TIME:
                    case vbaParser::TO:
                    case vbaParser::TRUE:
                    case vbaParser::TYPE:
                    case vbaParser::TYPEOF:
                    case vbaParser::UNLOAD:
                    case vbaParser::UNLOCK:
                    case vbaParser::UNTIL:
                    case vbaParser::VARIANT:
                    case vbaParser::VERSION:
                    case vbaParser::WEND:
                    case vbaParser::WHILE:
                    case vbaParser::WIDTH:
                    case vbaParser::WITH:
                    case vbaParser::WITHEVENTS:
                    case vbaParser::WRITE:
                    case vbaParser::XOR: {
                      setState(2483);
                      ambiguousKeyword();
                      break;
                    }

                    case vbaParser::IDENTIFIER: {
                      setState(2484);
                      match(vbaParser::IDENTIFIER);
                      break;
                    }

                  default:
                    throw NoViableAltException(this);
                  }
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(2487); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 416, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComparisonOperatorContext ------------------------------------------------------------------

vbaParser::ComparisonOperatorContext::ComparisonOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::ComparisonOperatorContext::LT() {
  return getToken(vbaParser::LT, 0);
}

tree::TerminalNode* vbaParser::ComparisonOperatorContext::LEQ() {
  return getToken(vbaParser::LEQ, 0);
}

tree::TerminalNode* vbaParser::ComparisonOperatorContext::GT() {
  return getToken(vbaParser::GT, 0);
}

tree::TerminalNode* vbaParser::ComparisonOperatorContext::GEQ() {
  return getToken(vbaParser::GEQ, 0);
}

tree::TerminalNode* vbaParser::ComparisonOperatorContext::EQ() {
  return getToken(vbaParser::EQ, 0);
}

tree::TerminalNode* vbaParser::ComparisonOperatorContext::NEQ() {
  return getToken(vbaParser::NEQ, 0);
}

tree::TerminalNode* vbaParser::ComparisonOperatorContext::IS() {
  return getToken(vbaParser::IS, 0);
}

tree::TerminalNode* vbaParser::ComparisonOperatorContext::LIKE() {
  return getToken(vbaParser::LIKE, 0);
}


size_t vbaParser::ComparisonOperatorContext::getRuleIndex() const {
  return vbaParser::RuleComparisonOperator;
}

void vbaParser::ComparisonOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparisonOperator(this);
}

void vbaParser::ComparisonOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparisonOperator(this);
}

vbaParser::ComparisonOperatorContext* vbaParser::comparisonOperator() {
  ComparisonOperatorContext *_localctx = _tracker.createInstance<ComparisonOperatorContext>(_ctx, getState());
  enterRule(_localctx, 266, vbaParser::RuleComparisonOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2491);
    _la = _input->LA(1);
    if (!(_la == vbaParser::IS

    || _la == vbaParser::LIKE || ((((_la - 189) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 189)) & 559) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComplexTypeContext ------------------------------------------------------------------

vbaParser::ComplexTypeContext::ComplexTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<vbaParser::AmbiguousIdentifierContext *> vbaParser::ComplexTypeContext::ambiguousIdentifier() {
  return getRuleContexts<vbaParser::AmbiguousIdentifierContext>();
}

vbaParser::AmbiguousIdentifierContext* vbaParser::ComplexTypeContext::ambiguousIdentifier(size_t i) {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(i);
}


size_t vbaParser::ComplexTypeContext::getRuleIndex() const {
  return vbaParser::RuleComplexType;
}

void vbaParser::ComplexTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComplexType(this);
}

void vbaParser::ComplexTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComplexType(this);
}

vbaParser::ComplexTypeContext* vbaParser::complexType() {
  ComplexTypeContext *_localctx = _tracker.createInstance<ComplexTypeContext>(_ctx, getState());
  enterRule(_localctx, 268, vbaParser::RuleComplexType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2493);
    ambiguousIdentifier();
    setState(2498);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 418, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2494);
        _la = _input->LA(1);
        if (!(_la == vbaParser::T__3

        || _la == vbaParser::T__4)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2495);
        ambiguousIdentifier(); 
      }
      setState(2500);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 418, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldLengthContext ------------------------------------------------------------------

vbaParser::FieldLengthContext::FieldLengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::FieldLengthContext::MULT() {
  return getToken(vbaParser::MULT, 0);
}

tree::TerminalNode* vbaParser::FieldLengthContext::INTEGERLITERAL() {
  return getToken(vbaParser::INTEGERLITERAL, 0);
}

vbaParser::AmbiguousIdentifierContext* vbaParser::FieldLengthContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

tree::TerminalNode* vbaParser::FieldLengthContext::WS() {
  return getToken(vbaParser::WS, 0);
}


size_t vbaParser::FieldLengthContext::getRuleIndex() const {
  return vbaParser::RuleFieldLength;
}

void vbaParser::FieldLengthContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldLength(this);
}

void vbaParser::FieldLengthContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldLength(this);
}

vbaParser::FieldLengthContext* vbaParser::fieldLength() {
  FieldLengthContext *_localctx = _tracker.createInstance<FieldLengthContext>(_ctx, getState());
  enterRule(_localctx, 270, vbaParser::RuleFieldLength);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2501);
    match(vbaParser::MULT);
    setState(2503);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(2502);
      match(vbaParser::WS);
    }
    setState(2507);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case vbaParser::INTEGERLITERAL: {
        setState(2505);
        match(vbaParser::INTEGERLITERAL);
        break;
      }

      case vbaParser::ACCESS:
      case vbaParser::ADDRESSOF:
      case vbaParser::ALIAS:
      case vbaParser::AND:
      case vbaParser::ATTRIBUTE:
      case vbaParser::APPACTIVATE:
      case vbaParser::APPEND:
      case vbaParser::AS:
      case vbaParser::BEGIN:
      case vbaParser::BEEP:
      case vbaParser::BINARY:
      case vbaParser::BOOLEAN:
      case vbaParser::BYVAL:
      case vbaParser::BYREF:
      case vbaParser::BYTE:
      case vbaParser::CALL:
      case vbaParser::CASE:
      case vbaParser::CHDIR:
      case vbaParser::CHDRIVE:
      case vbaParser::CLASS:
      case vbaParser::CLOSE:
      case vbaParser::COLLECTION:
      case vbaParser::CONST:
      case vbaParser::DATABASE:
      case vbaParser::DATE:
      case vbaParser::DECLARE:
      case vbaParser::DEFBOOL:
      case vbaParser::DEFBYTE:
      case vbaParser::DEFDATE:
      case vbaParser::DEFDBL:
      case vbaParser::DEFDEC:
      case vbaParser::DEFCUR:
      case vbaParser::DEFINT:
      case vbaParser::DEFLNG:
      case vbaParser::DEFOBJ:
      case vbaParser::DEFSNG:
      case vbaParser::DEFSTR:
      case vbaParser::DEFVAR:
      case vbaParser::DELETESETTING:
      case vbaParser::DIM:
      case vbaParser::DO:
      case vbaParser::DOUBLE:
      case vbaParser::EACH:
      case vbaParser::ELSE:
      case vbaParser::ELSEIF:
      case vbaParser::END:
      case vbaParser::ENUM:
      case vbaParser::EQV:
      case vbaParser::ERASE:
      case vbaParser::ERROR:
      case vbaParser::EVENT:
      case vbaParser::FALSE:
      case vbaParser::FILECOPY:
      case vbaParser::FRIEND:
      case vbaParser::FOR:
      case vbaParser::FUNCTION:
      case vbaParser::GET:
      case vbaParser::GLOBAL:
      case vbaParser::GOSUB:
      case vbaParser::GOTO:
      case vbaParser::IF:
      case vbaParser::IMP:
      case vbaParser::IMPLEMENTS:
      case vbaParser::IN:
      case vbaParser::INPUT:
      case vbaParser::IS:
      case vbaParser::INTEGER:
      case vbaParser::KILL:
      case vbaParser::LOAD:
      case vbaParser::LOCK:
      case vbaParser::LONG:
      case vbaParser::LOOP:
      case vbaParser::LEN:
      case vbaParser::LET:
      case vbaParser::LIB:
      case vbaParser::LIKE:
      case vbaParser::LSET:
      case vbaParser::ME:
      case vbaParser::MID:
      case vbaParser::MKDIR:
      case vbaParser::MOD:
      case vbaParser::NAME:
      case vbaParser::NEXT:
      case vbaParser::NEW:
      case vbaParser::NOT:
      case vbaParser::NOTHING:
      case vbaParser::NULL_:
      case vbaParser::ON:
      case vbaParser::OPEN:
      case vbaParser::OPTIONAL:
      case vbaParser::OR:
      case vbaParser::OUTPUT:
      case vbaParser::PARAMARRAY:
      case vbaParser::PRESERVE:
      case vbaParser::PRINT:
      case vbaParser::PRIVATE:
      case vbaParser::PUBLIC:
      case vbaParser::PUT:
      case vbaParser::RANDOM:
      case vbaParser::RANDOMIZE:
      case vbaParser::RAISEEVENT:
      case vbaParser::READ:
      case vbaParser::REDIM:
      case vbaParser::REM:
      case vbaParser::RESET:
      case vbaParser::RESUME:
      case vbaParser::RETURN:
      case vbaParser::RMDIR:
      case vbaParser::RSET:
      case vbaParser::SAVEPICTURE:
      case vbaParser::SAVESETTING:
      case vbaParser::SEEK:
      case vbaParser::SELECT:
      case vbaParser::SENDKEYS:
      case vbaParser::SET:
      case vbaParser::SETATTR:
      case vbaParser::SHARED:
      case vbaParser::SINGLE:
      case vbaParser::SPC:
      case vbaParser::STATIC:
      case vbaParser::STEP:
      case vbaParser::STOP:
      case vbaParser::STRING:
      case vbaParser::SUB:
      case vbaParser::TAB:
      case vbaParser::TEXT:
      case vbaParser::THEN:
      case vbaParser::TIME:
      case vbaParser::TO:
      case vbaParser::TRUE:
      case vbaParser::TYPE:
      case vbaParser::TYPEOF:
      case vbaParser::UNLOAD:
      case vbaParser::UNLOCK:
      case vbaParser::UNTIL:
      case vbaParser::VARIANT:
      case vbaParser::VERSION:
      case vbaParser::WEND:
      case vbaParser::WHILE:
      case vbaParser::WIDTH:
      case vbaParser::WITH:
      case vbaParser::WITHEVENTS:
      case vbaParser::WRITE:
      case vbaParser::XOR:
      case vbaParser::IDENTIFIER: {
        setState(2506);
        ambiguousIdentifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LetterrangeContext ------------------------------------------------------------------

vbaParser::LetterrangeContext::LetterrangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<vbaParser::CertainIdentifierContext *> vbaParser::LetterrangeContext::certainIdentifier() {
  return getRuleContexts<vbaParser::CertainIdentifierContext>();
}

vbaParser::CertainIdentifierContext* vbaParser::LetterrangeContext::certainIdentifier(size_t i) {
  return getRuleContext<vbaParser::CertainIdentifierContext>(i);
}

tree::TerminalNode* vbaParser::LetterrangeContext::MINUS() {
  return getToken(vbaParser::MINUS, 0);
}

std::vector<tree::TerminalNode *> vbaParser::LetterrangeContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::LetterrangeContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}


size_t vbaParser::LetterrangeContext::getRuleIndex() const {
  return vbaParser::RuleLetterrange;
}

void vbaParser::LetterrangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLetterrange(this);
}

void vbaParser::LetterrangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLetterrange(this);
}

vbaParser::LetterrangeContext* vbaParser::letterrange() {
  LetterrangeContext *_localctx = _tracker.createInstance<LetterrangeContext>(_ctx, getState());
  enterRule(_localctx, 272, vbaParser::RuleLetterrange);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2509);
    certainIdentifier();
    setState(2518);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 423, _ctx)) {
    case 1: {
      setState(2511);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(2510);
        match(vbaParser::WS);
      }
      setState(2513);
      match(vbaParser::MINUS);
      setState(2515);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(2514);
        match(vbaParser::WS);
      }
      setState(2517);
      certainIdentifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LineLabelContext ------------------------------------------------------------------

vbaParser::LineLabelContext::LineLabelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::AmbiguousIdentifierContext* vbaParser::LineLabelContext::ambiguousIdentifier() {
  return getRuleContext<vbaParser::AmbiguousIdentifierContext>(0);
}

tree::TerminalNode* vbaParser::LineLabelContext::COLON() {
  return getToken(vbaParser::COLON, 0);
}


size_t vbaParser::LineLabelContext::getRuleIndex() const {
  return vbaParser::RuleLineLabel;
}

void vbaParser::LineLabelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLineLabel(this);
}

void vbaParser::LineLabelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLineLabel(this);
}

vbaParser::LineLabelContext* vbaParser::lineLabel() {
  LineLabelContext *_localctx = _tracker.createInstance<LineLabelContext>(_ctx, getState());
  enterRule(_localctx, 274, vbaParser::RuleLineLabel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2520);
    ambiguousIdentifier();
    setState(2521);
    match(vbaParser::COLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

vbaParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::LiteralContext::HEXLITERAL() {
  return getToken(vbaParser::HEXLITERAL, 0);
}

tree::TerminalNode* vbaParser::LiteralContext::OCTLITERAL() {
  return getToken(vbaParser::OCTLITERAL, 0);
}

tree::TerminalNode* vbaParser::LiteralContext::DATELITERAL() {
  return getToken(vbaParser::DATELITERAL, 0);
}

tree::TerminalNode* vbaParser::LiteralContext::DOUBLELITERAL() {
  return getToken(vbaParser::DOUBLELITERAL, 0);
}

tree::TerminalNode* vbaParser::LiteralContext::INTEGERLITERAL() {
  return getToken(vbaParser::INTEGERLITERAL, 0);
}

tree::TerminalNode* vbaParser::LiteralContext::SHORTLITERAL() {
  return getToken(vbaParser::SHORTLITERAL, 0);
}

tree::TerminalNode* vbaParser::LiteralContext::STRINGLITERAL() {
  return getToken(vbaParser::STRINGLITERAL, 0);
}

tree::TerminalNode* vbaParser::LiteralContext::TRUE() {
  return getToken(vbaParser::TRUE, 0);
}

tree::TerminalNode* vbaParser::LiteralContext::FALSE() {
  return getToken(vbaParser::FALSE, 0);
}

tree::TerminalNode* vbaParser::LiteralContext::NOTHING() {
  return getToken(vbaParser::NOTHING, 0);
}

tree::TerminalNode* vbaParser::LiteralContext::NULL_() {
  return getToken(vbaParser::NULL_, 0);
}


size_t vbaParser::LiteralContext::getRuleIndex() const {
  return vbaParser::RuleLiteral;
}

void vbaParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void vbaParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}

vbaParser::LiteralContext* vbaParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 276, vbaParser::RuleLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2523);
    _la = _input->LA(1);
    if (!(((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & 26388279066625) != 0) || ((((_la - 171) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 171)) & 2181843386369) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_Context ------------------------------------------------------------------

vbaParser::Type_Context::Type_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

vbaParser::BaseTypeContext* vbaParser::Type_Context::baseType() {
  return getRuleContext<vbaParser::BaseTypeContext>(0);
}

vbaParser::ComplexTypeContext* vbaParser::Type_Context::complexType() {
  return getRuleContext<vbaParser::ComplexTypeContext>(0);
}

tree::TerminalNode* vbaParser::Type_Context::LPAREN() {
  return getToken(vbaParser::LPAREN, 0);
}

tree::TerminalNode* vbaParser::Type_Context::RPAREN() {
  return getToken(vbaParser::RPAREN, 0);
}

std::vector<tree::TerminalNode *> vbaParser::Type_Context::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::Type_Context::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}


size_t vbaParser::Type_Context::getRuleIndex() const {
  return vbaParser::RuleType_;
}

void vbaParser::Type_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_(this);
}

void vbaParser::Type_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_(this);
}

vbaParser::Type_Context* vbaParser::type_() {
  Type_Context *_localctx = _tracker.createInstance<Type_Context>(_ctx, getState());
  enterRule(_localctx, 278, vbaParser::RuleType_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2527);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 424, _ctx)) {
    case 1: {
      setState(2525);
      baseType();
      break;
    }

    case 2: {
      setState(2526);
      complexType();
      break;
    }

    default:
      break;
    }
    setState(2537);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 427, _ctx)) {
    case 1: {
      setState(2530);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(2529);
        match(vbaParser::WS);
      }
      setState(2532);
      match(vbaParser::LPAREN);
      setState(2534);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == vbaParser::WS) {
        setState(2533);
        match(vbaParser::WS);
      }
      setState(2536);
      match(vbaParser::RPAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeHintContext ------------------------------------------------------------------

vbaParser::TypeHintContext::TypeHintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::TypeHintContext::AMPERSAND() {
  return getToken(vbaParser::AMPERSAND, 0);
}


size_t vbaParser::TypeHintContext::getRuleIndex() const {
  return vbaParser::RuleTypeHint;
}

void vbaParser::TypeHintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeHint(this);
}

void vbaParser::TypeHintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeHint(this);
}

vbaParser::TypeHintContext* vbaParser::typeHint() {
  TypeHintContext *_localctx = _tracker.createInstance<TypeHintContext>(_ctx, getState());
  enterRule(_localctx, 280, vbaParser::RuleTypeHint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2539);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 488) != 0) || _la == vbaParser::AMPERSAND)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VisibilityContext ------------------------------------------------------------------

vbaParser::VisibilityContext::VisibilityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::VisibilityContext::PRIVATE() {
  return getToken(vbaParser::PRIVATE, 0);
}

tree::TerminalNode* vbaParser::VisibilityContext::PUBLIC() {
  return getToken(vbaParser::PUBLIC, 0);
}

tree::TerminalNode* vbaParser::VisibilityContext::FRIEND() {
  return getToken(vbaParser::FRIEND, 0);
}

tree::TerminalNode* vbaParser::VisibilityContext::GLOBAL() {
  return getToken(vbaParser::GLOBAL, 0);
}


size_t vbaParser::VisibilityContext::getRuleIndex() const {
  return vbaParser::RuleVisibility;
}

void vbaParser::VisibilityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVisibility(this);
}

void vbaParser::VisibilityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVisibility(this);
}

vbaParser::VisibilityContext* vbaParser::visibility() {
  VisibilityContext *_localctx = _tracker.createInstance<VisibilityContext>(_ctx, getState());
  enterRule(_localctx, 282, vbaParser::RuleVisibility);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2541);
    _la = _input->LA(1);
    if (!(((((_la - 75) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 75)) & 4755801206503243793) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AmbiguousKeywordContext ------------------------------------------------------------------

vbaParser::AmbiguousKeywordContext::AmbiguousKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::ACCESS() {
  return getToken(vbaParser::ACCESS, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::ADDRESSOF() {
  return getToken(vbaParser::ADDRESSOF, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::ALIAS() {
  return getToken(vbaParser::ALIAS, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::AND() {
  return getToken(vbaParser::AND, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::ATTRIBUTE() {
  return getToken(vbaParser::ATTRIBUTE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::APPACTIVATE() {
  return getToken(vbaParser::APPACTIVATE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::APPEND() {
  return getToken(vbaParser::APPEND, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::AS() {
  return getToken(vbaParser::AS, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::BEEP() {
  return getToken(vbaParser::BEEP, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::BEGIN() {
  return getToken(vbaParser::BEGIN, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::BINARY() {
  return getToken(vbaParser::BINARY, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::BOOLEAN() {
  return getToken(vbaParser::BOOLEAN, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::BYVAL() {
  return getToken(vbaParser::BYVAL, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::BYREF() {
  return getToken(vbaParser::BYREF, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::BYTE() {
  return getToken(vbaParser::BYTE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::CALL() {
  return getToken(vbaParser::CALL, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::CASE() {
  return getToken(vbaParser::CASE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::CLASS() {
  return getToken(vbaParser::CLASS, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::CLOSE() {
  return getToken(vbaParser::CLOSE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::CHDIR() {
  return getToken(vbaParser::CHDIR, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::CHDRIVE() {
  return getToken(vbaParser::CHDRIVE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::COLLECTION() {
  return getToken(vbaParser::COLLECTION, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::CONST() {
  return getToken(vbaParser::CONST, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::DATABASE() {
  return getToken(vbaParser::DATABASE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::DATE() {
  return getToken(vbaParser::DATE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::DECLARE() {
  return getToken(vbaParser::DECLARE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::DEFBOOL() {
  return getToken(vbaParser::DEFBOOL, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::DEFBYTE() {
  return getToken(vbaParser::DEFBYTE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::DEFCUR() {
  return getToken(vbaParser::DEFCUR, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::DEFDBL() {
  return getToken(vbaParser::DEFDBL, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::DEFDATE() {
  return getToken(vbaParser::DEFDATE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::DEFDEC() {
  return getToken(vbaParser::DEFDEC, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::DEFINT() {
  return getToken(vbaParser::DEFINT, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::DEFLNG() {
  return getToken(vbaParser::DEFLNG, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::DEFOBJ() {
  return getToken(vbaParser::DEFOBJ, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::DEFSNG() {
  return getToken(vbaParser::DEFSNG, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::DEFSTR() {
  return getToken(vbaParser::DEFSTR, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::DEFVAR() {
  return getToken(vbaParser::DEFVAR, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::DELETESETTING() {
  return getToken(vbaParser::DELETESETTING, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::DIM() {
  return getToken(vbaParser::DIM, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::DO() {
  return getToken(vbaParser::DO, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::DOUBLE() {
  return getToken(vbaParser::DOUBLE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::EACH() {
  return getToken(vbaParser::EACH, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::ELSE() {
  return getToken(vbaParser::ELSE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::ELSEIF() {
  return getToken(vbaParser::ELSEIF, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::END() {
  return getToken(vbaParser::END, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::ENUM() {
  return getToken(vbaParser::ENUM, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::EQV() {
  return getToken(vbaParser::EQV, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::ERASE() {
  return getToken(vbaParser::ERASE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::ERROR() {
  return getToken(vbaParser::ERROR, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::EVENT() {
  return getToken(vbaParser::EVENT, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::FALSE() {
  return getToken(vbaParser::FALSE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::FILECOPY() {
  return getToken(vbaParser::FILECOPY, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::FRIEND() {
  return getToken(vbaParser::FRIEND, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::FOR() {
  return getToken(vbaParser::FOR, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::FUNCTION() {
  return getToken(vbaParser::FUNCTION, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::GET() {
  return getToken(vbaParser::GET, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::GLOBAL() {
  return getToken(vbaParser::GLOBAL, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::GOSUB() {
  return getToken(vbaParser::GOSUB, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::GOTO() {
  return getToken(vbaParser::GOTO, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::IF() {
  return getToken(vbaParser::IF, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::IMP() {
  return getToken(vbaParser::IMP, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::IMPLEMENTS() {
  return getToken(vbaParser::IMPLEMENTS, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::IN() {
  return getToken(vbaParser::IN, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::INPUT() {
  return getToken(vbaParser::INPUT, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::IS() {
  return getToken(vbaParser::IS, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::INTEGER() {
  return getToken(vbaParser::INTEGER, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::KILL() {
  return getToken(vbaParser::KILL, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::LOAD() {
  return getToken(vbaParser::LOAD, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::LOCK() {
  return getToken(vbaParser::LOCK, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::LONG() {
  return getToken(vbaParser::LONG, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::LOOP() {
  return getToken(vbaParser::LOOP, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::LEN() {
  return getToken(vbaParser::LEN, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::LET() {
  return getToken(vbaParser::LET, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::LIB() {
  return getToken(vbaParser::LIB, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::LIKE() {
  return getToken(vbaParser::LIKE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::LSET() {
  return getToken(vbaParser::LSET, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::ME() {
  return getToken(vbaParser::ME, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::MID() {
  return getToken(vbaParser::MID, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::MKDIR() {
  return getToken(vbaParser::MKDIR, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::MOD() {
  return getToken(vbaParser::MOD, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::NAME() {
  return getToken(vbaParser::NAME, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::NEXT() {
  return getToken(vbaParser::NEXT, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::NEW() {
  return getToken(vbaParser::NEW, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::NOT() {
  return getToken(vbaParser::NOT, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::NOTHING() {
  return getToken(vbaParser::NOTHING, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::NULL_() {
  return getToken(vbaParser::NULL_, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::ON() {
  return getToken(vbaParser::ON, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::OPEN() {
  return getToken(vbaParser::OPEN, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::OPTIONAL() {
  return getToken(vbaParser::OPTIONAL, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::OR() {
  return getToken(vbaParser::OR, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::OUTPUT() {
  return getToken(vbaParser::OUTPUT, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::PARAMARRAY() {
  return getToken(vbaParser::PARAMARRAY, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::PRESERVE() {
  return getToken(vbaParser::PRESERVE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::PRINT() {
  return getToken(vbaParser::PRINT, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::PRIVATE() {
  return getToken(vbaParser::PRIVATE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::PUBLIC() {
  return getToken(vbaParser::PUBLIC, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::PUT() {
  return getToken(vbaParser::PUT, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::RANDOM() {
  return getToken(vbaParser::RANDOM, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::RANDOMIZE() {
  return getToken(vbaParser::RANDOMIZE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::RAISEEVENT() {
  return getToken(vbaParser::RAISEEVENT, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::READ() {
  return getToken(vbaParser::READ, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::REDIM() {
  return getToken(vbaParser::REDIM, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::REM() {
  return getToken(vbaParser::REM, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::RESET() {
  return getToken(vbaParser::RESET, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::RESUME() {
  return getToken(vbaParser::RESUME, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::RETURN() {
  return getToken(vbaParser::RETURN, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::RMDIR() {
  return getToken(vbaParser::RMDIR, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::RSET() {
  return getToken(vbaParser::RSET, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::SAVEPICTURE() {
  return getToken(vbaParser::SAVEPICTURE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::SAVESETTING() {
  return getToken(vbaParser::SAVESETTING, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::SEEK() {
  return getToken(vbaParser::SEEK, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::SELECT() {
  return getToken(vbaParser::SELECT, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::SENDKEYS() {
  return getToken(vbaParser::SENDKEYS, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::SET() {
  return getToken(vbaParser::SET, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::SETATTR() {
  return getToken(vbaParser::SETATTR, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::SHARED() {
  return getToken(vbaParser::SHARED, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::SINGLE() {
  return getToken(vbaParser::SINGLE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::SPC() {
  return getToken(vbaParser::SPC, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::STATIC() {
  return getToken(vbaParser::STATIC, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::STEP() {
  return getToken(vbaParser::STEP, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::STOP() {
  return getToken(vbaParser::STOP, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::STRING() {
  return getToken(vbaParser::STRING, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::SUB() {
  return getToken(vbaParser::SUB, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::TAB() {
  return getToken(vbaParser::TAB, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::TEXT() {
  return getToken(vbaParser::TEXT, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::THEN() {
  return getToken(vbaParser::THEN, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::TIME() {
  return getToken(vbaParser::TIME, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::TO() {
  return getToken(vbaParser::TO, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::TRUE() {
  return getToken(vbaParser::TRUE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::TYPE() {
  return getToken(vbaParser::TYPE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::TYPEOF() {
  return getToken(vbaParser::TYPEOF, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::UNLOAD() {
  return getToken(vbaParser::UNLOAD, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::UNLOCK() {
  return getToken(vbaParser::UNLOCK, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::UNTIL() {
  return getToken(vbaParser::UNTIL, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::VARIANT() {
  return getToken(vbaParser::VARIANT, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::VERSION() {
  return getToken(vbaParser::VERSION, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::WEND() {
  return getToken(vbaParser::WEND, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::WHILE() {
  return getToken(vbaParser::WHILE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::WIDTH() {
  return getToken(vbaParser::WIDTH, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::WITH() {
  return getToken(vbaParser::WITH, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::WITHEVENTS() {
  return getToken(vbaParser::WITHEVENTS, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::WRITE() {
  return getToken(vbaParser::WRITE, 0);
}

tree::TerminalNode* vbaParser::AmbiguousKeywordContext::XOR() {
  return getToken(vbaParser::XOR, 0);
}


size_t vbaParser::AmbiguousKeywordContext::getRuleIndex() const {
  return vbaParser::RuleAmbiguousKeyword;
}

void vbaParser::AmbiguousKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAmbiguousKeyword(this);
}

void vbaParser::AmbiguousKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAmbiguousKeyword(this);
}

vbaParser::AmbiguousKeywordContext* vbaParser::ambiguousKeyword() {
  AmbiguousKeywordContext *_localctx = _tracker.createInstance<AmbiguousKeywordContext>(_ctx, getState());
  enterRule(_localctx, 284, vbaParser::RuleAmbiguousKeyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2543);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4593671619917906432) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -8755014975736513009) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 288230376151678495) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RemCommentContext ------------------------------------------------------------------

vbaParser::RemCommentContext::RemCommentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::RemCommentContext::REMCOMMENT() {
  return getToken(vbaParser::REMCOMMENT, 0);
}


size_t vbaParser::RemCommentContext::getRuleIndex() const {
  return vbaParser::RuleRemComment;
}

void vbaParser::RemCommentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRemComment(this);
}

void vbaParser::RemCommentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRemComment(this);
}

vbaParser::RemCommentContext* vbaParser::remComment() {
  RemCommentContext *_localctx = _tracker.createInstance<RemCommentContext>(_ctx, getState());
  enterRule(_localctx, 286, vbaParser::RuleRemComment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2545);
    match(vbaParser::REMCOMMENT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommentContext ------------------------------------------------------------------

vbaParser::CommentContext::CommentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::CommentContext::COMMENT() {
  return getToken(vbaParser::COMMENT, 0);
}


size_t vbaParser::CommentContext::getRuleIndex() const {
  return vbaParser::RuleComment;
}

void vbaParser::CommentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComment(this);
}

void vbaParser::CommentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComment(this);
}

vbaParser::CommentContext* vbaParser::comment() {
  CommentContext *_localctx = _tracker.createInstance<CommentContext>(_ctx, getState());
  enterRule(_localctx, 288, vbaParser::RuleComment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2547);
    match(vbaParser::COMMENT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EndOfLineContext ------------------------------------------------------------------

vbaParser::EndOfLineContext::EndOfLineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* vbaParser::EndOfLineContext::NEWLINE() {
  return getToken(vbaParser::NEWLINE, 0);
}

vbaParser::CommentContext* vbaParser::EndOfLineContext::comment() {
  return getRuleContext<vbaParser::CommentContext>(0);
}

vbaParser::RemCommentContext* vbaParser::EndOfLineContext::remComment() {
  return getRuleContext<vbaParser::RemCommentContext>(0);
}

std::vector<tree::TerminalNode *> vbaParser::EndOfLineContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::EndOfLineContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}


size_t vbaParser::EndOfLineContext::getRuleIndex() const {
  return vbaParser::RuleEndOfLine;
}

void vbaParser::EndOfLineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEndOfLine(this);
}

void vbaParser::EndOfLineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEndOfLine(this);
}

vbaParser::EndOfLineContext* vbaParser::endOfLine() {
  EndOfLineContext *_localctx = _tracker.createInstance<EndOfLineContext>(_ctx, getState());
  enterRule(_localctx, 290, vbaParser::RuleEndOfLine);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2550);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == vbaParser::WS) {
      setState(2549);
      match(vbaParser::WS);
    }
    setState(2555);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case vbaParser::NEWLINE: {
        setState(2552);
        match(vbaParser::NEWLINE);
        break;
      }

      case vbaParser::COMMENT: {
        setState(2553);
        comment();
        break;
      }

      case vbaParser::REMCOMMENT: {
        setState(2554);
        remComment();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2558);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 430, _ctx)) {
    case 1: {
      setState(2557);
      match(vbaParser::WS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EndOfStatementContext ------------------------------------------------------------------

vbaParser::EndOfStatementContext::EndOfStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<vbaParser::EndOfLineContext *> vbaParser::EndOfStatementContext::endOfLine() {
  return getRuleContexts<vbaParser::EndOfLineContext>();
}

vbaParser::EndOfLineContext* vbaParser::EndOfStatementContext::endOfLine(size_t i) {
  return getRuleContext<vbaParser::EndOfLineContext>(i);
}

std::vector<tree::TerminalNode *> vbaParser::EndOfStatementContext::COLON() {
  return getTokens(vbaParser::COLON);
}

tree::TerminalNode* vbaParser::EndOfStatementContext::COLON(size_t i) {
  return getToken(vbaParser::COLON, i);
}

std::vector<tree::TerminalNode *> vbaParser::EndOfStatementContext::WS() {
  return getTokens(vbaParser::WS);
}

tree::TerminalNode* vbaParser::EndOfStatementContext::WS(size_t i) {
  return getToken(vbaParser::WS, i);
}


size_t vbaParser::EndOfStatementContext::getRuleIndex() const {
  return vbaParser::RuleEndOfStatement;
}

void vbaParser::EndOfStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEndOfStatement(this);
}

void vbaParser::EndOfStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<vbaListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEndOfStatement(this);
}

vbaParser::EndOfStatementContext* vbaParser::endOfStatement() {
  EndOfStatementContext *_localctx = _tracker.createInstance<EndOfStatementContext>(_ctx, getState());
  enterRule(_localctx, 292, vbaParser::RuleEndOfStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2570);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 434, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2568);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 433, _ctx)) {
        case 1: {
          setState(2560);
          endOfLine();
          break;
        }

        case 2: {
          setState(2562);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == vbaParser::WS) {
            setState(2561);
            match(vbaParser::WS);
          }
          setState(2564);
          match(vbaParser::COLON);
          setState(2566);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 432, _ctx)) {
          case 1: {
            setState(2565);
            match(vbaParser::WS);
            break;
          }

          default:
            break;
          }
          break;
        }

        default:
          break;
        } 
      }
      setState(2572);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 434, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool vbaParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 100: return valueStmtSempred(antlrcpp::downCast<ValueStmtContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool vbaParser::valueStmtSempred(ValueStmtContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 14);
    case 1: return precpred(_ctx, 11);
    case 2: return precpred(_ctx, 10);
    case 3: return precpred(_ctx, 9);
    case 4: return precpred(_ctx, 8);
    case 5: return precpred(_ctx, 7);
    case 6: return precpred(_ctx, 5);
    case 7: return precpred(_ctx, 4);
    case 8: return precpred(_ctx, 3);
    case 9: return precpred(_ctx, 2);
    case 10: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

void vbaParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  vbaParserInitialize();
#else
  ::antlr4::internal::call_once(vbaParserOnceFlag, vbaParserInitialize);
#endif
}

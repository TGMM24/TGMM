
// Generated from HaskellParser.g4 by ANTLR 4.13.0


#include "HaskellParserListener.h"

#include "HaskellParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct HaskellParserStaticData final {
  HaskellParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  HaskellParserStaticData(const HaskellParserStaticData&) = delete;
  HaskellParserStaticData(HaskellParserStaticData&&) = delete;
  HaskellParserStaticData& operator=(const HaskellParserStaticData&) = delete;
  HaskellParserStaticData& operator=(HaskellParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag haskellparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
HaskellParserStaticData *haskellparserParserStaticData = nullptr;

void haskellparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (haskellparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(haskellparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<HaskellParserStaticData>(
    std::vector<std::string>{
      "module", "module_content", "where_module", "module_body", "pragmas", 
      "pragma", "language_pragma", "options_ghc", "simple_options", "extension_", 
      "body", "impdecls", "exports", "exprt", "impdecl", "impspec", "himport", 
      "cname", "fixity", "ops", "topdecls", "topdecl", "cl_decl", "ty_decl", 
      "standalone_kind_sig", "sks_vars", "inst_decl", "overlap_pragma", 
      "deriv_strategy_no_via", "deriv_strategy_via", "deriv_standalone_strategy", 
      "opt_injective_info", "injectivity_cond", "inj_varids", "where_type_family", 
      "ty_fam_inst_eqn_list", "ty_fam_inst_eqns", "ty_fam_inst_eqn", "at_decl_cls", 
      "at_decl_inst", "opt_kind_sig", "opt_datafam_kind_sig", "opt_tyfam_kind_sig", 
      "opt_at_kind_inj_sig", "tycl_hdr", "tycl_hdr_inst", "capi_ctype", 
      "standalone_deriving", "role_annot", "roles", "role", "pattern_synonym_decl", 
      "pattern_synonym_lhs", "vars_", "cvars", "where_decls", "pattern_synonym_sig", 
      "decl_cls", "decls_cls", "decllist_cls", "where_cls", "decl_inst", 
      "decls_inst", "decllist_inst", "where_inst", "decls", "decllist", 
      "binds", "wherebinds", "rules", "pragma_rule", "rule_activation_marker", 
      "rule_activation", "rule_foralls", "rule_vars", "rule_var", "warnings", 
      "pragma_warning", "deprecations", "pragma_deprecation", "strings", 
      "stringlist", "annotation", "fdecl", "callconv", "safety", "fspec", 
      "opt_sig", "opt_tyconsig", "sigtype", "sigtypedoc", "sig_vars", "sigtypes1", 
      "unpackedness", "forall_vis_flag", "ktype", "ktypedoc", "ctype", "ctypedoc", 
      "tycl_context", "constr_context", "type_", "typedoc", "constr_btype", 
      "constr_tyapps", "constr_tyapp", "btype", "tyapps", "tyapp", "atype", 
      "inst_type", "deriv_types", "comma_types", "bar_types2", "tv_bndrs", 
      "tv_bndr", "tv_bndr_no_braces", "fds", "fds1", "fd", "varids0", "kind", 
      "gadt_constrlist", "gadt_constrs", "gadt_constr_with_doc", "gadt_constr", 
      "constrs", "constrs1", "constr", "forall", "constr_stuff", "fielddecls", 
      "fielddecl", "derivings", "deriving", "deriv_clause_types", "decl_no_th", 
      "decl", "rhs", "gdrhs", "gdrh", "sigdecl", "activation", "th_quasiquote", 
      "th_qquasiquote", "quasiquote", "exp", "infixexp", "exp10p", "exp10", 
      "fexp", "aexp", "aexp1", "aexp2", "splice_exp", "splice_untyped", 
      "splice_typed", "cmdargs", "acmd", "cvtopbody", "cvtopdecls0", "texp", 
      "tup_exprs", "commas_tup_tail", "tup_tail", "list_", "lexps", "flattenedpquals", 
      "pquals", "squals", "transformqual", "guards", "guard_", "alts", "alt", 
      "alt_rhs", "ralt", "gdpats", "ifgdpats", "gdpat", "pat", "bindpat", 
      "apat", "apats", "fpat", "stmtlist", "stmts", "stmt", "qual", "fbinds", 
      "fbind", "dbinds", "dbind", "name_boolformula_opt", "name_boolformula_and", 
      "name_boolformula_and_list", "name_boolformula_atom", "namelist", 
      "name_var", "qcon_nowiredlist", "qcon", "gen_qcon", "con", "con_list", 
      "sysdcon_nolist", "sysdcon", "conop", "qconop", "gconsym", "gtycon", 
      "ntgtycon", "oqtycon", "qtyconop", "qtycon", "tycon", "qtyconsym", 
      "tyconsym", "op", "varop", "qop", "qopm", "hole_op", "qvarop", "qvaropm", 
      "tyvar", "tyvarop", "tyvarid", "tycls", "qtycls", "var_", "qvar", 
      "qvarid", "varid", "qvarsym", "qvarsym_no_minus", "varsym", "varsym_no_minus", 
      "special_id", "qconid", "conid", "qconsym", "consym", "literal", "open_", 
      "close", "semi", "modid", "commas", "bars", "special", "symbol", "ascSymbol", 
      "integer", "pfloat", "pchar", "pstring"
    },
    std::vector<std::string>{
      "", "", "", "", "'as'", "'case'", "'class'", "'data'", "'default'", 
      "'deriving'", "'do'", "'else'", "'hiding'", "'if'", "'import'", "'in'", 
      "'infix'", "'infixl'", "'infixr'", "'instance'", "'let'", "'module'", 
      "'newtype'", "'of'", "'qualified'", "'then'", "'type'", "'where'", 
      "'_'", "'forall'", "'foreign'", "'export'", "'safe'", "'interruptible'", 
      "'unsafe'", "'mdo'", "'family'", "'role'", "'stdcall'", "'ccall'", 
      "'capi'", "'cplusplus'", "'javascript'", "'rec'", "'group'", "'by'", 
      "'using'", "'pattern'", "'stock'", "'anyclass'", "'via'", "'LANGUAGE'", 
      "'OPTIONS_GHC'", "'OPTIONS'", "'INLINE'", "'NOINLINE'", "'SPECIALISE'", 
      "'SPECIALISE_INLINE'", "'SOURCE'", "'RULES'", "'SCC'", "'DEPRECATED'", 
      "'WARNING'", "'UNPACK'", "'NOUNPACK'", "'ANN'", "'MINIMAL'", "'CTYPE'", 
      "'OVERLAPPING'", "'OVERLAPPABLE'", "'OVERLAPS'", "'INCOHERENT'", "'COMPLETE'", 
      "", "'=>'", "'::'", "'->'", "'<-'", "'-<'", "'>-'", "'-<<'", "'>>-'", 
      "'#'", "'<'", "'>'", "'&'", "'|'", "'!'", "'^'", "'+'", "'-'", "'*'", 
      "'%'", "'/'", "'~'", "'@'", "'$$'", "'$'", "'..'", "'.'", "';'", "'\\u003F'", 
      "','", "':'", "'='", "'''", "''''", "'\\'", "'`'", "", "", "'[||'", 
      "'||]'", "'[|'", "'[p|'", "'[t|'", "'[d|'", "'|]'", "'(#'", "'#)'", 
      "'('", "')'", "'['", "']'", "", "", "", "", "'{-#'", "'#-}'", "", 
      "", "'{'", "'}'", "'VOCURLY'", "'VCCURLY'", "'SEMI'"
    },
    std::vector<std::string>{
      "", "NEWLINE", "TAB", "WS", "AS", "CASE", "CLASS", "DATA", "DEFAULT", 
      "DERIVING", "DO", "ELSE", "HIDING", "IF", "IMPORT", "IN", "INFIX", 
      "INFIXL", "INFIXR", "INSTANCE", "LET", "MODULE", "NEWTYPE", "OF", 
      "QUALIFIED", "THEN", "TYPE", "WHERE", "WILDCARD", "FORALL", "FOREIGN", 
      "EXPORT", "SAFE", "INTERRUPTIBLE", "UNSAFE", "MDO", "FAMILY", "ROLE", 
      "STDCALL", "CCALL", "CAPI", "CPPCALL", "JSCALL", "REC", "GROUP", "BY", 
      "USING", "PATTERN", "STOCK", "ANYCLASS", "VIA", "LANGUAGE", "OPTIONS_GHC", 
      "OPTIONS", "INLINE", "NOINLINE", "SPECIALISE", "SPECINLINE", "SOURCE", 
      "RULES", "SCC", "DEPRECATED", "WARNING", "UNPACK", "NOUNPACK", "ANN", 
      "MINIMAL", "CTYPE", "OVERLAPPING", "OVERLAPPABLE", "OVERLAPS", "INCOHERENT", 
      "COMPLETE", "LCASE", "DoubleArrow", "DoubleColon", "Arrow", "Revarrow", 
      "LarrowTail", "RarrowTail", "LLarrowTail", "RRarrowTail", "Hash", 
      "Less", "Greater", "Ampersand", "Pipe", "Bang", "Caret", "Plus", "Minus", 
      "Asterisk", "Percent", "Divide", "Tilde", "Atsign", "DDollar", "Dollar", 
      "DoubleDot", "Dot", "Semi", "QuestionMark", "Comma", "Colon", "Eq", 
      "Quote", "DoubleQuote", "ReverseSlash", "BackQuote", "AopenParen", 
      "AcloseParen", "TopenTexpQuote", "TcloseTExpQoute", "TopenExpQuote", 
      "TopenPatQuote", "TopenTypQoute", "TopenDecQoute", "TcloseQoute", 
      "OpenBoxParen", "CloseBoxParen", "OpenRoundBracket", "CloseRoundBracket", 
      "OpenSquareBracket", "CloseSquareBracket", "CHAR", "STRING", "VARID", 
      "CONID", "OpenPragmaBracket", "ClosePragmaBracket", "COMMENT", "NCOMMENT", 
      "OCURLY", "CCURLY", "VOCURLY", "VCCURLY", "SEMI", "DECIMAL", "OCTAL", 
      "HEXADECIMAL", "FLOAT", "EXPONENT"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,141,2949,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,
  	7,134,2,135,7,135,2,136,7,136,2,137,7,137,2,138,7,138,2,139,7,139,2,140,
  	7,140,2,141,7,141,2,142,7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,
  	7,146,2,147,7,147,2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,
  	7,152,2,153,7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,
  	7,158,2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
  	7,164,2,165,7,165,2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,2,170,
  	7,170,2,171,7,171,2,172,7,172,2,173,7,173,2,174,7,174,2,175,7,175,2,176,
  	7,176,2,177,7,177,2,178,7,178,2,179,7,179,2,180,7,180,2,181,7,181,2,182,
  	7,182,2,183,7,183,2,184,7,184,2,185,7,185,2,186,7,186,2,187,7,187,2,188,
  	7,188,2,189,7,189,2,190,7,190,2,191,7,191,2,192,7,192,2,193,7,193,2,194,
  	7,194,2,195,7,195,2,196,7,196,2,197,7,197,2,198,7,198,2,199,7,199,2,200,
  	7,200,2,201,7,201,2,202,7,202,2,203,7,203,2,204,7,204,2,205,7,205,2,206,
  	7,206,2,207,7,207,2,208,7,208,2,209,7,209,2,210,7,210,2,211,7,211,2,212,
  	7,212,2,213,7,213,2,214,7,214,2,215,7,215,2,216,7,216,2,217,7,217,2,218,
  	7,218,2,219,7,219,2,220,7,220,2,221,7,221,2,222,7,222,2,223,7,223,2,224,
  	7,224,2,225,7,225,2,226,7,226,2,227,7,227,2,228,7,228,2,229,7,229,2,230,
  	7,230,2,231,7,231,2,232,7,232,2,233,7,233,2,234,7,234,2,235,7,235,2,236,
  	7,236,2,237,7,237,2,238,7,238,2,239,7,239,2,240,7,240,2,241,7,241,2,242,
  	7,242,2,243,7,243,2,244,7,244,2,245,7,245,2,246,7,246,2,247,7,247,2,248,
  	7,248,2,249,7,249,2,250,7,250,2,251,7,251,2,252,7,252,2,253,7,253,2,254,
  	7,254,2,255,7,255,1,0,3,0,514,8,0,1,0,5,0,517,8,0,10,0,12,0,520,9,0,1,
  	0,3,0,523,8,0,1,0,5,0,526,8,0,10,0,12,0,529,9,0,1,0,1,0,3,0,533,8,0,1,
  	0,3,0,536,8,0,1,0,3,0,539,8,0,1,0,1,0,1,1,1,1,1,1,3,1,546,8,1,1,1,1,1,
  	1,2,1,2,1,2,1,3,1,3,1,3,1,3,5,3,557,8,3,10,3,12,3,560,9,3,1,4,4,4,563,
  	8,4,11,4,12,4,564,1,5,1,5,1,5,3,5,570,8,5,1,6,1,6,1,6,1,6,1,6,5,6,577,
  	8,6,10,6,12,6,580,9,6,1,6,1,6,3,6,584,8,6,1,7,1,7,1,7,1,7,1,7,3,7,591,
  	8,7,5,7,593,8,7,10,7,12,7,596,9,7,1,7,1,7,3,7,600,8,7,1,8,1,8,1,8,1,8,
  	1,8,3,8,607,8,8,5,8,609,8,8,10,8,12,8,612,9,8,1,8,1,8,3,8,616,8,8,1,9,
  	1,9,1,10,1,10,1,10,1,10,1,10,3,10,625,8,10,1,11,1,11,1,11,4,11,630,8,
  	11,11,11,12,11,631,1,12,1,12,1,12,1,12,5,12,638,8,12,10,12,12,12,641,
  	9,12,3,12,643,8,12,1,12,3,12,646,8,12,1,12,1,12,1,13,1,13,1,13,1,13,1,
  	13,1,13,1,13,1,13,1,13,5,13,659,8,13,10,13,12,13,662,9,13,3,13,664,8,
  	13,1,13,3,13,667,8,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,5,13,677,
  	8,13,10,13,12,13,680,9,13,3,13,682,8,13,1,13,3,13,685,8,13,1,13,1,13,
  	3,13,689,8,13,1,14,1,14,3,14,693,8,14,1,14,1,14,1,14,3,14,698,8,14,1,
  	14,3,14,701,8,14,1,14,4,14,704,8,14,11,14,12,14,705,1,15,1,15,1,15,1,
  	15,5,15,712,8,15,10,15,12,15,715,9,15,1,15,3,15,718,8,15,3,15,720,8,15,
  	1,15,1,15,1,15,1,15,1,15,1,15,5,15,728,8,15,10,15,12,15,731,9,15,1,15,
  	3,15,734,8,15,3,15,736,8,15,1,15,3,15,739,8,15,1,16,1,16,1,16,1,16,1,
  	16,1,16,1,16,1,16,1,16,5,16,750,8,16,10,16,12,16,753,9,16,3,16,755,8,
  	16,1,16,3,16,758,8,16,1,16,1,16,1,16,1,16,1,16,1,16,3,16,766,8,16,1,16,
  	3,16,769,8,16,3,16,771,8,16,1,17,1,17,3,17,775,8,17,1,18,1,18,1,19,1,
  	19,1,19,5,19,782,8,19,10,19,12,19,785,9,19,1,20,1,20,4,20,789,8,20,11,
  	20,12,20,790,1,20,1,20,4,20,795,8,20,11,20,12,20,796,1,21,1,21,1,21,1,
  	21,1,21,1,21,1,21,1,21,1,21,3,21,808,8,21,1,21,1,21,1,21,1,21,1,21,1,
  	21,3,21,816,8,21,1,21,1,21,1,21,1,21,3,21,822,8,21,1,21,1,21,1,21,1,21,
  	3,21,828,8,21,1,21,1,21,1,21,1,21,3,21,834,8,21,1,22,1,22,1,22,3,22,839,
  	8,22,1,22,3,22,842,8,22,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,
  	3,23,853,8,23,1,23,3,23,856,8,23,1,23,3,23,859,8,23,1,23,1,23,3,23,863,
  	8,23,1,23,1,23,1,23,3,23,868,8,23,1,23,1,23,3,23,872,8,23,1,23,1,23,1,
  	23,3,23,877,8,23,1,23,1,23,3,23,881,8,23,1,23,1,23,3,23,885,8,23,1,23,
  	3,23,888,8,23,1,23,3,23,891,8,23,1,23,1,23,3,23,895,8,23,1,23,1,23,3,
  	23,899,8,23,1,23,3,23,902,8,23,1,23,3,23,905,8,23,1,23,1,23,1,23,1,23,
  	3,23,911,8,23,3,23,913,8,23,1,24,1,24,1,24,1,24,1,24,1,25,1,25,1,25,5,
  	25,923,8,25,10,25,12,25,926,9,25,1,26,1,26,3,26,930,8,26,1,26,1,26,3,
  	26,934,8,26,1,26,1,26,1,26,1,26,1,26,1,26,3,26,942,8,26,1,26,1,26,3,26,
  	946,8,26,1,26,1,26,1,26,3,26,951,8,26,1,26,1,26,3,26,955,8,26,1,26,1,
  	26,1,26,3,26,960,8,26,1,26,1,26,3,26,964,8,26,1,26,3,26,967,8,26,1,26,
  	3,26,970,8,26,1,26,1,26,1,26,3,26,975,8,26,1,26,1,26,3,26,979,8,26,1,
  	26,3,26,982,8,26,1,26,3,26,985,8,26,3,26,987,8,26,1,27,1,27,1,27,1,27,
  	1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,3,27,1001,8,27,1,28,1,28,1,29,
  	1,29,1,29,1,30,1,30,1,30,1,30,3,30,1012,8,30,1,31,1,31,1,31,1,32,1,32,
  	1,32,1,32,1,33,4,33,1022,8,33,11,33,12,33,1023,1,34,1,34,1,34,1,35,1,
  	35,3,35,1031,8,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,3,35,1042,
  	8,35,1,36,1,36,4,36,1046,8,36,11,36,12,36,1047,1,36,1,36,5,36,1052,8,
  	36,10,36,12,36,1055,9,36,1,36,5,36,1058,8,36,10,36,12,36,1061,9,36,1,
  	37,1,37,3,37,1065,8,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,3,
  	37,1076,8,37,1,38,1,38,3,38,1080,8,38,1,38,1,38,3,38,1084,8,38,1,38,1,
  	38,3,38,1088,8,38,1,38,1,38,3,38,1092,8,38,1,38,1,38,3,38,1096,8,38,1,
  	38,3,38,1099,8,38,1,39,1,39,3,39,1103,8,39,1,39,1,39,1,39,3,39,1108,8,
  	39,1,39,3,39,1111,8,39,1,39,1,39,1,39,3,39,1116,8,39,1,39,1,39,3,39,1120,
  	8,39,1,39,3,39,1123,8,39,1,39,1,39,1,39,3,39,1128,8,39,1,39,1,39,3,39,
  	1132,8,39,1,39,3,39,1135,8,39,1,39,1,39,3,39,1139,8,39,1,39,3,39,1142,
  	8,39,1,39,3,39,1145,8,39,1,39,1,39,3,39,1149,8,39,1,39,3,39,1152,8,39,
  	1,39,1,39,3,39,1156,8,39,1,39,3,39,1159,8,39,1,39,3,39,1162,8,39,3,39,
  	1164,8,39,1,40,1,40,1,40,1,41,1,41,1,41,1,42,1,42,1,42,1,42,3,42,1176,
  	8,42,1,43,1,43,1,43,1,43,1,43,1,43,1,43,3,43,1185,8,43,1,44,1,44,1,44,
  	1,44,1,44,3,44,1192,8,44,1,45,1,45,3,45,1196,8,45,1,45,1,45,1,45,1,45,
  	1,45,1,45,1,45,3,45,1205,8,45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,3,45,
  	1214,8,45,1,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,3,46,1225,8,46,
  	1,47,1,47,3,47,1229,8,47,1,47,1,47,3,47,1233,8,47,1,47,1,47,1,48,1,48,
  	1,48,1,48,3,48,1241,8,48,1,49,4,49,1244,8,49,11,49,12,49,1245,1,50,1,
  	50,3,50,1250,8,50,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,51,3,
  	51,1262,8,51,3,51,1264,8,51,1,52,1,52,3,52,1268,8,52,1,52,1,52,1,52,1,
  	52,1,52,1,52,1,52,1,52,1,52,3,52,1279,8,52,1,53,4,53,1282,8,53,11,53,
  	12,53,1283,1,54,1,54,1,54,5,54,1289,8,54,10,54,12,54,1292,9,54,1,55,1,
  	55,1,55,3,55,1297,8,55,1,55,1,55,1,56,1,56,1,56,1,56,1,56,1,57,1,57,1,
  	57,1,57,1,57,1,57,1,57,3,57,1313,8,57,1,58,1,58,4,58,1317,8,58,11,58,
  	12,58,1318,1,58,1,58,5,58,1323,8,58,10,58,12,58,1326,9,58,1,58,5,58,1329,
  	8,58,10,58,12,58,1332,9,58,1,59,1,59,3,59,1336,8,59,1,59,1,59,1,60,1,
  	60,1,60,1,61,1,61,3,61,1345,8,61,1,62,1,62,4,62,1349,8,62,11,62,12,62,
  	1350,1,62,1,62,5,62,1355,8,62,10,62,12,62,1358,9,62,1,62,5,62,1361,8,
  	62,10,62,12,62,1364,9,62,1,63,1,63,3,63,1368,8,63,1,63,1,63,1,64,1,64,
  	1,64,1,65,1,65,4,65,1377,8,65,11,65,12,65,1378,1,65,1,65,5,65,1383,8,
  	65,10,65,12,65,1386,9,65,1,65,5,65,1389,8,65,10,65,12,65,1392,9,65,1,
  	66,1,66,3,66,1396,8,66,1,66,1,66,1,67,1,67,1,67,3,67,1403,8,67,1,67,1,
  	67,3,67,1407,8,67,1,68,1,68,1,68,1,69,1,69,1,69,1,69,5,69,1416,8,69,10,
  	69,12,69,1419,9,69,1,69,3,69,1422,8,69,1,70,1,70,3,70,1426,8,70,1,70,
  	3,70,1429,8,70,1,70,1,70,1,70,1,70,1,71,1,71,3,71,1437,8,71,1,72,1,72,
  	1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,3,72,1452,8,72,
  	1,73,1,73,3,73,1456,8,73,1,73,1,73,1,73,3,73,1461,8,73,1,73,3,73,1464,
  	8,73,1,74,4,74,1467,8,74,11,74,12,74,1468,1,75,1,75,1,75,1,75,1,75,1,
  	75,1,75,3,75,1478,8,75,1,76,1,76,1,76,1,76,5,76,1484,8,76,10,76,12,76,
  	1487,9,76,1,76,3,76,1490,8,76,1,77,1,77,1,77,1,78,1,78,1,78,1,78,5,78,
  	1499,8,78,10,78,12,78,1502,9,78,1,78,3,78,1505,8,78,1,79,1,79,1,79,1,
  	80,1,80,1,80,3,80,1513,8,80,1,80,3,80,1516,8,80,1,81,1,81,1,81,5,81,1521,
  	8,81,10,81,12,81,1524,9,81,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,
  	82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,3,82,1544,8,82,1,83,1,
  	83,1,83,3,83,1549,8,83,1,83,1,83,1,83,1,83,1,83,1,83,3,83,1557,8,83,1,
  	84,1,84,1,85,1,85,1,86,3,86,1564,8,86,1,86,1,86,1,86,1,86,1,87,1,87,1,
  	87,1,88,1,88,1,88,1,89,1,89,1,90,1,90,1,91,1,91,1,91,5,91,1583,8,91,10,
  	91,12,91,1586,9,91,1,92,1,92,1,92,5,92,1591,8,92,10,92,12,92,1594,9,92,
  	1,93,1,93,1,93,1,93,1,93,1,93,3,93,1602,8,93,1,94,1,94,1,95,1,95,1,95,
  	1,95,1,95,3,95,1611,8,95,1,96,1,96,1,96,1,96,1,96,3,96,1618,8,96,1,97,
  	1,97,3,97,1622,8,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,
  	1,97,1,97,3,97,1636,8,97,1,98,1,98,3,98,1640,8,98,1,98,1,98,1,98,1,98,
  	1,98,1,98,1,98,1,98,1,98,1,98,1,98,1,98,3,98,1654,8,98,1,99,1,99,1,100,
  	1,100,1,101,1,101,1,101,1,101,1,101,3,101,1665,8,101,1,102,1,102,1,102,
  	1,102,1,102,3,102,1672,8,102,1,103,1,103,1,104,4,104,1677,8,104,11,104,
  	12,104,1678,1,105,1,105,1,106,1,106,1,107,4,107,1686,8,107,11,107,12,
  	107,1687,1,108,1,108,1,108,1,108,1,108,1,108,1,108,1,108,1,108,1,108,
  	3,108,1700,8,108,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,
  	3,109,1711,8,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,
  	1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,
  	1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,
  	1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,3,109,1754,8,109,1,109,
  	1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,3,109,
  	1768,8,109,1,110,1,110,1,111,1,111,1,111,5,111,1775,8,111,10,111,12,111,
  	1778,9,111,1,112,1,112,1,112,5,112,1783,8,112,10,112,12,112,1786,9,112,
  	1,113,1,113,1,113,1,113,1,113,5,113,1793,8,113,10,113,12,113,1796,9,113,
  	1,114,4,114,1799,8,114,11,114,12,114,1800,1,115,1,115,1,115,1,115,1,115,
  	1,115,1,115,1,115,1,115,1,115,1,115,3,115,1814,8,115,1,116,1,116,1,116,
  	1,116,1,116,1,116,1,116,3,116,1823,8,116,1,117,1,117,1,117,1,118,1,118,
  	1,118,5,118,1831,8,118,10,118,12,118,1834,9,118,1,119,3,119,1837,8,119,
  	1,119,1,119,3,119,1841,8,119,1,120,4,120,1844,8,120,11,120,12,120,1845,
  	1,121,1,121,1,122,1,122,1,122,3,122,1853,8,122,1,122,5,122,1856,8,122,
  	10,122,12,122,1859,9,122,1,122,1,122,1,123,1,123,1,123,1,123,5,123,1867,
  	8,123,10,123,12,123,1870,9,123,1,124,1,124,1,125,1,125,1,125,1,125,1,
  	126,1,126,1,126,1,127,1,127,1,127,5,127,1884,8,127,10,127,12,127,1887,
  	9,127,1,128,3,128,1890,8,128,1,128,1,128,1,128,3,128,1895,8,128,1,128,
  	1,128,1,129,1,129,3,129,1901,8,129,1,129,1,129,1,130,1,130,1,131,1,131,
  	1,131,5,131,1910,8,131,10,131,12,131,1913,9,131,1,132,1,132,1,132,1,132,
  	1,133,4,133,1920,8,133,11,133,12,133,1921,1,134,1,134,1,134,1,134,1,134,
  	1,134,1,134,1,134,1,134,1,134,3,134,1934,8,134,1,135,1,135,1,135,1,135,
  	1,135,1,135,1,135,3,135,1943,8,135,1,136,1,136,1,136,3,136,1948,8,136,
  	1,136,1,136,1,136,1,136,4,136,1954,8,136,11,136,12,136,1955,3,136,1958,
  	8,136,1,137,1,137,1,137,4,137,1963,8,137,11,137,12,137,1964,3,137,1967,
  	8,137,1,138,1,138,1,138,3,138,1972,8,138,1,138,1,138,3,138,1976,8,138,
  	3,138,1978,8,138,1,139,4,139,1981,8,139,11,139,12,139,1982,1,140,1,140,
  	1,140,1,140,1,140,1,141,1,141,1,141,1,141,1,141,1,141,1,141,1,141,1,141,
  	1,141,1,141,1,141,3,141,2002,8,141,1,141,1,141,1,141,1,141,1,141,1,141,
  	1,141,3,141,2011,8,141,1,141,1,141,1,141,1,141,1,141,3,141,2018,8,141,
  	1,141,1,141,1,141,1,141,1,141,1,141,1,141,3,141,2027,8,141,1,141,1,141,
  	1,141,1,141,1,141,3,141,2034,8,141,1,141,1,141,1,141,1,141,1,141,1,141,
  	1,141,1,141,3,141,2044,8,141,1,141,1,141,1,141,1,141,1,141,1,141,1,141,
  	1,141,1,141,1,141,1,141,1,141,1,141,1,141,1,141,3,141,2061,8,141,1,141,
  	1,141,4,141,2065,8,141,11,141,12,141,2066,3,141,2069,8,141,1,142,1,142,
  	1,142,1,142,1,142,1,142,1,142,1,142,1,142,3,142,2080,8,142,1,143,1,143,
  	1,143,1,143,1,144,1,144,1,144,1,144,1,145,1,145,3,145,2092,8,145,1,146,
  	1,146,1,146,1,146,1,146,1,146,1,146,1,146,1,146,1,146,1,146,1,146,1,146,
  	1,146,1,146,1,146,1,146,1,146,1,146,1,146,1,146,3,146,2115,8,146,1,147,
  	1,147,1,147,1,147,5,147,2121,8,147,10,147,12,147,2124,9,147,1,148,1,148,
  	1,149,3,149,2129,8,149,1,149,1,149,1,150,4,150,2134,8,150,11,150,12,150,
  	2135,1,150,1,150,3,150,2140,8,150,1,151,1,151,1,151,1,151,1,151,1,151,
  	1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,
  	1,151,1,151,1,151,1,151,1,151,3,151,2165,8,151,1,151,1,151,1,151,3,151,
  	2170,8,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,
  	1,151,1,151,1,151,1,151,1,151,3,151,2187,8,151,1,152,1,152,1,152,3,152,
  	2192,8,152,1,152,5,152,2195,8,152,10,152,12,152,2198,9,152,1,153,1,153,
  	1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,
  	1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,
  	1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,
  	1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,
  	1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,
  	1,153,3,153,2263,8,153,1,153,1,153,3,153,2267,8,153,1,154,1,154,3,154,
  	2271,8,154,1,155,1,155,1,155,1,156,1,156,1,156,1,157,4,157,2280,8,157,
  	11,157,12,157,2281,1,158,1,158,1,159,1,159,3,159,2288,8,159,1,159,1,159,
  	1,160,1,160,5,160,2294,8,160,10,160,12,160,2297,9,160,1,161,1,161,1,161,
  	1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,3,161,2310,8,161,1,162,
  	1,162,1,162,1,162,1,162,1,162,1,162,1,162,3,162,2320,8,162,1,162,1,162,
  	1,162,3,162,2325,8,162,3,162,2327,8,162,1,163,1,163,3,163,2331,8,163,
  	1,164,1,164,1,164,1,164,3,164,2337,8,164,1,165,1,165,1,165,1,165,1,165,
  	1,165,1,165,1,165,1,165,1,165,1,165,1,165,1,165,1,165,1,165,1,165,1,165,
  	1,165,1,165,1,165,1,165,1,165,1,165,1,165,3,165,2363,8,165,1,166,1,166,
  	1,166,1,166,1,166,5,166,2370,8,166,10,166,12,166,2373,9,166,1,167,1,167,
  	1,168,1,168,1,168,5,168,2380,8,168,10,168,12,168,2383,9,168,1,169,1,169,
  	1,169,5,169,2388,8,169,10,169,12,169,2391,9,169,1,169,1,169,1,169,5,169,
  	2396,8,169,10,169,12,169,2399,9,169,1,169,1,169,1,169,5,169,2404,8,169,
  	10,169,12,169,2407,9,169,1,169,1,169,1,169,5,169,2412,8,169,10,169,12,
  	169,2415,9,169,3,169,2417,8,169,1,170,1,170,1,170,1,170,1,170,1,170,1,
  	170,1,170,1,170,1,170,1,170,1,170,1,170,1,170,1,170,1,170,1,170,1,170,
  	3,170,2437,8,170,1,171,1,171,1,171,5,171,2442,8,171,10,171,12,171,2445,
  	9,171,1,172,1,172,1,172,1,172,1,172,1,172,1,172,3,172,2454,8,172,1,173,
  	1,173,1,173,5,173,2459,8,173,10,173,12,173,2462,9,173,4,173,2464,8,173,
  	11,173,12,173,2465,1,173,1,173,1,173,1,173,1,173,3,173,2473,8,173,1,174,
  	1,174,1,174,1,175,1,175,3,175,2480,8,175,1,176,1,176,1,176,3,176,2485,
  	8,176,1,177,4,177,2488,8,177,11,177,12,177,2489,1,178,1,178,1,178,1,178,
  	1,178,3,178,2497,8,178,1,179,1,179,1,179,1,179,1,179,1,180,1,180,1,181,
  	1,181,1,182,1,182,1,183,4,183,2511,8,183,11,183,12,183,2512,1,184,1,184,
  	1,184,1,184,1,185,1,185,3,185,2521,8,185,1,185,1,185,1,186,1,186,4,186,
  	2527,8,186,11,186,12,186,2528,1,186,1,186,5,186,2533,8,186,10,186,12,
  	186,2536,9,186,1,186,5,186,2539,8,186,10,186,12,186,2542,9,186,1,187,
  	1,187,1,187,1,187,4,187,2548,8,187,11,187,12,187,2549,3,187,2552,8,187,
  	1,188,1,188,1,188,1,188,1,188,1,188,1,188,3,188,2561,8,188,1,189,1,189,
  	1,189,5,189,2566,8,189,10,189,12,189,2569,9,189,1,189,3,189,2572,8,189,
  	1,190,1,190,1,190,1,190,1,190,3,190,2579,8,190,1,191,1,191,4,191,2583,
  	8,191,11,191,12,191,2584,1,191,1,191,1,191,5,191,2590,8,191,10,191,12,
  	191,2593,9,191,1,192,1,192,1,192,1,192,1,193,1,193,1,193,5,193,2602,8,
  	193,10,193,12,193,2605,9,193,1,194,1,194,1,195,1,195,1,195,5,195,2612,
  	8,195,10,195,12,195,2615,9,195,1,196,1,196,1,196,1,196,1,196,3,196,2622,
  	8,196,1,197,1,197,1,197,5,197,2627,8,197,10,197,12,197,2630,9,197,1,198,
  	1,198,3,198,2634,8,198,1,199,1,199,3,199,2638,8,199,1,200,1,200,3,200,
  	2642,8,200,1,201,1,201,1,201,1,201,1,201,3,201,2649,8,201,1,202,1,202,
  	1,202,1,202,1,202,1,202,3,202,2657,8,202,1,203,1,203,1,203,5,203,2662,
  	8,203,10,203,12,203,2665,9,203,1,204,1,204,1,204,1,204,1,204,1,204,1,
  	204,1,204,1,204,1,204,1,204,1,204,3,204,2679,8,204,1,205,1,205,1,205,
  	3,205,2684,8,205,1,206,1,206,1,206,1,206,1,206,3,206,2691,8,206,1,207,
  	1,207,1,207,1,207,1,207,3,207,2698,8,207,1,208,1,208,3,208,2702,8,208,
  	1,209,1,209,1,209,1,209,1,209,3,209,2709,8,209,1,210,1,210,1,210,1,210,
  	1,210,1,210,1,210,1,210,1,210,1,210,1,210,1,210,1,210,1,210,3,210,2725,
  	8,210,1,211,1,211,1,211,1,211,1,211,3,211,2732,8,211,1,212,1,212,1,212,
  	1,212,1,212,3,212,2739,8,212,1,213,1,213,1,213,3,213,2744,8,213,1,213,
  	1,213,1,214,1,214,1,215,1,215,1,215,3,215,2753,8,215,1,216,1,216,1,216,
  	1,216,1,216,3,216,2760,8,216,1,217,1,217,3,217,2764,8,217,1,218,1,218,
  	1,218,1,218,1,218,3,218,2771,8,218,1,219,1,219,3,219,2775,8,219,1,220,
  	1,220,1,220,3,220,2780,8,220,1,221,1,221,1,221,1,221,1,222,1,222,1,222,
  	1,222,1,222,3,222,2791,8,222,1,223,1,223,1,223,1,223,1,223,3,223,2798,
  	8,223,1,224,1,224,1,225,1,225,1,225,1,225,1,226,1,226,1,226,1,226,1,226,
  	3,226,2811,8,226,1,227,1,227,1,228,1,228,1,228,3,228,2818,8,228,1,228,
  	1,228,1,229,1,229,1,229,1,229,1,229,3,229,2827,8,229,1,230,1,230,1,230,
  	1,230,1,230,3,230,2834,8,230,1,231,1,231,1,231,3,231,2839,8,231,1,231,
  	1,231,1,232,1,232,3,232,2845,8,232,1,232,5,232,2848,8,232,10,232,12,232,
  	2851,9,232,1,233,1,233,1,233,3,233,2856,8,233,1,233,1,233,1,234,1,234,
  	3,234,2862,8,234,1,235,1,235,3,235,2866,8,235,1,236,4,236,2869,8,236,
  	11,236,12,236,2870,1,237,1,237,1,238,1,238,1,238,3,238,2878,8,238,1,238,
  	1,238,1,239,1,239,5,239,2884,8,239,10,239,12,239,2887,9,239,1,240,1,240,
  	1,240,3,240,2892,8,240,1,240,1,240,1,241,1,241,5,241,2898,8,241,10,241,
  	12,241,2901,9,241,1,242,1,242,1,242,1,242,3,242,2907,8,242,1,243,1,243,
  	1,244,1,244,1,245,1,245,1,246,1,246,1,246,5,246,2918,8,246,10,246,12,
  	246,2921,9,246,1,246,1,246,1,247,4,247,2926,8,247,11,247,12,247,2927,
  	1,248,4,248,2931,8,248,11,248,12,248,2932,1,249,1,249,1,250,1,250,1,251,
  	1,251,1,252,1,252,1,253,1,253,1,254,1,254,1,255,1,255,1,255,0,0,256,0,
  	2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,
  	52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,
  	98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,
  	134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,
  	170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,
  	206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,
  	242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,
  	278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,
  	314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,
  	350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,
  	386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,420,
  	422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,
  	458,460,462,464,466,468,470,472,474,476,478,480,482,484,486,488,490,492,
  	494,496,498,500,502,504,506,508,510,0,12,1,0,16,18,2,0,22,22,48,49,2,
  	0,38,39,41,42,1,0,32,34,2,0,76,76,99,99,7,0,4,4,12,12,24,24,31,31,38,
  	40,42,42,48,50,2,0,132,132,134,134,2,0,133,133,135,135,2,0,100,100,136,
  	136,5,0,100,100,102,102,108,108,120,123,132,133,7,0,82,89,91,95,97,97,
  	99,99,101,101,103,104,107,107,1,0,137,139,3200,0,513,1,0,0,0,2,542,1,
  	0,0,0,4,549,1,0,0,0,6,552,1,0,0,0,8,562,1,0,0,0,10,569,1,0,0,0,12,571,
  	1,0,0,0,14,585,1,0,0,0,16,601,1,0,0,0,18,617,1,0,0,0,20,624,1,0,0,0,22,
  	629,1,0,0,0,24,633,1,0,0,0,26,688,1,0,0,0,28,690,1,0,0,0,30,738,1,0,0,
  	0,32,770,1,0,0,0,34,774,1,0,0,0,36,776,1,0,0,0,38,778,1,0,0,0,40,794,
  	1,0,0,0,42,833,1,0,0,0,44,835,1,0,0,0,46,912,1,0,0,0,48,914,1,0,0,0,50,
  	919,1,0,0,0,52,986,1,0,0,0,54,1000,1,0,0,0,56,1002,1,0,0,0,58,1004,1,
  	0,0,0,60,1011,1,0,0,0,62,1013,1,0,0,0,64,1016,1,0,0,0,66,1021,1,0,0,0,
  	68,1025,1,0,0,0,70,1041,1,0,0,0,72,1043,1,0,0,0,74,1075,1,0,0,0,76,1098,
  	1,0,0,0,78,1163,1,0,0,0,80,1165,1,0,0,0,82,1168,1,0,0,0,84,1175,1,0,0,
  	0,86,1184,1,0,0,0,88,1191,1,0,0,0,90,1213,1,0,0,0,92,1224,1,0,0,0,94,
  	1226,1,0,0,0,96,1236,1,0,0,0,98,1243,1,0,0,0,100,1249,1,0,0,0,102,1263,
  	1,0,0,0,104,1278,1,0,0,0,106,1281,1,0,0,0,108,1285,1,0,0,0,110,1293,1,
  	0,0,0,112,1300,1,0,0,0,114,1312,1,0,0,0,116,1314,1,0,0,0,118,1333,1,0,
  	0,0,120,1339,1,0,0,0,122,1344,1,0,0,0,124,1346,1,0,0,0,126,1365,1,0,0,
  	0,128,1371,1,0,0,0,130,1374,1,0,0,0,132,1393,1,0,0,0,134,1406,1,0,0,0,
  	136,1408,1,0,0,0,138,1411,1,0,0,0,140,1423,1,0,0,0,142,1436,1,0,0,0,144,
  	1451,1,0,0,0,146,1453,1,0,0,0,148,1466,1,0,0,0,150,1477,1,0,0,0,152,1479,
  	1,0,0,0,154,1491,1,0,0,0,156,1494,1,0,0,0,158,1506,1,0,0,0,160,1515,1,
  	0,0,0,162,1517,1,0,0,0,164,1543,1,0,0,0,166,1556,1,0,0,0,168,1558,1,0,
  	0,0,170,1560,1,0,0,0,172,1563,1,0,0,0,174,1569,1,0,0,0,176,1572,1,0,0,
  	0,178,1575,1,0,0,0,180,1577,1,0,0,0,182,1579,1,0,0,0,184,1587,1,0,0,0,
  	186,1601,1,0,0,0,188,1603,1,0,0,0,190,1610,1,0,0,0,192,1617,1,0,0,0,194,
  	1635,1,0,0,0,196,1653,1,0,0,0,198,1655,1,0,0,0,200,1657,1,0,0,0,202,1664,
  	1,0,0,0,204,1671,1,0,0,0,206,1673,1,0,0,0,208,1676,1,0,0,0,210,1680,1,
  	0,0,0,212,1682,1,0,0,0,214,1685,1,0,0,0,216,1699,1,0,0,0,218,1767,1,0,
  	0,0,220,1769,1,0,0,0,222,1771,1,0,0,0,224,1779,1,0,0,0,226,1787,1,0,0,
  	0,228,1798,1,0,0,0,230,1813,1,0,0,0,232,1822,1,0,0,0,234,1824,1,0,0,0,
  	236,1827,1,0,0,0,238,1836,1,0,0,0,240,1843,1,0,0,0,242,1847,1,0,0,0,244,
  	1849,1,0,0,0,246,1862,1,0,0,0,248,1871,1,0,0,0,250,1873,1,0,0,0,252,1877,
  	1,0,0,0,254,1880,1,0,0,0,256,1889,1,0,0,0,258,1898,1,0,0,0,260,1904,1,
  	0,0,0,262,1906,1,0,0,0,264,1914,1,0,0,0,266,1919,1,0,0,0,268,1933,1,0,
  	0,0,270,1942,1,0,0,0,272,1957,1,0,0,0,274,1966,1,0,0,0,276,1977,1,0,0,
  	0,278,1980,1,0,0,0,280,1984,1,0,0,0,282,2068,1,0,0,0,284,2079,1,0,0,0,
  	286,2081,1,0,0,0,288,2085,1,0,0,0,290,2091,1,0,0,0,292,2114,1,0,0,0,294,
  	2116,1,0,0,0,296,2125,1,0,0,0,298,2128,1,0,0,0,300,2133,1,0,0,0,302,2186,
  	1,0,0,0,304,2188,1,0,0,0,306,2266,1,0,0,0,308,2270,1,0,0,0,310,2272,1,
  	0,0,0,312,2275,1,0,0,0,314,2279,1,0,0,0,316,2283,1,0,0,0,318,2285,1,0,
  	0,0,320,2291,1,0,0,0,322,2309,1,0,0,0,324,2326,1,0,0,0,326,2328,1,0,0,
  	0,328,2336,1,0,0,0,330,2362,1,0,0,0,332,2364,1,0,0,0,334,2374,1,0,0,0,
  	336,2376,1,0,0,0,338,2416,1,0,0,0,340,2436,1,0,0,0,342,2438,1,0,0,0,344,
  	2453,1,0,0,0,346,2472,1,0,0,0,348,2474,1,0,0,0,350,2477,1,0,0,0,352,2484,
  	1,0,0,0,354,2487,1,0,0,0,356,2496,1,0,0,0,358,2498,1,0,0,0,360,2503,1,
  	0,0,0,362,2505,1,0,0,0,364,2507,1,0,0,0,366,2510,1,0,0,0,368,2514,1,0,
  	0,0,370,2518,1,0,0,0,372,2524,1,0,0,0,374,2551,1,0,0,0,376,2560,1,0,0,
  	0,378,2571,1,0,0,0,380,2578,1,0,0,0,382,2580,1,0,0,0,384,2594,1,0,0,0,
  	386,2598,1,0,0,0,388,2606,1,0,0,0,390,2608,1,0,0,0,392,2621,1,0,0,0,394,
  	2623,1,0,0,0,396,2633,1,0,0,0,398,2637,1,0,0,0,400,2641,1,0,0,0,402,2648,
  	1,0,0,0,404,2656,1,0,0,0,406,2658,1,0,0,0,408,2678,1,0,0,0,410,2683,1,
  	0,0,0,412,2690,1,0,0,0,414,2697,1,0,0,0,416,2701,1,0,0,0,418,2708,1,0,
  	0,0,420,2724,1,0,0,0,422,2731,1,0,0,0,424,2738,1,0,0,0,426,2743,1,0,0,
  	0,428,2747,1,0,0,0,430,2752,1,0,0,0,432,2759,1,0,0,0,434,2763,1,0,0,0,
  	436,2770,1,0,0,0,438,2774,1,0,0,0,440,2779,1,0,0,0,442,2781,1,0,0,0,444,
  	2790,1,0,0,0,446,2797,1,0,0,0,448,2799,1,0,0,0,450,2801,1,0,0,0,452,2810,
  	1,0,0,0,454,2812,1,0,0,0,456,2817,1,0,0,0,458,2826,1,0,0,0,460,2833,1,
  	0,0,0,462,2838,1,0,0,0,464,2844,1,0,0,0,466,2855,1,0,0,0,468,2861,1,0,
  	0,0,470,2865,1,0,0,0,472,2868,1,0,0,0,474,2872,1,0,0,0,476,2877,1,0,0,
  	0,478,2881,1,0,0,0,480,2891,1,0,0,0,482,2895,1,0,0,0,484,2906,1,0,0,0,
  	486,2908,1,0,0,0,488,2910,1,0,0,0,490,2912,1,0,0,0,492,2919,1,0,0,0,494,
  	2925,1,0,0,0,496,2930,1,0,0,0,498,2934,1,0,0,0,500,2936,1,0,0,0,502,2938,
  	1,0,0,0,504,2940,1,0,0,0,506,2942,1,0,0,0,508,2944,1,0,0,0,510,2946,1,
  	0,0,0,512,514,5,132,0,0,513,512,1,0,0,0,513,514,1,0,0,0,514,518,1,0,0,
  	0,515,517,3,490,245,0,516,515,1,0,0,0,517,520,1,0,0,0,518,516,1,0,0,0,
  	518,519,1,0,0,0,519,522,1,0,0,0,520,518,1,0,0,0,521,523,3,8,4,0,522,521,
  	1,0,0,0,522,523,1,0,0,0,523,527,1,0,0,0,524,526,3,490,245,0,525,524,1,
  	0,0,0,526,529,1,0,0,0,527,525,1,0,0,0,527,528,1,0,0,0,528,532,1,0,0,0,
  	529,527,1,0,0,0,530,533,3,2,1,0,531,533,3,20,10,0,532,530,1,0,0,0,532,
  	531,1,0,0,0,533,535,1,0,0,0,534,536,5,133,0,0,535,534,1,0,0,0,535,536,
  	1,0,0,0,536,538,1,0,0,0,537,539,3,490,245,0,538,537,1,0,0,0,538,539,1,
  	0,0,0,539,540,1,0,0,0,540,541,5,0,0,1,541,1,1,0,0,0,542,543,5,21,0,0,
  	543,545,3,492,246,0,544,546,3,24,12,0,545,544,1,0,0,0,545,546,1,0,0,0,
  	546,547,1,0,0,0,547,548,3,4,2,0,548,3,1,0,0,0,549,550,5,27,0,0,550,551,
  	3,6,3,0,551,5,1,0,0,0,552,553,3,486,243,0,553,554,3,20,10,0,554,558,3,
  	488,244,0,555,557,3,490,245,0,556,555,1,0,0,0,557,560,1,0,0,0,558,556,
  	1,0,0,0,558,559,1,0,0,0,559,7,1,0,0,0,560,558,1,0,0,0,561,563,3,10,5,
  	0,562,561,1,0,0,0,563,564,1,0,0,0,564,562,1,0,0,0,564,565,1,0,0,0,565,
  	9,1,0,0,0,566,570,3,12,6,0,567,570,3,14,7,0,568,570,3,16,8,0,569,566,
  	1,0,0,0,569,567,1,0,0,0,569,568,1,0,0,0,570,11,1,0,0,0,571,572,5,128,
  	0,0,572,573,5,51,0,0,573,578,3,18,9,0,574,575,5,102,0,0,575,577,3,18,
  	9,0,576,574,1,0,0,0,577,580,1,0,0,0,578,576,1,0,0,0,578,579,1,0,0,0,579,
  	581,1,0,0,0,580,578,1,0,0,0,581,583,5,129,0,0,582,584,3,490,245,0,583,
  	582,1,0,0,0,583,584,1,0,0,0,584,13,1,0,0,0,585,586,5,128,0,0,586,594,
  	5,52,0,0,587,590,5,90,0,0,588,591,3,464,232,0,589,591,3,478,239,0,590,
  	588,1,0,0,0,590,589,1,0,0,0,591,593,1,0,0,0,592,587,1,0,0,0,593,596,1,
  	0,0,0,594,592,1,0,0,0,594,595,1,0,0,0,595,597,1,0,0,0,596,594,1,0,0,0,
  	597,599,5,129,0,0,598,600,3,490,245,0,599,598,1,0,0,0,599,600,1,0,0,0,
  	600,15,1,0,0,0,601,602,5,128,0,0,602,610,5,53,0,0,603,606,5,90,0,0,604,
  	607,3,464,232,0,605,607,3,478,239,0,606,604,1,0,0,0,606,605,1,0,0,0,607,
  	609,1,0,0,0,608,603,1,0,0,0,609,612,1,0,0,0,610,608,1,0,0,0,610,611,1,
  	0,0,0,611,613,1,0,0,0,612,610,1,0,0,0,613,615,5,129,0,0,614,616,3,490,
  	245,0,615,614,1,0,0,0,615,616,1,0,0,0,616,17,1,0,0,0,617,618,5,127,0,
  	0,618,19,1,0,0,0,619,620,3,22,11,0,620,621,3,40,20,0,621,625,1,0,0,0,
  	622,625,3,22,11,0,623,625,3,40,20,0,624,619,1,0,0,0,624,622,1,0,0,0,624,
  	623,1,0,0,0,625,21,1,0,0,0,626,630,3,28,14,0,627,630,5,1,0,0,628,630,
  	3,490,245,0,629,626,1,0,0,0,629,627,1,0,0,0,629,628,1,0,0,0,630,631,1,
  	0,0,0,631,629,1,0,0,0,631,632,1,0,0,0,632,23,1,0,0,0,633,642,5,120,0,
  	0,634,639,3,26,13,0,635,636,5,102,0,0,636,638,3,26,13,0,637,635,1,0,0,
  	0,638,641,1,0,0,0,639,637,1,0,0,0,639,640,1,0,0,0,640,643,1,0,0,0,641,
  	639,1,0,0,0,642,634,1,0,0,0,642,643,1,0,0,0,643,645,1,0,0,0,644,646,5,
  	102,0,0,645,644,1,0,0,0,645,646,1,0,0,0,646,647,1,0,0,0,647,648,5,121,
  	0,0,648,25,1,0,0,0,649,689,3,460,230,0,650,666,3,426,213,0,651,652,5,
  	120,0,0,652,653,5,98,0,0,653,667,5,121,0,0,654,663,5,120,0,0,655,660,
  	3,34,17,0,656,657,5,102,0,0,657,659,3,34,17,0,658,656,1,0,0,0,659,662,
  	1,0,0,0,660,658,1,0,0,0,660,661,1,0,0,0,661,664,1,0,0,0,662,660,1,0,0,
  	0,663,655,1,0,0,0,663,664,1,0,0,0,664,665,1,0,0,0,665,667,5,121,0,0,666,
  	651,1,0,0,0,666,654,1,0,0,0,666,667,1,0,0,0,667,689,1,0,0,0,668,684,3,
  	456,228,0,669,670,5,120,0,0,670,671,5,98,0,0,671,685,5,121,0,0,672,681,
  	5,120,0,0,673,678,3,460,230,0,674,675,5,102,0,0,675,677,3,460,230,0,676,
  	674,1,0,0,0,677,680,1,0,0,0,678,676,1,0,0,0,678,679,1,0,0,0,679,682,1,
  	0,0,0,680,678,1,0,0,0,681,673,1,0,0,0,681,682,1,0,0,0,682,683,1,0,0,0,
  	683,685,5,121,0,0,684,669,1,0,0,0,684,672,1,0,0,0,684,685,1,0,0,0,685,
  	689,1,0,0,0,686,687,5,21,0,0,687,689,3,492,246,0,688,649,1,0,0,0,688,
  	650,1,0,0,0,688,668,1,0,0,0,688,686,1,0,0,0,689,27,1,0,0,0,690,692,5,
  	14,0,0,691,693,5,24,0,0,692,691,1,0,0,0,692,693,1,0,0,0,693,694,1,0,0,
  	0,694,697,3,492,246,0,695,696,5,4,0,0,696,698,3,492,246,0,697,695,1,0,
  	0,0,697,698,1,0,0,0,698,700,1,0,0,0,699,701,3,30,15,0,700,699,1,0,0,0,
  	700,701,1,0,0,0,701,703,1,0,0,0,702,704,3,490,245,0,703,702,1,0,0,0,704,
  	705,1,0,0,0,705,703,1,0,0,0,705,706,1,0,0,0,706,29,1,0,0,0,707,719,5,
  	120,0,0,708,713,3,32,16,0,709,710,5,102,0,0,710,712,3,32,16,0,711,709,
  	1,0,0,0,712,715,1,0,0,0,713,711,1,0,0,0,713,714,1,0,0,0,714,717,1,0,0,
  	0,715,713,1,0,0,0,716,718,5,102,0,0,717,716,1,0,0,0,717,718,1,0,0,0,718,
  	720,1,0,0,0,719,708,1,0,0,0,719,720,1,0,0,0,720,721,1,0,0,0,721,739,5,
  	121,0,0,722,723,5,12,0,0,723,735,5,120,0,0,724,729,3,32,16,0,725,726,
  	5,102,0,0,726,728,3,32,16,0,727,725,1,0,0,0,728,731,1,0,0,0,729,727,1,
  	0,0,0,729,730,1,0,0,0,730,733,1,0,0,0,731,729,1,0,0,0,732,734,5,102,0,
  	0,733,732,1,0,0,0,733,734,1,0,0,0,734,736,1,0,0,0,735,724,1,0,0,0,735,
  	736,1,0,0,0,736,737,1,0,0,0,737,739,5,121,0,0,738,707,1,0,0,0,738,722,
  	1,0,0,0,739,31,1,0,0,0,740,771,3,458,229,0,741,757,3,428,214,0,742,743,
  	5,120,0,0,743,744,5,98,0,0,744,758,5,121,0,0,745,754,5,120,0,0,746,751,
  	3,34,17,0,747,748,5,102,0,0,748,750,3,34,17,0,749,747,1,0,0,0,750,753,
  	1,0,0,0,751,749,1,0,0,0,751,752,1,0,0,0,752,755,1,0,0,0,753,751,1,0,0,
  	0,754,746,1,0,0,0,754,755,1,0,0,0,755,756,1,0,0,0,756,758,5,121,0,0,757,
  	742,1,0,0,0,757,745,1,0,0,0,757,758,1,0,0,0,758,771,1,0,0,0,759,768,3,
  	454,227,0,760,761,5,120,0,0,761,762,5,98,0,0,762,769,5,121,0,0,763,765,
  	5,120,0,0,764,766,3,182,91,0,765,764,1,0,0,0,765,766,1,0,0,0,766,767,
  	1,0,0,0,767,769,5,121,0,0,768,760,1,0,0,0,768,763,1,0,0,0,768,769,1,0,
  	0,0,769,771,1,0,0,0,770,740,1,0,0,0,770,741,1,0,0,0,770,759,1,0,0,0,771,
  	33,1,0,0,0,772,775,3,458,229,0,773,775,3,404,202,0,774,772,1,0,0,0,774,
  	773,1,0,0,0,775,35,1,0,0,0,776,777,7,0,0,0,777,37,1,0,0,0,778,783,3,434,
  	217,0,779,780,5,102,0,0,780,782,3,434,217,0,781,779,1,0,0,0,782,785,1,
  	0,0,0,783,781,1,0,0,0,783,784,1,0,0,0,784,39,1,0,0,0,785,783,1,0,0,0,
  	786,788,3,42,21,0,787,789,3,490,245,0,788,787,1,0,0,0,789,790,1,0,0,0,
  	790,788,1,0,0,0,790,791,1,0,0,0,791,795,1,0,0,0,792,795,5,1,0,0,793,795,
  	3,490,245,0,794,786,1,0,0,0,794,792,1,0,0,0,794,793,1,0,0,0,795,796,1,
  	0,0,0,796,794,1,0,0,0,796,797,1,0,0,0,797,41,1,0,0,0,798,834,3,44,22,
  	0,799,834,3,46,23,0,800,834,3,48,24,0,801,834,3,52,26,0,802,834,3,94,
  	47,0,803,834,3,96,48,0,804,805,5,8,0,0,805,807,5,120,0,0,806,808,3,224,
  	112,0,807,806,1,0,0,0,807,808,1,0,0,0,808,809,1,0,0,0,809,834,5,121,0,
  	0,810,811,5,30,0,0,811,834,3,166,83,0,812,813,5,128,0,0,813,815,5,61,
  	0,0,814,816,3,156,78,0,815,814,1,0,0,0,815,816,1,0,0,0,816,817,1,0,0,
  	0,817,834,5,129,0,0,818,819,5,128,0,0,819,821,5,62,0,0,820,822,3,152,
  	76,0,821,820,1,0,0,0,821,822,1,0,0,0,822,823,1,0,0,0,823,834,5,129,0,
  	0,824,825,5,128,0,0,825,827,5,59,0,0,826,828,3,138,69,0,827,826,1,0,0,
  	0,827,828,1,0,0,0,828,829,1,0,0,0,829,834,5,129,0,0,830,834,3,164,82,
  	0,831,834,3,272,136,0,832,834,3,294,147,0,833,798,1,0,0,0,833,799,1,0,
  	0,0,833,800,1,0,0,0,833,801,1,0,0,0,833,802,1,0,0,0,833,803,1,0,0,0,833,
  	804,1,0,0,0,833,810,1,0,0,0,833,812,1,0,0,0,833,818,1,0,0,0,833,824,1,
  	0,0,0,833,830,1,0,0,0,833,831,1,0,0,0,833,832,1,0,0,0,834,43,1,0,0,0,
  	835,836,5,6,0,0,836,838,3,88,44,0,837,839,3,234,117,0,838,837,1,0,0,0,
  	838,839,1,0,0,0,839,841,1,0,0,0,840,842,3,120,60,0,841,840,1,0,0,0,841,
  	842,1,0,0,0,842,45,1,0,0,0,843,844,5,26,0,0,844,845,3,202,101,0,845,846,
  	5,104,0,0,846,847,3,192,96,0,847,913,1,0,0,0,848,849,5,26,0,0,849,850,
  	5,36,0,0,850,852,3,202,101,0,851,853,3,84,42,0,852,851,1,0,0,0,852,853,
  	1,0,0,0,853,855,1,0,0,0,854,856,3,62,31,0,855,854,1,0,0,0,855,856,1,0,
  	0,0,856,858,1,0,0,0,857,859,3,68,34,0,858,857,1,0,0,0,858,859,1,0,0,0,
  	859,913,1,0,0,0,860,862,5,7,0,0,861,863,3,92,46,0,862,861,1,0,0,0,862,
  	863,1,0,0,0,863,864,1,0,0,0,864,865,3,88,44,0,865,867,3,252,126,0,866,
  	868,3,266,133,0,867,866,1,0,0,0,867,868,1,0,0,0,868,913,1,0,0,0,869,871,
  	5,22,0,0,870,872,3,92,46,0,871,870,1,0,0,0,871,872,1,0,0,0,872,873,1,
  	0,0,0,873,874,3,88,44,0,874,876,3,252,126,0,875,877,3,266,133,0,876,875,
  	1,0,0,0,876,877,1,0,0,0,877,913,1,0,0,0,878,880,5,7,0,0,879,881,3,92,
  	46,0,880,879,1,0,0,0,880,881,1,0,0,0,881,882,1,0,0,0,882,884,3,88,44,
  	0,883,885,3,80,40,0,884,883,1,0,0,0,884,885,1,0,0,0,885,887,1,0,0,0,886,
  	888,3,244,122,0,887,886,1,0,0,0,887,888,1,0,0,0,888,890,1,0,0,0,889,891,
  	3,266,133,0,890,889,1,0,0,0,890,891,1,0,0,0,891,913,1,0,0,0,892,894,5,
  	22,0,0,893,895,3,92,46,0,894,893,1,0,0,0,894,895,1,0,0,0,895,896,1,0,
  	0,0,896,898,3,88,44,0,897,899,3,80,40,0,898,897,1,0,0,0,898,899,1,0,0,
  	0,899,901,1,0,0,0,900,902,3,244,122,0,901,900,1,0,0,0,901,902,1,0,0,0,
  	902,904,1,0,0,0,903,905,3,266,133,0,904,903,1,0,0,0,904,905,1,0,0,0,905,
  	913,1,0,0,0,906,907,5,7,0,0,907,908,5,36,0,0,908,910,3,202,101,0,909,
  	911,3,82,41,0,910,909,1,0,0,0,910,911,1,0,0,0,911,913,1,0,0,0,912,843,
  	1,0,0,0,912,848,1,0,0,0,912,860,1,0,0,0,912,869,1,0,0,0,912,878,1,0,0,
  	0,912,892,1,0,0,0,912,906,1,0,0,0,913,47,1,0,0,0,914,915,5,26,0,0,915,
  	916,3,50,25,0,916,917,5,75,0,0,917,918,3,192,96,0,918,49,1,0,0,0,919,
  	924,3,422,211,0,920,921,5,102,0,0,921,923,3,422,211,0,922,920,1,0,0,0,
  	923,926,1,0,0,0,924,922,1,0,0,0,924,925,1,0,0,0,925,51,1,0,0,0,926,924,
  	1,0,0,0,927,929,5,19,0,0,928,930,3,54,27,0,929,928,1,0,0,0,929,930,1,
  	0,0,0,930,931,1,0,0,0,931,933,3,220,110,0,932,934,3,128,64,0,933,932,
  	1,0,0,0,933,934,1,0,0,0,934,987,1,0,0,0,935,936,5,26,0,0,936,937,5,19,
  	0,0,937,987,3,74,37,0,938,939,5,7,0,0,939,941,5,19,0,0,940,942,3,92,46,
  	0,941,940,1,0,0,0,941,942,1,0,0,0,942,943,1,0,0,0,943,945,3,90,45,0,944,
  	946,3,266,133,0,945,944,1,0,0,0,945,946,1,0,0,0,946,987,1,0,0,0,947,948,
  	5,22,0,0,948,950,5,19,0,0,949,951,3,92,46,0,950,949,1,0,0,0,950,951,1,
  	0,0,0,951,952,1,0,0,0,952,954,3,90,45,0,953,955,3,266,133,0,954,953,1,
  	0,0,0,954,955,1,0,0,0,955,987,1,0,0,0,956,957,5,7,0,0,957,959,5,19,0,
  	0,958,960,3,92,46,0,959,958,1,0,0,0,959,960,1,0,0,0,960,961,1,0,0,0,961,
  	963,3,90,45,0,962,964,3,80,40,0,963,962,1,0,0,0,963,964,1,0,0,0,964,966,
  	1,0,0,0,965,967,3,244,122,0,966,965,1,0,0,0,966,967,1,0,0,0,967,969,1,
  	0,0,0,968,970,3,266,133,0,969,968,1,0,0,0,969,970,1,0,0,0,970,987,1,0,
  	0,0,971,972,5,22,0,0,972,974,5,19,0,0,973,975,3,92,46,0,974,973,1,0,0,
  	0,974,975,1,0,0,0,975,976,1,0,0,0,976,978,3,90,45,0,977,979,3,80,40,0,
  	978,977,1,0,0,0,978,979,1,0,0,0,979,981,1,0,0,0,980,982,3,244,122,0,981,
  	980,1,0,0,0,981,982,1,0,0,0,982,984,1,0,0,0,983,985,3,266,133,0,984,983,
  	1,0,0,0,984,985,1,0,0,0,985,987,1,0,0,0,986,927,1,0,0,0,986,935,1,0,0,
  	0,986,938,1,0,0,0,986,947,1,0,0,0,986,956,1,0,0,0,986,971,1,0,0,0,987,
  	53,1,0,0,0,988,989,5,128,0,0,989,990,5,69,0,0,990,1001,5,129,0,0,991,
  	992,5,128,0,0,992,993,5,68,0,0,993,1001,5,129,0,0,994,995,5,128,0,0,995,
  	996,5,70,0,0,996,1001,5,129,0,0,997,998,5,128,0,0,998,999,5,71,0,0,999,
  	1001,5,129,0,0,1000,988,1,0,0,0,1000,991,1,0,0,0,1000,994,1,0,0,0,1000,
  	997,1,0,0,0,1001,55,1,0,0,0,1002,1003,7,1,0,0,1003,57,1,0,0,0,1004,1005,
  	5,50,0,0,1005,1006,3,190,95,0,1006,59,1,0,0,0,1007,1012,5,48,0,0,1008,
  	1012,5,49,0,0,1009,1012,5,22,0,0,1010,1012,3,58,29,0,1011,1007,1,0,0,
  	0,1011,1008,1,0,0,0,1011,1009,1,0,0,0,1011,1010,1,0,0,0,1012,61,1,0,0,
  	0,1013,1014,5,86,0,0,1014,1015,3,64,32,0,1015,63,1,0,0,0,1016,1017,3,
  	452,226,0,1017,1018,5,76,0,0,1018,1019,3,66,33,0,1019,65,1,0,0,0,1020,
  	1022,3,452,226,0,1021,1020,1,0,0,0,1022,1023,1,0,0,0,1023,1021,1,0,0,
  	0,1023,1024,1,0,0,0,1024,67,1,0,0,0,1025,1026,5,27,0,0,1026,1027,3,70,
  	35,0,1027,69,1,0,0,0,1028,1030,3,486,243,0,1029,1031,3,72,36,0,1030,1029,
  	1,0,0,0,1030,1031,1,0,0,0,1031,1032,1,0,0,0,1032,1033,3,488,244,0,1033,
  	1042,1,0,0,0,1034,1035,5,132,0,0,1035,1036,5,98,0,0,1036,1042,5,133,0,
  	0,1037,1038,3,486,243,0,1038,1039,5,98,0,0,1039,1040,3,488,244,0,1040,
  	1042,1,0,0,0,1041,1028,1,0,0,0,1041,1034,1,0,0,0,1041,1037,1,0,0,0,1042,
  	71,1,0,0,0,1043,1053,3,74,37,0,1044,1046,3,490,245,0,1045,1044,1,0,0,
  	0,1046,1047,1,0,0,0,1047,1045,1,0,0,0,1047,1048,1,0,0,0,1048,1049,1,0,
  	0,0,1049,1050,3,74,37,0,1050,1052,1,0,0,0,1051,1045,1,0,0,0,1052,1055,
  	1,0,0,0,1053,1051,1,0,0,0,1053,1054,1,0,0,0,1054,1059,1,0,0,0,1055,1053,
  	1,0,0,0,1056,1058,3,490,245,0,1057,1056,1,0,0,0,1058,1061,1,0,0,0,1059,
  	1057,1,0,0,0,1059,1060,1,0,0,0,1060,73,1,0,0,0,1061,1059,1,0,0,0,1062,
  	1064,5,29,0,0,1063,1065,3,228,114,0,1064,1063,1,0,0,0,1064,1065,1,0,0,
  	0,1065,1066,1,0,0,0,1066,1067,5,99,0,0,1067,1068,3,202,101,0,1068,1069,
  	5,104,0,0,1069,1070,3,190,95,0,1070,1076,1,0,0,0,1071,1072,3,202,101,
  	0,1072,1073,5,104,0,0,1073,1074,3,190,95,0,1074,1076,1,0,0,0,1075,1062,
  	1,0,0,0,1075,1071,1,0,0,0,1076,75,1,0,0,0,1077,1079,5,7,0,0,1078,1080,
  	5,36,0,0,1079,1078,1,0,0,0,1079,1080,1,0,0,0,1080,1081,1,0,0,0,1081,1083,
  	3,202,101,0,1082,1084,3,82,41,0,1083,1082,1,0,0,0,1083,1084,1,0,0,0,1084,
  	1099,1,0,0,0,1085,1087,5,26,0,0,1086,1088,5,36,0,0,1087,1086,1,0,0,0,
  	1087,1088,1,0,0,0,1088,1089,1,0,0,0,1089,1091,3,202,101,0,1090,1092,3,
  	86,43,0,1091,1090,1,0,0,0,1091,1092,1,0,0,0,1092,1099,1,0,0,0,1093,1095,
  	5,26,0,0,1094,1096,5,19,0,0,1095,1094,1,0,0,0,1095,1096,1,0,0,0,1096,
  	1097,1,0,0,0,1097,1099,3,74,37,0,1098,1077,1,0,0,0,1098,1085,1,0,0,0,
  	1098,1093,1,0,0,0,1099,77,1,0,0,0,1100,1102,5,26,0,0,1101,1103,5,19,0,
  	0,1102,1101,1,0,0,0,1102,1103,1,0,0,0,1103,1104,1,0,0,0,1104,1164,3,74,
  	37,0,1105,1107,5,7,0,0,1106,1108,5,19,0,0,1107,1106,1,0,0,0,1107,1108,
  	1,0,0,0,1108,1110,1,0,0,0,1109,1111,3,92,46,0,1110,1109,1,0,0,0,1110,
  	1111,1,0,0,0,1111,1112,1,0,0,0,1112,1113,3,90,45,0,1113,1115,3,252,126,
  	0,1114,1116,3,266,133,0,1115,1114,1,0,0,0,1115,1116,1,0,0,0,1116,1164,
  	1,0,0,0,1117,1119,5,22,0,0,1118,1120,5,19,0,0,1119,1118,1,0,0,0,1119,
  	1120,1,0,0,0,1120,1122,1,0,0,0,1121,1123,3,92,46,0,1122,1121,1,0,0,0,
  	1122,1123,1,0,0,0,1123,1124,1,0,0,0,1124,1125,3,90,45,0,1125,1127,3,252,
  	126,0,1126,1128,3,266,133,0,1127,1126,1,0,0,0,1127,1128,1,0,0,0,1128,
  	1164,1,0,0,0,1129,1131,5,7,0,0,1130,1132,5,19,0,0,1131,1130,1,0,0,0,1131,
  	1132,1,0,0,0,1132,1134,1,0,0,0,1133,1135,3,92,46,0,1134,1133,1,0,0,0,
  	1134,1135,1,0,0,0,1135,1136,1,0,0,0,1136,1138,3,90,45,0,1137,1139,3,80,
  	40,0,1138,1137,1,0,0,0,1138,1139,1,0,0,0,1139,1141,1,0,0,0,1140,1142,
  	3,244,122,0,1141,1140,1,0,0,0,1141,1142,1,0,0,0,1142,1144,1,0,0,0,1143,
  	1145,3,266,133,0,1144,1143,1,0,0,0,1144,1145,1,0,0,0,1145,1164,1,0,0,
  	0,1146,1148,5,22,0,0,1147,1149,5,19,0,0,1148,1147,1,0,0,0,1148,1149,1,
  	0,0,0,1149,1151,1,0,0,0,1150,1152,3,92,46,0,1151,1150,1,0,0,0,1151,1152,
  	1,0,0,0,1152,1153,1,0,0,0,1153,1155,3,90,45,0,1154,1156,3,80,40,0,1155,
  	1154,1,0,0,0,1155,1156,1,0,0,0,1156,1158,1,0,0,0,1157,1159,3,244,122,
  	0,1158,1157,1,0,0,0,1158,1159,1,0,0,0,1159,1161,1,0,0,0,1160,1162,3,266,
  	133,0,1161,1160,1,0,0,0,1161,1162,1,0,0,0,1162,1164,1,0,0,0,1163,1100,
  	1,0,0,0,1163,1105,1,0,0,0,1163,1117,1,0,0,0,1163,1129,1,0,0,0,1163,1146,
  	1,0,0,0,1164,79,1,0,0,0,1165,1166,5,75,0,0,1166,1167,3,242,121,0,1167,
  	81,1,0,0,0,1168,1169,5,75,0,0,1169,1170,3,242,121,0,1170,83,1,0,0,0,1171,
  	1172,5,75,0,0,1172,1176,3,242,121,0,1173,1174,5,104,0,0,1174,1176,3,230,
  	115,0,1175,1171,1,0,0,0,1175,1173,1,0,0,0,1176,85,1,0,0,0,1177,1178,5,
  	75,0,0,1178,1185,3,242,121,0,1179,1180,5,104,0,0,1180,1181,3,232,116,
  	0,1181,1182,5,86,0,0,1182,1183,3,64,32,0,1183,1185,1,0,0,0,1184,1177,
  	1,0,0,0,1184,1179,1,0,0,0,1185,87,1,0,0,0,1186,1187,3,198,99,0,1187,1188,
  	5,74,0,0,1188,1189,3,202,101,0,1189,1192,1,0,0,0,1190,1192,3,202,101,
  	0,1191,1186,1,0,0,0,1191,1190,1,0,0,0,1192,89,1,0,0,0,1193,1195,5,29,
  	0,0,1194,1196,3,228,114,0,1195,1194,1,0,0,0,1195,1196,1,0,0,0,1196,1197,
  	1,0,0,0,1197,1198,5,99,0,0,1198,1199,3,198,99,0,1199,1200,5,74,0,0,1200,
  	1201,3,202,101,0,1201,1214,1,0,0,0,1202,1204,5,29,0,0,1203,1205,3,228,
  	114,0,1204,1203,1,0,0,0,1204,1205,1,0,0,0,1205,1206,1,0,0,0,1206,1207,
  	5,99,0,0,1207,1214,3,202,101,0,1208,1209,3,198,99,0,1209,1210,5,74,0,
  	0,1210,1211,3,202,101,0,1211,1214,1,0,0,0,1212,1214,3,202,101,0,1213,
  	1193,1,0,0,0,1213,1202,1,0,0,0,1213,1208,1,0,0,0,1213,1212,1,0,0,0,1214,
  	91,1,0,0,0,1215,1216,5,128,0,0,1216,1217,5,67,0,0,1217,1218,5,125,0,0,
  	1218,1219,5,125,0,0,1219,1225,5,129,0,0,1220,1221,5,128,0,0,1221,1222,
  	5,67,0,0,1222,1223,5,125,0,0,1223,1225,5,129,0,0,1224,1215,1,0,0,0,1224,
  	1220,1,0,0,0,1225,93,1,0,0,0,1226,1228,5,9,0,0,1227,1229,3,60,30,0,1228,
  	1227,1,0,0,0,1228,1229,1,0,0,0,1229,1230,1,0,0,0,1230,1232,5,19,0,0,1231,
  	1233,3,54,27,0,1232,1231,1,0,0,0,1232,1233,1,0,0,0,1233,1234,1,0,0,0,
  	1234,1235,3,220,110,0,1235,95,1,0,0,0,1236,1237,5,26,0,0,1237,1238,5,
  	37,0,0,1238,1240,3,422,211,0,1239,1241,3,98,49,0,1240,1239,1,0,0,0,1240,
  	1241,1,0,0,0,1241,97,1,0,0,0,1242,1244,3,100,50,0,1243,1242,1,0,0,0,1244,
  	1245,1,0,0,0,1245,1243,1,0,0,0,1245,1246,1,0,0,0,1246,99,1,0,0,0,1247,
  	1250,3,464,232,0,1248,1250,5,28,0,0,1249,1247,1,0,0,0,1249,1248,1,0,0,
  	0,1250,101,1,0,0,0,1251,1252,5,47,0,0,1252,1253,3,104,52,0,1253,1254,
  	5,104,0,0,1254,1255,3,360,180,0,1255,1264,1,0,0,0,1256,1257,5,47,0,0,
  	1257,1258,3,104,52,0,1258,1259,5,77,0,0,1259,1261,3,360,180,0,1260,1262,
  	3,110,55,0,1261,1260,1,0,0,0,1261,1262,1,0,0,0,1262,1264,1,0,0,0,1263,
  	1251,1,0,0,0,1263,1256,1,0,0,0,1264,103,1,0,0,0,1265,1267,3,404,202,0,
  	1266,1268,3,106,53,0,1267,1266,1,0,0,0,1267,1268,1,0,0,0,1268,1279,1,
  	0,0,0,1269,1270,3,464,232,0,1270,1271,3,412,206,0,1271,1272,3,464,232,
  	0,1272,1279,1,0,0,0,1273,1274,3,404,202,0,1274,1275,5,132,0,0,1275,1276,
  	3,108,54,0,1276,1277,5,133,0,0,1277,1279,1,0,0,0,1278,1265,1,0,0,0,1278,
  	1269,1,0,0,0,1278,1273,1,0,0,0,1279,105,1,0,0,0,1280,1282,3,464,232,0,
  	1281,1280,1,0,0,0,1282,1283,1,0,0,0,1283,1281,1,0,0,0,1283,1284,1,0,0,
  	0,1284,107,1,0,0,0,1285,1290,3,458,229,0,1286,1287,5,102,0,0,1287,1289,
  	3,458,229,0,1288,1286,1,0,0,0,1289,1292,1,0,0,0,1290,1288,1,0,0,0,1290,
  	1291,1,0,0,0,1291,109,1,0,0,0,1292,1290,1,0,0,0,1293,1294,5,27,0,0,1294,
  	1296,3,486,243,0,1295,1297,3,130,65,0,1296,1295,1,0,0,0,1296,1297,1,0,
  	0,0,1297,1298,1,0,0,0,1298,1299,3,488,244,0,1299,111,1,0,0,0,1300,1301,
  	5,47,0,0,1301,1302,3,406,203,0,1302,1303,5,75,0,0,1303,1304,3,180,90,
  	0,1304,113,1,0,0,0,1305,1313,3,76,38,0,1306,1313,3,274,137,0,1307,1308,
  	5,8,0,0,1308,1309,3,294,147,0,1309,1310,5,75,0,0,1310,1311,3,180,90,0,
  	1311,1313,1,0,0,0,1312,1305,1,0,0,0,1312,1306,1,0,0,0,1312,1307,1,0,0,
  	0,1313,115,1,0,0,0,1314,1324,3,114,57,0,1315,1317,3,490,245,0,1316,1315,
  	1,0,0,0,1317,1318,1,0,0,0,1318,1316,1,0,0,0,1318,1319,1,0,0,0,1319,1320,
  	1,0,0,0,1320,1321,3,114,57,0,1321,1323,1,0,0,0,1322,1316,1,0,0,0,1323,
  	1326,1,0,0,0,1324,1322,1,0,0,0,1324,1325,1,0,0,0,1325,1330,1,0,0,0,1326,
  	1324,1,0,0,0,1327,1329,3,490,245,0,1328,1327,1,0,0,0,1329,1332,1,0,0,
  	0,1330,1328,1,0,0,0,1330,1331,1,0,0,0,1331,117,1,0,0,0,1332,1330,1,0,
  	0,0,1333,1335,3,486,243,0,1334,1336,3,116,58,0,1335,1334,1,0,0,0,1335,
  	1336,1,0,0,0,1336,1337,1,0,0,0,1337,1338,3,488,244,0,1338,119,1,0,0,0,
  	1339,1340,5,27,0,0,1340,1341,3,118,59,0,1341,121,1,0,0,0,1342,1345,3,
  	78,39,0,1343,1345,3,274,137,0,1344,1342,1,0,0,0,1344,1343,1,0,0,0,1345,
  	123,1,0,0,0,1346,1356,3,122,61,0,1347,1349,3,490,245,0,1348,1347,1,0,
  	0,0,1349,1350,1,0,0,0,1350,1348,1,0,0,0,1350,1351,1,0,0,0,1351,1352,1,
  	0,0,0,1352,1353,3,122,61,0,1353,1355,1,0,0,0,1354,1348,1,0,0,0,1355,1358,
  	1,0,0,0,1356,1354,1,0,0,0,1356,1357,1,0,0,0,1357,1362,1,0,0,0,1358,1356,
  	1,0,0,0,1359,1361,3,490,245,0,1360,1359,1,0,0,0,1361,1364,1,0,0,0,1362,
  	1360,1,0,0,0,1362,1363,1,0,0,0,1363,125,1,0,0,0,1364,1362,1,0,0,0,1365,
  	1367,3,486,243,0,1366,1368,3,124,62,0,1367,1366,1,0,0,0,1367,1368,1,0,
  	0,0,1368,1369,1,0,0,0,1369,1370,3,488,244,0,1370,127,1,0,0,0,1371,1372,
  	5,27,0,0,1372,1373,3,126,63,0,1373,129,1,0,0,0,1374,1384,3,274,137,0,
  	1375,1377,3,490,245,0,1376,1375,1,0,0,0,1377,1378,1,0,0,0,1378,1376,1,
  	0,0,0,1378,1379,1,0,0,0,1379,1380,1,0,0,0,1380,1381,3,274,137,0,1381,
  	1383,1,0,0,0,1382,1376,1,0,0,0,1383,1386,1,0,0,0,1384,1382,1,0,0,0,1384,
  	1385,1,0,0,0,1385,1390,1,0,0,0,1386,1384,1,0,0,0,1387,1389,3,490,245,
  	0,1388,1387,1,0,0,0,1389,1392,1,0,0,0,1390,1388,1,0,0,0,1390,1391,1,0,
  	0,0,1391,131,1,0,0,0,1392,1390,1,0,0,0,1393,1395,3,486,243,0,1394,1396,
  	3,130,65,0,1395,1394,1,0,0,0,1395,1396,1,0,0,0,1396,1397,1,0,0,0,1397,
  	1398,3,488,244,0,1398,133,1,0,0,0,1399,1407,3,132,66,0,1400,1402,3,486,
  	243,0,1401,1403,3,382,191,0,1402,1401,1,0,0,0,1402,1403,1,0,0,0,1403,
  	1404,1,0,0,0,1404,1405,3,488,244,0,1405,1407,1,0,0,0,1406,1399,1,0,0,
  	0,1406,1400,1,0,0,0,1407,135,1,0,0,0,1408,1409,5,27,0,0,1409,1410,3,134,
  	67,0,1410,137,1,0,0,0,1411,1417,3,140,70,0,1412,1413,3,490,245,0,1413,
  	1414,3,140,70,0,1414,1416,1,0,0,0,1415,1412,1,0,0,0,1416,1419,1,0,0,0,
  	1417,1415,1,0,0,0,1417,1418,1,0,0,0,1418,1421,1,0,0,0,1419,1417,1,0,0,
  	0,1420,1422,3,490,245,0,1421,1420,1,0,0,0,1421,1422,1,0,0,0,1422,139,
  	1,0,0,0,1423,1425,3,510,255,0,1424,1426,3,144,72,0,1425,1424,1,0,0,0,
  	1425,1426,1,0,0,0,1426,1428,1,0,0,0,1427,1429,3,146,73,0,1428,1427,1,
  	0,0,0,1428,1429,1,0,0,0,1429,1430,1,0,0,0,1430,1431,3,294,147,0,1431,
  	1432,5,104,0,0,1432,1433,3,292,146,0,1433,141,1,0,0,0,1434,1437,5,94,
  	0,0,1435,1437,3,470,235,0,1436,1434,1,0,0,0,1436,1435,1,0,0,0,1437,143,
  	1,0,0,0,1438,1439,5,122,0,0,1439,1440,3,504,252,0,1440,1441,5,123,0,0,
  	1441,1452,1,0,0,0,1442,1443,5,122,0,0,1443,1444,3,142,71,0,1444,1445,
  	3,504,252,0,1445,1446,5,123,0,0,1446,1452,1,0,0,0,1447,1448,5,122,0,0,
  	1448,1449,3,142,71,0,1449,1450,5,123,0,0,1450,1452,1,0,0,0,1451,1438,
  	1,0,0,0,1451,1442,1,0,0,0,1451,1447,1,0,0,0,1452,145,1,0,0,0,1453,1455,
  	5,29,0,0,1454,1456,3,148,74,0,1455,1454,1,0,0,0,1455,1456,1,0,0,0,1456,
  	1457,1,0,0,0,1457,1463,5,99,0,0,1458,1460,5,29,0,0,1459,1461,3,148,74,
  	0,1460,1459,1,0,0,0,1460,1461,1,0,0,0,1461,1462,1,0,0,0,1462,1464,5,99,
  	0,0,1463,1458,1,0,0,0,1463,1464,1,0,0,0,1464,147,1,0,0,0,1465,1467,3,
  	150,75,0,1466,1465,1,0,0,0,1467,1468,1,0,0,0,1468,1466,1,0,0,0,1468,1469,
  	1,0,0,0,1469,149,1,0,0,0,1470,1478,3,464,232,0,1471,1472,5,120,0,0,1472,
  	1473,3,464,232,0,1473,1474,5,75,0,0,1474,1475,3,194,97,0,1475,1476,5,
  	121,0,0,1476,1478,1,0,0,0,1477,1470,1,0,0,0,1477,1471,1,0,0,0,1478,151,
  	1,0,0,0,1479,1485,3,154,77,0,1480,1481,3,490,245,0,1481,1482,3,154,77,
  	0,1482,1484,1,0,0,0,1483,1480,1,0,0,0,1484,1487,1,0,0,0,1485,1483,1,0,
  	0,0,1485,1486,1,0,0,0,1486,1489,1,0,0,0,1487,1485,1,0,0,0,1488,1490,3,
  	490,245,0,1489,1488,1,0,0,0,1489,1490,1,0,0,0,1490,153,1,0,0,0,1491,1492,
  	3,394,197,0,1492,1493,3,160,80,0,1493,155,1,0,0,0,1494,1500,3,158,79,
  	0,1495,1496,3,490,245,0,1496,1497,3,158,79,0,1497,1499,1,0,0,0,1498,1495,
  	1,0,0,0,1499,1502,1,0,0,0,1500,1498,1,0,0,0,1500,1501,1,0,0,0,1501,1504,
  	1,0,0,0,1502,1500,1,0,0,0,1503,1505,3,490,245,0,1504,1503,1,0,0,0,1504,
  	1505,1,0,0,0,1505,157,1,0,0,0,1506,1507,3,394,197,0,1507,1508,3,160,80,
  	0,1508,159,1,0,0,0,1509,1516,3,510,255,0,1510,1512,5,122,0,0,1511,1513,
  	3,162,81,0,1512,1511,1,0,0,0,1512,1513,1,0,0,0,1513,1514,1,0,0,0,1514,
  	1516,5,123,0,0,1515,1509,1,0,0,0,1515,1510,1,0,0,0,1516,161,1,0,0,0,1517,
  	1522,3,510,255,0,1518,1519,5,102,0,0,1519,1521,3,510,255,0,1520,1518,
  	1,0,0,0,1521,1524,1,0,0,0,1522,1520,1,0,0,0,1522,1523,1,0,0,0,1523,163,
  	1,0,0,0,1524,1522,1,0,0,0,1525,1526,5,128,0,0,1526,1527,5,65,0,0,1527,
  	1528,3,396,198,0,1528,1529,3,302,151,0,1529,1530,5,129,0,0,1530,1544,
  	1,0,0,0,1531,1532,5,128,0,0,1532,1533,5,65,0,0,1533,1534,3,428,214,0,
  	1534,1535,3,302,151,0,1535,1536,5,129,0,0,1536,1544,1,0,0,0,1537,1538,
  	5,128,0,0,1538,1539,5,65,0,0,1539,1540,5,21,0,0,1540,1541,3,302,151,0,
  	1541,1542,5,129,0,0,1542,1544,1,0,0,0,1543,1525,1,0,0,0,1543,1531,1,0,
  	0,0,1543,1537,1,0,0,0,1544,165,1,0,0,0,1545,1546,5,14,0,0,1546,1548,3,
  	168,84,0,1547,1549,3,170,85,0,1548,1547,1,0,0,0,1548,1549,1,0,0,0,1549,
  	1550,1,0,0,0,1550,1551,3,172,86,0,1551,1557,1,0,0,0,1552,1553,5,31,0,
  	0,1553,1554,3,168,84,0,1554,1555,3,172,86,0,1555,1557,1,0,0,0,1556,1545,
  	1,0,0,0,1556,1552,1,0,0,0,1557,167,1,0,0,0,1558,1559,7,2,0,0,1559,169,
  	1,0,0,0,1560,1561,7,3,0,0,1561,171,1,0,0,0,1562,1564,3,510,255,0,1563,
  	1562,1,0,0,0,1563,1564,1,0,0,0,1564,1565,1,0,0,0,1565,1566,3,458,229,
  	0,1566,1567,5,75,0,0,1567,1568,3,180,90,0,1568,173,1,0,0,0,1569,1570,
  	5,75,0,0,1570,1571,3,178,89,0,1571,175,1,0,0,0,1572,1573,5,75,0,0,1573,
  	1574,3,418,209,0,1574,177,1,0,0,0,1575,1576,3,194,97,0,1576,179,1,0,0,
  	0,1577,1578,3,196,98,0,1578,181,1,0,0,0,1579,1584,3,458,229,0,1580,1581,
  	5,102,0,0,1581,1583,3,458,229,0,1582,1580,1,0,0,0,1583,1586,1,0,0,0,1584,
  	1582,1,0,0,0,1584,1585,1,0,0,0,1585,183,1,0,0,0,1586,1584,1,0,0,0,1587,
  	1592,3,178,89,0,1588,1589,5,102,0,0,1589,1591,3,178,89,0,1590,1588,1,
  	0,0,0,1591,1594,1,0,0,0,1592,1590,1,0,0,0,1592,1593,1,0,0,0,1593,185,
  	1,0,0,0,1594,1592,1,0,0,0,1595,1596,5,128,0,0,1596,1597,5,63,0,0,1597,
  	1602,5,129,0,0,1598,1599,5,128,0,0,1599,1600,5,64,0,0,1600,1602,5,129,
  	0,0,1601,1595,1,0,0,0,1601,1598,1,0,0,0,1602,187,1,0,0,0,1603,1604,7,
  	4,0,0,1604,189,1,0,0,0,1605,1611,3,194,97,0,1606,1607,3,194,97,0,1607,
  	1608,5,75,0,0,1608,1609,3,242,121,0,1609,1611,1,0,0,0,1610,1605,1,0,0,
  	0,1610,1606,1,0,0,0,1611,191,1,0,0,0,1612,1618,3,196,98,0,1613,1614,3,
  	196,98,0,1614,1615,5,75,0,0,1615,1616,3,242,121,0,1616,1618,1,0,0,0,1617,
  	1612,1,0,0,0,1617,1613,1,0,0,0,1618,193,1,0,0,0,1619,1621,5,29,0,0,1620,
  	1622,3,228,114,0,1621,1620,1,0,0,0,1621,1622,1,0,0,0,1622,1623,1,0,0,
  	0,1623,1624,3,188,94,0,1624,1625,3,194,97,0,1625,1636,1,0,0,0,1626,1627,
  	3,212,106,0,1627,1628,5,74,0,0,1628,1629,3,194,97,0,1629,1636,1,0,0,0,
  	1630,1631,3,458,229,0,1631,1632,5,75,0,0,1632,1633,3,202,101,0,1633,1636,
  	1,0,0,0,1634,1636,3,202,101,0,1635,1619,1,0,0,0,1635,1626,1,0,0,0,1635,
  	1630,1,0,0,0,1635,1634,1,0,0,0,1636,195,1,0,0,0,1637,1639,5,29,0,0,1638,
  	1640,3,228,114,0,1639,1638,1,0,0,0,1639,1640,1,0,0,0,1640,1641,1,0,0,
  	0,1641,1642,3,188,94,0,1642,1643,3,196,98,0,1643,1654,1,0,0,0,1644,1645,
  	3,198,99,0,1645,1646,5,74,0,0,1646,1647,3,196,98,0,1647,1654,1,0,0,0,
  	1648,1649,3,458,229,0,1649,1650,5,75,0,0,1650,1651,3,202,101,0,1651,1654,
  	1,0,0,0,1652,1654,3,204,102,0,1653,1637,1,0,0,0,1653,1644,1,0,0,0,1653,
  	1648,1,0,0,0,1653,1652,1,0,0,0,1654,197,1,0,0,0,1655,1656,3,212,106,0,
  	1656,199,1,0,0,0,1657,1658,3,206,103,0,1658,201,1,0,0,0,1659,1665,3,212,
  	106,0,1660,1661,3,212,106,0,1661,1662,5,76,0,0,1662,1663,3,194,97,0,1663,
  	1665,1,0,0,0,1664,1659,1,0,0,0,1664,1660,1,0,0,0,1665,203,1,0,0,0,1666,
  	1672,3,212,106,0,1667,1668,3,212,106,0,1668,1669,5,76,0,0,1669,1670,3,
  	196,98,0,1670,1672,1,0,0,0,1671,1666,1,0,0,0,1671,1667,1,0,0,0,1672,205,
  	1,0,0,0,1673,1674,3,208,104,0,1674,207,1,0,0,0,1675,1677,3,210,105,0,
  	1676,1675,1,0,0,0,1677,1678,1,0,0,0,1678,1676,1,0,0,0,1678,1679,1,0,0,
  	0,1679,209,1,0,0,0,1680,1681,3,216,108,0,1681,211,1,0,0,0,1682,1683,3,
  	214,107,0,1683,213,1,0,0,0,1684,1686,3,216,108,0,1685,1684,1,0,0,0,1686,
  	1687,1,0,0,0,1687,1685,1,0,0,0,1687,1688,1,0,0,0,1688,215,1,0,0,0,1689,
  	1700,3,218,109,0,1690,1691,5,95,0,0,1691,1700,3,218,109,0,1692,1700,3,
  	424,212,0,1693,1700,3,450,225,0,1694,1695,5,105,0,0,1695,1700,3,414,207,
  	0,1696,1697,5,105,0,0,1697,1700,3,436,218,0,1698,1700,3,186,93,0,1699,
  	1689,1,0,0,0,1699,1690,1,0,0,0,1699,1692,1,0,0,0,1699,1693,1,0,0,0,1699,
  	1694,1,0,0,0,1699,1696,1,0,0,0,1699,1698,1,0,0,0,1700,217,1,0,0,0,1701,
  	1768,3,420,210,0,1702,1768,3,448,224,0,1703,1768,5,91,0,0,1704,1705,5,
  	94,0,0,1705,1768,3,218,109,0,1706,1707,5,87,0,0,1707,1768,3,218,109,0,
  	1708,1710,5,132,0,0,1709,1711,3,262,131,0,1710,1709,1,0,0,0,1710,1711,
  	1,0,0,0,1711,1712,1,0,0,0,1712,1768,5,133,0,0,1713,1714,5,120,0,0,1714,
  	1768,5,121,0,0,1715,1716,5,120,0,0,1716,1717,3,190,95,0,1717,1718,5,102,
  	0,0,1718,1719,3,224,112,0,1719,1720,5,121,0,0,1720,1768,1,0,0,0,1721,
  	1722,5,118,0,0,1722,1768,5,119,0,0,1723,1724,5,118,0,0,1724,1725,3,224,
  	112,0,1725,1726,5,119,0,0,1726,1768,1,0,0,0,1727,1728,5,118,0,0,1728,
  	1729,3,226,113,0,1729,1730,5,119,0,0,1730,1768,1,0,0,0,1731,1732,5,122,
  	0,0,1732,1733,3,190,95,0,1733,1734,5,123,0,0,1734,1768,1,0,0,0,1735,1736,
  	5,120,0,0,1736,1737,3,190,95,0,1737,1738,5,121,0,0,1738,1768,1,0,0,0,
  	1739,1768,3,290,145,0,1740,1768,3,310,155,0,1741,1742,5,105,0,0,1742,
  	1768,3,398,199,0,1743,1744,5,105,0,0,1744,1745,5,120,0,0,1745,1746,3,
  	190,95,0,1746,1747,5,102,0,0,1747,1748,3,224,112,0,1748,1749,5,121,0,
  	0,1749,1768,1,0,0,0,1750,1751,5,105,0,0,1751,1753,5,122,0,0,1752,1754,
  	3,224,112,0,1753,1752,1,0,0,0,1753,1754,1,0,0,0,1754,1755,1,0,0,0,1755,
  	1768,5,123,0,0,1756,1757,5,105,0,0,1757,1768,3,458,229,0,1758,1759,5,
  	122,0,0,1759,1760,3,190,95,0,1760,1761,5,102,0,0,1761,1762,3,224,112,
  	0,1762,1763,5,123,0,0,1763,1768,1,0,0,0,1764,1768,3,504,252,0,1765,1768,
  	3,510,255,0,1766,1768,5,28,0,0,1767,1701,1,0,0,0,1767,1702,1,0,0,0,1767,
  	1703,1,0,0,0,1767,1704,1,0,0,0,1767,1706,1,0,0,0,1767,1708,1,0,0,0,1767,
  	1713,1,0,0,0,1767,1715,1,0,0,0,1767,1721,1,0,0,0,1767,1723,1,0,0,0,1767,
  	1727,1,0,0,0,1767,1731,1,0,0,0,1767,1735,1,0,0,0,1767,1739,1,0,0,0,1767,
  	1740,1,0,0,0,1767,1741,1,0,0,0,1767,1743,1,0,0,0,1767,1750,1,0,0,0,1767,
  	1756,1,0,0,0,1767,1758,1,0,0,0,1767,1764,1,0,0,0,1767,1765,1,0,0,0,1767,
  	1766,1,0,0,0,1768,219,1,0,0,0,1769,1770,3,178,89,0,1770,221,1,0,0,0,1771,
  	1776,3,192,96,0,1772,1773,5,102,0,0,1773,1775,3,192,96,0,1774,1772,1,
  	0,0,0,1775,1778,1,0,0,0,1776,1774,1,0,0,0,1776,1777,1,0,0,0,1777,223,
  	1,0,0,0,1778,1776,1,0,0,0,1779,1784,3,190,95,0,1780,1781,5,102,0,0,1781,
  	1783,3,190,95,0,1782,1780,1,0,0,0,1783,1786,1,0,0,0,1784,1782,1,0,0,0,
  	1784,1785,1,0,0,0,1785,225,1,0,0,0,1786,1784,1,0,0,0,1787,1788,3,190,
  	95,0,1788,1789,5,86,0,0,1789,1794,3,190,95,0,1790,1791,5,86,0,0,1791,
  	1793,3,190,95,0,1792,1790,1,0,0,0,1793,1796,1,0,0,0,1794,1792,1,0,0,0,
  	1794,1795,1,0,0,0,1795,227,1,0,0,0,1796,1794,1,0,0,0,1797,1799,3,230,
  	115,0,1798,1797,1,0,0,0,1799,1800,1,0,0,0,1800,1798,1,0,0,0,1800,1801,
  	1,0,0,0,1801,229,1,0,0,0,1802,1814,3,232,116,0,1803,1804,5,132,0,0,1804,
  	1805,3,448,224,0,1805,1806,5,133,0,0,1806,1814,1,0,0,0,1807,1808,5,132,
  	0,0,1808,1809,3,448,224,0,1809,1810,5,75,0,0,1810,1811,3,242,121,0,1811,
  	1812,5,133,0,0,1812,1814,1,0,0,0,1813,1802,1,0,0,0,1813,1803,1,0,0,0,
  	1813,1807,1,0,0,0,1814,231,1,0,0,0,1815,1823,3,448,224,0,1816,1817,5,
  	120,0,0,1817,1818,3,448,224,0,1818,1819,5,75,0,0,1819,1820,3,242,121,
  	0,1820,1821,5,121,0,0,1821,1823,1,0,0,0,1822,1815,1,0,0,0,1822,1816,1,
  	0,0,0,1823,233,1,0,0,0,1824,1825,5,86,0,0,1825,1826,3,236,118,0,1826,
  	235,1,0,0,0,1827,1832,3,238,119,0,1828,1829,5,102,0,0,1829,1831,3,238,
  	119,0,1830,1828,1,0,0,0,1831,1834,1,0,0,0,1832,1830,1,0,0,0,1832,1833,
  	1,0,0,0,1833,237,1,0,0,0,1834,1832,1,0,0,0,1835,1837,3,240,120,0,1836,
  	1835,1,0,0,0,1836,1837,1,0,0,0,1837,1838,1,0,0,0,1838,1840,5,76,0,0,1839,
  	1841,3,240,120,0,1840,1839,1,0,0,0,1840,1841,1,0,0,0,1841,239,1,0,0,0,
  	1842,1844,3,448,224,0,1843,1842,1,0,0,0,1844,1845,1,0,0,0,1845,1843,1,
  	0,0,0,1845,1846,1,0,0,0,1846,241,1,0,0,0,1847,1848,3,194,97,0,1848,243,
  	1,0,0,0,1849,1850,5,27,0,0,1850,1852,3,486,243,0,1851,1853,3,246,123,
  	0,1852,1851,1,0,0,0,1852,1853,1,0,0,0,1853,1857,1,0,0,0,1854,1856,3,490,
  	245,0,1855,1854,1,0,0,0,1856,1859,1,0,0,0,1857,1855,1,0,0,0,1857,1858,
  	1,0,0,0,1858,1860,1,0,0,0,1859,1857,1,0,0,0,1860,1861,3,488,244,0,1861,
  	245,1,0,0,0,1862,1868,3,248,124,0,1863,1864,3,490,245,0,1864,1865,3,248,
  	124,0,1865,1867,1,0,0,0,1866,1863,1,0,0,0,1867,1870,1,0,0,0,1868,1866,
  	1,0,0,0,1868,1869,1,0,0,0,1869,247,1,0,0,0,1870,1868,1,0,0,0,1871,1872,
  	3,250,125,0,1872,249,1,0,0,0,1873,1874,3,406,203,0,1874,1875,5,75,0,0,
  	1875,1876,3,180,90,0,1876,251,1,0,0,0,1877,1878,5,104,0,0,1878,1879,3,
  	254,127,0,1879,253,1,0,0,0,1880,1885,3,256,128,0,1881,1882,5,86,0,0,1882,
  	1884,3,256,128,0,1883,1881,1,0,0,0,1884,1887,1,0,0,0,1885,1883,1,0,0,
  	0,1885,1886,1,0,0,0,1886,255,1,0,0,0,1887,1885,1,0,0,0,1888,1890,3,258,
  	129,0,1889,1888,1,0,0,0,1889,1890,1,0,0,0,1890,1894,1,0,0,0,1891,1892,
  	3,200,100,0,1892,1893,5,74,0,0,1893,1895,1,0,0,0,1894,1891,1,0,0,0,1894,
  	1895,1,0,0,0,1895,1896,1,0,0,0,1896,1897,3,260,130,0,1897,257,1,0,0,0,
  	1898,1900,5,29,0,0,1899,1901,3,228,114,0,1900,1899,1,0,0,0,1900,1901,
  	1,0,0,0,1901,1902,1,0,0,0,1902,1903,5,99,0,0,1903,259,1,0,0,0,1904,1905,
  	3,208,104,0,1905,261,1,0,0,0,1906,1911,3,264,132,0,1907,1908,5,102,0,
  	0,1908,1910,3,264,132,0,1909,1907,1,0,0,0,1910,1913,1,0,0,0,1911,1909,
  	1,0,0,0,1911,1912,1,0,0,0,1912,263,1,0,0,0,1913,1911,1,0,0,0,1914,1915,
  	3,182,91,0,1915,1916,5,75,0,0,1916,1917,3,194,97,0,1917,265,1,0,0,0,1918,
  	1920,3,268,134,0,1919,1918,1,0,0,0,1920,1921,1,0,0,0,1921,1919,1,0,0,
  	0,1921,1922,1,0,0,0,1922,267,1,0,0,0,1923,1924,5,9,0,0,1924,1934,3,270,
  	135,0,1925,1926,5,9,0,0,1926,1927,3,56,28,0,1927,1928,3,270,135,0,1928,
  	1934,1,0,0,0,1929,1930,5,9,0,0,1930,1931,3,270,135,0,1931,1932,3,58,29,
  	0,1932,1934,1,0,0,0,1933,1923,1,0,0,0,1933,1925,1,0,0,0,1933,1929,1,0,
  	0,0,1934,269,1,0,0,0,1935,1943,3,426,213,0,1936,1937,5,120,0,0,1937,1943,
  	5,121,0,0,1938,1939,5,120,0,0,1939,1940,3,222,111,0,1940,1941,5,121,0,
  	0,1941,1943,1,0,0,0,1942,1935,1,0,0,0,1942,1936,1,0,0,0,1942,1938,1,0,
  	0,0,1943,271,1,0,0,0,1944,1958,3,282,141,0,1945,1947,3,294,147,0,1946,
  	1948,3,174,87,0,1947,1946,1,0,0,0,1947,1948,1,0,0,0,1948,1949,1,0,0,0,
  	1949,1950,3,276,138,0,1950,1958,1,0,0,0,1951,1958,3,102,51,0,1952,1954,
  	3,490,245,0,1953,1952,1,0,0,0,1954,1955,1,0,0,0,1955,1953,1,0,0,0,1955,
  	1956,1,0,0,0,1956,1958,1,0,0,0,1957,1944,1,0,0,0,1957,1945,1,0,0,0,1957,
  	1951,1,0,0,0,1957,1953,1,0,0,0,1958,273,1,0,0,0,1959,1967,3,272,136,0,
  	1960,1967,3,308,154,0,1961,1963,3,490,245,0,1962,1961,1,0,0,0,1963,1964,
  	1,0,0,0,1964,1962,1,0,0,0,1964,1965,1,0,0,0,1965,1967,1,0,0,0,1966,1959,
  	1,0,0,0,1966,1960,1,0,0,0,1966,1962,1,0,0,0,1967,275,1,0,0,0,1968,1969,
  	5,104,0,0,1969,1971,3,292,146,0,1970,1972,3,136,68,0,1971,1970,1,0,0,
  	0,1971,1972,1,0,0,0,1972,1978,1,0,0,0,1973,1975,3,278,139,0,1974,1976,
  	3,136,68,0,1975,1974,1,0,0,0,1975,1976,1,0,0,0,1976,1978,1,0,0,0,1977,
  	1968,1,0,0,0,1977,1973,1,0,0,0,1978,277,1,0,0,0,1979,1981,3,280,140,0,
  	1980,1979,1,0,0,0,1981,1982,1,0,0,0,1982,1980,1,0,0,0,1982,1983,1,0,0,
  	0,1983,279,1,0,0,0,1984,1985,5,86,0,0,1985,1986,3,342,171,0,1986,1987,
  	5,104,0,0,1987,1988,3,292,146,0,1988,281,1,0,0,0,1989,1990,3,294,147,
  	0,1990,1991,5,75,0,0,1991,1992,3,180,90,0,1992,2069,1,0,0,0,1993,1994,
  	3,458,229,0,1994,1995,5,102,0,0,1995,1996,3,182,91,0,1996,1997,5,75,0,
  	0,1997,1998,3,180,90,0,1998,2069,1,0,0,0,1999,2001,3,36,18,0,2000,2002,
  	3,504,252,0,2001,2000,1,0,0,0,2001,2002,1,0,0,0,2002,2003,1,0,0,0,2003,
  	2004,3,38,19,0,2004,2069,1,0,0,0,2005,2069,3,112,56,0,2006,2007,5,128,
  	0,0,2007,2008,5,72,0,0,2008,2010,3,406,203,0,2009,2011,3,176,88,0,2010,
  	2009,1,0,0,0,2010,2011,1,0,0,0,2011,2012,1,0,0,0,2012,2013,5,129,0,0,
  	2013,2069,1,0,0,0,2014,2015,5,128,0,0,2015,2017,5,54,0,0,2016,2018,3,
  	284,142,0,2017,2016,1,0,0,0,2017,2018,1,0,0,0,2018,2019,1,0,0,0,2019,
  	2020,3,460,230,0,2020,2021,5,129,0,0,2021,2069,1,0,0,0,2022,2023,5,128,
  	0,0,2023,2024,5,60,0,0,2024,2026,3,460,230,0,2025,2027,3,510,255,0,2026,
  	2025,1,0,0,0,2026,2027,1,0,0,0,2027,2028,1,0,0,0,2028,2029,5,129,0,0,
  	2029,2069,1,0,0,0,2030,2031,5,128,0,0,2031,2033,5,56,0,0,2032,2034,3,
  	284,142,0,2033,2032,1,0,0,0,2033,2034,1,0,0,0,2034,2035,1,0,0,0,2035,
  	2036,3,460,230,0,2036,2037,5,75,0,0,2037,2038,3,184,92,0,2038,2039,5,
  	129,0,0,2039,2069,1,0,0,0,2040,2041,5,128,0,0,2041,2043,5,57,0,0,2042,
  	2044,3,284,142,0,2043,2042,1,0,0,0,2043,2044,1,0,0,0,2044,2045,1,0,0,
  	0,2045,2046,3,460,230,0,2046,2047,5,75,0,0,2047,2048,3,184,92,0,2048,
  	2049,5,129,0,0,2049,2069,1,0,0,0,2050,2051,5,128,0,0,2051,2052,5,56,0,
  	0,2052,2053,5,19,0,0,2053,2054,3,220,110,0,2054,2055,5,129,0,0,2055,2069,
  	1,0,0,0,2056,2057,5,128,0,0,2057,2058,5,66,0,0,2058,2060,5,129,0,0,2059,
  	2061,3,386,193,0,2060,2059,1,0,0,0,2060,2061,1,0,0,0,2061,2062,1,0,0,
  	0,2062,2069,5,129,0,0,2063,2065,3,490,245,0,2064,2063,1,0,0,0,2065,2066,
  	1,0,0,0,2066,2064,1,0,0,0,2066,2067,1,0,0,0,2067,2069,1,0,0,0,2068,1989,
  	1,0,0,0,2068,1993,1,0,0,0,2068,1999,1,0,0,0,2068,2005,1,0,0,0,2068,2006,
  	1,0,0,0,2068,2014,1,0,0,0,2068,2022,1,0,0,0,2068,2030,1,0,0,0,2068,2040,
  	1,0,0,0,2068,2050,1,0,0,0,2068,2056,1,0,0,0,2068,2064,1,0,0,0,2069,283,
  	1,0,0,0,2070,2071,5,122,0,0,2071,2072,3,504,252,0,2072,2073,5,123,0,0,
  	2073,2080,1,0,0,0,2074,2075,5,122,0,0,2075,2076,3,142,71,0,2076,2077,
  	3,504,252,0,2077,2078,5,123,0,0,2078,2080,1,0,0,0,2079,2070,1,0,0,0,2079,
  	2074,1,0,0,0,2080,285,1,0,0,0,2081,2082,5,122,0,0,2082,2083,3,464,232,
  	0,2083,2084,5,86,0,0,2084,287,1,0,0,0,2085,2086,5,122,0,0,2086,2087,3,
  	462,231,0,2087,2088,5,86,0,0,2088,289,1,0,0,0,2089,2092,3,286,143,0,2090,
  	2092,3,288,144,0,2091,2089,1,0,0,0,2091,2090,1,0,0,0,2092,291,1,0,0,0,
  	2093,2094,3,294,147,0,2094,2095,5,75,0,0,2095,2096,3,178,89,0,2096,2115,
  	1,0,0,0,2097,2098,3,294,147,0,2098,2099,5,78,0,0,2099,2100,3,292,146,
  	0,2100,2115,1,0,0,0,2101,2102,3,294,147,0,2102,2103,5,79,0,0,2103,2104,
  	3,292,146,0,2104,2115,1,0,0,0,2105,2106,3,294,147,0,2106,2107,5,80,0,
  	0,2107,2108,3,292,146,0,2108,2115,1,0,0,0,2109,2110,3,294,147,0,2110,
  	2111,5,81,0,0,2111,2112,3,292,146,0,2112,2115,1,0,0,0,2113,2115,3,294,
  	147,0,2114,2093,1,0,0,0,2114,2097,1,0,0,0,2114,2101,1,0,0,0,2114,2105,
  	1,0,0,0,2114,2109,1,0,0,0,2114,2113,1,0,0,0,2115,293,1,0,0,0,2116,2122,
  	3,298,149,0,2117,2118,3,438,219,0,2118,2119,3,296,148,0,2119,2121,1,0,
  	0,0,2120,2117,1,0,0,0,2121,2124,1,0,0,0,2122,2120,1,0,0,0,2122,2123,1,
  	0,0,0,2123,295,1,0,0,0,2124,2122,1,0,0,0,2125,2126,3,298,149,0,2126,297,
  	1,0,0,0,2127,2129,5,90,0,0,2128,2127,1,0,0,0,2128,2129,1,0,0,0,2129,2130,
  	1,0,0,0,2130,2131,3,300,150,0,2131,299,1,0,0,0,2132,2134,3,302,151,0,
  	2133,2132,1,0,0,0,2134,2135,1,0,0,0,2135,2133,1,0,0,0,2135,2136,1,0,0,
  	0,2136,2139,1,0,0,0,2137,2138,5,95,0,0,2138,2140,3,218,109,0,2139,2137,
  	1,0,0,0,2139,2140,1,0,0,0,2140,301,1,0,0,0,2141,2142,3,460,230,0,2142,
  	2143,5,95,0,0,2143,2144,3,302,151,0,2144,2187,1,0,0,0,2145,2146,5,94,
  	0,0,2146,2187,3,302,151,0,2147,2148,5,87,0,0,2148,2187,3,302,151,0,2149,
  	2150,5,107,0,0,2150,2151,3,366,183,0,2151,2152,5,76,0,0,2152,2153,3,292,
  	146,0,2153,2187,1,0,0,0,2154,2155,5,20,0,0,2155,2156,3,132,66,0,2156,
  	2157,5,15,0,0,2157,2158,3,292,146,0,2158,2187,1,0,0,0,2159,2160,5,73,
  	0,0,2160,2187,3,346,173,0,2161,2162,5,13,0,0,2162,2164,3,292,146,0,2163,
  	2165,3,490,245,0,2164,2163,1,0,0,0,2164,2165,1,0,0,0,2165,2166,1,0,0,
  	0,2166,2167,5,25,0,0,2167,2169,3,292,146,0,2168,2170,3,490,245,0,2169,
  	2168,1,0,0,0,2169,2170,1,0,0,0,2170,2171,1,0,0,0,2171,2172,5,11,0,0,2172,
  	2173,3,292,146,0,2173,2187,1,0,0,0,2174,2175,5,13,0,0,2175,2187,3,356,
  	178,0,2176,2177,5,5,0,0,2177,2178,3,292,146,0,2178,2179,5,23,0,0,2179,
  	2180,3,346,173,0,2180,2187,1,0,0,0,2181,2182,5,10,0,0,2182,2187,3,370,
  	185,0,2183,2184,5,35,0,0,2184,2187,3,370,185,0,2185,2187,3,304,152,0,
  	2186,2141,1,0,0,0,2186,2145,1,0,0,0,2186,2147,1,0,0,0,2186,2149,1,0,0,
  	0,2186,2154,1,0,0,0,2186,2159,1,0,0,0,2186,2161,1,0,0,0,2186,2174,1,0,
  	0,0,2186,2176,1,0,0,0,2186,2181,1,0,0,0,2186,2183,1,0,0,0,2186,2185,1,
  	0,0,0,2187,303,1,0,0,0,2188,2196,3,306,153,0,2189,2191,5,132,0,0,2190,
  	2192,3,378,189,0,2191,2190,1,0,0,0,2191,2192,1,0,0,0,2192,2193,1,0,0,
  	0,2193,2195,5,133,0,0,2194,2189,1,0,0,0,2195,2198,1,0,0,0,2196,2194,1,
  	0,0,0,2196,2197,1,0,0,0,2197,305,1,0,0,0,2198,2196,1,0,0,0,2199,2267,
  	3,460,230,0,2200,2267,3,400,200,0,2201,2267,3,464,232,0,2202,2267,3,484,
  	242,0,2203,2267,3,510,255,0,2204,2267,3,504,252,0,2205,2267,3,506,253,
  	0,2206,2207,5,120,0,0,2207,2208,3,322,161,0,2208,2209,5,121,0,0,2209,
  	2267,1,0,0,0,2210,2211,5,120,0,0,2211,2212,3,324,162,0,2212,2213,5,121,
  	0,0,2213,2267,1,0,0,0,2214,2215,5,118,0,0,2215,2216,3,322,161,0,2216,
  	2217,5,119,0,0,2217,2267,1,0,0,0,2218,2219,5,118,0,0,2219,2220,3,324,
  	162,0,2220,2221,5,119,0,0,2221,2267,1,0,0,0,2222,2223,5,122,0,0,2223,
  	2224,3,330,165,0,2224,2225,5,123,0,0,2225,2267,1,0,0,0,2226,2267,5,28,
  	0,0,2227,2267,3,310,155,0,2228,2267,3,312,156,0,2229,2230,5,105,0,0,2230,
  	2267,3,460,230,0,2231,2232,5,105,0,0,2232,2267,3,400,200,0,2233,2234,
  	5,106,0,0,2234,2267,3,448,224,0,2235,2236,5,106,0,0,2236,2267,3,418,209,
  	0,2237,2267,5,106,0,0,2238,2239,5,113,0,0,2239,2240,3,292,146,0,2240,
  	2241,5,117,0,0,2241,2267,1,0,0,0,2242,2243,5,111,0,0,2243,2244,3,292,
  	146,0,2244,2245,5,112,0,0,2245,2267,1,0,0,0,2246,2247,5,115,0,0,2247,
  	2248,3,190,95,0,2248,2249,5,117,0,0,2249,2267,1,0,0,0,2250,2251,5,114,
  	0,0,2251,2252,3,294,147,0,2252,2253,5,117,0,0,2253,2267,1,0,0,0,2254,
  	2255,5,116,0,0,2255,2256,3,318,159,0,2256,2257,5,117,0,0,2257,2267,1,
  	0,0,0,2258,2267,3,290,145,0,2259,2260,5,109,0,0,2260,2262,3,302,151,0,
  	2261,2263,3,314,157,0,2262,2261,1,0,0,0,2262,2263,1,0,0,0,2263,2264,1,
  	0,0,0,2264,2265,5,109,0,0,2265,2267,1,0,0,0,2266,2199,1,0,0,0,2266,2200,
  	1,0,0,0,2266,2201,1,0,0,0,2266,2202,1,0,0,0,2266,2203,1,0,0,0,2266,2204,
  	1,0,0,0,2266,2205,1,0,0,0,2266,2206,1,0,0,0,2266,2210,1,0,0,0,2266,2214,
  	1,0,0,0,2266,2218,1,0,0,0,2266,2222,1,0,0,0,2266,2226,1,0,0,0,2266,2227,
  	1,0,0,0,2266,2228,1,0,0,0,2266,2229,1,0,0,0,2266,2231,1,0,0,0,2266,2233,
  	1,0,0,0,2266,2235,1,0,0,0,2266,2237,1,0,0,0,2266,2238,1,0,0,0,2266,2242,
  	1,0,0,0,2266,2246,1,0,0,0,2266,2250,1,0,0,0,2266,2254,1,0,0,0,2266,2258,
  	1,0,0,0,2266,2259,1,0,0,0,2267,307,1,0,0,0,2268,2271,3,312,156,0,2269,
  	2271,3,310,155,0,2270,2268,1,0,0,0,2270,2269,1,0,0,0,2271,309,1,0,0,0,
  	2272,2273,5,97,0,0,2273,2274,3,302,151,0,2274,311,1,0,0,0,2275,2276,5,
  	96,0,0,2276,2277,3,302,151,0,2277,313,1,0,0,0,2278,2280,3,316,158,0,2279,
  	2278,1,0,0,0,2280,2281,1,0,0,0,2281,2279,1,0,0,0,2281,2282,1,0,0,0,2282,
  	315,1,0,0,0,2283,2284,3,302,151,0,2284,317,1,0,0,0,2285,2287,3,486,243,
  	0,2286,2288,3,320,160,0,2287,2286,1,0,0,0,2287,2288,1,0,0,0,2288,2289,
  	1,0,0,0,2289,2290,3,488,244,0,2290,319,1,0,0,0,2291,2295,3,40,20,0,2292,
  	2294,3,490,245,0,2293,2292,1,0,0,0,2294,2297,1,0,0,0,2295,2293,1,0,0,
  	0,2295,2296,1,0,0,0,2296,321,1,0,0,0,2297,2295,1,0,0,0,2298,2310,3,292,
  	146,0,2299,2300,3,294,147,0,2300,2301,3,438,219,0,2301,2310,1,0,0,0,2302,
  	2303,3,440,220,0,2303,2304,3,294,147,0,2304,2310,1,0,0,0,2305,2306,3,
  	292,146,0,2306,2307,5,76,0,0,2307,2308,3,322,161,0,2308,2310,1,0,0,0,
  	2309,2298,1,0,0,0,2309,2299,1,0,0,0,2309,2302,1,0,0,0,2309,2305,1,0,0,
  	0,2310,323,1,0,0,0,2311,2312,3,322,161,0,2312,2313,3,326,163,0,2313,2327,
  	1,0,0,0,2314,2315,3,322,161,0,2315,2316,3,496,248,0,2316,2327,1,0,0,0,
  	2317,2319,3,494,247,0,2318,2320,3,328,164,0,2319,2318,1,0,0,0,2319,2320,
  	1,0,0,0,2320,2327,1,0,0,0,2321,2322,3,496,248,0,2322,2324,3,322,161,0,
  	2323,2325,3,496,248,0,2324,2323,1,0,0,0,2324,2325,1,0,0,0,2325,2327,1,
  	0,0,0,2326,2311,1,0,0,0,2326,2314,1,0,0,0,2326,2317,1,0,0,0,2326,2321,
  	1,0,0,0,2327,325,1,0,0,0,2328,2330,3,494,247,0,2329,2331,3,328,164,0,
  	2330,2329,1,0,0,0,2330,2331,1,0,0,0,2331,327,1,0,0,0,2332,2333,3,322,
  	161,0,2333,2334,3,326,163,0,2334,2337,1,0,0,0,2335,2337,3,322,161,0,2336,
  	2332,1,0,0,0,2336,2335,1,0,0,0,2337,329,1,0,0,0,2338,2363,3,322,161,0,
  	2339,2363,3,332,166,0,2340,2341,3,322,161,0,2341,2342,5,98,0,0,2342,2363,
  	1,0,0,0,2343,2344,3,322,161,0,2344,2345,5,102,0,0,2345,2346,3,292,146,
  	0,2346,2347,5,98,0,0,2347,2363,1,0,0,0,2348,2349,3,322,161,0,2349,2350,
  	5,98,0,0,2350,2351,3,292,146,0,2351,2363,1,0,0,0,2352,2353,3,322,161,
  	0,2353,2354,5,102,0,0,2354,2355,3,292,146,0,2355,2356,5,98,0,0,2356,2357,
  	3,292,146,0,2357,2363,1,0,0,0,2358,2359,3,322,161,0,2359,2360,5,86,0,
  	0,2360,2361,3,334,167,0,2361,2363,1,0,0,0,2362,2338,1,0,0,0,2362,2339,
  	1,0,0,0,2362,2340,1,0,0,0,2362,2343,1,0,0,0,2362,2348,1,0,0,0,2362,2352,
  	1,0,0,0,2362,2358,1,0,0,0,2363,331,1,0,0,0,2364,2365,3,322,161,0,2365,
  	2366,5,102,0,0,2366,2371,3,322,161,0,2367,2368,5,102,0,0,2368,2370,3,
  	322,161,0,2369,2367,1,0,0,0,2370,2373,1,0,0,0,2371,2369,1,0,0,0,2371,
  	2372,1,0,0,0,2372,333,1,0,0,0,2373,2371,1,0,0,0,2374,2375,3,336,168,0,
  	2375,335,1,0,0,0,2376,2381,3,338,169,0,2377,2378,5,86,0,0,2378,2380,3,
  	338,169,0,2379,2377,1,0,0,0,2380,2383,1,0,0,0,2381,2379,1,0,0,0,2381,
  	2382,1,0,0,0,2382,337,1,0,0,0,2383,2381,1,0,0,0,2384,2389,3,340,170,0,
  	2385,2386,5,102,0,0,2386,2388,3,340,170,0,2387,2385,1,0,0,0,2388,2391,
  	1,0,0,0,2389,2387,1,0,0,0,2389,2390,1,0,0,0,2390,2417,1,0,0,0,2391,2389,
  	1,0,0,0,2392,2397,3,340,170,0,2393,2394,5,102,0,0,2394,2396,3,376,188,
  	0,2395,2393,1,0,0,0,2396,2399,1,0,0,0,2397,2395,1,0,0,0,2397,2398,1,0,
  	0,0,2398,2417,1,0,0,0,2399,2397,1,0,0,0,2400,2405,3,376,188,0,2401,2402,
  	5,102,0,0,2402,2404,3,340,170,0,2403,2401,1,0,0,0,2404,2407,1,0,0,0,2405,
  	2403,1,0,0,0,2405,2406,1,0,0,0,2406,2417,1,0,0,0,2407,2405,1,0,0,0,2408,
  	2413,3,376,188,0,2409,2410,5,102,0,0,2410,2412,3,376,188,0,2411,2409,
  	1,0,0,0,2412,2415,1,0,0,0,2413,2411,1,0,0,0,2413,2414,1,0,0,0,2414,2417,
  	1,0,0,0,2415,2413,1,0,0,0,2416,2384,1,0,0,0,2416,2392,1,0,0,0,2416,2400,
  	1,0,0,0,2416,2408,1,0,0,0,2417,339,1,0,0,0,2418,2419,5,25,0,0,2419,2437,
  	3,292,146,0,2420,2421,5,25,0,0,2421,2422,3,292,146,0,2422,2423,5,45,0,
  	0,2423,2424,3,292,146,0,2424,2437,1,0,0,0,2425,2426,5,25,0,0,2426,2427,
  	5,44,0,0,2427,2428,5,46,0,0,2428,2437,3,292,146,0,2429,2430,5,25,0,0,
  	2430,2431,5,44,0,0,2431,2432,5,45,0,0,2432,2433,3,292,146,0,2433,2434,
  	5,46,0,0,2434,2435,3,292,146,0,2435,2437,1,0,0,0,2436,2418,1,0,0,0,2436,
  	2420,1,0,0,0,2436,2425,1,0,0,0,2436,2429,1,0,0,0,2437,341,1,0,0,0,2438,
  	2443,3,344,172,0,2439,2440,5,102,0,0,2440,2442,3,344,172,0,2441,2439,
  	1,0,0,0,2442,2445,1,0,0,0,2443,2441,1,0,0,0,2443,2444,1,0,0,0,2444,343,
  	1,0,0,0,2445,2443,1,0,0,0,2446,2447,3,360,180,0,2447,2448,5,77,0,0,2448,
  	2449,3,294,147,0,2449,2454,1,0,0,0,2450,2451,5,20,0,0,2451,2454,3,132,
  	66,0,2452,2454,3,294,147,0,2453,2446,1,0,0,0,2453,2450,1,0,0,0,2453,2452,
  	1,0,0,0,2454,345,1,0,0,0,2455,2463,3,486,243,0,2456,2460,3,348,174,0,
  	2457,2459,3,490,245,0,2458,2457,1,0,0,0,2459,2462,1,0,0,0,2460,2458,1,
  	0,0,0,2460,2461,1,0,0,0,2461,2464,1,0,0,0,2462,2460,1,0,0,0,2463,2456,
  	1,0,0,0,2464,2465,1,0,0,0,2465,2463,1,0,0,0,2465,2466,1,0,0,0,2466,2467,
  	1,0,0,0,2467,2468,3,488,244,0,2468,2473,1,0,0,0,2469,2470,3,486,243,0,
  	2470,2471,3,488,244,0,2471,2473,1,0,0,0,2472,2455,1,0,0,0,2472,2469,1,
  	0,0,0,2473,347,1,0,0,0,2474,2475,3,360,180,0,2475,2476,3,350,175,0,2476,
  	349,1,0,0,0,2477,2479,3,352,176,0,2478,2480,3,136,68,0,2479,2478,1,0,
  	0,0,2479,2480,1,0,0,0,2480,351,1,0,0,0,2481,2482,5,76,0,0,2482,2485,3,
  	292,146,0,2483,2485,3,354,177,0,2484,2481,1,0,0,0,2484,2483,1,0,0,0,2485,
  	353,1,0,0,0,2486,2488,3,358,179,0,2487,2486,1,0,0,0,2488,2489,1,0,0,0,
  	2489,2487,1,0,0,0,2489,2490,1,0,0,0,2490,355,1,0,0,0,2491,2492,5,132,
  	0,0,2492,2493,3,354,177,0,2493,2494,5,133,0,0,2494,2497,1,0,0,0,2495,
  	2497,3,354,177,0,2496,2491,1,0,0,0,2496,2495,1,0,0,0,2497,357,1,0,0,0,
  	2498,2499,5,86,0,0,2499,2500,3,342,171,0,2500,2501,5,76,0,0,2501,2502,
  	3,292,146,0,2502,359,1,0,0,0,2503,2504,3,292,146,0,2504,361,1,0,0,0,2505,
  	2506,3,292,146,0,2506,363,1,0,0,0,2507,2508,3,302,151,0,2508,365,1,0,
  	0,0,2509,2511,3,364,182,0,2510,2509,1,0,0,0,2511,2512,1,0,0,0,2512,2510,
  	1,0,0,0,2512,2513,1,0,0,0,2513,367,1,0,0,0,2514,2515,3,460,230,0,2515,
  	2516,5,104,0,0,2516,2517,3,360,180,0,2517,369,1,0,0,0,2518,2520,3,486,
  	243,0,2519,2521,3,372,186,0,2520,2519,1,0,0,0,2520,2521,1,0,0,0,2521,
  	2522,1,0,0,0,2522,2523,3,488,244,0,2523,371,1,0,0,0,2524,2534,3,374,187,
  	0,2525,2527,3,490,245,0,2526,2525,1,0,0,0,2527,2528,1,0,0,0,2528,2526,
  	1,0,0,0,2528,2529,1,0,0,0,2529,2530,1,0,0,0,2530,2531,3,374,187,0,2531,
  	2533,1,0,0,0,2532,2526,1,0,0,0,2533,2536,1,0,0,0,2534,2532,1,0,0,0,2534,
  	2535,1,0,0,0,2535,2540,1,0,0,0,2536,2534,1,0,0,0,2537,2539,3,490,245,
  	0,2538,2537,1,0,0,0,2539,2542,1,0,0,0,2540,2538,1,0,0,0,2540,2541,1,0,
  	0,0,2541,373,1,0,0,0,2542,2540,1,0,0,0,2543,2552,3,376,188,0,2544,2545,
  	5,43,0,0,2545,2552,3,370,185,0,2546,2548,3,490,245,0,2547,2546,1,0,0,
  	0,2548,2549,1,0,0,0,2549,2547,1,0,0,0,2549,2550,1,0,0,0,2550,2552,1,0,
  	0,0,2551,2543,1,0,0,0,2551,2544,1,0,0,0,2551,2547,1,0,0,0,2552,375,1,
  	0,0,0,2553,2554,3,362,181,0,2554,2555,5,77,0,0,2555,2556,3,292,146,0,
  	2556,2561,1,0,0,0,2557,2561,3,292,146,0,2558,2559,5,20,0,0,2559,2561,
  	3,134,67,0,2560,2553,1,0,0,0,2560,2557,1,0,0,0,2560,2558,1,0,0,0,2561,
  	377,1,0,0,0,2562,2567,3,380,190,0,2563,2564,5,102,0,0,2564,2566,3,380,
  	190,0,2565,2563,1,0,0,0,2566,2569,1,0,0,0,2567,2565,1,0,0,0,2567,2568,
  	1,0,0,0,2568,2572,1,0,0,0,2569,2567,1,0,0,0,2570,2572,5,98,0,0,2571,2562,
  	1,0,0,0,2571,2570,1,0,0,0,2572,379,1,0,0,0,2573,2574,3,460,230,0,2574,
  	2575,5,104,0,0,2575,2576,3,292,146,0,2576,2579,1,0,0,0,2577,2579,3,460,
  	230,0,2578,2573,1,0,0,0,2578,2577,1,0,0,0,2579,381,1,0,0,0,2580,2582,
  	3,384,192,0,2581,2583,3,490,245,0,2582,2581,1,0,0,0,2583,2584,1,0,0,0,
  	2584,2582,1,0,0,0,2584,2585,1,0,0,0,2585,2586,1,0,0,0,2586,2587,3,384,
  	192,0,2587,2591,1,0,0,0,2588,2590,3,490,245,0,2589,2588,1,0,0,0,2590,
  	2593,1,0,0,0,2591,2589,1,0,0,0,2591,2592,1,0,0,0,2592,383,1,0,0,0,2593,
  	2591,1,0,0,0,2594,2595,3,464,232,0,2595,2596,5,104,0,0,2596,2597,3,292,
  	146,0,2597,385,1,0,0,0,2598,2603,3,388,194,0,2599,2600,5,86,0,0,2600,
  	2602,3,388,194,0,2601,2599,1,0,0,0,2602,2605,1,0,0,0,2603,2601,1,0,0,
  	0,2603,2604,1,0,0,0,2604,387,1,0,0,0,2605,2603,1,0,0,0,2606,2607,3,390,
  	195,0,2607,389,1,0,0,0,2608,2613,3,392,196,0,2609,2610,5,102,0,0,2610,
  	2612,3,392,196,0,2611,2609,1,0,0,0,2612,2615,1,0,0,0,2613,2611,1,0,0,
  	0,2613,2614,1,0,0,0,2614,391,1,0,0,0,2615,2613,1,0,0,0,2616,2617,5,120,
  	0,0,2617,2618,3,386,193,0,2618,2619,5,121,0,0,2619,2622,1,0,0,0,2620,
  	2622,3,396,198,0,2621,2616,1,0,0,0,2621,2620,1,0,0,0,2622,393,1,0,0,0,
  	2623,2628,3,396,198,0,2624,2625,5,102,0,0,2625,2627,3,396,198,0,2626,
  	2624,1,0,0,0,2627,2630,1,0,0,0,2628,2626,1,0,0,0,2628,2629,1,0,0,0,2629,
  	395,1,0,0,0,2630,2628,1,0,0,0,2631,2634,3,458,229,0,2632,2634,3,404,202,
  	0,2633,2631,1,0,0,0,2633,2632,1,0,0,0,2634,397,1,0,0,0,2635,2638,3,402,
  	201,0,2636,2638,3,408,204,0,2637,2635,1,0,0,0,2637,2636,1,0,0,0,2638,
  	399,1,0,0,0,2639,2642,3,402,201,0,2640,2642,3,410,205,0,2641,2639,1,0,
  	0,0,2641,2640,1,0,0,0,2642,401,1,0,0,0,2643,2649,3,476,238,0,2644,2645,
  	5,120,0,0,2645,2646,3,480,240,0,2646,2647,5,121,0,0,2647,2649,1,0,0,0,
  	2648,2643,1,0,0,0,2648,2644,1,0,0,0,2649,403,1,0,0,0,2650,2657,3,478,
  	239,0,2651,2652,5,120,0,0,2652,2653,3,482,241,0,2653,2654,5,121,0,0,2654,
  	2657,1,0,0,0,2655,2657,3,410,205,0,2656,2650,1,0,0,0,2656,2651,1,0,0,
  	0,2656,2655,1,0,0,0,2657,405,1,0,0,0,2658,2663,3,404,202,0,2659,2660,
  	5,102,0,0,2660,2662,3,404,202,0,2661,2659,1,0,0,0,2662,2665,1,0,0,0,2663,
  	2661,1,0,0,0,2663,2664,1,0,0,0,2664,407,1,0,0,0,2665,2663,1,0,0,0,2666,
  	2667,5,120,0,0,2667,2679,5,121,0,0,2668,2669,5,120,0,0,2669,2670,3,494,
  	247,0,2670,2671,5,121,0,0,2671,2679,1,0,0,0,2672,2673,5,118,0,0,2673,
  	2679,5,119,0,0,2674,2675,5,118,0,0,2675,2676,3,494,247,0,2676,2677,5,
  	119,0,0,2677,2679,1,0,0,0,2678,2666,1,0,0,0,2678,2668,1,0,0,0,2678,2672,
  	1,0,0,0,2678,2674,1,0,0,0,2679,409,1,0,0,0,2680,2684,3,408,204,0,2681,
  	2682,5,122,0,0,2682,2684,5,123,0,0,2683,2680,1,0,0,0,2683,2681,1,0,0,
  	0,2684,411,1,0,0,0,2685,2691,3,482,241,0,2686,2687,5,108,0,0,2687,2688,
  	3,478,239,0,2688,2689,5,108,0,0,2689,2691,1,0,0,0,2690,2685,1,0,0,0,2690,
  	2686,1,0,0,0,2691,413,1,0,0,0,2692,2698,3,416,208,0,2693,2694,5,108,0,
  	0,2694,2695,3,476,238,0,2695,2696,5,108,0,0,2696,2698,1,0,0,0,2697,2692,
  	1,0,0,0,2697,2693,1,0,0,0,2698,415,1,0,0,0,2699,2702,5,103,0,0,2700,2702,
  	3,480,240,0,2701,2699,1,0,0,0,2701,2700,1,0,0,0,2702,417,1,0,0,0,2703,
  	2709,3,420,210,0,2704,2705,5,120,0,0,2705,2709,5,121,0,0,2706,2707,5,
  	118,0,0,2707,2709,5,119,0,0,2708,2703,1,0,0,0,2708,2704,1,0,0,0,2708,
  	2706,1,0,0,0,2709,419,1,0,0,0,2710,2725,3,422,211,0,2711,2712,5,120,0,
  	0,2712,2713,3,494,247,0,2713,2714,5,121,0,0,2714,2725,1,0,0,0,2715,2716,
  	5,118,0,0,2716,2717,3,494,247,0,2717,2718,5,119,0,0,2718,2725,1,0,0,0,
  	2719,2720,5,120,0,0,2720,2721,5,76,0,0,2721,2725,5,121,0,0,2722,2723,
  	5,122,0,0,2723,2725,5,123,0,0,2724,2710,1,0,0,0,2724,2711,1,0,0,0,2724,
  	2715,1,0,0,0,2724,2719,1,0,0,0,2724,2722,1,0,0,0,2725,421,1,0,0,0,2726,
  	2732,3,426,213,0,2727,2728,5,120,0,0,2728,2729,3,430,215,0,2729,2730,
  	5,121,0,0,2730,2732,1,0,0,0,2731,2726,1,0,0,0,2731,2727,1,0,0,0,2732,
  	423,1,0,0,0,2733,2739,3,430,215,0,2734,2735,5,108,0,0,2735,2736,3,426,
  	213,0,2736,2737,5,108,0,0,2737,2739,1,0,0,0,2738,2733,1,0,0,0,2738,2734,
  	1,0,0,0,2739,425,1,0,0,0,2740,2741,3,492,246,0,2741,2742,5,99,0,0,2742,
  	2744,1,0,0,0,2743,2740,1,0,0,0,2743,2744,1,0,0,0,2744,2745,1,0,0,0,2745,
  	2746,3,428,214,0,2746,427,1,0,0,0,2747,2748,3,478,239,0,2748,429,1,0,
  	0,0,2749,2753,3,480,240,0,2750,2753,3,466,233,0,2751,2753,3,432,216,0,
  	2752,2749,1,0,0,0,2752,2750,1,0,0,0,2752,2751,1,0,0,0,2753,431,1,0,0,
  	0,2754,2760,3,482,241,0,2755,2760,3,470,235,0,2756,2760,5,103,0,0,2757,
  	2760,5,90,0,0,2758,2760,5,99,0,0,2759,2754,1,0,0,0,2759,2755,1,0,0,0,
  	2759,2756,1,0,0,0,2759,2757,1,0,0,0,2759,2758,1,0,0,0,2760,433,1,0,0,
  	0,2761,2764,3,436,218,0,2762,2764,3,412,206,0,2763,2761,1,0,0,0,2763,
  	2762,1,0,0,0,2764,435,1,0,0,0,2765,2771,3,470,235,0,2766,2767,5,108,0,
  	0,2767,2768,3,464,232,0,2768,2769,5,108,0,0,2769,2771,1,0,0,0,2770,2765,
  	1,0,0,0,2770,2766,1,0,0,0,2771,437,1,0,0,0,2772,2775,3,444,222,0,2773,
  	2775,3,414,207,0,2774,2772,1,0,0,0,2774,2773,1,0,0,0,2775,439,1,0,0,0,
  	2776,2780,3,446,223,0,2777,2780,3,414,207,0,2778,2780,3,442,221,0,2779,
  	2776,1,0,0,0,2779,2777,1,0,0,0,2779,2778,1,0,0,0,2780,441,1,0,0,0,2781,
  	2782,5,108,0,0,2782,2783,5,28,0,0,2783,2784,5,108,0,0,2784,443,1,0,0,
  	0,2785,2791,3,466,233,0,2786,2787,5,108,0,0,2787,2788,3,462,231,0,2788,
  	2789,5,108,0,0,2789,2791,1,0,0,0,2790,2785,1,0,0,0,2790,2786,1,0,0,0,
  	2791,445,1,0,0,0,2792,2798,3,468,234,0,2793,2794,5,108,0,0,2794,2795,
  	3,462,231,0,2795,2796,5,108,0,0,2796,2798,1,0,0,0,2797,2792,1,0,0,0,2797,
  	2793,1,0,0,0,2798,447,1,0,0,0,2799,2800,3,464,232,0,2800,449,1,0,0,0,
  	2801,2802,5,108,0,0,2802,2803,3,452,226,0,2803,2804,5,108,0,0,2804,451,
  	1,0,0,0,2805,2811,3,464,232,0,2806,2811,3,474,237,0,2807,2811,5,34,0,
  	0,2808,2811,5,32,0,0,2809,2811,5,33,0,0,2810,2805,1,0,0,0,2810,2806,1,
  	0,0,0,2810,2807,1,0,0,0,2810,2808,1,0,0,0,2810,2809,1,0,0,0,2811,453,
  	1,0,0,0,2812,2813,3,478,239,0,2813,455,1,0,0,0,2814,2815,3,492,246,0,
  	2815,2816,5,99,0,0,2816,2818,1,0,0,0,2817,2814,1,0,0,0,2817,2818,1,0,
  	0,0,2818,2819,1,0,0,0,2819,2820,3,454,227,0,2820,457,1,0,0,0,2821,2827,
  	3,464,232,0,2822,2823,5,120,0,0,2823,2824,3,470,235,0,2824,2825,5,121,
  	0,0,2825,2827,1,0,0,0,2826,2821,1,0,0,0,2826,2822,1,0,0,0,2827,459,1,
  	0,0,0,2828,2834,3,462,231,0,2829,2830,5,120,0,0,2830,2831,3,466,233,0,
  	2831,2832,5,121,0,0,2832,2834,1,0,0,0,2833,2828,1,0,0,0,2833,2829,1,0,
  	0,0,2834,461,1,0,0,0,2835,2836,3,492,246,0,2836,2837,5,99,0,0,2837,2839,
  	1,0,0,0,2838,2835,1,0,0,0,2838,2839,1,0,0,0,2839,2840,1,0,0,0,2840,2841,
  	3,464,232,0,2841,463,1,0,0,0,2842,2845,5,126,0,0,2843,2845,3,474,237,
  	0,2844,2842,1,0,0,0,2844,2843,1,0,0,0,2845,2849,1,0,0,0,2846,2848,5,82,
  	0,0,2847,2846,1,0,0,0,2848,2851,1,0,0,0,2849,2847,1,0,0,0,2849,2850,1,
  	0,0,0,2850,465,1,0,0,0,2851,2849,1,0,0,0,2852,2853,3,492,246,0,2853,2854,
  	5,99,0,0,2854,2856,1,0,0,0,2855,2852,1,0,0,0,2855,2856,1,0,0,0,2856,2857,
  	1,0,0,0,2857,2858,3,470,235,0,2858,467,1,0,0,0,2859,2862,3,472,236,0,
  	2860,2862,3,466,233,0,2861,2859,1,0,0,0,2861,2860,1,0,0,0,2862,469,1,
  	0,0,0,2863,2866,3,472,236,0,2864,2866,5,90,0,0,2865,2863,1,0,0,0,2865,
  	2864,1,0,0,0,2866,471,1,0,0,0,2867,2869,3,502,251,0,2868,2867,1,0,0,0,
  	2869,2870,1,0,0,0,2870,2868,1,0,0,0,2870,2871,1,0,0,0,2871,473,1,0,0,
  	0,2872,2873,7,5,0,0,2873,475,1,0,0,0,2874,2875,3,492,246,0,2875,2876,
  	5,99,0,0,2876,2878,1,0,0,0,2877,2874,1,0,0,0,2877,2878,1,0,0,0,2878,2879,
  	1,0,0,0,2879,2880,3,478,239,0,2880,477,1,0,0,0,2881,2885,5,127,0,0,2882,
  	2884,5,82,0,0,2883,2882,1,0,0,0,2884,2887,1,0,0,0,2885,2883,1,0,0,0,2885,
  	2886,1,0,0,0,2886,479,1,0,0,0,2887,2885,1,0,0,0,2888,2889,3,492,246,0,
  	2889,2890,5,99,0,0,2890,2892,1,0,0,0,2891,2888,1,0,0,0,2891,2892,1,0,
  	0,0,2892,2893,1,0,0,0,2893,2894,3,482,241,0,2894,481,1,0,0,0,2895,2899,
  	5,103,0,0,2896,2898,3,502,251,0,2897,2896,1,0,0,0,2898,2901,1,0,0,0,2899,
  	2897,1,0,0,0,2899,2900,1,0,0,0,2900,483,1,0,0,0,2901,2899,1,0,0,0,2902,
  	2907,3,504,252,0,2903,2907,3,506,253,0,2904,2907,3,508,254,0,2905,2907,
  	3,510,255,0,2906,2902,1,0,0,0,2906,2903,1,0,0,0,2906,2904,1,0,0,0,2906,
  	2905,1,0,0,0,2907,485,1,0,0,0,2908,2909,7,6,0,0,2909,487,1,0,0,0,2910,
  	2911,7,7,0,0,2911,489,1,0,0,0,2912,2913,7,8,0,0,2913,491,1,0,0,0,2914,
  	2915,3,478,239,0,2915,2916,5,99,0,0,2916,2918,1,0,0,0,2917,2914,1,0,0,
  	0,2918,2921,1,0,0,0,2919,2917,1,0,0,0,2919,2920,1,0,0,0,2920,2922,1,0,
  	0,0,2921,2919,1,0,0,0,2922,2923,3,478,239,0,2923,493,1,0,0,0,2924,2926,
  	5,102,0,0,2925,2924,1,0,0,0,2926,2927,1,0,0,0,2927,2925,1,0,0,0,2927,
  	2928,1,0,0,0,2928,495,1,0,0,0,2929,2931,5,86,0,0,2930,2929,1,0,0,0,2931,
  	2932,1,0,0,0,2932,2930,1,0,0,0,2932,2933,1,0,0,0,2933,497,1,0,0,0,2934,
  	2935,7,9,0,0,2935,499,1,0,0,0,2936,2937,3,502,251,0,2937,501,1,0,0,0,
  	2938,2939,7,10,0,0,2939,503,1,0,0,0,2940,2941,7,11,0,0,2941,505,1,0,0,
  	0,2942,2943,5,140,0,0,2943,507,1,0,0,0,2944,2945,5,124,0,0,2945,509,1,
  	0,0,0,2946,2947,5,125,0,0,2947,511,1,0,0,0,343,513,518,522,527,532,535,
  	538,545,558,564,569,578,583,590,594,599,606,610,615,624,629,631,639,642,
  	645,660,663,666,678,681,684,688,692,697,700,705,713,717,719,729,733,735,
  	738,751,754,757,765,768,770,774,783,790,794,796,807,815,821,827,833,838,
  	841,852,855,858,862,867,871,876,880,884,887,890,894,898,901,904,910,912,
  	924,929,933,941,945,950,954,959,963,966,969,974,978,981,984,986,1000,
  	1011,1023,1030,1041,1047,1053,1059,1064,1075,1079,1083,1087,1091,1095,
  	1098,1102,1107,1110,1115,1119,1122,1127,1131,1134,1138,1141,1144,1148,
  	1151,1155,1158,1161,1163,1175,1184,1191,1195,1204,1213,1224,1228,1232,
  	1240,1245,1249,1261,1263,1267,1278,1283,1290,1296,1312,1318,1324,1330,
  	1335,1344,1350,1356,1362,1367,1378,1384,1390,1395,1402,1406,1417,1421,
  	1425,1428,1436,1451,1455,1460,1463,1468,1477,1485,1489,1500,1504,1512,
  	1515,1522,1543,1548,1556,1563,1584,1592,1601,1610,1617,1621,1635,1639,
  	1653,1664,1671,1678,1687,1699,1710,1753,1767,1776,1784,1794,1800,1813,
  	1822,1832,1836,1840,1845,1852,1857,1868,1885,1889,1894,1900,1911,1921,
  	1933,1942,1947,1955,1957,1964,1966,1971,1975,1977,1982,2001,2010,2017,
  	2026,2033,2043,2060,2066,2068,2079,2091,2114,2122,2128,2135,2139,2164,
  	2169,2186,2191,2196,2262,2266,2270,2281,2287,2295,2309,2319,2324,2326,
  	2330,2336,2362,2371,2381,2389,2397,2405,2413,2416,2436,2443,2453,2460,
  	2465,2472,2479,2484,2489,2496,2512,2520,2528,2534,2540,2549,2551,2560,
  	2567,2571,2578,2584,2591,2603,2613,2621,2628,2633,2637,2641,2648,2656,
  	2663,2678,2683,2690,2697,2701,2708,2724,2731,2738,2743,2752,2759,2763,
  	2770,2774,2779,2790,2797,2810,2817,2826,2833,2838,2844,2849,2855,2861,
  	2865,2870,2877,2885,2891,2899,2906,2919,2927,2932
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  haskellparserParserStaticData = staticData.release();
}

}

HaskellParser::HaskellParser(TokenStream *input) : HaskellParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

HaskellParser::HaskellParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  HaskellParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *haskellparserParserStaticData->atn, haskellparserParserStaticData->decisionToDFA, haskellparserParserStaticData->sharedContextCache, options);
}

HaskellParser::~HaskellParser() {
  delete _interpreter;
}

const atn::ATN& HaskellParser::getATN() const {
  return *haskellparserParserStaticData->atn;
}

std::string HaskellParser::getGrammarFileName() const {
  return "HaskellParser.g4";
}

const std::vector<std::string>& HaskellParser::getRuleNames() const {
  return haskellparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& HaskellParser::getVocabulary() const {
  return haskellparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView HaskellParser::getSerializedATN() const {
  return haskellparserParserStaticData->serializedATN;
}


//----------------- ModuleContext ------------------------------------------------------------------

HaskellParser::ModuleContext::ModuleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::ModuleContext::EOF() {
  return getToken(HaskellParser::EOF, 0);
}

HaskellParser::Module_contentContext* HaskellParser::ModuleContext::module_content() {
  return getRuleContext<HaskellParser::Module_contentContext>(0);
}

HaskellParser::BodyContext* HaskellParser::ModuleContext::body() {
  return getRuleContext<HaskellParser::BodyContext>(0);
}

tree::TerminalNode* HaskellParser::ModuleContext::OCURLY() {
  return getToken(HaskellParser::OCURLY, 0);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::ModuleContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::ModuleContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}

HaskellParser::PragmasContext* HaskellParser::ModuleContext::pragmas() {
  return getRuleContext<HaskellParser::PragmasContext>(0);
}

tree::TerminalNode* HaskellParser::ModuleContext::CCURLY() {
  return getToken(HaskellParser::CCURLY, 0);
}


size_t HaskellParser::ModuleContext::getRuleIndex() const {
  return HaskellParser::RuleModule;
}

void HaskellParser::ModuleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule(this);
}

void HaskellParser::ModuleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule(this);
}

HaskellParser::ModuleContext* HaskellParser::module() {
  ModuleContext *_localctx = _tracker.createInstance<ModuleContext>(_ctx, getState());
  enterRule(_localctx, 0, HaskellParser::RuleModule);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(513);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::OCURLY) {
      setState(512);
      match(HaskellParser::OCURLY);
    }
    setState(518);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(515);
        semi(); 
      }
      setState(520);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx);
    }
    setState(522);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
    case 1: {
      setState(521);
      pragmas();
      break;
    }

    default:
      break;
    }
    setState(527);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(524);
        semi(); 
      }
      setState(529);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
    }
    setState(532);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::MODULE: {
        setState(530);
        module_content();
        break;
      }

      case HaskellParser::NEWLINE:
      case HaskellParser::AS:
      case HaskellParser::CASE:
      case HaskellParser::CLASS:
      case HaskellParser::DATA:
      case HaskellParser::DEFAULT:
      case HaskellParser::DERIVING:
      case HaskellParser::DO:
      case HaskellParser::HIDING:
      case HaskellParser::IF:
      case HaskellParser::IMPORT:
      case HaskellParser::INFIX:
      case HaskellParser::INFIXL:
      case HaskellParser::INFIXR:
      case HaskellParser::INSTANCE:
      case HaskellParser::LET:
      case HaskellParser::NEWTYPE:
      case HaskellParser::QUALIFIED:
      case HaskellParser::TYPE:
      case HaskellParser::WILDCARD:
      case HaskellParser::FOREIGN:
      case HaskellParser::EXPORT:
      case HaskellParser::MDO:
      case HaskellParser::STDCALL:
      case HaskellParser::CCALL:
      case HaskellParser::CAPI:
      case HaskellParser::JSCALL:
      case HaskellParser::PATTERN:
      case HaskellParser::STOCK:
      case HaskellParser::ANYCLASS:
      case HaskellParser::VIA:
      case HaskellParser::LCASE:
      case HaskellParser::Bang:
      case HaskellParser::Minus:
      case HaskellParser::Tilde:
      case HaskellParser::DDollar:
      case HaskellParser::Dollar:
      case HaskellParser::Semi:
      case HaskellParser::Quote:
      case HaskellParser::DoubleQuote:
      case HaskellParser::ReverseSlash:
      case HaskellParser::AopenParen:
      case HaskellParser::TopenTexpQuote:
      case HaskellParser::TopenExpQuote:
      case HaskellParser::TopenPatQuote:
      case HaskellParser::TopenTypQoute:
      case HaskellParser::TopenDecQoute:
      case HaskellParser::OpenBoxParen:
      case HaskellParser::OpenRoundBracket:
      case HaskellParser::OpenSquareBracket:
      case HaskellParser::CHAR:
      case HaskellParser::STRING:
      case HaskellParser::VARID:
      case HaskellParser::CONID:
      case HaskellParser::OpenPragmaBracket:
      case HaskellParser::SEMI:
      case HaskellParser::DECIMAL:
      case HaskellParser::OCTAL:
      case HaskellParser::HEXADECIMAL:
      case HaskellParser::FLOAT: {
        setState(531);
        body();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(535);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::CCURLY) {
      setState(534);
      match(HaskellParser::CCURLY);
    }
    setState(538);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::Semi

    || _la == HaskellParser::SEMI) {
      setState(537);
      semi();
    }
    setState(540);
    match(HaskellParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_contentContext ------------------------------------------------------------------

HaskellParser::Module_contentContext::Module_contentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Module_contentContext::MODULE() {
  return getToken(HaskellParser::MODULE, 0);
}

HaskellParser::ModidContext* HaskellParser::Module_contentContext::modid() {
  return getRuleContext<HaskellParser::ModidContext>(0);
}

HaskellParser::Where_moduleContext* HaskellParser::Module_contentContext::where_module() {
  return getRuleContext<HaskellParser::Where_moduleContext>(0);
}

HaskellParser::ExportsContext* HaskellParser::Module_contentContext::exports() {
  return getRuleContext<HaskellParser::ExportsContext>(0);
}


size_t HaskellParser::Module_contentContext::getRuleIndex() const {
  return HaskellParser::RuleModule_content;
}

void HaskellParser::Module_contentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_content(this);
}

void HaskellParser::Module_contentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_content(this);
}

HaskellParser::Module_contentContext* HaskellParser::module_content() {
  Module_contentContext *_localctx = _tracker.createInstance<Module_contentContext>(_ctx, getState());
  enterRule(_localctx, 2, HaskellParser::RuleModule_content);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(542);
    match(HaskellParser::MODULE);
    setState(543);
    modid();
    setState(545);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::OpenRoundBracket) {
      setState(544);
      exports();
    }
    setState(547);
    where_module();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Where_moduleContext ------------------------------------------------------------------

HaskellParser::Where_moduleContext::Where_moduleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Where_moduleContext::WHERE() {
  return getToken(HaskellParser::WHERE, 0);
}

HaskellParser::Module_bodyContext* HaskellParser::Where_moduleContext::module_body() {
  return getRuleContext<HaskellParser::Module_bodyContext>(0);
}


size_t HaskellParser::Where_moduleContext::getRuleIndex() const {
  return HaskellParser::RuleWhere_module;
}

void HaskellParser::Where_moduleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhere_module(this);
}

void HaskellParser::Where_moduleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhere_module(this);
}

HaskellParser::Where_moduleContext* HaskellParser::where_module() {
  Where_moduleContext *_localctx = _tracker.createInstance<Where_moduleContext>(_ctx, getState());
  enterRule(_localctx, 4, HaskellParser::RuleWhere_module);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(549);
    match(HaskellParser::WHERE);
    setState(550);
    module_body();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_bodyContext ------------------------------------------------------------------

HaskellParser::Module_bodyContext::Module_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Open_Context* HaskellParser::Module_bodyContext::open_() {
  return getRuleContext<HaskellParser::Open_Context>(0);
}

HaskellParser::BodyContext* HaskellParser::Module_bodyContext::body() {
  return getRuleContext<HaskellParser::BodyContext>(0);
}

HaskellParser::CloseContext* HaskellParser::Module_bodyContext::close() {
  return getRuleContext<HaskellParser::CloseContext>(0);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::Module_bodyContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::Module_bodyContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::Module_bodyContext::getRuleIndex() const {
  return HaskellParser::RuleModule_body;
}

void HaskellParser::Module_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_body(this);
}

void HaskellParser::Module_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_body(this);
}

HaskellParser::Module_bodyContext* HaskellParser::module_body() {
  Module_bodyContext *_localctx = _tracker.createInstance<Module_bodyContext>(_ctx, getState());
  enterRule(_localctx, 6, HaskellParser::RuleModule_body);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(552);
    open_();
    setState(553);
    body();
    setState(554);
    close();
    setState(558);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(555);
        semi(); 
      }
      setState(560);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PragmasContext ------------------------------------------------------------------

HaskellParser::PragmasContext::PragmasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::PragmaContext *> HaskellParser::PragmasContext::pragma() {
  return getRuleContexts<HaskellParser::PragmaContext>();
}

HaskellParser::PragmaContext* HaskellParser::PragmasContext::pragma(size_t i) {
  return getRuleContext<HaskellParser::PragmaContext>(i);
}


size_t HaskellParser::PragmasContext::getRuleIndex() const {
  return HaskellParser::RulePragmas;
}

void HaskellParser::PragmasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragmas(this);
}

void HaskellParser::PragmasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragmas(this);
}

HaskellParser::PragmasContext* HaskellParser::pragmas() {
  PragmasContext *_localctx = _tracker.createInstance<PragmasContext>(_ctx, getState());
  enterRule(_localctx, 8, HaskellParser::RulePragmas);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(562); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(561);
              pragma();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(564); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PragmaContext ------------------------------------------------------------------

HaskellParser::PragmaContext::PragmaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Language_pragmaContext* HaskellParser::PragmaContext::language_pragma() {
  return getRuleContext<HaskellParser::Language_pragmaContext>(0);
}

HaskellParser::Options_ghcContext* HaskellParser::PragmaContext::options_ghc() {
  return getRuleContext<HaskellParser::Options_ghcContext>(0);
}

HaskellParser::Simple_optionsContext* HaskellParser::PragmaContext::simple_options() {
  return getRuleContext<HaskellParser::Simple_optionsContext>(0);
}


size_t HaskellParser::PragmaContext::getRuleIndex() const {
  return HaskellParser::RulePragma;
}

void HaskellParser::PragmaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragma(this);
}

void HaskellParser::PragmaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragma(this);
}

HaskellParser::PragmaContext* HaskellParser::pragma() {
  PragmaContext *_localctx = _tracker.createInstance<PragmaContext>(_ctx, getState());
  enterRule(_localctx, 10, HaskellParser::RulePragma);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(569);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(566);
      language_pragma();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(567);
      options_ghc();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(568);
      simple_options();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Language_pragmaContext ------------------------------------------------------------------

HaskellParser::Language_pragmaContext::Language_pragmaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Language_pragmaContext::OpenPragmaBracket() {
  return getToken(HaskellParser::OpenPragmaBracket, 0);
}

tree::TerminalNode* HaskellParser::Language_pragmaContext::LANGUAGE() {
  return getToken(HaskellParser::LANGUAGE, 0);
}

std::vector<HaskellParser::Extension_Context *> HaskellParser::Language_pragmaContext::extension_() {
  return getRuleContexts<HaskellParser::Extension_Context>();
}

HaskellParser::Extension_Context* HaskellParser::Language_pragmaContext::extension_(size_t i) {
  return getRuleContext<HaskellParser::Extension_Context>(i);
}

tree::TerminalNode* HaskellParser::Language_pragmaContext::ClosePragmaBracket() {
  return getToken(HaskellParser::ClosePragmaBracket, 0);
}

std::vector<tree::TerminalNode *> HaskellParser::Language_pragmaContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::Language_pragmaContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}

HaskellParser::SemiContext* HaskellParser::Language_pragmaContext::semi() {
  return getRuleContext<HaskellParser::SemiContext>(0);
}


size_t HaskellParser::Language_pragmaContext::getRuleIndex() const {
  return HaskellParser::RuleLanguage_pragma;
}

void HaskellParser::Language_pragmaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLanguage_pragma(this);
}

void HaskellParser::Language_pragmaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLanguage_pragma(this);
}

HaskellParser::Language_pragmaContext* HaskellParser::language_pragma() {
  Language_pragmaContext *_localctx = _tracker.createInstance<Language_pragmaContext>(_ctx, getState());
  enterRule(_localctx, 12, HaskellParser::RuleLanguage_pragma);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(571);
    match(HaskellParser::OpenPragmaBracket);
    setState(572);
    match(HaskellParser::LANGUAGE);
    setState(573);
    extension_();
    setState(578);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Comma) {
      setState(574);
      match(HaskellParser::Comma);
      setState(575);
      extension_();
      setState(580);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(581);
    match(HaskellParser::ClosePragmaBracket);
    setState(583);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
    case 1: {
      setState(582);
      semi();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Options_ghcContext ------------------------------------------------------------------

HaskellParser::Options_ghcContext::Options_ghcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Options_ghcContext::OpenPragmaBracket() {
  return getToken(HaskellParser::OpenPragmaBracket, 0);
}

tree::TerminalNode* HaskellParser::Options_ghcContext::OPTIONS_GHC() {
  return getToken(HaskellParser::OPTIONS_GHC, 0);
}

tree::TerminalNode* HaskellParser::Options_ghcContext::ClosePragmaBracket() {
  return getToken(HaskellParser::ClosePragmaBracket, 0);
}

std::vector<tree::TerminalNode *> HaskellParser::Options_ghcContext::Minus() {
  return getTokens(HaskellParser::Minus);
}

tree::TerminalNode* HaskellParser::Options_ghcContext::Minus(size_t i) {
  return getToken(HaskellParser::Minus, i);
}

HaskellParser::SemiContext* HaskellParser::Options_ghcContext::semi() {
  return getRuleContext<HaskellParser::SemiContext>(0);
}

std::vector<HaskellParser::VaridContext *> HaskellParser::Options_ghcContext::varid() {
  return getRuleContexts<HaskellParser::VaridContext>();
}

HaskellParser::VaridContext* HaskellParser::Options_ghcContext::varid(size_t i) {
  return getRuleContext<HaskellParser::VaridContext>(i);
}

std::vector<HaskellParser::ConidContext *> HaskellParser::Options_ghcContext::conid() {
  return getRuleContexts<HaskellParser::ConidContext>();
}

HaskellParser::ConidContext* HaskellParser::Options_ghcContext::conid(size_t i) {
  return getRuleContext<HaskellParser::ConidContext>(i);
}


size_t HaskellParser::Options_ghcContext::getRuleIndex() const {
  return HaskellParser::RuleOptions_ghc;
}

void HaskellParser::Options_ghcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptions_ghc(this);
}

void HaskellParser::Options_ghcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptions_ghc(this);
}

HaskellParser::Options_ghcContext* HaskellParser::options_ghc() {
  Options_ghcContext *_localctx = _tracker.createInstance<Options_ghcContext>(_ctx, getState());
  enterRule(_localctx, 14, HaskellParser::RuleOptions_ghc);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(585);
    match(HaskellParser::OpenPragmaBracket);
    setState(586);
    match(HaskellParser::OPTIONS_GHC);
    setState(594);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Minus) {
      setState(587);
      match(HaskellParser::Minus);
      setState(590);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case HaskellParser::AS:
        case HaskellParser::HIDING:
        case HaskellParser::QUALIFIED:
        case HaskellParser::EXPORT:
        case HaskellParser::STDCALL:
        case HaskellParser::CCALL:
        case HaskellParser::CAPI:
        case HaskellParser::JSCALL:
        case HaskellParser::STOCK:
        case HaskellParser::ANYCLASS:
        case HaskellParser::VIA:
        case HaskellParser::VARID: {
          setState(588);
          varid();
          break;
        }

        case HaskellParser::CONID: {
          setState(589);
          conid();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(596);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(597);
    match(HaskellParser::ClosePragmaBracket);
    setState(599);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx)) {
    case 1: {
      setState(598);
      semi();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_optionsContext ------------------------------------------------------------------

HaskellParser::Simple_optionsContext::Simple_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Simple_optionsContext::OpenPragmaBracket() {
  return getToken(HaskellParser::OpenPragmaBracket, 0);
}

tree::TerminalNode* HaskellParser::Simple_optionsContext::OPTIONS() {
  return getToken(HaskellParser::OPTIONS, 0);
}

tree::TerminalNode* HaskellParser::Simple_optionsContext::ClosePragmaBracket() {
  return getToken(HaskellParser::ClosePragmaBracket, 0);
}

std::vector<tree::TerminalNode *> HaskellParser::Simple_optionsContext::Minus() {
  return getTokens(HaskellParser::Minus);
}

tree::TerminalNode* HaskellParser::Simple_optionsContext::Minus(size_t i) {
  return getToken(HaskellParser::Minus, i);
}

HaskellParser::SemiContext* HaskellParser::Simple_optionsContext::semi() {
  return getRuleContext<HaskellParser::SemiContext>(0);
}

std::vector<HaskellParser::VaridContext *> HaskellParser::Simple_optionsContext::varid() {
  return getRuleContexts<HaskellParser::VaridContext>();
}

HaskellParser::VaridContext* HaskellParser::Simple_optionsContext::varid(size_t i) {
  return getRuleContext<HaskellParser::VaridContext>(i);
}

std::vector<HaskellParser::ConidContext *> HaskellParser::Simple_optionsContext::conid() {
  return getRuleContexts<HaskellParser::ConidContext>();
}

HaskellParser::ConidContext* HaskellParser::Simple_optionsContext::conid(size_t i) {
  return getRuleContext<HaskellParser::ConidContext>(i);
}


size_t HaskellParser::Simple_optionsContext::getRuleIndex() const {
  return HaskellParser::RuleSimple_options;
}

void HaskellParser::Simple_optionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_options(this);
}

void HaskellParser::Simple_optionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_options(this);
}

HaskellParser::Simple_optionsContext* HaskellParser::simple_options() {
  Simple_optionsContext *_localctx = _tracker.createInstance<Simple_optionsContext>(_ctx, getState());
  enterRule(_localctx, 16, HaskellParser::RuleSimple_options);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(601);
    match(HaskellParser::OpenPragmaBracket);
    setState(602);
    match(HaskellParser::OPTIONS);
    setState(610);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Minus) {
      setState(603);
      match(HaskellParser::Minus);
      setState(606);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case HaskellParser::AS:
        case HaskellParser::HIDING:
        case HaskellParser::QUALIFIED:
        case HaskellParser::EXPORT:
        case HaskellParser::STDCALL:
        case HaskellParser::CCALL:
        case HaskellParser::CAPI:
        case HaskellParser::JSCALL:
        case HaskellParser::STOCK:
        case HaskellParser::ANYCLASS:
        case HaskellParser::VIA:
        case HaskellParser::VARID: {
          setState(604);
          varid();
          break;
        }

        case HaskellParser::CONID: {
          setState(605);
          conid();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(612);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(613);
    match(HaskellParser::ClosePragmaBracket);
    setState(615);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
    case 1: {
      setState(614);
      semi();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Extension_Context ------------------------------------------------------------------

HaskellParser::Extension_Context::Extension_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Extension_Context::CONID() {
  return getToken(HaskellParser::CONID, 0);
}


size_t HaskellParser::Extension_Context::getRuleIndex() const {
  return HaskellParser::RuleExtension_;
}

void HaskellParser::Extension_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExtension_(this);
}

void HaskellParser::Extension_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExtension_(this);
}

HaskellParser::Extension_Context* HaskellParser::extension_() {
  Extension_Context *_localctx = _tracker.createInstance<Extension_Context>(_ctx, getState());
  enterRule(_localctx, 18, HaskellParser::RuleExtension_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(617);
    match(HaskellParser::CONID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BodyContext ------------------------------------------------------------------

HaskellParser::BodyContext::BodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::ImpdeclsContext* HaskellParser::BodyContext::impdecls() {
  return getRuleContext<HaskellParser::ImpdeclsContext>(0);
}

HaskellParser::TopdeclsContext* HaskellParser::BodyContext::topdecls() {
  return getRuleContext<HaskellParser::TopdeclsContext>(0);
}


size_t HaskellParser::BodyContext::getRuleIndex() const {
  return HaskellParser::RuleBody;
}

void HaskellParser::BodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBody(this);
}

void HaskellParser::BodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBody(this);
}

HaskellParser::BodyContext* HaskellParser::body() {
  BodyContext *_localctx = _tracker.createInstance<BodyContext>(_ctx, getState());
  enterRule(_localctx, 20, HaskellParser::RuleBody);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(624);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(619);
      impdecls();
      setState(620);
      topdecls();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(622);
      impdecls();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(623);
      topdecls();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImpdeclsContext ------------------------------------------------------------------

HaskellParser::ImpdeclsContext::ImpdeclsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::ImpdeclContext *> HaskellParser::ImpdeclsContext::impdecl() {
  return getRuleContexts<HaskellParser::ImpdeclContext>();
}

HaskellParser::ImpdeclContext* HaskellParser::ImpdeclsContext::impdecl(size_t i) {
  return getRuleContext<HaskellParser::ImpdeclContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::ImpdeclsContext::NEWLINE() {
  return getTokens(HaskellParser::NEWLINE);
}

tree::TerminalNode* HaskellParser::ImpdeclsContext::NEWLINE(size_t i) {
  return getToken(HaskellParser::NEWLINE, i);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::ImpdeclsContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::ImpdeclsContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::ImpdeclsContext::getRuleIndex() const {
  return HaskellParser::RuleImpdecls;
}

void HaskellParser::ImpdeclsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImpdecls(this);
}

void HaskellParser::ImpdeclsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImpdecls(this);
}

HaskellParser::ImpdeclsContext* HaskellParser::impdecls() {
  ImpdeclsContext *_localctx = _tracker.createInstance<ImpdeclsContext>(_ctx, getState());
  enterRule(_localctx, 22, HaskellParser::RuleImpdecls);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(629); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(629);
              _errHandler->sync(this);
              switch (_input->LA(1)) {
                case HaskellParser::IMPORT: {
                  setState(626);
                  impdecl();
                  break;
                }

                case HaskellParser::NEWLINE: {
                  setState(627);
                  match(HaskellParser::NEWLINE);
                  break;
                }

                case HaskellParser::Semi:
                case HaskellParser::SEMI: {
                  setState(628);
                  semi();
                  break;
                }

              default:
                throw NoViableAltException(this);
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(631); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExportsContext ------------------------------------------------------------------

HaskellParser::ExportsContext::ExportsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::ExportsContext::OpenRoundBracket() {
  return getToken(HaskellParser::OpenRoundBracket, 0);
}

tree::TerminalNode* HaskellParser::ExportsContext::CloseRoundBracket() {
  return getToken(HaskellParser::CloseRoundBracket, 0);
}

std::vector<HaskellParser::ExprtContext *> HaskellParser::ExportsContext::exprt() {
  return getRuleContexts<HaskellParser::ExprtContext>();
}

HaskellParser::ExprtContext* HaskellParser::ExportsContext::exprt(size_t i) {
  return getRuleContext<HaskellParser::ExprtContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::ExportsContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::ExportsContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}


size_t HaskellParser::ExportsContext::getRuleIndex() const {
  return HaskellParser::RuleExports;
}

void HaskellParser::ExportsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExports(this);
}

void HaskellParser::ExportsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExports(this);
}

HaskellParser::ExportsContext* HaskellParser::exports() {
  ExportsContext *_localctx = _tracker.createInstance<ExportsContext>(_ctx, getState());
  enterRule(_localctx, 24, HaskellParser::RuleExports);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(633);
    match(HaskellParser::OpenRoundBracket);
    setState(642);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1976649195196432) != 0) || ((((_la - 120) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 120)) & 193) != 0)) {
      setState(634);
      exprt();
      setState(639);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(635);
          match(HaskellParser::Comma);
          setState(636);
          exprt(); 
        }
        setState(641);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx);
      }
    }
    setState(645);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::Comma) {
      setState(644);
      match(HaskellParser::Comma);
    }
    setState(647);
    match(HaskellParser::CloseRoundBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprtContext ------------------------------------------------------------------

HaskellParser::ExprtContext::ExprtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::QvarContext *> HaskellParser::ExprtContext::qvar() {
  return getRuleContexts<HaskellParser::QvarContext>();
}

HaskellParser::QvarContext* HaskellParser::ExprtContext::qvar(size_t i) {
  return getRuleContext<HaskellParser::QvarContext>(i);
}

HaskellParser::QtyconContext* HaskellParser::ExprtContext::qtycon() {
  return getRuleContext<HaskellParser::QtyconContext>(0);
}

tree::TerminalNode* HaskellParser::ExprtContext::OpenRoundBracket() {
  return getToken(HaskellParser::OpenRoundBracket, 0);
}

tree::TerminalNode* HaskellParser::ExprtContext::DoubleDot() {
  return getToken(HaskellParser::DoubleDot, 0);
}

tree::TerminalNode* HaskellParser::ExprtContext::CloseRoundBracket() {
  return getToken(HaskellParser::CloseRoundBracket, 0);
}

std::vector<HaskellParser::CnameContext *> HaskellParser::ExprtContext::cname() {
  return getRuleContexts<HaskellParser::CnameContext>();
}

HaskellParser::CnameContext* HaskellParser::ExprtContext::cname(size_t i) {
  return getRuleContext<HaskellParser::CnameContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::ExprtContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::ExprtContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}

HaskellParser::QtyclsContext* HaskellParser::ExprtContext::qtycls() {
  return getRuleContext<HaskellParser::QtyclsContext>(0);
}

tree::TerminalNode* HaskellParser::ExprtContext::MODULE() {
  return getToken(HaskellParser::MODULE, 0);
}

HaskellParser::ModidContext* HaskellParser::ExprtContext::modid() {
  return getRuleContext<HaskellParser::ModidContext>(0);
}


size_t HaskellParser::ExprtContext::getRuleIndex() const {
  return HaskellParser::RuleExprt;
}

void HaskellParser::ExprtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprt(this);
}

void HaskellParser::ExprtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprt(this);
}

HaskellParser::ExprtContext* HaskellParser::exprt() {
  ExprtContext *_localctx = _tracker.createInstance<ExprtContext>(_ctx, getState());
  enterRule(_localctx, 26, HaskellParser::RuleExprt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(688);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(649);
      qvar();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(650);
      qtycon();
      setState(666);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
      case 1: {
        setState(651);
        match(HaskellParser::OpenRoundBracket);
        setState(652);
        match(HaskellParser::DoubleDot);
        setState(653);
        match(HaskellParser::CloseRoundBracket);
        break;
      }

      case 2: {
        setState(654);
        match(HaskellParser::OpenRoundBracket);
        setState(663);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 1976649193099280) != 0) || ((((_la - 118) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 118)) & 789) != 0)) {
          setState(655);
          cname();
          setState(660);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == HaskellParser::Comma) {
            setState(656);
            match(HaskellParser::Comma);
            setState(657);
            cname();
            setState(662);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
        }
        setState(665);
        match(HaskellParser::CloseRoundBracket);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(668);
      qtycls();
      setState(684);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
      case 1: {
        setState(669);
        match(HaskellParser::OpenRoundBracket);
        setState(670);
        match(HaskellParser::DoubleDot);
        setState(671);
        match(HaskellParser::CloseRoundBracket);
        break;
      }

      case 2: {
        setState(672);
        match(HaskellParser::OpenRoundBracket);
        setState(681);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 1976649193099280) != 0) || ((((_la - 120) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 120)) & 193) != 0)) {
          setState(673);
          qvar();
          setState(678);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == HaskellParser::Comma) {
            setState(674);
            match(HaskellParser::Comma);
            setState(675);
            qvar();
            setState(680);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
        }
        setState(683);
        match(HaskellParser::CloseRoundBracket);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(686);
      match(HaskellParser::MODULE);
      setState(687);
      modid();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImpdeclContext ------------------------------------------------------------------

HaskellParser::ImpdeclContext::ImpdeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::ImpdeclContext::IMPORT() {
  return getToken(HaskellParser::IMPORT, 0);
}

std::vector<HaskellParser::ModidContext *> HaskellParser::ImpdeclContext::modid() {
  return getRuleContexts<HaskellParser::ModidContext>();
}

HaskellParser::ModidContext* HaskellParser::ImpdeclContext::modid(size_t i) {
  return getRuleContext<HaskellParser::ModidContext>(i);
}

tree::TerminalNode* HaskellParser::ImpdeclContext::QUALIFIED() {
  return getToken(HaskellParser::QUALIFIED, 0);
}

tree::TerminalNode* HaskellParser::ImpdeclContext::AS() {
  return getToken(HaskellParser::AS, 0);
}

HaskellParser::ImpspecContext* HaskellParser::ImpdeclContext::impspec() {
  return getRuleContext<HaskellParser::ImpspecContext>(0);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::ImpdeclContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::ImpdeclContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::ImpdeclContext::getRuleIndex() const {
  return HaskellParser::RuleImpdecl;
}

void HaskellParser::ImpdeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImpdecl(this);
}

void HaskellParser::ImpdeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImpdecl(this);
}

HaskellParser::ImpdeclContext* HaskellParser::impdecl() {
  ImpdeclContext *_localctx = _tracker.createInstance<ImpdeclContext>(_ctx, getState());
  enterRule(_localctx, 28, HaskellParser::RuleImpdecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(690);
    match(HaskellParser::IMPORT);
    setState(692);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::QUALIFIED) {
      setState(691);
      match(HaskellParser::QUALIFIED);
    }
    setState(694);
    modid();
    setState(697);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::AS) {
      setState(695);
      match(HaskellParser::AS);
      setState(696);
      modid();
    }
    setState(700);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::HIDING || _la == HaskellParser::OpenRoundBracket) {
      setState(699);
      impspec();
    }
    setState(703); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(702);
              semi();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(705); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImpspecContext ------------------------------------------------------------------

HaskellParser::ImpspecContext::ImpspecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::ImpspecContext::OpenRoundBracket() {
  return getToken(HaskellParser::OpenRoundBracket, 0);
}

tree::TerminalNode* HaskellParser::ImpspecContext::CloseRoundBracket() {
  return getToken(HaskellParser::CloseRoundBracket, 0);
}

std::vector<HaskellParser::HimportContext *> HaskellParser::ImpspecContext::himport() {
  return getRuleContexts<HaskellParser::HimportContext>();
}

HaskellParser::HimportContext* HaskellParser::ImpspecContext::himport(size_t i) {
  return getRuleContext<HaskellParser::HimportContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::ImpspecContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::ImpspecContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}

tree::TerminalNode* HaskellParser::ImpspecContext::HIDING() {
  return getToken(HaskellParser::HIDING, 0);
}


size_t HaskellParser::ImpspecContext::getRuleIndex() const {
  return HaskellParser::RuleImpspec;
}

void HaskellParser::ImpspecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImpspec(this);
}

void HaskellParser::ImpspecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImpspec(this);
}

HaskellParser::ImpspecContext* HaskellParser::impspec() {
  ImpspecContext *_localctx = _tracker.createInstance<ImpspecContext>(_ctx, getState());
  enterRule(_localctx, 30, HaskellParser::RuleImpspec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(738);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::OpenRoundBracket: {
        enterOuterAlt(_localctx, 1);
        setState(707);
        match(HaskellParser::OpenRoundBracket);
        setState(719);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 1976649193099280) != 0) || ((((_la - 120) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 120)) & 193) != 0)) {
          setState(708);
          himport();
          setState(713);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(709);
              match(HaskellParser::Comma);
              setState(710);
              himport(); 
            }
            setState(715);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
          }
          setState(717);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == HaskellParser::Comma) {
            setState(716);
            match(HaskellParser::Comma);
          }
        }
        setState(721);
        match(HaskellParser::CloseRoundBracket);
        break;
      }

      case HaskellParser::HIDING: {
        enterOuterAlt(_localctx, 2);
        setState(722);
        match(HaskellParser::HIDING);
        setState(723);
        match(HaskellParser::OpenRoundBracket);
        setState(735);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 1976649193099280) != 0) || ((((_la - 120) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 120)) & 193) != 0)) {
          setState(724);
          himport();
          setState(729);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(725);
              match(HaskellParser::Comma);
              setState(726);
              himport(); 
            }
            setState(731);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx);
          }
          setState(733);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == HaskellParser::Comma) {
            setState(732);
            match(HaskellParser::Comma);
          }
        }
        setState(737);
        match(HaskellParser::CloseRoundBracket);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HimportContext ------------------------------------------------------------------

HaskellParser::HimportContext::HimportContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Var_Context* HaskellParser::HimportContext::var_() {
  return getRuleContext<HaskellParser::Var_Context>(0);
}

HaskellParser::TyconContext* HaskellParser::HimportContext::tycon() {
  return getRuleContext<HaskellParser::TyconContext>(0);
}

tree::TerminalNode* HaskellParser::HimportContext::OpenRoundBracket() {
  return getToken(HaskellParser::OpenRoundBracket, 0);
}

tree::TerminalNode* HaskellParser::HimportContext::DoubleDot() {
  return getToken(HaskellParser::DoubleDot, 0);
}

tree::TerminalNode* HaskellParser::HimportContext::CloseRoundBracket() {
  return getToken(HaskellParser::CloseRoundBracket, 0);
}

std::vector<HaskellParser::CnameContext *> HaskellParser::HimportContext::cname() {
  return getRuleContexts<HaskellParser::CnameContext>();
}

HaskellParser::CnameContext* HaskellParser::HimportContext::cname(size_t i) {
  return getRuleContext<HaskellParser::CnameContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::HimportContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::HimportContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}

HaskellParser::TyclsContext* HaskellParser::HimportContext::tycls() {
  return getRuleContext<HaskellParser::TyclsContext>(0);
}

HaskellParser::Sig_varsContext* HaskellParser::HimportContext::sig_vars() {
  return getRuleContext<HaskellParser::Sig_varsContext>(0);
}


size_t HaskellParser::HimportContext::getRuleIndex() const {
  return HaskellParser::RuleHimport;
}

void HaskellParser::HimportContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHimport(this);
}

void HaskellParser::HimportContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHimport(this);
}

HaskellParser::HimportContext* HaskellParser::himport() {
  HimportContext *_localctx = _tracker.createInstance<HimportContext>(_ctx, getState());
  enterRule(_localctx, 32, HaskellParser::RuleHimport);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(770);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(740);
      var_();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(741);
      tycon();
      setState(757);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx)) {
      case 1: {
        setState(742);
        match(HaskellParser::OpenRoundBracket);
        setState(743);
        match(HaskellParser::DoubleDot);
        setState(744);
        match(HaskellParser::CloseRoundBracket);
        break;
      }

      case 2: {
        setState(745);
        match(HaskellParser::OpenRoundBracket);
        setState(754);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 1976649193099280) != 0) || ((((_la - 118) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 118)) & 789) != 0)) {
          setState(746);
          cname();
          setState(751);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == HaskellParser::Comma) {
            setState(747);
            match(HaskellParser::Comma);
            setState(748);
            cname();
            setState(753);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
        }
        setState(756);
        match(HaskellParser::CloseRoundBracket);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(759);
      tycls();
      setState(768);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx)) {
      case 1: {
        setState(760);
        match(HaskellParser::OpenRoundBracket);
        setState(761);
        match(HaskellParser::DoubleDot);
        setState(762);
        match(HaskellParser::CloseRoundBracket);
        break;
      }

      case 2: {
        setState(763);
        match(HaskellParser::OpenRoundBracket);
        setState(765);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 1976649193099280) != 0) || _la == HaskellParser::OpenRoundBracket

        || _la == HaskellParser::VARID) {
          setState(764);
          sig_vars();
        }
        setState(767);
        match(HaskellParser::CloseRoundBracket);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CnameContext ------------------------------------------------------------------

HaskellParser::CnameContext::CnameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Var_Context* HaskellParser::CnameContext::var_() {
  return getRuleContext<HaskellParser::Var_Context>(0);
}

HaskellParser::ConContext* HaskellParser::CnameContext::con() {
  return getRuleContext<HaskellParser::ConContext>(0);
}


size_t HaskellParser::CnameContext::getRuleIndex() const {
  return HaskellParser::RuleCname;
}

void HaskellParser::CnameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCname(this);
}

void HaskellParser::CnameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCname(this);
}

HaskellParser::CnameContext* HaskellParser::cname() {
  CnameContext *_localctx = _tracker.createInstance<CnameContext>(_ctx, getState());
  enterRule(_localctx, 34, HaskellParser::RuleCname);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(774);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(772);
      var_();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(773);
      con();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FixityContext ------------------------------------------------------------------

HaskellParser::FixityContext::FixityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::FixityContext::INFIX() {
  return getToken(HaskellParser::INFIX, 0);
}

tree::TerminalNode* HaskellParser::FixityContext::INFIXL() {
  return getToken(HaskellParser::INFIXL, 0);
}

tree::TerminalNode* HaskellParser::FixityContext::INFIXR() {
  return getToken(HaskellParser::INFIXR, 0);
}


size_t HaskellParser::FixityContext::getRuleIndex() const {
  return HaskellParser::RuleFixity;
}

void HaskellParser::FixityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFixity(this);
}

void HaskellParser::FixityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFixity(this);
}

HaskellParser::FixityContext* HaskellParser::fixity() {
  FixityContext *_localctx = _tracker.createInstance<FixityContext>(_ctx, getState());
  enterRule(_localctx, 36, HaskellParser::RuleFixity);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(776);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 458752) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OpsContext ------------------------------------------------------------------

HaskellParser::OpsContext::OpsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::OpContext *> HaskellParser::OpsContext::op() {
  return getRuleContexts<HaskellParser::OpContext>();
}

HaskellParser::OpContext* HaskellParser::OpsContext::op(size_t i) {
  return getRuleContext<HaskellParser::OpContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::OpsContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::OpsContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}


size_t HaskellParser::OpsContext::getRuleIndex() const {
  return HaskellParser::RuleOps;
}

void HaskellParser::OpsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOps(this);
}

void HaskellParser::OpsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOps(this);
}

HaskellParser::OpsContext* HaskellParser::ops() {
  OpsContext *_localctx = _tracker.createInstance<OpsContext>(_ctx, getState());
  enterRule(_localctx, 38, HaskellParser::RuleOps);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(778);
    op();
    setState(783);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Comma) {
      setState(779);
      match(HaskellParser::Comma);
      setState(780);
      op();
      setState(785);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TopdeclsContext ------------------------------------------------------------------

HaskellParser::TopdeclsContext::TopdeclsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::TopdeclContext *> HaskellParser::TopdeclsContext::topdecl() {
  return getRuleContexts<HaskellParser::TopdeclContext>();
}

HaskellParser::TopdeclContext* HaskellParser::TopdeclsContext::topdecl(size_t i) {
  return getRuleContext<HaskellParser::TopdeclContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::TopdeclsContext::NEWLINE() {
  return getTokens(HaskellParser::NEWLINE);
}

tree::TerminalNode* HaskellParser::TopdeclsContext::NEWLINE(size_t i) {
  return getToken(HaskellParser::NEWLINE, i);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::TopdeclsContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::TopdeclsContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::TopdeclsContext::getRuleIndex() const {
  return HaskellParser::RuleTopdecls;
}

void HaskellParser::TopdeclsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTopdecls(this);
}

void HaskellParser::TopdeclsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTopdecls(this);
}

HaskellParser::TopdeclsContext* HaskellParser::topdecls() {
  TopdeclsContext *_localctx = _tracker.createInstance<TopdeclsContext>(_ctx, getState());
  enterRule(_localctx, 40, HaskellParser::RuleTopdecls);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(794); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(794);
              _errHandler->sync(this);
              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx)) {
              case 1: {
                setState(786);
                topdecl();
                setState(788); 
                _errHandler->sync(this);
                alt = 1;
                do {
                  switch (alt) {
                    case 1: {
                          setState(787);
                          semi();
                          break;
                        }

                  default:
                    throw NoViableAltException(this);
                  }
                  setState(790); 
                  _errHandler->sync(this);
                  alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx);
                } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
                break;
              }

              case 2: {
                setState(792);
                match(HaskellParser::NEWLINE);
                break;
              }

              case 3: {
                setState(793);
                semi();
                break;
              }

              default:
                break;
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(796); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TopdeclContext ------------------------------------------------------------------

HaskellParser::TopdeclContext::TopdeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Cl_declContext* HaskellParser::TopdeclContext::cl_decl() {
  return getRuleContext<HaskellParser::Cl_declContext>(0);
}

HaskellParser::Ty_declContext* HaskellParser::TopdeclContext::ty_decl() {
  return getRuleContext<HaskellParser::Ty_declContext>(0);
}

HaskellParser::Standalone_kind_sigContext* HaskellParser::TopdeclContext::standalone_kind_sig() {
  return getRuleContext<HaskellParser::Standalone_kind_sigContext>(0);
}

HaskellParser::Inst_declContext* HaskellParser::TopdeclContext::inst_decl() {
  return getRuleContext<HaskellParser::Inst_declContext>(0);
}

HaskellParser::Standalone_derivingContext* HaskellParser::TopdeclContext::standalone_deriving() {
  return getRuleContext<HaskellParser::Standalone_derivingContext>(0);
}

HaskellParser::Role_annotContext* HaskellParser::TopdeclContext::role_annot() {
  return getRuleContext<HaskellParser::Role_annotContext>(0);
}

tree::TerminalNode* HaskellParser::TopdeclContext::DEFAULT() {
  return getToken(HaskellParser::DEFAULT, 0);
}

tree::TerminalNode* HaskellParser::TopdeclContext::OpenRoundBracket() {
  return getToken(HaskellParser::OpenRoundBracket, 0);
}

tree::TerminalNode* HaskellParser::TopdeclContext::CloseRoundBracket() {
  return getToken(HaskellParser::CloseRoundBracket, 0);
}

HaskellParser::Comma_typesContext* HaskellParser::TopdeclContext::comma_types() {
  return getRuleContext<HaskellParser::Comma_typesContext>(0);
}

tree::TerminalNode* HaskellParser::TopdeclContext::FOREIGN() {
  return getToken(HaskellParser::FOREIGN, 0);
}

HaskellParser::FdeclContext* HaskellParser::TopdeclContext::fdecl() {
  return getRuleContext<HaskellParser::FdeclContext>(0);
}

tree::TerminalNode* HaskellParser::TopdeclContext::OpenPragmaBracket() {
  return getToken(HaskellParser::OpenPragmaBracket, 0);
}

tree::TerminalNode* HaskellParser::TopdeclContext::DEPRECATED() {
  return getToken(HaskellParser::DEPRECATED, 0);
}

tree::TerminalNode* HaskellParser::TopdeclContext::ClosePragmaBracket() {
  return getToken(HaskellParser::ClosePragmaBracket, 0);
}

HaskellParser::DeprecationsContext* HaskellParser::TopdeclContext::deprecations() {
  return getRuleContext<HaskellParser::DeprecationsContext>(0);
}

tree::TerminalNode* HaskellParser::TopdeclContext::WARNING() {
  return getToken(HaskellParser::WARNING, 0);
}

HaskellParser::WarningsContext* HaskellParser::TopdeclContext::warnings() {
  return getRuleContext<HaskellParser::WarningsContext>(0);
}

tree::TerminalNode* HaskellParser::TopdeclContext::RULES() {
  return getToken(HaskellParser::RULES, 0);
}

HaskellParser::RulesContext* HaskellParser::TopdeclContext::rules() {
  return getRuleContext<HaskellParser::RulesContext>(0);
}

HaskellParser::AnnotationContext* HaskellParser::TopdeclContext::annotation() {
  return getRuleContext<HaskellParser::AnnotationContext>(0);
}

HaskellParser::Decl_no_thContext* HaskellParser::TopdeclContext::decl_no_th() {
  return getRuleContext<HaskellParser::Decl_no_thContext>(0);
}

HaskellParser::InfixexpContext* HaskellParser::TopdeclContext::infixexp() {
  return getRuleContext<HaskellParser::InfixexpContext>(0);
}


size_t HaskellParser::TopdeclContext::getRuleIndex() const {
  return HaskellParser::RuleTopdecl;
}

void HaskellParser::TopdeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTopdecl(this);
}

void HaskellParser::TopdeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTopdecl(this);
}

HaskellParser::TopdeclContext* HaskellParser::topdecl() {
  TopdeclContext *_localctx = _tracker.createInstance<TopdeclContext>(_ctx, getState());
  enterRule(_localctx, 42, HaskellParser::RuleTopdecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(833);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(798);
      cl_decl();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(799);
      ty_decl();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(800);
      standalone_kind_sig();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(801);
      inst_decl();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(802);
      standalone_deriving();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(803);
      role_annot();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(804);
      match(HaskellParser::DEFAULT);
      setState(805);
      match(HaskellParser::OpenRoundBracket);
      setState(807);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 1976649998405648) != 0) || ((((_la - 82) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 82)) & 253460863659982847) != 0)) {
        setState(806);
        comma_types();
      }
      setState(809);
      match(HaskellParser::CloseRoundBracket);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(810);
      match(HaskellParser::FOREIGN);
      setState(811);
      fdecl();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(812);
      match(HaskellParser::OpenPragmaBracket);
      setState(813);
      match(HaskellParser::DEPRECATED);
      setState(815);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 1976649193099280) != 0) || ((((_la - 118) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 118)) & 789) != 0)) {
        setState(814);
        deprecations();
      }
      setState(817);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(818);
      match(HaskellParser::OpenPragmaBracket);
      setState(819);
      match(HaskellParser::WARNING);
      setState(821);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 1976649193099280) != 0) || ((((_la - 118) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 118)) & 789) != 0)) {
        setState(820);
        warnings();
      }
      setState(823);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(824);
      match(HaskellParser::OpenPragmaBracket);
      setState(825);
      match(HaskellParser::RULES);
      setState(827);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::STRING) {
        setState(826);
        rules();
      }
      setState(829);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(830);
      annotation();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(831);
      decl_no_th();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(832);
      infixexp();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cl_declContext ------------------------------------------------------------------

HaskellParser::Cl_declContext::Cl_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Cl_declContext::CLASS() {
  return getToken(HaskellParser::CLASS, 0);
}

HaskellParser::Tycl_hdrContext* HaskellParser::Cl_declContext::tycl_hdr() {
  return getRuleContext<HaskellParser::Tycl_hdrContext>(0);
}

HaskellParser::FdsContext* HaskellParser::Cl_declContext::fds() {
  return getRuleContext<HaskellParser::FdsContext>(0);
}

HaskellParser::Where_clsContext* HaskellParser::Cl_declContext::where_cls() {
  return getRuleContext<HaskellParser::Where_clsContext>(0);
}


size_t HaskellParser::Cl_declContext::getRuleIndex() const {
  return HaskellParser::RuleCl_decl;
}

void HaskellParser::Cl_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCl_decl(this);
}

void HaskellParser::Cl_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCl_decl(this);
}

HaskellParser::Cl_declContext* HaskellParser::cl_decl() {
  Cl_declContext *_localctx = _tracker.createInstance<Cl_declContext>(_ctx, getState());
  enterRule(_localctx, 44, HaskellParser::RuleCl_decl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(835);
    match(HaskellParser::CLASS);
    setState(836);
    tycl_hdr();
    setState(838);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::Pipe) {
      setState(837);
      fds();
    }
    setState(841);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::WHERE) {
      setState(840);
      where_cls();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ty_declContext ------------------------------------------------------------------

HaskellParser::Ty_declContext::Ty_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Ty_declContext::TYPE() {
  return getToken(HaskellParser::TYPE, 0);
}

HaskellParser::Type_Context* HaskellParser::Ty_declContext::type_() {
  return getRuleContext<HaskellParser::Type_Context>(0);
}

tree::TerminalNode* HaskellParser::Ty_declContext::Eq() {
  return getToken(HaskellParser::Eq, 0);
}

HaskellParser::KtypedocContext* HaskellParser::Ty_declContext::ktypedoc() {
  return getRuleContext<HaskellParser::KtypedocContext>(0);
}

tree::TerminalNode* HaskellParser::Ty_declContext::FAMILY() {
  return getToken(HaskellParser::FAMILY, 0);
}

HaskellParser::Opt_tyfam_kind_sigContext* HaskellParser::Ty_declContext::opt_tyfam_kind_sig() {
  return getRuleContext<HaskellParser::Opt_tyfam_kind_sigContext>(0);
}

HaskellParser::Opt_injective_infoContext* HaskellParser::Ty_declContext::opt_injective_info() {
  return getRuleContext<HaskellParser::Opt_injective_infoContext>(0);
}

HaskellParser::Where_type_familyContext* HaskellParser::Ty_declContext::where_type_family() {
  return getRuleContext<HaskellParser::Where_type_familyContext>(0);
}

tree::TerminalNode* HaskellParser::Ty_declContext::DATA() {
  return getToken(HaskellParser::DATA, 0);
}

HaskellParser::Tycl_hdrContext* HaskellParser::Ty_declContext::tycl_hdr() {
  return getRuleContext<HaskellParser::Tycl_hdrContext>(0);
}

HaskellParser::ConstrsContext* HaskellParser::Ty_declContext::constrs() {
  return getRuleContext<HaskellParser::ConstrsContext>(0);
}

HaskellParser::Capi_ctypeContext* HaskellParser::Ty_declContext::capi_ctype() {
  return getRuleContext<HaskellParser::Capi_ctypeContext>(0);
}

HaskellParser::DerivingsContext* HaskellParser::Ty_declContext::derivings() {
  return getRuleContext<HaskellParser::DerivingsContext>(0);
}

tree::TerminalNode* HaskellParser::Ty_declContext::NEWTYPE() {
  return getToken(HaskellParser::NEWTYPE, 0);
}

HaskellParser::Opt_kind_sigContext* HaskellParser::Ty_declContext::opt_kind_sig() {
  return getRuleContext<HaskellParser::Opt_kind_sigContext>(0);
}

HaskellParser::Gadt_constrlistContext* HaskellParser::Ty_declContext::gadt_constrlist() {
  return getRuleContext<HaskellParser::Gadt_constrlistContext>(0);
}

HaskellParser::Opt_datafam_kind_sigContext* HaskellParser::Ty_declContext::opt_datafam_kind_sig() {
  return getRuleContext<HaskellParser::Opt_datafam_kind_sigContext>(0);
}


size_t HaskellParser::Ty_declContext::getRuleIndex() const {
  return HaskellParser::RuleTy_decl;
}

void HaskellParser::Ty_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTy_decl(this);
}

void HaskellParser::Ty_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTy_decl(this);
}

HaskellParser::Ty_declContext* HaskellParser::ty_decl() {
  Ty_declContext *_localctx = _tracker.createInstance<Ty_declContext>(_ctx, getState());
  enterRule(_localctx, 46, HaskellParser::RuleTy_decl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(912);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(843);
      match(HaskellParser::TYPE);
      setState(844);
      type_();
      setState(845);
      match(HaskellParser::Eq);
      setState(846);
      ktypedoc();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(848);
      match(HaskellParser::TYPE);
      setState(849);
      match(HaskellParser::FAMILY);
      setState(850);
      type_();
      setState(852);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DoubleColon

      || _la == HaskellParser::Eq) {
        setState(851);
        opt_tyfam_kind_sig();
      }
      setState(855);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::Pipe) {
        setState(854);
        opt_injective_info();
      }
      setState(858);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::WHERE) {
        setState(857);
        where_type_family();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(860);
      match(HaskellParser::DATA);
      setState(862);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
      case 1: {
        setState(861);
        capi_ctype();
        break;
      }

      default:
        break;
      }
      setState(864);
      tycl_hdr();
      setState(865);
      constrs();
      setState(867);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DERIVING) {
        setState(866);
        derivings();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(869);
      match(HaskellParser::NEWTYPE);
      setState(871);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx)) {
      case 1: {
        setState(870);
        capi_ctype();
        break;
      }

      default:
        break;
      }
      setState(873);
      tycl_hdr();
      setState(874);
      constrs();
      setState(876);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DERIVING) {
        setState(875);
        derivings();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(878);
      match(HaskellParser::DATA);
      setState(880);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 68, _ctx)) {
      case 1: {
        setState(879);
        capi_ctype();
        break;
      }

      default:
        break;
      }
      setState(882);
      tycl_hdr();
      setState(884);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DoubleColon) {
        setState(883);
        opt_kind_sig();
      }
      setState(887);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::WHERE) {
        setState(886);
        gadt_constrlist();
      }
      setState(890);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DERIVING) {
        setState(889);
        derivings();
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(892);
      match(HaskellParser::NEWTYPE);
      setState(894);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
      case 1: {
        setState(893);
        capi_ctype();
        break;
      }

      default:
        break;
      }
      setState(896);
      tycl_hdr();
      setState(898);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DoubleColon) {
        setState(897);
        opt_kind_sig();
      }
      setState(901);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::WHERE) {
        setState(900);
        gadt_constrlist();
      }
      setState(904);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DERIVING) {
        setState(903);
        derivings();
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(906);
      match(HaskellParser::DATA);
      setState(907);
      match(HaskellParser::FAMILY);
      setState(908);
      type_();
      setState(910);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DoubleColon) {
        setState(909);
        opt_datafam_kind_sig();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Standalone_kind_sigContext ------------------------------------------------------------------

HaskellParser::Standalone_kind_sigContext::Standalone_kind_sigContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Standalone_kind_sigContext::TYPE() {
  return getToken(HaskellParser::TYPE, 0);
}

HaskellParser::Sks_varsContext* HaskellParser::Standalone_kind_sigContext::sks_vars() {
  return getRuleContext<HaskellParser::Sks_varsContext>(0);
}

tree::TerminalNode* HaskellParser::Standalone_kind_sigContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::KtypedocContext* HaskellParser::Standalone_kind_sigContext::ktypedoc() {
  return getRuleContext<HaskellParser::KtypedocContext>(0);
}


size_t HaskellParser::Standalone_kind_sigContext::getRuleIndex() const {
  return HaskellParser::RuleStandalone_kind_sig;
}

void HaskellParser::Standalone_kind_sigContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStandalone_kind_sig(this);
}

void HaskellParser::Standalone_kind_sigContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStandalone_kind_sig(this);
}

HaskellParser::Standalone_kind_sigContext* HaskellParser::standalone_kind_sig() {
  Standalone_kind_sigContext *_localctx = _tracker.createInstance<Standalone_kind_sigContext>(_ctx, getState());
  enterRule(_localctx, 48, HaskellParser::RuleStandalone_kind_sig);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(914);
    match(HaskellParser::TYPE);
    setState(915);
    sks_vars();
    setState(916);
    match(HaskellParser::DoubleColon);
    setState(917);
    ktypedoc();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sks_varsContext ------------------------------------------------------------------

HaskellParser::Sks_varsContext::Sks_varsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::OqtyconContext *> HaskellParser::Sks_varsContext::oqtycon() {
  return getRuleContexts<HaskellParser::OqtyconContext>();
}

HaskellParser::OqtyconContext* HaskellParser::Sks_varsContext::oqtycon(size_t i) {
  return getRuleContext<HaskellParser::OqtyconContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::Sks_varsContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::Sks_varsContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}


size_t HaskellParser::Sks_varsContext::getRuleIndex() const {
  return HaskellParser::RuleSks_vars;
}

void HaskellParser::Sks_varsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSks_vars(this);
}

void HaskellParser::Sks_varsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSks_vars(this);
}

HaskellParser::Sks_varsContext* HaskellParser::sks_vars() {
  Sks_varsContext *_localctx = _tracker.createInstance<Sks_varsContext>(_ctx, getState());
  enterRule(_localctx, 50, HaskellParser::RuleSks_vars);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(919);
    oqtycon();
    setState(924);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Comma) {
      setState(920);
      match(HaskellParser::Comma);
      setState(921);
      oqtycon();
      setState(926);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inst_declContext ------------------------------------------------------------------

HaskellParser::Inst_declContext::Inst_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Inst_declContext::INSTANCE() {
  return getToken(HaskellParser::INSTANCE, 0);
}

HaskellParser::Inst_typeContext* HaskellParser::Inst_declContext::inst_type() {
  return getRuleContext<HaskellParser::Inst_typeContext>(0);
}

HaskellParser::Overlap_pragmaContext* HaskellParser::Inst_declContext::overlap_pragma() {
  return getRuleContext<HaskellParser::Overlap_pragmaContext>(0);
}

HaskellParser::Where_instContext* HaskellParser::Inst_declContext::where_inst() {
  return getRuleContext<HaskellParser::Where_instContext>(0);
}

tree::TerminalNode* HaskellParser::Inst_declContext::TYPE() {
  return getToken(HaskellParser::TYPE, 0);
}

HaskellParser::Ty_fam_inst_eqnContext* HaskellParser::Inst_declContext::ty_fam_inst_eqn() {
  return getRuleContext<HaskellParser::Ty_fam_inst_eqnContext>(0);
}

tree::TerminalNode* HaskellParser::Inst_declContext::DATA() {
  return getToken(HaskellParser::DATA, 0);
}

HaskellParser::Tycl_hdr_instContext* HaskellParser::Inst_declContext::tycl_hdr_inst() {
  return getRuleContext<HaskellParser::Tycl_hdr_instContext>(0);
}

HaskellParser::Capi_ctypeContext* HaskellParser::Inst_declContext::capi_ctype() {
  return getRuleContext<HaskellParser::Capi_ctypeContext>(0);
}

HaskellParser::DerivingsContext* HaskellParser::Inst_declContext::derivings() {
  return getRuleContext<HaskellParser::DerivingsContext>(0);
}

tree::TerminalNode* HaskellParser::Inst_declContext::NEWTYPE() {
  return getToken(HaskellParser::NEWTYPE, 0);
}

HaskellParser::Opt_kind_sigContext* HaskellParser::Inst_declContext::opt_kind_sig() {
  return getRuleContext<HaskellParser::Opt_kind_sigContext>(0);
}

HaskellParser::Gadt_constrlistContext* HaskellParser::Inst_declContext::gadt_constrlist() {
  return getRuleContext<HaskellParser::Gadt_constrlistContext>(0);
}


size_t HaskellParser::Inst_declContext::getRuleIndex() const {
  return HaskellParser::RuleInst_decl;
}

void HaskellParser::Inst_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInst_decl(this);
}

void HaskellParser::Inst_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInst_decl(this);
}

HaskellParser::Inst_declContext* HaskellParser::inst_decl() {
  Inst_declContext *_localctx = _tracker.createInstance<Inst_declContext>(_ctx, getState());
  enterRule(_localctx, 52, HaskellParser::RuleInst_decl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(986);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(927);
      match(HaskellParser::INSTANCE);
      setState(929);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx)) {
      case 1: {
        setState(928);
        overlap_pragma();
        break;
      }

      default:
        break;
      }
      setState(931);
      inst_type();
      setState(933);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::WHERE) {
        setState(932);
        where_inst();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(935);
      match(HaskellParser::TYPE);
      setState(936);
      match(HaskellParser::INSTANCE);
      setState(937);
      ty_fam_inst_eqn();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(938);
      match(HaskellParser::DATA);
      setState(939);
      match(HaskellParser::INSTANCE);
      setState(941);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx)) {
      case 1: {
        setState(940);
        capi_ctype();
        break;
      }

      default:
        break;
      }
      setState(943);
      tycl_hdr_inst();
      setState(945);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DERIVING) {
        setState(944);
        derivings();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(947);
      match(HaskellParser::NEWTYPE);
      setState(948);
      match(HaskellParser::INSTANCE);
      setState(950);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx)) {
      case 1: {
        setState(949);
        capi_ctype();
        break;
      }

      default:
        break;
      }
      setState(952);
      tycl_hdr_inst();
      setState(954);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DERIVING) {
        setState(953);
        derivings();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(956);
      match(HaskellParser::DATA);
      setState(957);
      match(HaskellParser::INSTANCE);
      setState(959);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx)) {
      case 1: {
        setState(958);
        capi_ctype();
        break;
      }

      default:
        break;
      }
      setState(961);
      tycl_hdr_inst();
      setState(963);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DoubleColon) {
        setState(962);
        opt_kind_sig();
      }
      setState(966);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::WHERE) {
        setState(965);
        gadt_constrlist();
      }
      setState(969);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DERIVING) {
        setState(968);
        derivings();
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(971);
      match(HaskellParser::NEWTYPE);
      setState(972);
      match(HaskellParser::INSTANCE);
      setState(974);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx)) {
      case 1: {
        setState(973);
        capi_ctype();
        break;
      }

      default:
        break;
      }
      setState(976);
      tycl_hdr_inst();
      setState(978);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DoubleColon) {
        setState(977);
        opt_kind_sig();
      }
      setState(981);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::WHERE) {
        setState(980);
        gadt_constrlist();
      }
      setState(984);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DERIVING) {
        setState(983);
        derivings();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Overlap_pragmaContext ------------------------------------------------------------------

HaskellParser::Overlap_pragmaContext::Overlap_pragmaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Overlap_pragmaContext::OpenPragmaBracket() {
  return getToken(HaskellParser::OpenPragmaBracket, 0);
}

tree::TerminalNode* HaskellParser::Overlap_pragmaContext::OVERLAPPABLE() {
  return getToken(HaskellParser::OVERLAPPABLE, 0);
}

tree::TerminalNode* HaskellParser::Overlap_pragmaContext::ClosePragmaBracket() {
  return getToken(HaskellParser::ClosePragmaBracket, 0);
}

tree::TerminalNode* HaskellParser::Overlap_pragmaContext::OVERLAPPING() {
  return getToken(HaskellParser::OVERLAPPING, 0);
}

tree::TerminalNode* HaskellParser::Overlap_pragmaContext::OVERLAPS() {
  return getToken(HaskellParser::OVERLAPS, 0);
}

tree::TerminalNode* HaskellParser::Overlap_pragmaContext::INCOHERENT() {
  return getToken(HaskellParser::INCOHERENT, 0);
}


size_t HaskellParser::Overlap_pragmaContext::getRuleIndex() const {
  return HaskellParser::RuleOverlap_pragma;
}

void HaskellParser::Overlap_pragmaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverlap_pragma(this);
}

void HaskellParser::Overlap_pragmaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverlap_pragma(this);
}

HaskellParser::Overlap_pragmaContext* HaskellParser::overlap_pragma() {
  Overlap_pragmaContext *_localctx = _tracker.createInstance<Overlap_pragmaContext>(_ctx, getState());
  enterRule(_localctx, 54, HaskellParser::RuleOverlap_pragma);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1000);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(988);
      match(HaskellParser::OpenPragmaBracket);
      setState(989);
      match(HaskellParser::OVERLAPPABLE);
      setState(990);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(991);
      match(HaskellParser::OpenPragmaBracket);
      setState(992);
      match(HaskellParser::OVERLAPPING);
      setState(993);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(994);
      match(HaskellParser::OpenPragmaBracket);
      setState(995);
      match(HaskellParser::OVERLAPS);
      setState(996);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(997);
      match(HaskellParser::OpenPragmaBracket);
      setState(998);
      match(HaskellParser::INCOHERENT);
      setState(999);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Deriv_strategy_no_viaContext ------------------------------------------------------------------

HaskellParser::Deriv_strategy_no_viaContext::Deriv_strategy_no_viaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Deriv_strategy_no_viaContext::STOCK() {
  return getToken(HaskellParser::STOCK, 0);
}

tree::TerminalNode* HaskellParser::Deriv_strategy_no_viaContext::ANYCLASS() {
  return getToken(HaskellParser::ANYCLASS, 0);
}

tree::TerminalNode* HaskellParser::Deriv_strategy_no_viaContext::NEWTYPE() {
  return getToken(HaskellParser::NEWTYPE, 0);
}


size_t HaskellParser::Deriv_strategy_no_viaContext::getRuleIndex() const {
  return HaskellParser::RuleDeriv_strategy_no_via;
}

void HaskellParser::Deriv_strategy_no_viaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeriv_strategy_no_via(this);
}

void HaskellParser::Deriv_strategy_no_viaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeriv_strategy_no_via(this);
}

HaskellParser::Deriv_strategy_no_viaContext* HaskellParser::deriv_strategy_no_via() {
  Deriv_strategy_no_viaContext *_localctx = _tracker.createInstance<Deriv_strategy_no_viaContext>(_ctx, getState());
  enterRule(_localctx, 56, HaskellParser::RuleDeriv_strategy_no_via);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1002);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 844424934326272) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Deriv_strategy_viaContext ------------------------------------------------------------------

HaskellParser::Deriv_strategy_viaContext::Deriv_strategy_viaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Deriv_strategy_viaContext::VIA() {
  return getToken(HaskellParser::VIA, 0);
}

HaskellParser::KtypeContext* HaskellParser::Deriv_strategy_viaContext::ktype() {
  return getRuleContext<HaskellParser::KtypeContext>(0);
}


size_t HaskellParser::Deriv_strategy_viaContext::getRuleIndex() const {
  return HaskellParser::RuleDeriv_strategy_via;
}

void HaskellParser::Deriv_strategy_viaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeriv_strategy_via(this);
}

void HaskellParser::Deriv_strategy_viaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeriv_strategy_via(this);
}

HaskellParser::Deriv_strategy_viaContext* HaskellParser::deriv_strategy_via() {
  Deriv_strategy_viaContext *_localctx = _tracker.createInstance<Deriv_strategy_viaContext>(_ctx, getState());
  enterRule(_localctx, 58, HaskellParser::RuleDeriv_strategy_via);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1004);
    match(HaskellParser::VIA);
    setState(1005);
    ktype();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Deriv_standalone_strategyContext ------------------------------------------------------------------

HaskellParser::Deriv_standalone_strategyContext::Deriv_standalone_strategyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Deriv_standalone_strategyContext::STOCK() {
  return getToken(HaskellParser::STOCK, 0);
}

tree::TerminalNode* HaskellParser::Deriv_standalone_strategyContext::ANYCLASS() {
  return getToken(HaskellParser::ANYCLASS, 0);
}

tree::TerminalNode* HaskellParser::Deriv_standalone_strategyContext::NEWTYPE() {
  return getToken(HaskellParser::NEWTYPE, 0);
}

HaskellParser::Deriv_strategy_viaContext* HaskellParser::Deriv_standalone_strategyContext::deriv_strategy_via() {
  return getRuleContext<HaskellParser::Deriv_strategy_viaContext>(0);
}


size_t HaskellParser::Deriv_standalone_strategyContext::getRuleIndex() const {
  return HaskellParser::RuleDeriv_standalone_strategy;
}

void HaskellParser::Deriv_standalone_strategyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeriv_standalone_strategy(this);
}

void HaskellParser::Deriv_standalone_strategyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeriv_standalone_strategy(this);
}

HaskellParser::Deriv_standalone_strategyContext* HaskellParser::deriv_standalone_strategy() {
  Deriv_standalone_strategyContext *_localctx = _tracker.createInstance<Deriv_standalone_strategyContext>(_ctx, getState());
  enterRule(_localctx, 60, HaskellParser::RuleDeriv_standalone_strategy);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1011);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::STOCK: {
        enterOuterAlt(_localctx, 1);
        setState(1007);
        match(HaskellParser::STOCK);
        break;
      }

      case HaskellParser::ANYCLASS: {
        enterOuterAlt(_localctx, 2);
        setState(1008);
        match(HaskellParser::ANYCLASS);
        break;
      }

      case HaskellParser::NEWTYPE: {
        enterOuterAlt(_localctx, 3);
        setState(1009);
        match(HaskellParser::NEWTYPE);
        break;
      }

      case HaskellParser::VIA: {
        enterOuterAlt(_localctx, 4);
        setState(1010);
        deriv_strategy_via();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_injective_infoContext ------------------------------------------------------------------

HaskellParser::Opt_injective_infoContext::Opt_injective_infoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Opt_injective_infoContext::Pipe() {
  return getToken(HaskellParser::Pipe, 0);
}

HaskellParser::Injectivity_condContext* HaskellParser::Opt_injective_infoContext::injectivity_cond() {
  return getRuleContext<HaskellParser::Injectivity_condContext>(0);
}


size_t HaskellParser::Opt_injective_infoContext::getRuleIndex() const {
  return HaskellParser::RuleOpt_injective_info;
}

void HaskellParser::Opt_injective_infoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_injective_info(this);
}

void HaskellParser::Opt_injective_infoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_injective_info(this);
}

HaskellParser::Opt_injective_infoContext* HaskellParser::opt_injective_info() {
  Opt_injective_infoContext *_localctx = _tracker.createInstance<Opt_injective_infoContext>(_ctx, getState());
  enterRule(_localctx, 62, HaskellParser::RuleOpt_injective_info);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1013);
    match(HaskellParser::Pipe);
    setState(1014);
    injectivity_cond();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Injectivity_condContext ------------------------------------------------------------------

HaskellParser::Injectivity_condContext::Injectivity_condContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::TyvaridContext* HaskellParser::Injectivity_condContext::tyvarid() {
  return getRuleContext<HaskellParser::TyvaridContext>(0);
}

tree::TerminalNode* HaskellParser::Injectivity_condContext::Arrow() {
  return getToken(HaskellParser::Arrow, 0);
}

HaskellParser::Inj_varidsContext* HaskellParser::Injectivity_condContext::inj_varids() {
  return getRuleContext<HaskellParser::Inj_varidsContext>(0);
}


size_t HaskellParser::Injectivity_condContext::getRuleIndex() const {
  return HaskellParser::RuleInjectivity_cond;
}

void HaskellParser::Injectivity_condContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInjectivity_cond(this);
}

void HaskellParser::Injectivity_condContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInjectivity_cond(this);
}

HaskellParser::Injectivity_condContext* HaskellParser::injectivity_cond() {
  Injectivity_condContext *_localctx = _tracker.createInstance<Injectivity_condContext>(_ctx, getState());
  enterRule(_localctx, 64, HaskellParser::RuleInjectivity_cond);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1016);
    tyvarid();
    setState(1017);
    match(HaskellParser::Arrow);
    setState(1018);
    inj_varids();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inj_varidsContext ------------------------------------------------------------------

HaskellParser::Inj_varidsContext::Inj_varidsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::TyvaridContext *> HaskellParser::Inj_varidsContext::tyvarid() {
  return getRuleContexts<HaskellParser::TyvaridContext>();
}

HaskellParser::TyvaridContext* HaskellParser::Inj_varidsContext::tyvarid(size_t i) {
  return getRuleContext<HaskellParser::TyvaridContext>(i);
}


size_t HaskellParser::Inj_varidsContext::getRuleIndex() const {
  return HaskellParser::RuleInj_varids;
}

void HaskellParser::Inj_varidsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInj_varids(this);
}

void HaskellParser::Inj_varidsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInj_varids(this);
}

HaskellParser::Inj_varidsContext* HaskellParser::inj_varids() {
  Inj_varidsContext *_localctx = _tracker.createInstance<Inj_varidsContext>(_ctx, getState());
  enterRule(_localctx, 66, HaskellParser::RuleInj_varids);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1021); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1020);
      tyvarid();
      setState(1023); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1976679257870352) != 0) || _la == HaskellParser::VARID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Where_type_familyContext ------------------------------------------------------------------

HaskellParser::Where_type_familyContext::Where_type_familyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Where_type_familyContext::WHERE() {
  return getToken(HaskellParser::WHERE, 0);
}

HaskellParser::Ty_fam_inst_eqn_listContext* HaskellParser::Where_type_familyContext::ty_fam_inst_eqn_list() {
  return getRuleContext<HaskellParser::Ty_fam_inst_eqn_listContext>(0);
}


size_t HaskellParser::Where_type_familyContext::getRuleIndex() const {
  return HaskellParser::RuleWhere_type_family;
}

void HaskellParser::Where_type_familyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhere_type_family(this);
}

void HaskellParser::Where_type_familyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhere_type_family(this);
}

HaskellParser::Where_type_familyContext* HaskellParser::where_type_family() {
  Where_type_familyContext *_localctx = _tracker.createInstance<Where_type_familyContext>(_ctx, getState());
  enterRule(_localctx, 68, HaskellParser::RuleWhere_type_family);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1025);
    match(HaskellParser::WHERE);
    setState(1026);
    ty_fam_inst_eqn_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ty_fam_inst_eqn_listContext ------------------------------------------------------------------

HaskellParser::Ty_fam_inst_eqn_listContext::Ty_fam_inst_eqn_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Open_Context* HaskellParser::Ty_fam_inst_eqn_listContext::open_() {
  return getRuleContext<HaskellParser::Open_Context>(0);
}

HaskellParser::CloseContext* HaskellParser::Ty_fam_inst_eqn_listContext::close() {
  return getRuleContext<HaskellParser::CloseContext>(0);
}

HaskellParser::Ty_fam_inst_eqnsContext* HaskellParser::Ty_fam_inst_eqn_listContext::ty_fam_inst_eqns() {
  return getRuleContext<HaskellParser::Ty_fam_inst_eqnsContext>(0);
}

tree::TerminalNode* HaskellParser::Ty_fam_inst_eqn_listContext::OCURLY() {
  return getToken(HaskellParser::OCURLY, 0);
}

tree::TerminalNode* HaskellParser::Ty_fam_inst_eqn_listContext::DoubleDot() {
  return getToken(HaskellParser::DoubleDot, 0);
}

tree::TerminalNode* HaskellParser::Ty_fam_inst_eqn_listContext::CCURLY() {
  return getToken(HaskellParser::CCURLY, 0);
}


size_t HaskellParser::Ty_fam_inst_eqn_listContext::getRuleIndex() const {
  return HaskellParser::RuleTy_fam_inst_eqn_list;
}

void HaskellParser::Ty_fam_inst_eqn_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTy_fam_inst_eqn_list(this);
}

void HaskellParser::Ty_fam_inst_eqn_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTy_fam_inst_eqn_list(this);
}

HaskellParser::Ty_fam_inst_eqn_listContext* HaskellParser::ty_fam_inst_eqn_list() {
  Ty_fam_inst_eqn_listContext *_localctx = _tracker.createInstance<Ty_fam_inst_eqn_listContext>(_ctx, getState());
  enterRule(_localctx, 70, HaskellParser::RuleTy_fam_inst_eqn_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1041);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1028);
      open_();
      setState(1030);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 1976649998405648) != 0) || ((((_la - 82) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 82)) & 253460863659982847) != 0)) {
        setState(1029);
        ty_fam_inst_eqns();
      }
      setState(1032);
      close();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1034);
      match(HaskellParser::OCURLY);
      setState(1035);
      match(HaskellParser::DoubleDot);
      setState(1036);
      match(HaskellParser::CCURLY);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1037);
      open_();
      setState(1038);
      match(HaskellParser::DoubleDot);
      setState(1039);
      close();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ty_fam_inst_eqnsContext ------------------------------------------------------------------

HaskellParser::Ty_fam_inst_eqnsContext::Ty_fam_inst_eqnsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::Ty_fam_inst_eqnContext *> HaskellParser::Ty_fam_inst_eqnsContext::ty_fam_inst_eqn() {
  return getRuleContexts<HaskellParser::Ty_fam_inst_eqnContext>();
}

HaskellParser::Ty_fam_inst_eqnContext* HaskellParser::Ty_fam_inst_eqnsContext::ty_fam_inst_eqn(size_t i) {
  return getRuleContext<HaskellParser::Ty_fam_inst_eqnContext>(i);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::Ty_fam_inst_eqnsContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::Ty_fam_inst_eqnsContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::Ty_fam_inst_eqnsContext::getRuleIndex() const {
  return HaskellParser::RuleTy_fam_inst_eqns;
}

void HaskellParser::Ty_fam_inst_eqnsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTy_fam_inst_eqns(this);
}

void HaskellParser::Ty_fam_inst_eqnsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTy_fam_inst_eqns(this);
}

HaskellParser::Ty_fam_inst_eqnsContext* HaskellParser::ty_fam_inst_eqns() {
  Ty_fam_inst_eqnsContext *_localctx = _tracker.createInstance<Ty_fam_inst_eqnsContext>(_ctx, getState());
  enterRule(_localctx, 72, HaskellParser::RuleTy_fam_inst_eqns);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1043);
    ty_fam_inst_eqn();
    setState(1053);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1045); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(1044);
          semi();
          setState(1047); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == HaskellParser::Semi

        || _la == HaskellParser::SEMI);
        setState(1049);
        ty_fam_inst_eqn(); 
      }
      setState(1055);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx);
    }
    setState(1059);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Semi

    || _la == HaskellParser::SEMI) {
      setState(1056);
      semi();
      setState(1061);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ty_fam_inst_eqnContext ------------------------------------------------------------------

HaskellParser::Ty_fam_inst_eqnContext::Ty_fam_inst_eqnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Ty_fam_inst_eqnContext::FORALL() {
  return getToken(HaskellParser::FORALL, 0);
}

tree::TerminalNode* HaskellParser::Ty_fam_inst_eqnContext::Dot() {
  return getToken(HaskellParser::Dot, 0);
}

HaskellParser::Type_Context* HaskellParser::Ty_fam_inst_eqnContext::type_() {
  return getRuleContext<HaskellParser::Type_Context>(0);
}

tree::TerminalNode* HaskellParser::Ty_fam_inst_eqnContext::Eq() {
  return getToken(HaskellParser::Eq, 0);
}

HaskellParser::KtypeContext* HaskellParser::Ty_fam_inst_eqnContext::ktype() {
  return getRuleContext<HaskellParser::KtypeContext>(0);
}

HaskellParser::Tv_bndrsContext* HaskellParser::Ty_fam_inst_eqnContext::tv_bndrs() {
  return getRuleContext<HaskellParser::Tv_bndrsContext>(0);
}


size_t HaskellParser::Ty_fam_inst_eqnContext::getRuleIndex() const {
  return HaskellParser::RuleTy_fam_inst_eqn;
}

void HaskellParser::Ty_fam_inst_eqnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTy_fam_inst_eqn(this);
}

void HaskellParser::Ty_fam_inst_eqnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTy_fam_inst_eqn(this);
}

HaskellParser::Ty_fam_inst_eqnContext* HaskellParser::ty_fam_inst_eqn() {
  Ty_fam_inst_eqnContext *_localctx = _tracker.createInstance<Ty_fam_inst_eqnContext>(_ctx, getState());
  enterRule(_localctx, 74, HaskellParser::RuleTy_fam_inst_eqn);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1075);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::FORALL: {
        enterOuterAlt(_localctx, 1);
        setState(1062);
        match(HaskellParser::FORALL);
        setState(1064);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 1976649193099280) != 0) || ((((_la - 120) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 120)) & 4161) != 0)) {
          setState(1063);
          tv_bndrs();
        }
        setState(1066);
        match(HaskellParser::Dot);
        setState(1067);
        type_();
        setState(1068);
        match(HaskellParser::Eq);
        setState(1069);
        ktype();
        break;
      }

      case HaskellParser::AS:
      case HaskellParser::HIDING:
      case HaskellParser::QUALIFIED:
      case HaskellParser::WILDCARD:
      case HaskellParser::EXPORT:
      case HaskellParser::STDCALL:
      case HaskellParser::CCALL:
      case HaskellParser::CAPI:
      case HaskellParser::JSCALL:
      case HaskellParser::STOCK:
      case HaskellParser::ANYCLASS:
      case HaskellParser::VIA:
      case HaskellParser::Hash:
      case HaskellParser::Less:
      case HaskellParser::Greater:
      case HaskellParser::Ampersand:
      case HaskellParser::Pipe:
      case HaskellParser::Bang:
      case HaskellParser::Caret:
      case HaskellParser::Plus:
      case HaskellParser::Minus:
      case HaskellParser::Asterisk:
      case HaskellParser::Percent:
      case HaskellParser::Divide:
      case HaskellParser::Tilde:
      case HaskellParser::Atsign:
      case HaskellParser::Dollar:
      case HaskellParser::Dot:
      case HaskellParser::QuestionMark:
      case HaskellParser::Colon:
      case HaskellParser::Eq:
      case HaskellParser::Quote:
      case HaskellParser::ReverseSlash:
      case HaskellParser::BackQuote:
      case HaskellParser::OpenBoxParen:
      case HaskellParser::OpenRoundBracket:
      case HaskellParser::OpenSquareBracket:
      case HaskellParser::STRING:
      case HaskellParser::VARID:
      case HaskellParser::CONID:
      case HaskellParser::OpenPragmaBracket:
      case HaskellParser::OCURLY:
      case HaskellParser::DECIMAL:
      case HaskellParser::OCTAL:
      case HaskellParser::HEXADECIMAL: {
        enterOuterAlt(_localctx, 2);
        setState(1071);
        type_();
        setState(1072);
        match(HaskellParser::Eq);
        setState(1073);
        ktype();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- At_decl_clsContext ------------------------------------------------------------------

HaskellParser::At_decl_clsContext::At_decl_clsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::At_decl_clsContext::DATA() {
  return getToken(HaskellParser::DATA, 0);
}

HaskellParser::Type_Context* HaskellParser::At_decl_clsContext::type_() {
  return getRuleContext<HaskellParser::Type_Context>(0);
}

tree::TerminalNode* HaskellParser::At_decl_clsContext::FAMILY() {
  return getToken(HaskellParser::FAMILY, 0);
}

HaskellParser::Opt_datafam_kind_sigContext* HaskellParser::At_decl_clsContext::opt_datafam_kind_sig() {
  return getRuleContext<HaskellParser::Opt_datafam_kind_sigContext>(0);
}

tree::TerminalNode* HaskellParser::At_decl_clsContext::TYPE() {
  return getToken(HaskellParser::TYPE, 0);
}

HaskellParser::Opt_at_kind_inj_sigContext* HaskellParser::At_decl_clsContext::opt_at_kind_inj_sig() {
  return getRuleContext<HaskellParser::Opt_at_kind_inj_sigContext>(0);
}

HaskellParser::Ty_fam_inst_eqnContext* HaskellParser::At_decl_clsContext::ty_fam_inst_eqn() {
  return getRuleContext<HaskellParser::Ty_fam_inst_eqnContext>(0);
}

tree::TerminalNode* HaskellParser::At_decl_clsContext::INSTANCE() {
  return getToken(HaskellParser::INSTANCE, 0);
}


size_t HaskellParser::At_decl_clsContext::getRuleIndex() const {
  return HaskellParser::RuleAt_decl_cls;
}

void HaskellParser::At_decl_clsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAt_decl_cls(this);
}

void HaskellParser::At_decl_clsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAt_decl_cls(this);
}

HaskellParser::At_decl_clsContext* HaskellParser::at_decl_cls() {
  At_decl_clsContext *_localctx = _tracker.createInstance<At_decl_clsContext>(_ctx, getState());
  enterRule(_localctx, 76, HaskellParser::RuleAt_decl_cls);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1098);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1077);
      match(HaskellParser::DATA);
      setState(1079);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::FAMILY) {
        setState(1078);
        match(HaskellParser::FAMILY);
      }
      setState(1081);
      type_();
      setState(1083);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DoubleColon) {
        setState(1082);
        opt_datafam_kind_sig();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1085);
      match(HaskellParser::TYPE);
      setState(1087);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::FAMILY) {
        setState(1086);
        match(HaskellParser::FAMILY);
      }
      setState(1089);
      type_();
      setState(1091);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DoubleColon

      || _la == HaskellParser::Eq) {
        setState(1090);
        opt_at_kind_inj_sig();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1093);
      match(HaskellParser::TYPE);
      setState(1095);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::INSTANCE) {
        setState(1094);
        match(HaskellParser::INSTANCE);
      }
      setState(1097);
      ty_fam_inst_eqn();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- At_decl_instContext ------------------------------------------------------------------

HaskellParser::At_decl_instContext::At_decl_instContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::At_decl_instContext::TYPE() {
  return getToken(HaskellParser::TYPE, 0);
}

HaskellParser::Ty_fam_inst_eqnContext* HaskellParser::At_decl_instContext::ty_fam_inst_eqn() {
  return getRuleContext<HaskellParser::Ty_fam_inst_eqnContext>(0);
}

tree::TerminalNode* HaskellParser::At_decl_instContext::INSTANCE() {
  return getToken(HaskellParser::INSTANCE, 0);
}

tree::TerminalNode* HaskellParser::At_decl_instContext::DATA() {
  return getToken(HaskellParser::DATA, 0);
}

HaskellParser::Tycl_hdr_instContext* HaskellParser::At_decl_instContext::tycl_hdr_inst() {
  return getRuleContext<HaskellParser::Tycl_hdr_instContext>(0);
}

HaskellParser::ConstrsContext* HaskellParser::At_decl_instContext::constrs() {
  return getRuleContext<HaskellParser::ConstrsContext>(0);
}

HaskellParser::Capi_ctypeContext* HaskellParser::At_decl_instContext::capi_ctype() {
  return getRuleContext<HaskellParser::Capi_ctypeContext>(0);
}

HaskellParser::DerivingsContext* HaskellParser::At_decl_instContext::derivings() {
  return getRuleContext<HaskellParser::DerivingsContext>(0);
}

tree::TerminalNode* HaskellParser::At_decl_instContext::NEWTYPE() {
  return getToken(HaskellParser::NEWTYPE, 0);
}

HaskellParser::Opt_kind_sigContext* HaskellParser::At_decl_instContext::opt_kind_sig() {
  return getRuleContext<HaskellParser::Opt_kind_sigContext>(0);
}

HaskellParser::Gadt_constrlistContext* HaskellParser::At_decl_instContext::gadt_constrlist() {
  return getRuleContext<HaskellParser::Gadt_constrlistContext>(0);
}


size_t HaskellParser::At_decl_instContext::getRuleIndex() const {
  return HaskellParser::RuleAt_decl_inst;
}

void HaskellParser::At_decl_instContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAt_decl_inst(this);
}

void HaskellParser::At_decl_instContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAt_decl_inst(this);
}

HaskellParser::At_decl_instContext* HaskellParser::at_decl_inst() {
  At_decl_instContext *_localctx = _tracker.createInstance<At_decl_instContext>(_ctx, getState());
  enterRule(_localctx, 78, HaskellParser::RuleAt_decl_inst);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1163);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1100);
      match(HaskellParser::TYPE);
      setState(1102);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::INSTANCE) {
        setState(1101);
        match(HaskellParser::INSTANCE);
      }
      setState(1104);
      ty_fam_inst_eqn();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1105);
      match(HaskellParser::DATA);
      setState(1107);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::INSTANCE) {
        setState(1106);
        match(HaskellParser::INSTANCE);
      }
      setState(1110);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 112, _ctx)) {
      case 1: {
        setState(1109);
        capi_ctype();
        break;
      }

      default:
        break;
      }
      setState(1112);
      tycl_hdr_inst();
      setState(1113);
      constrs();
      setState(1115);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DERIVING) {
        setState(1114);
        derivings();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1117);
      match(HaskellParser::NEWTYPE);
      setState(1119);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::INSTANCE) {
        setState(1118);
        match(HaskellParser::INSTANCE);
      }
      setState(1122);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx)) {
      case 1: {
        setState(1121);
        capi_ctype();
        break;
      }

      default:
        break;
      }
      setState(1124);
      tycl_hdr_inst();
      setState(1125);
      constrs();
      setState(1127);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DERIVING) {
        setState(1126);
        derivings();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1129);
      match(HaskellParser::DATA);
      setState(1131);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::INSTANCE) {
        setState(1130);
        match(HaskellParser::INSTANCE);
      }
      setState(1134);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx)) {
      case 1: {
        setState(1133);
        capi_ctype();
        break;
      }

      default:
        break;
      }
      setState(1136);
      tycl_hdr_inst();
      setState(1138);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DoubleColon) {
        setState(1137);
        opt_kind_sig();
      }
      setState(1141);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::WHERE) {
        setState(1140);
        gadt_constrlist();
      }
      setState(1144);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DERIVING) {
        setState(1143);
        derivings();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1146);
      match(HaskellParser::NEWTYPE);
      setState(1148);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::INSTANCE) {
        setState(1147);
        match(HaskellParser::INSTANCE);
      }
      setState(1151);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx)) {
      case 1: {
        setState(1150);
        capi_ctype();
        break;
      }

      default:
        break;
      }
      setState(1153);
      tycl_hdr_inst();
      setState(1155);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DoubleColon) {
        setState(1154);
        opt_kind_sig();
      }
      setState(1158);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::WHERE) {
        setState(1157);
        gadt_constrlist();
      }
      setState(1161);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DERIVING) {
        setState(1160);
        derivings();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_kind_sigContext ------------------------------------------------------------------

HaskellParser::Opt_kind_sigContext::Opt_kind_sigContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Opt_kind_sigContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::KindContext* HaskellParser::Opt_kind_sigContext::kind() {
  return getRuleContext<HaskellParser::KindContext>(0);
}


size_t HaskellParser::Opt_kind_sigContext::getRuleIndex() const {
  return HaskellParser::RuleOpt_kind_sig;
}

void HaskellParser::Opt_kind_sigContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_kind_sig(this);
}

void HaskellParser::Opt_kind_sigContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_kind_sig(this);
}

HaskellParser::Opt_kind_sigContext* HaskellParser::opt_kind_sig() {
  Opt_kind_sigContext *_localctx = _tracker.createInstance<Opt_kind_sigContext>(_ctx, getState());
  enterRule(_localctx, 80, HaskellParser::RuleOpt_kind_sig);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1165);
    match(HaskellParser::DoubleColon);
    setState(1166);
    kind();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_datafam_kind_sigContext ------------------------------------------------------------------

HaskellParser::Opt_datafam_kind_sigContext::Opt_datafam_kind_sigContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Opt_datafam_kind_sigContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::KindContext* HaskellParser::Opt_datafam_kind_sigContext::kind() {
  return getRuleContext<HaskellParser::KindContext>(0);
}


size_t HaskellParser::Opt_datafam_kind_sigContext::getRuleIndex() const {
  return HaskellParser::RuleOpt_datafam_kind_sig;
}

void HaskellParser::Opt_datafam_kind_sigContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_datafam_kind_sig(this);
}

void HaskellParser::Opt_datafam_kind_sigContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_datafam_kind_sig(this);
}

HaskellParser::Opt_datafam_kind_sigContext* HaskellParser::opt_datafam_kind_sig() {
  Opt_datafam_kind_sigContext *_localctx = _tracker.createInstance<Opt_datafam_kind_sigContext>(_ctx, getState());
  enterRule(_localctx, 82, HaskellParser::RuleOpt_datafam_kind_sig);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1168);
    match(HaskellParser::DoubleColon);
    setState(1169);
    kind();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_tyfam_kind_sigContext ------------------------------------------------------------------

HaskellParser::Opt_tyfam_kind_sigContext::Opt_tyfam_kind_sigContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Opt_tyfam_kind_sigContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::KindContext* HaskellParser::Opt_tyfam_kind_sigContext::kind() {
  return getRuleContext<HaskellParser::KindContext>(0);
}

tree::TerminalNode* HaskellParser::Opt_tyfam_kind_sigContext::Eq() {
  return getToken(HaskellParser::Eq, 0);
}

HaskellParser::Tv_bndrContext* HaskellParser::Opt_tyfam_kind_sigContext::tv_bndr() {
  return getRuleContext<HaskellParser::Tv_bndrContext>(0);
}


size_t HaskellParser::Opt_tyfam_kind_sigContext::getRuleIndex() const {
  return HaskellParser::RuleOpt_tyfam_kind_sig;
}

void HaskellParser::Opt_tyfam_kind_sigContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_tyfam_kind_sig(this);
}

void HaskellParser::Opt_tyfam_kind_sigContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_tyfam_kind_sig(this);
}

HaskellParser::Opt_tyfam_kind_sigContext* HaskellParser::opt_tyfam_kind_sig() {
  Opt_tyfam_kind_sigContext *_localctx = _tracker.createInstance<Opt_tyfam_kind_sigContext>(_ctx, getState());
  enterRule(_localctx, 84, HaskellParser::RuleOpt_tyfam_kind_sig);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1175);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::DoubleColon: {
        enterOuterAlt(_localctx, 1);
        setState(1171);
        match(HaskellParser::DoubleColon);
        setState(1172);
        kind();
        break;
      }

      case HaskellParser::Eq: {
        enterOuterAlt(_localctx, 2);
        setState(1173);
        match(HaskellParser::Eq);
        setState(1174);
        tv_bndr();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_at_kind_inj_sigContext ------------------------------------------------------------------

HaskellParser::Opt_at_kind_inj_sigContext::Opt_at_kind_inj_sigContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Opt_at_kind_inj_sigContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::KindContext* HaskellParser::Opt_at_kind_inj_sigContext::kind() {
  return getRuleContext<HaskellParser::KindContext>(0);
}

tree::TerminalNode* HaskellParser::Opt_at_kind_inj_sigContext::Eq() {
  return getToken(HaskellParser::Eq, 0);
}

HaskellParser::Tv_bndr_no_bracesContext* HaskellParser::Opt_at_kind_inj_sigContext::tv_bndr_no_braces() {
  return getRuleContext<HaskellParser::Tv_bndr_no_bracesContext>(0);
}

tree::TerminalNode* HaskellParser::Opt_at_kind_inj_sigContext::Pipe() {
  return getToken(HaskellParser::Pipe, 0);
}

HaskellParser::Injectivity_condContext* HaskellParser::Opt_at_kind_inj_sigContext::injectivity_cond() {
  return getRuleContext<HaskellParser::Injectivity_condContext>(0);
}


size_t HaskellParser::Opt_at_kind_inj_sigContext::getRuleIndex() const {
  return HaskellParser::RuleOpt_at_kind_inj_sig;
}

void HaskellParser::Opt_at_kind_inj_sigContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_at_kind_inj_sig(this);
}

void HaskellParser::Opt_at_kind_inj_sigContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_at_kind_inj_sig(this);
}

HaskellParser::Opt_at_kind_inj_sigContext* HaskellParser::opt_at_kind_inj_sig() {
  Opt_at_kind_inj_sigContext *_localctx = _tracker.createInstance<Opt_at_kind_inj_sigContext>(_ctx, getState());
  enterRule(_localctx, 86, HaskellParser::RuleOpt_at_kind_inj_sig);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1184);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::DoubleColon: {
        enterOuterAlt(_localctx, 1);
        setState(1177);
        match(HaskellParser::DoubleColon);
        setState(1178);
        kind();
        break;
      }

      case HaskellParser::Eq: {
        enterOuterAlt(_localctx, 2);
        setState(1179);
        match(HaskellParser::Eq);
        setState(1180);
        tv_bndr_no_braces();
        setState(1181);
        match(HaskellParser::Pipe);
        setState(1182);
        injectivity_cond();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tycl_hdrContext ------------------------------------------------------------------

HaskellParser::Tycl_hdrContext::Tycl_hdrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Tycl_contextContext* HaskellParser::Tycl_hdrContext::tycl_context() {
  return getRuleContext<HaskellParser::Tycl_contextContext>(0);
}

tree::TerminalNode* HaskellParser::Tycl_hdrContext::DoubleArrow() {
  return getToken(HaskellParser::DoubleArrow, 0);
}

HaskellParser::Type_Context* HaskellParser::Tycl_hdrContext::type_() {
  return getRuleContext<HaskellParser::Type_Context>(0);
}


size_t HaskellParser::Tycl_hdrContext::getRuleIndex() const {
  return HaskellParser::RuleTycl_hdr;
}

void HaskellParser::Tycl_hdrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTycl_hdr(this);
}

void HaskellParser::Tycl_hdrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTycl_hdr(this);
}

HaskellParser::Tycl_hdrContext* HaskellParser::tycl_hdr() {
  Tycl_hdrContext *_localctx = _tracker.createInstance<Tycl_hdrContext>(_ctx, getState());
  enterRule(_localctx, 88, HaskellParser::RuleTycl_hdr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1191);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 130, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1186);
      tycl_context();
      setState(1187);
      match(HaskellParser::DoubleArrow);
      setState(1188);
      type_();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1190);
      type_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tycl_hdr_instContext ------------------------------------------------------------------

HaskellParser::Tycl_hdr_instContext::Tycl_hdr_instContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Tycl_hdr_instContext::FORALL() {
  return getToken(HaskellParser::FORALL, 0);
}

tree::TerminalNode* HaskellParser::Tycl_hdr_instContext::Dot() {
  return getToken(HaskellParser::Dot, 0);
}

HaskellParser::Tycl_contextContext* HaskellParser::Tycl_hdr_instContext::tycl_context() {
  return getRuleContext<HaskellParser::Tycl_contextContext>(0);
}

tree::TerminalNode* HaskellParser::Tycl_hdr_instContext::DoubleArrow() {
  return getToken(HaskellParser::DoubleArrow, 0);
}

HaskellParser::Type_Context* HaskellParser::Tycl_hdr_instContext::type_() {
  return getRuleContext<HaskellParser::Type_Context>(0);
}

HaskellParser::Tv_bndrsContext* HaskellParser::Tycl_hdr_instContext::tv_bndrs() {
  return getRuleContext<HaskellParser::Tv_bndrsContext>(0);
}


size_t HaskellParser::Tycl_hdr_instContext::getRuleIndex() const {
  return HaskellParser::RuleTycl_hdr_inst;
}

void HaskellParser::Tycl_hdr_instContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTycl_hdr_inst(this);
}

void HaskellParser::Tycl_hdr_instContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTycl_hdr_inst(this);
}

HaskellParser::Tycl_hdr_instContext* HaskellParser::tycl_hdr_inst() {
  Tycl_hdr_instContext *_localctx = _tracker.createInstance<Tycl_hdr_instContext>(_ctx, getState());
  enterRule(_localctx, 90, HaskellParser::RuleTycl_hdr_inst);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1213);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 133, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1193);
      match(HaskellParser::FORALL);
      setState(1195);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 1976649193099280) != 0) || ((((_la - 120) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 120)) & 4161) != 0)) {
        setState(1194);
        tv_bndrs();
      }
      setState(1197);
      match(HaskellParser::Dot);
      setState(1198);
      tycl_context();
      setState(1199);
      match(HaskellParser::DoubleArrow);
      setState(1200);
      type_();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1202);
      match(HaskellParser::FORALL);
      setState(1204);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 1976649193099280) != 0) || ((((_la - 120) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 120)) & 4161) != 0)) {
        setState(1203);
        tv_bndrs();
      }
      setState(1206);
      match(HaskellParser::Dot);
      setState(1207);
      type_();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1208);
      tycl_context();
      setState(1209);
      match(HaskellParser::DoubleArrow);
      setState(1210);
      type_();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1212);
      type_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Capi_ctypeContext ------------------------------------------------------------------

HaskellParser::Capi_ctypeContext::Capi_ctypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Capi_ctypeContext::OpenPragmaBracket() {
  return getToken(HaskellParser::OpenPragmaBracket, 0);
}

tree::TerminalNode* HaskellParser::Capi_ctypeContext::CTYPE() {
  return getToken(HaskellParser::CTYPE, 0);
}

std::vector<tree::TerminalNode *> HaskellParser::Capi_ctypeContext::STRING() {
  return getTokens(HaskellParser::STRING);
}

tree::TerminalNode* HaskellParser::Capi_ctypeContext::STRING(size_t i) {
  return getToken(HaskellParser::STRING, i);
}

tree::TerminalNode* HaskellParser::Capi_ctypeContext::ClosePragmaBracket() {
  return getToken(HaskellParser::ClosePragmaBracket, 0);
}


size_t HaskellParser::Capi_ctypeContext::getRuleIndex() const {
  return HaskellParser::RuleCapi_ctype;
}

void HaskellParser::Capi_ctypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCapi_ctype(this);
}

void HaskellParser::Capi_ctypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCapi_ctype(this);
}

HaskellParser::Capi_ctypeContext* HaskellParser::capi_ctype() {
  Capi_ctypeContext *_localctx = _tracker.createInstance<Capi_ctypeContext>(_ctx, getState());
  enterRule(_localctx, 92, HaskellParser::RuleCapi_ctype);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1224);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 134, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1215);
      match(HaskellParser::OpenPragmaBracket);
      setState(1216);
      match(HaskellParser::CTYPE);
      setState(1217);
      match(HaskellParser::STRING);
      setState(1218);
      match(HaskellParser::STRING);
      setState(1219);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1220);
      match(HaskellParser::OpenPragmaBracket);
      setState(1221);
      match(HaskellParser::CTYPE);
      setState(1222);
      match(HaskellParser::STRING);
      setState(1223);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Standalone_derivingContext ------------------------------------------------------------------

HaskellParser::Standalone_derivingContext::Standalone_derivingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Standalone_derivingContext::DERIVING() {
  return getToken(HaskellParser::DERIVING, 0);
}

tree::TerminalNode* HaskellParser::Standalone_derivingContext::INSTANCE() {
  return getToken(HaskellParser::INSTANCE, 0);
}

HaskellParser::Inst_typeContext* HaskellParser::Standalone_derivingContext::inst_type() {
  return getRuleContext<HaskellParser::Inst_typeContext>(0);
}

HaskellParser::Deriv_standalone_strategyContext* HaskellParser::Standalone_derivingContext::deriv_standalone_strategy() {
  return getRuleContext<HaskellParser::Deriv_standalone_strategyContext>(0);
}

HaskellParser::Overlap_pragmaContext* HaskellParser::Standalone_derivingContext::overlap_pragma() {
  return getRuleContext<HaskellParser::Overlap_pragmaContext>(0);
}


size_t HaskellParser::Standalone_derivingContext::getRuleIndex() const {
  return HaskellParser::RuleStandalone_deriving;
}

void HaskellParser::Standalone_derivingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStandalone_deriving(this);
}

void HaskellParser::Standalone_derivingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStandalone_deriving(this);
}

HaskellParser::Standalone_derivingContext* HaskellParser::standalone_deriving() {
  Standalone_derivingContext *_localctx = _tracker.createInstance<Standalone_derivingContext>(_ctx, getState());
  enterRule(_localctx, 94, HaskellParser::RuleStandalone_deriving);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1226);
    match(HaskellParser::DERIVING);
    setState(1228);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1970324841168896) != 0)) {
      setState(1227);
      deriv_standalone_strategy();
    }
    setState(1230);
    match(HaskellParser::INSTANCE);
    setState(1232);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx)) {
    case 1: {
      setState(1231);
      overlap_pragma();
      break;
    }

    default:
      break;
    }
    setState(1234);
    inst_type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Role_annotContext ------------------------------------------------------------------

HaskellParser::Role_annotContext::Role_annotContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Role_annotContext::TYPE() {
  return getToken(HaskellParser::TYPE, 0);
}

tree::TerminalNode* HaskellParser::Role_annotContext::ROLE() {
  return getToken(HaskellParser::ROLE, 0);
}

HaskellParser::OqtyconContext* HaskellParser::Role_annotContext::oqtycon() {
  return getRuleContext<HaskellParser::OqtyconContext>(0);
}

HaskellParser::RolesContext* HaskellParser::Role_annotContext::roles() {
  return getRuleContext<HaskellParser::RolesContext>(0);
}


size_t HaskellParser::Role_annotContext::getRuleIndex() const {
  return HaskellParser::RuleRole_annot;
}

void HaskellParser::Role_annotContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRole_annot(this);
}

void HaskellParser::Role_annotContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRole_annot(this);
}

HaskellParser::Role_annotContext* HaskellParser::role_annot() {
  Role_annotContext *_localctx = _tracker.createInstance<Role_annotContext>(_ctx, getState());
  enterRule(_localctx, 96, HaskellParser::RuleRole_annot);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1236);
    match(HaskellParser::TYPE);
    setState(1237);
    match(HaskellParser::ROLE);
    setState(1238);
    oqtycon();
    setState(1240);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1976649461534736) != 0) || _la == HaskellParser::VARID) {
      setState(1239);
      roles();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RolesContext ------------------------------------------------------------------

HaskellParser::RolesContext::RolesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::RoleContext *> HaskellParser::RolesContext::role() {
  return getRuleContexts<HaskellParser::RoleContext>();
}

HaskellParser::RoleContext* HaskellParser::RolesContext::role(size_t i) {
  return getRuleContext<HaskellParser::RoleContext>(i);
}


size_t HaskellParser::RolesContext::getRuleIndex() const {
  return HaskellParser::RuleRoles;
}

void HaskellParser::RolesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoles(this);
}

void HaskellParser::RolesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoles(this);
}

HaskellParser::RolesContext* HaskellParser::roles() {
  RolesContext *_localctx = _tracker.createInstance<RolesContext>(_ctx, getState());
  enterRule(_localctx, 98, HaskellParser::RuleRoles);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1243); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1242);
      role();
      setState(1245); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1976649461534736) != 0) || _la == HaskellParser::VARID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleContext ------------------------------------------------------------------

HaskellParser::RoleContext::RoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::VaridContext* HaskellParser::RoleContext::varid() {
  return getRuleContext<HaskellParser::VaridContext>(0);
}

tree::TerminalNode* HaskellParser::RoleContext::WILDCARD() {
  return getToken(HaskellParser::WILDCARD, 0);
}


size_t HaskellParser::RoleContext::getRuleIndex() const {
  return HaskellParser::RuleRole;
}

void HaskellParser::RoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRole(this);
}

void HaskellParser::RoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRole(this);
}

HaskellParser::RoleContext* HaskellParser::role() {
  RoleContext *_localctx = _tracker.createInstance<RoleContext>(_ctx, getState());
  enterRule(_localctx, 100, HaskellParser::RuleRole);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1249);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::AS:
      case HaskellParser::HIDING:
      case HaskellParser::QUALIFIED:
      case HaskellParser::EXPORT:
      case HaskellParser::STDCALL:
      case HaskellParser::CCALL:
      case HaskellParser::CAPI:
      case HaskellParser::JSCALL:
      case HaskellParser::STOCK:
      case HaskellParser::ANYCLASS:
      case HaskellParser::VIA:
      case HaskellParser::VARID: {
        enterOuterAlt(_localctx, 1);
        setState(1247);
        varid();
        break;
      }

      case HaskellParser::WILDCARD: {
        enterOuterAlt(_localctx, 2);
        setState(1248);
        match(HaskellParser::WILDCARD);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pattern_synonym_declContext ------------------------------------------------------------------

HaskellParser::Pattern_synonym_declContext::Pattern_synonym_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Pattern_synonym_declContext::PATTERN() {
  return getToken(HaskellParser::PATTERN, 0);
}

HaskellParser::Pattern_synonym_lhsContext* HaskellParser::Pattern_synonym_declContext::pattern_synonym_lhs() {
  return getRuleContext<HaskellParser::Pattern_synonym_lhsContext>(0);
}

tree::TerminalNode* HaskellParser::Pattern_synonym_declContext::Eq() {
  return getToken(HaskellParser::Eq, 0);
}

HaskellParser::PatContext* HaskellParser::Pattern_synonym_declContext::pat() {
  return getRuleContext<HaskellParser::PatContext>(0);
}

tree::TerminalNode* HaskellParser::Pattern_synonym_declContext::Revarrow() {
  return getToken(HaskellParser::Revarrow, 0);
}

HaskellParser::Where_declsContext* HaskellParser::Pattern_synonym_declContext::where_decls() {
  return getRuleContext<HaskellParser::Where_declsContext>(0);
}


size_t HaskellParser::Pattern_synonym_declContext::getRuleIndex() const {
  return HaskellParser::RulePattern_synonym_decl;
}

void HaskellParser::Pattern_synonym_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPattern_synonym_decl(this);
}

void HaskellParser::Pattern_synonym_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPattern_synonym_decl(this);
}

HaskellParser::Pattern_synonym_declContext* HaskellParser::pattern_synonym_decl() {
  Pattern_synonym_declContext *_localctx = _tracker.createInstance<Pattern_synonym_declContext>(_ctx, getState());
  enterRule(_localctx, 102, HaskellParser::RulePattern_synonym_decl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1263);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1251);
      match(HaskellParser::PATTERN);
      setState(1252);
      pattern_synonym_lhs();
      setState(1253);
      match(HaskellParser::Eq);
      setState(1254);
      pat();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1256);
      match(HaskellParser::PATTERN);
      setState(1257);
      pattern_synonym_lhs();
      setState(1258);
      match(HaskellParser::Revarrow);
      setState(1259);
      pat();
      setState(1261);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::WHERE) {
        setState(1260);
        where_decls();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pattern_synonym_lhsContext ------------------------------------------------------------------

HaskellParser::Pattern_synonym_lhsContext::Pattern_synonym_lhsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::ConContext* HaskellParser::Pattern_synonym_lhsContext::con() {
  return getRuleContext<HaskellParser::ConContext>(0);
}

HaskellParser::Vars_Context* HaskellParser::Pattern_synonym_lhsContext::vars_() {
  return getRuleContext<HaskellParser::Vars_Context>(0);
}

std::vector<HaskellParser::VaridContext *> HaskellParser::Pattern_synonym_lhsContext::varid() {
  return getRuleContexts<HaskellParser::VaridContext>();
}

HaskellParser::VaridContext* HaskellParser::Pattern_synonym_lhsContext::varid(size_t i) {
  return getRuleContext<HaskellParser::VaridContext>(i);
}

HaskellParser::ConopContext* HaskellParser::Pattern_synonym_lhsContext::conop() {
  return getRuleContext<HaskellParser::ConopContext>(0);
}

tree::TerminalNode* HaskellParser::Pattern_synonym_lhsContext::OCURLY() {
  return getToken(HaskellParser::OCURLY, 0);
}

HaskellParser::CvarsContext* HaskellParser::Pattern_synonym_lhsContext::cvars() {
  return getRuleContext<HaskellParser::CvarsContext>(0);
}

tree::TerminalNode* HaskellParser::Pattern_synonym_lhsContext::CCURLY() {
  return getToken(HaskellParser::CCURLY, 0);
}


size_t HaskellParser::Pattern_synonym_lhsContext::getRuleIndex() const {
  return HaskellParser::RulePattern_synonym_lhs;
}

void HaskellParser::Pattern_synonym_lhsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPattern_synonym_lhs(this);
}

void HaskellParser::Pattern_synonym_lhsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPattern_synonym_lhs(this);
}

HaskellParser::Pattern_synonym_lhsContext* HaskellParser::pattern_synonym_lhs() {
  Pattern_synonym_lhsContext *_localctx = _tracker.createInstance<Pattern_synonym_lhsContext>(_ctx, getState());
  enterRule(_localctx, 104, HaskellParser::RulePattern_synonym_lhs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1278);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1265);
      con();
      setState(1267);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 1976649193099280) != 0) || _la == HaskellParser::VARID) {
        setState(1266);
        vars_();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1269);
      varid();
      setState(1270);
      conop();
      setState(1271);
      varid();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1273);
      con();
      setState(1274);
      match(HaskellParser::OCURLY);
      setState(1275);
      cvars();
      setState(1276);
      match(HaskellParser::CCURLY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Vars_Context ------------------------------------------------------------------

HaskellParser::Vars_Context::Vars_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::VaridContext *> HaskellParser::Vars_Context::varid() {
  return getRuleContexts<HaskellParser::VaridContext>();
}

HaskellParser::VaridContext* HaskellParser::Vars_Context::varid(size_t i) {
  return getRuleContext<HaskellParser::VaridContext>(i);
}


size_t HaskellParser::Vars_Context::getRuleIndex() const {
  return HaskellParser::RuleVars_;
}

void HaskellParser::Vars_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVars_(this);
}

void HaskellParser::Vars_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVars_(this);
}

HaskellParser::Vars_Context* HaskellParser::vars_() {
  Vars_Context *_localctx = _tracker.createInstance<Vars_Context>(_ctx, getState());
  enterRule(_localctx, 106, HaskellParser::RuleVars_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1281); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1280);
      varid();
      setState(1283); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1976649193099280) != 0) || _la == HaskellParser::VARID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CvarsContext ------------------------------------------------------------------

HaskellParser::CvarsContext::CvarsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::Var_Context *> HaskellParser::CvarsContext::var_() {
  return getRuleContexts<HaskellParser::Var_Context>();
}

HaskellParser::Var_Context* HaskellParser::CvarsContext::var_(size_t i) {
  return getRuleContext<HaskellParser::Var_Context>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::CvarsContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::CvarsContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}


size_t HaskellParser::CvarsContext::getRuleIndex() const {
  return HaskellParser::RuleCvars;
}

void HaskellParser::CvarsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCvars(this);
}

void HaskellParser::CvarsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCvars(this);
}

HaskellParser::CvarsContext* HaskellParser::cvars() {
  CvarsContext *_localctx = _tracker.createInstance<CvarsContext>(_ctx, getState());
  enterRule(_localctx, 108, HaskellParser::RuleCvars);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1285);
    var_();
    setState(1290);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Comma) {
      setState(1286);
      match(HaskellParser::Comma);
      setState(1287);
      var_();
      setState(1292);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Where_declsContext ------------------------------------------------------------------

HaskellParser::Where_declsContext::Where_declsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Where_declsContext::WHERE() {
  return getToken(HaskellParser::WHERE, 0);
}

HaskellParser::Open_Context* HaskellParser::Where_declsContext::open_() {
  return getRuleContext<HaskellParser::Open_Context>(0);
}

HaskellParser::CloseContext* HaskellParser::Where_declsContext::close() {
  return getRuleContext<HaskellParser::CloseContext>(0);
}

HaskellParser::DeclsContext* HaskellParser::Where_declsContext::decls() {
  return getRuleContext<HaskellParser::DeclsContext>(0);
}


size_t HaskellParser::Where_declsContext::getRuleIndex() const {
  return HaskellParser::RuleWhere_decls;
}

void HaskellParser::Where_declsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhere_decls(this);
}

void HaskellParser::Where_declsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhere_decls(this);
}

HaskellParser::Where_declsContext* HaskellParser::where_decls() {
  Where_declsContext *_localctx = _tracker.createInstance<Where_declsContext>(_ctx, getState());
  enterRule(_localctx, 110, HaskellParser::RuleWhere_decls);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1293);
    match(HaskellParser::WHERE);
    setState(1294);
    open_();
    setState(1296);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2117421311145008) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & -9152810504318468095) != 0) || ((((_la - 137) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 137)) & 15) != 0)) {
      setState(1295);
      decls();
    }
    setState(1298);
    close();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pattern_synonym_sigContext ------------------------------------------------------------------

HaskellParser::Pattern_synonym_sigContext::Pattern_synonym_sigContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Pattern_synonym_sigContext::PATTERN() {
  return getToken(HaskellParser::PATTERN, 0);
}

HaskellParser::Con_listContext* HaskellParser::Pattern_synonym_sigContext::con_list() {
  return getRuleContext<HaskellParser::Con_listContext>(0);
}

tree::TerminalNode* HaskellParser::Pattern_synonym_sigContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::SigtypedocContext* HaskellParser::Pattern_synonym_sigContext::sigtypedoc() {
  return getRuleContext<HaskellParser::SigtypedocContext>(0);
}


size_t HaskellParser::Pattern_synonym_sigContext::getRuleIndex() const {
  return HaskellParser::RulePattern_synonym_sig;
}

void HaskellParser::Pattern_synonym_sigContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPattern_synonym_sig(this);
}

void HaskellParser::Pattern_synonym_sigContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPattern_synonym_sig(this);
}

HaskellParser::Pattern_synonym_sigContext* HaskellParser::pattern_synonym_sig() {
  Pattern_synonym_sigContext *_localctx = _tracker.createInstance<Pattern_synonym_sigContext>(_ctx, getState());
  enterRule(_localctx, 112, HaskellParser::RulePattern_synonym_sig);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1300);
    match(HaskellParser::PATTERN);
    setState(1301);
    con_list();
    setState(1302);
    match(HaskellParser::DoubleColon);
    setState(1303);
    sigtypedoc();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Decl_clsContext ------------------------------------------------------------------

HaskellParser::Decl_clsContext::Decl_clsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::At_decl_clsContext* HaskellParser::Decl_clsContext::at_decl_cls() {
  return getRuleContext<HaskellParser::At_decl_clsContext>(0);
}

HaskellParser::DeclContext* HaskellParser::Decl_clsContext::decl() {
  return getRuleContext<HaskellParser::DeclContext>(0);
}

tree::TerminalNode* HaskellParser::Decl_clsContext::DEFAULT() {
  return getToken(HaskellParser::DEFAULT, 0);
}

HaskellParser::InfixexpContext* HaskellParser::Decl_clsContext::infixexp() {
  return getRuleContext<HaskellParser::InfixexpContext>(0);
}

tree::TerminalNode* HaskellParser::Decl_clsContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::SigtypedocContext* HaskellParser::Decl_clsContext::sigtypedoc() {
  return getRuleContext<HaskellParser::SigtypedocContext>(0);
}


size_t HaskellParser::Decl_clsContext::getRuleIndex() const {
  return HaskellParser::RuleDecl_cls;
}

void HaskellParser::Decl_clsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecl_cls(this);
}

void HaskellParser::Decl_clsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecl_cls(this);
}

HaskellParser::Decl_clsContext* HaskellParser::decl_cls() {
  Decl_clsContext *_localctx = _tracker.createInstance<Decl_clsContext>(_ctx, getState());
  enterRule(_localctx, 114, HaskellParser::RuleDecl_cls);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1312);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::DATA:
      case HaskellParser::TYPE: {
        enterOuterAlt(_localctx, 1);
        setState(1305);
        at_decl_cls();
        break;
      }

      case HaskellParser::AS:
      case HaskellParser::CASE:
      case HaskellParser::DO:
      case HaskellParser::HIDING:
      case HaskellParser::IF:
      case HaskellParser::INFIX:
      case HaskellParser::INFIXL:
      case HaskellParser::INFIXR:
      case HaskellParser::LET:
      case HaskellParser::QUALIFIED:
      case HaskellParser::WILDCARD:
      case HaskellParser::EXPORT:
      case HaskellParser::MDO:
      case HaskellParser::STDCALL:
      case HaskellParser::CCALL:
      case HaskellParser::CAPI:
      case HaskellParser::JSCALL:
      case HaskellParser::PATTERN:
      case HaskellParser::STOCK:
      case HaskellParser::ANYCLASS:
      case HaskellParser::VIA:
      case HaskellParser::LCASE:
      case HaskellParser::Bang:
      case HaskellParser::Minus:
      case HaskellParser::Tilde:
      case HaskellParser::DDollar:
      case HaskellParser::Dollar:
      case HaskellParser::Semi:
      case HaskellParser::Quote:
      case HaskellParser::DoubleQuote:
      case HaskellParser::ReverseSlash:
      case HaskellParser::AopenParen:
      case HaskellParser::TopenTexpQuote:
      case HaskellParser::TopenExpQuote:
      case HaskellParser::TopenPatQuote:
      case HaskellParser::TopenTypQoute:
      case HaskellParser::TopenDecQoute:
      case HaskellParser::OpenBoxParen:
      case HaskellParser::OpenRoundBracket:
      case HaskellParser::OpenSquareBracket:
      case HaskellParser::CHAR:
      case HaskellParser::STRING:
      case HaskellParser::VARID:
      case HaskellParser::CONID:
      case HaskellParser::OpenPragmaBracket:
      case HaskellParser::SEMI:
      case HaskellParser::DECIMAL:
      case HaskellParser::OCTAL:
      case HaskellParser::HEXADECIMAL:
      case HaskellParser::FLOAT: {
        enterOuterAlt(_localctx, 2);
        setState(1306);
        decl();
        break;
      }

      case HaskellParser::DEFAULT: {
        enterOuterAlt(_localctx, 3);
        setState(1307);
        match(HaskellParser::DEFAULT);
        setState(1308);
        infixexp();
        setState(1309);
        match(HaskellParser::DoubleColon);
        setState(1310);
        sigtypedoc();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Decls_clsContext ------------------------------------------------------------------

HaskellParser::Decls_clsContext::Decls_clsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::Decl_clsContext *> HaskellParser::Decls_clsContext::decl_cls() {
  return getRuleContexts<HaskellParser::Decl_clsContext>();
}

HaskellParser::Decl_clsContext* HaskellParser::Decls_clsContext::decl_cls(size_t i) {
  return getRuleContext<HaskellParser::Decl_clsContext>(i);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::Decls_clsContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::Decls_clsContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::Decls_clsContext::getRuleIndex() const {
  return HaskellParser::RuleDecls_cls;
}

void HaskellParser::Decls_clsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_cls(this);
}

void HaskellParser::Decls_clsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_cls(this);
}

HaskellParser::Decls_clsContext* HaskellParser::decls_cls() {
  Decls_clsContext *_localctx = _tracker.createInstance<Decls_clsContext>(_ctx, getState());
  enterRule(_localctx, 116, HaskellParser::RuleDecls_cls);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1314);
    decl_cls();
    setState(1324);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 149, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1316); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(1315);
                  semi();
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(1318); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 148, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        setState(1320);
        decl_cls(); 
      }
      setState(1326);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 149, _ctx);
    }
    setState(1330);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Semi

    || _la == HaskellParser::SEMI) {
      setState(1327);
      semi();
      setState(1332);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Decllist_clsContext ------------------------------------------------------------------

HaskellParser::Decllist_clsContext::Decllist_clsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Open_Context* HaskellParser::Decllist_clsContext::open_() {
  return getRuleContext<HaskellParser::Open_Context>(0);
}

HaskellParser::CloseContext* HaskellParser::Decllist_clsContext::close() {
  return getRuleContext<HaskellParser::CloseContext>(0);
}

HaskellParser::Decls_clsContext* HaskellParser::Decllist_clsContext::decls_cls() {
  return getRuleContext<HaskellParser::Decls_clsContext>(0);
}


size_t HaskellParser::Decllist_clsContext::getRuleIndex() const {
  return HaskellParser::RuleDecllist_cls;
}

void HaskellParser::Decllist_clsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecllist_cls(this);
}

void HaskellParser::Decllist_clsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecllist_cls(this);
}

HaskellParser::Decllist_clsContext* HaskellParser::decllist_cls() {
  Decllist_clsContext *_localctx = _tracker.createInstance<Decllist_clsContext>(_ctx, getState());
  enterRule(_localctx, 118, HaskellParser::RuleDecllist_cls);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1333);
    open_();
    setState(1335);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2117421378254256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & -9152810504318468095) != 0) || ((((_la - 137) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 137)) & 15) != 0)) {
      setState(1334);
      decls_cls();
    }
    setState(1337);
    close();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Where_clsContext ------------------------------------------------------------------

HaskellParser::Where_clsContext::Where_clsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Where_clsContext::WHERE() {
  return getToken(HaskellParser::WHERE, 0);
}

HaskellParser::Decllist_clsContext* HaskellParser::Where_clsContext::decllist_cls() {
  return getRuleContext<HaskellParser::Decllist_clsContext>(0);
}


size_t HaskellParser::Where_clsContext::getRuleIndex() const {
  return HaskellParser::RuleWhere_cls;
}

void HaskellParser::Where_clsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhere_cls(this);
}

void HaskellParser::Where_clsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhere_cls(this);
}

HaskellParser::Where_clsContext* HaskellParser::where_cls() {
  Where_clsContext *_localctx = _tracker.createInstance<Where_clsContext>(_ctx, getState());
  enterRule(_localctx, 120, HaskellParser::RuleWhere_cls);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1339);
    match(HaskellParser::WHERE);
    setState(1340);
    decllist_cls();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Decl_instContext ------------------------------------------------------------------

HaskellParser::Decl_instContext::Decl_instContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::At_decl_instContext* HaskellParser::Decl_instContext::at_decl_inst() {
  return getRuleContext<HaskellParser::At_decl_instContext>(0);
}

HaskellParser::DeclContext* HaskellParser::Decl_instContext::decl() {
  return getRuleContext<HaskellParser::DeclContext>(0);
}


size_t HaskellParser::Decl_instContext::getRuleIndex() const {
  return HaskellParser::RuleDecl_inst;
}

void HaskellParser::Decl_instContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecl_inst(this);
}

void HaskellParser::Decl_instContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecl_inst(this);
}

HaskellParser::Decl_instContext* HaskellParser::decl_inst() {
  Decl_instContext *_localctx = _tracker.createInstance<Decl_instContext>(_ctx, getState());
  enterRule(_localctx, 122, HaskellParser::RuleDecl_inst);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1344);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::DATA:
      case HaskellParser::NEWTYPE:
      case HaskellParser::TYPE: {
        enterOuterAlt(_localctx, 1);
        setState(1342);
        at_decl_inst();
        break;
      }

      case HaskellParser::AS:
      case HaskellParser::CASE:
      case HaskellParser::DO:
      case HaskellParser::HIDING:
      case HaskellParser::IF:
      case HaskellParser::INFIX:
      case HaskellParser::INFIXL:
      case HaskellParser::INFIXR:
      case HaskellParser::LET:
      case HaskellParser::QUALIFIED:
      case HaskellParser::WILDCARD:
      case HaskellParser::EXPORT:
      case HaskellParser::MDO:
      case HaskellParser::STDCALL:
      case HaskellParser::CCALL:
      case HaskellParser::CAPI:
      case HaskellParser::JSCALL:
      case HaskellParser::PATTERN:
      case HaskellParser::STOCK:
      case HaskellParser::ANYCLASS:
      case HaskellParser::VIA:
      case HaskellParser::LCASE:
      case HaskellParser::Bang:
      case HaskellParser::Minus:
      case HaskellParser::Tilde:
      case HaskellParser::DDollar:
      case HaskellParser::Dollar:
      case HaskellParser::Semi:
      case HaskellParser::Quote:
      case HaskellParser::DoubleQuote:
      case HaskellParser::ReverseSlash:
      case HaskellParser::AopenParen:
      case HaskellParser::TopenTexpQuote:
      case HaskellParser::TopenExpQuote:
      case HaskellParser::TopenPatQuote:
      case HaskellParser::TopenTypQoute:
      case HaskellParser::TopenDecQoute:
      case HaskellParser::OpenBoxParen:
      case HaskellParser::OpenRoundBracket:
      case HaskellParser::OpenSquareBracket:
      case HaskellParser::CHAR:
      case HaskellParser::STRING:
      case HaskellParser::VARID:
      case HaskellParser::CONID:
      case HaskellParser::OpenPragmaBracket:
      case HaskellParser::SEMI:
      case HaskellParser::DECIMAL:
      case HaskellParser::OCTAL:
      case HaskellParser::HEXADECIMAL:
      case HaskellParser::FLOAT: {
        enterOuterAlt(_localctx, 2);
        setState(1343);
        decl();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Decls_instContext ------------------------------------------------------------------

HaskellParser::Decls_instContext::Decls_instContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::Decl_instContext *> HaskellParser::Decls_instContext::decl_inst() {
  return getRuleContexts<HaskellParser::Decl_instContext>();
}

HaskellParser::Decl_instContext* HaskellParser::Decls_instContext::decl_inst(size_t i) {
  return getRuleContext<HaskellParser::Decl_instContext>(i);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::Decls_instContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::Decls_instContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::Decls_instContext::getRuleIndex() const {
  return HaskellParser::RuleDecls_inst;
}

void HaskellParser::Decls_instContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_inst(this);
}

void HaskellParser::Decls_instContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_inst(this);
}

HaskellParser::Decls_instContext* HaskellParser::decls_inst() {
  Decls_instContext *_localctx = _tracker.createInstance<Decls_instContext>(_ctx, getState());
  enterRule(_localctx, 124, HaskellParser::RuleDecls_inst);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1346);
    decl_inst();
    setState(1356);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1348); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(1347);
                  semi();
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(1350); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 153, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        setState(1352);
        decl_inst(); 
      }
      setState(1358);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx);
    }
    setState(1362);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Semi

    || _la == HaskellParser::SEMI) {
      setState(1359);
      semi();
      setState(1364);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Decllist_instContext ------------------------------------------------------------------

HaskellParser::Decllist_instContext::Decllist_instContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Open_Context* HaskellParser::Decllist_instContext::open_() {
  return getRuleContext<HaskellParser::Open_Context>(0);
}

HaskellParser::CloseContext* HaskellParser::Decllist_instContext::close() {
  return getRuleContext<HaskellParser::CloseContext>(0);
}

HaskellParser::Decls_instContext* HaskellParser::Decllist_instContext::decls_inst() {
  return getRuleContext<HaskellParser::Decls_instContext>(0);
}


size_t HaskellParser::Decllist_instContext::getRuleIndex() const {
  return HaskellParser::RuleDecllist_inst;
}

void HaskellParser::Decllist_instContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecllist_inst(this);
}

void HaskellParser::Decllist_instContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecllist_inst(this);
}

HaskellParser::Decllist_instContext* HaskellParser::decllist_inst() {
  Decllist_instContext *_localctx = _tracker.createInstance<Decllist_instContext>(_ctx, getState());
  enterRule(_localctx, 126, HaskellParser::RuleDecllist_inst);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1365);
    open_();
    setState(1367);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2117421382448304) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & -9152810504318468095) != 0) || ((((_la - 137) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 137)) & 15) != 0)) {
      setState(1366);
      decls_inst();
    }
    setState(1369);
    close();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Where_instContext ------------------------------------------------------------------

HaskellParser::Where_instContext::Where_instContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Where_instContext::WHERE() {
  return getToken(HaskellParser::WHERE, 0);
}

HaskellParser::Decllist_instContext* HaskellParser::Where_instContext::decllist_inst() {
  return getRuleContext<HaskellParser::Decllist_instContext>(0);
}


size_t HaskellParser::Where_instContext::getRuleIndex() const {
  return HaskellParser::RuleWhere_inst;
}

void HaskellParser::Where_instContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhere_inst(this);
}

void HaskellParser::Where_instContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhere_inst(this);
}

HaskellParser::Where_instContext* HaskellParser::where_inst() {
  Where_instContext *_localctx = _tracker.createInstance<Where_instContext>(_ctx, getState());
  enterRule(_localctx, 128, HaskellParser::RuleWhere_inst);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1371);
    match(HaskellParser::WHERE);
    setState(1372);
    decllist_inst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclsContext ------------------------------------------------------------------

HaskellParser::DeclsContext::DeclsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::DeclContext *> HaskellParser::DeclsContext::decl() {
  return getRuleContexts<HaskellParser::DeclContext>();
}

HaskellParser::DeclContext* HaskellParser::DeclsContext::decl(size_t i) {
  return getRuleContext<HaskellParser::DeclContext>(i);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::DeclsContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::DeclsContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::DeclsContext::getRuleIndex() const {
  return HaskellParser::RuleDecls;
}

void HaskellParser::DeclsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls(this);
}

void HaskellParser::DeclsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls(this);
}

HaskellParser::DeclsContext* HaskellParser::decls() {
  DeclsContext *_localctx = _tracker.createInstance<DeclsContext>(_ctx, getState());
  enterRule(_localctx, 130, HaskellParser::RuleDecls);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1374);
    decl();
    setState(1384);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 158, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1376); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(1375);
                  semi();
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(1378); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 157, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        setState(1380);
        decl(); 
      }
      setState(1386);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 158, _ctx);
    }
    setState(1390);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Semi

    || _la == HaskellParser::SEMI) {
      setState(1387);
      semi();
      setState(1392);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DecllistContext ------------------------------------------------------------------

HaskellParser::DecllistContext::DecllistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Open_Context* HaskellParser::DecllistContext::open_() {
  return getRuleContext<HaskellParser::Open_Context>(0);
}

HaskellParser::CloseContext* HaskellParser::DecllistContext::close() {
  return getRuleContext<HaskellParser::CloseContext>(0);
}

HaskellParser::DeclsContext* HaskellParser::DecllistContext::decls() {
  return getRuleContext<HaskellParser::DeclsContext>(0);
}


size_t HaskellParser::DecllistContext::getRuleIndex() const {
  return HaskellParser::RuleDecllist;
}

void HaskellParser::DecllistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecllist(this);
}

void HaskellParser::DecllistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecllist(this);
}

HaskellParser::DecllistContext* HaskellParser::decllist() {
  DecllistContext *_localctx = _tracker.createInstance<DecllistContext>(_ctx, getState());
  enterRule(_localctx, 132, HaskellParser::RuleDecllist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1393);
    open_();
    setState(1395);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2117421311145008) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & -9152810504318468095) != 0) || ((((_la - 137) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 137)) & 15) != 0)) {
      setState(1394);
      decls();
    }
    setState(1397);
    close();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BindsContext ------------------------------------------------------------------

HaskellParser::BindsContext::BindsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::DecllistContext* HaskellParser::BindsContext::decllist() {
  return getRuleContext<HaskellParser::DecllistContext>(0);
}

HaskellParser::Open_Context* HaskellParser::BindsContext::open_() {
  return getRuleContext<HaskellParser::Open_Context>(0);
}

HaskellParser::CloseContext* HaskellParser::BindsContext::close() {
  return getRuleContext<HaskellParser::CloseContext>(0);
}

HaskellParser::DbindsContext* HaskellParser::BindsContext::dbinds() {
  return getRuleContext<HaskellParser::DbindsContext>(0);
}


size_t HaskellParser::BindsContext::getRuleIndex() const {
  return HaskellParser::RuleBinds;
}

void HaskellParser::BindsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinds(this);
}

void HaskellParser::BindsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinds(this);
}

HaskellParser::BindsContext* HaskellParser::binds() {
  BindsContext *_localctx = _tracker.createInstance<BindsContext>(_ctx, getState());
  enterRule(_localctx, 134, HaskellParser::RuleBinds);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1406);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 162, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1399);
      decllist();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1400);
      open_();
      setState(1402);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 1976649193099280) != 0) || _la == HaskellParser::VARID) {
        setState(1401);
        dbinds();
      }
      setState(1404);
      close();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WherebindsContext ------------------------------------------------------------------

HaskellParser::WherebindsContext::WherebindsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::WherebindsContext::WHERE() {
  return getToken(HaskellParser::WHERE, 0);
}

HaskellParser::BindsContext* HaskellParser::WherebindsContext::binds() {
  return getRuleContext<HaskellParser::BindsContext>(0);
}


size_t HaskellParser::WherebindsContext::getRuleIndex() const {
  return HaskellParser::RuleWherebinds;
}

void HaskellParser::WherebindsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWherebinds(this);
}

void HaskellParser::WherebindsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWherebinds(this);
}

HaskellParser::WherebindsContext* HaskellParser::wherebinds() {
  WherebindsContext *_localctx = _tracker.createInstance<WherebindsContext>(_ctx, getState());
  enterRule(_localctx, 136, HaskellParser::RuleWherebinds);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1408);
    match(HaskellParser::WHERE);
    setState(1409);
    binds();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RulesContext ------------------------------------------------------------------

HaskellParser::RulesContext::RulesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::Pragma_ruleContext *> HaskellParser::RulesContext::pragma_rule() {
  return getRuleContexts<HaskellParser::Pragma_ruleContext>();
}

HaskellParser::Pragma_ruleContext* HaskellParser::RulesContext::pragma_rule(size_t i) {
  return getRuleContext<HaskellParser::Pragma_ruleContext>(i);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::RulesContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::RulesContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::RulesContext::getRuleIndex() const {
  return HaskellParser::RuleRules;
}

void HaskellParser::RulesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRules(this);
}

void HaskellParser::RulesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRules(this);
}

HaskellParser::RulesContext* HaskellParser::rules() {
  RulesContext *_localctx = _tracker.createInstance<RulesContext>(_ctx, getState());
  enterRule(_localctx, 138, HaskellParser::RuleRules);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1411);
    pragma_rule();
    setState(1417);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1412);
        semi();
        setState(1413);
        pragma_rule(); 
      }
      setState(1419);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, _ctx);
    }
    setState(1421);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::Semi

    || _la == HaskellParser::SEMI) {
      setState(1420);
      semi();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pragma_ruleContext ------------------------------------------------------------------

HaskellParser::Pragma_ruleContext::Pragma_ruleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::PstringContext* HaskellParser::Pragma_ruleContext::pstring() {
  return getRuleContext<HaskellParser::PstringContext>(0);
}

HaskellParser::InfixexpContext* HaskellParser::Pragma_ruleContext::infixexp() {
  return getRuleContext<HaskellParser::InfixexpContext>(0);
}

tree::TerminalNode* HaskellParser::Pragma_ruleContext::Eq() {
  return getToken(HaskellParser::Eq, 0);
}

HaskellParser::ExpContext* HaskellParser::Pragma_ruleContext::exp() {
  return getRuleContext<HaskellParser::ExpContext>(0);
}

HaskellParser::Rule_activationContext* HaskellParser::Pragma_ruleContext::rule_activation() {
  return getRuleContext<HaskellParser::Rule_activationContext>(0);
}

HaskellParser::Rule_forallsContext* HaskellParser::Pragma_ruleContext::rule_foralls() {
  return getRuleContext<HaskellParser::Rule_forallsContext>(0);
}


size_t HaskellParser::Pragma_ruleContext::getRuleIndex() const {
  return HaskellParser::RulePragma_rule;
}

void HaskellParser::Pragma_ruleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragma_rule(this);
}

void HaskellParser::Pragma_ruleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragma_rule(this);
}

HaskellParser::Pragma_ruleContext* HaskellParser::pragma_rule() {
  Pragma_ruleContext *_localctx = _tracker.createInstance<Pragma_ruleContext>(_ctx, getState());
  enterRule(_localctx, 140, HaskellParser::RulePragma_rule);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1423);
    pstring();
    setState(1425);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx)) {
    case 1: {
      setState(1424);
      rule_activation();
      break;
    }

    default:
      break;
    }
    setState(1428);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::FORALL) {
      setState(1427);
      rule_foralls();
    }
    setState(1430);
    infixexp();
    setState(1431);
    match(HaskellParser::Eq);
    setState(1432);
    exp();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rule_activation_markerContext ------------------------------------------------------------------

HaskellParser::Rule_activation_markerContext::Rule_activation_markerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Rule_activation_markerContext::Tilde() {
  return getToken(HaskellParser::Tilde, 0);
}

HaskellParser::VarsymContext* HaskellParser::Rule_activation_markerContext::varsym() {
  return getRuleContext<HaskellParser::VarsymContext>(0);
}


size_t HaskellParser::Rule_activation_markerContext::getRuleIndex() const {
  return HaskellParser::RuleRule_activation_marker;
}

void HaskellParser::Rule_activation_markerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRule_activation_marker(this);
}

void HaskellParser::Rule_activation_markerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRule_activation_marker(this);
}

HaskellParser::Rule_activation_markerContext* HaskellParser::rule_activation_marker() {
  Rule_activation_markerContext *_localctx = _tracker.createInstance<Rule_activation_markerContext>(_ctx, getState());
  enterRule(_localctx, 142, HaskellParser::RuleRule_activation_marker);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1436);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1434);
      match(HaskellParser::Tilde);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1435);
      varsym();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rule_activationContext ------------------------------------------------------------------

HaskellParser::Rule_activationContext::Rule_activationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Rule_activationContext::OpenSquareBracket() {
  return getToken(HaskellParser::OpenSquareBracket, 0);
}

HaskellParser::IntegerContext* HaskellParser::Rule_activationContext::integer() {
  return getRuleContext<HaskellParser::IntegerContext>(0);
}

tree::TerminalNode* HaskellParser::Rule_activationContext::CloseSquareBracket() {
  return getToken(HaskellParser::CloseSquareBracket, 0);
}

HaskellParser::Rule_activation_markerContext* HaskellParser::Rule_activationContext::rule_activation_marker() {
  return getRuleContext<HaskellParser::Rule_activation_markerContext>(0);
}


size_t HaskellParser::Rule_activationContext::getRuleIndex() const {
  return HaskellParser::RuleRule_activation;
}

void HaskellParser::Rule_activationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRule_activation(this);
}

void HaskellParser::Rule_activationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRule_activation(this);
}

HaskellParser::Rule_activationContext* HaskellParser::rule_activation() {
  Rule_activationContext *_localctx = _tracker.createInstance<Rule_activationContext>(_ctx, getState());
  enterRule(_localctx, 144, HaskellParser::RuleRule_activation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1451);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 168, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1438);
      match(HaskellParser::OpenSquareBracket);
      setState(1439);
      integer();
      setState(1440);
      match(HaskellParser::CloseSquareBracket);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1442);
      match(HaskellParser::OpenSquareBracket);
      setState(1443);
      rule_activation_marker();
      setState(1444);
      integer();
      setState(1445);
      match(HaskellParser::CloseSquareBracket);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1447);
      match(HaskellParser::OpenSquareBracket);
      setState(1448);
      rule_activation_marker();
      setState(1449);
      match(HaskellParser::CloseSquareBracket);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rule_forallsContext ------------------------------------------------------------------

HaskellParser::Rule_forallsContext::Rule_forallsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> HaskellParser::Rule_forallsContext::FORALL() {
  return getTokens(HaskellParser::FORALL);
}

tree::TerminalNode* HaskellParser::Rule_forallsContext::FORALL(size_t i) {
  return getToken(HaskellParser::FORALL, i);
}

std::vector<tree::TerminalNode *> HaskellParser::Rule_forallsContext::Dot() {
  return getTokens(HaskellParser::Dot);
}

tree::TerminalNode* HaskellParser::Rule_forallsContext::Dot(size_t i) {
  return getToken(HaskellParser::Dot, i);
}

std::vector<HaskellParser::Rule_varsContext *> HaskellParser::Rule_forallsContext::rule_vars() {
  return getRuleContexts<HaskellParser::Rule_varsContext>();
}

HaskellParser::Rule_varsContext* HaskellParser::Rule_forallsContext::rule_vars(size_t i) {
  return getRuleContext<HaskellParser::Rule_varsContext>(i);
}


size_t HaskellParser::Rule_forallsContext::getRuleIndex() const {
  return HaskellParser::RuleRule_foralls;
}

void HaskellParser::Rule_forallsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRule_foralls(this);
}

void HaskellParser::Rule_forallsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRule_foralls(this);
}

HaskellParser::Rule_forallsContext* HaskellParser::rule_foralls() {
  Rule_forallsContext *_localctx = _tracker.createInstance<Rule_forallsContext>(_ctx, getState());
  enterRule(_localctx, 146, HaskellParser::RuleRule_foralls);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1453);
    match(HaskellParser::FORALL);
    setState(1455);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1976649193099280) != 0) || _la == HaskellParser::OpenRoundBracket

    || _la == HaskellParser::VARID) {
      setState(1454);
      rule_vars();
    }
    setState(1457);
    match(HaskellParser::Dot);
    setState(1463);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::FORALL) {
      setState(1458);
      match(HaskellParser::FORALL);
      setState(1460);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 1976649193099280) != 0) || _la == HaskellParser::OpenRoundBracket

      || _la == HaskellParser::VARID) {
        setState(1459);
        rule_vars();
      }
      setState(1462);
      match(HaskellParser::Dot);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rule_varsContext ------------------------------------------------------------------

HaskellParser::Rule_varsContext::Rule_varsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::Rule_varContext *> HaskellParser::Rule_varsContext::rule_var() {
  return getRuleContexts<HaskellParser::Rule_varContext>();
}

HaskellParser::Rule_varContext* HaskellParser::Rule_varsContext::rule_var(size_t i) {
  return getRuleContext<HaskellParser::Rule_varContext>(i);
}


size_t HaskellParser::Rule_varsContext::getRuleIndex() const {
  return HaskellParser::RuleRule_vars;
}

void HaskellParser::Rule_varsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRule_vars(this);
}

void HaskellParser::Rule_varsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRule_vars(this);
}

HaskellParser::Rule_varsContext* HaskellParser::rule_vars() {
  Rule_varsContext *_localctx = _tracker.createInstance<Rule_varsContext>(_ctx, getState());
  enterRule(_localctx, 148, HaskellParser::RuleRule_vars);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1466); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1465);
      rule_var();
      setState(1468); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1976649193099280) != 0) || _la == HaskellParser::OpenRoundBracket

    || _la == HaskellParser::VARID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rule_varContext ------------------------------------------------------------------

HaskellParser::Rule_varContext::Rule_varContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::VaridContext* HaskellParser::Rule_varContext::varid() {
  return getRuleContext<HaskellParser::VaridContext>(0);
}

tree::TerminalNode* HaskellParser::Rule_varContext::OpenRoundBracket() {
  return getToken(HaskellParser::OpenRoundBracket, 0);
}

tree::TerminalNode* HaskellParser::Rule_varContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::CtypeContext* HaskellParser::Rule_varContext::ctype() {
  return getRuleContext<HaskellParser::CtypeContext>(0);
}

tree::TerminalNode* HaskellParser::Rule_varContext::CloseRoundBracket() {
  return getToken(HaskellParser::CloseRoundBracket, 0);
}


size_t HaskellParser::Rule_varContext::getRuleIndex() const {
  return HaskellParser::RuleRule_var;
}

void HaskellParser::Rule_varContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRule_var(this);
}

void HaskellParser::Rule_varContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRule_var(this);
}

HaskellParser::Rule_varContext* HaskellParser::rule_var() {
  Rule_varContext *_localctx = _tracker.createInstance<Rule_varContext>(_ctx, getState());
  enterRule(_localctx, 150, HaskellParser::RuleRule_var);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1477);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::AS:
      case HaskellParser::HIDING:
      case HaskellParser::QUALIFIED:
      case HaskellParser::EXPORT:
      case HaskellParser::STDCALL:
      case HaskellParser::CCALL:
      case HaskellParser::CAPI:
      case HaskellParser::JSCALL:
      case HaskellParser::STOCK:
      case HaskellParser::ANYCLASS:
      case HaskellParser::VIA:
      case HaskellParser::VARID: {
        enterOuterAlt(_localctx, 1);
        setState(1470);
        varid();
        break;
      }

      case HaskellParser::OpenRoundBracket: {
        enterOuterAlt(_localctx, 2);
        setState(1471);
        match(HaskellParser::OpenRoundBracket);
        setState(1472);
        varid();
        setState(1473);
        match(HaskellParser::DoubleColon);
        setState(1474);
        ctype();
        setState(1475);
        match(HaskellParser::CloseRoundBracket);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WarningsContext ------------------------------------------------------------------

HaskellParser::WarningsContext::WarningsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::Pragma_warningContext *> HaskellParser::WarningsContext::pragma_warning() {
  return getRuleContexts<HaskellParser::Pragma_warningContext>();
}

HaskellParser::Pragma_warningContext* HaskellParser::WarningsContext::pragma_warning(size_t i) {
  return getRuleContext<HaskellParser::Pragma_warningContext>(i);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::WarningsContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::WarningsContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::WarningsContext::getRuleIndex() const {
  return HaskellParser::RuleWarnings;
}

void HaskellParser::WarningsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWarnings(this);
}

void HaskellParser::WarningsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWarnings(this);
}

HaskellParser::WarningsContext* HaskellParser::warnings() {
  WarningsContext *_localctx = _tracker.createInstance<WarningsContext>(_ctx, getState());
  enterRule(_localctx, 152, HaskellParser::RuleWarnings);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1479);
    pragma_warning();
    setState(1485);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 174, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1480);
        semi();
        setState(1481);
        pragma_warning(); 
      }
      setState(1487);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 174, _ctx);
    }
    setState(1489);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::Semi

    || _la == HaskellParser::SEMI) {
      setState(1488);
      semi();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pragma_warningContext ------------------------------------------------------------------

HaskellParser::Pragma_warningContext::Pragma_warningContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::NamelistContext* HaskellParser::Pragma_warningContext::namelist() {
  return getRuleContext<HaskellParser::NamelistContext>(0);
}

HaskellParser::StringsContext* HaskellParser::Pragma_warningContext::strings() {
  return getRuleContext<HaskellParser::StringsContext>(0);
}


size_t HaskellParser::Pragma_warningContext::getRuleIndex() const {
  return HaskellParser::RulePragma_warning;
}

void HaskellParser::Pragma_warningContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragma_warning(this);
}

void HaskellParser::Pragma_warningContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragma_warning(this);
}

HaskellParser::Pragma_warningContext* HaskellParser::pragma_warning() {
  Pragma_warningContext *_localctx = _tracker.createInstance<Pragma_warningContext>(_ctx, getState());
  enterRule(_localctx, 154, HaskellParser::RulePragma_warning);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1491);
    namelist();
    setState(1492);
    strings();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeprecationsContext ------------------------------------------------------------------

HaskellParser::DeprecationsContext::DeprecationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::Pragma_deprecationContext *> HaskellParser::DeprecationsContext::pragma_deprecation() {
  return getRuleContexts<HaskellParser::Pragma_deprecationContext>();
}

HaskellParser::Pragma_deprecationContext* HaskellParser::DeprecationsContext::pragma_deprecation(size_t i) {
  return getRuleContext<HaskellParser::Pragma_deprecationContext>(i);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::DeprecationsContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::DeprecationsContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::DeprecationsContext::getRuleIndex() const {
  return HaskellParser::RuleDeprecations;
}

void HaskellParser::DeprecationsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeprecations(this);
}

void HaskellParser::DeprecationsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeprecations(this);
}

HaskellParser::DeprecationsContext* HaskellParser::deprecations() {
  DeprecationsContext *_localctx = _tracker.createInstance<DeprecationsContext>(_ctx, getState());
  enterRule(_localctx, 156, HaskellParser::RuleDeprecations);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1494);
    pragma_deprecation();
    setState(1500);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 176, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1495);
        semi();
        setState(1496);
        pragma_deprecation(); 
      }
      setState(1502);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 176, _ctx);
    }
    setState(1504);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::Semi

    || _la == HaskellParser::SEMI) {
      setState(1503);
      semi();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pragma_deprecationContext ------------------------------------------------------------------

HaskellParser::Pragma_deprecationContext::Pragma_deprecationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::NamelistContext* HaskellParser::Pragma_deprecationContext::namelist() {
  return getRuleContext<HaskellParser::NamelistContext>(0);
}

HaskellParser::StringsContext* HaskellParser::Pragma_deprecationContext::strings() {
  return getRuleContext<HaskellParser::StringsContext>(0);
}


size_t HaskellParser::Pragma_deprecationContext::getRuleIndex() const {
  return HaskellParser::RulePragma_deprecation;
}

void HaskellParser::Pragma_deprecationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragma_deprecation(this);
}

void HaskellParser::Pragma_deprecationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragma_deprecation(this);
}

HaskellParser::Pragma_deprecationContext* HaskellParser::pragma_deprecation() {
  Pragma_deprecationContext *_localctx = _tracker.createInstance<Pragma_deprecationContext>(_ctx, getState());
  enterRule(_localctx, 158, HaskellParser::RulePragma_deprecation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1506);
    namelist();
    setState(1507);
    strings();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringsContext ------------------------------------------------------------------

HaskellParser::StringsContext::StringsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::PstringContext* HaskellParser::StringsContext::pstring() {
  return getRuleContext<HaskellParser::PstringContext>(0);
}

tree::TerminalNode* HaskellParser::StringsContext::OpenSquareBracket() {
  return getToken(HaskellParser::OpenSquareBracket, 0);
}

tree::TerminalNode* HaskellParser::StringsContext::CloseSquareBracket() {
  return getToken(HaskellParser::CloseSquareBracket, 0);
}

HaskellParser::StringlistContext* HaskellParser::StringsContext::stringlist() {
  return getRuleContext<HaskellParser::StringlistContext>(0);
}


size_t HaskellParser::StringsContext::getRuleIndex() const {
  return HaskellParser::RuleStrings;
}

void HaskellParser::StringsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStrings(this);
}

void HaskellParser::StringsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStrings(this);
}

HaskellParser::StringsContext* HaskellParser::strings() {
  StringsContext *_localctx = _tracker.createInstance<StringsContext>(_ctx, getState());
  enterRule(_localctx, 160, HaskellParser::RuleStrings);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1515);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::STRING: {
        enterOuterAlt(_localctx, 1);
        setState(1509);
        pstring();
        break;
      }

      case HaskellParser::OpenSquareBracket: {
        enterOuterAlt(_localctx, 2);
        setState(1510);
        match(HaskellParser::OpenSquareBracket);
        setState(1512);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HaskellParser::STRING) {
          setState(1511);
          stringlist();
        }
        setState(1514);
        match(HaskellParser::CloseSquareBracket);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringlistContext ------------------------------------------------------------------

HaskellParser::StringlistContext::StringlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::PstringContext *> HaskellParser::StringlistContext::pstring() {
  return getRuleContexts<HaskellParser::PstringContext>();
}

HaskellParser::PstringContext* HaskellParser::StringlistContext::pstring(size_t i) {
  return getRuleContext<HaskellParser::PstringContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::StringlistContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::StringlistContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}


size_t HaskellParser::StringlistContext::getRuleIndex() const {
  return HaskellParser::RuleStringlist;
}

void HaskellParser::StringlistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringlist(this);
}

void HaskellParser::StringlistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringlist(this);
}

HaskellParser::StringlistContext* HaskellParser::stringlist() {
  StringlistContext *_localctx = _tracker.createInstance<StringlistContext>(_ctx, getState());
  enterRule(_localctx, 162, HaskellParser::RuleStringlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1517);
    pstring();
    setState(1522);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Comma) {
      setState(1518);
      match(HaskellParser::Comma);
      setState(1519);
      pstring();
      setState(1524);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnnotationContext ------------------------------------------------------------------

HaskellParser::AnnotationContext::AnnotationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::AnnotationContext::OpenPragmaBracket() {
  return getToken(HaskellParser::OpenPragmaBracket, 0);
}

tree::TerminalNode* HaskellParser::AnnotationContext::ANN() {
  return getToken(HaskellParser::ANN, 0);
}

HaskellParser::Name_varContext* HaskellParser::AnnotationContext::name_var() {
  return getRuleContext<HaskellParser::Name_varContext>(0);
}

HaskellParser::AexpContext* HaskellParser::AnnotationContext::aexp() {
  return getRuleContext<HaskellParser::AexpContext>(0);
}

tree::TerminalNode* HaskellParser::AnnotationContext::ClosePragmaBracket() {
  return getToken(HaskellParser::ClosePragmaBracket, 0);
}

HaskellParser::TyconContext* HaskellParser::AnnotationContext::tycon() {
  return getRuleContext<HaskellParser::TyconContext>(0);
}

tree::TerminalNode* HaskellParser::AnnotationContext::MODULE() {
  return getToken(HaskellParser::MODULE, 0);
}


size_t HaskellParser::AnnotationContext::getRuleIndex() const {
  return HaskellParser::RuleAnnotation;
}

void HaskellParser::AnnotationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnnotation(this);
}

void HaskellParser::AnnotationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnnotation(this);
}

HaskellParser::AnnotationContext* HaskellParser::annotation() {
  AnnotationContext *_localctx = _tracker.createInstance<AnnotationContext>(_ctx, getState());
  enterRule(_localctx, 164, HaskellParser::RuleAnnotation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1543);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 181, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1525);
      match(HaskellParser::OpenPragmaBracket);
      setState(1526);
      match(HaskellParser::ANN);
      setState(1527);
      name_var();
      setState(1528);
      aexp();
      setState(1529);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1531);
      match(HaskellParser::OpenPragmaBracket);
      setState(1532);
      match(HaskellParser::ANN);
      setState(1533);
      tycon();
      setState(1534);
      aexp();
      setState(1535);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1537);
      match(HaskellParser::OpenPragmaBracket);
      setState(1538);
      match(HaskellParser::ANN);
      setState(1539);
      match(HaskellParser::MODULE);
      setState(1540);
      aexp();
      setState(1541);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FdeclContext ------------------------------------------------------------------

HaskellParser::FdeclContext::FdeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::FdeclContext::IMPORT() {
  return getToken(HaskellParser::IMPORT, 0);
}

HaskellParser::CallconvContext* HaskellParser::FdeclContext::callconv() {
  return getRuleContext<HaskellParser::CallconvContext>(0);
}

HaskellParser::FspecContext* HaskellParser::FdeclContext::fspec() {
  return getRuleContext<HaskellParser::FspecContext>(0);
}

HaskellParser::SafetyContext* HaskellParser::FdeclContext::safety() {
  return getRuleContext<HaskellParser::SafetyContext>(0);
}

tree::TerminalNode* HaskellParser::FdeclContext::EXPORT() {
  return getToken(HaskellParser::EXPORT, 0);
}


size_t HaskellParser::FdeclContext::getRuleIndex() const {
  return HaskellParser::RuleFdecl;
}

void HaskellParser::FdeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFdecl(this);
}

void HaskellParser::FdeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFdecl(this);
}

HaskellParser::FdeclContext* HaskellParser::fdecl() {
  FdeclContext *_localctx = _tracker.createInstance<FdeclContext>(_ctx, getState());
  enterRule(_localctx, 166, HaskellParser::RuleFdecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1556);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::IMPORT: {
        enterOuterAlt(_localctx, 1);
        setState(1545);
        match(HaskellParser::IMPORT);
        setState(1546);
        callconv();
        setState(1548);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 30064771072) != 0)) {
          setState(1547);
          safety();
        }
        setState(1550);
        fspec();
        break;
      }

      case HaskellParser::EXPORT: {
        enterOuterAlt(_localctx, 2);
        setState(1552);
        match(HaskellParser::EXPORT);
        setState(1553);
        callconv();
        setState(1554);
        fspec();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CallconvContext ------------------------------------------------------------------

HaskellParser::CallconvContext::CallconvContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::CallconvContext::CCALL() {
  return getToken(HaskellParser::CCALL, 0);
}

tree::TerminalNode* HaskellParser::CallconvContext::STDCALL() {
  return getToken(HaskellParser::STDCALL, 0);
}

tree::TerminalNode* HaskellParser::CallconvContext::CPPCALL() {
  return getToken(HaskellParser::CPPCALL, 0);
}

tree::TerminalNode* HaskellParser::CallconvContext::JSCALL() {
  return getToken(HaskellParser::JSCALL, 0);
}


size_t HaskellParser::CallconvContext::getRuleIndex() const {
  return HaskellParser::RuleCallconv;
}

void HaskellParser::CallconvContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCallconv(this);
}

void HaskellParser::CallconvContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCallconv(this);
}

HaskellParser::CallconvContext* HaskellParser::callconv() {
  CallconvContext *_localctx = _tracker.createInstance<CallconvContext>(_ctx, getState());
  enterRule(_localctx, 168, HaskellParser::RuleCallconv);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1558);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 7421703487488) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SafetyContext ------------------------------------------------------------------

HaskellParser::SafetyContext::SafetyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::SafetyContext::UNSAFE() {
  return getToken(HaskellParser::UNSAFE, 0);
}

tree::TerminalNode* HaskellParser::SafetyContext::SAFE() {
  return getToken(HaskellParser::SAFE, 0);
}

tree::TerminalNode* HaskellParser::SafetyContext::INTERRUPTIBLE() {
  return getToken(HaskellParser::INTERRUPTIBLE, 0);
}


size_t HaskellParser::SafetyContext::getRuleIndex() const {
  return HaskellParser::RuleSafety;
}

void HaskellParser::SafetyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSafety(this);
}

void HaskellParser::SafetyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSafety(this);
}

HaskellParser::SafetyContext* HaskellParser::safety() {
  SafetyContext *_localctx = _tracker.createInstance<SafetyContext>(_ctx, getState());
  enterRule(_localctx, 170, HaskellParser::RuleSafety);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1560);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 30064771072) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FspecContext ------------------------------------------------------------------

HaskellParser::FspecContext::FspecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Var_Context* HaskellParser::FspecContext::var_() {
  return getRuleContext<HaskellParser::Var_Context>(0);
}

tree::TerminalNode* HaskellParser::FspecContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::SigtypedocContext* HaskellParser::FspecContext::sigtypedoc() {
  return getRuleContext<HaskellParser::SigtypedocContext>(0);
}

HaskellParser::PstringContext* HaskellParser::FspecContext::pstring() {
  return getRuleContext<HaskellParser::PstringContext>(0);
}


size_t HaskellParser::FspecContext::getRuleIndex() const {
  return HaskellParser::RuleFspec;
}

void HaskellParser::FspecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFspec(this);
}

void HaskellParser::FspecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFspec(this);
}

HaskellParser::FspecContext* HaskellParser::fspec() {
  FspecContext *_localctx = _tracker.createInstance<FspecContext>(_ctx, getState());
  enterRule(_localctx, 172, HaskellParser::RuleFspec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1563);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::STRING) {
      setState(1562);
      pstring();
    }
    setState(1565);
    var_();
    setState(1566);
    match(HaskellParser::DoubleColon);
    setState(1567);
    sigtypedoc();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_sigContext ------------------------------------------------------------------

HaskellParser::Opt_sigContext::Opt_sigContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Opt_sigContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::SigtypeContext* HaskellParser::Opt_sigContext::sigtype() {
  return getRuleContext<HaskellParser::SigtypeContext>(0);
}


size_t HaskellParser::Opt_sigContext::getRuleIndex() const {
  return HaskellParser::RuleOpt_sig;
}

void HaskellParser::Opt_sigContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_sig(this);
}

void HaskellParser::Opt_sigContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_sig(this);
}

HaskellParser::Opt_sigContext* HaskellParser::opt_sig() {
  Opt_sigContext *_localctx = _tracker.createInstance<Opt_sigContext>(_ctx, getState());
  enterRule(_localctx, 174, HaskellParser::RuleOpt_sig);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1569);
    match(HaskellParser::DoubleColon);
    setState(1570);
    sigtype();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_tyconsigContext ------------------------------------------------------------------

HaskellParser::Opt_tyconsigContext::Opt_tyconsigContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Opt_tyconsigContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::GtyconContext* HaskellParser::Opt_tyconsigContext::gtycon() {
  return getRuleContext<HaskellParser::GtyconContext>(0);
}


size_t HaskellParser::Opt_tyconsigContext::getRuleIndex() const {
  return HaskellParser::RuleOpt_tyconsig;
}

void HaskellParser::Opt_tyconsigContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_tyconsig(this);
}

void HaskellParser::Opt_tyconsigContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_tyconsig(this);
}

HaskellParser::Opt_tyconsigContext* HaskellParser::opt_tyconsig() {
  Opt_tyconsigContext *_localctx = _tracker.createInstance<Opt_tyconsigContext>(_ctx, getState());
  enterRule(_localctx, 176, HaskellParser::RuleOpt_tyconsig);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1572);
    match(HaskellParser::DoubleColon);
    setState(1573);
    gtycon();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SigtypeContext ------------------------------------------------------------------

HaskellParser::SigtypeContext::SigtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::CtypeContext* HaskellParser::SigtypeContext::ctype() {
  return getRuleContext<HaskellParser::CtypeContext>(0);
}


size_t HaskellParser::SigtypeContext::getRuleIndex() const {
  return HaskellParser::RuleSigtype;
}

void HaskellParser::SigtypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSigtype(this);
}

void HaskellParser::SigtypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSigtype(this);
}

HaskellParser::SigtypeContext* HaskellParser::sigtype() {
  SigtypeContext *_localctx = _tracker.createInstance<SigtypeContext>(_ctx, getState());
  enterRule(_localctx, 178, HaskellParser::RuleSigtype);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1575);
    ctype();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SigtypedocContext ------------------------------------------------------------------

HaskellParser::SigtypedocContext::SigtypedocContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::CtypedocContext* HaskellParser::SigtypedocContext::ctypedoc() {
  return getRuleContext<HaskellParser::CtypedocContext>(0);
}


size_t HaskellParser::SigtypedocContext::getRuleIndex() const {
  return HaskellParser::RuleSigtypedoc;
}

void HaskellParser::SigtypedocContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSigtypedoc(this);
}

void HaskellParser::SigtypedocContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSigtypedoc(this);
}

HaskellParser::SigtypedocContext* HaskellParser::sigtypedoc() {
  SigtypedocContext *_localctx = _tracker.createInstance<SigtypedocContext>(_ctx, getState());
  enterRule(_localctx, 180, HaskellParser::RuleSigtypedoc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1577);
    ctypedoc();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sig_varsContext ------------------------------------------------------------------

HaskellParser::Sig_varsContext::Sig_varsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::Var_Context *> HaskellParser::Sig_varsContext::var_() {
  return getRuleContexts<HaskellParser::Var_Context>();
}

HaskellParser::Var_Context* HaskellParser::Sig_varsContext::var_(size_t i) {
  return getRuleContext<HaskellParser::Var_Context>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::Sig_varsContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::Sig_varsContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}


size_t HaskellParser::Sig_varsContext::getRuleIndex() const {
  return HaskellParser::RuleSig_vars;
}

void HaskellParser::Sig_varsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSig_vars(this);
}

void HaskellParser::Sig_varsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSig_vars(this);
}

HaskellParser::Sig_varsContext* HaskellParser::sig_vars() {
  Sig_varsContext *_localctx = _tracker.createInstance<Sig_varsContext>(_ctx, getState());
  enterRule(_localctx, 182, HaskellParser::RuleSig_vars);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1579);
    var_();
    setState(1584);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Comma) {
      setState(1580);
      match(HaskellParser::Comma);
      setState(1581);
      var_();
      setState(1586);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sigtypes1Context ------------------------------------------------------------------

HaskellParser::Sigtypes1Context::Sigtypes1Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::SigtypeContext *> HaskellParser::Sigtypes1Context::sigtype() {
  return getRuleContexts<HaskellParser::SigtypeContext>();
}

HaskellParser::SigtypeContext* HaskellParser::Sigtypes1Context::sigtype(size_t i) {
  return getRuleContext<HaskellParser::SigtypeContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::Sigtypes1Context::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::Sigtypes1Context::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}


size_t HaskellParser::Sigtypes1Context::getRuleIndex() const {
  return HaskellParser::RuleSigtypes1;
}

void HaskellParser::Sigtypes1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSigtypes1(this);
}

void HaskellParser::Sigtypes1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSigtypes1(this);
}

HaskellParser::Sigtypes1Context* HaskellParser::sigtypes1() {
  Sigtypes1Context *_localctx = _tracker.createInstance<Sigtypes1Context>(_ctx, getState());
  enterRule(_localctx, 184, HaskellParser::RuleSigtypes1);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1587);
    sigtype();
    setState(1592);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Comma) {
      setState(1588);
      match(HaskellParser::Comma);
      setState(1589);
      sigtype();
      setState(1594);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnpackednessContext ------------------------------------------------------------------

HaskellParser::UnpackednessContext::UnpackednessContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::UnpackednessContext::OpenPragmaBracket() {
  return getToken(HaskellParser::OpenPragmaBracket, 0);
}

tree::TerminalNode* HaskellParser::UnpackednessContext::UNPACK() {
  return getToken(HaskellParser::UNPACK, 0);
}

tree::TerminalNode* HaskellParser::UnpackednessContext::ClosePragmaBracket() {
  return getToken(HaskellParser::ClosePragmaBracket, 0);
}

tree::TerminalNode* HaskellParser::UnpackednessContext::NOUNPACK() {
  return getToken(HaskellParser::NOUNPACK, 0);
}


size_t HaskellParser::UnpackednessContext::getRuleIndex() const {
  return HaskellParser::RuleUnpackedness;
}

void HaskellParser::UnpackednessContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnpackedness(this);
}

void HaskellParser::UnpackednessContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnpackedness(this);
}

HaskellParser::UnpackednessContext* HaskellParser::unpackedness() {
  UnpackednessContext *_localctx = _tracker.createInstance<UnpackednessContext>(_ctx, getState());
  enterRule(_localctx, 186, HaskellParser::RuleUnpackedness);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1601);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 187, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1595);
      match(HaskellParser::OpenPragmaBracket);
      setState(1596);
      match(HaskellParser::UNPACK);
      setState(1597);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1598);
      match(HaskellParser::OpenPragmaBracket);
      setState(1599);
      match(HaskellParser::NOUNPACK);
      setState(1600);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Forall_vis_flagContext ------------------------------------------------------------------

HaskellParser::Forall_vis_flagContext::Forall_vis_flagContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Forall_vis_flagContext::Dot() {
  return getToken(HaskellParser::Dot, 0);
}

tree::TerminalNode* HaskellParser::Forall_vis_flagContext::Arrow() {
  return getToken(HaskellParser::Arrow, 0);
}


size_t HaskellParser::Forall_vis_flagContext::getRuleIndex() const {
  return HaskellParser::RuleForall_vis_flag;
}

void HaskellParser::Forall_vis_flagContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForall_vis_flag(this);
}

void HaskellParser::Forall_vis_flagContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForall_vis_flag(this);
}

HaskellParser::Forall_vis_flagContext* HaskellParser::forall_vis_flag() {
  Forall_vis_flagContext *_localctx = _tracker.createInstance<Forall_vis_flagContext>(_ctx, getState());
  enterRule(_localctx, 188, HaskellParser::RuleForall_vis_flag);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1603);
    _la = _input->LA(1);
    if (!(_la == HaskellParser::Arrow

    || _la == HaskellParser::Dot)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KtypeContext ------------------------------------------------------------------

HaskellParser::KtypeContext::KtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::CtypeContext* HaskellParser::KtypeContext::ctype() {
  return getRuleContext<HaskellParser::CtypeContext>(0);
}

tree::TerminalNode* HaskellParser::KtypeContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::KindContext* HaskellParser::KtypeContext::kind() {
  return getRuleContext<HaskellParser::KindContext>(0);
}


size_t HaskellParser::KtypeContext::getRuleIndex() const {
  return HaskellParser::RuleKtype;
}

void HaskellParser::KtypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKtype(this);
}

void HaskellParser::KtypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKtype(this);
}

HaskellParser::KtypeContext* HaskellParser::ktype() {
  KtypeContext *_localctx = _tracker.createInstance<KtypeContext>(_ctx, getState());
  enterRule(_localctx, 190, HaskellParser::RuleKtype);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1610);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 188, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1605);
      ctype();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1606);
      ctype();
      setState(1607);
      match(HaskellParser::DoubleColon);
      setState(1608);
      kind();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KtypedocContext ------------------------------------------------------------------

HaskellParser::KtypedocContext::KtypedocContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::CtypedocContext* HaskellParser::KtypedocContext::ctypedoc() {
  return getRuleContext<HaskellParser::CtypedocContext>(0);
}

tree::TerminalNode* HaskellParser::KtypedocContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::KindContext* HaskellParser::KtypedocContext::kind() {
  return getRuleContext<HaskellParser::KindContext>(0);
}


size_t HaskellParser::KtypedocContext::getRuleIndex() const {
  return HaskellParser::RuleKtypedoc;
}

void HaskellParser::KtypedocContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKtypedoc(this);
}

void HaskellParser::KtypedocContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKtypedoc(this);
}

HaskellParser::KtypedocContext* HaskellParser::ktypedoc() {
  KtypedocContext *_localctx = _tracker.createInstance<KtypedocContext>(_ctx, getState());
  enterRule(_localctx, 192, HaskellParser::RuleKtypedoc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1617);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 189, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1612);
      ctypedoc();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1613);
      ctypedoc();
      setState(1614);
      match(HaskellParser::DoubleColon);
      setState(1615);
      kind();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CtypeContext ------------------------------------------------------------------

HaskellParser::CtypeContext::CtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::CtypeContext::FORALL() {
  return getToken(HaskellParser::FORALL, 0);
}

HaskellParser::Forall_vis_flagContext* HaskellParser::CtypeContext::forall_vis_flag() {
  return getRuleContext<HaskellParser::Forall_vis_flagContext>(0);
}

HaskellParser::CtypeContext* HaskellParser::CtypeContext::ctype() {
  return getRuleContext<HaskellParser::CtypeContext>(0);
}

HaskellParser::Tv_bndrsContext* HaskellParser::CtypeContext::tv_bndrs() {
  return getRuleContext<HaskellParser::Tv_bndrsContext>(0);
}

HaskellParser::BtypeContext* HaskellParser::CtypeContext::btype() {
  return getRuleContext<HaskellParser::BtypeContext>(0);
}

tree::TerminalNode* HaskellParser::CtypeContext::DoubleArrow() {
  return getToken(HaskellParser::DoubleArrow, 0);
}

HaskellParser::Var_Context* HaskellParser::CtypeContext::var_() {
  return getRuleContext<HaskellParser::Var_Context>(0);
}

tree::TerminalNode* HaskellParser::CtypeContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::Type_Context* HaskellParser::CtypeContext::type_() {
  return getRuleContext<HaskellParser::Type_Context>(0);
}


size_t HaskellParser::CtypeContext::getRuleIndex() const {
  return HaskellParser::RuleCtype;
}

void HaskellParser::CtypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCtype(this);
}

void HaskellParser::CtypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCtype(this);
}

HaskellParser::CtypeContext* HaskellParser::ctype() {
  CtypeContext *_localctx = _tracker.createInstance<CtypeContext>(_ctx, getState());
  enterRule(_localctx, 194, HaskellParser::RuleCtype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1635);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 191, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1619);
      match(HaskellParser::FORALL);
      setState(1621);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 1976649193099280) != 0) || ((((_la - 120) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 120)) & 4161) != 0)) {
        setState(1620);
        tv_bndrs();
      }
      setState(1623);
      forall_vis_flag();
      setState(1624);
      ctype();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1626);
      btype();
      setState(1627);
      match(HaskellParser::DoubleArrow);
      setState(1628);
      ctype();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1630);
      var_();
      setState(1631);
      match(HaskellParser::DoubleColon);
      setState(1632);
      type_();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1634);
      type_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CtypedocContext ------------------------------------------------------------------

HaskellParser::CtypedocContext::CtypedocContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::CtypedocContext::FORALL() {
  return getToken(HaskellParser::FORALL, 0);
}

HaskellParser::Forall_vis_flagContext* HaskellParser::CtypedocContext::forall_vis_flag() {
  return getRuleContext<HaskellParser::Forall_vis_flagContext>(0);
}

HaskellParser::CtypedocContext* HaskellParser::CtypedocContext::ctypedoc() {
  return getRuleContext<HaskellParser::CtypedocContext>(0);
}

HaskellParser::Tv_bndrsContext* HaskellParser::CtypedocContext::tv_bndrs() {
  return getRuleContext<HaskellParser::Tv_bndrsContext>(0);
}

HaskellParser::Tycl_contextContext* HaskellParser::CtypedocContext::tycl_context() {
  return getRuleContext<HaskellParser::Tycl_contextContext>(0);
}

tree::TerminalNode* HaskellParser::CtypedocContext::DoubleArrow() {
  return getToken(HaskellParser::DoubleArrow, 0);
}

HaskellParser::Var_Context* HaskellParser::CtypedocContext::var_() {
  return getRuleContext<HaskellParser::Var_Context>(0);
}

tree::TerminalNode* HaskellParser::CtypedocContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::Type_Context* HaskellParser::CtypedocContext::type_() {
  return getRuleContext<HaskellParser::Type_Context>(0);
}

HaskellParser::TypedocContext* HaskellParser::CtypedocContext::typedoc() {
  return getRuleContext<HaskellParser::TypedocContext>(0);
}


size_t HaskellParser::CtypedocContext::getRuleIndex() const {
  return HaskellParser::RuleCtypedoc;
}

void HaskellParser::CtypedocContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCtypedoc(this);
}

void HaskellParser::CtypedocContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCtypedoc(this);
}

HaskellParser::CtypedocContext* HaskellParser::ctypedoc() {
  CtypedocContext *_localctx = _tracker.createInstance<CtypedocContext>(_ctx, getState());
  enterRule(_localctx, 196, HaskellParser::RuleCtypedoc);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1653);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 193, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1637);
      match(HaskellParser::FORALL);
      setState(1639);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 1976649193099280) != 0) || ((((_la - 120) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 120)) & 4161) != 0)) {
        setState(1638);
        tv_bndrs();
      }
      setState(1641);
      forall_vis_flag();
      setState(1642);
      ctypedoc();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1644);
      tycl_context();
      setState(1645);
      match(HaskellParser::DoubleArrow);
      setState(1646);
      ctypedoc();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1648);
      var_();
      setState(1649);
      match(HaskellParser::DoubleColon);
      setState(1650);
      type_();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1652);
      typedoc();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tycl_contextContext ------------------------------------------------------------------

HaskellParser::Tycl_contextContext::Tycl_contextContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::BtypeContext* HaskellParser::Tycl_contextContext::btype() {
  return getRuleContext<HaskellParser::BtypeContext>(0);
}


size_t HaskellParser::Tycl_contextContext::getRuleIndex() const {
  return HaskellParser::RuleTycl_context;
}

void HaskellParser::Tycl_contextContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTycl_context(this);
}

void HaskellParser::Tycl_contextContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTycl_context(this);
}

HaskellParser::Tycl_contextContext* HaskellParser::tycl_context() {
  Tycl_contextContext *_localctx = _tracker.createInstance<Tycl_contextContext>(_ctx, getState());
  enterRule(_localctx, 198, HaskellParser::RuleTycl_context);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1655);
    btype();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constr_contextContext ------------------------------------------------------------------

HaskellParser::Constr_contextContext::Constr_contextContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Constr_btypeContext* HaskellParser::Constr_contextContext::constr_btype() {
  return getRuleContext<HaskellParser::Constr_btypeContext>(0);
}


size_t HaskellParser::Constr_contextContext::getRuleIndex() const {
  return HaskellParser::RuleConstr_context;
}

void HaskellParser::Constr_contextContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstr_context(this);
}

void HaskellParser::Constr_contextContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstr_context(this);
}

HaskellParser::Constr_contextContext* HaskellParser::constr_context() {
  Constr_contextContext *_localctx = _tracker.createInstance<Constr_contextContext>(_ctx, getState());
  enterRule(_localctx, 200, HaskellParser::RuleConstr_context);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1657);
    constr_btype();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_Context ------------------------------------------------------------------

HaskellParser::Type_Context::Type_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::BtypeContext* HaskellParser::Type_Context::btype() {
  return getRuleContext<HaskellParser::BtypeContext>(0);
}

tree::TerminalNode* HaskellParser::Type_Context::Arrow() {
  return getToken(HaskellParser::Arrow, 0);
}

HaskellParser::CtypeContext* HaskellParser::Type_Context::ctype() {
  return getRuleContext<HaskellParser::CtypeContext>(0);
}


size_t HaskellParser::Type_Context::getRuleIndex() const {
  return HaskellParser::RuleType_;
}

void HaskellParser::Type_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_(this);
}

void HaskellParser::Type_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_(this);
}

HaskellParser::Type_Context* HaskellParser::type_() {
  Type_Context *_localctx = _tracker.createInstance<Type_Context>(_ctx, getState());
  enterRule(_localctx, 202, HaskellParser::RuleType_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1664);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 194, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1659);
      btype();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1660);
      btype();
      setState(1661);
      match(HaskellParser::Arrow);
      setState(1662);
      ctype();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypedocContext ------------------------------------------------------------------

HaskellParser::TypedocContext::TypedocContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::BtypeContext* HaskellParser::TypedocContext::btype() {
  return getRuleContext<HaskellParser::BtypeContext>(0);
}

tree::TerminalNode* HaskellParser::TypedocContext::Arrow() {
  return getToken(HaskellParser::Arrow, 0);
}

HaskellParser::CtypedocContext* HaskellParser::TypedocContext::ctypedoc() {
  return getRuleContext<HaskellParser::CtypedocContext>(0);
}


size_t HaskellParser::TypedocContext::getRuleIndex() const {
  return HaskellParser::RuleTypedoc;
}

void HaskellParser::TypedocContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypedoc(this);
}

void HaskellParser::TypedocContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypedoc(this);
}

HaskellParser::TypedocContext* HaskellParser::typedoc() {
  TypedocContext *_localctx = _tracker.createInstance<TypedocContext>(_ctx, getState());
  enterRule(_localctx, 204, HaskellParser::RuleTypedoc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1671);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 195, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1666);
      btype();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1667);
      btype();
      setState(1668);
      match(HaskellParser::Arrow);
      setState(1669);
      ctypedoc();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constr_btypeContext ------------------------------------------------------------------

HaskellParser::Constr_btypeContext::Constr_btypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Constr_tyappsContext* HaskellParser::Constr_btypeContext::constr_tyapps() {
  return getRuleContext<HaskellParser::Constr_tyappsContext>(0);
}


size_t HaskellParser::Constr_btypeContext::getRuleIndex() const {
  return HaskellParser::RuleConstr_btype;
}

void HaskellParser::Constr_btypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstr_btype(this);
}

void HaskellParser::Constr_btypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstr_btype(this);
}

HaskellParser::Constr_btypeContext* HaskellParser::constr_btype() {
  Constr_btypeContext *_localctx = _tracker.createInstance<Constr_btypeContext>(_ctx, getState());
  enterRule(_localctx, 206, HaskellParser::RuleConstr_btype);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1673);
    constr_tyapps();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constr_tyappsContext ------------------------------------------------------------------

HaskellParser::Constr_tyappsContext::Constr_tyappsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::Constr_tyappContext *> HaskellParser::Constr_tyappsContext::constr_tyapp() {
  return getRuleContexts<HaskellParser::Constr_tyappContext>();
}

HaskellParser::Constr_tyappContext* HaskellParser::Constr_tyappsContext::constr_tyapp(size_t i) {
  return getRuleContext<HaskellParser::Constr_tyappContext>(i);
}


size_t HaskellParser::Constr_tyappsContext::getRuleIndex() const {
  return HaskellParser::RuleConstr_tyapps;
}

void HaskellParser::Constr_tyappsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstr_tyapps(this);
}

void HaskellParser::Constr_tyappsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstr_tyapps(this);
}

HaskellParser::Constr_tyappsContext* HaskellParser::constr_tyapps() {
  Constr_tyappsContext *_localctx = _tracker.createInstance<Constr_tyappsContext>(_ctx, getState());
  enterRule(_localctx, 208, HaskellParser::RuleConstr_tyapps);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1676); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1675);
              constr_tyapp();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1678); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 196, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constr_tyappContext ------------------------------------------------------------------

HaskellParser::Constr_tyappContext::Constr_tyappContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::TyappContext* HaskellParser::Constr_tyappContext::tyapp() {
  return getRuleContext<HaskellParser::TyappContext>(0);
}


size_t HaskellParser::Constr_tyappContext::getRuleIndex() const {
  return HaskellParser::RuleConstr_tyapp;
}

void HaskellParser::Constr_tyappContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstr_tyapp(this);
}

void HaskellParser::Constr_tyappContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstr_tyapp(this);
}

HaskellParser::Constr_tyappContext* HaskellParser::constr_tyapp() {
  Constr_tyappContext *_localctx = _tracker.createInstance<Constr_tyappContext>(_ctx, getState());
  enterRule(_localctx, 210, HaskellParser::RuleConstr_tyapp);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1680);
    tyapp();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BtypeContext ------------------------------------------------------------------

HaskellParser::BtypeContext::BtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::TyappsContext* HaskellParser::BtypeContext::tyapps() {
  return getRuleContext<HaskellParser::TyappsContext>(0);
}


size_t HaskellParser::BtypeContext::getRuleIndex() const {
  return HaskellParser::RuleBtype;
}

void HaskellParser::BtypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBtype(this);
}

void HaskellParser::BtypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBtype(this);
}

HaskellParser::BtypeContext* HaskellParser::btype() {
  BtypeContext *_localctx = _tracker.createInstance<BtypeContext>(_ctx, getState());
  enterRule(_localctx, 212, HaskellParser::RuleBtype);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1682);
    tyapps();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TyappsContext ------------------------------------------------------------------

HaskellParser::TyappsContext::TyappsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::TyappContext *> HaskellParser::TyappsContext::tyapp() {
  return getRuleContexts<HaskellParser::TyappContext>();
}

HaskellParser::TyappContext* HaskellParser::TyappsContext::tyapp(size_t i) {
  return getRuleContext<HaskellParser::TyappContext>(i);
}


size_t HaskellParser::TyappsContext::getRuleIndex() const {
  return HaskellParser::RuleTyapps;
}

void HaskellParser::TyappsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTyapps(this);
}

void HaskellParser::TyappsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTyapps(this);
}

HaskellParser::TyappsContext* HaskellParser::tyapps() {
  TyappsContext *_localctx = _tracker.createInstance<TyappsContext>(_ctx, getState());
  enterRule(_localctx, 214, HaskellParser::RuleTyapps);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1685); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1684);
              tyapp();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1687); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 197, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TyappContext ------------------------------------------------------------------

HaskellParser::TyappContext::TyappContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::AtypeContext* HaskellParser::TyappContext::atype() {
  return getRuleContext<HaskellParser::AtypeContext>(0);
}

tree::TerminalNode* HaskellParser::TyappContext::Atsign() {
  return getToken(HaskellParser::Atsign, 0);
}

HaskellParser::QtyconopContext* HaskellParser::TyappContext::qtyconop() {
  return getRuleContext<HaskellParser::QtyconopContext>(0);
}

HaskellParser::TyvaropContext* HaskellParser::TyappContext::tyvarop() {
  return getRuleContext<HaskellParser::TyvaropContext>(0);
}

tree::TerminalNode* HaskellParser::TyappContext::Quote() {
  return getToken(HaskellParser::Quote, 0);
}

HaskellParser::QconopContext* HaskellParser::TyappContext::qconop() {
  return getRuleContext<HaskellParser::QconopContext>(0);
}

HaskellParser::VaropContext* HaskellParser::TyappContext::varop() {
  return getRuleContext<HaskellParser::VaropContext>(0);
}

HaskellParser::UnpackednessContext* HaskellParser::TyappContext::unpackedness() {
  return getRuleContext<HaskellParser::UnpackednessContext>(0);
}


size_t HaskellParser::TyappContext::getRuleIndex() const {
  return HaskellParser::RuleTyapp;
}

void HaskellParser::TyappContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTyapp(this);
}

void HaskellParser::TyappContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTyapp(this);
}

HaskellParser::TyappContext* HaskellParser::tyapp() {
  TyappContext *_localctx = _tracker.createInstance<TyappContext>(_ctx, getState());
  enterRule(_localctx, 216, HaskellParser::RuleTyapp);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1699);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 198, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1689);
      atype();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1690);
      match(HaskellParser::Atsign);
      setState(1691);
      atype();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1692);
      qtyconop();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1693);
      tyvarop();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1694);
      match(HaskellParser::Quote);
      setState(1695);
      qconop();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1696);
      match(HaskellParser::Quote);
      setState(1697);
      varop();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1698);
      unpackedness();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AtypeContext ------------------------------------------------------------------

HaskellParser::AtypeContext::AtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::NtgtyconContext* HaskellParser::AtypeContext::ntgtycon() {
  return getRuleContext<HaskellParser::NtgtyconContext>(0);
}

HaskellParser::TyvarContext* HaskellParser::AtypeContext::tyvar() {
  return getRuleContext<HaskellParser::TyvarContext>(0);
}

tree::TerminalNode* HaskellParser::AtypeContext::Asterisk() {
  return getToken(HaskellParser::Asterisk, 0);
}

tree::TerminalNode* HaskellParser::AtypeContext::Tilde() {
  return getToken(HaskellParser::Tilde, 0);
}

HaskellParser::AtypeContext* HaskellParser::AtypeContext::atype() {
  return getRuleContext<HaskellParser::AtypeContext>(0);
}

tree::TerminalNode* HaskellParser::AtypeContext::Bang() {
  return getToken(HaskellParser::Bang, 0);
}

tree::TerminalNode* HaskellParser::AtypeContext::OCURLY() {
  return getToken(HaskellParser::OCURLY, 0);
}

tree::TerminalNode* HaskellParser::AtypeContext::CCURLY() {
  return getToken(HaskellParser::CCURLY, 0);
}

HaskellParser::FielddeclsContext* HaskellParser::AtypeContext::fielddecls() {
  return getRuleContext<HaskellParser::FielddeclsContext>(0);
}

tree::TerminalNode* HaskellParser::AtypeContext::OpenRoundBracket() {
  return getToken(HaskellParser::OpenRoundBracket, 0);
}

tree::TerminalNode* HaskellParser::AtypeContext::CloseRoundBracket() {
  return getToken(HaskellParser::CloseRoundBracket, 0);
}

HaskellParser::KtypeContext* HaskellParser::AtypeContext::ktype() {
  return getRuleContext<HaskellParser::KtypeContext>(0);
}

tree::TerminalNode* HaskellParser::AtypeContext::Comma() {
  return getToken(HaskellParser::Comma, 0);
}

HaskellParser::Comma_typesContext* HaskellParser::AtypeContext::comma_types() {
  return getRuleContext<HaskellParser::Comma_typesContext>(0);
}

tree::TerminalNode* HaskellParser::AtypeContext::OpenBoxParen() {
  return getToken(HaskellParser::OpenBoxParen, 0);
}

tree::TerminalNode* HaskellParser::AtypeContext::CloseBoxParen() {
  return getToken(HaskellParser::CloseBoxParen, 0);
}

HaskellParser::Bar_types2Context* HaskellParser::AtypeContext::bar_types2() {
  return getRuleContext<HaskellParser::Bar_types2Context>(0);
}

tree::TerminalNode* HaskellParser::AtypeContext::OpenSquareBracket() {
  return getToken(HaskellParser::OpenSquareBracket, 0);
}

tree::TerminalNode* HaskellParser::AtypeContext::CloseSquareBracket() {
  return getToken(HaskellParser::CloseSquareBracket, 0);
}

HaskellParser::QuasiquoteContext* HaskellParser::AtypeContext::quasiquote() {
  return getRuleContext<HaskellParser::QuasiquoteContext>(0);
}

HaskellParser::Splice_untypedContext* HaskellParser::AtypeContext::splice_untyped() {
  return getRuleContext<HaskellParser::Splice_untypedContext>(0);
}

tree::TerminalNode* HaskellParser::AtypeContext::Quote() {
  return getToken(HaskellParser::Quote, 0);
}

HaskellParser::Qcon_nowiredlistContext* HaskellParser::AtypeContext::qcon_nowiredlist() {
  return getRuleContext<HaskellParser::Qcon_nowiredlistContext>(0);
}

HaskellParser::Var_Context* HaskellParser::AtypeContext::var_() {
  return getRuleContext<HaskellParser::Var_Context>(0);
}

HaskellParser::IntegerContext* HaskellParser::AtypeContext::integer() {
  return getRuleContext<HaskellParser::IntegerContext>(0);
}

HaskellParser::PstringContext* HaskellParser::AtypeContext::pstring() {
  return getRuleContext<HaskellParser::PstringContext>(0);
}

tree::TerminalNode* HaskellParser::AtypeContext::WILDCARD() {
  return getToken(HaskellParser::WILDCARD, 0);
}


size_t HaskellParser::AtypeContext::getRuleIndex() const {
  return HaskellParser::RuleAtype;
}

void HaskellParser::AtypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtype(this);
}

void HaskellParser::AtypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtype(this);
}

HaskellParser::AtypeContext* HaskellParser::atype() {
  AtypeContext *_localctx = _tracker.createInstance<AtypeContext>(_ctx, getState());
  enterRule(_localctx, 218, HaskellParser::RuleAtype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1767);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 201, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1701);
      ntgtycon();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1702);
      tyvar();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1703);
      match(HaskellParser::Asterisk);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1704);
      match(HaskellParser::Tilde);
      setState(1705);
      atype();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1706);
      match(HaskellParser::Bang);
      setState(1707);
      atype();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1708);
      match(HaskellParser::OCURLY);
      setState(1710);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 1976649193099280) != 0) || _la == HaskellParser::OpenRoundBracket

      || _la == HaskellParser::VARID) {
        setState(1709);
        fielddecls();
      }
      setState(1712);
      match(HaskellParser::CCURLY);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1713);
      match(HaskellParser::OpenRoundBracket);
      setState(1714);
      match(HaskellParser::CloseRoundBracket);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1715);
      match(HaskellParser::OpenRoundBracket);
      setState(1716);
      ktype();
      setState(1717);
      match(HaskellParser::Comma);
      setState(1718);
      comma_types();
      setState(1719);
      match(HaskellParser::CloseRoundBracket);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1721);
      match(HaskellParser::OpenBoxParen);
      setState(1722);
      match(HaskellParser::CloseBoxParen);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1723);
      match(HaskellParser::OpenBoxParen);
      setState(1724);
      comma_types();
      setState(1725);
      match(HaskellParser::CloseBoxParen);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1727);
      match(HaskellParser::OpenBoxParen);
      setState(1728);
      bar_types2();
      setState(1729);
      match(HaskellParser::CloseBoxParen);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1731);
      match(HaskellParser::OpenSquareBracket);
      setState(1732);
      ktype();
      setState(1733);
      match(HaskellParser::CloseSquareBracket);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(1735);
      match(HaskellParser::OpenRoundBracket);
      setState(1736);
      ktype();
      setState(1737);
      match(HaskellParser::CloseRoundBracket);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(1739);
      quasiquote();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(1740);
      splice_untyped();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(1741);
      match(HaskellParser::Quote);
      setState(1742);
      qcon_nowiredlist();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(1743);
      match(HaskellParser::Quote);
      setState(1744);
      match(HaskellParser::OpenRoundBracket);
      setState(1745);
      ktype();
      setState(1746);
      match(HaskellParser::Comma);
      setState(1747);
      comma_types();
      setState(1748);
      match(HaskellParser::CloseRoundBracket);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(1750);
      match(HaskellParser::Quote);
      setState(1751);
      match(HaskellParser::OpenSquareBracket);
      setState(1753);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 1976649998405648) != 0) || ((((_la - 82) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 82)) & 253460863659982847) != 0)) {
        setState(1752);
        comma_types();
      }
      setState(1755);
      match(HaskellParser::CloseSquareBracket);
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(1756);
      match(HaskellParser::Quote);
      setState(1757);
      var_();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(1758);
      match(HaskellParser::OpenSquareBracket);
      setState(1759);
      ktype();
      setState(1760);
      match(HaskellParser::Comma);
      setState(1761);
      comma_types();
      setState(1762);
      match(HaskellParser::CloseSquareBracket);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(1764);
      integer();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(1765);
      pstring();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(1766);
      match(HaskellParser::WILDCARD);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inst_typeContext ------------------------------------------------------------------

HaskellParser::Inst_typeContext::Inst_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::SigtypeContext* HaskellParser::Inst_typeContext::sigtype() {
  return getRuleContext<HaskellParser::SigtypeContext>(0);
}


size_t HaskellParser::Inst_typeContext::getRuleIndex() const {
  return HaskellParser::RuleInst_type;
}

void HaskellParser::Inst_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInst_type(this);
}

void HaskellParser::Inst_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInst_type(this);
}

HaskellParser::Inst_typeContext* HaskellParser::inst_type() {
  Inst_typeContext *_localctx = _tracker.createInstance<Inst_typeContext>(_ctx, getState());
  enterRule(_localctx, 220, HaskellParser::RuleInst_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1769);
    sigtype();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Deriv_typesContext ------------------------------------------------------------------

HaskellParser::Deriv_typesContext::Deriv_typesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::KtypedocContext *> HaskellParser::Deriv_typesContext::ktypedoc() {
  return getRuleContexts<HaskellParser::KtypedocContext>();
}

HaskellParser::KtypedocContext* HaskellParser::Deriv_typesContext::ktypedoc(size_t i) {
  return getRuleContext<HaskellParser::KtypedocContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::Deriv_typesContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::Deriv_typesContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}


size_t HaskellParser::Deriv_typesContext::getRuleIndex() const {
  return HaskellParser::RuleDeriv_types;
}

void HaskellParser::Deriv_typesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeriv_types(this);
}

void HaskellParser::Deriv_typesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeriv_types(this);
}

HaskellParser::Deriv_typesContext* HaskellParser::deriv_types() {
  Deriv_typesContext *_localctx = _tracker.createInstance<Deriv_typesContext>(_ctx, getState());
  enterRule(_localctx, 222, HaskellParser::RuleDeriv_types);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1771);
    ktypedoc();
    setState(1776);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Comma) {
      setState(1772);
      match(HaskellParser::Comma);
      setState(1773);
      ktypedoc();
      setState(1778);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comma_typesContext ------------------------------------------------------------------

HaskellParser::Comma_typesContext::Comma_typesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::KtypeContext *> HaskellParser::Comma_typesContext::ktype() {
  return getRuleContexts<HaskellParser::KtypeContext>();
}

HaskellParser::KtypeContext* HaskellParser::Comma_typesContext::ktype(size_t i) {
  return getRuleContext<HaskellParser::KtypeContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::Comma_typesContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::Comma_typesContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}


size_t HaskellParser::Comma_typesContext::getRuleIndex() const {
  return HaskellParser::RuleComma_types;
}

void HaskellParser::Comma_typesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComma_types(this);
}

void HaskellParser::Comma_typesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComma_types(this);
}

HaskellParser::Comma_typesContext* HaskellParser::comma_types() {
  Comma_typesContext *_localctx = _tracker.createInstance<Comma_typesContext>(_ctx, getState());
  enterRule(_localctx, 224, HaskellParser::RuleComma_types);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1779);
    ktype();
    setState(1784);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Comma) {
      setState(1780);
      match(HaskellParser::Comma);
      setState(1781);
      ktype();
      setState(1786);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bar_types2Context ------------------------------------------------------------------

HaskellParser::Bar_types2Context::Bar_types2Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::KtypeContext *> HaskellParser::Bar_types2Context::ktype() {
  return getRuleContexts<HaskellParser::KtypeContext>();
}

HaskellParser::KtypeContext* HaskellParser::Bar_types2Context::ktype(size_t i) {
  return getRuleContext<HaskellParser::KtypeContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::Bar_types2Context::Pipe() {
  return getTokens(HaskellParser::Pipe);
}

tree::TerminalNode* HaskellParser::Bar_types2Context::Pipe(size_t i) {
  return getToken(HaskellParser::Pipe, i);
}


size_t HaskellParser::Bar_types2Context::getRuleIndex() const {
  return HaskellParser::RuleBar_types2;
}

void HaskellParser::Bar_types2Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBar_types2(this);
}

void HaskellParser::Bar_types2Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBar_types2(this);
}

HaskellParser::Bar_types2Context* HaskellParser::bar_types2() {
  Bar_types2Context *_localctx = _tracker.createInstance<Bar_types2Context>(_ctx, getState());
  enterRule(_localctx, 226, HaskellParser::RuleBar_types2);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1787);
    ktype();
    setState(1788);
    match(HaskellParser::Pipe);
    setState(1789);
    ktype();
    setState(1794);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Pipe) {
      setState(1790);
      match(HaskellParser::Pipe);
      setState(1791);
      ktype();
      setState(1796);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tv_bndrsContext ------------------------------------------------------------------

HaskellParser::Tv_bndrsContext::Tv_bndrsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::Tv_bndrContext *> HaskellParser::Tv_bndrsContext::tv_bndr() {
  return getRuleContexts<HaskellParser::Tv_bndrContext>();
}

HaskellParser::Tv_bndrContext* HaskellParser::Tv_bndrsContext::tv_bndr(size_t i) {
  return getRuleContext<HaskellParser::Tv_bndrContext>(i);
}


size_t HaskellParser::Tv_bndrsContext::getRuleIndex() const {
  return HaskellParser::RuleTv_bndrs;
}

void HaskellParser::Tv_bndrsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTv_bndrs(this);
}

void HaskellParser::Tv_bndrsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTv_bndrs(this);
}

HaskellParser::Tv_bndrsContext* HaskellParser::tv_bndrs() {
  Tv_bndrsContext *_localctx = _tracker.createInstance<Tv_bndrsContext>(_ctx, getState());
  enterRule(_localctx, 228, HaskellParser::RuleTv_bndrs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1798); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1797);
      tv_bndr();
      setState(1800); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1976649193099280) != 0) || ((((_la - 120) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 120)) & 4161) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tv_bndrContext ------------------------------------------------------------------

HaskellParser::Tv_bndrContext::Tv_bndrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Tv_bndr_no_bracesContext* HaskellParser::Tv_bndrContext::tv_bndr_no_braces() {
  return getRuleContext<HaskellParser::Tv_bndr_no_bracesContext>(0);
}

tree::TerminalNode* HaskellParser::Tv_bndrContext::OCURLY() {
  return getToken(HaskellParser::OCURLY, 0);
}

HaskellParser::TyvarContext* HaskellParser::Tv_bndrContext::tyvar() {
  return getRuleContext<HaskellParser::TyvarContext>(0);
}

tree::TerminalNode* HaskellParser::Tv_bndrContext::CCURLY() {
  return getToken(HaskellParser::CCURLY, 0);
}

tree::TerminalNode* HaskellParser::Tv_bndrContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::KindContext* HaskellParser::Tv_bndrContext::kind() {
  return getRuleContext<HaskellParser::KindContext>(0);
}


size_t HaskellParser::Tv_bndrContext::getRuleIndex() const {
  return HaskellParser::RuleTv_bndr;
}

void HaskellParser::Tv_bndrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTv_bndr(this);
}

void HaskellParser::Tv_bndrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTv_bndr(this);
}

HaskellParser::Tv_bndrContext* HaskellParser::tv_bndr() {
  Tv_bndrContext *_localctx = _tracker.createInstance<Tv_bndrContext>(_ctx, getState());
  enterRule(_localctx, 230, HaskellParser::RuleTv_bndr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1813);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 206, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1802);
      tv_bndr_no_braces();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1803);
      match(HaskellParser::OCURLY);
      setState(1804);
      tyvar();
      setState(1805);
      match(HaskellParser::CCURLY);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1807);
      match(HaskellParser::OCURLY);
      setState(1808);
      tyvar();
      setState(1809);
      match(HaskellParser::DoubleColon);
      setState(1810);
      kind();
      setState(1811);
      match(HaskellParser::CCURLY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tv_bndr_no_bracesContext ------------------------------------------------------------------

HaskellParser::Tv_bndr_no_bracesContext::Tv_bndr_no_bracesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::TyvarContext* HaskellParser::Tv_bndr_no_bracesContext::tyvar() {
  return getRuleContext<HaskellParser::TyvarContext>(0);
}

tree::TerminalNode* HaskellParser::Tv_bndr_no_bracesContext::OpenRoundBracket() {
  return getToken(HaskellParser::OpenRoundBracket, 0);
}

tree::TerminalNode* HaskellParser::Tv_bndr_no_bracesContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::KindContext* HaskellParser::Tv_bndr_no_bracesContext::kind() {
  return getRuleContext<HaskellParser::KindContext>(0);
}

tree::TerminalNode* HaskellParser::Tv_bndr_no_bracesContext::CloseRoundBracket() {
  return getToken(HaskellParser::CloseRoundBracket, 0);
}


size_t HaskellParser::Tv_bndr_no_bracesContext::getRuleIndex() const {
  return HaskellParser::RuleTv_bndr_no_braces;
}

void HaskellParser::Tv_bndr_no_bracesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTv_bndr_no_braces(this);
}

void HaskellParser::Tv_bndr_no_bracesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTv_bndr_no_braces(this);
}

HaskellParser::Tv_bndr_no_bracesContext* HaskellParser::tv_bndr_no_braces() {
  Tv_bndr_no_bracesContext *_localctx = _tracker.createInstance<Tv_bndr_no_bracesContext>(_ctx, getState());
  enterRule(_localctx, 232, HaskellParser::RuleTv_bndr_no_braces);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1822);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::AS:
      case HaskellParser::HIDING:
      case HaskellParser::QUALIFIED:
      case HaskellParser::EXPORT:
      case HaskellParser::STDCALL:
      case HaskellParser::CCALL:
      case HaskellParser::CAPI:
      case HaskellParser::JSCALL:
      case HaskellParser::STOCK:
      case HaskellParser::ANYCLASS:
      case HaskellParser::VIA:
      case HaskellParser::VARID: {
        enterOuterAlt(_localctx, 1);
        setState(1815);
        tyvar();
        break;
      }

      case HaskellParser::OpenRoundBracket: {
        enterOuterAlt(_localctx, 2);
        setState(1816);
        match(HaskellParser::OpenRoundBracket);
        setState(1817);
        tyvar();
        setState(1818);
        match(HaskellParser::DoubleColon);
        setState(1819);
        kind();
        setState(1820);
        match(HaskellParser::CloseRoundBracket);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FdsContext ------------------------------------------------------------------

HaskellParser::FdsContext::FdsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::FdsContext::Pipe() {
  return getToken(HaskellParser::Pipe, 0);
}

HaskellParser::Fds1Context* HaskellParser::FdsContext::fds1() {
  return getRuleContext<HaskellParser::Fds1Context>(0);
}


size_t HaskellParser::FdsContext::getRuleIndex() const {
  return HaskellParser::RuleFds;
}

void HaskellParser::FdsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFds(this);
}

void HaskellParser::FdsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFds(this);
}

HaskellParser::FdsContext* HaskellParser::fds() {
  FdsContext *_localctx = _tracker.createInstance<FdsContext>(_ctx, getState());
  enterRule(_localctx, 234, HaskellParser::RuleFds);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1824);
    match(HaskellParser::Pipe);
    setState(1825);
    fds1();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fds1Context ------------------------------------------------------------------

HaskellParser::Fds1Context::Fds1Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::FdContext *> HaskellParser::Fds1Context::fd() {
  return getRuleContexts<HaskellParser::FdContext>();
}

HaskellParser::FdContext* HaskellParser::Fds1Context::fd(size_t i) {
  return getRuleContext<HaskellParser::FdContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::Fds1Context::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::Fds1Context::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}


size_t HaskellParser::Fds1Context::getRuleIndex() const {
  return HaskellParser::RuleFds1;
}

void HaskellParser::Fds1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFds1(this);
}

void HaskellParser::Fds1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFds1(this);
}

HaskellParser::Fds1Context* HaskellParser::fds1() {
  Fds1Context *_localctx = _tracker.createInstance<Fds1Context>(_ctx, getState());
  enterRule(_localctx, 236, HaskellParser::RuleFds1);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1827);
    fd();
    setState(1832);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Comma) {
      setState(1828);
      match(HaskellParser::Comma);
      setState(1829);
      fd();
      setState(1834);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FdContext ------------------------------------------------------------------

HaskellParser::FdContext::FdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::FdContext::Arrow() {
  return getToken(HaskellParser::Arrow, 0);
}

std::vector<HaskellParser::Varids0Context *> HaskellParser::FdContext::varids0() {
  return getRuleContexts<HaskellParser::Varids0Context>();
}

HaskellParser::Varids0Context* HaskellParser::FdContext::varids0(size_t i) {
  return getRuleContext<HaskellParser::Varids0Context>(i);
}


size_t HaskellParser::FdContext::getRuleIndex() const {
  return HaskellParser::RuleFd;
}

void HaskellParser::FdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFd(this);
}

void HaskellParser::FdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFd(this);
}

HaskellParser::FdContext* HaskellParser::fd() {
  FdContext *_localctx = _tracker.createInstance<FdContext>(_ctx, getState());
  enterRule(_localctx, 238, HaskellParser::RuleFd);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1836);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1976649193099280) != 0) || _la == HaskellParser::VARID) {
      setState(1835);
      varids0();
    }
    setState(1838);
    match(HaskellParser::Arrow);
    setState(1840);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1976649193099280) != 0) || _la == HaskellParser::VARID) {
      setState(1839);
      varids0();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Varids0Context ------------------------------------------------------------------

HaskellParser::Varids0Context::Varids0Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::TyvarContext *> HaskellParser::Varids0Context::tyvar() {
  return getRuleContexts<HaskellParser::TyvarContext>();
}

HaskellParser::TyvarContext* HaskellParser::Varids0Context::tyvar(size_t i) {
  return getRuleContext<HaskellParser::TyvarContext>(i);
}


size_t HaskellParser::Varids0Context::getRuleIndex() const {
  return HaskellParser::RuleVarids0;
}

void HaskellParser::Varids0Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarids0(this);
}

void HaskellParser::Varids0Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarids0(this);
}

HaskellParser::Varids0Context* HaskellParser::varids0() {
  Varids0Context *_localctx = _tracker.createInstance<Varids0Context>(_ctx, getState());
  enterRule(_localctx, 240, HaskellParser::RuleVarids0);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1843); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1842);
      tyvar();
      setState(1845); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1976649193099280) != 0) || _la == HaskellParser::VARID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KindContext ------------------------------------------------------------------

HaskellParser::KindContext::KindContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::CtypeContext* HaskellParser::KindContext::ctype() {
  return getRuleContext<HaskellParser::CtypeContext>(0);
}


size_t HaskellParser::KindContext::getRuleIndex() const {
  return HaskellParser::RuleKind;
}

void HaskellParser::KindContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKind(this);
}

void HaskellParser::KindContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKind(this);
}

HaskellParser::KindContext* HaskellParser::kind() {
  KindContext *_localctx = _tracker.createInstance<KindContext>(_ctx, getState());
  enterRule(_localctx, 242, HaskellParser::RuleKind);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1847);
    ctype();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Gadt_constrlistContext ------------------------------------------------------------------

HaskellParser::Gadt_constrlistContext::Gadt_constrlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Gadt_constrlistContext::WHERE() {
  return getToken(HaskellParser::WHERE, 0);
}

HaskellParser::Open_Context* HaskellParser::Gadt_constrlistContext::open_() {
  return getRuleContext<HaskellParser::Open_Context>(0);
}

HaskellParser::CloseContext* HaskellParser::Gadt_constrlistContext::close() {
  return getRuleContext<HaskellParser::CloseContext>(0);
}

HaskellParser::Gadt_constrsContext* HaskellParser::Gadt_constrlistContext::gadt_constrs() {
  return getRuleContext<HaskellParser::Gadt_constrsContext>(0);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::Gadt_constrlistContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::Gadt_constrlistContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::Gadt_constrlistContext::getRuleIndex() const {
  return HaskellParser::RuleGadt_constrlist;
}

void HaskellParser::Gadt_constrlistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGadt_constrlist(this);
}

void HaskellParser::Gadt_constrlistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGadt_constrlist(this);
}

HaskellParser::Gadt_constrlistContext* HaskellParser::gadt_constrlist() {
  Gadt_constrlistContext *_localctx = _tracker.createInstance<Gadt_constrlistContext>(_ctx, getState());
  enterRule(_localctx, 244, HaskellParser::RuleGadt_constrlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1849);
    match(HaskellParser::WHERE);
    setState(1850);
    open_();
    setState(1852);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 118) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 118)) & 533) != 0)) {
      setState(1851);
      gadt_constrs();
    }
    setState(1857);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Semi

    || _la == HaskellParser::SEMI) {
      setState(1854);
      semi();
      setState(1859);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1860);
    close();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Gadt_constrsContext ------------------------------------------------------------------

HaskellParser::Gadt_constrsContext::Gadt_constrsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::Gadt_constr_with_docContext *> HaskellParser::Gadt_constrsContext::gadt_constr_with_doc() {
  return getRuleContexts<HaskellParser::Gadt_constr_with_docContext>();
}

HaskellParser::Gadt_constr_with_docContext* HaskellParser::Gadt_constrsContext::gadt_constr_with_doc(size_t i) {
  return getRuleContext<HaskellParser::Gadt_constr_with_docContext>(i);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::Gadt_constrsContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::Gadt_constrsContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::Gadt_constrsContext::getRuleIndex() const {
  return HaskellParser::RuleGadt_constrs;
}

void HaskellParser::Gadt_constrsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGadt_constrs(this);
}

void HaskellParser::Gadt_constrsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGadt_constrs(this);
}

HaskellParser::Gadt_constrsContext* HaskellParser::gadt_constrs() {
  Gadt_constrsContext *_localctx = _tracker.createInstance<Gadt_constrsContext>(_ctx, getState());
  enterRule(_localctx, 246, HaskellParser::RuleGadt_constrs);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1862);
    gadt_constr_with_doc();
    setState(1868);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 214, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1863);
        semi();
        setState(1864);
        gadt_constr_with_doc(); 
      }
      setState(1870);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 214, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Gadt_constr_with_docContext ------------------------------------------------------------------

HaskellParser::Gadt_constr_with_docContext::Gadt_constr_with_docContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Gadt_constrContext* HaskellParser::Gadt_constr_with_docContext::gadt_constr() {
  return getRuleContext<HaskellParser::Gadt_constrContext>(0);
}


size_t HaskellParser::Gadt_constr_with_docContext::getRuleIndex() const {
  return HaskellParser::RuleGadt_constr_with_doc;
}

void HaskellParser::Gadt_constr_with_docContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGadt_constr_with_doc(this);
}

void HaskellParser::Gadt_constr_with_docContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGadt_constr_with_doc(this);
}

HaskellParser::Gadt_constr_with_docContext* HaskellParser::gadt_constr_with_doc() {
  Gadt_constr_with_docContext *_localctx = _tracker.createInstance<Gadt_constr_with_docContext>(_ctx, getState());
  enterRule(_localctx, 248, HaskellParser::RuleGadt_constr_with_doc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1871);
    gadt_constr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Gadt_constrContext ------------------------------------------------------------------

HaskellParser::Gadt_constrContext::Gadt_constrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Con_listContext* HaskellParser::Gadt_constrContext::con_list() {
  return getRuleContext<HaskellParser::Con_listContext>(0);
}

tree::TerminalNode* HaskellParser::Gadt_constrContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::SigtypedocContext* HaskellParser::Gadt_constrContext::sigtypedoc() {
  return getRuleContext<HaskellParser::SigtypedocContext>(0);
}


size_t HaskellParser::Gadt_constrContext::getRuleIndex() const {
  return HaskellParser::RuleGadt_constr;
}

void HaskellParser::Gadt_constrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGadt_constr(this);
}

void HaskellParser::Gadt_constrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGadt_constr(this);
}

HaskellParser::Gadt_constrContext* HaskellParser::gadt_constr() {
  Gadt_constrContext *_localctx = _tracker.createInstance<Gadt_constrContext>(_ctx, getState());
  enterRule(_localctx, 250, HaskellParser::RuleGadt_constr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1873);
    con_list();
    setState(1874);
    match(HaskellParser::DoubleColon);
    setState(1875);
    sigtypedoc();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstrsContext ------------------------------------------------------------------

HaskellParser::ConstrsContext::ConstrsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::ConstrsContext::Eq() {
  return getToken(HaskellParser::Eq, 0);
}

HaskellParser::Constrs1Context* HaskellParser::ConstrsContext::constrs1() {
  return getRuleContext<HaskellParser::Constrs1Context>(0);
}


size_t HaskellParser::ConstrsContext::getRuleIndex() const {
  return HaskellParser::RuleConstrs;
}

void HaskellParser::ConstrsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstrs(this);
}

void HaskellParser::ConstrsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstrs(this);
}

HaskellParser::ConstrsContext* HaskellParser::constrs() {
  ConstrsContext *_localctx = _tracker.createInstance<ConstrsContext>(_ctx, getState());
  enterRule(_localctx, 252, HaskellParser::RuleConstrs);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1877);
    match(HaskellParser::Eq);
    setState(1878);
    constrs1();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constrs1Context ------------------------------------------------------------------

HaskellParser::Constrs1Context::Constrs1Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::ConstrContext *> HaskellParser::Constrs1Context::constr() {
  return getRuleContexts<HaskellParser::ConstrContext>();
}

HaskellParser::ConstrContext* HaskellParser::Constrs1Context::constr(size_t i) {
  return getRuleContext<HaskellParser::ConstrContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::Constrs1Context::Pipe() {
  return getTokens(HaskellParser::Pipe);
}

tree::TerminalNode* HaskellParser::Constrs1Context::Pipe(size_t i) {
  return getToken(HaskellParser::Pipe, i);
}


size_t HaskellParser::Constrs1Context::getRuleIndex() const {
  return HaskellParser::RuleConstrs1;
}

void HaskellParser::Constrs1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstrs1(this);
}

void HaskellParser::Constrs1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstrs1(this);
}

HaskellParser::Constrs1Context* HaskellParser::constrs1() {
  Constrs1Context *_localctx = _tracker.createInstance<Constrs1Context>(_ctx, getState());
  enterRule(_localctx, 254, HaskellParser::RuleConstrs1);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1880);
    constr();
    setState(1885);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Pipe) {
      setState(1881);
      match(HaskellParser::Pipe);
      setState(1882);
      constr();
      setState(1887);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstrContext ------------------------------------------------------------------

HaskellParser::ConstrContext::ConstrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Constr_stuffContext* HaskellParser::ConstrContext::constr_stuff() {
  return getRuleContext<HaskellParser::Constr_stuffContext>(0);
}

HaskellParser::ForallContext* HaskellParser::ConstrContext::forall() {
  return getRuleContext<HaskellParser::ForallContext>(0);
}

HaskellParser::Constr_contextContext* HaskellParser::ConstrContext::constr_context() {
  return getRuleContext<HaskellParser::Constr_contextContext>(0);
}

tree::TerminalNode* HaskellParser::ConstrContext::DoubleArrow() {
  return getToken(HaskellParser::DoubleArrow, 0);
}


size_t HaskellParser::ConstrContext::getRuleIndex() const {
  return HaskellParser::RuleConstr;
}

void HaskellParser::ConstrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstr(this);
}

void HaskellParser::ConstrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstr(this);
}

HaskellParser::ConstrContext* HaskellParser::constr() {
  ConstrContext *_localctx = _tracker.createInstance<ConstrContext>(_ctx, getState());
  enterRule(_localctx, 256, HaskellParser::RuleConstr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1889);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::FORALL) {
      setState(1888);
      forall();
    }
    setState(1894);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 217, _ctx)) {
    case 1: {
      setState(1891);
      constr_context();
      setState(1892);
      match(HaskellParser::DoubleArrow);
      break;
    }

    default:
      break;
    }
    setState(1896);
    constr_stuff();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForallContext ------------------------------------------------------------------

HaskellParser::ForallContext::ForallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::ForallContext::FORALL() {
  return getToken(HaskellParser::FORALL, 0);
}

tree::TerminalNode* HaskellParser::ForallContext::Dot() {
  return getToken(HaskellParser::Dot, 0);
}

HaskellParser::Tv_bndrsContext* HaskellParser::ForallContext::tv_bndrs() {
  return getRuleContext<HaskellParser::Tv_bndrsContext>(0);
}


size_t HaskellParser::ForallContext::getRuleIndex() const {
  return HaskellParser::RuleForall;
}

void HaskellParser::ForallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForall(this);
}

void HaskellParser::ForallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForall(this);
}

HaskellParser::ForallContext* HaskellParser::forall() {
  ForallContext *_localctx = _tracker.createInstance<ForallContext>(_ctx, getState());
  enterRule(_localctx, 258, HaskellParser::RuleForall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1898);
    match(HaskellParser::FORALL);
    setState(1900);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1976649193099280) != 0) || ((((_la - 120) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 120)) & 4161) != 0)) {
      setState(1899);
      tv_bndrs();
    }
    setState(1902);
    match(HaskellParser::Dot);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constr_stuffContext ------------------------------------------------------------------

HaskellParser::Constr_stuffContext::Constr_stuffContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Constr_tyappsContext* HaskellParser::Constr_stuffContext::constr_tyapps() {
  return getRuleContext<HaskellParser::Constr_tyappsContext>(0);
}


size_t HaskellParser::Constr_stuffContext::getRuleIndex() const {
  return HaskellParser::RuleConstr_stuff;
}

void HaskellParser::Constr_stuffContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstr_stuff(this);
}

void HaskellParser::Constr_stuffContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstr_stuff(this);
}

HaskellParser::Constr_stuffContext* HaskellParser::constr_stuff() {
  Constr_stuffContext *_localctx = _tracker.createInstance<Constr_stuffContext>(_ctx, getState());
  enterRule(_localctx, 260, HaskellParser::RuleConstr_stuff);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1904);
    constr_tyapps();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FielddeclsContext ------------------------------------------------------------------

HaskellParser::FielddeclsContext::FielddeclsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::FielddeclContext *> HaskellParser::FielddeclsContext::fielddecl() {
  return getRuleContexts<HaskellParser::FielddeclContext>();
}

HaskellParser::FielddeclContext* HaskellParser::FielddeclsContext::fielddecl(size_t i) {
  return getRuleContext<HaskellParser::FielddeclContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::FielddeclsContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::FielddeclsContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}


size_t HaskellParser::FielddeclsContext::getRuleIndex() const {
  return HaskellParser::RuleFielddecls;
}

void HaskellParser::FielddeclsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFielddecls(this);
}

void HaskellParser::FielddeclsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFielddecls(this);
}

HaskellParser::FielddeclsContext* HaskellParser::fielddecls() {
  FielddeclsContext *_localctx = _tracker.createInstance<FielddeclsContext>(_ctx, getState());
  enterRule(_localctx, 262, HaskellParser::RuleFielddecls);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1906);
    fielddecl();
    setState(1911);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Comma) {
      setState(1907);
      match(HaskellParser::Comma);
      setState(1908);
      fielddecl();
      setState(1913);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FielddeclContext ------------------------------------------------------------------

HaskellParser::FielddeclContext::FielddeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Sig_varsContext* HaskellParser::FielddeclContext::sig_vars() {
  return getRuleContext<HaskellParser::Sig_varsContext>(0);
}

tree::TerminalNode* HaskellParser::FielddeclContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::CtypeContext* HaskellParser::FielddeclContext::ctype() {
  return getRuleContext<HaskellParser::CtypeContext>(0);
}


size_t HaskellParser::FielddeclContext::getRuleIndex() const {
  return HaskellParser::RuleFielddecl;
}

void HaskellParser::FielddeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFielddecl(this);
}

void HaskellParser::FielddeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFielddecl(this);
}

HaskellParser::FielddeclContext* HaskellParser::fielddecl() {
  FielddeclContext *_localctx = _tracker.createInstance<FielddeclContext>(_ctx, getState());
  enterRule(_localctx, 264, HaskellParser::RuleFielddecl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1914);
    sig_vars();
    setState(1915);
    match(HaskellParser::DoubleColon);
    setState(1916);
    ctype();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DerivingsContext ------------------------------------------------------------------

HaskellParser::DerivingsContext::DerivingsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::DerivingContext *> HaskellParser::DerivingsContext::deriving() {
  return getRuleContexts<HaskellParser::DerivingContext>();
}

HaskellParser::DerivingContext* HaskellParser::DerivingsContext::deriving(size_t i) {
  return getRuleContext<HaskellParser::DerivingContext>(i);
}


size_t HaskellParser::DerivingsContext::getRuleIndex() const {
  return HaskellParser::RuleDerivings;
}

void HaskellParser::DerivingsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDerivings(this);
}

void HaskellParser::DerivingsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDerivings(this);
}

HaskellParser::DerivingsContext* HaskellParser::derivings() {
  DerivingsContext *_localctx = _tracker.createInstance<DerivingsContext>(_ctx, getState());
  enterRule(_localctx, 266, HaskellParser::RuleDerivings);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1919); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1918);
      deriving();
      setState(1921); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == HaskellParser::DERIVING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DerivingContext ------------------------------------------------------------------

HaskellParser::DerivingContext::DerivingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::DerivingContext::DERIVING() {
  return getToken(HaskellParser::DERIVING, 0);
}

HaskellParser::Deriv_clause_typesContext* HaskellParser::DerivingContext::deriv_clause_types() {
  return getRuleContext<HaskellParser::Deriv_clause_typesContext>(0);
}

HaskellParser::Deriv_strategy_no_viaContext* HaskellParser::DerivingContext::deriv_strategy_no_via() {
  return getRuleContext<HaskellParser::Deriv_strategy_no_viaContext>(0);
}

HaskellParser::Deriv_strategy_viaContext* HaskellParser::DerivingContext::deriv_strategy_via() {
  return getRuleContext<HaskellParser::Deriv_strategy_viaContext>(0);
}


size_t HaskellParser::DerivingContext::getRuleIndex() const {
  return HaskellParser::RuleDeriving;
}

void HaskellParser::DerivingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeriving(this);
}

void HaskellParser::DerivingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeriving(this);
}

HaskellParser::DerivingContext* HaskellParser::deriving() {
  DerivingContext *_localctx = _tracker.createInstance<DerivingContext>(_ctx, getState());
  enterRule(_localctx, 268, HaskellParser::RuleDeriving);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1933);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1923);
      match(HaskellParser::DERIVING);
      setState(1924);
      deriv_clause_types();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1925);
      match(HaskellParser::DERIVING);
      setState(1926);
      deriv_strategy_no_via();
      setState(1927);
      deriv_clause_types();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1929);
      match(HaskellParser::DERIVING);
      setState(1930);
      deriv_clause_types();
      setState(1931);
      deriv_strategy_via();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Deriv_clause_typesContext ------------------------------------------------------------------

HaskellParser::Deriv_clause_typesContext::Deriv_clause_typesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::QtyconContext* HaskellParser::Deriv_clause_typesContext::qtycon() {
  return getRuleContext<HaskellParser::QtyconContext>(0);
}

tree::TerminalNode* HaskellParser::Deriv_clause_typesContext::OpenRoundBracket() {
  return getToken(HaskellParser::OpenRoundBracket, 0);
}

tree::TerminalNode* HaskellParser::Deriv_clause_typesContext::CloseRoundBracket() {
  return getToken(HaskellParser::CloseRoundBracket, 0);
}

HaskellParser::Deriv_typesContext* HaskellParser::Deriv_clause_typesContext::deriv_types() {
  return getRuleContext<HaskellParser::Deriv_typesContext>(0);
}


size_t HaskellParser::Deriv_clause_typesContext::getRuleIndex() const {
  return HaskellParser::RuleDeriv_clause_types;
}

void HaskellParser::Deriv_clause_typesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeriv_clause_types(this);
}

void HaskellParser::Deriv_clause_typesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeriv_clause_types(this);
}

HaskellParser::Deriv_clause_typesContext* HaskellParser::deriv_clause_types() {
  Deriv_clause_typesContext *_localctx = _tracker.createInstance<Deriv_clause_typesContext>(_ctx, getState());
  enterRule(_localctx, 270, HaskellParser::RuleDeriv_clause_types);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1942);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 222, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1935);
      qtycon();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1936);
      match(HaskellParser::OpenRoundBracket);
      setState(1937);
      match(HaskellParser::CloseRoundBracket);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1938);
      match(HaskellParser::OpenRoundBracket);
      setState(1939);
      deriv_types();
      setState(1940);
      match(HaskellParser::CloseRoundBracket);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Decl_no_thContext ------------------------------------------------------------------

HaskellParser::Decl_no_thContext::Decl_no_thContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::SigdeclContext* HaskellParser::Decl_no_thContext::sigdecl() {
  return getRuleContext<HaskellParser::SigdeclContext>(0);
}

HaskellParser::InfixexpContext* HaskellParser::Decl_no_thContext::infixexp() {
  return getRuleContext<HaskellParser::InfixexpContext>(0);
}

HaskellParser::RhsContext* HaskellParser::Decl_no_thContext::rhs() {
  return getRuleContext<HaskellParser::RhsContext>(0);
}

HaskellParser::Opt_sigContext* HaskellParser::Decl_no_thContext::opt_sig() {
  return getRuleContext<HaskellParser::Opt_sigContext>(0);
}

HaskellParser::Pattern_synonym_declContext* HaskellParser::Decl_no_thContext::pattern_synonym_decl() {
  return getRuleContext<HaskellParser::Pattern_synonym_declContext>(0);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::Decl_no_thContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::Decl_no_thContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::Decl_no_thContext::getRuleIndex() const {
  return HaskellParser::RuleDecl_no_th;
}

void HaskellParser::Decl_no_thContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecl_no_th(this);
}

void HaskellParser::Decl_no_thContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecl_no_th(this);
}

HaskellParser::Decl_no_thContext* HaskellParser::decl_no_th() {
  Decl_no_thContext *_localctx = _tracker.createInstance<Decl_no_thContext>(_ctx, getState());
  enterRule(_localctx, 272, HaskellParser::RuleDecl_no_th);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1957);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 225, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1944);
      sigdecl();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1945);
      infixexp();
      setState(1947);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DoubleColon) {
        setState(1946);
        opt_sig();
      }
      setState(1949);
      rhs();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1951);
      pattern_synonym_decl();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1953); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(1952);
                semi();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(1955); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 224, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclContext ------------------------------------------------------------------

HaskellParser::DeclContext::DeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Decl_no_thContext* HaskellParser::DeclContext::decl_no_th() {
  return getRuleContext<HaskellParser::Decl_no_thContext>(0);
}

HaskellParser::Splice_expContext* HaskellParser::DeclContext::splice_exp() {
  return getRuleContext<HaskellParser::Splice_expContext>(0);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::DeclContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::DeclContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::DeclContext::getRuleIndex() const {
  return HaskellParser::RuleDecl;
}

void HaskellParser::DeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecl(this);
}

void HaskellParser::DeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecl(this);
}

HaskellParser::DeclContext* HaskellParser::decl() {
  DeclContext *_localctx = _tracker.createInstance<DeclContext>(_ctx, getState());
  enterRule(_localctx, 274, HaskellParser::RuleDecl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1966);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 227, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1959);
      decl_no_th();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1960);
      splice_exp();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1962); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(1961);
                semi();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(1964); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 226, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RhsContext ------------------------------------------------------------------

HaskellParser::RhsContext::RhsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::RhsContext::Eq() {
  return getToken(HaskellParser::Eq, 0);
}

HaskellParser::ExpContext* HaskellParser::RhsContext::exp() {
  return getRuleContext<HaskellParser::ExpContext>(0);
}

HaskellParser::WherebindsContext* HaskellParser::RhsContext::wherebinds() {
  return getRuleContext<HaskellParser::WherebindsContext>(0);
}

HaskellParser::GdrhsContext* HaskellParser::RhsContext::gdrhs() {
  return getRuleContext<HaskellParser::GdrhsContext>(0);
}


size_t HaskellParser::RhsContext::getRuleIndex() const {
  return HaskellParser::RuleRhs;
}

void HaskellParser::RhsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRhs(this);
}

void HaskellParser::RhsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRhs(this);
}

HaskellParser::RhsContext* HaskellParser::rhs() {
  RhsContext *_localctx = _tracker.createInstance<RhsContext>(_ctx, getState());
  enterRule(_localctx, 276, HaskellParser::RuleRhs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1977);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::Eq: {
        enterOuterAlt(_localctx, 1);
        setState(1968);
        match(HaskellParser::Eq);
        setState(1969);
        exp();
        setState(1971);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HaskellParser::WHERE) {
          setState(1970);
          wherebinds();
        }
        break;
      }

      case HaskellParser::Pipe: {
        enterOuterAlt(_localctx, 2);
        setState(1973);
        gdrhs();
        setState(1975);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HaskellParser::WHERE) {
          setState(1974);
          wherebinds();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GdrhsContext ------------------------------------------------------------------

HaskellParser::GdrhsContext::GdrhsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::GdrhContext *> HaskellParser::GdrhsContext::gdrh() {
  return getRuleContexts<HaskellParser::GdrhContext>();
}

HaskellParser::GdrhContext* HaskellParser::GdrhsContext::gdrh(size_t i) {
  return getRuleContext<HaskellParser::GdrhContext>(i);
}


size_t HaskellParser::GdrhsContext::getRuleIndex() const {
  return HaskellParser::RuleGdrhs;
}

void HaskellParser::GdrhsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGdrhs(this);
}

void HaskellParser::GdrhsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGdrhs(this);
}

HaskellParser::GdrhsContext* HaskellParser::gdrhs() {
  GdrhsContext *_localctx = _tracker.createInstance<GdrhsContext>(_ctx, getState());
  enterRule(_localctx, 278, HaskellParser::RuleGdrhs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1980); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1979);
      gdrh();
      setState(1982); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == HaskellParser::Pipe);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GdrhContext ------------------------------------------------------------------

HaskellParser::GdrhContext::GdrhContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::GdrhContext::Pipe() {
  return getToken(HaskellParser::Pipe, 0);
}

HaskellParser::GuardsContext* HaskellParser::GdrhContext::guards() {
  return getRuleContext<HaskellParser::GuardsContext>(0);
}

tree::TerminalNode* HaskellParser::GdrhContext::Eq() {
  return getToken(HaskellParser::Eq, 0);
}

HaskellParser::ExpContext* HaskellParser::GdrhContext::exp() {
  return getRuleContext<HaskellParser::ExpContext>(0);
}


size_t HaskellParser::GdrhContext::getRuleIndex() const {
  return HaskellParser::RuleGdrh;
}

void HaskellParser::GdrhContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGdrh(this);
}

void HaskellParser::GdrhContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGdrh(this);
}

HaskellParser::GdrhContext* HaskellParser::gdrh() {
  GdrhContext *_localctx = _tracker.createInstance<GdrhContext>(_ctx, getState());
  enterRule(_localctx, 280, HaskellParser::RuleGdrh);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1984);
    match(HaskellParser::Pipe);
    setState(1985);
    guards();
    setState(1986);
    match(HaskellParser::Eq);
    setState(1987);
    exp();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SigdeclContext ------------------------------------------------------------------

HaskellParser::SigdeclContext::SigdeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::InfixexpContext* HaskellParser::SigdeclContext::infixexp() {
  return getRuleContext<HaskellParser::InfixexpContext>(0);
}

tree::TerminalNode* HaskellParser::SigdeclContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::SigtypedocContext* HaskellParser::SigdeclContext::sigtypedoc() {
  return getRuleContext<HaskellParser::SigtypedocContext>(0);
}

HaskellParser::Var_Context* HaskellParser::SigdeclContext::var_() {
  return getRuleContext<HaskellParser::Var_Context>(0);
}

tree::TerminalNode* HaskellParser::SigdeclContext::Comma() {
  return getToken(HaskellParser::Comma, 0);
}

HaskellParser::Sig_varsContext* HaskellParser::SigdeclContext::sig_vars() {
  return getRuleContext<HaskellParser::Sig_varsContext>(0);
}

HaskellParser::FixityContext* HaskellParser::SigdeclContext::fixity() {
  return getRuleContext<HaskellParser::FixityContext>(0);
}

HaskellParser::OpsContext* HaskellParser::SigdeclContext::ops() {
  return getRuleContext<HaskellParser::OpsContext>(0);
}

HaskellParser::IntegerContext* HaskellParser::SigdeclContext::integer() {
  return getRuleContext<HaskellParser::IntegerContext>(0);
}

HaskellParser::Pattern_synonym_sigContext* HaskellParser::SigdeclContext::pattern_synonym_sig() {
  return getRuleContext<HaskellParser::Pattern_synonym_sigContext>(0);
}

tree::TerminalNode* HaskellParser::SigdeclContext::OpenPragmaBracket() {
  return getToken(HaskellParser::OpenPragmaBracket, 0);
}

tree::TerminalNode* HaskellParser::SigdeclContext::COMPLETE() {
  return getToken(HaskellParser::COMPLETE, 0);
}

HaskellParser::Con_listContext* HaskellParser::SigdeclContext::con_list() {
  return getRuleContext<HaskellParser::Con_listContext>(0);
}

std::vector<tree::TerminalNode *> HaskellParser::SigdeclContext::ClosePragmaBracket() {
  return getTokens(HaskellParser::ClosePragmaBracket);
}

tree::TerminalNode* HaskellParser::SigdeclContext::ClosePragmaBracket(size_t i) {
  return getToken(HaskellParser::ClosePragmaBracket, i);
}

HaskellParser::Opt_tyconsigContext* HaskellParser::SigdeclContext::opt_tyconsig() {
  return getRuleContext<HaskellParser::Opt_tyconsigContext>(0);
}

tree::TerminalNode* HaskellParser::SigdeclContext::INLINE() {
  return getToken(HaskellParser::INLINE, 0);
}

HaskellParser::QvarContext* HaskellParser::SigdeclContext::qvar() {
  return getRuleContext<HaskellParser::QvarContext>(0);
}

HaskellParser::ActivationContext* HaskellParser::SigdeclContext::activation() {
  return getRuleContext<HaskellParser::ActivationContext>(0);
}

tree::TerminalNode* HaskellParser::SigdeclContext::SCC() {
  return getToken(HaskellParser::SCC, 0);
}

HaskellParser::PstringContext* HaskellParser::SigdeclContext::pstring() {
  return getRuleContext<HaskellParser::PstringContext>(0);
}

tree::TerminalNode* HaskellParser::SigdeclContext::SPECIALISE() {
  return getToken(HaskellParser::SPECIALISE, 0);
}

HaskellParser::Sigtypes1Context* HaskellParser::SigdeclContext::sigtypes1() {
  return getRuleContext<HaskellParser::Sigtypes1Context>(0);
}

tree::TerminalNode* HaskellParser::SigdeclContext::SPECINLINE() {
  return getToken(HaskellParser::SPECINLINE, 0);
}

tree::TerminalNode* HaskellParser::SigdeclContext::INSTANCE() {
  return getToken(HaskellParser::INSTANCE, 0);
}

HaskellParser::Inst_typeContext* HaskellParser::SigdeclContext::inst_type() {
  return getRuleContext<HaskellParser::Inst_typeContext>(0);
}

tree::TerminalNode* HaskellParser::SigdeclContext::MINIMAL() {
  return getToken(HaskellParser::MINIMAL, 0);
}

HaskellParser::Name_boolformula_optContext* HaskellParser::SigdeclContext::name_boolformula_opt() {
  return getRuleContext<HaskellParser::Name_boolformula_optContext>(0);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::SigdeclContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::SigdeclContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::SigdeclContext::getRuleIndex() const {
  return HaskellParser::RuleSigdecl;
}

void HaskellParser::SigdeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSigdecl(this);
}

void HaskellParser::SigdeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSigdecl(this);
}

HaskellParser::SigdeclContext* HaskellParser::sigdecl() {
  SigdeclContext *_localctx = _tracker.createInstance<SigdeclContext>(_ctx, getState());
  enterRule(_localctx, 282, HaskellParser::RuleSigdecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(2068);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 240, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1989);
      infixexp();
      setState(1990);
      match(HaskellParser::DoubleColon);
      setState(1991);
      sigtypedoc();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1993);
      var_();
      setState(1994);
      match(HaskellParser::Comma);
      setState(1995);
      sig_vars();
      setState(1996);
      match(HaskellParser::DoubleColon);
      setState(1997);
      sigtypedoc();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1999);
      fixity();
      setState(2001);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 137) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 137)) & 7) != 0)) {
        setState(2000);
        integer();
      }
      setState(2003);
      ops();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2005);
      pattern_synonym_sig();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2006);
      match(HaskellParser::OpenPragmaBracket);
      setState(2007);
      match(HaskellParser::COMPLETE);
      setState(2008);
      con_list();
      setState(2010);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::DoubleColon) {
        setState(2009);
        opt_tyconsig();
      }
      setState(2012);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2014);
      match(HaskellParser::OpenPragmaBracket);
      setState(2015);
      match(HaskellParser::INLINE);
      setState(2017);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::OpenSquareBracket) {
        setState(2016);
        activation();
      }
      setState(2019);
      qvar();
      setState(2020);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2022);
      match(HaskellParser::OpenPragmaBracket);
      setState(2023);
      match(HaskellParser::SCC);
      setState(2024);
      qvar();
      setState(2026);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::STRING) {
        setState(2025);
        pstring();
      }
      setState(2028);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2030);
      match(HaskellParser::OpenPragmaBracket);
      setState(2031);
      match(HaskellParser::SPECIALISE);
      setState(2033);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::OpenSquareBracket) {
        setState(2032);
        activation();
      }
      setState(2035);
      qvar();
      setState(2036);
      match(HaskellParser::DoubleColon);
      setState(2037);
      sigtypes1();
      setState(2038);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2040);
      match(HaskellParser::OpenPragmaBracket);
      setState(2041);
      match(HaskellParser::SPECINLINE);
      setState(2043);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::OpenSquareBracket) {
        setState(2042);
        activation();
      }
      setState(2045);
      qvar();
      setState(2046);
      match(HaskellParser::DoubleColon);
      setState(2047);
      sigtypes1();
      setState(2048);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(2050);
      match(HaskellParser::OpenPragmaBracket);
      setState(2051);
      match(HaskellParser::SPECIALISE);
      setState(2052);
      match(HaskellParser::INSTANCE);
      setState(2053);
      inst_type();
      setState(2054);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(2056);
      match(HaskellParser::OpenPragmaBracket);
      setState(2057);
      match(HaskellParser::MINIMAL);
      setState(2058);
      match(HaskellParser::ClosePragmaBracket);
      setState(2060);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 1976649193099280) != 0) || ((((_la - 118) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 118)) & 789) != 0)) {
        setState(2059);
        name_boolformula_opt();
      }
      setState(2062);
      match(HaskellParser::ClosePragmaBracket);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(2064); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(2063);
                semi();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(2066); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 239, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ActivationContext ------------------------------------------------------------------

HaskellParser::ActivationContext::ActivationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::ActivationContext::OpenSquareBracket() {
  return getToken(HaskellParser::OpenSquareBracket, 0);
}

HaskellParser::IntegerContext* HaskellParser::ActivationContext::integer() {
  return getRuleContext<HaskellParser::IntegerContext>(0);
}

tree::TerminalNode* HaskellParser::ActivationContext::CloseSquareBracket() {
  return getToken(HaskellParser::CloseSquareBracket, 0);
}

HaskellParser::Rule_activation_markerContext* HaskellParser::ActivationContext::rule_activation_marker() {
  return getRuleContext<HaskellParser::Rule_activation_markerContext>(0);
}


size_t HaskellParser::ActivationContext::getRuleIndex() const {
  return HaskellParser::RuleActivation;
}

void HaskellParser::ActivationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterActivation(this);
}

void HaskellParser::ActivationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitActivation(this);
}

HaskellParser::ActivationContext* HaskellParser::activation() {
  ActivationContext *_localctx = _tracker.createInstance<ActivationContext>(_ctx, getState());
  enterRule(_localctx, 284, HaskellParser::RuleActivation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2079);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 241, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2070);
      match(HaskellParser::OpenSquareBracket);
      setState(2071);
      integer();
      setState(2072);
      match(HaskellParser::CloseSquareBracket);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2074);
      match(HaskellParser::OpenSquareBracket);
      setState(2075);
      rule_activation_marker();
      setState(2076);
      integer();
      setState(2077);
      match(HaskellParser::CloseSquareBracket);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Th_quasiquoteContext ------------------------------------------------------------------

HaskellParser::Th_quasiquoteContext::Th_quasiquoteContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Th_quasiquoteContext::OpenSquareBracket() {
  return getToken(HaskellParser::OpenSquareBracket, 0);
}

HaskellParser::VaridContext* HaskellParser::Th_quasiquoteContext::varid() {
  return getRuleContext<HaskellParser::VaridContext>(0);
}

tree::TerminalNode* HaskellParser::Th_quasiquoteContext::Pipe() {
  return getToken(HaskellParser::Pipe, 0);
}


size_t HaskellParser::Th_quasiquoteContext::getRuleIndex() const {
  return HaskellParser::RuleTh_quasiquote;
}

void HaskellParser::Th_quasiquoteContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTh_quasiquote(this);
}

void HaskellParser::Th_quasiquoteContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTh_quasiquote(this);
}

HaskellParser::Th_quasiquoteContext* HaskellParser::th_quasiquote() {
  Th_quasiquoteContext *_localctx = _tracker.createInstance<Th_quasiquoteContext>(_ctx, getState());
  enterRule(_localctx, 286, HaskellParser::RuleTh_quasiquote);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2081);
    match(HaskellParser::OpenSquareBracket);
    setState(2082);
    varid();
    setState(2083);
    match(HaskellParser::Pipe);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Th_qquasiquoteContext ------------------------------------------------------------------

HaskellParser::Th_qquasiquoteContext::Th_qquasiquoteContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Th_qquasiquoteContext::OpenSquareBracket() {
  return getToken(HaskellParser::OpenSquareBracket, 0);
}

HaskellParser::QvaridContext* HaskellParser::Th_qquasiquoteContext::qvarid() {
  return getRuleContext<HaskellParser::QvaridContext>(0);
}

tree::TerminalNode* HaskellParser::Th_qquasiquoteContext::Pipe() {
  return getToken(HaskellParser::Pipe, 0);
}


size_t HaskellParser::Th_qquasiquoteContext::getRuleIndex() const {
  return HaskellParser::RuleTh_qquasiquote;
}

void HaskellParser::Th_qquasiquoteContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTh_qquasiquote(this);
}

void HaskellParser::Th_qquasiquoteContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTh_qquasiquote(this);
}

HaskellParser::Th_qquasiquoteContext* HaskellParser::th_qquasiquote() {
  Th_qquasiquoteContext *_localctx = _tracker.createInstance<Th_qquasiquoteContext>(_ctx, getState());
  enterRule(_localctx, 288, HaskellParser::RuleTh_qquasiquote);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2085);
    match(HaskellParser::OpenSquareBracket);
    setState(2086);
    qvarid();
    setState(2087);
    match(HaskellParser::Pipe);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuasiquoteContext ------------------------------------------------------------------

HaskellParser::QuasiquoteContext::QuasiquoteContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Th_quasiquoteContext* HaskellParser::QuasiquoteContext::th_quasiquote() {
  return getRuleContext<HaskellParser::Th_quasiquoteContext>(0);
}

HaskellParser::Th_qquasiquoteContext* HaskellParser::QuasiquoteContext::th_qquasiquote() {
  return getRuleContext<HaskellParser::Th_qquasiquoteContext>(0);
}


size_t HaskellParser::QuasiquoteContext::getRuleIndex() const {
  return HaskellParser::RuleQuasiquote;
}

void HaskellParser::QuasiquoteContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuasiquote(this);
}

void HaskellParser::QuasiquoteContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuasiquote(this);
}

HaskellParser::QuasiquoteContext* HaskellParser::quasiquote() {
  QuasiquoteContext *_localctx = _tracker.createInstance<QuasiquoteContext>(_ctx, getState());
  enterRule(_localctx, 290, HaskellParser::RuleQuasiquote);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2091);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2089);
      th_quasiquote();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2090);
      th_qquasiquote();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpContext ------------------------------------------------------------------

HaskellParser::ExpContext::ExpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::InfixexpContext* HaskellParser::ExpContext::infixexp() {
  return getRuleContext<HaskellParser::InfixexpContext>(0);
}

tree::TerminalNode* HaskellParser::ExpContext::DoubleColon() {
  return getToken(HaskellParser::DoubleColon, 0);
}

HaskellParser::SigtypeContext* HaskellParser::ExpContext::sigtype() {
  return getRuleContext<HaskellParser::SigtypeContext>(0);
}

tree::TerminalNode* HaskellParser::ExpContext::LarrowTail() {
  return getToken(HaskellParser::LarrowTail, 0);
}

HaskellParser::ExpContext* HaskellParser::ExpContext::exp() {
  return getRuleContext<HaskellParser::ExpContext>(0);
}

tree::TerminalNode* HaskellParser::ExpContext::RarrowTail() {
  return getToken(HaskellParser::RarrowTail, 0);
}

tree::TerminalNode* HaskellParser::ExpContext::LLarrowTail() {
  return getToken(HaskellParser::LLarrowTail, 0);
}

tree::TerminalNode* HaskellParser::ExpContext::RRarrowTail() {
  return getToken(HaskellParser::RRarrowTail, 0);
}


size_t HaskellParser::ExpContext::getRuleIndex() const {
  return HaskellParser::RuleExp;
}

void HaskellParser::ExpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExp(this);
}

void HaskellParser::ExpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExp(this);
}

HaskellParser::ExpContext* HaskellParser::exp() {
  ExpContext *_localctx = _tracker.createInstance<ExpContext>(_ctx, getState());
  enterRule(_localctx, 292, HaskellParser::RuleExp);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2114);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 243, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2093);
      infixexp();
      setState(2094);
      match(HaskellParser::DoubleColon);
      setState(2095);
      sigtype();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2097);
      infixexp();
      setState(2098);
      match(HaskellParser::LarrowTail);
      setState(2099);
      exp();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2101);
      infixexp();
      setState(2102);
      match(HaskellParser::RarrowTail);
      setState(2103);
      exp();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2105);
      infixexp();
      setState(2106);
      match(HaskellParser::LLarrowTail);
      setState(2107);
      exp();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2109);
      infixexp();
      setState(2110);
      match(HaskellParser::RRarrowTail);
      setState(2111);
      exp();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2113);
      infixexp();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InfixexpContext ------------------------------------------------------------------

HaskellParser::InfixexpContext::InfixexpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Exp10Context* HaskellParser::InfixexpContext::exp10() {
  return getRuleContext<HaskellParser::Exp10Context>(0);
}

std::vector<HaskellParser::QopContext *> HaskellParser::InfixexpContext::qop() {
  return getRuleContexts<HaskellParser::QopContext>();
}

HaskellParser::QopContext* HaskellParser::InfixexpContext::qop(size_t i) {
  return getRuleContext<HaskellParser::QopContext>(i);
}

std::vector<HaskellParser::Exp10pContext *> HaskellParser::InfixexpContext::exp10p() {
  return getRuleContexts<HaskellParser::Exp10pContext>();
}

HaskellParser::Exp10pContext* HaskellParser::InfixexpContext::exp10p(size_t i) {
  return getRuleContext<HaskellParser::Exp10pContext>(i);
}


size_t HaskellParser::InfixexpContext::getRuleIndex() const {
  return HaskellParser::RuleInfixexp;
}

void HaskellParser::InfixexpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInfixexp(this);
}

void HaskellParser::InfixexpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInfixexp(this);
}

HaskellParser::InfixexpContext* HaskellParser::infixexp() {
  InfixexpContext *_localctx = _tracker.createInstance<InfixexpContext>(_ctx, getState());
  enterRule(_localctx, 294, HaskellParser::RuleInfixexp);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2116);
    exp10();
    setState(2122);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 244, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2117);
        qop();
        setState(2118);
        exp10p(); 
      }
      setState(2124);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 244, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Exp10pContext ------------------------------------------------------------------

HaskellParser::Exp10pContext::Exp10pContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Exp10Context* HaskellParser::Exp10pContext::exp10() {
  return getRuleContext<HaskellParser::Exp10Context>(0);
}


size_t HaskellParser::Exp10pContext::getRuleIndex() const {
  return HaskellParser::RuleExp10p;
}

void HaskellParser::Exp10pContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExp10p(this);
}

void HaskellParser::Exp10pContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExp10p(this);
}

HaskellParser::Exp10pContext* HaskellParser::exp10p() {
  Exp10pContext *_localctx = _tracker.createInstance<Exp10pContext>(_ctx, getState());
  enterRule(_localctx, 296, HaskellParser::RuleExp10p);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2125);
    exp10();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Exp10Context ------------------------------------------------------------------

HaskellParser::Exp10Context::Exp10Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::FexpContext* HaskellParser::Exp10Context::fexp() {
  return getRuleContext<HaskellParser::FexpContext>(0);
}

tree::TerminalNode* HaskellParser::Exp10Context::Minus() {
  return getToken(HaskellParser::Minus, 0);
}


size_t HaskellParser::Exp10Context::getRuleIndex() const {
  return HaskellParser::RuleExp10;
}

void HaskellParser::Exp10Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExp10(this);
}

void HaskellParser::Exp10Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExp10(this);
}

HaskellParser::Exp10Context* HaskellParser::exp10() {
  Exp10Context *_localctx = _tracker.createInstance<Exp10Context>(_ctx, getState());
  enterRule(_localctx, 298, HaskellParser::RuleExp10);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2128);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::Minus) {
      setState(2127);
      match(HaskellParser::Minus);
    }
    setState(2130);
    fexp();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FexpContext ------------------------------------------------------------------

HaskellParser::FexpContext::FexpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::AexpContext *> HaskellParser::FexpContext::aexp() {
  return getRuleContexts<HaskellParser::AexpContext>();
}

HaskellParser::AexpContext* HaskellParser::FexpContext::aexp(size_t i) {
  return getRuleContext<HaskellParser::AexpContext>(i);
}

tree::TerminalNode* HaskellParser::FexpContext::Atsign() {
  return getToken(HaskellParser::Atsign, 0);
}

HaskellParser::AtypeContext* HaskellParser::FexpContext::atype() {
  return getRuleContext<HaskellParser::AtypeContext>(0);
}


size_t HaskellParser::FexpContext::getRuleIndex() const {
  return HaskellParser::RuleFexp;
}

void HaskellParser::FexpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFexp(this);
}

void HaskellParser::FexpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFexp(this);
}

HaskellParser::FexpContext* HaskellParser::fexp() {
  FexpContext *_localctx = _tracker.createInstance<FexpContext>(_ctx, getState());
  enterRule(_localctx, 300, HaskellParser::RuleFexp);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2133); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(2132);
              aexp();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(2135); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 246, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(2139);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 247, _ctx)) {
    case 1: {
      setState(2137);
      match(HaskellParser::Atsign);
      setState(2138);
      atype();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AexpContext ------------------------------------------------------------------

HaskellParser::AexpContext::AexpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::QvarContext* HaskellParser::AexpContext::qvar() {
  return getRuleContext<HaskellParser::QvarContext>(0);
}

tree::TerminalNode* HaskellParser::AexpContext::Atsign() {
  return getToken(HaskellParser::Atsign, 0);
}

HaskellParser::AexpContext* HaskellParser::AexpContext::aexp() {
  return getRuleContext<HaskellParser::AexpContext>(0);
}

tree::TerminalNode* HaskellParser::AexpContext::Tilde() {
  return getToken(HaskellParser::Tilde, 0);
}

tree::TerminalNode* HaskellParser::AexpContext::Bang() {
  return getToken(HaskellParser::Bang, 0);
}

tree::TerminalNode* HaskellParser::AexpContext::ReverseSlash() {
  return getToken(HaskellParser::ReverseSlash, 0);
}

HaskellParser::ApatsContext* HaskellParser::AexpContext::apats() {
  return getRuleContext<HaskellParser::ApatsContext>(0);
}

tree::TerminalNode* HaskellParser::AexpContext::Arrow() {
  return getToken(HaskellParser::Arrow, 0);
}

std::vector<HaskellParser::ExpContext *> HaskellParser::AexpContext::exp() {
  return getRuleContexts<HaskellParser::ExpContext>();
}

HaskellParser::ExpContext* HaskellParser::AexpContext::exp(size_t i) {
  return getRuleContext<HaskellParser::ExpContext>(i);
}

tree::TerminalNode* HaskellParser::AexpContext::LET() {
  return getToken(HaskellParser::LET, 0);
}

HaskellParser::DecllistContext* HaskellParser::AexpContext::decllist() {
  return getRuleContext<HaskellParser::DecllistContext>(0);
}

tree::TerminalNode* HaskellParser::AexpContext::IN() {
  return getToken(HaskellParser::IN, 0);
}

tree::TerminalNode* HaskellParser::AexpContext::LCASE() {
  return getToken(HaskellParser::LCASE, 0);
}

HaskellParser::AltsContext* HaskellParser::AexpContext::alts() {
  return getRuleContext<HaskellParser::AltsContext>(0);
}

tree::TerminalNode* HaskellParser::AexpContext::IF() {
  return getToken(HaskellParser::IF, 0);
}

tree::TerminalNode* HaskellParser::AexpContext::THEN() {
  return getToken(HaskellParser::THEN, 0);
}

tree::TerminalNode* HaskellParser::AexpContext::ELSE() {
  return getToken(HaskellParser::ELSE, 0);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::AexpContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::AexpContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}

HaskellParser::IfgdpatsContext* HaskellParser::AexpContext::ifgdpats() {
  return getRuleContext<HaskellParser::IfgdpatsContext>(0);
}

tree::TerminalNode* HaskellParser::AexpContext::CASE() {
  return getToken(HaskellParser::CASE, 0);
}

tree::TerminalNode* HaskellParser::AexpContext::OF() {
  return getToken(HaskellParser::OF, 0);
}

tree::TerminalNode* HaskellParser::AexpContext::DO() {
  return getToken(HaskellParser::DO, 0);
}

HaskellParser::StmtlistContext* HaskellParser::AexpContext::stmtlist() {
  return getRuleContext<HaskellParser::StmtlistContext>(0);
}

tree::TerminalNode* HaskellParser::AexpContext::MDO() {
  return getToken(HaskellParser::MDO, 0);
}

HaskellParser::Aexp1Context* HaskellParser::AexpContext::aexp1() {
  return getRuleContext<HaskellParser::Aexp1Context>(0);
}


size_t HaskellParser::AexpContext::getRuleIndex() const {
  return HaskellParser::RuleAexp;
}

void HaskellParser::AexpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAexp(this);
}

void HaskellParser::AexpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAexp(this);
}

HaskellParser::AexpContext* HaskellParser::aexp() {
  AexpContext *_localctx = _tracker.createInstance<AexpContext>(_ctx, getState());
  enterRule(_localctx, 302, HaskellParser::RuleAexp);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2186);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 250, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2141);
      qvar();
      setState(2142);
      match(HaskellParser::Atsign);
      setState(2143);
      aexp();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2145);
      match(HaskellParser::Tilde);
      setState(2146);
      aexp();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2147);
      match(HaskellParser::Bang);
      setState(2148);
      aexp();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2149);
      match(HaskellParser::ReverseSlash);
      setState(2150);
      apats();
      setState(2151);
      match(HaskellParser::Arrow);
      setState(2152);
      exp();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2154);
      match(HaskellParser::LET);
      setState(2155);
      decllist();
      setState(2156);
      match(HaskellParser::IN);
      setState(2157);
      exp();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2159);
      match(HaskellParser::LCASE);
      setState(2160);
      alts();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2161);
      match(HaskellParser::IF);
      setState(2162);
      exp();
      setState(2164);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::Semi

      || _la == HaskellParser::SEMI) {
        setState(2163);
        semi();
      }
      setState(2166);
      match(HaskellParser::THEN);
      setState(2167);
      exp();
      setState(2169);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::Semi

      || _la == HaskellParser::SEMI) {
        setState(2168);
        semi();
      }
      setState(2171);
      match(HaskellParser::ELSE);
      setState(2172);
      exp();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2174);
      match(HaskellParser::IF);
      setState(2175);
      ifgdpats();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2176);
      match(HaskellParser::CASE);
      setState(2177);
      exp();
      setState(2178);
      match(HaskellParser::OF);
      setState(2179);
      alts();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(2181);
      match(HaskellParser::DO);
      setState(2182);
      stmtlist();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(2183);
      match(HaskellParser::MDO);
      setState(2184);
      stmtlist();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(2185);
      aexp1();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Aexp1Context ------------------------------------------------------------------

HaskellParser::Aexp1Context::Aexp1Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Aexp2Context* HaskellParser::Aexp1Context::aexp2() {
  return getRuleContext<HaskellParser::Aexp2Context>(0);
}

std::vector<tree::TerminalNode *> HaskellParser::Aexp1Context::OCURLY() {
  return getTokens(HaskellParser::OCURLY);
}

tree::TerminalNode* HaskellParser::Aexp1Context::OCURLY(size_t i) {
  return getToken(HaskellParser::OCURLY, i);
}

std::vector<tree::TerminalNode *> HaskellParser::Aexp1Context::CCURLY() {
  return getTokens(HaskellParser::CCURLY);
}

tree::TerminalNode* HaskellParser::Aexp1Context::CCURLY(size_t i) {
  return getToken(HaskellParser::CCURLY, i);
}

std::vector<HaskellParser::FbindsContext *> HaskellParser::Aexp1Context::fbinds() {
  return getRuleContexts<HaskellParser::FbindsContext>();
}

HaskellParser::FbindsContext* HaskellParser::Aexp1Context::fbinds(size_t i) {
  return getRuleContext<HaskellParser::FbindsContext>(i);
}


size_t HaskellParser::Aexp1Context::getRuleIndex() const {
  return HaskellParser::RuleAexp1;
}

void HaskellParser::Aexp1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAexp1(this);
}

void HaskellParser::Aexp1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAexp1(this);
}

HaskellParser::Aexp1Context* HaskellParser::aexp1() {
  Aexp1Context *_localctx = _tracker.createInstance<Aexp1Context>(_ctx, getState());
  enterRule(_localctx, 304, HaskellParser::RuleAexp1);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2188);
    aexp2();
    setState(2196);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 252, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2189);
        match(HaskellParser::OCURLY);
        setState(2191);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 1976649193099280) != 0) || ((((_la - 98) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 98)) & 809500673) != 0)) {
          setState(2190);
          fbinds();
        }
        setState(2193);
        match(HaskellParser::CCURLY); 
      }
      setState(2198);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 252, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Aexp2Context ------------------------------------------------------------------

HaskellParser::Aexp2Context::Aexp2Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::QvarContext* HaskellParser::Aexp2Context::qvar() {
  return getRuleContext<HaskellParser::QvarContext>(0);
}

HaskellParser::QconContext* HaskellParser::Aexp2Context::qcon() {
  return getRuleContext<HaskellParser::QconContext>(0);
}

HaskellParser::VaridContext* HaskellParser::Aexp2Context::varid() {
  return getRuleContext<HaskellParser::VaridContext>(0);
}

HaskellParser::LiteralContext* HaskellParser::Aexp2Context::literal() {
  return getRuleContext<HaskellParser::LiteralContext>(0);
}

HaskellParser::PstringContext* HaskellParser::Aexp2Context::pstring() {
  return getRuleContext<HaskellParser::PstringContext>(0);
}

HaskellParser::IntegerContext* HaskellParser::Aexp2Context::integer() {
  return getRuleContext<HaskellParser::IntegerContext>(0);
}

HaskellParser::PfloatContext* HaskellParser::Aexp2Context::pfloat() {
  return getRuleContext<HaskellParser::PfloatContext>(0);
}

tree::TerminalNode* HaskellParser::Aexp2Context::OpenRoundBracket() {
  return getToken(HaskellParser::OpenRoundBracket, 0);
}

HaskellParser::TexpContext* HaskellParser::Aexp2Context::texp() {
  return getRuleContext<HaskellParser::TexpContext>(0);
}

tree::TerminalNode* HaskellParser::Aexp2Context::CloseRoundBracket() {
  return getToken(HaskellParser::CloseRoundBracket, 0);
}

HaskellParser::Tup_exprsContext* HaskellParser::Aexp2Context::tup_exprs() {
  return getRuleContext<HaskellParser::Tup_exprsContext>(0);
}

tree::TerminalNode* HaskellParser::Aexp2Context::OpenBoxParen() {
  return getToken(HaskellParser::OpenBoxParen, 0);
}

tree::TerminalNode* HaskellParser::Aexp2Context::CloseBoxParen() {
  return getToken(HaskellParser::CloseBoxParen, 0);
}

tree::TerminalNode* HaskellParser::Aexp2Context::OpenSquareBracket() {
  return getToken(HaskellParser::OpenSquareBracket, 0);
}

HaskellParser::List_Context* HaskellParser::Aexp2Context::list_() {
  return getRuleContext<HaskellParser::List_Context>(0);
}

tree::TerminalNode* HaskellParser::Aexp2Context::CloseSquareBracket() {
  return getToken(HaskellParser::CloseSquareBracket, 0);
}

tree::TerminalNode* HaskellParser::Aexp2Context::WILDCARD() {
  return getToken(HaskellParser::WILDCARD, 0);
}

HaskellParser::Splice_untypedContext* HaskellParser::Aexp2Context::splice_untyped() {
  return getRuleContext<HaskellParser::Splice_untypedContext>(0);
}

HaskellParser::Splice_typedContext* HaskellParser::Aexp2Context::splice_typed() {
  return getRuleContext<HaskellParser::Splice_typedContext>(0);
}

tree::TerminalNode* HaskellParser::Aexp2Context::Quote() {
  return getToken(HaskellParser::Quote, 0);
}

tree::TerminalNode* HaskellParser::Aexp2Context::DoubleQuote() {
  return getToken(HaskellParser::DoubleQuote, 0);
}

HaskellParser::TyvarContext* HaskellParser::Aexp2Context::tyvar() {
  return getRuleContext<HaskellParser::TyvarContext>(0);
}

HaskellParser::GtyconContext* HaskellParser::Aexp2Context::gtycon() {
  return getRuleContext<HaskellParser::GtyconContext>(0);
}

tree::TerminalNode* HaskellParser::Aexp2Context::TopenExpQuote() {
  return getToken(HaskellParser::TopenExpQuote, 0);
}

HaskellParser::ExpContext* HaskellParser::Aexp2Context::exp() {
  return getRuleContext<HaskellParser::ExpContext>(0);
}

tree::TerminalNode* HaskellParser::Aexp2Context::TcloseQoute() {
  return getToken(HaskellParser::TcloseQoute, 0);
}

tree::TerminalNode* HaskellParser::Aexp2Context::TopenTexpQuote() {
  return getToken(HaskellParser::TopenTexpQuote, 0);
}

tree::TerminalNode* HaskellParser::Aexp2Context::TcloseTExpQoute() {
  return getToken(HaskellParser::TcloseTExpQoute, 0);
}

tree::TerminalNode* HaskellParser::Aexp2Context::TopenTypQoute() {
  return getToken(HaskellParser::TopenTypQoute, 0);
}

HaskellParser::KtypeContext* HaskellParser::Aexp2Context::ktype() {
  return getRuleContext<HaskellParser::KtypeContext>(0);
}

tree::TerminalNode* HaskellParser::Aexp2Context::TopenPatQuote() {
  return getToken(HaskellParser::TopenPatQuote, 0);
}

HaskellParser::InfixexpContext* HaskellParser::Aexp2Context::infixexp() {
  return getRuleContext<HaskellParser::InfixexpContext>(0);
}

tree::TerminalNode* HaskellParser::Aexp2Context::TopenDecQoute() {
  return getToken(HaskellParser::TopenDecQoute, 0);
}

HaskellParser::CvtopbodyContext* HaskellParser::Aexp2Context::cvtopbody() {
  return getRuleContext<HaskellParser::CvtopbodyContext>(0);
}

HaskellParser::QuasiquoteContext* HaskellParser::Aexp2Context::quasiquote() {
  return getRuleContext<HaskellParser::QuasiquoteContext>(0);
}

std::vector<tree::TerminalNode *> HaskellParser::Aexp2Context::AopenParen() {
  return getTokens(HaskellParser::AopenParen);
}

tree::TerminalNode* HaskellParser::Aexp2Context::AopenParen(size_t i) {
  return getToken(HaskellParser::AopenParen, i);
}

HaskellParser::AexpContext* HaskellParser::Aexp2Context::aexp() {
  return getRuleContext<HaskellParser::AexpContext>(0);
}

HaskellParser::CmdargsContext* HaskellParser::Aexp2Context::cmdargs() {
  return getRuleContext<HaskellParser::CmdargsContext>(0);
}


size_t HaskellParser::Aexp2Context::getRuleIndex() const {
  return HaskellParser::RuleAexp2;
}

void HaskellParser::Aexp2Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAexp2(this);
}

void HaskellParser::Aexp2Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAexp2(this);
}

HaskellParser::Aexp2Context* HaskellParser::aexp2() {
  Aexp2Context *_localctx = _tracker.createInstance<Aexp2Context>(_ctx, getState());
  enterRule(_localctx, 306, HaskellParser::RuleAexp2);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2266);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 254, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2199);
      qvar();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2200);
      qcon();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2201);
      varid();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2202);
      literal();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2203);
      pstring();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2204);
      integer();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2205);
      pfloat();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2206);
      match(HaskellParser::OpenRoundBracket);
      setState(2207);
      texp();
      setState(2208);
      match(HaskellParser::CloseRoundBracket);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2210);
      match(HaskellParser::OpenRoundBracket);
      setState(2211);
      tup_exprs();
      setState(2212);
      match(HaskellParser::CloseRoundBracket);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(2214);
      match(HaskellParser::OpenBoxParen);
      setState(2215);
      texp();
      setState(2216);
      match(HaskellParser::CloseBoxParen);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(2218);
      match(HaskellParser::OpenBoxParen);
      setState(2219);
      tup_exprs();
      setState(2220);
      match(HaskellParser::CloseBoxParen);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(2222);
      match(HaskellParser::OpenSquareBracket);
      setState(2223);
      list_();
      setState(2224);
      match(HaskellParser::CloseSquareBracket);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(2226);
      match(HaskellParser::WILDCARD);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(2227);
      splice_untyped();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(2228);
      splice_typed();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(2229);
      match(HaskellParser::Quote);
      setState(2230);
      qvar();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(2231);
      match(HaskellParser::Quote);
      setState(2232);
      qcon();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(2233);
      match(HaskellParser::DoubleQuote);
      setState(2234);
      tyvar();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(2235);
      match(HaskellParser::DoubleQuote);
      setState(2236);
      gtycon();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(2237);
      match(HaskellParser::DoubleQuote);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(2238);
      match(HaskellParser::TopenExpQuote);
      setState(2239);
      exp();
      setState(2240);
      match(HaskellParser::TcloseQoute);
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(2242);
      match(HaskellParser::TopenTexpQuote);
      setState(2243);
      exp();
      setState(2244);
      match(HaskellParser::TcloseTExpQoute);
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(2246);
      match(HaskellParser::TopenTypQoute);
      setState(2247);
      ktype();
      setState(2248);
      match(HaskellParser::TcloseQoute);
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(2250);
      match(HaskellParser::TopenPatQuote);
      setState(2251);
      infixexp();
      setState(2252);
      match(HaskellParser::TcloseQoute);
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(2254);
      match(HaskellParser::TopenDecQoute);
      setState(2255);
      cvtopbody();
      setState(2256);
      match(HaskellParser::TcloseQoute);
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(2258);
      quasiquote();
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(2259);
      match(HaskellParser::AopenParen);
      setState(2260);
      aexp();
      setState(2262);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 253, _ctx)) {
      case 1: {
        setState(2261);
        cmdargs();
        break;
      }

      default:
        break;
      }
      setState(2264);
      match(HaskellParser::AopenParen);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Splice_expContext ------------------------------------------------------------------

HaskellParser::Splice_expContext::Splice_expContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Splice_typedContext* HaskellParser::Splice_expContext::splice_typed() {
  return getRuleContext<HaskellParser::Splice_typedContext>(0);
}

HaskellParser::Splice_untypedContext* HaskellParser::Splice_expContext::splice_untyped() {
  return getRuleContext<HaskellParser::Splice_untypedContext>(0);
}


size_t HaskellParser::Splice_expContext::getRuleIndex() const {
  return HaskellParser::RuleSplice_exp;
}

void HaskellParser::Splice_expContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSplice_exp(this);
}

void HaskellParser::Splice_expContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSplice_exp(this);
}

HaskellParser::Splice_expContext* HaskellParser::splice_exp() {
  Splice_expContext *_localctx = _tracker.createInstance<Splice_expContext>(_ctx, getState());
  enterRule(_localctx, 308, HaskellParser::RuleSplice_exp);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2270);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::DDollar: {
        enterOuterAlt(_localctx, 1);
        setState(2268);
        splice_typed();
        break;
      }

      case HaskellParser::Dollar: {
        enterOuterAlt(_localctx, 2);
        setState(2269);
        splice_untyped();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Splice_untypedContext ------------------------------------------------------------------

HaskellParser::Splice_untypedContext::Splice_untypedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Splice_untypedContext::Dollar() {
  return getToken(HaskellParser::Dollar, 0);
}

HaskellParser::AexpContext* HaskellParser::Splice_untypedContext::aexp() {
  return getRuleContext<HaskellParser::AexpContext>(0);
}


size_t HaskellParser::Splice_untypedContext::getRuleIndex() const {
  return HaskellParser::RuleSplice_untyped;
}

void HaskellParser::Splice_untypedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSplice_untyped(this);
}

void HaskellParser::Splice_untypedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSplice_untyped(this);
}

HaskellParser::Splice_untypedContext* HaskellParser::splice_untyped() {
  Splice_untypedContext *_localctx = _tracker.createInstance<Splice_untypedContext>(_ctx, getState());
  enterRule(_localctx, 310, HaskellParser::RuleSplice_untyped);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2272);
    match(HaskellParser::Dollar);
    setState(2273);
    aexp();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Splice_typedContext ------------------------------------------------------------------

HaskellParser::Splice_typedContext::Splice_typedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Splice_typedContext::DDollar() {
  return getToken(HaskellParser::DDollar, 0);
}

HaskellParser::AexpContext* HaskellParser::Splice_typedContext::aexp() {
  return getRuleContext<HaskellParser::AexpContext>(0);
}


size_t HaskellParser::Splice_typedContext::getRuleIndex() const {
  return HaskellParser::RuleSplice_typed;
}

void HaskellParser::Splice_typedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSplice_typed(this);
}

void HaskellParser::Splice_typedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSplice_typed(this);
}

HaskellParser::Splice_typedContext* HaskellParser::splice_typed() {
  Splice_typedContext *_localctx = _tracker.createInstance<Splice_typedContext>(_ctx, getState());
  enterRule(_localctx, 312, HaskellParser::RuleSplice_typed);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2275);
    match(HaskellParser::DDollar);
    setState(2276);
    aexp();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CmdargsContext ------------------------------------------------------------------

HaskellParser::CmdargsContext::CmdargsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::AcmdContext *> HaskellParser::CmdargsContext::acmd() {
  return getRuleContexts<HaskellParser::AcmdContext>();
}

HaskellParser::AcmdContext* HaskellParser::CmdargsContext::acmd(size_t i) {
  return getRuleContext<HaskellParser::AcmdContext>(i);
}


size_t HaskellParser::CmdargsContext::getRuleIndex() const {
  return HaskellParser::RuleCmdargs;
}

void HaskellParser::CmdargsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmdargs(this);
}

void HaskellParser::CmdargsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmdargs(this);
}

HaskellParser::CmdargsContext* HaskellParser::cmdargs() {
  CmdargsContext *_localctx = _tracker.createInstance<CmdargsContext>(_ctx, getState());
  enterRule(_localctx, 314, HaskellParser::RuleCmdargs);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2279); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(2278);
              acmd();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(2281); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 256, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AcmdContext ------------------------------------------------------------------

HaskellParser::AcmdContext::AcmdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::AexpContext* HaskellParser::AcmdContext::aexp() {
  return getRuleContext<HaskellParser::AexpContext>(0);
}


size_t HaskellParser::AcmdContext::getRuleIndex() const {
  return HaskellParser::RuleAcmd;
}

void HaskellParser::AcmdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAcmd(this);
}

void HaskellParser::AcmdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAcmd(this);
}

HaskellParser::AcmdContext* HaskellParser::acmd() {
  AcmdContext *_localctx = _tracker.createInstance<AcmdContext>(_ctx, getState());
  enterRule(_localctx, 316, HaskellParser::RuleAcmd);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2283);
    aexp();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CvtopbodyContext ------------------------------------------------------------------

HaskellParser::CvtopbodyContext::CvtopbodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Open_Context* HaskellParser::CvtopbodyContext::open_() {
  return getRuleContext<HaskellParser::Open_Context>(0);
}

HaskellParser::CloseContext* HaskellParser::CvtopbodyContext::close() {
  return getRuleContext<HaskellParser::CloseContext>(0);
}

HaskellParser::Cvtopdecls0Context* HaskellParser::CvtopbodyContext::cvtopdecls0() {
  return getRuleContext<HaskellParser::Cvtopdecls0Context>(0);
}


size_t HaskellParser::CvtopbodyContext::getRuleIndex() const {
  return HaskellParser::RuleCvtopbody;
}

void HaskellParser::CvtopbodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCvtopbody(this);
}

void HaskellParser::CvtopbodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCvtopbody(this);
}

HaskellParser::CvtopbodyContext* HaskellParser::cvtopbody() {
  CvtopbodyContext *_localctx = _tracker.createInstance<CvtopbodyContext>(_ctx, getState());
  enterRule(_localctx, 318, HaskellParser::RuleCvtopbody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2285);
    open_();
    setState(2287);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2117422456715250) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & -9152810504318468095) != 0) || ((((_la - 137) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 137)) & 15) != 0)) {
      setState(2286);
      cvtopdecls0();
    }
    setState(2289);
    close();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cvtopdecls0Context ------------------------------------------------------------------

HaskellParser::Cvtopdecls0Context::Cvtopdecls0Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::TopdeclsContext* HaskellParser::Cvtopdecls0Context::topdecls() {
  return getRuleContext<HaskellParser::TopdeclsContext>(0);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::Cvtopdecls0Context::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::Cvtopdecls0Context::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::Cvtopdecls0Context::getRuleIndex() const {
  return HaskellParser::RuleCvtopdecls0;
}

void HaskellParser::Cvtopdecls0Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCvtopdecls0(this);
}

void HaskellParser::Cvtopdecls0Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCvtopdecls0(this);
}

HaskellParser::Cvtopdecls0Context* HaskellParser::cvtopdecls0() {
  Cvtopdecls0Context *_localctx = _tracker.createInstance<Cvtopdecls0Context>(_ctx, getState());
  enterRule(_localctx, 320, HaskellParser::RuleCvtopdecls0);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2291);
    topdecls();
    setState(2295);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Semi

    || _la == HaskellParser::SEMI) {
      setState(2292);
      semi();
      setState(2297);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TexpContext ------------------------------------------------------------------

HaskellParser::TexpContext::TexpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::ExpContext* HaskellParser::TexpContext::exp() {
  return getRuleContext<HaskellParser::ExpContext>(0);
}

HaskellParser::InfixexpContext* HaskellParser::TexpContext::infixexp() {
  return getRuleContext<HaskellParser::InfixexpContext>(0);
}

HaskellParser::QopContext* HaskellParser::TexpContext::qop() {
  return getRuleContext<HaskellParser::QopContext>(0);
}

HaskellParser::QopmContext* HaskellParser::TexpContext::qopm() {
  return getRuleContext<HaskellParser::QopmContext>(0);
}

tree::TerminalNode* HaskellParser::TexpContext::Arrow() {
  return getToken(HaskellParser::Arrow, 0);
}

HaskellParser::TexpContext* HaskellParser::TexpContext::texp() {
  return getRuleContext<HaskellParser::TexpContext>(0);
}


size_t HaskellParser::TexpContext::getRuleIndex() const {
  return HaskellParser::RuleTexp;
}

void HaskellParser::TexpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTexp(this);
}

void HaskellParser::TexpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTexp(this);
}

HaskellParser::TexpContext* HaskellParser::texp() {
  TexpContext *_localctx = _tracker.createInstance<TexpContext>(_ctx, getState());
  enterRule(_localctx, 322, HaskellParser::RuleTexp);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2309);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 259, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2298);
      exp();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2299);
      infixexp();
      setState(2300);
      qop();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2302);
      qopm();
      setState(2303);
      infixexp();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2305);
      exp();
      setState(2306);
      match(HaskellParser::Arrow);
      setState(2307);
      texp();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tup_exprsContext ------------------------------------------------------------------

HaskellParser::Tup_exprsContext::Tup_exprsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::TexpContext* HaskellParser::Tup_exprsContext::texp() {
  return getRuleContext<HaskellParser::TexpContext>(0);
}

HaskellParser::Commas_tup_tailContext* HaskellParser::Tup_exprsContext::commas_tup_tail() {
  return getRuleContext<HaskellParser::Commas_tup_tailContext>(0);
}

std::vector<HaskellParser::BarsContext *> HaskellParser::Tup_exprsContext::bars() {
  return getRuleContexts<HaskellParser::BarsContext>();
}

HaskellParser::BarsContext* HaskellParser::Tup_exprsContext::bars(size_t i) {
  return getRuleContext<HaskellParser::BarsContext>(i);
}

HaskellParser::CommasContext* HaskellParser::Tup_exprsContext::commas() {
  return getRuleContext<HaskellParser::CommasContext>(0);
}

HaskellParser::Tup_tailContext* HaskellParser::Tup_exprsContext::tup_tail() {
  return getRuleContext<HaskellParser::Tup_tailContext>(0);
}


size_t HaskellParser::Tup_exprsContext::getRuleIndex() const {
  return HaskellParser::RuleTup_exprs;
}

void HaskellParser::Tup_exprsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTup_exprs(this);
}

void HaskellParser::Tup_exprsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTup_exprs(this);
}

HaskellParser::Tup_exprsContext* HaskellParser::tup_exprs() {
  Tup_exprsContext *_localctx = _tracker.createInstance<Tup_exprsContext>(_ctx, getState());
  enterRule(_localctx, 324, HaskellParser::RuleTup_exprs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2326);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 262, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2311);
      texp();
      setState(2312);
      commas_tup_tail();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2314);
      texp();
      setState(2315);
      bars();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2317);
      commas();
      setState(2319);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 1976683822330928) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 73)) & 34532773305777665) != 0) || ((((_la - 137) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 137)) & 15) != 0)) {
        setState(2318);
        tup_tail();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2321);
      bars();
      setState(2322);
      texp();
      setState(2324);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HaskellParser::Pipe) {
        setState(2323);
        bars();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Commas_tup_tailContext ------------------------------------------------------------------

HaskellParser::Commas_tup_tailContext::Commas_tup_tailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::CommasContext* HaskellParser::Commas_tup_tailContext::commas() {
  return getRuleContext<HaskellParser::CommasContext>(0);
}

HaskellParser::Tup_tailContext* HaskellParser::Commas_tup_tailContext::tup_tail() {
  return getRuleContext<HaskellParser::Tup_tailContext>(0);
}


size_t HaskellParser::Commas_tup_tailContext::getRuleIndex() const {
  return HaskellParser::RuleCommas_tup_tail;
}

void HaskellParser::Commas_tup_tailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommas_tup_tail(this);
}

void HaskellParser::Commas_tup_tailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommas_tup_tail(this);
}

HaskellParser::Commas_tup_tailContext* HaskellParser::commas_tup_tail() {
  Commas_tup_tailContext *_localctx = _tracker.createInstance<Commas_tup_tailContext>(_ctx, getState());
  enterRule(_localctx, 326, HaskellParser::RuleCommas_tup_tail);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2328);
    commas();
    setState(2330);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1976683822330928) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & 34532773305777665) != 0) || ((((_la - 137) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 137)) & 15) != 0)) {
      setState(2329);
      tup_tail();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tup_tailContext ------------------------------------------------------------------

HaskellParser::Tup_tailContext::Tup_tailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::TexpContext* HaskellParser::Tup_tailContext::texp() {
  return getRuleContext<HaskellParser::TexpContext>(0);
}

HaskellParser::Commas_tup_tailContext* HaskellParser::Tup_tailContext::commas_tup_tail() {
  return getRuleContext<HaskellParser::Commas_tup_tailContext>(0);
}


size_t HaskellParser::Tup_tailContext::getRuleIndex() const {
  return HaskellParser::RuleTup_tail;
}

void HaskellParser::Tup_tailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTup_tail(this);
}

void HaskellParser::Tup_tailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTup_tail(this);
}

HaskellParser::Tup_tailContext* HaskellParser::tup_tail() {
  Tup_tailContext *_localctx = _tracker.createInstance<Tup_tailContext>(_ctx, getState());
  enterRule(_localctx, 328, HaskellParser::RuleTup_tail);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2336);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 264, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2332);
      texp();
      setState(2333);
      commas_tup_tail();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2335);
      texp();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_Context ------------------------------------------------------------------

HaskellParser::List_Context::List_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::TexpContext* HaskellParser::List_Context::texp() {
  return getRuleContext<HaskellParser::TexpContext>(0);
}

HaskellParser::LexpsContext* HaskellParser::List_Context::lexps() {
  return getRuleContext<HaskellParser::LexpsContext>(0);
}

tree::TerminalNode* HaskellParser::List_Context::DoubleDot() {
  return getToken(HaskellParser::DoubleDot, 0);
}

tree::TerminalNode* HaskellParser::List_Context::Comma() {
  return getToken(HaskellParser::Comma, 0);
}

std::vector<HaskellParser::ExpContext *> HaskellParser::List_Context::exp() {
  return getRuleContexts<HaskellParser::ExpContext>();
}

HaskellParser::ExpContext* HaskellParser::List_Context::exp(size_t i) {
  return getRuleContext<HaskellParser::ExpContext>(i);
}

tree::TerminalNode* HaskellParser::List_Context::Pipe() {
  return getToken(HaskellParser::Pipe, 0);
}

HaskellParser::FlattenedpqualsContext* HaskellParser::List_Context::flattenedpquals() {
  return getRuleContext<HaskellParser::FlattenedpqualsContext>(0);
}


size_t HaskellParser::List_Context::getRuleIndex() const {
  return HaskellParser::RuleList_;
}

void HaskellParser::List_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_(this);
}

void HaskellParser::List_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_(this);
}

HaskellParser::List_Context* HaskellParser::list_() {
  List_Context *_localctx = _tracker.createInstance<List_Context>(_ctx, getState());
  enterRule(_localctx, 330, HaskellParser::RuleList_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2362);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 265, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2338);
      texp();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2339);
      lexps();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2340);
      texp();
      setState(2341);
      match(HaskellParser::DoubleDot);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2343);
      texp();
      setState(2344);
      match(HaskellParser::Comma);
      setState(2345);
      exp();
      setState(2346);
      match(HaskellParser::DoubleDot);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2348);
      texp();
      setState(2349);
      match(HaskellParser::DoubleDot);
      setState(2350);
      exp();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2352);
      texp();
      setState(2353);
      match(HaskellParser::Comma);
      setState(2354);
      exp();
      setState(2355);
      match(HaskellParser::DoubleDot);
      setState(2356);
      exp();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2358);
      texp();
      setState(2359);
      match(HaskellParser::Pipe);
      setState(2360);
      flattenedpquals();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LexpsContext ------------------------------------------------------------------

HaskellParser::LexpsContext::LexpsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::TexpContext *> HaskellParser::LexpsContext::texp() {
  return getRuleContexts<HaskellParser::TexpContext>();
}

HaskellParser::TexpContext* HaskellParser::LexpsContext::texp(size_t i) {
  return getRuleContext<HaskellParser::TexpContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::LexpsContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::LexpsContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}


size_t HaskellParser::LexpsContext::getRuleIndex() const {
  return HaskellParser::RuleLexps;
}

void HaskellParser::LexpsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLexps(this);
}

void HaskellParser::LexpsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLexps(this);
}

HaskellParser::LexpsContext* HaskellParser::lexps() {
  LexpsContext *_localctx = _tracker.createInstance<LexpsContext>(_ctx, getState());
  enterRule(_localctx, 332, HaskellParser::RuleLexps);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2364);
    texp();
    setState(2365);
    match(HaskellParser::Comma);
    setState(2366);
    texp();
    setState(2371);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Comma) {
      setState(2367);
      match(HaskellParser::Comma);
      setState(2368);
      texp();
      setState(2373);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FlattenedpqualsContext ------------------------------------------------------------------

HaskellParser::FlattenedpqualsContext::FlattenedpqualsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::PqualsContext* HaskellParser::FlattenedpqualsContext::pquals() {
  return getRuleContext<HaskellParser::PqualsContext>(0);
}


size_t HaskellParser::FlattenedpqualsContext::getRuleIndex() const {
  return HaskellParser::RuleFlattenedpquals;
}

void HaskellParser::FlattenedpqualsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFlattenedpquals(this);
}

void HaskellParser::FlattenedpqualsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFlattenedpquals(this);
}

HaskellParser::FlattenedpqualsContext* HaskellParser::flattenedpquals() {
  FlattenedpqualsContext *_localctx = _tracker.createInstance<FlattenedpqualsContext>(_ctx, getState());
  enterRule(_localctx, 334, HaskellParser::RuleFlattenedpquals);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2374);
    pquals();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PqualsContext ------------------------------------------------------------------

HaskellParser::PqualsContext::PqualsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::SqualsContext *> HaskellParser::PqualsContext::squals() {
  return getRuleContexts<HaskellParser::SqualsContext>();
}

HaskellParser::SqualsContext* HaskellParser::PqualsContext::squals(size_t i) {
  return getRuleContext<HaskellParser::SqualsContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::PqualsContext::Pipe() {
  return getTokens(HaskellParser::Pipe);
}

tree::TerminalNode* HaskellParser::PqualsContext::Pipe(size_t i) {
  return getToken(HaskellParser::Pipe, i);
}


size_t HaskellParser::PqualsContext::getRuleIndex() const {
  return HaskellParser::RulePquals;
}

void HaskellParser::PqualsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPquals(this);
}

void HaskellParser::PqualsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPquals(this);
}

HaskellParser::PqualsContext* HaskellParser::pquals() {
  PqualsContext *_localctx = _tracker.createInstance<PqualsContext>(_ctx, getState());
  enterRule(_localctx, 336, HaskellParser::RulePquals);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2376);
    squals();
    setState(2381);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Pipe) {
      setState(2377);
      match(HaskellParser::Pipe);
      setState(2378);
      squals();
      setState(2383);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SqualsContext ------------------------------------------------------------------

HaskellParser::SqualsContext::SqualsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::TransformqualContext *> HaskellParser::SqualsContext::transformqual() {
  return getRuleContexts<HaskellParser::TransformqualContext>();
}

HaskellParser::TransformqualContext* HaskellParser::SqualsContext::transformqual(size_t i) {
  return getRuleContext<HaskellParser::TransformqualContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::SqualsContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::SqualsContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}

std::vector<HaskellParser::QualContext *> HaskellParser::SqualsContext::qual() {
  return getRuleContexts<HaskellParser::QualContext>();
}

HaskellParser::QualContext* HaskellParser::SqualsContext::qual(size_t i) {
  return getRuleContext<HaskellParser::QualContext>(i);
}


size_t HaskellParser::SqualsContext::getRuleIndex() const {
  return HaskellParser::RuleSquals;
}

void HaskellParser::SqualsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSquals(this);
}

void HaskellParser::SqualsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSquals(this);
}

HaskellParser::SqualsContext* HaskellParser::squals() {
  SqualsContext *_localctx = _tracker.createInstance<SqualsContext>(_ctx, getState());
  enterRule(_localctx, 338, HaskellParser::RuleSquals);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2416);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 272, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2384);
      transformqual();
      setState(2389);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == HaskellParser::Comma) {
        setState(2385);
        match(HaskellParser::Comma);
        setState(2386);
        transformqual();
        setState(2391);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2392);
      transformqual();
      setState(2397);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == HaskellParser::Comma) {
        setState(2393);
        match(HaskellParser::Comma);
        setState(2394);
        qual();
        setState(2399);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2400);
      qual();
      setState(2405);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == HaskellParser::Comma) {
        setState(2401);
        match(HaskellParser::Comma);
        setState(2402);
        transformqual();
        setState(2407);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2408);
      qual();
      setState(2413);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == HaskellParser::Comma) {
        setState(2409);
        match(HaskellParser::Comma);
        setState(2410);
        qual();
        setState(2415);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransformqualContext ------------------------------------------------------------------

HaskellParser::TransformqualContext::TransformqualContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::TransformqualContext::THEN() {
  return getToken(HaskellParser::THEN, 0);
}

std::vector<HaskellParser::ExpContext *> HaskellParser::TransformqualContext::exp() {
  return getRuleContexts<HaskellParser::ExpContext>();
}

HaskellParser::ExpContext* HaskellParser::TransformqualContext::exp(size_t i) {
  return getRuleContext<HaskellParser::ExpContext>(i);
}

tree::TerminalNode* HaskellParser::TransformqualContext::BY() {
  return getToken(HaskellParser::BY, 0);
}

tree::TerminalNode* HaskellParser::TransformqualContext::GROUP() {
  return getToken(HaskellParser::GROUP, 0);
}

tree::TerminalNode* HaskellParser::TransformqualContext::USING() {
  return getToken(HaskellParser::USING, 0);
}


size_t HaskellParser::TransformqualContext::getRuleIndex() const {
  return HaskellParser::RuleTransformqual;
}

void HaskellParser::TransformqualContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransformqual(this);
}

void HaskellParser::TransformqualContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransformqual(this);
}

HaskellParser::TransformqualContext* HaskellParser::transformqual() {
  TransformqualContext *_localctx = _tracker.createInstance<TransformqualContext>(_ctx, getState());
  enterRule(_localctx, 340, HaskellParser::RuleTransformqual);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2436);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 273, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2418);
      match(HaskellParser::THEN);
      setState(2419);
      exp();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2420);
      match(HaskellParser::THEN);
      setState(2421);
      exp();
      setState(2422);
      match(HaskellParser::BY);
      setState(2423);
      exp();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2425);
      match(HaskellParser::THEN);
      setState(2426);
      match(HaskellParser::GROUP);
      setState(2427);
      match(HaskellParser::USING);
      setState(2428);
      exp();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2429);
      match(HaskellParser::THEN);
      setState(2430);
      match(HaskellParser::GROUP);
      setState(2431);
      match(HaskellParser::BY);
      setState(2432);
      exp();
      setState(2433);
      match(HaskellParser::USING);
      setState(2434);
      exp();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GuardsContext ------------------------------------------------------------------

HaskellParser::GuardsContext::GuardsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::Guard_Context *> HaskellParser::GuardsContext::guard_() {
  return getRuleContexts<HaskellParser::Guard_Context>();
}

HaskellParser::Guard_Context* HaskellParser::GuardsContext::guard_(size_t i) {
  return getRuleContext<HaskellParser::Guard_Context>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::GuardsContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::GuardsContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}


size_t HaskellParser::GuardsContext::getRuleIndex() const {
  return HaskellParser::RuleGuards;
}

void HaskellParser::GuardsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGuards(this);
}

void HaskellParser::GuardsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGuards(this);
}

HaskellParser::GuardsContext* HaskellParser::guards() {
  GuardsContext *_localctx = _tracker.createInstance<GuardsContext>(_ctx, getState());
  enterRule(_localctx, 342, HaskellParser::RuleGuards);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2438);
    guard_();
    setState(2443);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Comma) {
      setState(2439);
      match(HaskellParser::Comma);
      setState(2440);
      guard_();
      setState(2445);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Guard_Context ------------------------------------------------------------------

HaskellParser::Guard_Context::Guard_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::PatContext* HaskellParser::Guard_Context::pat() {
  return getRuleContext<HaskellParser::PatContext>(0);
}

tree::TerminalNode* HaskellParser::Guard_Context::Revarrow() {
  return getToken(HaskellParser::Revarrow, 0);
}

HaskellParser::InfixexpContext* HaskellParser::Guard_Context::infixexp() {
  return getRuleContext<HaskellParser::InfixexpContext>(0);
}

tree::TerminalNode* HaskellParser::Guard_Context::LET() {
  return getToken(HaskellParser::LET, 0);
}

HaskellParser::DecllistContext* HaskellParser::Guard_Context::decllist() {
  return getRuleContext<HaskellParser::DecllistContext>(0);
}


size_t HaskellParser::Guard_Context::getRuleIndex() const {
  return HaskellParser::RuleGuard_;
}

void HaskellParser::Guard_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGuard_(this);
}

void HaskellParser::Guard_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGuard_(this);
}

HaskellParser::Guard_Context* HaskellParser::guard_() {
  Guard_Context *_localctx = _tracker.createInstance<Guard_Context>(_ctx, getState());
  enterRule(_localctx, 344, HaskellParser::RuleGuard_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2453);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 275, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2446);
      pat();
      setState(2447);
      match(HaskellParser::Revarrow);
      setState(2448);
      infixexp();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2450);
      match(HaskellParser::LET);
      setState(2451);
      decllist();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2452);
      infixexp();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AltsContext ------------------------------------------------------------------

HaskellParser::AltsContext::AltsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Open_Context* HaskellParser::AltsContext::open_() {
  return getRuleContext<HaskellParser::Open_Context>(0);
}

HaskellParser::CloseContext* HaskellParser::AltsContext::close() {
  return getRuleContext<HaskellParser::CloseContext>(0);
}

std::vector<HaskellParser::AltContext *> HaskellParser::AltsContext::alt() {
  return getRuleContexts<HaskellParser::AltContext>();
}

HaskellParser::AltContext* HaskellParser::AltsContext::alt(size_t i) {
  return getRuleContext<HaskellParser::AltContext>(i);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::AltsContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::AltsContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::AltsContext::getRuleIndex() const {
  return HaskellParser::RuleAlts;
}

void HaskellParser::AltsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlts(this);
}

void HaskellParser::AltsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlts(this);
}

HaskellParser::AltsContext* HaskellParser::alts() {
  AltsContext *_localctx = _tracker.createInstance<AltsContext>(_ctx, getState());
  enterRule(_localctx, 346, HaskellParser::RuleAlts);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2472);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 278, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2455);
      open_();
      setState(2463); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(2456);
        alt();
        setState(2460);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == HaskellParser::Semi

        || _la == HaskellParser::SEMI) {
          setState(2457);
          semi();
          setState(2462);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2465); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 1976683822330928) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 73)) & 34532735383126017) != 0) || ((((_la - 137) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 137)) & 15) != 0));
      setState(2467);
      close();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2469);
      open_();
      setState(2470);
      close();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AltContext ------------------------------------------------------------------

HaskellParser::AltContext::AltContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::PatContext* HaskellParser::AltContext::pat() {
  return getRuleContext<HaskellParser::PatContext>(0);
}

HaskellParser::Alt_rhsContext* HaskellParser::AltContext::alt_rhs() {
  return getRuleContext<HaskellParser::Alt_rhsContext>(0);
}


size_t HaskellParser::AltContext::getRuleIndex() const {
  return HaskellParser::RuleAlt;
}

void HaskellParser::AltContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlt(this);
}

void HaskellParser::AltContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlt(this);
}

HaskellParser::AltContext* HaskellParser::alt() {
  AltContext *_localctx = _tracker.createInstance<AltContext>(_ctx, getState());
  enterRule(_localctx, 348, HaskellParser::RuleAlt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2474);
    pat();
    setState(2475);
    alt_rhs();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alt_rhsContext ------------------------------------------------------------------

HaskellParser::Alt_rhsContext::Alt_rhsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::RaltContext* HaskellParser::Alt_rhsContext::ralt() {
  return getRuleContext<HaskellParser::RaltContext>(0);
}

HaskellParser::WherebindsContext* HaskellParser::Alt_rhsContext::wherebinds() {
  return getRuleContext<HaskellParser::WherebindsContext>(0);
}


size_t HaskellParser::Alt_rhsContext::getRuleIndex() const {
  return HaskellParser::RuleAlt_rhs;
}

void HaskellParser::Alt_rhsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlt_rhs(this);
}

void HaskellParser::Alt_rhsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlt_rhs(this);
}

HaskellParser::Alt_rhsContext* HaskellParser::alt_rhs() {
  Alt_rhsContext *_localctx = _tracker.createInstance<Alt_rhsContext>(_ctx, getState());
  enterRule(_localctx, 350, HaskellParser::RuleAlt_rhs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2477);
    ralt();
    setState(2479);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::WHERE) {
      setState(2478);
      wherebinds();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RaltContext ------------------------------------------------------------------

HaskellParser::RaltContext::RaltContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::RaltContext::Arrow() {
  return getToken(HaskellParser::Arrow, 0);
}

HaskellParser::ExpContext* HaskellParser::RaltContext::exp() {
  return getRuleContext<HaskellParser::ExpContext>(0);
}

HaskellParser::GdpatsContext* HaskellParser::RaltContext::gdpats() {
  return getRuleContext<HaskellParser::GdpatsContext>(0);
}


size_t HaskellParser::RaltContext::getRuleIndex() const {
  return HaskellParser::RuleRalt;
}

void HaskellParser::RaltContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRalt(this);
}

void HaskellParser::RaltContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRalt(this);
}

HaskellParser::RaltContext* HaskellParser::ralt() {
  RaltContext *_localctx = _tracker.createInstance<RaltContext>(_ctx, getState());
  enterRule(_localctx, 352, HaskellParser::RuleRalt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2484);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::Arrow: {
        enterOuterAlt(_localctx, 1);
        setState(2481);
        match(HaskellParser::Arrow);
        setState(2482);
        exp();
        break;
      }

      case HaskellParser::Pipe: {
        enterOuterAlt(_localctx, 2);
        setState(2483);
        gdpats();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GdpatsContext ------------------------------------------------------------------

HaskellParser::GdpatsContext::GdpatsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::GdpatContext *> HaskellParser::GdpatsContext::gdpat() {
  return getRuleContexts<HaskellParser::GdpatContext>();
}

HaskellParser::GdpatContext* HaskellParser::GdpatsContext::gdpat(size_t i) {
  return getRuleContext<HaskellParser::GdpatContext>(i);
}


size_t HaskellParser::GdpatsContext::getRuleIndex() const {
  return HaskellParser::RuleGdpats;
}

void HaskellParser::GdpatsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGdpats(this);
}

void HaskellParser::GdpatsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGdpats(this);
}

HaskellParser::GdpatsContext* HaskellParser::gdpats() {
  GdpatsContext *_localctx = _tracker.createInstance<GdpatsContext>(_ctx, getState());
  enterRule(_localctx, 354, HaskellParser::RuleGdpats);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2487); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(2486);
              gdpat();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(2489); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 281, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfgdpatsContext ------------------------------------------------------------------

HaskellParser::IfgdpatsContext::IfgdpatsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::IfgdpatsContext::OCURLY() {
  return getToken(HaskellParser::OCURLY, 0);
}

HaskellParser::GdpatsContext* HaskellParser::IfgdpatsContext::gdpats() {
  return getRuleContext<HaskellParser::GdpatsContext>(0);
}

tree::TerminalNode* HaskellParser::IfgdpatsContext::CCURLY() {
  return getToken(HaskellParser::CCURLY, 0);
}


size_t HaskellParser::IfgdpatsContext::getRuleIndex() const {
  return HaskellParser::RuleIfgdpats;
}

void HaskellParser::IfgdpatsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfgdpats(this);
}

void HaskellParser::IfgdpatsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfgdpats(this);
}

HaskellParser::IfgdpatsContext* HaskellParser::ifgdpats() {
  IfgdpatsContext *_localctx = _tracker.createInstance<IfgdpatsContext>(_ctx, getState());
  enterRule(_localctx, 356, HaskellParser::RuleIfgdpats);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2496);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::OCURLY: {
        enterOuterAlt(_localctx, 1);
        setState(2491);
        match(HaskellParser::OCURLY);
        setState(2492);
        gdpats();
        setState(2493);
        match(HaskellParser::CCURLY);
        break;
      }

      case HaskellParser::Pipe: {
        enterOuterAlt(_localctx, 2);
        setState(2495);
        gdpats();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GdpatContext ------------------------------------------------------------------

HaskellParser::GdpatContext::GdpatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::GdpatContext::Pipe() {
  return getToken(HaskellParser::Pipe, 0);
}

HaskellParser::GuardsContext* HaskellParser::GdpatContext::guards() {
  return getRuleContext<HaskellParser::GuardsContext>(0);
}

tree::TerminalNode* HaskellParser::GdpatContext::Arrow() {
  return getToken(HaskellParser::Arrow, 0);
}

HaskellParser::ExpContext* HaskellParser::GdpatContext::exp() {
  return getRuleContext<HaskellParser::ExpContext>(0);
}


size_t HaskellParser::GdpatContext::getRuleIndex() const {
  return HaskellParser::RuleGdpat;
}

void HaskellParser::GdpatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGdpat(this);
}

void HaskellParser::GdpatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGdpat(this);
}

HaskellParser::GdpatContext* HaskellParser::gdpat() {
  GdpatContext *_localctx = _tracker.createInstance<GdpatContext>(_ctx, getState());
  enterRule(_localctx, 358, HaskellParser::RuleGdpat);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2498);
    match(HaskellParser::Pipe);
    setState(2499);
    guards();
    setState(2500);
    match(HaskellParser::Arrow);
    setState(2501);
    exp();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatContext ------------------------------------------------------------------

HaskellParser::PatContext::PatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::ExpContext* HaskellParser::PatContext::exp() {
  return getRuleContext<HaskellParser::ExpContext>(0);
}


size_t HaskellParser::PatContext::getRuleIndex() const {
  return HaskellParser::RulePat;
}

void HaskellParser::PatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPat(this);
}

void HaskellParser::PatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPat(this);
}

HaskellParser::PatContext* HaskellParser::pat() {
  PatContext *_localctx = _tracker.createInstance<PatContext>(_ctx, getState());
  enterRule(_localctx, 360, HaskellParser::RulePat);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2503);
    exp();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BindpatContext ------------------------------------------------------------------

HaskellParser::BindpatContext::BindpatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::ExpContext* HaskellParser::BindpatContext::exp() {
  return getRuleContext<HaskellParser::ExpContext>(0);
}


size_t HaskellParser::BindpatContext::getRuleIndex() const {
  return HaskellParser::RuleBindpat;
}

void HaskellParser::BindpatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBindpat(this);
}

void HaskellParser::BindpatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBindpat(this);
}

HaskellParser::BindpatContext* HaskellParser::bindpat() {
  BindpatContext *_localctx = _tracker.createInstance<BindpatContext>(_ctx, getState());
  enterRule(_localctx, 362, HaskellParser::RuleBindpat);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2505);
    exp();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ApatContext ------------------------------------------------------------------

HaskellParser::ApatContext::ApatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::AexpContext* HaskellParser::ApatContext::aexp() {
  return getRuleContext<HaskellParser::AexpContext>(0);
}


size_t HaskellParser::ApatContext::getRuleIndex() const {
  return HaskellParser::RuleApat;
}

void HaskellParser::ApatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApat(this);
}

void HaskellParser::ApatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApat(this);
}

HaskellParser::ApatContext* HaskellParser::apat() {
  ApatContext *_localctx = _tracker.createInstance<ApatContext>(_ctx, getState());
  enterRule(_localctx, 364, HaskellParser::RuleApat);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2507);
    aexp();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ApatsContext ------------------------------------------------------------------

HaskellParser::ApatsContext::ApatsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::ApatContext *> HaskellParser::ApatsContext::apat() {
  return getRuleContexts<HaskellParser::ApatContext>();
}

HaskellParser::ApatContext* HaskellParser::ApatsContext::apat(size_t i) {
  return getRuleContext<HaskellParser::ApatContext>(i);
}


size_t HaskellParser::ApatsContext::getRuleIndex() const {
  return HaskellParser::RuleApats;
}

void HaskellParser::ApatsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApats(this);
}

void HaskellParser::ApatsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApats(this);
}

HaskellParser::ApatsContext* HaskellParser::apats() {
  ApatsContext *_localctx = _tracker.createInstance<ApatsContext>(_ctx, getState());
  enterRule(_localctx, 366, HaskellParser::RuleApats);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2510); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2509);
      apat();
      setState(2512); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1976683822330928) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & 34532735382994945) != 0) || ((((_la - 137) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 137)) & 15) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FpatContext ------------------------------------------------------------------

HaskellParser::FpatContext::FpatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::QvarContext* HaskellParser::FpatContext::qvar() {
  return getRuleContext<HaskellParser::QvarContext>(0);
}

tree::TerminalNode* HaskellParser::FpatContext::Eq() {
  return getToken(HaskellParser::Eq, 0);
}

HaskellParser::PatContext* HaskellParser::FpatContext::pat() {
  return getRuleContext<HaskellParser::PatContext>(0);
}


size_t HaskellParser::FpatContext::getRuleIndex() const {
  return HaskellParser::RuleFpat;
}

void HaskellParser::FpatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFpat(this);
}

void HaskellParser::FpatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFpat(this);
}

HaskellParser::FpatContext* HaskellParser::fpat() {
  FpatContext *_localctx = _tracker.createInstance<FpatContext>(_ctx, getState());
  enterRule(_localctx, 368, HaskellParser::RuleFpat);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2514);
    qvar();
    setState(2515);
    match(HaskellParser::Eq);
    setState(2516);
    pat();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StmtlistContext ------------------------------------------------------------------

HaskellParser::StmtlistContext::StmtlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Open_Context* HaskellParser::StmtlistContext::open_() {
  return getRuleContext<HaskellParser::Open_Context>(0);
}

HaskellParser::CloseContext* HaskellParser::StmtlistContext::close() {
  return getRuleContext<HaskellParser::CloseContext>(0);
}

HaskellParser::StmtsContext* HaskellParser::StmtlistContext::stmts() {
  return getRuleContext<HaskellParser::StmtsContext>(0);
}


size_t HaskellParser::StmtlistContext::getRuleIndex() const {
  return HaskellParser::RuleStmtlist;
}

void HaskellParser::StmtlistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStmtlist(this);
}

void HaskellParser::StmtlistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStmtlist(this);
}

HaskellParser::StmtlistContext* HaskellParser::stmtlist() {
  StmtlistContext *_localctx = _tracker.createInstance<StmtlistContext>(_ctx, getState());
  enterRule(_localctx, 370, HaskellParser::RuleStmtlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2518);
    open_();
    setState(2520);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1985479915353136) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & -9188839301337432063) != 0) || ((((_la - 137) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 137)) & 15) != 0)) {
      setState(2519);
      stmts();
    }
    setState(2522);
    close();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StmtsContext ------------------------------------------------------------------

HaskellParser::StmtsContext::StmtsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::StmtContext *> HaskellParser::StmtsContext::stmt() {
  return getRuleContexts<HaskellParser::StmtContext>();
}

HaskellParser::StmtContext* HaskellParser::StmtsContext::stmt(size_t i) {
  return getRuleContext<HaskellParser::StmtContext>(i);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::StmtsContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::StmtsContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::StmtsContext::getRuleIndex() const {
  return HaskellParser::RuleStmts;
}

void HaskellParser::StmtsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStmts(this);
}

void HaskellParser::StmtsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStmts(this);
}

HaskellParser::StmtsContext* HaskellParser::stmts() {
  StmtsContext *_localctx = _tracker.createInstance<StmtsContext>(_ctx, getState());
  enterRule(_localctx, 372, HaskellParser::RuleStmts);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2524);
    stmt();
    setState(2534);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 286, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2526); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(2525);
                  semi();
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(2528); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 285, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        setState(2530);
        stmt(); 
      }
      setState(2536);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 286, _ctx);
    }
    setState(2540);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Semi

    || _la == HaskellParser::SEMI) {
      setState(2537);
      semi();
      setState(2542);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StmtContext ------------------------------------------------------------------

HaskellParser::StmtContext::StmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::QualContext* HaskellParser::StmtContext::qual() {
  return getRuleContext<HaskellParser::QualContext>(0);
}

tree::TerminalNode* HaskellParser::StmtContext::REC() {
  return getToken(HaskellParser::REC, 0);
}

HaskellParser::StmtlistContext* HaskellParser::StmtContext::stmtlist() {
  return getRuleContext<HaskellParser::StmtlistContext>(0);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::StmtContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::StmtContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::StmtContext::getRuleIndex() const {
  return HaskellParser::RuleStmt;
}

void HaskellParser::StmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStmt(this);
}

void HaskellParser::StmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStmt(this);
}

HaskellParser::StmtContext* HaskellParser::stmt() {
  StmtContext *_localctx = _tracker.createInstance<StmtContext>(_ctx, getState());
  enterRule(_localctx, 374, HaskellParser::RuleStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(2551);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::AS:
      case HaskellParser::CASE:
      case HaskellParser::DO:
      case HaskellParser::HIDING:
      case HaskellParser::IF:
      case HaskellParser::LET:
      case HaskellParser::QUALIFIED:
      case HaskellParser::WILDCARD:
      case HaskellParser::EXPORT:
      case HaskellParser::MDO:
      case HaskellParser::STDCALL:
      case HaskellParser::CCALL:
      case HaskellParser::CAPI:
      case HaskellParser::JSCALL:
      case HaskellParser::STOCK:
      case HaskellParser::ANYCLASS:
      case HaskellParser::VIA:
      case HaskellParser::LCASE:
      case HaskellParser::Bang:
      case HaskellParser::Minus:
      case HaskellParser::Tilde:
      case HaskellParser::DDollar:
      case HaskellParser::Dollar:
      case HaskellParser::Quote:
      case HaskellParser::DoubleQuote:
      case HaskellParser::ReverseSlash:
      case HaskellParser::AopenParen:
      case HaskellParser::TopenTexpQuote:
      case HaskellParser::TopenExpQuote:
      case HaskellParser::TopenPatQuote:
      case HaskellParser::TopenTypQoute:
      case HaskellParser::TopenDecQoute:
      case HaskellParser::OpenBoxParen:
      case HaskellParser::OpenRoundBracket:
      case HaskellParser::OpenSquareBracket:
      case HaskellParser::CHAR:
      case HaskellParser::STRING:
      case HaskellParser::VARID:
      case HaskellParser::CONID:
      case HaskellParser::DECIMAL:
      case HaskellParser::OCTAL:
      case HaskellParser::HEXADECIMAL:
      case HaskellParser::FLOAT: {
        enterOuterAlt(_localctx, 1);
        setState(2543);
        qual();
        break;
      }

      case HaskellParser::REC: {
        enterOuterAlt(_localctx, 2);
        setState(2544);
        match(HaskellParser::REC);
        setState(2545);
        stmtlist();
        break;
      }

      case HaskellParser::Semi:
      case HaskellParser::SEMI: {
        enterOuterAlt(_localctx, 3);
        setState(2547); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(2546);
                  semi();
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(2549); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 288, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualContext ------------------------------------------------------------------

HaskellParser::QualContext::QualContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::BindpatContext* HaskellParser::QualContext::bindpat() {
  return getRuleContext<HaskellParser::BindpatContext>(0);
}

tree::TerminalNode* HaskellParser::QualContext::Revarrow() {
  return getToken(HaskellParser::Revarrow, 0);
}

HaskellParser::ExpContext* HaskellParser::QualContext::exp() {
  return getRuleContext<HaskellParser::ExpContext>(0);
}

tree::TerminalNode* HaskellParser::QualContext::LET() {
  return getToken(HaskellParser::LET, 0);
}

HaskellParser::BindsContext* HaskellParser::QualContext::binds() {
  return getRuleContext<HaskellParser::BindsContext>(0);
}


size_t HaskellParser::QualContext::getRuleIndex() const {
  return HaskellParser::RuleQual;
}

void HaskellParser::QualContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQual(this);
}

void HaskellParser::QualContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQual(this);
}

HaskellParser::QualContext* HaskellParser::qual() {
  QualContext *_localctx = _tracker.createInstance<QualContext>(_ctx, getState());
  enterRule(_localctx, 376, HaskellParser::RuleQual);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2560);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 290, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2553);
      bindpat();
      setState(2554);
      match(HaskellParser::Revarrow);
      setState(2555);
      exp();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2557);
      exp();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2558);
      match(HaskellParser::LET);
      setState(2559);
      binds();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FbindsContext ------------------------------------------------------------------

HaskellParser::FbindsContext::FbindsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::FbindContext *> HaskellParser::FbindsContext::fbind() {
  return getRuleContexts<HaskellParser::FbindContext>();
}

HaskellParser::FbindContext* HaskellParser::FbindsContext::fbind(size_t i) {
  return getRuleContext<HaskellParser::FbindContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::FbindsContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::FbindsContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}

tree::TerminalNode* HaskellParser::FbindsContext::DoubleDot() {
  return getToken(HaskellParser::DoubleDot, 0);
}


size_t HaskellParser::FbindsContext::getRuleIndex() const {
  return HaskellParser::RuleFbinds;
}

void HaskellParser::FbindsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFbinds(this);
}

void HaskellParser::FbindsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFbinds(this);
}

HaskellParser::FbindsContext* HaskellParser::fbinds() {
  FbindsContext *_localctx = _tracker.createInstance<FbindsContext>(_ctx, getState());
  enterRule(_localctx, 378, HaskellParser::RuleFbinds);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2571);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::AS:
      case HaskellParser::HIDING:
      case HaskellParser::QUALIFIED:
      case HaskellParser::EXPORT:
      case HaskellParser::STDCALL:
      case HaskellParser::CCALL:
      case HaskellParser::CAPI:
      case HaskellParser::JSCALL:
      case HaskellParser::STOCK:
      case HaskellParser::ANYCLASS:
      case HaskellParser::VIA:
      case HaskellParser::OpenRoundBracket:
      case HaskellParser::VARID:
      case HaskellParser::CONID: {
        enterOuterAlt(_localctx, 1);
        setState(2562);
        fbind();
        setState(2567);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == HaskellParser::Comma) {
          setState(2563);
          match(HaskellParser::Comma);
          setState(2564);
          fbind();
          setState(2569);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case HaskellParser::DoubleDot: {
        enterOuterAlt(_localctx, 2);
        setState(2570);
        match(HaskellParser::DoubleDot);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FbindContext ------------------------------------------------------------------

HaskellParser::FbindContext::FbindContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::QvarContext* HaskellParser::FbindContext::qvar() {
  return getRuleContext<HaskellParser::QvarContext>(0);
}

tree::TerminalNode* HaskellParser::FbindContext::Eq() {
  return getToken(HaskellParser::Eq, 0);
}

HaskellParser::ExpContext* HaskellParser::FbindContext::exp() {
  return getRuleContext<HaskellParser::ExpContext>(0);
}


size_t HaskellParser::FbindContext::getRuleIndex() const {
  return HaskellParser::RuleFbind;
}

void HaskellParser::FbindContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFbind(this);
}

void HaskellParser::FbindContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFbind(this);
}

HaskellParser::FbindContext* HaskellParser::fbind() {
  FbindContext *_localctx = _tracker.createInstance<FbindContext>(_ctx, getState());
  enterRule(_localctx, 380, HaskellParser::RuleFbind);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2578);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 293, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2573);
      qvar();
      setState(2574);
      match(HaskellParser::Eq);
      setState(2575);
      exp();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2577);
      qvar();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DbindsContext ------------------------------------------------------------------

HaskellParser::DbindsContext::DbindsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::DbindContext *> HaskellParser::DbindsContext::dbind() {
  return getRuleContexts<HaskellParser::DbindContext>();
}

HaskellParser::DbindContext* HaskellParser::DbindsContext::dbind(size_t i) {
  return getRuleContext<HaskellParser::DbindContext>(i);
}

std::vector<HaskellParser::SemiContext *> HaskellParser::DbindsContext::semi() {
  return getRuleContexts<HaskellParser::SemiContext>();
}

HaskellParser::SemiContext* HaskellParser::DbindsContext::semi(size_t i) {
  return getRuleContext<HaskellParser::SemiContext>(i);
}


size_t HaskellParser::DbindsContext::getRuleIndex() const {
  return HaskellParser::RuleDbinds;
}

void HaskellParser::DbindsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDbinds(this);
}

void HaskellParser::DbindsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDbinds(this);
}

HaskellParser::DbindsContext* HaskellParser::dbinds() {
  DbindsContext *_localctx = _tracker.createInstance<DbindsContext>(_ctx, getState());
  enterRule(_localctx, 382, HaskellParser::RuleDbinds);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2580);
    dbind();

    setState(2582); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2581);
      semi();
      setState(2584); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == HaskellParser::Semi

    || _la == HaskellParser::SEMI);
    setState(2586);
    dbind();
    setState(2591);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Semi

    || _la == HaskellParser::SEMI) {
      setState(2588);
      semi();
      setState(2593);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DbindContext ------------------------------------------------------------------

HaskellParser::DbindContext::DbindContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::VaridContext* HaskellParser::DbindContext::varid() {
  return getRuleContext<HaskellParser::VaridContext>(0);
}

tree::TerminalNode* HaskellParser::DbindContext::Eq() {
  return getToken(HaskellParser::Eq, 0);
}

HaskellParser::ExpContext* HaskellParser::DbindContext::exp() {
  return getRuleContext<HaskellParser::ExpContext>(0);
}


size_t HaskellParser::DbindContext::getRuleIndex() const {
  return HaskellParser::RuleDbind;
}

void HaskellParser::DbindContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDbind(this);
}

void HaskellParser::DbindContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDbind(this);
}

HaskellParser::DbindContext* HaskellParser::dbind() {
  DbindContext *_localctx = _tracker.createInstance<DbindContext>(_ctx, getState());
  enterRule(_localctx, 384, HaskellParser::RuleDbind);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2594);
    varid();
    setState(2595);
    match(HaskellParser::Eq);
    setState(2596);
    exp();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_boolformula_optContext ------------------------------------------------------------------

HaskellParser::Name_boolformula_optContext::Name_boolformula_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::Name_boolformula_andContext *> HaskellParser::Name_boolformula_optContext::name_boolformula_and() {
  return getRuleContexts<HaskellParser::Name_boolformula_andContext>();
}

HaskellParser::Name_boolformula_andContext* HaskellParser::Name_boolformula_optContext::name_boolformula_and(size_t i) {
  return getRuleContext<HaskellParser::Name_boolformula_andContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::Name_boolformula_optContext::Pipe() {
  return getTokens(HaskellParser::Pipe);
}

tree::TerminalNode* HaskellParser::Name_boolformula_optContext::Pipe(size_t i) {
  return getToken(HaskellParser::Pipe, i);
}


size_t HaskellParser::Name_boolformula_optContext::getRuleIndex() const {
  return HaskellParser::RuleName_boolformula_opt;
}

void HaskellParser::Name_boolformula_optContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterName_boolformula_opt(this);
}

void HaskellParser::Name_boolformula_optContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitName_boolformula_opt(this);
}

HaskellParser::Name_boolformula_optContext* HaskellParser::name_boolformula_opt() {
  Name_boolformula_optContext *_localctx = _tracker.createInstance<Name_boolformula_optContext>(_ctx, getState());
  enterRule(_localctx, 386, HaskellParser::RuleName_boolformula_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2598);
    name_boolformula_and();
    setState(2603);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Pipe) {
      setState(2599);
      match(HaskellParser::Pipe);
      setState(2600);
      name_boolformula_and();
      setState(2605);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_boolformula_andContext ------------------------------------------------------------------

HaskellParser::Name_boolformula_andContext::Name_boolformula_andContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Name_boolformula_and_listContext* HaskellParser::Name_boolformula_andContext::name_boolformula_and_list() {
  return getRuleContext<HaskellParser::Name_boolformula_and_listContext>(0);
}


size_t HaskellParser::Name_boolformula_andContext::getRuleIndex() const {
  return HaskellParser::RuleName_boolformula_and;
}

void HaskellParser::Name_boolformula_andContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterName_boolformula_and(this);
}

void HaskellParser::Name_boolformula_andContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitName_boolformula_and(this);
}

HaskellParser::Name_boolformula_andContext* HaskellParser::name_boolformula_and() {
  Name_boolformula_andContext *_localctx = _tracker.createInstance<Name_boolformula_andContext>(_ctx, getState());
  enterRule(_localctx, 388, HaskellParser::RuleName_boolformula_and);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2606);
    name_boolformula_and_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_boolformula_and_listContext ------------------------------------------------------------------

HaskellParser::Name_boolformula_and_listContext::Name_boolformula_and_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::Name_boolformula_atomContext *> HaskellParser::Name_boolformula_and_listContext::name_boolformula_atom() {
  return getRuleContexts<HaskellParser::Name_boolformula_atomContext>();
}

HaskellParser::Name_boolformula_atomContext* HaskellParser::Name_boolformula_and_listContext::name_boolformula_atom(size_t i) {
  return getRuleContext<HaskellParser::Name_boolformula_atomContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::Name_boolformula_and_listContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::Name_boolformula_and_listContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}


size_t HaskellParser::Name_boolformula_and_listContext::getRuleIndex() const {
  return HaskellParser::RuleName_boolformula_and_list;
}

void HaskellParser::Name_boolformula_and_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterName_boolformula_and_list(this);
}

void HaskellParser::Name_boolformula_and_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitName_boolformula_and_list(this);
}

HaskellParser::Name_boolformula_and_listContext* HaskellParser::name_boolformula_and_list() {
  Name_boolformula_and_listContext *_localctx = _tracker.createInstance<Name_boolformula_and_listContext>(_ctx, getState());
  enterRule(_localctx, 390, HaskellParser::RuleName_boolformula_and_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2608);
    name_boolformula_atom();
    setState(2613);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Comma) {
      setState(2609);
      match(HaskellParser::Comma);
      setState(2610);
      name_boolformula_atom();
      setState(2615);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_boolformula_atomContext ------------------------------------------------------------------

HaskellParser::Name_boolformula_atomContext::Name_boolformula_atomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Name_boolformula_atomContext::OpenRoundBracket() {
  return getToken(HaskellParser::OpenRoundBracket, 0);
}

HaskellParser::Name_boolformula_optContext* HaskellParser::Name_boolformula_atomContext::name_boolformula_opt() {
  return getRuleContext<HaskellParser::Name_boolformula_optContext>(0);
}

tree::TerminalNode* HaskellParser::Name_boolformula_atomContext::CloseRoundBracket() {
  return getToken(HaskellParser::CloseRoundBracket, 0);
}

HaskellParser::Name_varContext* HaskellParser::Name_boolformula_atomContext::name_var() {
  return getRuleContext<HaskellParser::Name_varContext>(0);
}


size_t HaskellParser::Name_boolformula_atomContext::getRuleIndex() const {
  return HaskellParser::RuleName_boolformula_atom;
}

void HaskellParser::Name_boolformula_atomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterName_boolformula_atom(this);
}

void HaskellParser::Name_boolformula_atomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitName_boolformula_atom(this);
}

HaskellParser::Name_boolformula_atomContext* HaskellParser::name_boolformula_atom() {
  Name_boolformula_atomContext *_localctx = _tracker.createInstance<Name_boolformula_atomContext>(_ctx, getState());
  enterRule(_localctx, 392, HaskellParser::RuleName_boolformula_atom);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2621);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 298, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2616);
      match(HaskellParser::OpenRoundBracket);
      setState(2617);
      name_boolformula_opt();
      setState(2618);
      match(HaskellParser::CloseRoundBracket);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2620);
      name_var();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamelistContext ------------------------------------------------------------------

HaskellParser::NamelistContext::NamelistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::Name_varContext *> HaskellParser::NamelistContext::name_var() {
  return getRuleContexts<HaskellParser::Name_varContext>();
}

HaskellParser::Name_varContext* HaskellParser::NamelistContext::name_var(size_t i) {
  return getRuleContext<HaskellParser::Name_varContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::NamelistContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::NamelistContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}


size_t HaskellParser::NamelistContext::getRuleIndex() const {
  return HaskellParser::RuleNamelist;
}

void HaskellParser::NamelistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamelist(this);
}

void HaskellParser::NamelistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamelist(this);
}

HaskellParser::NamelistContext* HaskellParser::namelist() {
  NamelistContext *_localctx = _tracker.createInstance<NamelistContext>(_ctx, getState());
  enterRule(_localctx, 394, HaskellParser::RuleNamelist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2623);
    name_var();
    setState(2628);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Comma) {
      setState(2624);
      match(HaskellParser::Comma);
      setState(2625);
      name_var();
      setState(2630);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_varContext ------------------------------------------------------------------

HaskellParser::Name_varContext::Name_varContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Var_Context* HaskellParser::Name_varContext::var_() {
  return getRuleContext<HaskellParser::Var_Context>(0);
}

HaskellParser::ConContext* HaskellParser::Name_varContext::con() {
  return getRuleContext<HaskellParser::ConContext>(0);
}


size_t HaskellParser::Name_varContext::getRuleIndex() const {
  return HaskellParser::RuleName_var;
}

void HaskellParser::Name_varContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterName_var(this);
}

void HaskellParser::Name_varContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitName_var(this);
}

HaskellParser::Name_varContext* HaskellParser::name_var() {
  Name_varContext *_localctx = _tracker.createInstance<Name_varContext>(_ctx, getState());
  enterRule(_localctx, 396, HaskellParser::RuleName_var);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2633);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 300, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2631);
      var_();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2632);
      con();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Qcon_nowiredlistContext ------------------------------------------------------------------

HaskellParser::Qcon_nowiredlistContext::Qcon_nowiredlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Gen_qconContext* HaskellParser::Qcon_nowiredlistContext::gen_qcon() {
  return getRuleContext<HaskellParser::Gen_qconContext>(0);
}

HaskellParser::Sysdcon_nolistContext* HaskellParser::Qcon_nowiredlistContext::sysdcon_nolist() {
  return getRuleContext<HaskellParser::Sysdcon_nolistContext>(0);
}


size_t HaskellParser::Qcon_nowiredlistContext::getRuleIndex() const {
  return HaskellParser::RuleQcon_nowiredlist;
}

void HaskellParser::Qcon_nowiredlistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQcon_nowiredlist(this);
}

void HaskellParser::Qcon_nowiredlistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQcon_nowiredlist(this);
}

HaskellParser::Qcon_nowiredlistContext* HaskellParser::qcon_nowiredlist() {
  Qcon_nowiredlistContext *_localctx = _tracker.createInstance<Qcon_nowiredlistContext>(_ctx, getState());
  enterRule(_localctx, 398, HaskellParser::RuleQcon_nowiredlist);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2637);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 301, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2635);
      gen_qcon();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2636);
      sysdcon_nolist();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QconContext ------------------------------------------------------------------

HaskellParser::QconContext::QconContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Gen_qconContext* HaskellParser::QconContext::gen_qcon() {
  return getRuleContext<HaskellParser::Gen_qconContext>(0);
}

HaskellParser::SysdconContext* HaskellParser::QconContext::sysdcon() {
  return getRuleContext<HaskellParser::SysdconContext>(0);
}


size_t HaskellParser::QconContext::getRuleIndex() const {
  return HaskellParser::RuleQcon;
}

void HaskellParser::QconContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQcon(this);
}

void HaskellParser::QconContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQcon(this);
}

HaskellParser::QconContext* HaskellParser::qcon() {
  QconContext *_localctx = _tracker.createInstance<QconContext>(_ctx, getState());
  enterRule(_localctx, 400, HaskellParser::RuleQcon);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2641);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 302, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2639);
      gen_qcon();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2640);
      sysdcon();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Gen_qconContext ------------------------------------------------------------------

HaskellParser::Gen_qconContext::Gen_qconContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::QconidContext* HaskellParser::Gen_qconContext::qconid() {
  return getRuleContext<HaskellParser::QconidContext>(0);
}

tree::TerminalNode* HaskellParser::Gen_qconContext::OpenRoundBracket() {
  return getToken(HaskellParser::OpenRoundBracket, 0);
}

HaskellParser::QconsymContext* HaskellParser::Gen_qconContext::qconsym() {
  return getRuleContext<HaskellParser::QconsymContext>(0);
}

tree::TerminalNode* HaskellParser::Gen_qconContext::CloseRoundBracket() {
  return getToken(HaskellParser::CloseRoundBracket, 0);
}


size_t HaskellParser::Gen_qconContext::getRuleIndex() const {
  return HaskellParser::RuleGen_qcon;
}

void HaskellParser::Gen_qconContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGen_qcon(this);
}

void HaskellParser::Gen_qconContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGen_qcon(this);
}

HaskellParser::Gen_qconContext* HaskellParser::gen_qcon() {
  Gen_qconContext *_localctx = _tracker.createInstance<Gen_qconContext>(_ctx, getState());
  enterRule(_localctx, 402, HaskellParser::RuleGen_qcon);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2648);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::CONID: {
        enterOuterAlt(_localctx, 1);
        setState(2643);
        qconid();
        break;
      }

      case HaskellParser::OpenRoundBracket: {
        enterOuterAlt(_localctx, 2);
        setState(2644);
        match(HaskellParser::OpenRoundBracket);
        setState(2645);
        qconsym();
        setState(2646);
        match(HaskellParser::CloseRoundBracket);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConContext ------------------------------------------------------------------

HaskellParser::ConContext::ConContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::ConidContext* HaskellParser::ConContext::conid() {
  return getRuleContext<HaskellParser::ConidContext>(0);
}

tree::TerminalNode* HaskellParser::ConContext::OpenRoundBracket() {
  return getToken(HaskellParser::OpenRoundBracket, 0);
}

HaskellParser::ConsymContext* HaskellParser::ConContext::consym() {
  return getRuleContext<HaskellParser::ConsymContext>(0);
}

tree::TerminalNode* HaskellParser::ConContext::CloseRoundBracket() {
  return getToken(HaskellParser::CloseRoundBracket, 0);
}

HaskellParser::SysdconContext* HaskellParser::ConContext::sysdcon() {
  return getRuleContext<HaskellParser::SysdconContext>(0);
}


size_t HaskellParser::ConContext::getRuleIndex() const {
  return HaskellParser::RuleCon;
}

void HaskellParser::ConContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCon(this);
}

void HaskellParser::ConContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCon(this);
}

HaskellParser::ConContext* HaskellParser::con() {
  ConContext *_localctx = _tracker.createInstance<ConContext>(_ctx, getState());
  enterRule(_localctx, 404, HaskellParser::RuleCon);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2656);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 304, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2650);
      conid();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2651);
      match(HaskellParser::OpenRoundBracket);
      setState(2652);
      consym();
      setState(2653);
      match(HaskellParser::CloseRoundBracket);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2655);
      sysdcon();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Con_listContext ------------------------------------------------------------------

HaskellParser::Con_listContext::Con_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::ConContext *> HaskellParser::Con_listContext::con() {
  return getRuleContexts<HaskellParser::ConContext>();
}

HaskellParser::ConContext* HaskellParser::Con_listContext::con(size_t i) {
  return getRuleContext<HaskellParser::ConContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::Con_listContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::Con_listContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}


size_t HaskellParser::Con_listContext::getRuleIndex() const {
  return HaskellParser::RuleCon_list;
}

void HaskellParser::Con_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCon_list(this);
}

void HaskellParser::Con_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCon_list(this);
}

HaskellParser::Con_listContext* HaskellParser::con_list() {
  Con_listContext *_localctx = _tracker.createInstance<Con_listContext>(_ctx, getState());
  enterRule(_localctx, 406, HaskellParser::RuleCon_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2658);
    con();
    setState(2663);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HaskellParser::Comma) {
      setState(2659);
      match(HaskellParser::Comma);
      setState(2660);
      con();
      setState(2665);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sysdcon_nolistContext ------------------------------------------------------------------

HaskellParser::Sysdcon_nolistContext::Sysdcon_nolistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Sysdcon_nolistContext::OpenRoundBracket() {
  return getToken(HaskellParser::OpenRoundBracket, 0);
}

tree::TerminalNode* HaskellParser::Sysdcon_nolistContext::CloseRoundBracket() {
  return getToken(HaskellParser::CloseRoundBracket, 0);
}

HaskellParser::CommasContext* HaskellParser::Sysdcon_nolistContext::commas() {
  return getRuleContext<HaskellParser::CommasContext>(0);
}

tree::TerminalNode* HaskellParser::Sysdcon_nolistContext::OpenBoxParen() {
  return getToken(HaskellParser::OpenBoxParen, 0);
}

tree::TerminalNode* HaskellParser::Sysdcon_nolistContext::CloseBoxParen() {
  return getToken(HaskellParser::CloseBoxParen, 0);
}


size_t HaskellParser::Sysdcon_nolistContext::getRuleIndex() const {
  return HaskellParser::RuleSysdcon_nolist;
}

void HaskellParser::Sysdcon_nolistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSysdcon_nolist(this);
}

void HaskellParser::Sysdcon_nolistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSysdcon_nolist(this);
}

HaskellParser::Sysdcon_nolistContext* HaskellParser::sysdcon_nolist() {
  Sysdcon_nolistContext *_localctx = _tracker.createInstance<Sysdcon_nolistContext>(_ctx, getState());
  enterRule(_localctx, 408, HaskellParser::RuleSysdcon_nolist);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2678);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 306, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2666);
      match(HaskellParser::OpenRoundBracket);
      setState(2667);
      match(HaskellParser::CloseRoundBracket);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2668);
      match(HaskellParser::OpenRoundBracket);
      setState(2669);
      commas();
      setState(2670);
      match(HaskellParser::CloseRoundBracket);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2672);
      match(HaskellParser::OpenBoxParen);
      setState(2673);
      match(HaskellParser::CloseBoxParen);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2674);
      match(HaskellParser::OpenBoxParen);
      setState(2675);
      commas();
      setState(2676);
      match(HaskellParser::CloseBoxParen);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SysdconContext ------------------------------------------------------------------

HaskellParser::SysdconContext::SysdconContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Sysdcon_nolistContext* HaskellParser::SysdconContext::sysdcon_nolist() {
  return getRuleContext<HaskellParser::Sysdcon_nolistContext>(0);
}

tree::TerminalNode* HaskellParser::SysdconContext::OpenSquareBracket() {
  return getToken(HaskellParser::OpenSquareBracket, 0);
}

tree::TerminalNode* HaskellParser::SysdconContext::CloseSquareBracket() {
  return getToken(HaskellParser::CloseSquareBracket, 0);
}


size_t HaskellParser::SysdconContext::getRuleIndex() const {
  return HaskellParser::RuleSysdcon;
}

void HaskellParser::SysdconContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSysdcon(this);
}

void HaskellParser::SysdconContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSysdcon(this);
}

HaskellParser::SysdconContext* HaskellParser::sysdcon() {
  SysdconContext *_localctx = _tracker.createInstance<SysdconContext>(_ctx, getState());
  enterRule(_localctx, 410, HaskellParser::RuleSysdcon);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2683);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::OpenBoxParen:
      case HaskellParser::OpenRoundBracket: {
        enterOuterAlt(_localctx, 1);
        setState(2680);
        sysdcon_nolist();
        break;
      }

      case HaskellParser::OpenSquareBracket: {
        enterOuterAlt(_localctx, 2);
        setState(2681);
        match(HaskellParser::OpenSquareBracket);
        setState(2682);
        match(HaskellParser::CloseSquareBracket);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConopContext ------------------------------------------------------------------

HaskellParser::ConopContext::ConopContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::ConsymContext* HaskellParser::ConopContext::consym() {
  return getRuleContext<HaskellParser::ConsymContext>(0);
}

std::vector<tree::TerminalNode *> HaskellParser::ConopContext::BackQuote() {
  return getTokens(HaskellParser::BackQuote);
}

tree::TerminalNode* HaskellParser::ConopContext::BackQuote(size_t i) {
  return getToken(HaskellParser::BackQuote, i);
}

HaskellParser::ConidContext* HaskellParser::ConopContext::conid() {
  return getRuleContext<HaskellParser::ConidContext>(0);
}


size_t HaskellParser::ConopContext::getRuleIndex() const {
  return HaskellParser::RuleConop;
}

void HaskellParser::ConopContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConop(this);
}

void HaskellParser::ConopContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConop(this);
}

HaskellParser::ConopContext* HaskellParser::conop() {
  ConopContext *_localctx = _tracker.createInstance<ConopContext>(_ctx, getState());
  enterRule(_localctx, 412, HaskellParser::RuleConop);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2690);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::Colon: {
        enterOuterAlt(_localctx, 1);
        setState(2685);
        consym();
        break;
      }

      case HaskellParser::BackQuote: {
        enterOuterAlt(_localctx, 2);
        setState(2686);
        match(HaskellParser::BackQuote);
        setState(2687);
        conid();
        setState(2688);
        match(HaskellParser::BackQuote);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QconopContext ------------------------------------------------------------------

HaskellParser::QconopContext::QconopContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::GconsymContext* HaskellParser::QconopContext::gconsym() {
  return getRuleContext<HaskellParser::GconsymContext>(0);
}

std::vector<tree::TerminalNode *> HaskellParser::QconopContext::BackQuote() {
  return getTokens(HaskellParser::BackQuote);
}

tree::TerminalNode* HaskellParser::QconopContext::BackQuote(size_t i) {
  return getToken(HaskellParser::BackQuote, i);
}

HaskellParser::QconidContext* HaskellParser::QconopContext::qconid() {
  return getRuleContext<HaskellParser::QconidContext>(0);
}


size_t HaskellParser::QconopContext::getRuleIndex() const {
  return HaskellParser::RuleQconop;
}

void HaskellParser::QconopContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQconop(this);
}

void HaskellParser::QconopContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQconop(this);
}

HaskellParser::QconopContext* HaskellParser::qconop() {
  QconopContext *_localctx = _tracker.createInstance<QconopContext>(_ctx, getState());
  enterRule(_localctx, 414, HaskellParser::RuleQconop);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2697);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::Colon:
      case HaskellParser::CONID: {
        enterOuterAlt(_localctx, 1);
        setState(2692);
        gconsym();
        break;
      }

      case HaskellParser::BackQuote: {
        enterOuterAlt(_localctx, 2);
        setState(2693);
        match(HaskellParser::BackQuote);
        setState(2694);
        qconid();
        setState(2695);
        match(HaskellParser::BackQuote);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GconsymContext ------------------------------------------------------------------

HaskellParser::GconsymContext::GconsymContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::GconsymContext::Colon() {
  return getToken(HaskellParser::Colon, 0);
}

HaskellParser::QconsymContext* HaskellParser::GconsymContext::qconsym() {
  return getRuleContext<HaskellParser::QconsymContext>(0);
}


size_t HaskellParser::GconsymContext::getRuleIndex() const {
  return HaskellParser::RuleGconsym;
}

void HaskellParser::GconsymContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGconsym(this);
}

void HaskellParser::GconsymContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGconsym(this);
}

HaskellParser::GconsymContext* HaskellParser::gconsym() {
  GconsymContext *_localctx = _tracker.createInstance<GconsymContext>(_ctx, getState());
  enterRule(_localctx, 416, HaskellParser::RuleGconsym);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2701);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 310, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2699);
      match(HaskellParser::Colon);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2700);
      qconsym();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GtyconContext ------------------------------------------------------------------

HaskellParser::GtyconContext::GtyconContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::NtgtyconContext* HaskellParser::GtyconContext::ntgtycon() {
  return getRuleContext<HaskellParser::NtgtyconContext>(0);
}

tree::TerminalNode* HaskellParser::GtyconContext::OpenRoundBracket() {
  return getToken(HaskellParser::OpenRoundBracket, 0);
}

tree::TerminalNode* HaskellParser::GtyconContext::CloseRoundBracket() {
  return getToken(HaskellParser::CloseRoundBracket, 0);
}

tree::TerminalNode* HaskellParser::GtyconContext::OpenBoxParen() {
  return getToken(HaskellParser::OpenBoxParen, 0);
}

tree::TerminalNode* HaskellParser::GtyconContext::CloseBoxParen() {
  return getToken(HaskellParser::CloseBoxParen, 0);
}


size_t HaskellParser::GtyconContext::getRuleIndex() const {
  return HaskellParser::RuleGtycon;
}

void HaskellParser::GtyconContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGtycon(this);
}

void HaskellParser::GtyconContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGtycon(this);
}

HaskellParser::GtyconContext* HaskellParser::gtycon() {
  GtyconContext *_localctx = _tracker.createInstance<GtyconContext>(_ctx, getState());
  enterRule(_localctx, 418, HaskellParser::RuleGtycon);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2708);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 311, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2703);
      ntgtycon();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2704);
      match(HaskellParser::OpenRoundBracket);
      setState(2705);
      match(HaskellParser::CloseRoundBracket);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2706);
      match(HaskellParser::OpenBoxParen);
      setState(2707);
      match(HaskellParser::CloseBoxParen);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NtgtyconContext ------------------------------------------------------------------

HaskellParser::NtgtyconContext::NtgtyconContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::OqtyconContext* HaskellParser::NtgtyconContext::oqtycon() {
  return getRuleContext<HaskellParser::OqtyconContext>(0);
}

tree::TerminalNode* HaskellParser::NtgtyconContext::OpenRoundBracket() {
  return getToken(HaskellParser::OpenRoundBracket, 0);
}

HaskellParser::CommasContext* HaskellParser::NtgtyconContext::commas() {
  return getRuleContext<HaskellParser::CommasContext>(0);
}

tree::TerminalNode* HaskellParser::NtgtyconContext::CloseRoundBracket() {
  return getToken(HaskellParser::CloseRoundBracket, 0);
}

tree::TerminalNode* HaskellParser::NtgtyconContext::OpenBoxParen() {
  return getToken(HaskellParser::OpenBoxParen, 0);
}

tree::TerminalNode* HaskellParser::NtgtyconContext::CloseBoxParen() {
  return getToken(HaskellParser::CloseBoxParen, 0);
}

tree::TerminalNode* HaskellParser::NtgtyconContext::Arrow() {
  return getToken(HaskellParser::Arrow, 0);
}

tree::TerminalNode* HaskellParser::NtgtyconContext::OpenSquareBracket() {
  return getToken(HaskellParser::OpenSquareBracket, 0);
}

tree::TerminalNode* HaskellParser::NtgtyconContext::CloseSquareBracket() {
  return getToken(HaskellParser::CloseSquareBracket, 0);
}


size_t HaskellParser::NtgtyconContext::getRuleIndex() const {
  return HaskellParser::RuleNtgtycon;
}

void HaskellParser::NtgtyconContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNtgtycon(this);
}

void HaskellParser::NtgtyconContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNtgtycon(this);
}

HaskellParser::NtgtyconContext* HaskellParser::ntgtycon() {
  NtgtyconContext *_localctx = _tracker.createInstance<NtgtyconContext>(_ctx, getState());
  enterRule(_localctx, 420, HaskellParser::RuleNtgtycon);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2724);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 312, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2710);
      oqtycon();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2711);
      match(HaskellParser::OpenRoundBracket);
      setState(2712);
      commas();
      setState(2713);
      match(HaskellParser::CloseRoundBracket);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2715);
      match(HaskellParser::OpenBoxParen);
      setState(2716);
      commas();
      setState(2717);
      match(HaskellParser::CloseBoxParen);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2719);
      match(HaskellParser::OpenRoundBracket);
      setState(2720);
      match(HaskellParser::Arrow);
      setState(2721);
      match(HaskellParser::CloseRoundBracket);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2722);
      match(HaskellParser::OpenSquareBracket);
      setState(2723);
      match(HaskellParser::CloseSquareBracket);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OqtyconContext ------------------------------------------------------------------

HaskellParser::OqtyconContext::OqtyconContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::QtyconContext* HaskellParser::OqtyconContext::qtycon() {
  return getRuleContext<HaskellParser::QtyconContext>(0);
}

tree::TerminalNode* HaskellParser::OqtyconContext::OpenRoundBracket() {
  return getToken(HaskellParser::OpenRoundBracket, 0);
}

HaskellParser::QtyconsymContext* HaskellParser::OqtyconContext::qtyconsym() {
  return getRuleContext<HaskellParser::QtyconsymContext>(0);
}

tree::TerminalNode* HaskellParser::OqtyconContext::CloseRoundBracket() {
  return getToken(HaskellParser::CloseRoundBracket, 0);
}


size_t HaskellParser::OqtyconContext::getRuleIndex() const {
  return HaskellParser::RuleOqtycon;
}

void HaskellParser::OqtyconContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOqtycon(this);
}

void HaskellParser::OqtyconContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOqtycon(this);
}

HaskellParser::OqtyconContext* HaskellParser::oqtycon() {
  OqtyconContext *_localctx = _tracker.createInstance<OqtyconContext>(_ctx, getState());
  enterRule(_localctx, 422, HaskellParser::RuleOqtycon);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2731);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::CONID: {
        enterOuterAlt(_localctx, 1);
        setState(2726);
        qtycon();
        break;
      }

      case HaskellParser::OpenRoundBracket: {
        enterOuterAlt(_localctx, 2);
        setState(2727);
        match(HaskellParser::OpenRoundBracket);
        setState(2728);
        qtyconsym();
        setState(2729);
        match(HaskellParser::CloseRoundBracket);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QtyconopContext ------------------------------------------------------------------

HaskellParser::QtyconopContext::QtyconopContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::QtyconsymContext* HaskellParser::QtyconopContext::qtyconsym() {
  return getRuleContext<HaskellParser::QtyconsymContext>(0);
}

std::vector<tree::TerminalNode *> HaskellParser::QtyconopContext::BackQuote() {
  return getTokens(HaskellParser::BackQuote);
}

tree::TerminalNode* HaskellParser::QtyconopContext::BackQuote(size_t i) {
  return getToken(HaskellParser::BackQuote, i);
}

HaskellParser::QtyconContext* HaskellParser::QtyconopContext::qtycon() {
  return getRuleContext<HaskellParser::QtyconContext>(0);
}


size_t HaskellParser::QtyconopContext::getRuleIndex() const {
  return HaskellParser::RuleQtyconop;
}

void HaskellParser::QtyconopContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQtyconop(this);
}

void HaskellParser::QtyconopContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQtyconop(this);
}

HaskellParser::QtyconopContext* HaskellParser::qtyconop() {
  QtyconopContext *_localctx = _tracker.createInstance<QtyconopContext>(_ctx, getState());
  enterRule(_localctx, 424, HaskellParser::RuleQtyconop);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2738);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::Hash:
      case HaskellParser::Less:
      case HaskellParser::Greater:
      case HaskellParser::Ampersand:
      case HaskellParser::Pipe:
      case HaskellParser::Bang:
      case HaskellParser::Caret:
      case HaskellParser::Plus:
      case HaskellParser::Minus:
      case HaskellParser::Asterisk:
      case HaskellParser::Percent:
      case HaskellParser::Divide:
      case HaskellParser::Tilde:
      case HaskellParser::Atsign:
      case HaskellParser::Dollar:
      case HaskellParser::Dot:
      case HaskellParser::QuestionMark:
      case HaskellParser::Colon:
      case HaskellParser::Eq:
      case HaskellParser::ReverseSlash:
      case HaskellParser::CONID: {
        enterOuterAlt(_localctx, 1);
        setState(2733);
        qtyconsym();
        break;
      }

      case HaskellParser::BackQuote: {
        enterOuterAlt(_localctx, 2);
        setState(2734);
        match(HaskellParser::BackQuote);
        setState(2735);
        qtycon();
        setState(2736);
        match(HaskellParser::BackQuote);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QtyconContext ------------------------------------------------------------------

HaskellParser::QtyconContext::QtyconContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::TyconContext* HaskellParser::QtyconContext::tycon() {
  return getRuleContext<HaskellParser::TyconContext>(0);
}

HaskellParser::ModidContext* HaskellParser::QtyconContext::modid() {
  return getRuleContext<HaskellParser::ModidContext>(0);
}

tree::TerminalNode* HaskellParser::QtyconContext::Dot() {
  return getToken(HaskellParser::Dot, 0);
}


size_t HaskellParser::QtyconContext::getRuleIndex() const {
  return HaskellParser::RuleQtycon;
}

void HaskellParser::QtyconContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQtycon(this);
}

void HaskellParser::QtyconContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQtycon(this);
}

HaskellParser::QtyconContext* HaskellParser::qtycon() {
  QtyconContext *_localctx = _tracker.createInstance<QtyconContext>(_ctx, getState());
  enterRule(_localctx, 426, HaskellParser::RuleQtycon);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2743);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 315, _ctx)) {
    case 1: {
      setState(2740);
      modid();
      setState(2741);
      match(HaskellParser::Dot);
      break;
    }

    default:
      break;
    }
    setState(2745);
    tycon();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TyconContext ------------------------------------------------------------------

HaskellParser::TyconContext::TyconContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::ConidContext* HaskellParser::TyconContext::conid() {
  return getRuleContext<HaskellParser::ConidContext>(0);
}


size_t HaskellParser::TyconContext::getRuleIndex() const {
  return HaskellParser::RuleTycon;
}

void HaskellParser::TyconContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTycon(this);
}

void HaskellParser::TyconContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTycon(this);
}

HaskellParser::TyconContext* HaskellParser::tycon() {
  TyconContext *_localctx = _tracker.createInstance<TyconContext>(_ctx, getState());
  enterRule(_localctx, 428, HaskellParser::RuleTycon);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2747);
    conid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QtyconsymContext ------------------------------------------------------------------

HaskellParser::QtyconsymContext::QtyconsymContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::QconsymContext* HaskellParser::QtyconsymContext::qconsym() {
  return getRuleContext<HaskellParser::QconsymContext>(0);
}

HaskellParser::QvarsymContext* HaskellParser::QtyconsymContext::qvarsym() {
  return getRuleContext<HaskellParser::QvarsymContext>(0);
}

HaskellParser::TyconsymContext* HaskellParser::QtyconsymContext::tyconsym() {
  return getRuleContext<HaskellParser::TyconsymContext>(0);
}


size_t HaskellParser::QtyconsymContext::getRuleIndex() const {
  return HaskellParser::RuleQtyconsym;
}

void HaskellParser::QtyconsymContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQtyconsym(this);
}

void HaskellParser::QtyconsymContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQtyconsym(this);
}

HaskellParser::QtyconsymContext* HaskellParser::qtyconsym() {
  QtyconsymContext *_localctx = _tracker.createInstance<QtyconsymContext>(_ctx, getState());
  enterRule(_localctx, 430, HaskellParser::RuleQtyconsym);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2752);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 316, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2749);
      qconsym();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2750);
      qvarsym();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2751);
      tyconsym();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TyconsymContext ------------------------------------------------------------------

HaskellParser::TyconsymContext::TyconsymContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::ConsymContext* HaskellParser::TyconsymContext::consym() {
  return getRuleContext<HaskellParser::ConsymContext>(0);
}

HaskellParser::VarsymContext* HaskellParser::TyconsymContext::varsym() {
  return getRuleContext<HaskellParser::VarsymContext>(0);
}

tree::TerminalNode* HaskellParser::TyconsymContext::Colon() {
  return getToken(HaskellParser::Colon, 0);
}

tree::TerminalNode* HaskellParser::TyconsymContext::Minus() {
  return getToken(HaskellParser::Minus, 0);
}

tree::TerminalNode* HaskellParser::TyconsymContext::Dot() {
  return getToken(HaskellParser::Dot, 0);
}


size_t HaskellParser::TyconsymContext::getRuleIndex() const {
  return HaskellParser::RuleTyconsym;
}

void HaskellParser::TyconsymContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTyconsym(this);
}

void HaskellParser::TyconsymContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTyconsym(this);
}

HaskellParser::TyconsymContext* HaskellParser::tyconsym() {
  TyconsymContext *_localctx = _tracker.createInstance<TyconsymContext>(_ctx, getState());
  enterRule(_localctx, 432, HaskellParser::RuleTyconsym);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2759);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 317, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2754);
      consym();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2755);
      varsym();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2756);
      match(HaskellParser::Colon);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2757);
      match(HaskellParser::Minus);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2758);
      match(HaskellParser::Dot);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OpContext ------------------------------------------------------------------

HaskellParser::OpContext::OpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::VaropContext* HaskellParser::OpContext::varop() {
  return getRuleContext<HaskellParser::VaropContext>(0);
}

HaskellParser::ConopContext* HaskellParser::OpContext::conop() {
  return getRuleContext<HaskellParser::ConopContext>(0);
}


size_t HaskellParser::OpContext::getRuleIndex() const {
  return HaskellParser::RuleOp;
}

void HaskellParser::OpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp(this);
}

void HaskellParser::OpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp(this);
}

HaskellParser::OpContext* HaskellParser::op() {
  OpContext *_localctx = _tracker.createInstance<OpContext>(_ctx, getState());
  enterRule(_localctx, 434, HaskellParser::RuleOp);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2763);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 318, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2761);
      varop();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2762);
      conop();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VaropContext ------------------------------------------------------------------

HaskellParser::VaropContext::VaropContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::VarsymContext* HaskellParser::VaropContext::varsym() {
  return getRuleContext<HaskellParser::VarsymContext>(0);
}

std::vector<tree::TerminalNode *> HaskellParser::VaropContext::BackQuote() {
  return getTokens(HaskellParser::BackQuote);
}

tree::TerminalNode* HaskellParser::VaropContext::BackQuote(size_t i) {
  return getToken(HaskellParser::BackQuote, i);
}

HaskellParser::VaridContext* HaskellParser::VaropContext::varid() {
  return getRuleContext<HaskellParser::VaridContext>(0);
}


size_t HaskellParser::VaropContext::getRuleIndex() const {
  return HaskellParser::RuleVarop;
}

void HaskellParser::VaropContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarop(this);
}

void HaskellParser::VaropContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarop(this);
}

HaskellParser::VaropContext* HaskellParser::varop() {
  VaropContext *_localctx = _tracker.createInstance<VaropContext>(_ctx, getState());
  enterRule(_localctx, 436, HaskellParser::RuleVarop);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2770);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::Hash:
      case HaskellParser::Less:
      case HaskellParser::Greater:
      case HaskellParser::Ampersand:
      case HaskellParser::Pipe:
      case HaskellParser::Bang:
      case HaskellParser::Caret:
      case HaskellParser::Plus:
      case HaskellParser::Minus:
      case HaskellParser::Asterisk:
      case HaskellParser::Percent:
      case HaskellParser::Divide:
      case HaskellParser::Tilde:
      case HaskellParser::Atsign:
      case HaskellParser::Dollar:
      case HaskellParser::Dot:
      case HaskellParser::QuestionMark:
      case HaskellParser::Colon:
      case HaskellParser::Eq:
      case HaskellParser::ReverseSlash: {
        enterOuterAlt(_localctx, 1);
        setState(2765);
        varsym();
        break;
      }

      case HaskellParser::BackQuote: {
        enterOuterAlt(_localctx, 2);
        setState(2766);
        match(HaskellParser::BackQuote);
        setState(2767);
        varid();
        setState(2768);
        match(HaskellParser::BackQuote);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QopContext ------------------------------------------------------------------

HaskellParser::QopContext::QopContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::QvaropContext* HaskellParser::QopContext::qvarop() {
  return getRuleContext<HaskellParser::QvaropContext>(0);
}

HaskellParser::QconopContext* HaskellParser::QopContext::qconop() {
  return getRuleContext<HaskellParser::QconopContext>(0);
}


size_t HaskellParser::QopContext::getRuleIndex() const {
  return HaskellParser::RuleQop;
}

void HaskellParser::QopContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQop(this);
}

void HaskellParser::QopContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQop(this);
}

HaskellParser::QopContext* HaskellParser::qop() {
  QopContext *_localctx = _tracker.createInstance<QopContext>(_ctx, getState());
  enterRule(_localctx, 438, HaskellParser::RuleQop);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2774);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 320, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2772);
      qvarop();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2773);
      qconop();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QopmContext ------------------------------------------------------------------

HaskellParser::QopmContext::QopmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::QvaropmContext* HaskellParser::QopmContext::qvaropm() {
  return getRuleContext<HaskellParser::QvaropmContext>(0);
}

HaskellParser::QconopContext* HaskellParser::QopmContext::qconop() {
  return getRuleContext<HaskellParser::QconopContext>(0);
}

HaskellParser::Hole_opContext* HaskellParser::QopmContext::hole_op() {
  return getRuleContext<HaskellParser::Hole_opContext>(0);
}


size_t HaskellParser::QopmContext::getRuleIndex() const {
  return HaskellParser::RuleQopm;
}

void HaskellParser::QopmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQopm(this);
}

void HaskellParser::QopmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQopm(this);
}

HaskellParser::QopmContext* HaskellParser::qopm() {
  QopmContext *_localctx = _tracker.createInstance<QopmContext>(_ctx, getState());
  enterRule(_localctx, 440, HaskellParser::RuleQopm);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2779);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 321, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2776);
      qvaropm();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2777);
      qconop();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2778);
      hole_op();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hole_opContext ------------------------------------------------------------------

HaskellParser::Hole_opContext::Hole_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> HaskellParser::Hole_opContext::BackQuote() {
  return getTokens(HaskellParser::BackQuote);
}

tree::TerminalNode* HaskellParser::Hole_opContext::BackQuote(size_t i) {
  return getToken(HaskellParser::BackQuote, i);
}

tree::TerminalNode* HaskellParser::Hole_opContext::WILDCARD() {
  return getToken(HaskellParser::WILDCARD, 0);
}


size_t HaskellParser::Hole_opContext::getRuleIndex() const {
  return HaskellParser::RuleHole_op;
}

void HaskellParser::Hole_opContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHole_op(this);
}

void HaskellParser::Hole_opContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHole_op(this);
}

HaskellParser::Hole_opContext* HaskellParser::hole_op() {
  Hole_opContext *_localctx = _tracker.createInstance<Hole_opContext>(_ctx, getState());
  enterRule(_localctx, 442, HaskellParser::RuleHole_op);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2781);
    match(HaskellParser::BackQuote);
    setState(2782);
    match(HaskellParser::WILDCARD);
    setState(2783);
    match(HaskellParser::BackQuote);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QvaropContext ------------------------------------------------------------------

HaskellParser::QvaropContext::QvaropContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::QvarsymContext* HaskellParser::QvaropContext::qvarsym() {
  return getRuleContext<HaskellParser::QvarsymContext>(0);
}

std::vector<tree::TerminalNode *> HaskellParser::QvaropContext::BackQuote() {
  return getTokens(HaskellParser::BackQuote);
}

tree::TerminalNode* HaskellParser::QvaropContext::BackQuote(size_t i) {
  return getToken(HaskellParser::BackQuote, i);
}

HaskellParser::QvaridContext* HaskellParser::QvaropContext::qvarid() {
  return getRuleContext<HaskellParser::QvaridContext>(0);
}


size_t HaskellParser::QvaropContext::getRuleIndex() const {
  return HaskellParser::RuleQvarop;
}

void HaskellParser::QvaropContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQvarop(this);
}

void HaskellParser::QvaropContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQvarop(this);
}

HaskellParser::QvaropContext* HaskellParser::qvarop() {
  QvaropContext *_localctx = _tracker.createInstance<QvaropContext>(_ctx, getState());
  enterRule(_localctx, 444, HaskellParser::RuleQvarop);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2790);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::Hash:
      case HaskellParser::Less:
      case HaskellParser::Greater:
      case HaskellParser::Ampersand:
      case HaskellParser::Pipe:
      case HaskellParser::Bang:
      case HaskellParser::Caret:
      case HaskellParser::Plus:
      case HaskellParser::Minus:
      case HaskellParser::Asterisk:
      case HaskellParser::Percent:
      case HaskellParser::Divide:
      case HaskellParser::Tilde:
      case HaskellParser::Atsign:
      case HaskellParser::Dollar:
      case HaskellParser::Dot:
      case HaskellParser::QuestionMark:
      case HaskellParser::Colon:
      case HaskellParser::Eq:
      case HaskellParser::ReverseSlash:
      case HaskellParser::CONID: {
        enterOuterAlt(_localctx, 1);
        setState(2785);
        qvarsym();
        break;
      }

      case HaskellParser::BackQuote: {
        enterOuterAlt(_localctx, 2);
        setState(2786);
        match(HaskellParser::BackQuote);
        setState(2787);
        qvarid();
        setState(2788);
        match(HaskellParser::BackQuote);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QvaropmContext ------------------------------------------------------------------

HaskellParser::QvaropmContext::QvaropmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Qvarsym_no_minusContext* HaskellParser::QvaropmContext::qvarsym_no_minus() {
  return getRuleContext<HaskellParser::Qvarsym_no_minusContext>(0);
}

std::vector<tree::TerminalNode *> HaskellParser::QvaropmContext::BackQuote() {
  return getTokens(HaskellParser::BackQuote);
}

tree::TerminalNode* HaskellParser::QvaropmContext::BackQuote(size_t i) {
  return getToken(HaskellParser::BackQuote, i);
}

HaskellParser::QvaridContext* HaskellParser::QvaropmContext::qvarid() {
  return getRuleContext<HaskellParser::QvaridContext>(0);
}


size_t HaskellParser::QvaropmContext::getRuleIndex() const {
  return HaskellParser::RuleQvaropm;
}

void HaskellParser::QvaropmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQvaropm(this);
}

void HaskellParser::QvaropmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQvaropm(this);
}

HaskellParser::QvaropmContext* HaskellParser::qvaropm() {
  QvaropmContext *_localctx = _tracker.createInstance<QvaropmContext>(_ctx, getState());
  enterRule(_localctx, 446, HaskellParser::RuleQvaropm);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2797);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::Hash:
      case HaskellParser::Less:
      case HaskellParser::Greater:
      case HaskellParser::Ampersand:
      case HaskellParser::Pipe:
      case HaskellParser::Bang:
      case HaskellParser::Caret:
      case HaskellParser::Plus:
      case HaskellParser::Minus:
      case HaskellParser::Asterisk:
      case HaskellParser::Percent:
      case HaskellParser::Divide:
      case HaskellParser::Tilde:
      case HaskellParser::Atsign:
      case HaskellParser::Dollar:
      case HaskellParser::Dot:
      case HaskellParser::QuestionMark:
      case HaskellParser::Colon:
      case HaskellParser::Eq:
      case HaskellParser::ReverseSlash:
      case HaskellParser::CONID: {
        enterOuterAlt(_localctx, 1);
        setState(2792);
        qvarsym_no_minus();
        break;
      }

      case HaskellParser::BackQuote: {
        enterOuterAlt(_localctx, 2);
        setState(2793);
        match(HaskellParser::BackQuote);
        setState(2794);
        qvarid();
        setState(2795);
        match(HaskellParser::BackQuote);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TyvarContext ------------------------------------------------------------------

HaskellParser::TyvarContext::TyvarContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::VaridContext* HaskellParser::TyvarContext::varid() {
  return getRuleContext<HaskellParser::VaridContext>(0);
}


size_t HaskellParser::TyvarContext::getRuleIndex() const {
  return HaskellParser::RuleTyvar;
}

void HaskellParser::TyvarContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTyvar(this);
}

void HaskellParser::TyvarContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTyvar(this);
}

HaskellParser::TyvarContext* HaskellParser::tyvar() {
  TyvarContext *_localctx = _tracker.createInstance<TyvarContext>(_ctx, getState());
  enterRule(_localctx, 448, HaskellParser::RuleTyvar);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2799);
    varid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TyvaropContext ------------------------------------------------------------------

HaskellParser::TyvaropContext::TyvaropContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> HaskellParser::TyvaropContext::BackQuote() {
  return getTokens(HaskellParser::BackQuote);
}

tree::TerminalNode* HaskellParser::TyvaropContext::BackQuote(size_t i) {
  return getToken(HaskellParser::BackQuote, i);
}

HaskellParser::TyvaridContext* HaskellParser::TyvaropContext::tyvarid() {
  return getRuleContext<HaskellParser::TyvaridContext>(0);
}


size_t HaskellParser::TyvaropContext::getRuleIndex() const {
  return HaskellParser::RuleTyvarop;
}

void HaskellParser::TyvaropContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTyvarop(this);
}

void HaskellParser::TyvaropContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTyvarop(this);
}

HaskellParser::TyvaropContext* HaskellParser::tyvarop() {
  TyvaropContext *_localctx = _tracker.createInstance<TyvaropContext>(_ctx, getState());
  enterRule(_localctx, 450, HaskellParser::RuleTyvarop);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2801);
    match(HaskellParser::BackQuote);
    setState(2802);
    tyvarid();
    setState(2803);
    match(HaskellParser::BackQuote);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TyvaridContext ------------------------------------------------------------------

HaskellParser::TyvaridContext::TyvaridContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::VaridContext* HaskellParser::TyvaridContext::varid() {
  return getRuleContext<HaskellParser::VaridContext>(0);
}

HaskellParser::Special_idContext* HaskellParser::TyvaridContext::special_id() {
  return getRuleContext<HaskellParser::Special_idContext>(0);
}

tree::TerminalNode* HaskellParser::TyvaridContext::UNSAFE() {
  return getToken(HaskellParser::UNSAFE, 0);
}

tree::TerminalNode* HaskellParser::TyvaridContext::SAFE() {
  return getToken(HaskellParser::SAFE, 0);
}

tree::TerminalNode* HaskellParser::TyvaridContext::INTERRUPTIBLE() {
  return getToken(HaskellParser::INTERRUPTIBLE, 0);
}


size_t HaskellParser::TyvaridContext::getRuleIndex() const {
  return HaskellParser::RuleTyvarid;
}

void HaskellParser::TyvaridContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTyvarid(this);
}

void HaskellParser::TyvaridContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTyvarid(this);
}

HaskellParser::TyvaridContext* HaskellParser::tyvarid() {
  TyvaridContext *_localctx = _tracker.createInstance<TyvaridContext>(_ctx, getState());
  enterRule(_localctx, 452, HaskellParser::RuleTyvarid);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2810);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 324, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2805);
      varid();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2806);
      special_id();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2807);
      match(HaskellParser::UNSAFE);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2808);
      match(HaskellParser::SAFE);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2809);
      match(HaskellParser::INTERRUPTIBLE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TyclsContext ------------------------------------------------------------------

HaskellParser::TyclsContext::TyclsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::ConidContext* HaskellParser::TyclsContext::conid() {
  return getRuleContext<HaskellParser::ConidContext>(0);
}


size_t HaskellParser::TyclsContext::getRuleIndex() const {
  return HaskellParser::RuleTycls;
}

void HaskellParser::TyclsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTycls(this);
}

void HaskellParser::TyclsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTycls(this);
}

HaskellParser::TyclsContext* HaskellParser::tycls() {
  TyclsContext *_localctx = _tracker.createInstance<TyclsContext>(_ctx, getState());
  enterRule(_localctx, 454, HaskellParser::RuleTycls);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2812);
    conid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QtyclsContext ------------------------------------------------------------------

HaskellParser::QtyclsContext::QtyclsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::TyclsContext* HaskellParser::QtyclsContext::tycls() {
  return getRuleContext<HaskellParser::TyclsContext>(0);
}

HaskellParser::ModidContext* HaskellParser::QtyclsContext::modid() {
  return getRuleContext<HaskellParser::ModidContext>(0);
}

tree::TerminalNode* HaskellParser::QtyclsContext::Dot() {
  return getToken(HaskellParser::Dot, 0);
}


size_t HaskellParser::QtyclsContext::getRuleIndex() const {
  return HaskellParser::RuleQtycls;
}

void HaskellParser::QtyclsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQtycls(this);
}

void HaskellParser::QtyclsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQtycls(this);
}

HaskellParser::QtyclsContext* HaskellParser::qtycls() {
  QtyclsContext *_localctx = _tracker.createInstance<QtyclsContext>(_ctx, getState());
  enterRule(_localctx, 456, HaskellParser::RuleQtycls);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2817);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 325, _ctx)) {
    case 1: {
      setState(2814);
      modid();
      setState(2815);
      match(HaskellParser::Dot);
      break;
    }

    default:
      break;
    }
    setState(2819);
    tycls();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Var_Context ------------------------------------------------------------------

HaskellParser::Var_Context::Var_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::VaridContext* HaskellParser::Var_Context::varid() {
  return getRuleContext<HaskellParser::VaridContext>(0);
}

tree::TerminalNode* HaskellParser::Var_Context::OpenRoundBracket() {
  return getToken(HaskellParser::OpenRoundBracket, 0);
}

HaskellParser::VarsymContext* HaskellParser::Var_Context::varsym() {
  return getRuleContext<HaskellParser::VarsymContext>(0);
}

tree::TerminalNode* HaskellParser::Var_Context::CloseRoundBracket() {
  return getToken(HaskellParser::CloseRoundBracket, 0);
}


size_t HaskellParser::Var_Context::getRuleIndex() const {
  return HaskellParser::RuleVar_;
}

void HaskellParser::Var_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVar_(this);
}

void HaskellParser::Var_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVar_(this);
}

HaskellParser::Var_Context* HaskellParser::var_() {
  Var_Context *_localctx = _tracker.createInstance<Var_Context>(_ctx, getState());
  enterRule(_localctx, 458, HaskellParser::RuleVar_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2826);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::AS:
      case HaskellParser::HIDING:
      case HaskellParser::QUALIFIED:
      case HaskellParser::EXPORT:
      case HaskellParser::STDCALL:
      case HaskellParser::CCALL:
      case HaskellParser::CAPI:
      case HaskellParser::JSCALL:
      case HaskellParser::STOCK:
      case HaskellParser::ANYCLASS:
      case HaskellParser::VIA:
      case HaskellParser::VARID: {
        enterOuterAlt(_localctx, 1);
        setState(2821);
        varid();
        break;
      }

      case HaskellParser::OpenRoundBracket: {
        enterOuterAlt(_localctx, 2);
        setState(2822);
        match(HaskellParser::OpenRoundBracket);
        setState(2823);
        varsym();
        setState(2824);
        match(HaskellParser::CloseRoundBracket);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QvarContext ------------------------------------------------------------------

HaskellParser::QvarContext::QvarContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::QvaridContext* HaskellParser::QvarContext::qvarid() {
  return getRuleContext<HaskellParser::QvaridContext>(0);
}

tree::TerminalNode* HaskellParser::QvarContext::OpenRoundBracket() {
  return getToken(HaskellParser::OpenRoundBracket, 0);
}

HaskellParser::QvarsymContext* HaskellParser::QvarContext::qvarsym() {
  return getRuleContext<HaskellParser::QvarsymContext>(0);
}

tree::TerminalNode* HaskellParser::QvarContext::CloseRoundBracket() {
  return getToken(HaskellParser::CloseRoundBracket, 0);
}


size_t HaskellParser::QvarContext::getRuleIndex() const {
  return HaskellParser::RuleQvar;
}

void HaskellParser::QvarContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQvar(this);
}

void HaskellParser::QvarContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQvar(this);
}

HaskellParser::QvarContext* HaskellParser::qvar() {
  QvarContext *_localctx = _tracker.createInstance<QvarContext>(_ctx, getState());
  enterRule(_localctx, 460, HaskellParser::RuleQvar);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2833);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::AS:
      case HaskellParser::HIDING:
      case HaskellParser::QUALIFIED:
      case HaskellParser::EXPORT:
      case HaskellParser::STDCALL:
      case HaskellParser::CCALL:
      case HaskellParser::CAPI:
      case HaskellParser::JSCALL:
      case HaskellParser::STOCK:
      case HaskellParser::ANYCLASS:
      case HaskellParser::VIA:
      case HaskellParser::VARID:
      case HaskellParser::CONID: {
        enterOuterAlt(_localctx, 1);
        setState(2828);
        qvarid();
        break;
      }

      case HaskellParser::OpenRoundBracket: {
        enterOuterAlt(_localctx, 2);
        setState(2829);
        match(HaskellParser::OpenRoundBracket);
        setState(2830);
        qvarsym();
        setState(2831);
        match(HaskellParser::CloseRoundBracket);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QvaridContext ------------------------------------------------------------------

HaskellParser::QvaridContext::QvaridContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::VaridContext* HaskellParser::QvaridContext::varid() {
  return getRuleContext<HaskellParser::VaridContext>(0);
}

HaskellParser::ModidContext* HaskellParser::QvaridContext::modid() {
  return getRuleContext<HaskellParser::ModidContext>(0);
}

tree::TerminalNode* HaskellParser::QvaridContext::Dot() {
  return getToken(HaskellParser::Dot, 0);
}


size_t HaskellParser::QvaridContext::getRuleIndex() const {
  return HaskellParser::RuleQvarid;
}

void HaskellParser::QvaridContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQvarid(this);
}

void HaskellParser::QvaridContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQvarid(this);
}

HaskellParser::QvaridContext* HaskellParser::qvarid() {
  QvaridContext *_localctx = _tracker.createInstance<QvaridContext>(_ctx, getState());
  enterRule(_localctx, 462, HaskellParser::RuleQvarid);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2838);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::CONID) {
      setState(2835);
      modid();
      setState(2836);
      match(HaskellParser::Dot);
    }
    setState(2840);
    varid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VaridContext ------------------------------------------------------------------

HaskellParser::VaridContext::VaridContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::VaridContext::VARID() {
  return getToken(HaskellParser::VARID, 0);
}

HaskellParser::Special_idContext* HaskellParser::VaridContext::special_id() {
  return getRuleContext<HaskellParser::Special_idContext>(0);
}

std::vector<tree::TerminalNode *> HaskellParser::VaridContext::Hash() {
  return getTokens(HaskellParser::Hash);
}

tree::TerminalNode* HaskellParser::VaridContext::Hash(size_t i) {
  return getToken(HaskellParser::Hash, i);
}


size_t HaskellParser::VaridContext::getRuleIndex() const {
  return HaskellParser::RuleVarid;
}

void HaskellParser::VaridContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarid(this);
}

void HaskellParser::VaridContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarid(this);
}

HaskellParser::VaridContext* HaskellParser::varid() {
  VaridContext *_localctx = _tracker.createInstance<VaridContext>(_ctx, getState());
  enterRule(_localctx, 464, HaskellParser::RuleVarid);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2844);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::VARID: {
        setState(2842);
        match(HaskellParser::VARID);
        break;
      }

      case HaskellParser::AS:
      case HaskellParser::HIDING:
      case HaskellParser::QUALIFIED:
      case HaskellParser::EXPORT:
      case HaskellParser::STDCALL:
      case HaskellParser::CCALL:
      case HaskellParser::CAPI:
      case HaskellParser::JSCALL:
      case HaskellParser::STOCK:
      case HaskellParser::ANYCLASS:
      case HaskellParser::VIA: {
        setState(2843);
        special_id();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2849);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 330, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2846);
        match(HaskellParser::Hash); 
      }
      setState(2851);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 330, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QvarsymContext ------------------------------------------------------------------

HaskellParser::QvarsymContext::QvarsymContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::VarsymContext* HaskellParser::QvarsymContext::varsym() {
  return getRuleContext<HaskellParser::VarsymContext>(0);
}

HaskellParser::ModidContext* HaskellParser::QvarsymContext::modid() {
  return getRuleContext<HaskellParser::ModidContext>(0);
}

tree::TerminalNode* HaskellParser::QvarsymContext::Dot() {
  return getToken(HaskellParser::Dot, 0);
}


size_t HaskellParser::QvarsymContext::getRuleIndex() const {
  return HaskellParser::RuleQvarsym;
}

void HaskellParser::QvarsymContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQvarsym(this);
}

void HaskellParser::QvarsymContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQvarsym(this);
}

HaskellParser::QvarsymContext* HaskellParser::qvarsym() {
  QvarsymContext *_localctx = _tracker.createInstance<QvarsymContext>(_ctx, getState());
  enterRule(_localctx, 466, HaskellParser::RuleQvarsym);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2855);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::CONID) {
      setState(2852);
      modid();
      setState(2853);
      match(HaskellParser::Dot);
    }
    setState(2857);
    varsym();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Qvarsym_no_minusContext ------------------------------------------------------------------

HaskellParser::Qvarsym_no_minusContext::Qvarsym_no_minusContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Varsym_no_minusContext* HaskellParser::Qvarsym_no_minusContext::varsym_no_minus() {
  return getRuleContext<HaskellParser::Varsym_no_minusContext>(0);
}

HaskellParser::QvarsymContext* HaskellParser::Qvarsym_no_minusContext::qvarsym() {
  return getRuleContext<HaskellParser::QvarsymContext>(0);
}


size_t HaskellParser::Qvarsym_no_minusContext::getRuleIndex() const {
  return HaskellParser::RuleQvarsym_no_minus;
}

void HaskellParser::Qvarsym_no_minusContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQvarsym_no_minus(this);
}

void HaskellParser::Qvarsym_no_minusContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQvarsym_no_minus(this);
}

HaskellParser::Qvarsym_no_minusContext* HaskellParser::qvarsym_no_minus() {
  Qvarsym_no_minusContext *_localctx = _tracker.createInstance<Qvarsym_no_minusContext>(_ctx, getState());
  enterRule(_localctx, 468, HaskellParser::RuleQvarsym_no_minus);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2861);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 332, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2859);
      varsym_no_minus();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2860);
      qvarsym();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarsymContext ------------------------------------------------------------------

HaskellParser::VarsymContext::VarsymContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::Varsym_no_minusContext* HaskellParser::VarsymContext::varsym_no_minus() {
  return getRuleContext<HaskellParser::Varsym_no_minusContext>(0);
}

tree::TerminalNode* HaskellParser::VarsymContext::Minus() {
  return getToken(HaskellParser::Minus, 0);
}


size_t HaskellParser::VarsymContext::getRuleIndex() const {
  return HaskellParser::RuleVarsym;
}

void HaskellParser::VarsymContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarsym(this);
}

void HaskellParser::VarsymContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarsym(this);
}

HaskellParser::VarsymContext* HaskellParser::varsym() {
  VarsymContext *_localctx = _tracker.createInstance<VarsymContext>(_ctx, getState());
  enterRule(_localctx, 470, HaskellParser::RuleVarsym);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2865);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::Hash:
      case HaskellParser::Less:
      case HaskellParser::Greater:
      case HaskellParser::Ampersand:
      case HaskellParser::Pipe:
      case HaskellParser::Bang:
      case HaskellParser::Caret:
      case HaskellParser::Plus:
      case HaskellParser::Asterisk:
      case HaskellParser::Percent:
      case HaskellParser::Divide:
      case HaskellParser::Tilde:
      case HaskellParser::Atsign:
      case HaskellParser::Dollar:
      case HaskellParser::Dot:
      case HaskellParser::QuestionMark:
      case HaskellParser::Colon:
      case HaskellParser::Eq:
      case HaskellParser::ReverseSlash: {
        enterOuterAlt(_localctx, 1);
        setState(2863);
        varsym_no_minus();
        break;
      }

      case HaskellParser::Minus: {
        enterOuterAlt(_localctx, 2);
        setState(2864);
        match(HaskellParser::Minus);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Varsym_no_minusContext ------------------------------------------------------------------

HaskellParser::Varsym_no_minusContext::Varsym_no_minusContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::AscSymbolContext *> HaskellParser::Varsym_no_minusContext::ascSymbol() {
  return getRuleContexts<HaskellParser::AscSymbolContext>();
}

HaskellParser::AscSymbolContext* HaskellParser::Varsym_no_minusContext::ascSymbol(size_t i) {
  return getRuleContext<HaskellParser::AscSymbolContext>(i);
}


size_t HaskellParser::Varsym_no_minusContext::getRuleIndex() const {
  return HaskellParser::RuleVarsym_no_minus;
}

void HaskellParser::Varsym_no_minusContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarsym_no_minus(this);
}

void HaskellParser::Varsym_no_minusContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarsym_no_minus(this);
}

HaskellParser::Varsym_no_minusContext* HaskellParser::varsym_no_minus() {
  Varsym_no_minusContext *_localctx = _tracker.createInstance<Varsym_no_minusContext>(_ctx, getState());
  enterRule(_localctx, 472, HaskellParser::RuleVarsym_no_minus);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2868); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(2867);
              ascSymbol();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(2870); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 334, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Special_idContext ------------------------------------------------------------------

HaskellParser::Special_idContext::Special_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Special_idContext::AS() {
  return getToken(HaskellParser::AS, 0);
}

tree::TerminalNode* HaskellParser::Special_idContext::QUALIFIED() {
  return getToken(HaskellParser::QUALIFIED, 0);
}

tree::TerminalNode* HaskellParser::Special_idContext::HIDING() {
  return getToken(HaskellParser::HIDING, 0);
}

tree::TerminalNode* HaskellParser::Special_idContext::EXPORT() {
  return getToken(HaskellParser::EXPORT, 0);
}

tree::TerminalNode* HaskellParser::Special_idContext::STDCALL() {
  return getToken(HaskellParser::STDCALL, 0);
}

tree::TerminalNode* HaskellParser::Special_idContext::CCALL() {
  return getToken(HaskellParser::CCALL, 0);
}

tree::TerminalNode* HaskellParser::Special_idContext::CAPI() {
  return getToken(HaskellParser::CAPI, 0);
}

tree::TerminalNode* HaskellParser::Special_idContext::JSCALL() {
  return getToken(HaskellParser::JSCALL, 0);
}

tree::TerminalNode* HaskellParser::Special_idContext::STOCK() {
  return getToken(HaskellParser::STOCK, 0);
}

tree::TerminalNode* HaskellParser::Special_idContext::ANYCLASS() {
  return getToken(HaskellParser::ANYCLASS, 0);
}

tree::TerminalNode* HaskellParser::Special_idContext::VIA() {
  return getToken(HaskellParser::VIA, 0);
}


size_t HaskellParser::Special_idContext::getRuleIndex() const {
  return HaskellParser::RuleSpecial_id;
}

void HaskellParser::Special_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpecial_id(this);
}

void HaskellParser::Special_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpecial_id(this);
}

HaskellParser::Special_idContext* HaskellParser::special_id() {
  Special_idContext *_localctx = _tracker.createInstance<Special_idContext>(_ctx, getState());
  enterRule(_localctx, 474, HaskellParser::RuleSpecial_id);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2872);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1976649193099280) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QconidContext ------------------------------------------------------------------

HaskellParser::QconidContext::QconidContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::ConidContext* HaskellParser::QconidContext::conid() {
  return getRuleContext<HaskellParser::ConidContext>(0);
}

HaskellParser::ModidContext* HaskellParser::QconidContext::modid() {
  return getRuleContext<HaskellParser::ModidContext>(0);
}

tree::TerminalNode* HaskellParser::QconidContext::Dot() {
  return getToken(HaskellParser::Dot, 0);
}


size_t HaskellParser::QconidContext::getRuleIndex() const {
  return HaskellParser::RuleQconid;
}

void HaskellParser::QconidContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQconid(this);
}

void HaskellParser::QconidContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQconid(this);
}

HaskellParser::QconidContext* HaskellParser::qconid() {
  QconidContext *_localctx = _tracker.createInstance<QconidContext>(_ctx, getState());
  enterRule(_localctx, 476, HaskellParser::RuleQconid);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2877);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 335, _ctx)) {
    case 1: {
      setState(2874);
      modid();
      setState(2875);
      match(HaskellParser::Dot);
      break;
    }

    default:
      break;
    }
    setState(2879);
    conid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConidContext ------------------------------------------------------------------

HaskellParser::ConidContext::ConidContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::ConidContext::CONID() {
  return getToken(HaskellParser::CONID, 0);
}

std::vector<tree::TerminalNode *> HaskellParser::ConidContext::Hash() {
  return getTokens(HaskellParser::Hash);
}

tree::TerminalNode* HaskellParser::ConidContext::Hash(size_t i) {
  return getToken(HaskellParser::Hash, i);
}


size_t HaskellParser::ConidContext::getRuleIndex() const {
  return HaskellParser::RuleConid;
}

void HaskellParser::ConidContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConid(this);
}

void HaskellParser::ConidContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConid(this);
}

HaskellParser::ConidContext* HaskellParser::conid() {
  ConidContext *_localctx = _tracker.createInstance<ConidContext>(_ctx, getState());
  enterRule(_localctx, 478, HaskellParser::RuleConid);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2881);
    match(HaskellParser::CONID);
    setState(2885);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 336, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2882);
        match(HaskellParser::Hash); 
      }
      setState(2887);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 336, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QconsymContext ------------------------------------------------------------------

HaskellParser::QconsymContext::QconsymContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::ConsymContext* HaskellParser::QconsymContext::consym() {
  return getRuleContext<HaskellParser::ConsymContext>(0);
}

HaskellParser::ModidContext* HaskellParser::QconsymContext::modid() {
  return getRuleContext<HaskellParser::ModidContext>(0);
}

tree::TerminalNode* HaskellParser::QconsymContext::Dot() {
  return getToken(HaskellParser::Dot, 0);
}


size_t HaskellParser::QconsymContext::getRuleIndex() const {
  return HaskellParser::RuleQconsym;
}

void HaskellParser::QconsymContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQconsym(this);
}

void HaskellParser::QconsymContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQconsym(this);
}

HaskellParser::QconsymContext* HaskellParser::qconsym() {
  QconsymContext *_localctx = _tracker.createInstance<QconsymContext>(_ctx, getState());
  enterRule(_localctx, 480, HaskellParser::RuleQconsym);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2891);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HaskellParser::CONID) {
      setState(2888);
      modid();
      setState(2889);
      match(HaskellParser::Dot);
    }
    setState(2893);
    consym();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConsymContext ------------------------------------------------------------------

HaskellParser::ConsymContext::ConsymContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::ConsymContext::Colon() {
  return getToken(HaskellParser::Colon, 0);
}

std::vector<HaskellParser::AscSymbolContext *> HaskellParser::ConsymContext::ascSymbol() {
  return getRuleContexts<HaskellParser::AscSymbolContext>();
}

HaskellParser::AscSymbolContext* HaskellParser::ConsymContext::ascSymbol(size_t i) {
  return getRuleContext<HaskellParser::AscSymbolContext>(i);
}


size_t HaskellParser::ConsymContext::getRuleIndex() const {
  return HaskellParser::RuleConsym;
}

void HaskellParser::ConsymContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConsym(this);
}

void HaskellParser::ConsymContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConsym(this);
}

HaskellParser::ConsymContext* HaskellParser::consym() {
  ConsymContext *_localctx = _tracker.createInstance<ConsymContext>(_ctx, getState());
  enterRule(_localctx, 482, HaskellParser::RuleConsym);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2895);
    match(HaskellParser::Colon);
    setState(2899);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 338, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2896);
        ascSymbol(); 
      }
      setState(2901);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 338, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

HaskellParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::IntegerContext* HaskellParser::LiteralContext::integer() {
  return getRuleContext<HaskellParser::IntegerContext>(0);
}

HaskellParser::PfloatContext* HaskellParser::LiteralContext::pfloat() {
  return getRuleContext<HaskellParser::PfloatContext>(0);
}

HaskellParser::PcharContext* HaskellParser::LiteralContext::pchar() {
  return getRuleContext<HaskellParser::PcharContext>(0);
}

HaskellParser::PstringContext* HaskellParser::LiteralContext::pstring() {
  return getRuleContext<HaskellParser::PstringContext>(0);
}


size_t HaskellParser::LiteralContext::getRuleIndex() const {
  return HaskellParser::RuleLiteral;
}

void HaskellParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void HaskellParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}

HaskellParser::LiteralContext* HaskellParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 484, HaskellParser::RuleLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2906);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HaskellParser::DECIMAL:
      case HaskellParser::OCTAL:
      case HaskellParser::HEXADECIMAL: {
        enterOuterAlt(_localctx, 1);
        setState(2902);
        integer();
        break;
      }

      case HaskellParser::FLOAT: {
        enterOuterAlt(_localctx, 2);
        setState(2903);
        pfloat();
        break;
      }

      case HaskellParser::CHAR: {
        enterOuterAlt(_localctx, 3);
        setState(2904);
        pchar();
        break;
      }

      case HaskellParser::STRING: {
        enterOuterAlt(_localctx, 4);
        setState(2905);
        pstring();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Open_Context ------------------------------------------------------------------

HaskellParser::Open_Context::Open_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::Open_Context::VOCURLY() {
  return getToken(HaskellParser::VOCURLY, 0);
}

tree::TerminalNode* HaskellParser::Open_Context::OCURLY() {
  return getToken(HaskellParser::OCURLY, 0);
}


size_t HaskellParser::Open_Context::getRuleIndex() const {
  return HaskellParser::RuleOpen_;
}

void HaskellParser::Open_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpen_(this);
}

void HaskellParser::Open_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpen_(this);
}

HaskellParser::Open_Context* HaskellParser::open_() {
  Open_Context *_localctx = _tracker.createInstance<Open_Context>(_ctx, getState());
  enterRule(_localctx, 486, HaskellParser::RuleOpen_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2908);
    _la = _input->LA(1);
    if (!(_la == HaskellParser::OCURLY

    || _la == HaskellParser::VOCURLY)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CloseContext ------------------------------------------------------------------

HaskellParser::CloseContext::CloseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::CloseContext::VCCURLY() {
  return getToken(HaskellParser::VCCURLY, 0);
}

tree::TerminalNode* HaskellParser::CloseContext::CCURLY() {
  return getToken(HaskellParser::CCURLY, 0);
}


size_t HaskellParser::CloseContext::getRuleIndex() const {
  return HaskellParser::RuleClose;
}

void HaskellParser::CloseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClose(this);
}

void HaskellParser::CloseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClose(this);
}

HaskellParser::CloseContext* HaskellParser::close() {
  CloseContext *_localctx = _tracker.createInstance<CloseContext>(_ctx, getState());
  enterRule(_localctx, 488, HaskellParser::RuleClose);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2910);
    _la = _input->LA(1);
    if (!(_la == HaskellParser::CCURLY

    || _la == HaskellParser::VCCURLY)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SemiContext ------------------------------------------------------------------

HaskellParser::SemiContext::SemiContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::SemiContext::Semi() {
  return getToken(HaskellParser::Semi, 0);
}

tree::TerminalNode* HaskellParser::SemiContext::SEMI() {
  return getToken(HaskellParser::SEMI, 0);
}


size_t HaskellParser::SemiContext::getRuleIndex() const {
  return HaskellParser::RuleSemi;
}

void HaskellParser::SemiContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSemi(this);
}

void HaskellParser::SemiContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSemi(this);
}

HaskellParser::SemiContext* HaskellParser::semi() {
  SemiContext *_localctx = _tracker.createInstance<SemiContext>(_ctx, getState());
  enterRule(_localctx, 490, HaskellParser::RuleSemi);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2912);
    _la = _input->LA(1);
    if (!(_la == HaskellParser::Semi

    || _la == HaskellParser::SEMI)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModidContext ------------------------------------------------------------------

HaskellParser::ModidContext::ModidContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HaskellParser::ConidContext *> HaskellParser::ModidContext::conid() {
  return getRuleContexts<HaskellParser::ConidContext>();
}

HaskellParser::ConidContext* HaskellParser::ModidContext::conid(size_t i) {
  return getRuleContext<HaskellParser::ConidContext>(i);
}

std::vector<tree::TerminalNode *> HaskellParser::ModidContext::Dot() {
  return getTokens(HaskellParser::Dot);
}

tree::TerminalNode* HaskellParser::ModidContext::Dot(size_t i) {
  return getToken(HaskellParser::Dot, i);
}


size_t HaskellParser::ModidContext::getRuleIndex() const {
  return HaskellParser::RuleModid;
}

void HaskellParser::ModidContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModid(this);
}

void HaskellParser::ModidContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModid(this);
}

HaskellParser::ModidContext* HaskellParser::modid() {
  ModidContext *_localctx = _tracker.createInstance<ModidContext>(_ctx, getState());
  enterRule(_localctx, 492, HaskellParser::RuleModid);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2919);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 340, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2914);
        conid();
        setState(2915);
        match(HaskellParser::Dot); 
      }
      setState(2921);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 340, _ctx);
    }
    setState(2922);
    conid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommasContext ------------------------------------------------------------------

HaskellParser::CommasContext::CommasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> HaskellParser::CommasContext::Comma() {
  return getTokens(HaskellParser::Comma);
}

tree::TerminalNode* HaskellParser::CommasContext::Comma(size_t i) {
  return getToken(HaskellParser::Comma, i);
}


size_t HaskellParser::CommasContext::getRuleIndex() const {
  return HaskellParser::RuleCommas;
}

void HaskellParser::CommasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommas(this);
}

void HaskellParser::CommasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommas(this);
}

HaskellParser::CommasContext* HaskellParser::commas() {
  CommasContext *_localctx = _tracker.createInstance<CommasContext>(_ctx, getState());
  enterRule(_localctx, 494, HaskellParser::RuleCommas);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2925); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2924);
      match(HaskellParser::Comma);
      setState(2927); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == HaskellParser::Comma);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BarsContext ------------------------------------------------------------------

HaskellParser::BarsContext::BarsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> HaskellParser::BarsContext::Pipe() {
  return getTokens(HaskellParser::Pipe);
}

tree::TerminalNode* HaskellParser::BarsContext::Pipe(size_t i) {
  return getToken(HaskellParser::Pipe, i);
}


size_t HaskellParser::BarsContext::getRuleIndex() const {
  return HaskellParser::RuleBars;
}

void HaskellParser::BarsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBars(this);
}

void HaskellParser::BarsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBars(this);
}

HaskellParser::BarsContext* HaskellParser::bars() {
  BarsContext *_localctx = _tracker.createInstance<BarsContext>(_ctx, getState());
  enterRule(_localctx, 496, HaskellParser::RuleBars);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2930); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(2929);
              match(HaskellParser::Pipe);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(2932); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 342, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SpecialContext ------------------------------------------------------------------

HaskellParser::SpecialContext::SpecialContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::SpecialContext::OpenRoundBracket() {
  return getToken(HaskellParser::OpenRoundBracket, 0);
}

tree::TerminalNode* HaskellParser::SpecialContext::CloseRoundBracket() {
  return getToken(HaskellParser::CloseRoundBracket, 0);
}

tree::TerminalNode* HaskellParser::SpecialContext::Comma() {
  return getToken(HaskellParser::Comma, 0);
}

tree::TerminalNode* HaskellParser::SpecialContext::Semi() {
  return getToken(HaskellParser::Semi, 0);
}

tree::TerminalNode* HaskellParser::SpecialContext::OpenSquareBracket() {
  return getToken(HaskellParser::OpenSquareBracket, 0);
}

tree::TerminalNode* HaskellParser::SpecialContext::CloseSquareBracket() {
  return getToken(HaskellParser::CloseSquareBracket, 0);
}

tree::TerminalNode* HaskellParser::SpecialContext::BackQuote() {
  return getToken(HaskellParser::BackQuote, 0);
}

tree::TerminalNode* HaskellParser::SpecialContext::OCURLY() {
  return getToken(HaskellParser::OCURLY, 0);
}

tree::TerminalNode* HaskellParser::SpecialContext::CCURLY() {
  return getToken(HaskellParser::CCURLY, 0);
}


size_t HaskellParser::SpecialContext::getRuleIndex() const {
  return HaskellParser::RuleSpecial;
}

void HaskellParser::SpecialContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpecial(this);
}

void HaskellParser::SpecialContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpecial(this);
}

HaskellParser::SpecialContext* HaskellParser::special() {
  SpecialContext *_localctx = _tracker.createInstance<SpecialContext>(_ctx, getState());
  enterRule(_localctx, 498, HaskellParser::RuleSpecial);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2934);
    _la = _input->LA(1);
    if (!(((((_la - 100) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 100)) & 12900630789) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SymbolContext ------------------------------------------------------------------

HaskellParser::SymbolContext::SymbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HaskellParser::AscSymbolContext* HaskellParser::SymbolContext::ascSymbol() {
  return getRuleContext<HaskellParser::AscSymbolContext>(0);
}


size_t HaskellParser::SymbolContext::getRuleIndex() const {
  return HaskellParser::RuleSymbol;
}

void HaskellParser::SymbolContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSymbol(this);
}

void HaskellParser::SymbolContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSymbol(this);
}

HaskellParser::SymbolContext* HaskellParser::symbol() {
  SymbolContext *_localctx = _tracker.createInstance<SymbolContext>(_ctx, getState());
  enterRule(_localctx, 500, HaskellParser::RuleSymbol);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2936);
    ascSymbol();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AscSymbolContext ------------------------------------------------------------------

HaskellParser::AscSymbolContext::AscSymbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::AscSymbolContext::Bang() {
  return getToken(HaskellParser::Bang, 0);
}

tree::TerminalNode* HaskellParser::AscSymbolContext::Hash() {
  return getToken(HaskellParser::Hash, 0);
}

tree::TerminalNode* HaskellParser::AscSymbolContext::Dollar() {
  return getToken(HaskellParser::Dollar, 0);
}

tree::TerminalNode* HaskellParser::AscSymbolContext::Percent() {
  return getToken(HaskellParser::Percent, 0);
}

tree::TerminalNode* HaskellParser::AscSymbolContext::Ampersand() {
  return getToken(HaskellParser::Ampersand, 0);
}

tree::TerminalNode* HaskellParser::AscSymbolContext::Asterisk() {
  return getToken(HaskellParser::Asterisk, 0);
}

tree::TerminalNode* HaskellParser::AscSymbolContext::Plus() {
  return getToken(HaskellParser::Plus, 0);
}

tree::TerminalNode* HaskellParser::AscSymbolContext::Dot() {
  return getToken(HaskellParser::Dot, 0);
}

tree::TerminalNode* HaskellParser::AscSymbolContext::Divide() {
  return getToken(HaskellParser::Divide, 0);
}

tree::TerminalNode* HaskellParser::AscSymbolContext::Less() {
  return getToken(HaskellParser::Less, 0);
}

tree::TerminalNode* HaskellParser::AscSymbolContext::Eq() {
  return getToken(HaskellParser::Eq, 0);
}

tree::TerminalNode* HaskellParser::AscSymbolContext::Greater() {
  return getToken(HaskellParser::Greater, 0);
}

tree::TerminalNode* HaskellParser::AscSymbolContext::QuestionMark() {
  return getToken(HaskellParser::QuestionMark, 0);
}

tree::TerminalNode* HaskellParser::AscSymbolContext::Atsign() {
  return getToken(HaskellParser::Atsign, 0);
}

tree::TerminalNode* HaskellParser::AscSymbolContext::ReverseSlash() {
  return getToken(HaskellParser::ReverseSlash, 0);
}

tree::TerminalNode* HaskellParser::AscSymbolContext::Caret() {
  return getToken(HaskellParser::Caret, 0);
}

tree::TerminalNode* HaskellParser::AscSymbolContext::Pipe() {
  return getToken(HaskellParser::Pipe, 0);
}

tree::TerminalNode* HaskellParser::AscSymbolContext::Tilde() {
  return getToken(HaskellParser::Tilde, 0);
}

tree::TerminalNode* HaskellParser::AscSymbolContext::Colon() {
  return getToken(HaskellParser::Colon, 0);
}


size_t HaskellParser::AscSymbolContext::getRuleIndex() const {
  return HaskellParser::RuleAscSymbol;
}

void HaskellParser::AscSymbolContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAscSymbol(this);
}

void HaskellParser::AscSymbolContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAscSymbol(this);
}

HaskellParser::AscSymbolContext* HaskellParser::ascSymbol() {
  AscSymbolContext *_localctx = _tracker.createInstance<AscSymbolContext>(_ctx, getState());
  enterRule(_localctx, 502, HaskellParser::RuleAscSymbol);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2938);
    _la = _input->LA(1);
    if (!(((((_la - 82) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 82)) & 40550143) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntegerContext ------------------------------------------------------------------

HaskellParser::IntegerContext::IntegerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::IntegerContext::DECIMAL() {
  return getToken(HaskellParser::DECIMAL, 0);
}

tree::TerminalNode* HaskellParser::IntegerContext::OCTAL() {
  return getToken(HaskellParser::OCTAL, 0);
}

tree::TerminalNode* HaskellParser::IntegerContext::HEXADECIMAL() {
  return getToken(HaskellParser::HEXADECIMAL, 0);
}


size_t HaskellParser::IntegerContext::getRuleIndex() const {
  return HaskellParser::RuleInteger;
}

void HaskellParser::IntegerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInteger(this);
}

void HaskellParser::IntegerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInteger(this);
}

HaskellParser::IntegerContext* HaskellParser::integer() {
  IntegerContext *_localctx = _tracker.createInstance<IntegerContext>(_ctx, getState());
  enterRule(_localctx, 504, HaskellParser::RuleInteger);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2940);
    _la = _input->LA(1);
    if (!(((((_la - 137) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 137)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PfloatContext ------------------------------------------------------------------

HaskellParser::PfloatContext::PfloatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::PfloatContext::FLOAT() {
  return getToken(HaskellParser::FLOAT, 0);
}


size_t HaskellParser::PfloatContext::getRuleIndex() const {
  return HaskellParser::RulePfloat;
}

void HaskellParser::PfloatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPfloat(this);
}

void HaskellParser::PfloatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPfloat(this);
}

HaskellParser::PfloatContext* HaskellParser::pfloat() {
  PfloatContext *_localctx = _tracker.createInstance<PfloatContext>(_ctx, getState());
  enterRule(_localctx, 506, HaskellParser::RulePfloat);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2942);
    match(HaskellParser::FLOAT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PcharContext ------------------------------------------------------------------

HaskellParser::PcharContext::PcharContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::PcharContext::CHAR() {
  return getToken(HaskellParser::CHAR, 0);
}


size_t HaskellParser::PcharContext::getRuleIndex() const {
  return HaskellParser::RulePchar;
}

void HaskellParser::PcharContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPchar(this);
}

void HaskellParser::PcharContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPchar(this);
}

HaskellParser::PcharContext* HaskellParser::pchar() {
  PcharContext *_localctx = _tracker.createInstance<PcharContext>(_ctx, getState());
  enterRule(_localctx, 508, HaskellParser::RulePchar);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2944);
    match(HaskellParser::CHAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PstringContext ------------------------------------------------------------------

HaskellParser::PstringContext::PstringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HaskellParser::PstringContext::STRING() {
  return getToken(HaskellParser::STRING, 0);
}


size_t HaskellParser::PstringContext::getRuleIndex() const {
  return HaskellParser::RulePstring;
}

void HaskellParser::PstringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPstring(this);
}

void HaskellParser::PstringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HaskellParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPstring(this);
}

HaskellParser::PstringContext* HaskellParser::pstring() {
  PstringContext *_localctx = _tracker.createInstance<PstringContext>(_ctx, getState());
  enterRule(_localctx, 510, HaskellParser::RulePstring);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2946);
    match(HaskellParser::STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

void HaskellParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  haskellparserParserInitialize();
#else
  ::antlr4::internal::call_once(haskellparserParserOnceFlag, haskellparserParserInitialize);
#endif
}

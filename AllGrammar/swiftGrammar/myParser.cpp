
// Generated from myParser.g4 by ANTLR 4.13.0


#include "myParserListener.h"

#include "myParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct MyParserStaticData final {
  MyParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  MyParserStaticData(const MyParserStaticData&) = delete;
  MyParserStaticData(MyParserStaticData&&) = delete;
  MyParserStaticData& operator=(const MyParserStaticData&) = delete;
  MyParserStaticData& operator=(MyParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag myparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
MyParserStaticData *myparserParserStaticData = nullptr;

void myparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (myparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(myparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<MyParserStaticData>(
    std::vector<std::string>{
      "top_level", "statement", "statements", "loop_statement", "for_in_statement", 
      "while_statement", "condition_list", "condition", "case_condition", 
      "optional_binding_condition", "repeat_while_statement", "branch_statement", 
      "if_statement", "else_clause", "guard_statement", "switch_statement", 
      "switch_cases", "switch_case", "case_label", "case_item_list", "default_label", 
      "where_clause", "where_expression", "conditional_switch_case", "switch_if_directive_clause", 
      "switch_elseif_directive_clauses", "switch_elseif_directive_clause", 
      "switch_else_directive_clause", "labeled_statement", "statement_label", 
      "label_name", "control_transfer_statement", "break_statement", "continue_statement", 
      "fallthrough_statement", "return_statement", "throw_statement", "defer_statement", 
      "do_statement", "catch_clauses", "catch_clause", "catch_pattern_list", 
      "catch_pattern", "compiler_control_statement", "conditional_compilation_block", 
      "if_directive_clause", "elseif_directive_clauses", "elseif_directive_clause", 
      "else_directive_clause", "compilation_condition", "platform_condition", 
      "swift_version", "swift_version_continuation", "operating_system", 
      "architecture", "module_name", "environment", "line_control_statement", 
      "line_number", "file_name", "diagnostic_statement", "diagnostic_message", 
      "availability_condition", "availability_arguments", "availability_argument", 
      "platform_name", "platform_version", "generic_parameter_clause", "generic_parameter_list", 
      "generic_parameter", "generic_where_clause", "requirement_list", "requirement", 
      "conformance_requirement", "same_type_requirement", "generic_argument_clause", 
      "generic_argument_list", "generic_argument", "declaration", "declarations", 
      "top_level_declaration", "code_block", "import_declaration", "import_kind", 
      "import_path", "import_path_identifier", "constant_declaration", "pattern_initializer_list", 
      "pattern_initializer", "initializer", "variable_declaration", "variable_declaration_head", 
      "variable_name", "getter_setter_block", "getter_clause", "setter_clause", 
      "setter_name", "getter_setter_keyword_block", "getter_keyword_clause", 
      "setter_keyword_clause", "willSet_didSet_block", "willSet_clause", 
      "didSet_clause", "typealias_declaration", "typealias_name", "typealias_assignment", 
      "function_declaration", "function_head", "function_name", "function_signature", 
      "function_result", "function_body", "parameter_clause", "parameter_list", 
      "parameter", "external_parameter_name", "local_parameter_name", "default_argument_clause", 
      "enum_declaration", "union_style_enum", "union_style_enum_members", 
      "union_style_enum_member", "union_style_enum_case_clause", "union_style_enum_case_list", 
      "union_style_enum_case", "enum_name", "enum_case_name", "raw_value_style_enum", 
      "raw_value_style_enum_members", "raw_value_style_enum_member", "raw_value_style_enum_case_clause", 
      "raw_value_style_enum_case_list", "raw_value_style_enum_case", "raw_value_assignment", 
      "raw_value_literal", "struct_declaration", "struct_name", "struct_body", 
      "struct_members", "struct_member", "class_declaration", "class_name", 
      "class_body", "class_members", "class_member", "protocol_declaration", 
      "protocol_name", "protocol_body", "protocol_members", "protocol_member", 
      "protocol_member_declaration", "protocol_property_declaration", "protocol_method_declaration", 
      "protocol_initializer_declaration", "protocol_subscript_declaration", 
      "protocol_associated_type_declaration", "initializer_declaration", 
      "initializer_head", "initializer_body", "deinitializer_declaration", 
      "extension_declaration", "extension_body", "extension_members", "extension_member", 
      "subscript_declaration", "subscript_head", "subscript_result", "operator_declaration", 
      "prefix_operator_declaration", "postfix_operator_declaration", "infix_operator_declaration", 
      "infix_operator_group", "precedence_group_declaration", "precedence_group_attributes", 
      "precedence_group_attribute", "precedence_group_relation", "precedence_group_assignment", 
      "precedence_group_associativity", "precedence_group_names", "precedence_group_name", 
      "declaration_modifier", "declaration_modifiers", "access_level_modifier", 
      "mutation_modifier", "pattern", "wildcard_pattern", "identifier_pattern", 
      "value_binding_pattern", "tuple_pattern", "tuple_pattern_element_list", 
      "tuple_pattern_element", "enum_case_pattern", "optional_pattern", 
      "expression_pattern", "attribute", "attribute_name", "attribute_argument_clause", 
      "attributes", "balanced_tokens", "balanced_token", "balanced_token_punctuation", 
      "expression", "expression_list", "prefix_expression", "in_out_expression", 
      "try_operator", "binary_expression", "binary_expressions", "conditional_operator", 
      "type_casting_operator", "primary_expression", "unqualified_name", 
      "literal_expression", "array_literal", "array_literal_items", "array_literal_item", 
      "dictionary_literal", "dictionary_literal_items", "dictionary_literal_item", 
      "playground_literal", "self_expression", "superclass_expression", 
      "closure_expression", "closure_signature", "closure_parameter_clause", 
      "closure_parameter_list", "closure_parameter", "capture_list", "capture_list_items", 
      "capture_list_item", "capture_specifier", "implicit_member_expression", 
      "parenthesized_operator", "parenthesized_expression", "tuple_expression", 
      "tuple_element_list", "tuple_element", "wildcard_expression", "key_path_expression", 
      "key_path_components", "key_path_component", "key_path_postfixes", 
      "key_path_postfix", "selector_expression", "key_path_string_expression", 
      "postfix_expression", "function_call_suffix", "initializer_suffix", 
      "explicit_member_suffix", "postfix_self_suffix", "subscript_suffix", 
      "forced_value_suffix", "optional_chaining_suffix", "function_call_argument_clause", 
      "function_call_argument_list", "function_call_argument", "trailing_closures", 
      "labeled_trailing_closures", "labeled_trailing_closure", "argument_names", 
      "argument_name", "type", "type_annotation", "type_identifier", "type_name", 
      "tuple_type", "tuple_type_element_list", "tuple_type_element", "element_name", 
      "function_type", "function_type_argument_clause", "function_type_argument_list", 
      "function_type_argument", "argument_label", "array_type", "dictionary_type", 
      "protocol_composition_type", "trailing_composition_and", "opaque_type", 
      "any_type", "self_type", "type_inheritance_clause", "type_inheritance_list", 
      "identifier", "identifier_list", "keyword", "assignment_operator", 
      "negate_prefix_operator", "compilation_condition_AND", "compilation_condition_OR", 
      "compilation_condition_GE", "compilation_condition_L", "arrow_operator", 
      "range_operator", "same_type_equals", "binary_operator", "prefix_operator", 
      "postfix_operator", "operator", "operator_head", "operator_character", 
      "operator_characters", "dot_operator_head", "dot_operator_character", 
      "dot_operator_characters", "literal", "numeric_literal", "boolean_literal", 
      "nil_literal", "integer_literal", "string_literal", "extended_string_literal", 
      "static_string_literal", "interpolated_string_literal"
    },
    std::vector<std::string>{
      "", "'as'", "'alpha'", "'break'", "'case'", "'catch'", "'class'", 
      "'continue'", "'default'", "'defer'", "'do'", "'guard'", "'else'", 
      "'enum'", "'for'", "'fallthrough'", "'func'", "'in'", "'if'", "'import'", 
      "'internal'", "'final'", "'open'", "'private'", "'public'", "'where'", 
      "'while'", "'let'", "'var'", "'protocol'", "'get'", "'set'", "'willSet'", 
      "'didSet'", "'repeat'", "'switch'", "'struct'", "'return'", "'throw'", 
      "'throws'", "'rethrows'", "'indirect'", "'init'", "'deinit'", "'associatedtype'", 
      "'extension'", "'subscript'", "'prefix'", "'infix'", "'left'", "'right'", 
      "'none'", "'precedencegroup'", "'higherThan'", "'lowerThan'", "'assignment'", 
      "'associativity'", "'postfix'", "'operator'", "'typealias'", "'os'", 
      "'arch'", "'swift'", "'compiler'", "'canImport'", "'targetEnvironment'", 
      "'convenience'", "'dynamic'", "'lazy'", "'optional'", "'override'", 
      "'required'", "'static'", "'weak'", "'unowned'", "'safe'", "'unsafe'", 
      "'mutating'", "'nonmutating'", "'fileprivate'", "'is'", "'try'", "'super'", 
      "'Any'", "'false'", "'red'", "'blue'", "'green'", "'resourceName'", 
      "'true'", "'nil'", "'inout'", "'some'", "'Type'", "'precedence'", 
      "'self'", "'Self'", "'macOS'", "'iOS'", "'OSX'", "'watchOS'", "'tvOS'", 
      "'Linux'", "'Windows'", "'i386'", "'x86_64'", "'arm'", "'arm64'", 
      "'simulator'", "'macCatalyst'", "'iOSApplicationExtension'", "'macCatalystApplicationExtension'", 
      "'macOSApplicationExtension'", "'#sourceLocation'", "'file'", "'line'", 
      "'#error'", "'#warning'", "'#available'", "'#if'", "'#elseif'", "'#else'", 
      "'#endif'", "'#file'", "'#fileID'", "'#filePath'", "'#line'", "'#column'", 
      "'#function'", "'#dsohandle'", "'#selector'", "'#keyPath'", "'#colorLiteral'", 
      "'#fileLiteral'", "'#imageLiteral'", "'getter'", "'setter'", "", "'.'", 
      "'{'", "'('", "'['", "'}'", "')'", "']'", "','", "':'", "';'", "'<'", 
      "'>'", "'_'", "'!'", "'\\u003F'", "'@'", "'&'", "'-'", "'='", "'|'", 
      "'/'", "'+'", "'*'", "'%'", "'^'", "'~'", "'#'", "'`'", "'$'", "'\\'"
    },
    std::vector<std::string>{
      "", "AS", "ALPHA", "BREAK", "CASE", "CATCH", "CLASS", "CONTINUE", 
      "DEFAULT", "DEFER", "DO", "GUARD", "ELSE", "ENUM", "FOR", "FALLTHROUGH", 
      "FUNC", "IN", "IF", "IMPORT", "INTERNAL", "FINAL", "OPEN", "PRIVATE", 
      "PUBLIC", "WHERE", "WHILE", "LET", "VAR", "PROTOCOL", "GET", "SET", 
      "WILL_SET", "DID_SET", "REPEAT", "SWITCH", "STRUCT", "RETURN", "THROW", 
      "THROWS", "RETHROWS", "INDIRECT", "INIT", "DEINIT", "ASSOCIATED_TYPE", 
      "EXTENSION", "SUBSCRIPT", "PREFIX", "INFIX", "LEFT", "RIGHT", "NONE", 
      "PRECEDENCE_GROUP", "HIGHER_THAN", "LOWER_THAN", "ASSIGNMENT", "ASSOCIATIVITY", 
      "POSTFIX", "OPERATOR", "TYPEALIAS", "OS", "ARCH", "SWIFT", "COMPILER", 
      "CAN_IMPORT", "TARGET_ENVIRONMENT", "CONVENIENCE", "DYNAMIC", "LAZY", 
      "OPTIONAL", "OVERRIDE", "REQUIRED", "STATIC", "WEAK", "UNOWNED", "SAFE", 
      "UNSAFE", "MUTATING", "NONMUTATING", "FILE_PRIVATE", "IS", "TRY", 
      "SUPER", "ANY", "FALSE", "RED", "BLUE", "GREEN", "RESOURCE_NAME", 
      "TRUE", "NIL", "INOUT", "SOME", "TYPE", "PRECEDENCE", "SELF", "SELF_BIG", 
      "MAC_OS", "I_OS", "OSX", "WATCH_OS", "TV_OS", "LINUX", "WINDOWS", 
      "I386", "X86_64", "ARM", "ARM64", "SIMULATOR", "MAC_CATALYST", "I_OS_APPLICATION_EXTENSION", 
      "MAC_CATALYST_APPLICATION_EXTENSION", "MAC_OS_APPLICATION_EXTENSION", 
      "SOURCE_LOCATION", "FILE", "LINE", "ERROR", "WARNING", "AVAILABLE", 
      "HASH_IF", "HASH_ELSEIF", "HASH_ELSE", "HASH_ENDIF", "HASH_FILE", 
      "HASH_FILE_ID", "HASH_FILE_PATH", "HASH_LINE", "HASH_COLUMN", "HASH_FUNCTION", 
      "HASH_DSO_HANDLE", "HASH_SELECTOR", "HASH_KEYPATH", "HASH_COLOR_LITERAL", 
      "HASH_FILE_LITERAL", "HASH_IMAGE_LITERAL", "GETTER", "SETTER", "Identifier", 
      "DOT", "LCURLY", "LPAREN", "LBRACK", "RCURLY", "RPAREN", "RBRACK", 
      "COMMA", "COLON", "SEMI", "LT", "GT", "UNDERSCORE", "BANG", "QUESTION", 
      "AT", "AND", "SUB", "EQUAL", "OR", "DIV", "ADD", "MUL", "MOD", "CARET", 
      "TILDE", "HASH", "BACKTICK", "DOLLAR", "BACKSLASH", "Operator_head_other", 
      "Operator_following_character", "Binary_literal", "Octal_literal", 
      "Decimal_digits", "Decimal_literal", "Hexadecimal_literal", "Floating_point_literal", 
      "WS", "HASHBANG", "Block_comment", "Line_comment", "Multi_line_extended_string_open", 
      "Single_line_extended_string_open", "Multi_line_string_open", "Single_line_string_open", 
      "Interpolataion_single_line", "Single_line_string_close", "Quoted_single_line_text", 
      "Interpolataion_multi_line", "Multi_line_string_close", "Quoted_multi_line_text", 
      "Single_line_extended_string_close", "Quoted_single_line_extended_text", 
      "Multi_line_extended_string_close", "Quoted_multi_line_extended_text"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,193,2872,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,
  	7,134,2,135,7,135,2,136,7,136,2,137,7,137,2,138,7,138,2,139,7,139,2,140,
  	7,140,2,141,7,141,2,142,7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,
  	7,146,2,147,7,147,2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,
  	7,152,2,153,7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,
  	7,158,2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
  	7,164,2,165,7,165,2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,2,170,
  	7,170,2,171,7,171,2,172,7,172,2,173,7,173,2,174,7,174,2,175,7,175,2,176,
  	7,176,2,177,7,177,2,178,7,178,2,179,7,179,2,180,7,180,2,181,7,181,2,182,
  	7,182,2,183,7,183,2,184,7,184,2,185,7,185,2,186,7,186,2,187,7,187,2,188,
  	7,188,2,189,7,189,2,190,7,190,2,191,7,191,2,192,7,192,2,193,7,193,2,194,
  	7,194,2,195,7,195,2,196,7,196,2,197,7,197,2,198,7,198,2,199,7,199,2,200,
  	7,200,2,201,7,201,2,202,7,202,2,203,7,203,2,204,7,204,2,205,7,205,2,206,
  	7,206,2,207,7,207,2,208,7,208,2,209,7,209,2,210,7,210,2,211,7,211,2,212,
  	7,212,2,213,7,213,2,214,7,214,2,215,7,215,2,216,7,216,2,217,7,217,2,218,
  	7,218,2,219,7,219,2,220,7,220,2,221,7,221,2,222,7,222,2,223,7,223,2,224,
  	7,224,2,225,7,225,2,226,7,226,2,227,7,227,2,228,7,228,2,229,7,229,2,230,
  	7,230,2,231,7,231,2,232,7,232,2,233,7,233,2,234,7,234,2,235,7,235,2,236,
  	7,236,2,237,7,237,2,238,7,238,2,239,7,239,2,240,7,240,2,241,7,241,2,242,
  	7,242,2,243,7,243,2,244,7,244,2,245,7,245,2,246,7,246,2,247,7,247,2,248,
  	7,248,2,249,7,249,2,250,7,250,2,251,7,251,2,252,7,252,2,253,7,253,2,254,
  	7,254,2,255,7,255,2,256,7,256,2,257,7,257,2,258,7,258,2,259,7,259,2,260,
  	7,260,2,261,7,261,2,262,7,262,2,263,7,263,2,264,7,264,2,265,7,265,2,266,
  	7,266,2,267,7,267,2,268,7,268,2,269,7,269,2,270,7,270,2,271,7,271,2,272,
  	7,272,2,273,7,273,2,274,7,274,2,275,7,275,2,276,7,276,2,277,7,277,2,278,
  	7,278,2,279,7,279,2,280,7,280,2,281,7,281,2,282,7,282,2,283,7,283,2,284,
  	7,284,2,285,7,285,2,286,7,286,2,287,7,287,2,288,7,288,2,289,7,289,2,290,
  	7,290,2,291,7,291,2,292,7,292,2,293,7,293,2,294,7,294,2,295,7,295,2,296,
  	7,296,2,297,7,297,2,298,7,298,2,299,7,299,2,300,7,300,2,301,7,301,2,302,
  	7,302,2,303,7,303,2,304,7,304,2,305,7,305,2,306,7,306,2,307,7,307,2,308,
  	7,308,2,309,7,309,2,310,7,310,2,311,7,311,2,312,7,312,2,313,7,313,1,0,
  	3,0,630,8,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,642,8,1,1,1,3,
  	1,645,8,1,1,1,3,1,648,8,1,1,2,1,2,1,2,1,2,4,2,654,8,2,11,2,12,2,655,1,
  	3,1,3,1,3,3,3,661,8,3,1,4,1,4,3,4,665,8,4,1,4,1,4,1,4,1,4,3,4,671,8,4,
  	1,4,1,4,1,5,1,5,1,5,1,5,1,6,1,6,1,6,5,6,682,8,6,10,6,12,6,685,9,6,1,7,
  	1,7,1,7,1,7,3,7,691,8,7,1,8,1,8,1,8,1,8,1,9,1,9,1,9,1,9,1,10,1,10,1,10,
  	1,10,1,10,1,11,1,11,1,11,3,11,709,8,11,1,12,1,12,1,12,1,12,3,12,715,8,
  	12,1,13,1,13,1,13,1,13,3,13,721,8,13,1,14,1,14,1,14,1,14,1,14,1,15,1,
  	15,1,15,1,15,3,15,732,8,15,1,15,1,15,1,16,1,16,3,16,738,8,16,1,17,1,17,
  	3,17,742,8,17,1,17,1,17,1,17,3,17,747,8,17,1,18,3,18,750,8,18,1,18,1,
  	18,1,18,1,18,1,19,1,19,3,19,758,8,19,1,19,1,19,1,19,3,19,763,8,19,5,19,
  	765,8,19,10,19,12,19,768,9,19,1,20,3,20,771,8,20,1,20,1,20,1,20,1,21,
  	1,21,1,21,1,22,1,22,1,23,1,23,3,23,783,8,23,1,23,3,23,786,8,23,1,23,1,
  	23,1,24,1,24,1,24,3,24,793,8,24,1,25,1,25,3,25,797,8,25,1,26,1,26,1,26,
  	3,26,802,8,26,1,27,1,27,3,27,806,8,27,1,28,1,28,1,28,1,28,1,28,3,28,813,
  	8,28,1,29,1,29,1,29,1,30,1,30,1,31,1,31,1,31,1,31,1,31,3,31,825,8,31,
  	1,32,1,32,3,32,829,8,32,1,33,1,33,3,33,833,8,33,1,34,1,34,1,35,1,35,3,
  	35,839,8,35,1,36,1,36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,3,38,850,8,38,
  	1,39,4,39,853,8,39,11,39,12,39,854,1,40,1,40,3,40,859,8,40,1,40,1,40,
  	1,41,1,41,1,41,1,41,1,41,5,41,868,8,41,10,41,12,41,871,9,41,1,42,1,42,
  	3,42,875,8,42,1,43,1,43,1,43,3,43,880,8,43,1,44,1,44,3,44,884,8,44,1,
  	44,3,44,887,8,44,1,44,1,44,1,45,1,45,1,45,3,45,894,8,45,1,46,4,46,897,
  	8,46,11,46,12,46,898,1,47,1,47,1,47,3,47,904,8,47,1,48,1,48,3,48,908,
  	8,48,1,49,1,49,1,49,1,49,1,49,1,49,1,49,1,49,1,49,1,49,3,49,920,8,49,
  	1,49,1,49,1,49,3,49,925,8,49,1,49,1,49,5,49,929,8,49,10,49,12,49,932,
  	9,49,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,
  	1,50,3,50,948,8,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,
  	1,50,1,50,1,50,3,50,963,8,50,1,51,1,51,3,51,967,8,51,1,52,1,52,1,52,3,
  	52,972,8,52,1,53,1,53,1,54,1,54,1,55,1,55,1,55,5,55,981,8,55,10,55,12,
  	55,984,9,55,1,56,1,56,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,
  	57,3,57,998,8,57,1,57,1,57,1,58,1,58,1,59,1,59,1,60,1,60,1,60,1,60,1,
  	60,1,61,1,61,1,62,1,62,1,62,1,62,1,62,1,63,1,63,1,63,5,63,1021,8,63,10,
  	63,12,63,1024,9,63,1,64,1,64,1,64,1,64,3,64,1030,8,64,1,65,1,65,1,66,
  	1,66,1,66,1,66,1,66,3,66,1039,8,66,3,66,1041,8,66,1,67,1,67,1,67,1,67,
  	1,68,1,68,1,68,5,68,1050,8,68,10,68,12,68,1053,9,68,1,69,1,69,1,69,1,
  	69,3,69,1059,8,69,3,69,1061,8,69,1,70,1,70,1,70,1,71,1,71,1,71,5,71,1069,
  	8,71,10,71,12,71,1072,9,71,1,72,1,72,3,72,1076,8,72,1,73,1,73,1,73,1,
  	73,3,73,1082,8,73,1,74,1,74,1,74,1,74,3,74,1088,8,74,1,75,1,75,1,75,1,
  	75,1,76,1,76,1,76,5,76,1097,8,76,10,76,12,76,1100,9,76,1,77,1,77,1,78,
  	1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,
  	3,78,1119,8,78,1,78,3,78,1122,8,78,1,79,4,79,1125,8,79,11,79,12,79,1126,
  	1,80,3,80,1130,8,80,1,81,1,81,3,81,1134,8,81,1,81,1,81,1,82,3,82,1139,
  	8,82,1,82,1,82,3,82,1143,8,82,1,82,1,82,1,83,1,83,1,84,1,84,1,84,5,84,
  	1152,8,84,10,84,12,84,1155,9,84,1,85,1,85,3,85,1159,8,85,1,86,3,86,1162,
  	8,86,1,86,3,86,1165,8,86,1,86,1,86,1,86,1,87,1,87,1,87,5,87,1173,8,87,
  	10,87,12,87,1176,9,87,1,88,1,88,3,88,1180,8,88,1,89,1,89,1,89,1,90,1,
  	90,1,90,1,90,1,90,1,90,1,90,3,90,1192,8,90,1,90,1,90,1,90,3,90,1197,8,
  	90,3,90,1199,8,90,1,90,3,90,1202,8,90,1,91,3,91,1205,8,91,1,91,3,91,1208,
  	8,91,1,91,1,91,1,92,1,92,1,93,1,93,1,93,3,93,1217,8,93,1,93,1,93,1,93,
  	3,93,1222,8,93,1,93,1,93,1,93,3,93,1227,8,93,1,94,3,94,1230,8,94,1,94,
  	3,94,1233,8,94,1,94,1,94,3,94,1237,8,94,1,95,3,95,1240,8,95,1,95,3,95,
  	1243,8,95,1,95,1,95,3,95,1247,8,95,1,95,3,95,1250,8,95,1,96,1,96,1,96,
  	1,96,1,97,1,97,1,97,3,97,1259,8,97,1,97,1,97,1,97,3,97,1264,8,97,1,97,
  	1,97,1,98,3,98,1269,8,98,1,98,3,98,1272,8,98,1,98,1,98,1,99,3,99,1277,
  	8,99,1,99,3,99,1280,8,99,1,99,1,99,1,100,1,100,1,100,3,100,1287,8,100,
  	1,100,1,100,3,100,1291,8,100,3,100,1293,8,100,1,100,1,100,1,101,3,101,
  	1298,8,101,1,101,1,101,3,101,1302,8,101,1,101,1,101,1,102,3,102,1307,
  	8,102,1,102,1,102,3,102,1311,8,102,1,102,1,102,1,103,3,103,1316,8,103,
  	1,103,3,103,1319,8,103,1,103,1,103,1,103,3,103,1324,8,103,1,103,1,103,
  	1,104,1,104,1,105,1,105,1,105,1,106,1,106,1,106,3,106,1336,8,106,1,106,
  	1,106,3,106,1340,8,106,1,106,3,106,1343,8,106,1,107,3,107,1346,8,107,
  	1,107,3,107,1349,8,107,1,107,1,107,1,108,1,108,3,108,1355,8,108,1,109,
  	1,109,3,109,1359,8,109,1,109,3,109,1362,8,109,1,109,3,109,1365,8,109,
  	1,110,1,110,3,110,1369,8,110,1,110,1,110,1,111,1,111,1,112,1,112,3,112,
  	1377,8,112,1,112,1,112,1,113,1,113,1,113,5,113,1384,8,113,10,113,12,113,
  	1387,9,113,1,114,3,114,1390,8,114,1,114,3,114,1393,8,114,1,114,1,114,
  	1,114,3,114,1398,8,114,1,114,3,114,1401,8,114,1,115,1,115,1,116,1,116,
  	1,117,1,117,1,117,1,118,3,118,1411,8,118,1,118,3,118,1414,8,118,1,118,
  	1,118,3,118,1418,8,118,1,119,3,119,1421,8,119,1,119,1,119,1,119,3,119,
  	1426,8,119,1,119,3,119,1429,8,119,1,119,3,119,1432,8,119,1,119,1,119,
  	3,119,1436,8,119,1,119,1,119,1,120,4,120,1441,8,120,11,120,12,120,1442,
  	1,121,1,121,1,121,3,121,1448,8,121,1,122,3,122,1451,8,122,1,122,3,122,
  	1454,8,122,1,122,1,122,1,122,1,123,1,123,1,123,5,123,1462,8,123,10,123,
  	12,123,1465,9,123,1,124,1,124,1,124,1,124,1,124,1,124,1,124,3,124,1474,
  	8,124,3,124,1476,8,124,1,125,1,125,1,126,1,126,1,127,1,127,1,127,3,127,
  	1485,8,127,1,127,1,127,3,127,1489,8,127,1,127,1,127,1,127,1,127,1,128,
  	4,128,1496,8,128,11,128,12,128,1497,1,129,1,129,1,129,3,129,1503,8,129,
  	1,130,3,130,1506,8,130,1,130,1,130,1,130,1,131,1,131,1,131,5,131,1514,
  	8,131,10,131,12,131,1517,9,131,1,132,1,132,3,132,1521,8,132,1,133,1,133,
  	1,133,1,134,1,134,1,134,3,134,1529,8,134,1,135,3,135,1532,8,135,1,135,
  	3,135,1535,8,135,1,135,1,135,1,135,3,135,1540,8,135,1,135,3,135,1543,
  	8,135,1,135,3,135,1546,8,135,1,135,1,135,1,136,1,136,1,137,1,137,1,137,
  	1,137,1,138,5,138,1557,8,138,10,138,12,138,1560,9,138,1,139,1,139,3,139,
  	1564,8,139,1,140,3,140,1567,8,140,1,140,3,140,1570,8,140,1,140,3,140,
  	1573,8,140,1,140,1,140,3,140,1577,8,140,3,140,1579,8,140,1,140,1,140,
  	1,140,3,140,1584,8,140,1,140,3,140,1587,8,140,1,140,3,140,1590,8,140,
  	1,140,1,140,1,141,1,141,1,142,1,142,1,142,1,142,1,143,5,143,1601,8,143,
  	10,143,12,143,1604,9,143,1,144,1,144,3,144,1608,8,144,1,145,3,145,1611,
  	8,145,1,145,3,145,1614,8,145,1,145,1,145,1,145,1,145,1,145,3,145,1621,
  	8,145,1,145,3,145,1624,8,145,1,145,1,145,1,146,1,146,1,147,1,147,1,147,
  	1,147,1,148,5,148,1635,8,148,10,148,12,148,1638,9,148,1,149,1,149,3,149,
  	1642,8,149,1,150,1,150,1,150,1,150,1,150,1,150,3,150,1650,8,150,1,151,
  	1,151,1,151,1,151,1,151,1,152,1,152,1,152,3,152,1660,8,152,1,152,1,152,
  	3,152,1664,8,152,1,153,1,153,3,153,1668,8,153,1,153,1,153,3,153,1672,
  	8,153,1,153,3,153,1675,8,153,1,153,3,153,1678,8,153,1,154,1,154,1,154,
  	3,154,1683,8,154,1,154,1,154,1,155,3,155,1688,8,155,1,155,3,155,1691,
  	8,155,1,155,1,155,1,155,3,155,1696,8,155,1,155,3,155,1699,8,155,1,155,
  	3,155,1702,8,155,1,156,1,156,3,156,1706,8,156,1,156,1,156,3,156,1710,
  	8,156,1,156,3,156,1713,8,156,1,156,1,156,1,157,3,157,1718,8,157,1,157,
  	3,157,1721,8,157,1,157,1,157,3,157,1725,8,157,1,158,1,158,1,159,3,159,
  	1730,8,159,1,159,1,159,1,159,1,160,3,160,1736,8,160,1,160,3,160,1739,
  	8,160,1,160,1,160,1,160,3,160,1744,8,160,1,160,3,160,1747,8,160,1,160,
  	1,160,1,161,1,161,1,161,1,161,1,162,5,162,1756,8,162,10,162,12,162,1759,
  	9,162,1,163,1,163,3,163,1763,8,163,1,164,1,164,1,164,3,164,1768,8,164,
  	1,164,1,164,1,164,3,164,1773,8,164,1,165,3,165,1776,8,165,1,165,3,165,
  	1779,8,165,1,165,1,165,3,165,1783,8,165,1,165,1,165,1,166,1,166,3,166,
  	1789,8,166,1,166,1,166,1,167,1,167,1,167,3,167,1796,8,167,1,168,1,168,
  	1,168,1,168,1,169,1,169,1,169,1,169,1,170,1,170,1,170,1,170,3,170,1810,
  	8,170,1,171,1,171,1,171,1,172,1,172,1,172,1,172,3,172,1819,8,172,1,172,
  	1,172,1,173,4,173,1824,8,173,11,173,12,173,1825,1,174,1,174,1,174,3,174,
  	1831,8,174,1,175,1,175,1,175,1,175,1,176,1,176,1,176,1,176,1,177,1,177,
  	1,177,1,177,1,178,1,178,1,178,5,178,1848,8,178,10,178,12,178,1851,9,178,
  	1,179,1,179,1,179,5,179,1856,8,179,10,179,12,179,1859,9,179,1,180,1,180,
  	1,180,1,180,1,180,1,180,1,180,1,180,1,180,1,180,1,180,1,180,1,180,1,180,
  	1,180,1,180,3,180,1877,8,180,1,180,1,180,1,180,3,180,1882,8,180,1,181,
  	4,181,1885,8,181,11,181,12,181,1886,1,182,1,182,1,182,1,182,3,182,1893,
  	8,182,1,183,1,183,1,184,1,184,1,184,1,184,3,184,1901,8,184,1,184,3,184,
  	1904,8,184,1,184,1,184,1,184,1,184,1,184,1,184,3,184,1912,8,184,1,184,
  	1,184,1,184,5,184,1917,8,184,10,184,12,184,1920,9,184,1,185,1,185,1,186,
  	1,186,1,187,1,187,1,187,1,187,3,187,1930,8,187,1,188,1,188,3,188,1934,
  	8,188,1,188,1,188,1,189,1,189,1,189,5,189,1941,8,189,10,189,12,189,1944,
  	9,189,1,190,1,190,1,190,3,190,1949,8,190,1,190,1,190,1,191,3,191,1954,
  	8,191,1,191,1,191,1,191,3,191,1959,8,191,1,192,1,192,1,192,1,193,1,193,
  	1,194,1,194,1,194,3,194,1969,8,194,1,195,1,195,1,195,5,195,1974,8,195,
  	10,195,12,195,1977,9,195,1,196,1,196,3,196,1981,8,196,1,196,1,196,1,197,
  	4,197,1986,8,197,11,197,12,197,1987,1,198,4,198,1991,8,198,11,198,12,
  	198,1992,1,199,1,199,3,199,1997,8,199,1,199,1,199,1,199,3,199,2002,8,
  	199,1,199,1,199,1,199,3,199,2007,8,199,1,199,1,199,1,199,1,199,1,199,
  	1,199,3,199,2015,8,199,1,200,1,200,1,200,1,200,1,200,1,200,3,200,2023,
  	8,200,1,201,3,201,2026,8,201,1,201,1,201,3,201,2030,8,201,1,202,1,202,
  	1,202,5,202,2035,8,202,10,202,12,202,2038,9,202,1,203,3,203,2041,8,203,
  	1,203,1,203,3,203,2045,8,203,1,204,1,204,1,204,1,205,1,205,3,205,2052,
  	8,205,1,206,1,206,1,206,1,206,1,206,3,206,2059,8,206,1,206,3,206,2062,
  	8,206,1,206,1,206,1,206,3,206,2067,8,206,1,207,4,207,2070,8,207,11,207,
  	12,207,2071,1,208,1,208,1,208,1,208,1,209,1,209,1,209,3,209,2081,8,209,
  	3,209,2083,8,209,1,209,1,209,1,210,1,210,3,210,2089,8,210,1,210,1,210,
  	1,210,1,210,1,210,1,210,1,210,1,210,1,210,1,210,1,210,1,210,1,210,1,210,
  	3,210,2105,8,210,1,211,1,211,1,211,1,211,1,211,3,211,2112,8,211,1,212,
  	1,212,1,212,1,212,1,212,1,212,1,212,1,212,1,212,1,212,1,212,3,212,2125,
  	8,212,1,213,1,213,3,213,2129,8,213,1,213,1,213,1,214,1,214,1,214,5,214,
  	2136,8,214,10,214,12,214,2139,9,214,1,214,3,214,2142,8,214,1,215,1,215,
  	1,216,1,216,1,216,3,216,2149,8,216,1,216,1,216,1,217,1,217,1,217,5,217,
  	2156,8,217,10,217,12,217,2159,9,217,1,217,3,217,2162,8,217,1,218,1,218,
  	1,218,1,218,1,219,1,219,1,219,1,219,1,219,1,219,1,219,1,219,1,219,1,219,
  	1,219,1,219,1,219,1,219,1,219,1,219,1,219,1,219,1,219,1,219,1,219,1,219,
  	1,219,1,219,1,219,1,219,1,219,1,219,1,219,1,219,1,219,1,219,1,219,3,219,
  	2201,8,219,1,220,1,220,1,220,1,220,1,220,1,220,1,220,1,220,1,220,1,220,
  	1,220,1,220,3,220,2215,8,220,1,221,1,221,1,221,1,221,1,221,1,221,1,221,
  	1,221,1,221,1,221,1,221,3,221,2228,8,221,1,222,1,222,3,222,2232,8,222,
  	1,222,3,222,2235,8,222,1,222,1,222,1,223,3,223,2240,8,223,1,223,1,223,
  	3,223,2244,8,223,1,223,3,223,2247,8,223,1,223,1,223,1,223,1,223,1,223,
  	3,223,2254,8,223,1,224,1,224,3,224,2258,8,224,1,224,1,224,3,224,2262,
  	8,224,1,225,1,225,1,225,5,225,2267,8,225,10,225,12,225,2270,9,225,1,226,
  	1,226,1,226,3,226,2275,8,226,3,226,2277,8,226,1,227,1,227,1,227,1,227,
  	1,228,1,228,1,228,5,228,2286,8,228,10,228,12,228,2289,9,228,1,229,3,229,
  	2292,8,229,1,229,1,229,3,229,2296,8,229,1,229,1,229,1,229,3,229,2301,
  	8,229,1,230,1,230,1,230,1,230,1,230,3,230,2308,8,230,3,230,2310,8,230,
  	1,231,1,231,1,231,3,231,2315,8,231,1,231,1,231,3,231,2319,8,231,1,232,
  	1,232,1,232,1,232,1,233,1,233,1,233,1,233,1,234,1,234,1,234,1,234,1,234,
  	1,234,1,234,1,234,3,234,2337,8,234,1,235,1,235,1,235,5,235,2342,8,235,
  	10,235,12,235,2345,9,235,1,236,1,236,1,236,3,236,2350,8,236,1,236,1,236,
  	1,237,1,237,1,238,1,238,3,238,2358,8,238,1,238,1,238,1,238,1,239,1,239,
  	1,239,5,239,2366,8,239,10,239,12,239,2369,9,239,1,240,1,240,3,240,2373,
  	8,240,1,240,3,240,2376,8,240,1,241,4,241,2379,8,241,11,241,12,241,2380,
  	1,242,1,242,1,242,1,242,1,242,1,242,1,242,3,242,2390,8,242,1,243,1,243,
  	1,243,1,243,3,243,2396,8,243,1,243,1,243,1,243,1,244,1,244,1,244,1,244,
  	1,244,1,245,1,245,1,245,1,245,1,245,1,245,1,245,1,245,5,245,2414,8,245,
  	10,245,12,245,2417,9,245,1,245,5,245,2420,8,245,10,245,12,245,2423,9,
  	245,1,246,3,246,2426,8,246,1,246,1,246,3,246,2430,8,246,1,247,1,247,1,
  	247,1,247,1,247,1,247,3,247,2438,8,247,1,248,1,248,1,248,1,248,1,248,
  	1,248,1,248,1,248,3,248,2448,8,248,3,248,2450,8,248,1,249,1,249,1,249,
  	1,250,1,250,1,250,1,250,1,251,1,251,1,251,1,252,1,252,1,252,1,253,1,253,
  	3,253,2467,8,253,1,253,1,253,1,254,1,254,1,254,5,254,2474,8,254,10,254,
  	12,254,2477,9,254,1,255,3,255,2480,8,255,1,255,1,255,1,255,3,255,2485,
  	8,255,1,256,1,256,3,256,2489,8,256,1,257,4,257,2492,8,257,11,257,12,257,
  	2493,1,258,1,258,1,258,1,258,1,259,4,259,2501,8,259,11,259,12,259,2502,
  	1,260,1,260,1,260,1,261,1,261,1,261,1,261,1,261,1,261,1,261,1,261,1,261,
  	1,261,1,261,1,261,1,261,1,261,3,261,2522,8,261,1,261,1,261,1,261,1,261,
  	1,261,1,261,1,261,1,261,1,261,3,261,2533,8,261,5,261,2535,8,261,10,261,
  	12,261,2538,9,261,1,262,1,262,3,262,2542,8,262,1,262,3,262,2545,8,262,
  	1,262,1,262,1,263,1,263,3,263,2551,8,263,1,263,1,263,3,263,2555,8,263,
  	1,264,1,264,1,265,1,265,3,265,2561,8,265,1,265,1,265,1,266,1,266,1,266,
  	5,266,2568,8,266,10,266,12,266,2571,9,266,1,267,1,267,1,267,1,267,3,267,
  	2577,8,267,1,267,1,267,3,267,2581,8,267,1,268,4,268,2584,8,268,11,268,
  	12,268,2585,1,269,3,269,2589,8,269,1,269,1,269,3,269,2593,8,269,1,269,
  	1,269,1,269,1,270,1,270,1,270,3,270,2601,8,270,3,270,2603,8,270,1,270,
  	1,270,1,271,1,271,1,271,5,271,2610,8,271,10,271,12,271,2613,9,271,1,272,
  	3,272,2616,8,272,1,272,3,272,2619,8,272,1,272,1,272,1,272,1,272,3,272,
  	2625,8,272,1,273,4,273,2628,8,273,11,273,12,273,2629,1,274,1,274,1,274,
  	1,274,1,275,1,275,1,275,1,275,1,275,1,275,1,276,1,276,1,276,5,276,2645,
  	8,276,10,276,12,276,2648,9,276,1,276,3,276,2651,8,276,1,277,1,277,1,277,
  	1,278,1,278,1,278,1,279,1,279,1,280,1,280,1,281,1,281,1,281,1,282,1,282,
  	1,282,5,282,2669,8,282,10,282,12,282,2672,9,282,1,283,1,283,1,283,1,283,
  	1,283,1,283,3,283,2680,8,283,1,283,3,283,2683,8,283,1,284,1,284,1,284,
  	5,284,2688,8,284,10,284,12,284,2691,9,284,1,285,1,285,1,286,1,286,1,286,
  	1,287,1,287,1,287,1,288,1,288,1,288,1,288,1,289,1,289,1,289,1,289,1,290,
  	1,290,1,290,1,290,1,291,1,291,1,291,1,292,1,292,1,292,1,292,1,293,1,293,
  	1,293,1,293,1,293,1,294,1,294,1,294,1,294,1,295,1,295,1,295,1,296,1,296,
  	1,296,1,297,1,297,1,297,1,298,1,298,3,298,2740,8,298,1,298,1,298,1,298,
  	3,298,2745,8,298,1,299,1,299,3,299,2749,8,299,1,300,1,300,3,300,2753,
  	8,300,1,301,1,301,4,301,2757,8,301,11,301,12,301,2758,1,302,1,302,1,303,
  	1,303,3,303,2765,8,303,1,304,1,304,4,304,2769,8,304,11,304,12,304,2770,
  	1,305,1,305,1,305,1,305,3,305,2777,8,305,1,306,3,306,2780,8,306,1,306,
  	1,306,3,306,2784,8,306,1,306,3,306,2787,8,306,1,307,1,307,1,308,1,308,
  	1,309,1,309,1,310,1,310,1,310,3,310,2798,8,310,1,311,1,311,4,311,2802,
  	8,311,11,311,12,311,2803,1,311,1,311,1,311,4,311,2809,8,311,11,311,12,
  	311,2810,1,311,3,311,2814,8,311,1,312,1,312,5,312,2818,8,312,10,312,12,
  	312,2821,9,312,1,312,1,312,1,312,5,312,2826,8,312,10,312,12,312,2829,
  	9,312,1,312,3,312,2832,8,312,1,313,1,313,1,313,1,313,1,313,1,313,1,313,
  	1,313,3,313,2842,8,313,1,313,1,313,5,313,2846,8,313,10,313,12,313,2849,
  	9,313,1,313,1,313,1,313,1,313,1,313,1,313,1,313,1,313,1,313,3,313,2860,
  	8,313,1,313,1,313,5,313,2864,8,313,10,313,12,313,2867,9,313,1,313,3,313,
  	2870,8,313,1,313,1,2421,3,98,368,522,314,0,2,4,6,8,10,12,14,16,18,20,
  	22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,
  	68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,
  	112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,
  	148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,
  	184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,
  	220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,
  	256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,
  	292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,
  	328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,
  	364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,
  	400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,
  	436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,
  	472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,502,504,506,
  	508,510,512,514,516,518,520,522,524,526,528,530,532,534,536,538,540,542,
  	544,546,548,550,552,554,556,558,560,562,564,566,568,570,572,574,576,578,
  	580,582,584,586,588,590,592,594,596,598,600,602,604,606,608,610,612,614,
  	616,618,620,622,624,626,0,22,1,0,27,28,1,0,62,63,1,0,97,103,1,0,104,107,
  	1,0,108,109,1,0,116,117,2,0,97,101,109,112,6,0,6,6,13,13,16,16,27,29,
  	36,36,59,59,1,0,39,40,1,0,151,152,1,0,53,54,1,0,49,51,1,0,75,76,3,0,20,
  	20,22,24,79,79,1,0,77,78,5,0,138,138,145,147,152,153,156,156,164,165,
  	1,0,135,136,16,0,1,2,5,6,8,8,10,11,14,14,17,17,20,26,29,33,41,41,47,58,
  	60,71,73,78,85,88,92,112,114,115,135,136,15,0,1,1,3,20,22,29,34,40,42,
  	46,58,59,72,72,79,84,89,91,95,96,113,113,116,128,130,130,132,134,150,
  	150,3,0,148,149,151,152,154,163,2,0,84,84,89,89,1,0,170,174,3041,0,629,
  	1,0,0,0,2,647,1,0,0,0,4,653,1,0,0,0,6,660,1,0,0,0,8,662,1,0,0,0,10,674,
  	1,0,0,0,12,678,1,0,0,0,14,690,1,0,0,0,16,692,1,0,0,0,18,696,1,0,0,0,20,
  	700,1,0,0,0,22,708,1,0,0,0,24,710,1,0,0,0,26,720,1,0,0,0,28,722,1,0,0,
  	0,30,727,1,0,0,0,32,735,1,0,0,0,34,746,1,0,0,0,36,749,1,0,0,0,38,755,
  	1,0,0,0,40,770,1,0,0,0,42,775,1,0,0,0,44,778,1,0,0,0,46,780,1,0,0,0,48,
  	789,1,0,0,0,50,794,1,0,0,0,52,798,1,0,0,0,54,803,1,0,0,0,56,807,1,0,0,
  	0,58,814,1,0,0,0,60,817,1,0,0,0,62,824,1,0,0,0,64,826,1,0,0,0,66,830,
  	1,0,0,0,68,834,1,0,0,0,70,836,1,0,0,0,72,840,1,0,0,0,74,843,1,0,0,0,76,
  	846,1,0,0,0,78,852,1,0,0,0,80,856,1,0,0,0,82,862,1,0,0,0,84,872,1,0,0,
  	0,86,879,1,0,0,0,88,881,1,0,0,0,90,890,1,0,0,0,92,896,1,0,0,0,94,900,
  	1,0,0,0,96,905,1,0,0,0,98,919,1,0,0,0,100,962,1,0,0,0,102,964,1,0,0,0,
  	104,968,1,0,0,0,106,973,1,0,0,0,108,975,1,0,0,0,110,977,1,0,0,0,112,985,
  	1,0,0,0,114,987,1,0,0,0,116,1001,1,0,0,0,118,1003,1,0,0,0,120,1005,1,
  	0,0,0,122,1010,1,0,0,0,124,1012,1,0,0,0,126,1017,1,0,0,0,128,1029,1,0,
  	0,0,130,1031,1,0,0,0,132,1040,1,0,0,0,134,1042,1,0,0,0,136,1046,1,0,0,
  	0,138,1054,1,0,0,0,140,1062,1,0,0,0,142,1065,1,0,0,0,144,1075,1,0,0,0,
  	146,1077,1,0,0,0,148,1083,1,0,0,0,150,1089,1,0,0,0,152,1093,1,0,0,0,154,
  	1101,1,0,0,0,156,1118,1,0,0,0,158,1124,1,0,0,0,160,1129,1,0,0,0,162,1131,
  	1,0,0,0,164,1138,1,0,0,0,166,1146,1,0,0,0,168,1148,1,0,0,0,170,1158,1,
  	0,0,0,172,1161,1,0,0,0,174,1169,1,0,0,0,176,1177,1,0,0,0,178,1181,1,0,
  	0,0,180,1184,1,0,0,0,182,1204,1,0,0,0,184,1211,1,0,0,0,186,1226,1,0,0,
  	0,188,1229,1,0,0,0,190,1239,1,0,0,0,192,1251,1,0,0,0,194,1255,1,0,0,0,
  	196,1268,1,0,0,0,198,1276,1,0,0,0,200,1283,1,0,0,0,202,1297,1,0,0,0,204,
  	1306,1,0,0,0,206,1315,1,0,0,0,208,1327,1,0,0,0,210,1329,1,0,0,0,212,1332,
  	1,0,0,0,214,1345,1,0,0,0,216,1354,1,0,0,0,218,1356,1,0,0,0,220,1366,1,
  	0,0,0,222,1372,1,0,0,0,224,1374,1,0,0,0,226,1380,1,0,0,0,228,1389,1,0,
  	0,0,230,1402,1,0,0,0,232,1404,1,0,0,0,234,1406,1,0,0,0,236,1410,1,0,0,
  	0,238,1420,1,0,0,0,240,1440,1,0,0,0,242,1447,1,0,0,0,244,1450,1,0,0,0,
  	246,1458,1,0,0,0,248,1475,1,0,0,0,250,1477,1,0,0,0,252,1479,1,0,0,0,254,
  	1481,1,0,0,0,256,1495,1,0,0,0,258,1502,1,0,0,0,260,1505,1,0,0,0,262,1510,
  	1,0,0,0,264,1518,1,0,0,0,266,1522,1,0,0,0,268,1528,1,0,0,0,270,1531,1,
  	0,0,0,272,1549,1,0,0,0,274,1551,1,0,0,0,276,1558,1,0,0,0,278,1563,1,0,
  	0,0,280,1566,1,0,0,0,282,1593,1,0,0,0,284,1595,1,0,0,0,286,1602,1,0,0,
  	0,288,1607,1,0,0,0,290,1610,1,0,0,0,292,1627,1,0,0,0,294,1629,1,0,0,0,
  	296,1636,1,0,0,0,298,1641,1,0,0,0,300,1649,1,0,0,0,302,1651,1,0,0,0,304,
  	1656,1,0,0,0,306,1665,1,0,0,0,308,1679,1,0,0,0,310,1687,1,0,0,0,312,1703,
  	1,0,0,0,314,1717,1,0,0,0,316,1726,1,0,0,0,318,1729,1,0,0,0,320,1735,1,
  	0,0,0,322,1750,1,0,0,0,324,1757,1,0,0,0,326,1762,1,0,0,0,328,1764,1,0,
  	0,0,330,1775,1,0,0,0,332,1786,1,0,0,0,334,1795,1,0,0,0,336,1797,1,0,0,
  	0,338,1801,1,0,0,0,340,1805,1,0,0,0,342,1811,1,0,0,0,344,1814,1,0,0,0,
  	346,1823,1,0,0,0,348,1830,1,0,0,0,350,1832,1,0,0,0,352,1836,1,0,0,0,354,
  	1840,1,0,0,0,356,1844,1,0,0,0,358,1852,1,0,0,0,360,1881,1,0,0,0,362,1884,
  	1,0,0,0,364,1888,1,0,0,0,366,1894,1,0,0,0,368,1911,1,0,0,0,370,1921,1,
  	0,0,0,372,1923,1,0,0,0,374,1929,1,0,0,0,376,1931,1,0,0,0,378,1937,1,0,
  	0,0,380,1948,1,0,0,0,382,1953,1,0,0,0,384,1960,1,0,0,0,386,1963,1,0,0,
  	0,388,1965,1,0,0,0,390,1970,1,0,0,0,392,1978,1,0,0,0,394,1985,1,0,0,0,
  	396,1990,1,0,0,0,398,2014,1,0,0,0,400,2022,1,0,0,0,402,2025,1,0,0,0,404,
  	2031,1,0,0,0,406,2044,1,0,0,0,408,2046,1,0,0,0,410,2049,1,0,0,0,412,2066,
  	1,0,0,0,414,2069,1,0,0,0,416,2073,1,0,0,0,418,2082,1,0,0,0,420,2104,1,
  	0,0,0,422,2106,1,0,0,0,424,2124,1,0,0,0,426,2126,1,0,0,0,428,2132,1,0,
  	0,0,430,2143,1,0,0,0,432,2145,1,0,0,0,434,2152,1,0,0,0,436,2163,1,0,0,
  	0,438,2200,1,0,0,0,440,2214,1,0,0,0,442,2227,1,0,0,0,444,2229,1,0,0,0,
  	446,2253,1,0,0,0,448,2261,1,0,0,0,450,2263,1,0,0,0,452,2271,1,0,0,0,454,
  	2278,1,0,0,0,456,2282,1,0,0,0,458,2291,1,0,0,0,460,2309,1,0,0,0,462,2311,
  	1,0,0,0,464,2320,1,0,0,0,466,2324,1,0,0,0,468,2336,1,0,0,0,470,2338,1,
  	0,0,0,472,2349,1,0,0,0,474,2353,1,0,0,0,476,2355,1,0,0,0,478,2362,1,0,
  	0,0,480,2375,1,0,0,0,482,2378,1,0,0,0,484,2389,1,0,0,0,486,2391,1,0,0,
  	0,488,2400,1,0,0,0,490,2405,1,0,0,0,492,2429,1,0,0,0,494,2431,1,0,0,0,
  	496,2439,1,0,0,0,498,2451,1,0,0,0,500,2454,1,0,0,0,502,2458,1,0,0,0,504,
  	2461,1,0,0,0,506,2464,1,0,0,0,508,2470,1,0,0,0,510,2479,1,0,0,0,512,2486,
  	1,0,0,0,514,2491,1,0,0,0,516,2495,1,0,0,0,518,2500,1,0,0,0,520,2504,1,
  	0,0,0,522,2521,1,0,0,0,524,2539,1,0,0,0,526,2548,1,0,0,0,528,2556,1,0,
  	0,0,530,2558,1,0,0,0,532,2564,1,0,0,0,534,2576,1,0,0,0,536,2583,1,0,0,
  	0,538,2588,1,0,0,0,540,2597,1,0,0,0,542,2606,1,0,0,0,544,2624,1,0,0,0,
  	546,2627,1,0,0,0,548,2631,1,0,0,0,550,2635,1,0,0,0,552,2641,1,0,0,0,554,
  	2652,1,0,0,0,556,2655,1,0,0,0,558,2658,1,0,0,0,560,2660,1,0,0,0,562,2662,
  	1,0,0,0,564,2665,1,0,0,0,566,2682,1,0,0,0,568,2684,1,0,0,0,570,2692,1,
  	0,0,0,572,2694,1,0,0,0,574,2697,1,0,0,0,576,2700,1,0,0,0,578,2704,1,0,
  	0,0,580,2708,1,0,0,0,582,2712,1,0,0,0,584,2715,1,0,0,0,586,2719,1,0,0,
  	0,588,2724,1,0,0,0,590,2728,1,0,0,0,592,2731,1,0,0,0,594,2734,1,0,0,0,
  	596,2744,1,0,0,0,598,2748,1,0,0,0,600,2752,1,0,0,0,602,2756,1,0,0,0,604,
  	2760,1,0,0,0,606,2764,1,0,0,0,608,2768,1,0,0,0,610,2776,1,0,0,0,612,2786,
  	1,0,0,0,614,2788,1,0,0,0,616,2790,1,0,0,0,618,2792,1,0,0,0,620,2797,1,
  	0,0,0,622,2813,1,0,0,0,624,2831,1,0,0,0,626,2869,1,0,0,0,628,630,3,4,
  	2,0,629,628,1,0,0,0,629,630,1,0,0,0,630,631,1,0,0,0,631,632,5,0,0,1,632,
  	1,1,0,0,0,633,642,3,6,3,0,634,642,3,156,78,0,635,642,3,22,11,0,636,642,
  	3,56,28,0,637,642,3,62,31,0,638,642,3,74,37,0,639,642,3,76,38,0,640,642,
  	3,402,201,0,641,633,1,0,0,0,641,634,1,0,0,0,641,635,1,0,0,0,641,636,1,
  	0,0,0,641,637,1,0,0,0,641,638,1,0,0,0,641,639,1,0,0,0,641,640,1,0,0,0,
  	642,644,1,0,0,0,643,645,5,147,0,0,644,643,1,0,0,0,644,645,1,0,0,0,645,
  	648,1,0,0,0,646,648,3,86,43,0,647,641,1,0,0,0,647,646,1,0,0,0,648,3,1,
  	0,0,0,649,650,4,2,0,1,650,651,3,2,1,0,651,652,6,2,-1,0,652,654,1,0,0,
  	0,653,649,1,0,0,0,654,655,1,0,0,0,655,653,1,0,0,0,655,656,1,0,0,0,656,
  	5,1,0,0,0,657,661,3,8,4,0,658,661,3,10,5,0,659,661,3,20,10,0,660,657,
  	1,0,0,0,660,658,1,0,0,0,660,659,1,0,0,0,661,7,1,0,0,0,662,664,5,14,0,
  	0,663,665,5,4,0,0,664,663,1,0,0,0,664,665,1,0,0,0,665,666,1,0,0,0,666,
  	667,3,368,184,0,667,668,5,17,0,0,668,670,3,402,201,0,669,671,3,42,21,
  	0,670,669,1,0,0,0,670,671,1,0,0,0,671,672,1,0,0,0,672,673,3,162,81,0,
  	673,9,1,0,0,0,674,675,5,26,0,0,675,676,3,12,6,0,676,677,3,162,81,0,677,
  	11,1,0,0,0,678,683,3,14,7,0,679,680,5,145,0,0,680,682,3,14,7,0,681,679,
  	1,0,0,0,682,685,1,0,0,0,683,681,1,0,0,0,683,684,1,0,0,0,684,13,1,0,0,
  	0,685,683,1,0,0,0,686,691,3,124,62,0,687,691,3,402,201,0,688,691,3,16,
  	8,0,689,691,3,18,9,0,690,686,1,0,0,0,690,687,1,0,0,0,690,688,1,0,0,0,
  	690,689,1,0,0,0,691,15,1,0,0,0,692,693,5,4,0,0,693,694,3,368,184,0,694,
  	695,3,178,89,0,695,17,1,0,0,0,696,697,7,0,0,0,697,698,3,368,184,0,698,
  	699,3,178,89,0,699,19,1,0,0,0,700,701,5,34,0,0,701,702,3,162,81,0,702,
  	703,5,26,0,0,703,704,3,402,201,0,704,21,1,0,0,0,705,709,3,24,12,0,706,
  	709,3,28,14,0,707,709,3,30,15,0,708,705,1,0,0,0,708,706,1,0,0,0,708,707,
  	1,0,0,0,709,23,1,0,0,0,710,711,5,18,0,0,711,712,3,12,6,0,712,714,3,162,
  	81,0,713,715,3,26,13,0,714,713,1,0,0,0,714,715,1,0,0,0,715,25,1,0,0,0,
  	716,717,5,12,0,0,717,721,3,162,81,0,718,719,5,12,0,0,719,721,3,24,12,
  	0,720,716,1,0,0,0,720,718,1,0,0,0,721,27,1,0,0,0,722,723,5,11,0,0,723,
  	724,3,12,6,0,724,725,5,12,0,0,725,726,3,162,81,0,726,29,1,0,0,0,727,728,
  	5,35,0,0,728,729,3,402,201,0,729,731,5,139,0,0,730,732,3,32,16,0,731,
  	730,1,0,0,0,731,732,1,0,0,0,732,733,1,0,0,0,733,734,5,142,0,0,734,31,
  	1,0,0,0,735,737,3,34,17,0,736,738,3,32,16,0,737,736,1,0,0,0,737,738,1,
  	0,0,0,738,33,1,0,0,0,739,742,3,36,18,0,740,742,3,40,20,0,741,739,1,0,
  	0,0,741,740,1,0,0,0,742,743,1,0,0,0,743,744,3,4,2,0,744,747,1,0,0,0,745,
  	747,3,46,23,0,746,741,1,0,0,0,746,745,1,0,0,0,747,35,1,0,0,0,748,750,
  	3,394,197,0,749,748,1,0,0,0,749,750,1,0,0,0,750,751,1,0,0,0,751,752,5,
  	4,0,0,752,753,3,38,19,0,753,754,5,146,0,0,754,37,1,0,0,0,755,757,3,368,
  	184,0,756,758,3,42,21,0,757,756,1,0,0,0,757,758,1,0,0,0,758,766,1,0,0,
  	0,759,760,5,145,0,0,760,762,3,368,184,0,761,763,3,42,21,0,762,761,1,0,
  	0,0,762,763,1,0,0,0,763,765,1,0,0,0,764,759,1,0,0,0,765,768,1,0,0,0,766,
  	764,1,0,0,0,766,767,1,0,0,0,767,39,1,0,0,0,768,766,1,0,0,0,769,771,3,
  	394,197,0,770,769,1,0,0,0,770,771,1,0,0,0,771,772,1,0,0,0,772,773,5,8,
  	0,0,773,774,5,146,0,0,774,41,1,0,0,0,775,776,5,25,0,0,776,777,3,44,22,
  	0,777,43,1,0,0,0,778,779,3,402,201,0,779,45,1,0,0,0,780,782,3,48,24,0,
  	781,783,3,50,25,0,782,781,1,0,0,0,782,783,1,0,0,0,783,785,1,0,0,0,784,
  	786,3,54,27,0,785,784,1,0,0,0,785,786,1,0,0,0,786,787,1,0,0,0,787,788,
  	5,122,0,0,788,47,1,0,0,0,789,790,5,119,0,0,790,792,3,98,49,0,791,793,
  	3,32,16,0,792,791,1,0,0,0,792,793,1,0,0,0,793,49,1,0,0,0,794,796,3,94,
  	47,0,795,797,3,50,25,0,796,795,1,0,0,0,796,797,1,0,0,0,797,51,1,0,0,0,
  	798,799,5,120,0,0,799,801,3,98,49,0,800,802,3,32,16,0,801,800,1,0,0,0,
  	801,802,1,0,0,0,802,53,1,0,0,0,803,805,5,121,0,0,804,806,3,32,16,0,805,
  	804,1,0,0,0,805,806,1,0,0,0,806,55,1,0,0,0,807,812,3,58,29,0,808,813,
  	3,6,3,0,809,813,3,24,12,0,810,813,3,30,15,0,811,813,3,76,38,0,812,808,
  	1,0,0,0,812,809,1,0,0,0,812,810,1,0,0,0,812,811,1,0,0,0,813,57,1,0,0,
  	0,814,815,3,60,30,0,815,816,5,146,0,0,816,59,1,0,0,0,817,818,3,566,283,
  	0,818,61,1,0,0,0,819,825,3,64,32,0,820,825,3,66,33,0,821,825,3,68,34,
  	0,822,825,3,70,35,0,823,825,3,72,36,0,824,819,1,0,0,0,824,820,1,0,0,0,
  	824,821,1,0,0,0,824,822,1,0,0,0,824,823,1,0,0,0,825,63,1,0,0,0,826,828,
  	5,3,0,0,827,829,3,60,30,0,828,827,1,0,0,0,828,829,1,0,0,0,829,65,1,0,
  	0,0,830,832,5,7,0,0,831,833,3,60,30,0,832,831,1,0,0,0,832,833,1,0,0,0,
  	833,67,1,0,0,0,834,835,5,15,0,0,835,69,1,0,0,0,836,838,5,37,0,0,837,839,
  	3,402,201,0,838,837,1,0,0,0,838,839,1,0,0,0,839,71,1,0,0,0,840,841,5,
  	38,0,0,841,842,3,402,201,0,842,73,1,0,0,0,843,844,5,9,0,0,844,845,3,162,
  	81,0,845,75,1,0,0,0,846,847,5,10,0,0,847,849,3,162,81,0,848,850,3,78,
  	39,0,849,848,1,0,0,0,849,850,1,0,0,0,850,77,1,0,0,0,851,853,3,80,40,0,
  	852,851,1,0,0,0,853,854,1,0,0,0,854,852,1,0,0,0,854,855,1,0,0,0,855,79,
  	1,0,0,0,856,858,5,5,0,0,857,859,3,82,41,0,858,857,1,0,0,0,858,859,1,0,
  	0,0,859,860,1,0,0,0,860,861,3,162,81,0,861,81,1,0,0,0,862,869,3,84,42,
  	0,863,864,3,84,42,0,864,865,5,145,0,0,865,866,3,84,42,0,866,868,1,0,0,
  	0,867,863,1,0,0,0,868,871,1,0,0,0,869,867,1,0,0,0,869,870,1,0,0,0,870,
  	83,1,0,0,0,871,869,1,0,0,0,872,874,3,368,184,0,873,875,3,42,21,0,874,
  	873,1,0,0,0,874,875,1,0,0,0,875,85,1,0,0,0,876,880,3,88,44,0,877,880,
  	3,114,57,0,878,880,3,120,60,0,879,876,1,0,0,0,879,877,1,0,0,0,879,878,
  	1,0,0,0,880,87,1,0,0,0,881,883,3,90,45,0,882,884,3,92,46,0,883,882,1,
  	0,0,0,883,884,1,0,0,0,884,886,1,0,0,0,885,887,3,96,48,0,886,885,1,0,0,
  	0,886,887,1,0,0,0,887,888,1,0,0,0,888,889,5,122,0,0,889,89,1,0,0,0,890,
  	891,5,119,0,0,891,893,3,98,49,0,892,894,3,4,2,0,893,892,1,0,0,0,893,894,
  	1,0,0,0,894,91,1,0,0,0,895,897,3,94,47,0,896,895,1,0,0,0,897,898,1,0,
  	0,0,898,896,1,0,0,0,898,899,1,0,0,0,899,93,1,0,0,0,900,901,5,120,0,0,
  	901,903,3,98,49,0,902,904,3,4,2,0,903,902,1,0,0,0,903,904,1,0,0,0,904,
  	95,1,0,0,0,905,907,5,121,0,0,906,908,3,4,2,0,907,906,1,0,0,0,907,908,
  	1,0,0,0,908,97,1,0,0,0,909,910,6,49,-1,0,910,920,3,100,50,0,911,920,3,
  	566,283,0,912,920,3,614,307,0,913,914,5,140,0,0,914,915,3,98,49,0,915,
  	916,5,143,0,0,916,920,1,0,0,0,917,918,5,151,0,0,918,920,3,98,49,2,919,
  	909,1,0,0,0,919,911,1,0,0,0,919,912,1,0,0,0,919,913,1,0,0,0,919,917,1,
  	0,0,0,920,930,1,0,0,0,921,924,10,1,0,0,922,925,3,576,288,0,923,925,3,
  	578,289,0,924,922,1,0,0,0,924,923,1,0,0,0,925,926,1,0,0,0,926,927,3,98,
  	49,2,927,929,1,0,0,0,928,921,1,0,0,0,929,932,1,0,0,0,930,928,1,0,0,0,
  	930,931,1,0,0,0,931,99,1,0,0,0,932,930,1,0,0,0,933,934,5,60,0,0,934,935,
  	5,140,0,0,935,936,3,106,53,0,936,937,5,143,0,0,937,963,1,0,0,0,938,939,
  	5,61,0,0,939,940,5,140,0,0,940,941,3,108,54,0,941,942,5,143,0,0,942,963,
  	1,0,0,0,943,944,7,1,0,0,944,947,5,140,0,0,945,948,3,580,290,0,946,948,
  	3,582,291,0,947,945,1,0,0,0,947,946,1,0,0,0,948,949,1,0,0,0,949,950,3,
  	102,51,0,950,951,5,143,0,0,951,963,1,0,0,0,952,953,5,64,0,0,953,954,5,
  	140,0,0,954,955,3,110,55,0,955,956,5,143,0,0,956,963,1,0,0,0,957,958,
  	5,65,0,0,958,959,5,140,0,0,959,960,3,112,56,0,960,961,5,143,0,0,961,963,
  	1,0,0,0,962,933,1,0,0,0,962,938,1,0,0,0,962,943,1,0,0,0,962,952,1,0,0,
  	0,962,957,1,0,0,0,963,101,1,0,0,0,964,966,5,172,0,0,965,967,3,104,52,
  	0,966,965,1,0,0,0,966,967,1,0,0,0,967,103,1,0,0,0,968,969,5,138,0,0,969,
  	971,5,172,0,0,970,972,3,104,52,0,971,970,1,0,0,0,971,972,1,0,0,0,972,
  	105,1,0,0,0,973,974,7,2,0,0,974,107,1,0,0,0,975,976,7,3,0,0,976,109,1,
  	0,0,0,977,982,3,566,283,0,978,979,5,138,0,0,979,981,3,566,283,0,980,978,
  	1,0,0,0,981,984,1,0,0,0,982,980,1,0,0,0,982,983,1,0,0,0,983,111,1,0,0,
  	0,984,982,1,0,0,0,985,986,7,4,0,0,986,113,1,0,0,0,987,988,5,113,0,0,988,
  	997,5,140,0,0,989,990,5,114,0,0,990,991,5,146,0,0,991,992,3,118,59,0,
  	992,993,5,145,0,0,993,994,5,115,0,0,994,995,5,146,0,0,995,996,3,116,58,
  	0,996,998,1,0,0,0,997,989,1,0,0,0,997,998,1,0,0,0,998,999,1,0,0,0,999,
  	1000,5,143,0,0,1000,115,1,0,0,0,1001,1002,5,173,0,0,1002,117,1,0,0,0,
  	1003,1004,3,624,312,0,1004,119,1,0,0,0,1005,1006,7,5,0,0,1006,1007,5,
  	140,0,0,1007,1008,3,122,61,0,1008,1009,5,143,0,0,1009,121,1,0,0,0,1010,
  	1011,3,624,312,0,1011,123,1,0,0,0,1012,1013,5,118,0,0,1013,1014,5,140,
  	0,0,1014,1015,3,126,63,0,1015,1016,5,143,0,0,1016,125,1,0,0,0,1017,1022,
  	3,128,64,0,1018,1019,5,145,0,0,1019,1021,3,128,64,0,1020,1018,1,0,0,0,
  	1021,1024,1,0,0,0,1022,1020,1,0,0,0,1022,1023,1,0,0,0,1023,127,1,0,0,
  	0,1024,1022,1,0,0,0,1025,1026,3,130,65,0,1026,1027,3,132,66,0,1027,1030,
  	1,0,0,0,1028,1030,5,160,0,0,1029,1025,1,0,0,0,1029,1028,1,0,0,0,1030,
  	129,1,0,0,0,1031,1032,7,6,0,0,1032,131,1,0,0,0,1033,1041,5,173,0,0,1034,
  	1041,5,172,0,0,1035,1038,5,175,0,0,1036,1037,5,138,0,0,1037,1039,5,172,
  	0,0,1038,1036,1,0,0,0,1038,1039,1,0,0,0,1039,1041,1,0,0,0,1040,1033,1,
  	0,0,0,1040,1034,1,0,0,0,1040,1035,1,0,0,0,1041,133,1,0,0,0,1042,1043,
  	5,148,0,0,1043,1044,3,136,68,0,1044,1045,5,149,0,0,1045,135,1,0,0,0,1046,
  	1051,3,138,69,0,1047,1048,5,145,0,0,1048,1050,3,138,69,0,1049,1047,1,
  	0,0,0,1050,1053,1,0,0,0,1051,1049,1,0,0,0,1051,1052,1,0,0,0,1052,137,
  	1,0,0,0,1053,1051,1,0,0,0,1054,1060,3,528,264,0,1055,1058,5,146,0,0,1056,
  	1059,3,526,263,0,1057,1059,3,552,276,0,1058,1056,1,0,0,0,1058,1057,1,
  	0,0,0,1059,1061,1,0,0,0,1060,1055,1,0,0,0,1060,1061,1,0,0,0,1061,139,
  	1,0,0,0,1062,1063,5,25,0,0,1063,1064,3,142,71,0,1064,141,1,0,0,0,1065,
  	1070,3,144,72,0,1066,1067,5,145,0,0,1067,1069,3,144,72,0,1068,1066,1,
  	0,0,0,1069,1072,1,0,0,0,1070,1068,1,0,0,0,1070,1071,1,0,0,0,1071,143,
  	1,0,0,0,1072,1070,1,0,0,0,1073,1076,3,146,73,0,1074,1076,3,148,74,0,1075,
  	1073,1,0,0,0,1075,1074,1,0,0,0,1076,145,1,0,0,0,1077,1078,3,526,263,0,
  	1078,1081,5,146,0,0,1079,1082,3,526,263,0,1080,1082,3,552,276,0,1081,
  	1079,1,0,0,0,1081,1080,1,0,0,0,1082,147,1,0,0,0,1083,1084,3,526,263,0,
  	1084,1087,3,588,294,0,1085,1088,3,526,263,0,1086,1088,3,522,261,0,1087,
  	1085,1,0,0,0,1087,1086,1,0,0,0,1088,149,1,0,0,0,1089,1090,5,148,0,0,1090,
  	1091,3,152,76,0,1091,1092,5,149,0,0,1092,151,1,0,0,0,1093,1098,3,154,
  	77,0,1094,1095,5,145,0,0,1095,1097,3,154,77,0,1096,1094,1,0,0,0,1097,
  	1100,1,0,0,0,1098,1096,1,0,0,0,1098,1099,1,0,0,0,1099,153,1,0,0,0,1100,
  	1098,1,0,0,0,1101,1102,3,522,261,0,1102,155,1,0,0,0,1103,1119,3,164,82,
  	0,1104,1119,3,172,86,0,1105,1119,3,180,90,0,1106,1119,3,206,103,0,1107,
  	1119,3,212,106,0,1108,1119,3,236,118,0,1109,1119,3,270,135,0,1110,1119,
  	3,280,140,0,1111,1119,3,290,145,0,1112,1119,3,312,156,0,1113,1119,3,318,
  	159,0,1114,1119,3,320,160,0,1115,1119,3,328,164,0,1116,1119,3,334,167,
  	0,1117,1119,3,344,172,0,1118,1103,1,0,0,0,1118,1104,1,0,0,0,1118,1105,
  	1,0,0,0,1118,1106,1,0,0,0,1118,1107,1,0,0,0,1118,1108,1,0,0,0,1118,1109,
  	1,0,0,0,1118,1110,1,0,0,0,1118,1111,1,0,0,0,1118,1112,1,0,0,0,1118,1113,
  	1,0,0,0,1118,1114,1,0,0,0,1118,1115,1,0,0,0,1118,1116,1,0,0,0,1118,1117,
  	1,0,0,0,1119,1121,1,0,0,0,1120,1122,5,147,0,0,1121,1120,1,0,0,0,1121,
  	1122,1,0,0,0,1122,157,1,0,0,0,1123,1125,3,156,78,0,1124,1123,1,0,0,0,
  	1125,1126,1,0,0,0,1126,1124,1,0,0,0,1126,1127,1,0,0,0,1127,159,1,0,0,
  	0,1128,1130,3,4,2,0,1129,1128,1,0,0,0,1129,1130,1,0,0,0,1130,161,1,0,
  	0,0,1131,1133,5,139,0,0,1132,1134,3,4,2,0,1133,1132,1,0,0,0,1133,1134,
  	1,0,0,0,1134,1135,1,0,0,0,1135,1136,5,142,0,0,1136,163,1,0,0,0,1137,1139,
  	3,394,197,0,1138,1137,1,0,0,0,1138,1139,1,0,0,0,1139,1140,1,0,0,0,1140,
  	1142,5,19,0,0,1141,1143,3,166,83,0,1142,1141,1,0,0,0,1142,1143,1,0,0,
  	0,1143,1144,1,0,0,0,1144,1145,3,168,84,0,1145,165,1,0,0,0,1146,1147,7,
  	7,0,0,1147,167,1,0,0,0,1148,1153,3,170,85,0,1149,1150,5,138,0,0,1150,
  	1152,3,170,85,0,1151,1149,1,0,0,0,1152,1155,1,0,0,0,1153,1151,1,0,0,0,
  	1153,1154,1,0,0,0,1154,169,1,0,0,0,1155,1153,1,0,0,0,1156,1159,3,566,
  	283,0,1157,1159,3,596,298,0,1158,1156,1,0,0,0,1158,1157,1,0,0,0,1159,
  	171,1,0,0,0,1160,1162,3,394,197,0,1161,1160,1,0,0,0,1161,1162,1,0,0,0,
  	1162,1164,1,0,0,0,1163,1165,3,362,181,0,1164,1163,1,0,0,0,1164,1165,1,
  	0,0,0,1165,1166,1,0,0,0,1166,1167,5,27,0,0,1167,1168,3,174,87,0,1168,
  	173,1,0,0,0,1169,1174,3,176,88,0,1170,1171,5,145,0,0,1171,1173,3,176,
  	88,0,1172,1170,1,0,0,0,1173,1176,1,0,0,0,1174,1172,1,0,0,0,1174,1175,
  	1,0,0,0,1175,175,1,0,0,0,1176,1174,1,0,0,0,1177,1179,3,368,184,0,1178,
  	1180,3,178,89,0,1179,1178,1,0,0,0,1179,1180,1,0,0,0,1180,177,1,0,0,0,
  	1181,1182,5,156,0,0,1182,1183,3,402,201,0,1183,179,1,0,0,0,1184,1201,
  	3,182,91,0,1185,1198,3,184,92,0,1186,1187,3,178,89,0,1187,1188,3,200,
  	100,0,1188,1199,1,0,0,0,1189,1196,3,524,262,0,1190,1192,3,178,89,0,1191,
  	1190,1,0,0,0,1191,1192,1,0,0,0,1192,1193,1,0,0,0,1193,1197,3,200,100,
  	0,1194,1197,3,186,93,0,1195,1197,3,194,97,0,1196,1191,1,0,0,0,1196,1194,
  	1,0,0,0,1196,1195,1,0,0,0,1197,1199,1,0,0,0,1198,1186,1,0,0,0,1198,1189,
  	1,0,0,0,1199,1202,1,0,0,0,1200,1202,3,174,87,0,1201,1185,1,0,0,0,1201,
  	1200,1,0,0,0,1202,181,1,0,0,0,1203,1205,3,394,197,0,1204,1203,1,0,0,0,
  	1204,1205,1,0,0,0,1205,1207,1,0,0,0,1206,1208,3,362,181,0,1207,1206,1,
  	0,0,0,1207,1208,1,0,0,0,1208,1209,1,0,0,0,1209,1210,5,28,0,0,1210,183,
  	1,0,0,0,1211,1212,3,566,283,0,1212,185,1,0,0,0,1213,1221,5,139,0,0,1214,
  	1216,3,188,94,0,1215,1217,3,190,95,0,1216,1215,1,0,0,0,1216,1217,1,0,
  	0,0,1217,1222,1,0,0,0,1218,1219,3,190,95,0,1219,1220,3,188,94,0,1220,
  	1222,1,0,0,0,1221,1214,1,0,0,0,1221,1218,1,0,0,0,1222,1223,1,0,0,0,1223,
  	1224,5,142,0,0,1224,1227,1,0,0,0,1225,1227,3,162,81,0,1226,1213,1,0,0,
  	0,1226,1225,1,0,0,0,1227,187,1,0,0,0,1228,1230,3,394,197,0,1229,1228,
  	1,0,0,0,1229,1230,1,0,0,0,1230,1232,1,0,0,0,1231,1233,3,366,183,0,1232,
  	1231,1,0,0,0,1232,1233,1,0,0,0,1233,1234,1,0,0,0,1234,1236,5,30,0,0,1235,
  	1237,3,162,81,0,1236,1235,1,0,0,0,1236,1237,1,0,0,0,1237,189,1,0,0,0,
  	1238,1240,3,394,197,0,1239,1238,1,0,0,0,1239,1240,1,0,0,0,1240,1242,1,
  	0,0,0,1241,1243,3,366,183,0,1242,1241,1,0,0,0,1242,1243,1,0,0,0,1243,
  	1244,1,0,0,0,1244,1246,5,31,0,0,1245,1247,3,192,96,0,1246,1245,1,0,0,
  	0,1246,1247,1,0,0,0,1247,1249,1,0,0,0,1248,1250,3,162,81,0,1249,1248,
  	1,0,0,0,1249,1250,1,0,0,0,1250,191,1,0,0,0,1251,1252,5,140,0,0,1252,1253,
  	3,566,283,0,1253,1254,5,143,0,0,1254,193,1,0,0,0,1255,1263,5,139,0,0,
  	1256,1258,3,196,98,0,1257,1259,3,198,99,0,1258,1257,1,0,0,0,1258,1259,
  	1,0,0,0,1259,1264,1,0,0,0,1260,1261,3,198,99,0,1261,1262,3,196,98,0,1262,
  	1264,1,0,0,0,1263,1256,1,0,0,0,1263,1260,1,0,0,0,1264,1265,1,0,0,0,1265,
  	1266,5,142,0,0,1266,195,1,0,0,0,1267,1269,3,394,197,0,1268,1267,1,0,0,
  	0,1268,1269,1,0,0,0,1269,1271,1,0,0,0,1270,1272,3,366,183,0,1271,1270,
  	1,0,0,0,1271,1272,1,0,0,0,1272,1273,1,0,0,0,1273,1274,5,30,0,0,1274,197,
  	1,0,0,0,1275,1277,3,394,197,0,1276,1275,1,0,0,0,1276,1277,1,0,0,0,1277,
  	1279,1,0,0,0,1278,1280,3,366,183,0,1279,1278,1,0,0,0,1279,1280,1,0,0,
  	0,1280,1281,1,0,0,0,1281,1282,5,31,0,0,1282,199,1,0,0,0,1283,1292,5,139,
  	0,0,1284,1286,3,202,101,0,1285,1287,3,204,102,0,1286,1285,1,0,0,0,1286,
  	1287,1,0,0,0,1287,1293,1,0,0,0,1288,1290,3,204,102,0,1289,1291,3,202,
  	101,0,1290,1289,1,0,0,0,1290,1291,1,0,0,0,1291,1293,1,0,0,0,1292,1284,
  	1,0,0,0,1292,1288,1,0,0,0,1293,1294,1,0,0,0,1294,1295,5,142,0,0,1295,
  	201,1,0,0,0,1296,1298,3,394,197,0,1297,1296,1,0,0,0,1297,1298,1,0,0,0,
  	1298,1299,1,0,0,0,1299,1301,5,32,0,0,1300,1302,3,192,96,0,1301,1300,1,
  	0,0,0,1301,1302,1,0,0,0,1302,1303,1,0,0,0,1303,1304,3,162,81,0,1304,203,
  	1,0,0,0,1305,1307,3,394,197,0,1306,1305,1,0,0,0,1306,1307,1,0,0,0,1307,
  	1308,1,0,0,0,1308,1310,5,33,0,0,1309,1311,3,192,96,0,1310,1309,1,0,0,
  	0,1310,1311,1,0,0,0,1311,1312,1,0,0,0,1312,1313,3,162,81,0,1313,205,1,
  	0,0,0,1314,1316,3,394,197,0,1315,1314,1,0,0,0,1315,1316,1,0,0,0,1316,
  	1318,1,0,0,0,1317,1319,3,364,182,0,1318,1317,1,0,0,0,1318,1319,1,0,0,
  	0,1319,1320,1,0,0,0,1320,1321,5,59,0,0,1321,1323,3,208,104,0,1322,1324,
  	3,134,67,0,1323,1322,1,0,0,0,1323,1324,1,0,0,0,1324,1325,1,0,0,0,1325,
  	1326,3,210,105,0,1326,207,1,0,0,0,1327,1328,3,566,283,0,1328,209,1,0,
  	0,0,1329,1330,5,156,0,0,1330,1331,3,522,261,0,1331,211,1,0,0,0,1332,1333,
  	3,214,107,0,1333,1335,3,216,108,0,1334,1336,3,134,67,0,1335,1334,1,0,
  	0,0,1335,1336,1,0,0,0,1336,1337,1,0,0,0,1337,1339,3,218,109,0,1338,1340,
  	3,140,70,0,1339,1338,1,0,0,0,1339,1340,1,0,0,0,1340,1342,1,0,0,0,1341,
  	1343,3,222,111,0,1342,1341,1,0,0,0,1342,1343,1,0,0,0,1343,213,1,0,0,0,
  	1344,1346,3,394,197,0,1345,1344,1,0,0,0,1345,1346,1,0,0,0,1346,1348,1,
  	0,0,0,1347,1349,3,362,181,0,1348,1347,1,0,0,0,1348,1349,1,0,0,0,1349,
  	1350,1,0,0,0,1350,1351,5,16,0,0,1351,215,1,0,0,0,1352,1355,3,566,283,
  	0,1353,1355,3,596,298,0,1354,1352,1,0,0,0,1354,1353,1,0,0,0,1355,217,
  	1,0,0,0,1356,1361,3,224,112,0,1357,1359,5,39,0,0,1358,1357,1,0,0,0,1358,
  	1359,1,0,0,0,1359,1362,1,0,0,0,1360,1362,5,40,0,0,1361,1358,1,0,0,0,1361,
  	1360,1,0,0,0,1362,1364,1,0,0,0,1363,1365,3,220,110,0,1364,1363,1,0,0,
  	0,1364,1365,1,0,0,0,1365,219,1,0,0,0,1366,1368,3,584,292,0,1367,1369,
  	3,394,197,0,1368,1367,1,0,0,0,1368,1369,1,0,0,0,1369,1370,1,0,0,0,1370,
  	1371,3,522,261,0,1371,221,1,0,0,0,1372,1373,3,162,81,0,1373,223,1,0,0,
  	0,1374,1376,5,140,0,0,1375,1377,3,226,113,0,1376,1375,1,0,0,0,1376,1377,
  	1,0,0,0,1377,1378,1,0,0,0,1378,1379,5,143,0,0,1379,225,1,0,0,0,1380,1385,
  	3,228,114,0,1381,1382,5,145,0,0,1382,1384,3,228,114,0,1383,1381,1,0,0,
  	0,1384,1387,1,0,0,0,1385,1383,1,0,0,0,1385,1386,1,0,0,0,1386,227,1,0,
  	0,0,1387,1385,1,0,0,0,1388,1390,3,394,197,0,1389,1388,1,0,0,0,1389,1390,
  	1,0,0,0,1390,1392,1,0,0,0,1391,1393,3,230,115,0,1392,1391,1,0,0,0,1392,
  	1393,1,0,0,0,1393,1394,1,0,0,0,1394,1395,3,232,116,0,1395,1400,3,524,
  	262,0,1396,1398,3,234,117,0,1397,1396,1,0,0,0,1397,1398,1,0,0,0,1398,
  	1401,1,0,0,0,1399,1401,3,586,293,0,1400,1397,1,0,0,0,1400,1399,1,0,0,
  	0,1401,229,1,0,0,0,1402,1403,3,566,283,0,1403,231,1,0,0,0,1404,1405,3,
  	566,283,0,1405,233,1,0,0,0,1406,1407,5,156,0,0,1407,1408,3,402,201,0,
  	1408,235,1,0,0,0,1409,1411,3,394,197,0,1410,1409,1,0,0,0,1410,1411,1,
  	0,0,0,1411,1413,1,0,0,0,1412,1414,3,364,182,0,1413,1412,1,0,0,0,1413,
  	1414,1,0,0,0,1414,1417,1,0,0,0,1415,1418,3,238,119,0,1416,1418,3,254,
  	127,0,1417,1415,1,0,0,0,1417,1416,1,0,0,0,1418,237,1,0,0,0,1419,1421,
  	5,41,0,0,1420,1419,1,0,0,0,1420,1421,1,0,0,0,1421,1422,1,0,0,0,1422,1423,
  	5,13,0,0,1423,1425,3,250,125,0,1424,1426,3,134,67,0,1425,1424,1,0,0,0,
  	1425,1426,1,0,0,0,1426,1428,1,0,0,0,1427,1429,3,562,281,0,1428,1427,1,
  	0,0,0,1428,1429,1,0,0,0,1429,1431,1,0,0,0,1430,1432,3,140,70,0,1431,1430,
  	1,0,0,0,1431,1432,1,0,0,0,1432,1433,1,0,0,0,1433,1435,5,139,0,0,1434,
  	1436,3,240,120,0,1435,1434,1,0,0,0,1435,1436,1,0,0,0,1436,1437,1,0,0,
  	0,1437,1438,5,142,0,0,1438,239,1,0,0,0,1439,1441,3,242,121,0,1440,1439,
  	1,0,0,0,1441,1442,1,0,0,0,1442,1440,1,0,0,0,1442,1443,1,0,0,0,1443,241,
  	1,0,0,0,1444,1448,3,156,78,0,1445,1448,3,244,122,0,1446,1448,3,86,43,
  	0,1447,1444,1,0,0,0,1447,1445,1,0,0,0,1447,1446,1,0,0,0,1448,243,1,0,
  	0,0,1449,1451,3,394,197,0,1450,1449,1,0,0,0,1450,1451,1,0,0,0,1451,1453,
  	1,0,0,0,1452,1454,5,41,0,0,1453,1452,1,0,0,0,1453,1454,1,0,0,0,1454,1455,
  	1,0,0,0,1455,1456,5,4,0,0,1456,1457,3,246,123,0,1457,245,1,0,0,0,1458,
  	1463,3,248,124,0,1459,1460,5,145,0,0,1460,1462,3,248,124,0,1461,1459,
  	1,0,0,0,1462,1465,1,0,0,0,1463,1461,1,0,0,0,1463,1464,1,0,0,0,1464,247,
  	1,0,0,0,1465,1463,1,0,0,0,1466,1476,3,556,278,0,1467,1473,3,252,126,0,
  	1468,1474,3,530,265,0,1469,1470,5,140,0,0,1470,1471,3,522,261,0,1471,
  	1472,5,143,0,0,1472,1474,1,0,0,0,1473,1468,1,0,0,0,1473,1469,1,0,0,0,
  	1473,1474,1,0,0,0,1474,1476,1,0,0,0,1475,1466,1,0,0,0,1475,1467,1,0,0,
  	0,1476,249,1,0,0,0,1477,1478,3,566,283,0,1478,251,1,0,0,0,1479,1480,3,
  	566,283,0,1480,253,1,0,0,0,1481,1482,5,13,0,0,1482,1484,3,250,125,0,1483,
  	1485,3,134,67,0,1484,1483,1,0,0,0,1484,1485,1,0,0,0,1485,1486,1,0,0,0,
  	1486,1488,3,562,281,0,1487,1489,3,140,70,0,1488,1487,1,0,0,0,1488,1489,
  	1,0,0,0,1489,1490,1,0,0,0,1490,1491,5,139,0,0,1491,1492,3,256,128,0,1492,
  	1493,5,142,0,0,1493,255,1,0,0,0,1494,1496,3,258,129,0,1495,1494,1,0,0,
  	0,1496,1497,1,0,0,0,1497,1495,1,0,0,0,1497,1498,1,0,0,0,1498,257,1,0,
  	0,0,1499,1503,3,156,78,0,1500,1503,3,260,130,0,1501,1503,3,86,43,0,1502,
  	1499,1,0,0,0,1502,1500,1,0,0,0,1502,1501,1,0,0,0,1503,259,1,0,0,0,1504,
  	1506,3,394,197,0,1505,1504,1,0,0,0,1505,1506,1,0,0,0,1506,1507,1,0,0,
  	0,1507,1508,5,4,0,0,1508,1509,3,262,131,0,1509,261,1,0,0,0,1510,1515,
  	3,264,132,0,1511,1512,5,145,0,0,1512,1514,3,264,132,0,1513,1511,1,0,0,
  	0,1514,1517,1,0,0,0,1515,1513,1,0,0,0,1515,1516,1,0,0,0,1516,263,1,0,
  	0,0,1517,1515,1,0,0,0,1518,1520,3,252,126,0,1519,1521,3,266,133,0,1520,
  	1519,1,0,0,0,1520,1521,1,0,0,0,1521,265,1,0,0,0,1522,1523,5,156,0,0,1523,
  	1524,3,268,134,0,1524,267,1,0,0,0,1525,1529,3,612,306,0,1526,1529,3,624,
  	312,0,1527,1529,3,614,307,0,1528,1525,1,0,0,0,1528,1526,1,0,0,0,1528,
  	1527,1,0,0,0,1529,269,1,0,0,0,1530,1532,3,394,197,0,1531,1530,1,0,0,0,
  	1531,1532,1,0,0,0,1532,1534,1,0,0,0,1533,1535,3,364,182,0,1534,1533,1,
  	0,0,0,1534,1535,1,0,0,0,1535,1536,1,0,0,0,1536,1537,5,36,0,0,1537,1539,
  	3,272,136,0,1538,1540,3,134,67,0,1539,1538,1,0,0,0,1539,1540,1,0,0,0,
  	1540,1542,1,0,0,0,1541,1543,3,562,281,0,1542,1541,1,0,0,0,1542,1543,1,
  	0,0,0,1543,1545,1,0,0,0,1544,1546,3,140,70,0,1545,1544,1,0,0,0,1545,1546,
  	1,0,0,0,1546,1547,1,0,0,0,1547,1548,3,274,137,0,1548,271,1,0,0,0,1549,
  	1550,3,566,283,0,1550,273,1,0,0,0,1551,1552,5,139,0,0,1552,1553,3,276,
  	138,0,1553,1554,5,142,0,0,1554,275,1,0,0,0,1555,1557,3,278,139,0,1556,
  	1555,1,0,0,0,1557,1560,1,0,0,0,1558,1556,1,0,0,0,1558,1559,1,0,0,0,1559,
  	277,1,0,0,0,1560,1558,1,0,0,0,1561,1564,3,156,78,0,1562,1564,3,86,43,
  	0,1563,1561,1,0,0,0,1563,1562,1,0,0,0,1564,279,1,0,0,0,1565,1567,3,394,
  	197,0,1566,1565,1,0,0,0,1566,1567,1,0,0,0,1567,1578,1,0,0,0,1568,1570,
  	3,364,182,0,1569,1568,1,0,0,0,1569,1570,1,0,0,0,1570,1572,1,0,0,0,1571,
  	1573,5,21,0,0,1572,1571,1,0,0,0,1572,1573,1,0,0,0,1573,1579,1,0,0,0,1574,
  	1576,5,21,0,0,1575,1577,3,364,182,0,1576,1575,1,0,0,0,1576,1577,1,0,0,
  	0,1577,1579,1,0,0,0,1578,1569,1,0,0,0,1578,1574,1,0,0,0,1579,1580,1,0,
  	0,0,1580,1581,5,6,0,0,1581,1583,3,282,141,0,1582,1584,3,134,67,0,1583,
  	1582,1,0,0,0,1583,1584,1,0,0,0,1584,1586,1,0,0,0,1585,1587,3,562,281,
  	0,1586,1585,1,0,0,0,1586,1587,1,0,0,0,1587,1589,1,0,0,0,1588,1590,3,140,
  	70,0,1589,1588,1,0,0,0,1589,1590,1,0,0,0,1590,1591,1,0,0,0,1591,1592,
  	3,284,142,0,1592,281,1,0,0,0,1593,1594,3,566,283,0,1594,283,1,0,0,0,1595,
  	1596,5,139,0,0,1596,1597,3,286,143,0,1597,1598,5,142,0,0,1598,285,1,0,
  	0,0,1599,1601,3,288,144,0,1600,1599,1,0,0,0,1601,1604,1,0,0,0,1602,1600,
  	1,0,0,0,1602,1603,1,0,0,0,1603,287,1,0,0,0,1604,1602,1,0,0,0,1605,1608,
  	3,156,78,0,1606,1608,3,86,43,0,1607,1605,1,0,0,0,1607,1606,1,0,0,0,1608,
  	289,1,0,0,0,1609,1611,3,394,197,0,1610,1609,1,0,0,0,1610,1611,1,0,0,0,
  	1611,1613,1,0,0,0,1612,1614,3,364,182,0,1613,1612,1,0,0,0,1613,1614,1,
  	0,0,0,1614,1615,1,0,0,0,1615,1616,5,29,0,0,1616,1620,3,292,146,0,1617,
  	1618,5,146,0,0,1618,1621,5,6,0,0,1619,1621,3,562,281,0,1620,1617,1,0,
  	0,0,1620,1619,1,0,0,0,1620,1621,1,0,0,0,1621,1623,1,0,0,0,1622,1624,3,
  	140,70,0,1623,1622,1,0,0,0,1623,1624,1,0,0,0,1624,1625,1,0,0,0,1625,1626,
  	3,294,147,0,1626,291,1,0,0,0,1627,1628,3,566,283,0,1628,293,1,0,0,0,1629,
  	1630,5,139,0,0,1630,1631,3,296,148,0,1631,1632,5,142,0,0,1632,295,1,0,
  	0,0,1633,1635,3,298,149,0,1634,1633,1,0,0,0,1635,1638,1,0,0,0,1636,1634,
  	1,0,0,0,1636,1637,1,0,0,0,1637,297,1,0,0,0,1638,1636,1,0,0,0,1639,1642,
  	3,300,150,0,1640,1642,3,86,43,0,1641,1639,1,0,0,0,1641,1640,1,0,0,0,1642,
  	299,1,0,0,0,1643,1650,3,302,151,0,1644,1650,3,304,152,0,1645,1650,3,306,
  	153,0,1646,1650,3,308,154,0,1647,1650,3,310,155,0,1648,1650,3,206,103,
  	0,1649,1643,1,0,0,0,1649,1644,1,0,0,0,1649,1645,1,0,0,0,1649,1646,1,0,
  	0,0,1649,1647,1,0,0,0,1649,1648,1,0,0,0,1650,301,1,0,0,0,1651,1652,3,
  	182,91,0,1652,1653,3,184,92,0,1653,1654,3,524,262,0,1654,1655,3,194,97,
  	0,1655,303,1,0,0,0,1656,1657,3,214,107,0,1657,1659,3,216,108,0,1658,1660,
  	3,134,67,0,1659,1658,1,0,0,0,1659,1660,1,0,0,0,1660,1661,1,0,0,0,1661,
  	1663,3,218,109,0,1662,1664,3,140,70,0,1663,1662,1,0,0,0,1663,1664,1,0,
  	0,0,1664,305,1,0,0,0,1665,1667,3,314,157,0,1666,1668,3,134,67,0,1667,
  	1666,1,0,0,0,1667,1668,1,0,0,0,1668,1669,1,0,0,0,1669,1674,3,224,112,
  	0,1670,1672,5,39,0,0,1671,1670,1,0,0,0,1671,1672,1,0,0,0,1672,1675,1,
  	0,0,0,1673,1675,5,40,0,0,1674,1671,1,0,0,0,1674,1673,1,0,0,0,1675,1677,
  	1,0,0,0,1676,1678,3,140,70,0,1677,1676,1,0,0,0,1677,1678,1,0,0,0,1678,
  	307,1,0,0,0,1679,1680,3,330,165,0,1680,1682,3,332,166,0,1681,1683,3,140,
  	70,0,1682,1681,1,0,0,0,1682,1683,1,0,0,0,1683,1684,1,0,0,0,1684,1685,
  	3,194,97,0,1685,309,1,0,0,0,1686,1688,3,394,197,0,1687,1686,1,0,0,0,1687,
  	1688,1,0,0,0,1688,1690,1,0,0,0,1689,1691,3,364,182,0,1690,1689,1,0,0,
  	0,1690,1691,1,0,0,0,1691,1692,1,0,0,0,1692,1693,5,44,0,0,1693,1695,3,
  	208,104,0,1694,1696,3,562,281,0,1695,1694,1,0,0,0,1695,1696,1,0,0,0,1696,
  	1698,1,0,0,0,1697,1699,3,210,105,0,1698,1697,1,0,0,0,1698,1699,1,0,0,
  	0,1699,1701,1,0,0,0,1700,1702,3,140,70,0,1701,1700,1,0,0,0,1701,1702,
  	1,0,0,0,1702,311,1,0,0,0,1703,1705,3,314,157,0,1704,1706,3,134,67,0,1705,
  	1704,1,0,0,0,1705,1706,1,0,0,0,1706,1707,1,0,0,0,1707,1709,3,224,112,
  	0,1708,1710,7,8,0,0,1709,1708,1,0,0,0,1709,1710,1,0,0,0,1710,1712,1,0,
  	0,0,1711,1713,3,140,70,0,1712,1711,1,0,0,0,1712,1713,1,0,0,0,1713,1714,
  	1,0,0,0,1714,1715,3,316,158,0,1715,313,1,0,0,0,1716,1718,3,394,197,0,
  	1717,1716,1,0,0,0,1717,1718,1,0,0,0,1718,1720,1,0,0,0,1719,1721,3,362,
  	181,0,1720,1719,1,0,0,0,1720,1721,1,0,0,0,1721,1722,1,0,0,0,1722,1724,
  	5,42,0,0,1723,1725,7,9,0,0,1724,1723,1,0,0,0,1724,1725,1,0,0,0,1725,315,
  	1,0,0,0,1726,1727,3,162,81,0,1727,317,1,0,0,0,1728,1730,3,394,197,0,1729,
  	1728,1,0,0,0,1729,1730,1,0,0,0,1730,1731,1,0,0,0,1731,1732,5,43,0,0,1732,
  	1733,3,162,81,0,1733,319,1,0,0,0,1734,1736,3,394,197,0,1735,1734,1,0,
  	0,0,1735,1736,1,0,0,0,1736,1738,1,0,0,0,1737,1739,3,364,182,0,1738,1737,
  	1,0,0,0,1738,1739,1,0,0,0,1739,1740,1,0,0,0,1740,1741,5,45,0,0,1741,1743,
  	3,526,263,0,1742,1744,3,562,281,0,1743,1742,1,0,0,0,1743,1744,1,0,0,0,
  	1744,1746,1,0,0,0,1745,1747,3,140,70,0,1746,1745,1,0,0,0,1746,1747,1,
  	0,0,0,1747,1748,1,0,0,0,1748,1749,3,322,161,0,1749,321,1,0,0,0,1750,1751,
  	5,139,0,0,1751,1752,3,324,162,0,1752,1753,5,142,0,0,1753,323,1,0,0,0,
  	1754,1756,3,326,163,0,1755,1754,1,0,0,0,1756,1759,1,0,0,0,1757,1755,1,
  	0,0,0,1757,1758,1,0,0,0,1758,325,1,0,0,0,1759,1757,1,0,0,0,1760,1763,
  	3,156,78,0,1761,1763,3,86,43,0,1762,1760,1,0,0,0,1762,1761,1,0,0,0,1763,
  	327,1,0,0,0,1764,1765,3,330,165,0,1765,1767,3,332,166,0,1766,1768,3,140,
  	70,0,1767,1766,1,0,0,0,1767,1768,1,0,0,0,1768,1772,1,0,0,0,1769,1773,
  	3,162,81,0,1770,1773,3,186,93,0,1771,1773,3,194,97,0,1772,1769,1,0,0,
  	0,1772,1770,1,0,0,0,1772,1771,1,0,0,0,1773,329,1,0,0,0,1774,1776,3,394,
  	197,0,1775,1774,1,0,0,0,1775,1776,1,0,0,0,1776,1778,1,0,0,0,1777,1779,
  	3,362,181,0,1778,1777,1,0,0,0,1778,1779,1,0,0,0,1779,1780,1,0,0,0,1780,
  	1782,5,46,0,0,1781,1783,3,134,67,0,1782,1781,1,0,0,0,1782,1783,1,0,0,
  	0,1783,1784,1,0,0,0,1784,1785,3,224,112,0,1785,331,1,0,0,0,1786,1788,
  	3,584,292,0,1787,1789,3,394,197,0,1788,1787,1,0,0,0,1788,1789,1,0,0,0,
  	1789,1790,1,0,0,0,1790,1791,3,522,261,0,1791,333,1,0,0,0,1792,1796,3,
  	336,168,0,1793,1796,3,338,169,0,1794,1796,3,340,170,0,1795,1792,1,0,0,
  	0,1795,1793,1,0,0,0,1795,1794,1,0,0,0,1796,335,1,0,0,0,1797,1798,5,47,
  	0,0,1798,1799,5,58,0,0,1799,1800,3,596,298,0,1800,337,1,0,0,0,1801,1802,
  	5,57,0,0,1802,1803,5,58,0,0,1803,1804,3,596,298,0,1804,339,1,0,0,0,1805,
  	1806,5,48,0,0,1806,1807,5,58,0,0,1807,1809,3,596,298,0,1808,1810,3,342,
  	171,0,1809,1808,1,0,0,0,1809,1810,1,0,0,0,1810,341,1,0,0,0,1811,1812,
  	5,146,0,0,1812,1813,3,358,179,0,1813,343,1,0,0,0,1814,1815,5,52,0,0,1815,
  	1816,3,358,179,0,1816,1818,5,139,0,0,1817,1819,3,346,173,0,1818,1817,
  	1,0,0,0,1818,1819,1,0,0,0,1819,1820,1,0,0,0,1820,1821,5,142,0,0,1821,
  	345,1,0,0,0,1822,1824,3,348,174,0,1823,1822,1,0,0,0,1824,1825,1,0,0,0,
  	1825,1823,1,0,0,0,1825,1826,1,0,0,0,1826,347,1,0,0,0,1827,1831,3,350,
  	175,0,1828,1831,3,352,176,0,1829,1831,3,354,177,0,1830,1827,1,0,0,0,1830,
  	1828,1,0,0,0,1830,1829,1,0,0,0,1831,349,1,0,0,0,1832,1833,7,10,0,0,1833,
  	1834,5,146,0,0,1834,1835,3,356,178,0,1835,351,1,0,0,0,1836,1837,5,55,
  	0,0,1837,1838,5,146,0,0,1838,1839,3,614,307,0,1839,353,1,0,0,0,1840,1841,
  	5,56,0,0,1841,1842,5,146,0,0,1842,1843,7,11,0,0,1843,355,1,0,0,0,1844,
  	1849,3,358,179,0,1845,1846,5,145,0,0,1846,1848,3,358,179,0,1847,1845,
  	1,0,0,0,1848,1851,1,0,0,0,1849,1847,1,0,0,0,1849,1850,1,0,0,0,1850,357,
  	1,0,0,0,1851,1849,1,0,0,0,1852,1857,3,566,283,0,1853,1854,5,138,0,0,1854,
  	1856,3,566,283,0,1855,1853,1,0,0,0,1856,1859,1,0,0,0,1857,1855,1,0,0,
  	0,1857,1858,1,0,0,0,1858,359,1,0,0,0,1859,1857,1,0,0,0,1860,1882,5,6,
  	0,0,1861,1882,5,66,0,0,1862,1882,5,67,0,0,1863,1882,5,21,0,0,1864,1882,
  	5,48,0,0,1865,1882,5,68,0,0,1866,1882,5,69,0,0,1867,1882,5,70,0,0,1868,
  	1882,5,57,0,0,1869,1882,5,47,0,0,1870,1882,5,71,0,0,1871,1882,5,72,0,
  	0,1872,1876,5,74,0,0,1873,1874,5,140,0,0,1874,1875,7,12,0,0,1875,1877,
  	5,143,0,0,1876,1873,1,0,0,0,1876,1877,1,0,0,0,1877,1882,1,0,0,0,1878,
  	1882,5,73,0,0,1879,1882,3,364,182,0,1880,1882,3,366,183,0,1881,1860,1,
  	0,0,0,1881,1861,1,0,0,0,1881,1862,1,0,0,0,1881,1863,1,0,0,0,1881,1864,
  	1,0,0,0,1881,1865,1,0,0,0,1881,1866,1,0,0,0,1881,1867,1,0,0,0,1881,1868,
  	1,0,0,0,1881,1869,1,0,0,0,1881,1870,1,0,0,0,1881,1871,1,0,0,0,1881,1872,
  	1,0,0,0,1881,1878,1,0,0,0,1881,1879,1,0,0,0,1881,1880,1,0,0,0,1882,361,
  	1,0,0,0,1883,1885,3,360,180,0,1884,1883,1,0,0,0,1885,1886,1,0,0,0,1886,
  	1884,1,0,0,0,1886,1887,1,0,0,0,1887,363,1,0,0,0,1888,1892,7,13,0,0,1889,
  	1890,5,140,0,0,1890,1891,5,31,0,0,1891,1893,5,143,0,0,1892,1889,1,0,0,
  	0,1892,1893,1,0,0,0,1893,365,1,0,0,0,1894,1895,7,14,0,0,1895,367,1,0,
  	0,0,1896,1900,6,184,-1,0,1897,1901,3,370,185,0,1898,1901,3,372,186,0,
  	1899,1901,3,376,188,0,1900,1897,1,0,0,0,1900,1898,1,0,0,0,1900,1899,1,
  	0,0,0,1901,1903,1,0,0,0,1902,1904,3,524,262,0,1903,1902,1,0,0,0,1903,
  	1904,1,0,0,0,1904,1912,1,0,0,0,1905,1912,3,374,187,0,1906,1912,3,382,
  	191,0,1907,1912,3,384,192,0,1908,1909,5,80,0,0,1909,1912,3,522,261,0,
  	1910,1912,3,386,193,0,1911,1896,1,0,0,0,1911,1905,1,0,0,0,1911,1906,1,
  	0,0,0,1911,1907,1,0,0,0,1911,1908,1,0,0,0,1911,1910,1,0,0,0,1912,1918,
  	1,0,0,0,1913,1914,10,2,0,0,1914,1915,5,1,0,0,1915,1917,3,522,261,0,1916,
  	1913,1,0,0,0,1917,1920,1,0,0,0,1918,1916,1,0,0,0,1918,1919,1,0,0,0,1919,
  	369,1,0,0,0,1920,1918,1,0,0,0,1921,1922,5,150,0,0,1922,371,1,0,0,0,1923,
  	1924,3,566,283,0,1924,373,1,0,0,0,1925,1926,5,28,0,0,1926,1930,3,368,
  	184,0,1927,1928,5,27,0,0,1928,1930,3,368,184,0,1929,1925,1,0,0,0,1929,
  	1927,1,0,0,0,1930,375,1,0,0,0,1931,1933,5,140,0,0,1932,1934,3,378,189,
  	0,1933,1932,1,0,0,0,1933,1934,1,0,0,0,1934,1935,1,0,0,0,1935,1936,5,143,
  	0,0,1936,377,1,0,0,0,1937,1942,3,380,190,0,1938,1939,5,145,0,0,1939,1941,
  	3,380,190,0,1940,1938,1,0,0,0,1941,1944,1,0,0,0,1942,1940,1,0,0,0,1942,
  	1943,1,0,0,0,1943,379,1,0,0,0,1944,1942,1,0,0,0,1945,1946,3,566,283,0,
  	1946,1947,5,146,0,0,1947,1949,1,0,0,0,1948,1945,1,0,0,0,1948,1949,1,0,
  	0,0,1949,1950,1,0,0,0,1950,1951,3,368,184,0,1951,381,1,0,0,0,1952,1954,
  	3,526,263,0,1953,1952,1,0,0,0,1953,1954,1,0,0,0,1954,1955,1,0,0,0,1955,
  	1956,5,138,0,0,1956,1958,3,252,126,0,1957,1959,3,376,188,0,1958,1957,
  	1,0,0,0,1958,1959,1,0,0,0,1959,383,1,0,0,0,1960,1961,3,372,186,0,1961,
  	1962,5,152,0,0,1962,385,1,0,0,0,1963,1964,3,402,201,0,1964,387,1,0,0,
  	0,1965,1966,5,153,0,0,1966,1968,3,390,195,0,1967,1969,3,392,196,0,1968,
  	1967,1,0,0,0,1968,1969,1,0,0,0,1969,389,1,0,0,0,1970,1975,3,566,283,0,
  	1971,1972,5,138,0,0,1972,1974,3,566,283,0,1973,1971,1,0,0,0,1974,1977,
  	1,0,0,0,1975,1973,1,0,0,0,1975,1976,1,0,0,0,1976,391,1,0,0,0,1977,1975,
  	1,0,0,0,1978,1980,5,140,0,0,1979,1981,3,396,198,0,1980,1979,1,0,0,0,1980,
  	1981,1,0,0,0,1981,1982,1,0,0,0,1982,1983,5,143,0,0,1983,393,1,0,0,0,1984,
  	1986,3,388,194,0,1985,1984,1,0,0,0,1986,1987,1,0,0,0,1987,1985,1,0,0,
  	0,1987,1988,1,0,0,0,1988,395,1,0,0,0,1989,1991,3,398,199,0,1990,1989,
  	1,0,0,0,1991,1992,1,0,0,0,1992,1990,1,0,0,0,1992,1993,1,0,0,0,1993,397,
  	1,0,0,0,1994,1996,5,140,0,0,1995,1997,3,396,198,0,1996,1995,1,0,0,0,1996,
  	1997,1,0,0,0,1997,1998,1,0,0,0,1998,2015,5,143,0,0,1999,2001,5,141,0,
  	0,2000,2002,3,396,198,0,2001,2000,1,0,0,0,2001,2002,1,0,0,0,2002,2003,
  	1,0,0,0,2003,2015,5,144,0,0,2004,2006,5,139,0,0,2005,2007,3,396,198,0,
  	2006,2005,1,0,0,0,2006,2007,1,0,0,0,2007,2008,1,0,0,0,2008,2015,5,142,
  	0,0,2009,2015,3,566,283,0,2010,2015,3,570,285,0,2011,2015,3,610,305,0,
  	2012,2015,3,596,298,0,2013,2015,3,400,200,0,2014,1994,1,0,0,0,2014,1999,
  	1,0,0,0,2014,2004,1,0,0,0,2014,2009,1,0,0,0,2014,2010,1,0,0,0,2014,2011,
  	1,0,0,0,2014,2012,1,0,0,0,2014,2013,1,0,0,0,2015,399,1,0,0,0,2016,2023,
  	7,15,0,0,2017,2023,3,584,292,0,2018,2019,4,200,3,0,2019,2023,5,154,0,
  	0,2020,2021,4,200,4,0,2021,2023,5,151,0,0,2022,2016,1,0,0,0,2022,2017,
  	1,0,0,0,2022,2018,1,0,0,0,2022,2020,1,0,0,0,2023,401,1,0,0,0,2024,2026,
  	3,410,205,0,2025,2024,1,0,0,0,2025,2026,1,0,0,0,2026,2027,1,0,0,0,2027,
  	2029,3,406,203,0,2028,2030,3,414,207,0,2029,2028,1,0,0,0,2029,2030,1,
  	0,0,0,2030,403,1,0,0,0,2031,2036,3,402,201,0,2032,2033,5,145,0,0,2033,
  	2035,3,402,201,0,2034,2032,1,0,0,0,2035,2038,1,0,0,0,2036,2034,1,0,0,
  	0,2036,2037,1,0,0,0,2037,405,1,0,0,0,2038,2036,1,0,0,0,2039,2041,3,592,
  	296,0,2040,2039,1,0,0,0,2040,2041,1,0,0,0,2041,2042,1,0,0,0,2042,2045,
  	3,490,245,0,2043,2045,3,408,204,0,2044,2040,1,0,0,0,2044,2043,1,0,0,0,
  	2045,407,1,0,0,0,2046,2047,5,154,0,0,2047,2048,3,566,283,0,2048,409,1,
  	0,0,0,2049,2051,5,81,0,0,2050,2052,7,9,0,0,2051,2050,1,0,0,0,2051,2052,
  	1,0,0,0,2052,411,1,0,0,0,2053,2054,3,590,295,0,2054,2055,3,406,203,0,
  	2055,2067,1,0,0,0,2056,2059,3,572,286,0,2057,2059,3,416,208,0,2058,2056,
  	1,0,0,0,2058,2057,1,0,0,0,2059,2061,1,0,0,0,2060,2062,3,410,205,0,2061,
  	2060,1,0,0,0,2061,2062,1,0,0,0,2062,2063,1,0,0,0,2063,2064,3,406,203,
  	0,2064,2067,1,0,0,0,2065,2067,3,418,209,0,2066,2053,1,0,0,0,2066,2058,
  	1,0,0,0,2066,2065,1,0,0,0,2067,413,1,0,0,0,2068,2070,3,412,206,0,2069,
  	2068,1,0,0,0,2070,2071,1,0,0,0,2071,2069,1,0,0,0,2071,2072,1,0,0,0,2072,
  	415,1,0,0,0,2073,2074,5,152,0,0,2074,2075,3,402,201,0,2075,2076,5,146,
  	0,0,2076,417,1,0,0,0,2077,2083,5,80,0,0,2078,2080,5,1,0,0,2079,2081,7,
  	9,0,0,2080,2079,1,0,0,0,2080,2081,1,0,0,0,2081,2083,1,0,0,0,2082,2077,
  	1,0,0,0,2082,2078,1,0,0,0,2083,2084,1,0,0,0,2084,2085,3,522,261,0,2085,
  	419,1,0,0,0,2086,2088,3,422,211,0,2087,2089,3,150,75,0,2088,2087,1,0,
  	0,0,2088,2089,1,0,0,0,2089,2105,1,0,0,0,2090,2105,3,548,274,0,2091,2105,
  	3,550,275,0,2092,2105,3,424,212,0,2093,2105,3,440,220,0,2094,2105,3,442,
  	221,0,2095,2105,3,444,222,0,2096,2105,3,464,232,0,2097,2105,3,466,233,
  	0,2098,2105,3,468,234,0,2099,2105,3,462,231,0,2100,2105,3,474,237,0,2101,
  	2105,3,476,238,0,2102,2105,3,486,243,0,2103,2105,3,488,244,0,2104,2086,
  	1,0,0,0,2104,2090,1,0,0,0,2104,2091,1,0,0,0,2104,2092,1,0,0,0,2104,2093,
  	1,0,0,0,2104,2094,1,0,0,0,2104,2095,1,0,0,0,2104,2096,1,0,0,0,2104,2097,
  	1,0,0,0,2104,2098,1,0,0,0,2104,2099,1,0,0,0,2104,2100,1,0,0,0,2104,2101,
  	1,0,0,0,2104,2102,1,0,0,0,2104,2103,1,0,0,0,2105,421,1,0,0,0,2106,2111,
  	3,566,283,0,2107,2108,5,140,0,0,2108,2109,3,518,259,0,2109,2110,5,143,
  	0,0,2110,2112,1,0,0,0,2111,2107,1,0,0,0,2111,2112,1,0,0,0,2112,423,1,
  	0,0,0,2113,2125,3,610,305,0,2114,2125,3,426,213,0,2115,2125,3,432,216,
  	0,2116,2125,3,438,219,0,2117,2125,5,123,0,0,2118,2125,5,124,0,0,2119,
  	2125,5,125,0,0,2120,2125,5,126,0,0,2121,2125,5,127,0,0,2122,2125,5,128,
  	0,0,2123,2125,5,129,0,0,2124,2113,1,0,0,0,2124,2114,1,0,0,0,2124,2115,
  	1,0,0,0,2124,2116,1,0,0,0,2124,2117,1,0,0,0,2124,2118,1,0,0,0,2124,2119,
  	1,0,0,0,2124,2120,1,0,0,0,2124,2121,1,0,0,0,2124,2122,1,0,0,0,2124,2123,
  	1,0,0,0,2125,425,1,0,0,0,2126,2128,5,141,0,0,2127,2129,3,428,214,0,2128,
  	2127,1,0,0,0,2128,2129,1,0,0,0,2129,2130,1,0,0,0,2130,2131,5,144,0,0,
  	2131,427,1,0,0,0,2132,2137,3,430,215,0,2133,2134,5,145,0,0,2134,2136,
  	3,430,215,0,2135,2133,1,0,0,0,2136,2139,1,0,0,0,2137,2135,1,0,0,0,2137,
  	2138,1,0,0,0,2138,2141,1,0,0,0,2139,2137,1,0,0,0,2140,2142,5,145,0,0,
  	2141,2140,1,0,0,0,2141,2142,1,0,0,0,2142,429,1,0,0,0,2143,2144,3,402,
  	201,0,2144,431,1,0,0,0,2145,2148,5,141,0,0,2146,2149,3,434,217,0,2147,
  	2149,5,146,0,0,2148,2146,1,0,0,0,2148,2147,1,0,0,0,2149,2150,1,0,0,0,
  	2150,2151,5,144,0,0,2151,433,1,0,0,0,2152,2157,3,436,218,0,2153,2154,
  	5,145,0,0,2154,2156,3,436,218,0,2155,2153,1,0,0,0,2156,2159,1,0,0,0,2157,
  	2155,1,0,0,0,2157,2158,1,0,0,0,2158,2161,1,0,0,0,2159,2157,1,0,0,0,2160,
  	2162,5,145,0,0,2161,2160,1,0,0,0,2161,2162,1,0,0,0,2162,435,1,0,0,0,2163,
  	2164,3,402,201,0,2164,2165,5,146,0,0,2165,2166,3,402,201,0,2166,437,1,
  	0,0,0,2167,2168,5,132,0,0,2168,2169,5,140,0,0,2169,2170,5,85,0,0,2170,
  	2171,5,146,0,0,2171,2172,3,402,201,0,2172,2173,5,145,0,0,2173,2174,5,
  	87,0,0,2174,2175,5,146,0,0,2175,2176,3,402,201,0,2176,2177,5,145,0,0,
  	2177,2178,5,86,0,0,2178,2179,5,146,0,0,2179,2180,3,402,201,0,2180,2181,
  	5,145,0,0,2181,2182,5,2,0,0,2182,2183,5,146,0,0,2183,2184,3,402,201,0,
  	2184,2185,5,143,0,0,2185,2201,1,0,0,0,2186,2187,5,133,0,0,2187,2188,5,
  	140,0,0,2188,2189,5,88,0,0,2189,2190,5,146,0,0,2190,2191,3,402,201,0,
  	2191,2192,5,143,0,0,2192,2201,1,0,0,0,2193,2194,5,134,0,0,2194,2195,5,
  	140,0,0,2195,2196,5,88,0,0,2196,2197,5,146,0,0,2197,2198,3,402,201,0,
  	2198,2199,5,143,0,0,2199,2201,1,0,0,0,2200,2167,1,0,0,0,2200,2186,1,0,
  	0,0,2200,2193,1,0,0,0,2201,439,1,0,0,0,2202,2215,5,95,0,0,2203,2204,5,
  	95,0,0,2204,2205,5,138,0,0,2205,2215,3,566,283,0,2206,2207,5,95,0,0,2207,
  	2208,5,141,0,0,2208,2209,3,508,254,0,2209,2210,5,144,0,0,2210,2215,1,
  	0,0,0,2211,2212,5,95,0,0,2212,2213,5,138,0,0,2213,2215,5,42,0,0,2214,
  	2202,1,0,0,0,2214,2203,1,0,0,0,2214,2206,1,0,0,0,2214,2211,1,0,0,0,2215,
  	441,1,0,0,0,2216,2217,5,82,0,0,2217,2218,5,138,0,0,2218,2228,3,566,283,
  	0,2219,2220,5,82,0,0,2220,2221,5,141,0,0,2221,2222,3,508,254,0,2222,2223,
  	5,144,0,0,2223,2228,1,0,0,0,2224,2225,5,82,0,0,2225,2226,5,138,0,0,2226,
  	2228,5,42,0,0,2227,2216,1,0,0,0,2227,2219,1,0,0,0,2227,2224,1,0,0,0,2228,
  	443,1,0,0,0,2229,2231,5,139,0,0,2230,2232,3,446,223,0,2231,2230,1,0,0,
  	0,2231,2232,1,0,0,0,2232,2234,1,0,0,0,2233,2235,3,4,2,0,2234,2233,1,0,
  	0,0,2234,2235,1,0,0,0,2235,2236,1,0,0,0,2236,2237,5,142,0,0,2237,445,
  	1,0,0,0,2238,2240,3,454,227,0,2239,2238,1,0,0,0,2239,2240,1,0,0,0,2240,
  	2241,1,0,0,0,2241,2243,3,448,224,0,2242,2244,5,39,0,0,2243,2242,1,0,0,
  	0,2243,2244,1,0,0,0,2244,2246,1,0,0,0,2245,2247,3,220,110,0,2246,2245,
  	1,0,0,0,2246,2247,1,0,0,0,2247,2248,1,0,0,0,2248,2249,5,17,0,0,2249,2254,
  	1,0,0,0,2250,2251,3,454,227,0,2251,2252,5,17,0,0,2252,2254,1,0,0,0,2253,
  	2239,1,0,0,0,2253,2250,1,0,0,0,2254,447,1,0,0,0,2255,2257,5,140,0,0,2256,
  	2258,3,450,225,0,2257,2256,1,0,0,0,2257,2258,1,0,0,0,2258,2259,1,0,0,
  	0,2259,2262,5,143,0,0,2260,2262,3,568,284,0,2261,2255,1,0,0,0,2261,2260,
  	1,0,0,0,2262,449,1,0,0,0,2263,2268,3,452,226,0,2264,2265,5,145,0,0,2265,
  	2267,3,452,226,0,2266,2264,1,0,0,0,2267,2270,1,0,0,0,2268,2266,1,0,0,
  	0,2268,2269,1,0,0,0,2269,451,1,0,0,0,2270,2268,1,0,0,0,2271,2276,3,566,
  	283,0,2272,2274,3,524,262,0,2273,2275,3,586,293,0,2274,2273,1,0,0,0,2274,
  	2275,1,0,0,0,2275,2277,1,0,0,0,2276,2272,1,0,0,0,2276,2277,1,0,0,0,2277,
  	453,1,0,0,0,2278,2279,5,141,0,0,2279,2280,3,456,228,0,2280,2281,5,144,
  	0,0,2281,455,1,0,0,0,2282,2287,3,458,229,0,2283,2284,5,145,0,0,2284,2286,
  	3,458,229,0,2285,2283,1,0,0,0,2286,2289,1,0,0,0,2287,2285,1,0,0,0,2287,
  	2288,1,0,0,0,2288,457,1,0,0,0,2289,2287,1,0,0,0,2290,2292,3,460,230,0,
  	2291,2290,1,0,0,0,2291,2292,1,0,0,0,2292,2300,1,0,0,0,2293,2295,3,566,
  	283,0,2294,2296,5,156,0,0,2295,2294,1,0,0,0,2295,2296,1,0,0,0,2296,2297,
  	1,0,0,0,2297,2298,3,402,201,0,2298,2301,1,0,0,0,2299,2301,3,440,220,0,
  	2300,2293,1,0,0,0,2300,2299,1,0,0,0,2301,459,1,0,0,0,2302,2310,5,73,0,
  	0,2303,2307,5,74,0,0,2304,2305,5,140,0,0,2305,2306,7,12,0,0,2306,2308,
  	5,143,0,0,2307,2304,1,0,0,0,2307,2308,1,0,0,0,2308,2310,1,0,0,0,2309,
  	2302,1,0,0,0,2309,2303,1,0,0,0,2310,461,1,0,0,0,2311,2314,5,138,0,0,2312,
  	2315,3,566,283,0,2313,2315,3,570,285,0,2314,2312,1,0,0,0,2314,2313,1,
  	0,0,0,2315,2318,1,0,0,0,2316,2317,5,138,0,0,2317,2319,3,490,245,0,2318,
  	2316,1,0,0,0,2318,2319,1,0,0,0,2319,463,1,0,0,0,2320,2321,5,140,0,0,2321,
  	2322,3,596,298,0,2322,2323,5,143,0,0,2323,465,1,0,0,0,2324,2325,5,140,
  	0,0,2325,2326,3,402,201,0,2326,2327,5,143,0,0,2327,467,1,0,0,0,2328,2329,
  	5,140,0,0,2329,2337,5,143,0,0,2330,2331,5,140,0,0,2331,2332,3,472,236,
  	0,2332,2333,5,145,0,0,2333,2334,3,470,235,0,2334,2335,5,143,0,0,2335,
  	2337,1,0,0,0,2336,2328,1,0,0,0,2336,2330,1,0,0,0,2337,469,1,0,0,0,2338,
  	2343,3,472,236,0,2339,2340,5,145,0,0,2340,2342,3,472,236,0,2341,2339,
  	1,0,0,0,2342,2345,1,0,0,0,2343,2341,1,0,0,0,2343,2344,1,0,0,0,2344,471,
  	1,0,0,0,2345,2343,1,0,0,0,2346,2347,3,566,283,0,2347,2348,5,146,0,0,2348,
  	2350,1,0,0,0,2349,2346,1,0,0,0,2349,2350,1,0,0,0,2350,2351,1,0,0,0,2351,
  	2352,3,402,201,0,2352,473,1,0,0,0,2353,2354,5,150,0,0,2354,475,1,0,0,
  	0,2355,2357,5,167,0,0,2356,2358,3,522,261,0,2357,2356,1,0,0,0,2357,2358,
  	1,0,0,0,2358,2359,1,0,0,0,2359,2360,5,138,0,0,2360,2361,3,478,239,0,2361,
  	477,1,0,0,0,2362,2367,3,480,240,0,2363,2364,5,138,0,0,2364,2366,3,480,
  	240,0,2365,2363,1,0,0,0,2366,2369,1,0,0,0,2367,2365,1,0,0,0,2367,2368,
  	1,0,0,0,2368,479,1,0,0,0,2369,2367,1,0,0,0,2370,2372,3,566,283,0,2371,
  	2373,3,482,241,0,2372,2371,1,0,0,0,2372,2373,1,0,0,0,2373,2376,1,0,0,
  	0,2374,2376,3,482,241,0,2375,2370,1,0,0,0,2375,2374,1,0,0,0,2376,481,
  	1,0,0,0,2377,2379,3,484,242,0,2378,2377,1,0,0,0,2379,2380,1,0,0,0,2380,
  	2378,1,0,0,0,2380,2381,1,0,0,0,2381,483,1,0,0,0,2382,2390,5,152,0,0,2383,
  	2390,5,151,0,0,2384,2390,5,95,0,0,2385,2386,5,141,0,0,2386,2387,3,508,
  	254,0,2387,2388,5,144,0,0,2388,2390,1,0,0,0,2389,2382,1,0,0,0,2389,2383,
  	1,0,0,0,2389,2384,1,0,0,0,2389,2385,1,0,0,0,2390,485,1,0,0,0,2391,2392,
  	5,130,0,0,2392,2395,5,140,0,0,2393,2394,7,16,0,0,2394,2396,5,146,0,0,
  	2395,2393,1,0,0,0,2395,2396,1,0,0,0,2396,2397,1,0,0,0,2397,2398,3,402,
  	201,0,2398,2399,5,143,0,0,2399,487,1,0,0,0,2400,2401,5,131,0,0,2401,2402,
  	5,140,0,0,2402,2403,3,402,201,0,2403,2404,5,143,0,0,2404,489,1,0,0,0,
  	2405,2415,3,420,210,0,2406,2414,3,492,246,0,2407,2414,3,494,247,0,2408,
  	2414,3,496,248,0,2409,2414,3,498,249,0,2410,2414,3,500,250,0,2411,2414,
  	3,502,251,0,2412,2414,3,504,252,0,2413,2406,1,0,0,0,2413,2407,1,0,0,0,
  	2413,2408,1,0,0,0,2413,2409,1,0,0,0,2413,2410,1,0,0,0,2413,2411,1,0,0,
  	0,2413,2412,1,0,0,0,2414,2417,1,0,0,0,2415,2413,1,0,0,0,2415,2416,1,0,
  	0,0,2416,2421,1,0,0,0,2417,2415,1,0,0,0,2418,2420,3,594,297,0,2419,2418,
  	1,0,0,0,2420,2423,1,0,0,0,2421,2422,1,0,0,0,2421,2419,1,0,0,0,2422,491,
  	1,0,0,0,2423,2421,1,0,0,0,2424,2426,3,506,253,0,2425,2424,1,0,0,0,2425,
  	2426,1,0,0,0,2426,2427,1,0,0,0,2427,2430,3,512,256,0,2428,2430,3,506,
  	253,0,2429,2425,1,0,0,0,2429,2428,1,0,0,0,2430,493,1,0,0,0,2431,2432,
  	5,138,0,0,2432,2437,5,42,0,0,2433,2434,5,140,0,0,2434,2435,3,518,259,
  	0,2435,2436,5,143,0,0,2436,2438,1,0,0,0,2437,2433,1,0,0,0,2437,2438,1,
  	0,0,0,2438,495,1,0,0,0,2439,2449,5,138,0,0,2440,2450,5,172,0,0,2441,2447,
  	3,566,283,0,2442,2448,3,150,75,0,2443,2444,5,140,0,0,2444,2445,3,518,
  	259,0,2445,2446,5,143,0,0,2446,2448,1,0,0,0,2447,2442,1,0,0,0,2447,2443,
  	1,0,0,0,2447,2448,1,0,0,0,2448,2450,1,0,0,0,2449,2440,1,0,0,0,2449,2441,
  	1,0,0,0,2450,497,1,0,0,0,2451,2452,5,138,0,0,2452,2453,5,95,0,0,2453,
  	499,1,0,0,0,2454,2455,5,141,0,0,2455,2456,3,508,254,0,2456,2457,5,144,
  	0,0,2457,501,1,0,0,0,2458,2459,4,251,5,0,2459,2460,5,151,0,0,2460,503,
  	1,0,0,0,2461,2462,4,252,6,0,2462,2463,5,152,0,0,2463,505,1,0,0,0,2464,
  	2466,5,140,0,0,2465,2467,3,508,254,0,2466,2465,1,0,0,0,2466,2467,1,0,
  	0,0,2467,2468,1,0,0,0,2468,2469,5,143,0,0,2469,507,1,0,0,0,2470,2475,
  	3,510,255,0,2471,2472,5,145,0,0,2472,2474,3,510,255,0,2473,2471,1,0,0,
  	0,2474,2477,1,0,0,0,2475,2473,1,0,0,0,2475,2476,1,0,0,0,2476,509,1,0,
  	0,0,2477,2475,1,0,0,0,2478,2480,3,520,260,0,2479,2478,1,0,0,0,2479,2480,
  	1,0,0,0,2480,2484,1,0,0,0,2481,2485,3,566,283,0,2482,2485,3,402,201,0,
  	2483,2485,3,596,298,0,2484,2481,1,0,0,0,2484,2482,1,0,0,0,2484,2483,1,
  	0,0,0,2485,511,1,0,0,0,2486,2488,3,444,222,0,2487,2489,3,514,257,0,2488,
  	2487,1,0,0,0,2488,2489,1,0,0,0,2489,513,1,0,0,0,2490,2492,3,516,258,0,
  	2491,2490,1,0,0,0,2492,2493,1,0,0,0,2493,2491,1,0,0,0,2493,2494,1,0,0,
  	0,2494,515,1,0,0,0,2495,2496,3,566,283,0,2496,2497,5,146,0,0,2497,2498,
  	3,444,222,0,2498,517,1,0,0,0,2499,2501,3,520,260,0,2500,2499,1,0,0,0,
  	2501,2502,1,0,0,0,2502,2500,1,0,0,0,2502,2503,1,0,0,0,2503,519,1,0,0,
  	0,2504,2505,3,566,283,0,2505,2506,5,146,0,0,2506,521,1,0,0,0,2507,2508,
  	6,261,-1,0,2508,2522,3,538,269,0,2509,2522,3,548,274,0,2510,2522,3,550,
  	275,0,2511,2522,3,552,276,0,2512,2522,3,526,263,0,2513,2522,3,530,265,
  	0,2514,2522,3,556,278,0,2515,2522,3,558,279,0,2516,2522,3,560,280,0,2517,
  	2518,5,140,0,0,2518,2519,3,522,261,0,2519,2520,5,143,0,0,2520,2522,1,
  	0,0,0,2521,2507,1,0,0,0,2521,2509,1,0,0,0,2521,2510,1,0,0,0,2521,2511,
  	1,0,0,0,2521,2512,1,0,0,0,2521,2513,1,0,0,0,2521,2514,1,0,0,0,2521,2515,
  	1,0,0,0,2521,2516,1,0,0,0,2521,2517,1,0,0,0,2522,2536,1,0,0,0,2523,2532,
  	10,4,0,0,2524,2525,4,261,8,0,2525,2533,5,152,0,0,2526,2527,4,261,9,0,
  	2527,2533,5,151,0,0,2528,2529,5,138,0,0,2529,2533,5,93,0,0,2530,2531,
  	5,138,0,0,2531,2533,5,29,0,0,2532,2524,1,0,0,0,2532,2526,1,0,0,0,2532,
  	2528,1,0,0,0,2532,2530,1,0,0,0,2533,2535,1,0,0,0,2534,2523,1,0,0,0,2535,
  	2538,1,0,0,0,2536,2534,1,0,0,0,2536,2537,1,0,0,0,2537,523,1,0,0,0,2538,
  	2536,1,0,0,0,2539,2541,5,146,0,0,2540,2542,3,394,197,0,2541,2540,1,0,
  	0,0,2541,2542,1,0,0,0,2542,2544,1,0,0,0,2543,2545,5,91,0,0,2544,2543,
  	1,0,0,0,2544,2545,1,0,0,0,2545,2546,1,0,0,0,2546,2547,3,522,261,0,2547,
  	525,1,0,0,0,2548,2550,3,528,264,0,2549,2551,3,150,75,0,2550,2549,1,0,
  	0,0,2550,2551,1,0,0,0,2551,2554,1,0,0,0,2552,2553,5,138,0,0,2553,2555,
  	3,526,263,0,2554,2552,1,0,0,0,2554,2555,1,0,0,0,2555,527,1,0,0,0,2556,
  	2557,3,566,283,0,2557,529,1,0,0,0,2558,2560,5,140,0,0,2559,2561,3,532,
  	266,0,2560,2559,1,0,0,0,2560,2561,1,0,0,0,2561,2562,1,0,0,0,2562,2563,
  	5,143,0,0,2563,531,1,0,0,0,2564,2569,3,534,267,0,2565,2566,5,145,0,0,
  	2566,2568,3,534,267,0,2567,2565,1,0,0,0,2568,2571,1,0,0,0,2569,2567,1,
  	0,0,0,2569,2570,1,0,0,0,2570,533,1,0,0,0,2571,2569,1,0,0,0,2572,2573,
  	3,536,268,0,2573,2574,3,524,262,0,2574,2577,1,0,0,0,2575,2577,3,522,261,
  	0,2576,2572,1,0,0,0,2576,2575,1,0,0,0,2577,2580,1,0,0,0,2578,2579,5,156,
  	0,0,2579,2581,3,402,201,0,2580,2578,1,0,0,0,2580,2581,1,0,0,0,2581,535,
  	1,0,0,0,2582,2584,3,566,283,0,2583,2582,1,0,0,0,2584,2585,1,0,0,0,2585,
  	2583,1,0,0,0,2585,2586,1,0,0,0,2586,537,1,0,0,0,2587,2589,3,394,197,0,
  	2588,2587,1,0,0,0,2588,2589,1,0,0,0,2589,2590,1,0,0,0,2590,2592,3,540,
  	270,0,2591,2593,5,39,0,0,2592,2591,1,0,0,0,2592,2593,1,0,0,0,2593,2594,
  	1,0,0,0,2594,2595,3,584,292,0,2595,2596,3,522,261,0,2596,539,1,0,0,0,
  	2597,2602,5,140,0,0,2598,2600,3,542,271,0,2599,2601,3,586,293,0,2600,
  	2599,1,0,0,0,2600,2601,1,0,0,0,2601,2603,1,0,0,0,2602,2598,1,0,0,0,2602,
  	2603,1,0,0,0,2603,2604,1,0,0,0,2604,2605,5,143,0,0,2605,541,1,0,0,0,2606,
  	2611,3,544,272,0,2607,2608,5,145,0,0,2608,2610,3,544,272,0,2609,2607,
  	1,0,0,0,2610,2613,1,0,0,0,2611,2609,1,0,0,0,2611,2612,1,0,0,0,2612,543,
  	1,0,0,0,2613,2611,1,0,0,0,2614,2616,3,394,197,0,2615,2614,1,0,0,0,2615,
  	2616,1,0,0,0,2616,2618,1,0,0,0,2617,2619,5,91,0,0,2618,2617,1,0,0,0,2618,
  	2619,1,0,0,0,2619,2620,1,0,0,0,2620,2625,3,522,261,0,2621,2622,3,546,
  	273,0,2622,2623,3,524,262,0,2623,2625,1,0,0,0,2624,2615,1,0,0,0,2624,
  	2621,1,0,0,0,2625,545,1,0,0,0,2626,2628,3,566,283,0,2627,2626,1,0,0,0,
  	2628,2629,1,0,0,0,2629,2627,1,0,0,0,2629,2630,1,0,0,0,2630,547,1,0,0,
  	0,2631,2632,5,141,0,0,2632,2633,3,522,261,0,2633,2634,5,144,0,0,2634,
  	549,1,0,0,0,2635,2636,5,141,0,0,2636,2637,3,522,261,0,2637,2638,5,146,
  	0,0,2638,2639,3,522,261,0,2639,2640,5,144,0,0,2640,551,1,0,0,0,2641,2646,
  	3,526,263,0,2642,2643,5,154,0,0,2643,2645,3,526,263,0,2644,2642,1,0,0,
  	0,2645,2648,1,0,0,0,2646,2644,1,0,0,0,2646,2647,1,0,0,0,2647,2650,1,0,
  	0,0,2648,2646,1,0,0,0,2649,2651,3,554,277,0,2650,2649,1,0,0,0,2650,2651,
  	1,0,0,0,2651,553,1,0,0,0,2652,2653,4,277,10,0,2653,2654,5,154,0,0,2654,
  	555,1,0,0,0,2655,2656,5,92,0,0,2656,2657,3,522,261,0,2657,557,1,0,0,0,
  	2658,2659,5,83,0,0,2659,559,1,0,0,0,2660,2661,5,96,0,0,2661,561,1,0,0,
  	0,2662,2663,5,146,0,0,2663,2664,3,564,282,0,2664,563,1,0,0,0,2665,2670,
  	3,526,263,0,2666,2667,5,145,0,0,2667,2669,3,526,263,0,2668,2666,1,0,0,
  	0,2669,2672,1,0,0,0,2670,2668,1,0,0,0,2670,2671,1,0,0,0,2671,565,1,0,
  	0,0,2672,2670,1,0,0,0,2673,2683,7,17,0,0,2674,2683,5,137,0,0,2675,2679,
  	5,165,0,0,2676,2680,3,570,285,0,2677,2680,5,137,0,0,2678,2680,5,166,0,
  	0,2679,2676,1,0,0,0,2679,2677,1,0,0,0,2679,2678,1,0,0,0,2680,2681,1,0,
  	0,0,2681,2683,5,165,0,0,2682,2673,1,0,0,0,2682,2674,1,0,0,0,2682,2675,
  	1,0,0,0,2683,567,1,0,0,0,2684,2689,3,566,283,0,2685,2686,5,145,0,0,2686,
  	2688,3,566,283,0,2687,2685,1,0,0,0,2688,2691,1,0,0,0,2689,2687,1,0,0,
  	0,2689,2690,1,0,0,0,2690,569,1,0,0,0,2691,2689,1,0,0,0,2692,2693,7,18,
  	0,0,2693,571,1,0,0,0,2694,2695,4,286,11,0,2695,2696,5,156,0,0,2696,573,
  	1,0,0,0,2697,2698,4,287,12,0,2698,2699,5,155,0,0,2699,575,1,0,0,0,2700,
  	2701,4,288,13,0,2701,2702,5,154,0,0,2702,2703,5,154,0,0,2703,577,1,0,
  	0,0,2704,2705,4,289,14,0,2705,2706,5,157,0,0,2706,2707,5,157,0,0,2707,
  	579,1,0,0,0,2708,2709,4,290,15,0,2709,2710,5,149,0,0,2710,2711,5,156,
  	0,0,2711,581,1,0,0,0,2712,2713,4,291,16,0,2713,2714,5,148,0,0,2714,583,
  	1,0,0,0,2715,2716,4,292,17,0,2716,2717,5,155,0,0,2717,2718,5,149,0,0,
  	2718,585,1,0,0,0,2719,2720,4,293,18,0,2720,2721,5,138,0,0,2721,2722,5,
  	138,0,0,2722,2723,5,138,0,0,2723,587,1,0,0,0,2724,2725,4,294,19,0,2725,
  	2726,5,156,0,0,2726,2727,5,156,0,0,2727,589,1,0,0,0,2728,2729,4,295,20,
  	0,2729,2730,3,596,298,0,2730,591,1,0,0,0,2731,2732,4,296,21,0,2732,2733,
  	3,596,298,0,2733,593,1,0,0,0,2734,2735,4,297,22,0,2735,2736,3,596,298,
  	0,2736,595,1,0,0,0,2737,2739,3,598,299,0,2738,2740,3,602,301,0,2739,2738,
  	1,0,0,0,2739,2740,1,0,0,0,2740,2745,1,0,0,0,2741,2742,3,604,302,0,2742,
  	2743,3,608,304,0,2743,2745,1,0,0,0,2744,2737,1,0,0,0,2744,2741,1,0,0,
  	0,2745,597,1,0,0,0,2746,2749,7,19,0,0,2747,2749,5,168,0,0,2748,2746,1,
  	0,0,0,2748,2747,1,0,0,0,2749,599,1,0,0,0,2750,2753,3,598,299,0,2751,2753,
  	5,169,0,0,2752,2750,1,0,0,0,2752,2751,1,0,0,0,2753,601,1,0,0,0,2754,2755,
  	4,301,23,0,2755,2757,3,600,300,0,2756,2754,1,0,0,0,2757,2758,1,0,0,0,
  	2758,2756,1,0,0,0,2758,2759,1,0,0,0,2759,603,1,0,0,0,2760,2761,5,138,
  	0,0,2761,605,1,0,0,0,2762,2765,5,138,0,0,2763,2765,3,600,300,0,2764,2762,
  	1,0,0,0,2764,2763,1,0,0,0,2765,607,1,0,0,0,2766,2767,4,304,24,0,2767,
  	2769,3,606,303,0,2768,2766,1,0,0,0,2769,2770,1,0,0,0,2770,2768,1,0,0,
  	0,2770,2771,1,0,0,0,2771,609,1,0,0,0,2772,2777,3,612,306,0,2773,2777,
  	3,620,310,0,2774,2777,3,614,307,0,2775,2777,3,616,308,0,2776,2772,1,0,
  	0,0,2776,2773,1,0,0,0,2776,2774,1,0,0,0,2776,2775,1,0,0,0,2777,611,1,
  	0,0,0,2778,2780,3,574,287,0,2779,2778,1,0,0,0,2779,2780,1,0,0,0,2780,
  	2781,1,0,0,0,2781,2787,3,618,309,0,2782,2784,3,574,287,0,2783,2782,1,
  	0,0,0,2783,2784,1,0,0,0,2784,2785,1,0,0,0,2785,2787,5,175,0,0,2786,2779,
  	1,0,0,0,2786,2783,1,0,0,0,2787,613,1,0,0,0,2788,2789,7,20,0,0,2789,615,
  	1,0,0,0,2790,2791,5,90,0,0,2791,617,1,0,0,0,2792,2793,7,21,0,0,2793,619,
  	1,0,0,0,2794,2798,3,622,311,0,2795,2798,3,626,313,0,2796,2798,3,624,312,
  	0,2797,2794,1,0,0,0,2797,2795,1,0,0,0,2797,2796,1,0,0,0,2798,621,1,0,
  	0,0,2799,2801,5,180,0,0,2800,2802,5,193,0,0,2801,2800,1,0,0,0,2802,2803,
  	1,0,0,0,2803,2801,1,0,0,0,2803,2804,1,0,0,0,2804,2805,1,0,0,0,2805,2814,
  	5,192,0,0,2806,2808,5,181,0,0,2807,2809,5,191,0,0,2808,2807,1,0,0,0,2809,
  	2810,1,0,0,0,2810,2808,1,0,0,0,2810,2811,1,0,0,0,2811,2812,1,0,0,0,2812,
  	2814,5,190,0,0,2813,2799,1,0,0,0,2813,2806,1,0,0,0,2814,623,1,0,0,0,2815,
  	2819,5,183,0,0,2816,2818,5,186,0,0,2817,2816,1,0,0,0,2818,2821,1,0,0,
  	0,2819,2817,1,0,0,0,2819,2820,1,0,0,0,2820,2822,1,0,0,0,2821,2819,1,0,
  	0,0,2822,2832,5,185,0,0,2823,2827,5,182,0,0,2824,2826,5,189,0,0,2825,
  	2824,1,0,0,0,2826,2829,1,0,0,0,2827,2825,1,0,0,0,2827,2828,1,0,0,0,2828,
  	2830,1,0,0,0,2829,2827,1,0,0,0,2830,2832,5,188,0,0,2831,2815,1,0,0,0,
  	2831,2823,1,0,0,0,2832,625,1,0,0,0,2833,2847,5,183,0,0,2834,2846,5,186,
  	0,0,2835,2841,5,184,0,0,2836,2842,3,402,201,0,2837,2838,3,472,236,0,2838,
  	2839,5,145,0,0,2839,2840,3,470,235,0,2840,2842,1,0,0,0,2841,2836,1,0,
  	0,0,2841,2837,1,0,0,0,2842,2843,1,0,0,0,2843,2844,5,143,0,0,2844,2846,
  	1,0,0,0,2845,2834,1,0,0,0,2845,2835,1,0,0,0,2846,2849,1,0,0,0,2847,2845,
  	1,0,0,0,2847,2848,1,0,0,0,2848,2850,1,0,0,0,2849,2847,1,0,0,0,2850,2870,
  	5,185,0,0,2851,2865,5,182,0,0,2852,2864,5,189,0,0,2853,2859,5,187,0,0,
  	2854,2860,3,402,201,0,2855,2856,3,472,236,0,2856,2857,5,145,0,0,2857,
  	2858,3,470,235,0,2858,2860,1,0,0,0,2859,2854,1,0,0,0,2859,2855,1,0,0,
  	0,2860,2861,1,0,0,0,2861,2862,5,143,0,0,2862,2864,1,0,0,0,2863,2852,1,
  	0,0,0,2863,2853,1,0,0,0,2864,2867,1,0,0,0,2865,2863,1,0,0,0,2865,2866,
  	1,0,0,0,2866,2868,1,0,0,0,2867,2865,1,0,0,0,2868,2870,5,188,0,0,2869,
  	2833,1,0,0,0,2869,2851,1,0,0,0,2870,627,1,0,0,0,357,629,641,644,647,655,
  	660,664,670,683,690,708,714,720,731,737,741,746,749,757,762,766,770,782,
  	785,792,796,801,805,812,824,828,832,838,849,854,858,869,874,879,883,886,
  	893,898,903,907,919,924,930,947,962,966,971,982,997,1022,1029,1038,1040,
  	1051,1058,1060,1070,1075,1081,1087,1098,1118,1121,1126,1129,1133,1138,
  	1142,1153,1158,1161,1164,1174,1179,1191,1196,1198,1201,1204,1207,1216,
  	1221,1226,1229,1232,1236,1239,1242,1246,1249,1258,1263,1268,1271,1276,
  	1279,1286,1290,1292,1297,1301,1306,1310,1315,1318,1323,1335,1339,1342,
  	1345,1348,1354,1358,1361,1364,1368,1376,1385,1389,1392,1397,1400,1410,
  	1413,1417,1420,1425,1428,1431,1435,1442,1447,1450,1453,1463,1473,1475,
  	1484,1488,1497,1502,1505,1515,1520,1528,1531,1534,1539,1542,1545,1558,
  	1563,1566,1569,1572,1576,1578,1583,1586,1589,1602,1607,1610,1613,1620,
  	1623,1636,1641,1649,1659,1663,1667,1671,1674,1677,1682,1687,1690,1695,
  	1698,1701,1705,1709,1712,1717,1720,1724,1729,1735,1738,1743,1746,1757,
  	1762,1767,1772,1775,1778,1782,1788,1795,1809,1818,1825,1830,1849,1857,
  	1876,1881,1886,1892,1900,1903,1911,1918,1929,1933,1942,1948,1953,1958,
  	1968,1975,1980,1987,1992,1996,2001,2006,2014,2022,2025,2029,2036,2040,
  	2044,2051,2058,2061,2066,2071,2080,2082,2088,2104,2111,2124,2128,2137,
  	2141,2148,2157,2161,2200,2214,2227,2231,2234,2239,2243,2246,2253,2257,
  	2261,2268,2274,2276,2287,2291,2295,2300,2307,2309,2314,2318,2336,2343,
  	2349,2357,2367,2372,2375,2380,2389,2395,2413,2415,2421,2425,2429,2437,
  	2447,2449,2466,2475,2479,2484,2488,2493,2502,2521,2532,2536,2541,2544,
  	2550,2554,2560,2569,2576,2580,2585,2588,2592,2600,2602,2611,2615,2618,
  	2624,2629,2646,2650,2670,2679,2682,2689,2739,2744,2748,2752,2758,2764,
  	2770,2776,2779,2783,2786,2797,2803,2810,2813,2819,2827,2831,2841,2845,
  	2847,2859,2863,2865,2869
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  myparserParserStaticData = staticData.release();
}

}

myParser::myParser(TokenStream *input) : myParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

myParser::myParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  myParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *myparserParserStaticData->atn, myparserParserStaticData->decisionToDFA, myparserParserStaticData->sharedContextCache, options);
}

myParser::~myParser() {
  delete _interpreter;
}

const atn::ATN& myParser::getATN() const {
  return *myparserParserStaticData->atn;
}

std::string myParser::getGrammarFileName() const {
  return "myParser.g4";
}

const std::vector<std::string>& myParser::getRuleNames() const {
  return myparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& myParser::getVocabulary() const {
  return myparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView myParser::getSerializedATN() const {
  return myparserParserStaticData->serializedATN;
}


//----------------- Top_levelContext ------------------------------------------------------------------

myParser::Top_levelContext::Top_levelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Top_levelContext::EOF() {
  return getToken(myParser::EOF, 0);
}

myParser::StatementsContext* myParser::Top_levelContext::statements() {
  return getRuleContext<myParser::StatementsContext>(0);
}


size_t myParser::Top_levelContext::getRuleIndex() const {
  return myParser::RuleTop_level;
}

void myParser::Top_levelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTop_level(this);
}

void myParser::Top_levelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTop_level(this);
}

myParser::Top_levelContext* myParser::top_level() {
  Top_levelContext *_localctx = _tracker.createInstance<Top_levelContext>(_ctx, getState());
  enterRule(_localctx, 0, myParser::RuleTop_level);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(629);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx)) {
    case 1: {
      setState(628);
      statements();
      break;
    }

    default:
      break;
    }
    setState(631);
    match(myParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

myParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Loop_statementContext* myParser::StatementContext::loop_statement() {
  return getRuleContext<myParser::Loop_statementContext>(0);
}

myParser::DeclarationContext* myParser::StatementContext::declaration() {
  return getRuleContext<myParser::DeclarationContext>(0);
}

myParser::Branch_statementContext* myParser::StatementContext::branch_statement() {
  return getRuleContext<myParser::Branch_statementContext>(0);
}

myParser::Labeled_statementContext* myParser::StatementContext::labeled_statement() {
  return getRuleContext<myParser::Labeled_statementContext>(0);
}

myParser::Control_transfer_statementContext* myParser::StatementContext::control_transfer_statement() {
  return getRuleContext<myParser::Control_transfer_statementContext>(0);
}

myParser::Defer_statementContext* myParser::StatementContext::defer_statement() {
  return getRuleContext<myParser::Defer_statementContext>(0);
}

myParser::Do_statementContext* myParser::StatementContext::do_statement() {
  return getRuleContext<myParser::Do_statementContext>(0);
}

myParser::ExpressionContext* myParser::StatementContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

tree::TerminalNode* myParser::StatementContext::SEMI() {
  return getToken(myParser::SEMI, 0);
}

myParser::Compiler_control_statementContext* myParser::StatementContext::compiler_control_statement() {
  return getRuleContext<myParser::Compiler_control_statementContext>(0);
}


size_t myParser::StatementContext::getRuleIndex() const {
  return myParser::RuleStatement;
}

void myParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void myParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}

myParser::StatementContext* myParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 2, myParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(647);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(641);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx)) {
      case 1: {
        setState(633);
        loop_statement();
        break;
      }

      case 2: {
        setState(634);
        declaration();
        break;
      }

      case 3: {
        setState(635);
        branch_statement();
        break;
      }

      case 4: {
        setState(636);
        labeled_statement();
        break;
      }

      case 5: {
        setState(637);
        control_transfer_statement();
        break;
      }

      case 6: {
        setState(638);
        defer_statement();
        break;
      }

      case 7: {
        setState(639);
        do_statement();
        break;
      }

      case 8: {
        setState(640);
        expression();
        break;
      }

      default:
        break;
      }
      setState(644);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
      case 1: {
        setState(643);
        match(myParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(646);
      compiler_control_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementsContext ------------------------------------------------------------------

myParser::StatementsContext::StatementsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::StatementContext *> myParser::StatementsContext::statement() {
  return getRuleContexts<myParser::StatementContext>();
}

myParser::StatementContext* myParser::StatementsContext::statement(size_t i) {
  return getRuleContext<myParser::StatementContext>(i);
}


size_t myParser::StatementsContext::getRuleIndex() const {
  return myParser::RuleStatements;
}

void myParser::StatementsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatements(this);
}

void myParser::StatementsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatements(this);
}

myParser::StatementsContext* myParser::statements() {
  StatementsContext *_localctx = _tracker.createInstance<StatementsContext>(_ctx, getState());
  enterRule(_localctx, 4, myParser::RuleStatements);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(653); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(649);

              if (!(SwiftSupport.isSeparatedStatement(_input, _localctx->indexBefore))) throw FailedPredicateException(this, "SwiftSupport.isSeparatedStatement(_input, $indexBefore)");
              setState(650);
              statement();
              antlrcpp::downCast<StatementsContext *>(_localctx)->indexBefore =  _input.index();
              			
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(655); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Loop_statementContext ------------------------------------------------------------------

myParser::Loop_statementContext::Loop_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::For_in_statementContext* myParser::Loop_statementContext::for_in_statement() {
  return getRuleContext<myParser::For_in_statementContext>(0);
}

myParser::While_statementContext* myParser::Loop_statementContext::while_statement() {
  return getRuleContext<myParser::While_statementContext>(0);
}

myParser::Repeat_while_statementContext* myParser::Loop_statementContext::repeat_while_statement() {
  return getRuleContext<myParser::Repeat_while_statementContext>(0);
}


size_t myParser::Loop_statementContext::getRuleIndex() const {
  return myParser::RuleLoop_statement;
}

void myParser::Loop_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoop_statement(this);
}

void myParser::Loop_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoop_statement(this);
}

myParser::Loop_statementContext* myParser::loop_statement() {
  Loop_statementContext *_localctx = _tracker.createInstance<Loop_statementContext>(_ctx, getState());
  enterRule(_localctx, 6, myParser::RuleLoop_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(660);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::FOR: {
        enterOuterAlt(_localctx, 1);
        setState(657);
        for_in_statement();
        break;
      }

      case myParser::WHILE: {
        enterOuterAlt(_localctx, 2);
        setState(658);
        while_statement();
        break;
      }

      case myParser::REPEAT: {
        enterOuterAlt(_localctx, 3);
        setState(659);
        repeat_while_statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_in_statementContext ------------------------------------------------------------------

myParser::For_in_statementContext::For_in_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::For_in_statementContext::FOR() {
  return getToken(myParser::FOR, 0);
}

myParser::PatternContext* myParser::For_in_statementContext::pattern() {
  return getRuleContext<myParser::PatternContext>(0);
}

tree::TerminalNode* myParser::For_in_statementContext::IN() {
  return getToken(myParser::IN, 0);
}

myParser::ExpressionContext* myParser::For_in_statementContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

myParser::Code_blockContext* myParser::For_in_statementContext::code_block() {
  return getRuleContext<myParser::Code_blockContext>(0);
}

tree::TerminalNode* myParser::For_in_statementContext::CASE() {
  return getToken(myParser::CASE, 0);
}

myParser::Where_clauseContext* myParser::For_in_statementContext::where_clause() {
  return getRuleContext<myParser::Where_clauseContext>(0);
}


size_t myParser::For_in_statementContext::getRuleIndex() const {
  return myParser::RuleFor_in_statement;
}

void myParser::For_in_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFor_in_statement(this);
}

void myParser::For_in_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFor_in_statement(this);
}

myParser::For_in_statementContext* myParser::for_in_statement() {
  For_in_statementContext *_localctx = _tracker.createInstance<For_in_statementContext>(_ctx, getState());
  enterRule(_localctx, 8, myParser::RuleFor_in_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(662);
    match(myParser::FOR);
    setState(664);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx)) {
    case 1: {
      setState(663);
      match(myParser::CASE);
      break;
    }

    default:
      break;
    }
    setState(666);
    pattern(0);
    setState(667);
    match(myParser::IN);
    setState(668);
    expression();
    setState(670);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::WHERE) {
      setState(669);
      where_clause();
    }
    setState(672);
    code_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- While_statementContext ------------------------------------------------------------------

myParser::While_statementContext::While_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::While_statementContext::WHILE() {
  return getToken(myParser::WHILE, 0);
}

myParser::Condition_listContext* myParser::While_statementContext::condition_list() {
  return getRuleContext<myParser::Condition_listContext>(0);
}

myParser::Code_blockContext* myParser::While_statementContext::code_block() {
  return getRuleContext<myParser::Code_blockContext>(0);
}


size_t myParser::While_statementContext::getRuleIndex() const {
  return myParser::RuleWhile_statement;
}

void myParser::While_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhile_statement(this);
}

void myParser::While_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhile_statement(this);
}

myParser::While_statementContext* myParser::while_statement() {
  While_statementContext *_localctx = _tracker.createInstance<While_statementContext>(_ctx, getState());
  enterRule(_localctx, 10, myParser::RuleWhile_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(674);
    match(myParser::WHILE);
    setState(675);
    condition_list();
    setState(676);
    code_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Condition_listContext ------------------------------------------------------------------

myParser::Condition_listContext::Condition_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::ConditionContext *> myParser::Condition_listContext::condition() {
  return getRuleContexts<myParser::ConditionContext>();
}

myParser::ConditionContext* myParser::Condition_listContext::condition(size_t i) {
  return getRuleContext<myParser::ConditionContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Condition_listContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Condition_listContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Condition_listContext::getRuleIndex() const {
  return myParser::RuleCondition_list;
}

void myParser::Condition_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCondition_list(this);
}

void myParser::Condition_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCondition_list(this);
}

myParser::Condition_listContext* myParser::condition_list() {
  Condition_listContext *_localctx = _tracker.createInstance<Condition_listContext>(_ctx, getState());
  enterRule(_localctx, 12, myParser::RuleCondition_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(678);
    condition();
    setState(683);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(679);
      match(myParser::COMMA);
      setState(680);
      condition();
      setState(685);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionContext ------------------------------------------------------------------

myParser::ConditionContext::ConditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Availability_conditionContext* myParser::ConditionContext::availability_condition() {
  return getRuleContext<myParser::Availability_conditionContext>(0);
}

myParser::ExpressionContext* myParser::ConditionContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

myParser::Case_conditionContext* myParser::ConditionContext::case_condition() {
  return getRuleContext<myParser::Case_conditionContext>(0);
}

myParser::Optional_binding_conditionContext* myParser::ConditionContext::optional_binding_condition() {
  return getRuleContext<myParser::Optional_binding_conditionContext>(0);
}


size_t myParser::ConditionContext::getRuleIndex() const {
  return myParser::RuleCondition;
}

void myParser::ConditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCondition(this);
}

void myParser::ConditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCondition(this);
}

myParser::ConditionContext* myParser::condition() {
  ConditionContext *_localctx = _tracker.createInstance<ConditionContext>(_ctx, getState());
  enterRule(_localctx, 14, myParser::RuleCondition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(690);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(686);
      availability_condition();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(687);
      expression();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(688);
      case_condition();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(689);
      optional_binding_condition();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_conditionContext ------------------------------------------------------------------

myParser::Case_conditionContext::Case_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Case_conditionContext::CASE() {
  return getToken(myParser::CASE, 0);
}

myParser::PatternContext* myParser::Case_conditionContext::pattern() {
  return getRuleContext<myParser::PatternContext>(0);
}

myParser::InitializerContext* myParser::Case_conditionContext::initializer() {
  return getRuleContext<myParser::InitializerContext>(0);
}


size_t myParser::Case_conditionContext::getRuleIndex() const {
  return myParser::RuleCase_condition;
}

void myParser::Case_conditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_condition(this);
}

void myParser::Case_conditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_condition(this);
}

myParser::Case_conditionContext* myParser::case_condition() {
  Case_conditionContext *_localctx = _tracker.createInstance<Case_conditionContext>(_ctx, getState());
  enterRule(_localctx, 16, myParser::RuleCase_condition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(692);
    match(myParser::CASE);
    setState(693);
    pattern(0);
    setState(694);
    initializer();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Optional_binding_conditionContext ------------------------------------------------------------------

myParser::Optional_binding_conditionContext::Optional_binding_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::PatternContext* myParser::Optional_binding_conditionContext::pattern() {
  return getRuleContext<myParser::PatternContext>(0);
}

myParser::InitializerContext* myParser::Optional_binding_conditionContext::initializer() {
  return getRuleContext<myParser::InitializerContext>(0);
}

tree::TerminalNode* myParser::Optional_binding_conditionContext::LET() {
  return getToken(myParser::LET, 0);
}

tree::TerminalNode* myParser::Optional_binding_conditionContext::VAR() {
  return getToken(myParser::VAR, 0);
}


size_t myParser::Optional_binding_conditionContext::getRuleIndex() const {
  return myParser::RuleOptional_binding_condition;
}

void myParser::Optional_binding_conditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptional_binding_condition(this);
}

void myParser::Optional_binding_conditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptional_binding_condition(this);
}

myParser::Optional_binding_conditionContext* myParser::optional_binding_condition() {
  Optional_binding_conditionContext *_localctx = _tracker.createInstance<Optional_binding_conditionContext>(_ctx, getState());
  enterRule(_localctx, 18, myParser::RuleOptional_binding_condition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(696);
    _la = _input->LA(1);
    if (!(_la == myParser::LET

    || _la == myParser::VAR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(697);
    pattern(0);
    setState(698);
    initializer();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Repeat_while_statementContext ------------------------------------------------------------------

myParser::Repeat_while_statementContext::Repeat_while_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Repeat_while_statementContext::REPEAT() {
  return getToken(myParser::REPEAT, 0);
}

myParser::Code_blockContext* myParser::Repeat_while_statementContext::code_block() {
  return getRuleContext<myParser::Code_blockContext>(0);
}

tree::TerminalNode* myParser::Repeat_while_statementContext::WHILE() {
  return getToken(myParser::WHILE, 0);
}

myParser::ExpressionContext* myParser::Repeat_while_statementContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}


size_t myParser::Repeat_while_statementContext::getRuleIndex() const {
  return myParser::RuleRepeat_while_statement;
}

void myParser::Repeat_while_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRepeat_while_statement(this);
}

void myParser::Repeat_while_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRepeat_while_statement(this);
}

myParser::Repeat_while_statementContext* myParser::repeat_while_statement() {
  Repeat_while_statementContext *_localctx = _tracker.createInstance<Repeat_while_statementContext>(_ctx, getState());
  enterRule(_localctx, 20, myParser::RuleRepeat_while_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(700);
    match(myParser::REPEAT);
    setState(701);
    code_block();
    setState(702);
    match(myParser::WHILE);
    setState(703);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Branch_statementContext ------------------------------------------------------------------

myParser::Branch_statementContext::Branch_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::If_statementContext* myParser::Branch_statementContext::if_statement() {
  return getRuleContext<myParser::If_statementContext>(0);
}

myParser::Guard_statementContext* myParser::Branch_statementContext::guard_statement() {
  return getRuleContext<myParser::Guard_statementContext>(0);
}

myParser::Switch_statementContext* myParser::Branch_statementContext::switch_statement() {
  return getRuleContext<myParser::Switch_statementContext>(0);
}


size_t myParser::Branch_statementContext::getRuleIndex() const {
  return myParser::RuleBranch_statement;
}

void myParser::Branch_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBranch_statement(this);
}

void myParser::Branch_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBranch_statement(this);
}

myParser::Branch_statementContext* myParser::branch_statement() {
  Branch_statementContext *_localctx = _tracker.createInstance<Branch_statementContext>(_ctx, getState());
  enterRule(_localctx, 22, myParser::RuleBranch_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(708);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::IF: {
        enterOuterAlt(_localctx, 1);
        setState(705);
        if_statement();
        break;
      }

      case myParser::GUARD: {
        enterOuterAlt(_localctx, 2);
        setState(706);
        guard_statement();
        break;
      }

      case myParser::SWITCH: {
        enterOuterAlt(_localctx, 3);
        setState(707);
        switch_statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_statementContext ------------------------------------------------------------------

myParser::If_statementContext::If_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::If_statementContext::IF() {
  return getToken(myParser::IF, 0);
}

myParser::Condition_listContext* myParser::If_statementContext::condition_list() {
  return getRuleContext<myParser::Condition_listContext>(0);
}

myParser::Code_blockContext* myParser::If_statementContext::code_block() {
  return getRuleContext<myParser::Code_blockContext>(0);
}

myParser::Else_clauseContext* myParser::If_statementContext::else_clause() {
  return getRuleContext<myParser::Else_clauseContext>(0);
}


size_t myParser::If_statementContext::getRuleIndex() const {
  return myParser::RuleIf_statement;
}

void myParser::If_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_statement(this);
}

void myParser::If_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_statement(this);
}

myParser::If_statementContext* myParser::if_statement() {
  If_statementContext *_localctx = _tracker.createInstance<If_statementContext>(_ctx, getState());
  enterRule(_localctx, 24, myParser::RuleIf_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(710);
    match(myParser::IF);
    setState(711);
    condition_list();
    setState(712);
    code_block();
    setState(714);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx)) {
    case 1: {
      setState(713);
      else_clause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Else_clauseContext ------------------------------------------------------------------

myParser::Else_clauseContext::Else_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Else_clauseContext::ELSE() {
  return getToken(myParser::ELSE, 0);
}

myParser::Code_blockContext* myParser::Else_clauseContext::code_block() {
  return getRuleContext<myParser::Code_blockContext>(0);
}

myParser::If_statementContext* myParser::Else_clauseContext::if_statement() {
  return getRuleContext<myParser::If_statementContext>(0);
}


size_t myParser::Else_clauseContext::getRuleIndex() const {
  return myParser::RuleElse_clause;
}

void myParser::Else_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElse_clause(this);
}

void myParser::Else_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElse_clause(this);
}

myParser::Else_clauseContext* myParser::else_clause() {
  Else_clauseContext *_localctx = _tracker.createInstance<Else_clauseContext>(_ctx, getState());
  enterRule(_localctx, 26, myParser::RuleElse_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(720);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(716);
      match(myParser::ELSE);
      setState(717);
      code_block();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(718);
      match(myParser::ELSE);
      setState(719);
      if_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Guard_statementContext ------------------------------------------------------------------

myParser::Guard_statementContext::Guard_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Guard_statementContext::GUARD() {
  return getToken(myParser::GUARD, 0);
}

myParser::Condition_listContext* myParser::Guard_statementContext::condition_list() {
  return getRuleContext<myParser::Condition_listContext>(0);
}

tree::TerminalNode* myParser::Guard_statementContext::ELSE() {
  return getToken(myParser::ELSE, 0);
}

myParser::Code_blockContext* myParser::Guard_statementContext::code_block() {
  return getRuleContext<myParser::Code_blockContext>(0);
}


size_t myParser::Guard_statementContext::getRuleIndex() const {
  return myParser::RuleGuard_statement;
}

void myParser::Guard_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGuard_statement(this);
}

void myParser::Guard_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGuard_statement(this);
}

myParser::Guard_statementContext* myParser::guard_statement() {
  Guard_statementContext *_localctx = _tracker.createInstance<Guard_statementContext>(_ctx, getState());
  enterRule(_localctx, 28, myParser::RuleGuard_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(722);
    match(myParser::GUARD);
    setState(723);
    condition_list();
    setState(724);
    match(myParser::ELSE);
    setState(725);
    code_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Switch_statementContext ------------------------------------------------------------------

myParser::Switch_statementContext::Switch_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Switch_statementContext::SWITCH() {
  return getToken(myParser::SWITCH, 0);
}

myParser::ExpressionContext* myParser::Switch_statementContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

tree::TerminalNode* myParser::Switch_statementContext::LCURLY() {
  return getToken(myParser::LCURLY, 0);
}

tree::TerminalNode* myParser::Switch_statementContext::RCURLY() {
  return getToken(myParser::RCURLY, 0);
}

myParser::Switch_casesContext* myParser::Switch_statementContext::switch_cases() {
  return getRuleContext<myParser::Switch_casesContext>(0);
}


size_t myParser::Switch_statementContext::getRuleIndex() const {
  return myParser::RuleSwitch_statement;
}

void myParser::Switch_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitch_statement(this);
}

void myParser::Switch_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitch_statement(this);
}

myParser::Switch_statementContext* myParser::switch_statement() {
  Switch_statementContext *_localctx = _tracker.createInstance<Switch_statementContext>(_ctx, getState());
  enterRule(_localctx, 30, myParser::RuleSwitch_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(727);
    match(myParser::SWITCH);
    setState(728);
    expression();
    setState(729);
    match(myParser::LCURLY);
    setState(731);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::CASE

    || _la == myParser::DEFAULT || _la == myParser::HASH_IF

    || _la == myParser::AT) {
      setState(730);
      switch_cases();
    }
    setState(733);
    match(myParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Switch_casesContext ------------------------------------------------------------------

myParser::Switch_casesContext::Switch_casesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Switch_caseContext* myParser::Switch_casesContext::switch_case() {
  return getRuleContext<myParser::Switch_caseContext>(0);
}

myParser::Switch_casesContext* myParser::Switch_casesContext::switch_cases() {
  return getRuleContext<myParser::Switch_casesContext>(0);
}


size_t myParser::Switch_casesContext::getRuleIndex() const {
  return myParser::RuleSwitch_cases;
}

void myParser::Switch_casesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitch_cases(this);
}

void myParser::Switch_casesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitch_cases(this);
}

myParser::Switch_casesContext* myParser::switch_cases() {
  Switch_casesContext *_localctx = _tracker.createInstance<Switch_casesContext>(_ctx, getState());
  enterRule(_localctx, 32, myParser::RuleSwitch_cases);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(735);
    switch_case();
    setState(737);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::CASE

    || _la == myParser::DEFAULT || _la == myParser::HASH_IF

    || _la == myParser::AT) {
      setState(736);
      switch_cases();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Switch_caseContext ------------------------------------------------------------------

myParser::Switch_caseContext::Switch_caseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::StatementsContext* myParser::Switch_caseContext::statements() {
  return getRuleContext<myParser::StatementsContext>(0);
}

myParser::Case_labelContext* myParser::Switch_caseContext::case_label() {
  return getRuleContext<myParser::Case_labelContext>(0);
}

myParser::Default_labelContext* myParser::Switch_caseContext::default_label() {
  return getRuleContext<myParser::Default_labelContext>(0);
}

myParser::Conditional_switch_caseContext* myParser::Switch_caseContext::conditional_switch_case() {
  return getRuleContext<myParser::Conditional_switch_caseContext>(0);
}


size_t myParser::Switch_caseContext::getRuleIndex() const {
  return myParser::RuleSwitch_case;
}

void myParser::Switch_caseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitch_case(this);
}

void myParser::Switch_caseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitch_case(this);
}

myParser::Switch_caseContext* myParser::switch_case() {
  Switch_caseContext *_localctx = _tracker.createInstance<Switch_caseContext>(_ctx, getState());
  enterRule(_localctx, 34, myParser::RuleSwitch_case);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(746);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::CASE:
      case myParser::DEFAULT:
      case myParser::AT: {
        enterOuterAlt(_localctx, 1);
        setState(741);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx)) {
        case 1: {
          setState(739);
          case_label();
          break;
        }

        case 2: {
          setState(740);
          default_label();
          break;
        }

        default:
          break;
        }
        setState(743);
        statements();
        break;
      }

      case myParser::HASH_IF: {
        enterOuterAlt(_localctx, 2);
        setState(745);
        conditional_switch_case();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_labelContext ------------------------------------------------------------------

myParser::Case_labelContext::Case_labelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Case_labelContext::CASE() {
  return getToken(myParser::CASE, 0);
}

myParser::Case_item_listContext* myParser::Case_labelContext::case_item_list() {
  return getRuleContext<myParser::Case_item_listContext>(0);
}

tree::TerminalNode* myParser::Case_labelContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::AttributesContext* myParser::Case_labelContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}


size_t myParser::Case_labelContext::getRuleIndex() const {
  return myParser::RuleCase_label;
}

void myParser::Case_labelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_label(this);
}

void myParser::Case_labelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_label(this);
}

myParser::Case_labelContext* myParser::case_label() {
  Case_labelContext *_localctx = _tracker.createInstance<Case_labelContext>(_ctx, getState());
  enterRule(_localctx, 36, myParser::RuleCase_label);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(749);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(748);
      attributes();
    }
    setState(751);
    match(myParser::CASE);
    setState(752);
    case_item_list();
    setState(753);
    match(myParser::COLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_item_listContext ------------------------------------------------------------------

myParser::Case_item_listContext::Case_item_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::PatternContext *> myParser::Case_item_listContext::pattern() {
  return getRuleContexts<myParser::PatternContext>();
}

myParser::PatternContext* myParser::Case_item_listContext::pattern(size_t i) {
  return getRuleContext<myParser::PatternContext>(i);
}

std::vector<myParser::Where_clauseContext *> myParser::Case_item_listContext::where_clause() {
  return getRuleContexts<myParser::Where_clauseContext>();
}

myParser::Where_clauseContext* myParser::Case_item_listContext::where_clause(size_t i) {
  return getRuleContext<myParser::Where_clauseContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Case_item_listContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Case_item_listContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Case_item_listContext::getRuleIndex() const {
  return myParser::RuleCase_item_list;
}

void myParser::Case_item_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_item_list(this);
}

void myParser::Case_item_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_item_list(this);
}

myParser::Case_item_listContext* myParser::case_item_list() {
  Case_item_listContext *_localctx = _tracker.createInstance<Case_item_listContext>(_ctx, getState());
  enterRule(_localctx, 38, myParser::RuleCase_item_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(755);
    pattern(0);
    setState(757);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::WHERE) {
      setState(756);
      where_clause();
    }
    setState(766);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(759);
      match(myParser::COMMA);
      setState(760);
      pattern(0);
      setState(762);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::WHERE) {
        setState(761);
        where_clause();
      }
      setState(768);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Default_labelContext ------------------------------------------------------------------

myParser::Default_labelContext::Default_labelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Default_labelContext::DEFAULT() {
  return getToken(myParser::DEFAULT, 0);
}

tree::TerminalNode* myParser::Default_labelContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::AttributesContext* myParser::Default_labelContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}


size_t myParser::Default_labelContext::getRuleIndex() const {
  return myParser::RuleDefault_label;
}

void myParser::Default_labelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefault_label(this);
}

void myParser::Default_labelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefault_label(this);
}

myParser::Default_labelContext* myParser::default_label() {
  Default_labelContext *_localctx = _tracker.createInstance<Default_labelContext>(_ctx, getState());
  enterRule(_localctx, 40, myParser::RuleDefault_label);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(770);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(769);
      attributes();
    }
    setState(772);
    match(myParser::DEFAULT);
    setState(773);
    match(myParser::COLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Where_clauseContext ------------------------------------------------------------------

myParser::Where_clauseContext::Where_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Where_clauseContext::WHERE() {
  return getToken(myParser::WHERE, 0);
}

myParser::Where_expressionContext* myParser::Where_clauseContext::where_expression() {
  return getRuleContext<myParser::Where_expressionContext>(0);
}


size_t myParser::Where_clauseContext::getRuleIndex() const {
  return myParser::RuleWhere_clause;
}

void myParser::Where_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhere_clause(this);
}

void myParser::Where_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhere_clause(this);
}

myParser::Where_clauseContext* myParser::where_clause() {
  Where_clauseContext *_localctx = _tracker.createInstance<Where_clauseContext>(_ctx, getState());
  enterRule(_localctx, 42, myParser::RuleWhere_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(775);
    match(myParser::WHERE);
    setState(776);
    where_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Where_expressionContext ------------------------------------------------------------------

myParser::Where_expressionContext::Where_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionContext* myParser::Where_expressionContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}


size_t myParser::Where_expressionContext::getRuleIndex() const {
  return myParser::RuleWhere_expression;
}

void myParser::Where_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhere_expression(this);
}

void myParser::Where_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhere_expression(this);
}

myParser::Where_expressionContext* myParser::where_expression() {
  Where_expressionContext *_localctx = _tracker.createInstance<Where_expressionContext>(_ctx, getState());
  enterRule(_localctx, 44, myParser::RuleWhere_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(778);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Conditional_switch_caseContext ------------------------------------------------------------------

myParser::Conditional_switch_caseContext::Conditional_switch_caseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Switch_if_directive_clauseContext* myParser::Conditional_switch_caseContext::switch_if_directive_clause() {
  return getRuleContext<myParser::Switch_if_directive_clauseContext>(0);
}

tree::TerminalNode* myParser::Conditional_switch_caseContext::HASH_ENDIF() {
  return getToken(myParser::HASH_ENDIF, 0);
}

myParser::Switch_elseif_directive_clausesContext* myParser::Conditional_switch_caseContext::switch_elseif_directive_clauses() {
  return getRuleContext<myParser::Switch_elseif_directive_clausesContext>(0);
}

myParser::Switch_else_directive_clauseContext* myParser::Conditional_switch_caseContext::switch_else_directive_clause() {
  return getRuleContext<myParser::Switch_else_directive_clauseContext>(0);
}


size_t myParser::Conditional_switch_caseContext::getRuleIndex() const {
  return myParser::RuleConditional_switch_case;
}

void myParser::Conditional_switch_caseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditional_switch_case(this);
}

void myParser::Conditional_switch_caseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditional_switch_case(this);
}

myParser::Conditional_switch_caseContext* myParser::conditional_switch_case() {
  Conditional_switch_caseContext *_localctx = _tracker.createInstance<Conditional_switch_caseContext>(_ctx, getState());
  enterRule(_localctx, 46, myParser::RuleConditional_switch_case);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(780);
    switch_if_directive_clause();
    setState(782);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::HASH_ELSEIF) {
      setState(781);
      switch_elseif_directive_clauses();
    }
    setState(785);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::HASH_ELSE) {
      setState(784);
      switch_else_directive_clause();
    }
    setState(787);
    match(myParser::HASH_ENDIF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Switch_if_directive_clauseContext ------------------------------------------------------------------

myParser::Switch_if_directive_clauseContext::Switch_if_directive_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Switch_if_directive_clauseContext::HASH_IF() {
  return getToken(myParser::HASH_IF, 0);
}

myParser::Compilation_conditionContext* myParser::Switch_if_directive_clauseContext::compilation_condition() {
  return getRuleContext<myParser::Compilation_conditionContext>(0);
}

myParser::Switch_casesContext* myParser::Switch_if_directive_clauseContext::switch_cases() {
  return getRuleContext<myParser::Switch_casesContext>(0);
}


size_t myParser::Switch_if_directive_clauseContext::getRuleIndex() const {
  return myParser::RuleSwitch_if_directive_clause;
}

void myParser::Switch_if_directive_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitch_if_directive_clause(this);
}

void myParser::Switch_if_directive_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitch_if_directive_clause(this);
}

myParser::Switch_if_directive_clauseContext* myParser::switch_if_directive_clause() {
  Switch_if_directive_clauseContext *_localctx = _tracker.createInstance<Switch_if_directive_clauseContext>(_ctx, getState());
  enterRule(_localctx, 48, myParser::RuleSwitch_if_directive_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(789);
    match(myParser::HASH_IF);
    setState(790);
    compilation_condition(0);
    setState(792);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::CASE

    || _la == myParser::DEFAULT || _la == myParser::HASH_IF

    || _la == myParser::AT) {
      setState(791);
      switch_cases();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Switch_elseif_directive_clausesContext ------------------------------------------------------------------

myParser::Switch_elseif_directive_clausesContext::Switch_elseif_directive_clausesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Elseif_directive_clauseContext* myParser::Switch_elseif_directive_clausesContext::elseif_directive_clause() {
  return getRuleContext<myParser::Elseif_directive_clauseContext>(0);
}

myParser::Switch_elseif_directive_clausesContext* myParser::Switch_elseif_directive_clausesContext::switch_elseif_directive_clauses() {
  return getRuleContext<myParser::Switch_elseif_directive_clausesContext>(0);
}


size_t myParser::Switch_elseif_directive_clausesContext::getRuleIndex() const {
  return myParser::RuleSwitch_elseif_directive_clauses;
}

void myParser::Switch_elseif_directive_clausesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitch_elseif_directive_clauses(this);
}

void myParser::Switch_elseif_directive_clausesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitch_elseif_directive_clauses(this);
}

myParser::Switch_elseif_directive_clausesContext* myParser::switch_elseif_directive_clauses() {
  Switch_elseif_directive_clausesContext *_localctx = _tracker.createInstance<Switch_elseif_directive_clausesContext>(_ctx, getState());
  enterRule(_localctx, 50, myParser::RuleSwitch_elseif_directive_clauses);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(794);
    elseif_directive_clause();
    setState(796);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::HASH_ELSEIF) {
      setState(795);
      switch_elseif_directive_clauses();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Switch_elseif_directive_clauseContext ------------------------------------------------------------------

myParser::Switch_elseif_directive_clauseContext::Switch_elseif_directive_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Switch_elseif_directive_clauseContext::HASH_ELSEIF() {
  return getToken(myParser::HASH_ELSEIF, 0);
}

myParser::Compilation_conditionContext* myParser::Switch_elseif_directive_clauseContext::compilation_condition() {
  return getRuleContext<myParser::Compilation_conditionContext>(0);
}

myParser::Switch_casesContext* myParser::Switch_elseif_directive_clauseContext::switch_cases() {
  return getRuleContext<myParser::Switch_casesContext>(0);
}


size_t myParser::Switch_elseif_directive_clauseContext::getRuleIndex() const {
  return myParser::RuleSwitch_elseif_directive_clause;
}

void myParser::Switch_elseif_directive_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitch_elseif_directive_clause(this);
}

void myParser::Switch_elseif_directive_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitch_elseif_directive_clause(this);
}

myParser::Switch_elseif_directive_clauseContext* myParser::switch_elseif_directive_clause() {
  Switch_elseif_directive_clauseContext *_localctx = _tracker.createInstance<Switch_elseif_directive_clauseContext>(_ctx, getState());
  enterRule(_localctx, 52, myParser::RuleSwitch_elseif_directive_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(798);
    match(myParser::HASH_ELSEIF);
    setState(799);
    compilation_condition(0);
    setState(801);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::CASE

    || _la == myParser::DEFAULT || _la == myParser::HASH_IF

    || _la == myParser::AT) {
      setState(800);
      switch_cases();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Switch_else_directive_clauseContext ------------------------------------------------------------------

myParser::Switch_else_directive_clauseContext::Switch_else_directive_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Switch_else_directive_clauseContext::HASH_ELSE() {
  return getToken(myParser::HASH_ELSE, 0);
}

myParser::Switch_casesContext* myParser::Switch_else_directive_clauseContext::switch_cases() {
  return getRuleContext<myParser::Switch_casesContext>(0);
}


size_t myParser::Switch_else_directive_clauseContext::getRuleIndex() const {
  return myParser::RuleSwitch_else_directive_clause;
}

void myParser::Switch_else_directive_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitch_else_directive_clause(this);
}

void myParser::Switch_else_directive_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitch_else_directive_clause(this);
}

myParser::Switch_else_directive_clauseContext* myParser::switch_else_directive_clause() {
  Switch_else_directive_clauseContext *_localctx = _tracker.createInstance<Switch_else_directive_clauseContext>(_ctx, getState());
  enterRule(_localctx, 54, myParser::RuleSwitch_else_directive_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(803);
    match(myParser::HASH_ELSE);
    setState(805);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::CASE

    || _la == myParser::DEFAULT || _la == myParser::HASH_IF

    || _la == myParser::AT) {
      setState(804);
      switch_cases();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Labeled_statementContext ------------------------------------------------------------------

myParser::Labeled_statementContext::Labeled_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Statement_labelContext* myParser::Labeled_statementContext::statement_label() {
  return getRuleContext<myParser::Statement_labelContext>(0);
}

myParser::Loop_statementContext* myParser::Labeled_statementContext::loop_statement() {
  return getRuleContext<myParser::Loop_statementContext>(0);
}

myParser::If_statementContext* myParser::Labeled_statementContext::if_statement() {
  return getRuleContext<myParser::If_statementContext>(0);
}

myParser::Switch_statementContext* myParser::Labeled_statementContext::switch_statement() {
  return getRuleContext<myParser::Switch_statementContext>(0);
}

myParser::Do_statementContext* myParser::Labeled_statementContext::do_statement() {
  return getRuleContext<myParser::Do_statementContext>(0);
}


size_t myParser::Labeled_statementContext::getRuleIndex() const {
  return myParser::RuleLabeled_statement;
}

void myParser::Labeled_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabeled_statement(this);
}

void myParser::Labeled_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabeled_statement(this);
}

myParser::Labeled_statementContext* myParser::labeled_statement() {
  Labeled_statementContext *_localctx = _tracker.createInstance<Labeled_statementContext>(_ctx, getState());
  enterRule(_localctx, 56, myParser::RuleLabeled_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(807);
    statement_label();
    setState(812);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::FOR:
      case myParser::WHILE:
      case myParser::REPEAT: {
        setState(808);
        loop_statement();
        break;
      }

      case myParser::IF: {
        setState(809);
        if_statement();
        break;
      }

      case myParser::SWITCH: {
        setState(810);
        switch_statement();
        break;
      }

      case myParser::DO: {
        setState(811);
        do_statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Statement_labelContext ------------------------------------------------------------------

myParser::Statement_labelContext::Statement_labelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Label_nameContext* myParser::Statement_labelContext::label_name() {
  return getRuleContext<myParser::Label_nameContext>(0);
}

tree::TerminalNode* myParser::Statement_labelContext::COLON() {
  return getToken(myParser::COLON, 0);
}


size_t myParser::Statement_labelContext::getRuleIndex() const {
  return myParser::RuleStatement_label;
}

void myParser::Statement_labelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement_label(this);
}

void myParser::Statement_labelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement_label(this);
}

myParser::Statement_labelContext* myParser::statement_label() {
  Statement_labelContext *_localctx = _tracker.createInstance<Statement_labelContext>(_ctx, getState());
  enterRule(_localctx, 58, myParser::RuleStatement_label);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(814);
    label_name();
    setState(815);
    match(myParser::COLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Label_nameContext ------------------------------------------------------------------

myParser::Label_nameContext::Label_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::Label_nameContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}


size_t myParser::Label_nameContext::getRuleIndex() const {
  return myParser::RuleLabel_name;
}

void myParser::Label_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabel_name(this);
}

void myParser::Label_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabel_name(this);
}

myParser::Label_nameContext* myParser::label_name() {
  Label_nameContext *_localctx = _tracker.createInstance<Label_nameContext>(_ctx, getState());
  enterRule(_localctx, 60, myParser::RuleLabel_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(817);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Control_transfer_statementContext ------------------------------------------------------------------

myParser::Control_transfer_statementContext::Control_transfer_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Break_statementContext* myParser::Control_transfer_statementContext::break_statement() {
  return getRuleContext<myParser::Break_statementContext>(0);
}

myParser::Continue_statementContext* myParser::Control_transfer_statementContext::continue_statement() {
  return getRuleContext<myParser::Continue_statementContext>(0);
}

myParser::Fallthrough_statementContext* myParser::Control_transfer_statementContext::fallthrough_statement() {
  return getRuleContext<myParser::Fallthrough_statementContext>(0);
}

myParser::Return_statementContext* myParser::Control_transfer_statementContext::return_statement() {
  return getRuleContext<myParser::Return_statementContext>(0);
}

myParser::Throw_statementContext* myParser::Control_transfer_statementContext::throw_statement() {
  return getRuleContext<myParser::Throw_statementContext>(0);
}


size_t myParser::Control_transfer_statementContext::getRuleIndex() const {
  return myParser::RuleControl_transfer_statement;
}

void myParser::Control_transfer_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterControl_transfer_statement(this);
}

void myParser::Control_transfer_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitControl_transfer_statement(this);
}

myParser::Control_transfer_statementContext* myParser::control_transfer_statement() {
  Control_transfer_statementContext *_localctx = _tracker.createInstance<Control_transfer_statementContext>(_ctx, getState());
  enterRule(_localctx, 62, myParser::RuleControl_transfer_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(824);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::BREAK: {
        enterOuterAlt(_localctx, 1);
        setState(819);
        break_statement();
        break;
      }

      case myParser::CONTINUE: {
        enterOuterAlt(_localctx, 2);
        setState(820);
        continue_statement();
        break;
      }

      case myParser::FALLTHROUGH: {
        enterOuterAlt(_localctx, 3);
        setState(821);
        fallthrough_statement();
        break;
      }

      case myParser::RETURN: {
        enterOuterAlt(_localctx, 4);
        setState(822);
        return_statement();
        break;
      }

      case myParser::THROW: {
        enterOuterAlt(_localctx, 5);
        setState(823);
        throw_statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Break_statementContext ------------------------------------------------------------------

myParser::Break_statementContext::Break_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Break_statementContext::BREAK() {
  return getToken(myParser::BREAK, 0);
}

myParser::Label_nameContext* myParser::Break_statementContext::label_name() {
  return getRuleContext<myParser::Label_nameContext>(0);
}


size_t myParser::Break_statementContext::getRuleIndex() const {
  return myParser::RuleBreak_statement;
}

void myParser::Break_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBreak_statement(this);
}

void myParser::Break_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBreak_statement(this);
}

myParser::Break_statementContext* myParser::break_statement() {
  Break_statementContext *_localctx = _tracker.createInstance<Break_statementContext>(_ctx, getState());
  enterRule(_localctx, 64, myParser::RuleBreak_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(826);
    match(myParser::BREAK);
    setState(828);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
    case 1: {
      setState(827);
      label_name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Continue_statementContext ------------------------------------------------------------------

myParser::Continue_statementContext::Continue_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Continue_statementContext::CONTINUE() {
  return getToken(myParser::CONTINUE, 0);
}

myParser::Label_nameContext* myParser::Continue_statementContext::label_name() {
  return getRuleContext<myParser::Label_nameContext>(0);
}


size_t myParser::Continue_statementContext::getRuleIndex() const {
  return myParser::RuleContinue_statement;
}

void myParser::Continue_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContinue_statement(this);
}

void myParser::Continue_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContinue_statement(this);
}

myParser::Continue_statementContext* myParser::continue_statement() {
  Continue_statementContext *_localctx = _tracker.createInstance<Continue_statementContext>(_ctx, getState());
  enterRule(_localctx, 66, myParser::RuleContinue_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(830);
    match(myParser::CONTINUE);
    setState(832);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
    case 1: {
      setState(831);
      label_name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fallthrough_statementContext ------------------------------------------------------------------

myParser::Fallthrough_statementContext::Fallthrough_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Fallthrough_statementContext::FALLTHROUGH() {
  return getToken(myParser::FALLTHROUGH, 0);
}


size_t myParser::Fallthrough_statementContext::getRuleIndex() const {
  return myParser::RuleFallthrough_statement;
}

void myParser::Fallthrough_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFallthrough_statement(this);
}

void myParser::Fallthrough_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFallthrough_statement(this);
}

myParser::Fallthrough_statementContext* myParser::fallthrough_statement() {
  Fallthrough_statementContext *_localctx = _tracker.createInstance<Fallthrough_statementContext>(_ctx, getState());
  enterRule(_localctx, 68, myParser::RuleFallthrough_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(834);
    match(myParser::FALLTHROUGH);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Return_statementContext ------------------------------------------------------------------

myParser::Return_statementContext::Return_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Return_statementContext::RETURN() {
  return getToken(myParser::RETURN, 0);
}

myParser::ExpressionContext* myParser::Return_statementContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}


size_t myParser::Return_statementContext::getRuleIndex() const {
  return myParser::RuleReturn_statement;
}

void myParser::Return_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturn_statement(this);
}

void myParser::Return_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturn_statement(this);
}

myParser::Return_statementContext* myParser::return_statement() {
  Return_statementContext *_localctx = _tracker.createInstance<Return_statementContext>(_ctx, getState());
  enterRule(_localctx, 70, myParser::RuleReturn_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(836);
    match(myParser::RETURN);
    setState(838);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
    case 1: {
      setState(837);
      expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Throw_statementContext ------------------------------------------------------------------

myParser::Throw_statementContext::Throw_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Throw_statementContext::THROW() {
  return getToken(myParser::THROW, 0);
}

myParser::ExpressionContext* myParser::Throw_statementContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}


size_t myParser::Throw_statementContext::getRuleIndex() const {
  return myParser::RuleThrow_statement;
}

void myParser::Throw_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrow_statement(this);
}

void myParser::Throw_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrow_statement(this);
}

myParser::Throw_statementContext* myParser::throw_statement() {
  Throw_statementContext *_localctx = _tracker.createInstance<Throw_statementContext>(_ctx, getState());
  enterRule(_localctx, 72, myParser::RuleThrow_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(840);
    match(myParser::THROW);
    setState(841);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Defer_statementContext ------------------------------------------------------------------

myParser::Defer_statementContext::Defer_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Defer_statementContext::DEFER() {
  return getToken(myParser::DEFER, 0);
}

myParser::Code_blockContext* myParser::Defer_statementContext::code_block() {
  return getRuleContext<myParser::Code_blockContext>(0);
}


size_t myParser::Defer_statementContext::getRuleIndex() const {
  return myParser::RuleDefer_statement;
}

void myParser::Defer_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefer_statement(this);
}

void myParser::Defer_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefer_statement(this);
}

myParser::Defer_statementContext* myParser::defer_statement() {
  Defer_statementContext *_localctx = _tracker.createInstance<Defer_statementContext>(_ctx, getState());
  enterRule(_localctx, 74, myParser::RuleDefer_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(843);
    match(myParser::DEFER);
    setState(844);
    code_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Do_statementContext ------------------------------------------------------------------

myParser::Do_statementContext::Do_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Do_statementContext::DO() {
  return getToken(myParser::DO, 0);
}

myParser::Code_blockContext* myParser::Do_statementContext::code_block() {
  return getRuleContext<myParser::Code_blockContext>(0);
}

myParser::Catch_clausesContext* myParser::Do_statementContext::catch_clauses() {
  return getRuleContext<myParser::Catch_clausesContext>(0);
}


size_t myParser::Do_statementContext::getRuleIndex() const {
  return myParser::RuleDo_statement;
}

void myParser::Do_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDo_statement(this);
}

void myParser::Do_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDo_statement(this);
}

myParser::Do_statementContext* myParser::do_statement() {
  Do_statementContext *_localctx = _tracker.createInstance<Do_statementContext>(_ctx, getState());
  enterRule(_localctx, 76, myParser::RuleDo_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(846);
    match(myParser::DO);
    setState(847);
    code_block();
    setState(849);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {
    case 1: {
      setState(848);
      catch_clauses();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Catch_clausesContext ------------------------------------------------------------------

myParser::Catch_clausesContext::Catch_clausesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Catch_clauseContext *> myParser::Catch_clausesContext::catch_clause() {
  return getRuleContexts<myParser::Catch_clauseContext>();
}

myParser::Catch_clauseContext* myParser::Catch_clausesContext::catch_clause(size_t i) {
  return getRuleContext<myParser::Catch_clauseContext>(i);
}


size_t myParser::Catch_clausesContext::getRuleIndex() const {
  return myParser::RuleCatch_clauses;
}

void myParser::Catch_clausesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCatch_clauses(this);
}

void myParser::Catch_clausesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCatch_clauses(this);
}

myParser::Catch_clausesContext* myParser::catch_clauses() {
  Catch_clausesContext *_localctx = _tracker.createInstance<Catch_clausesContext>(_ctx, getState());
  enterRule(_localctx, 78, myParser::RuleCatch_clauses);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(852); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(851);
              catch_clause();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(854); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Catch_clauseContext ------------------------------------------------------------------

myParser::Catch_clauseContext::Catch_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Catch_clauseContext::CATCH() {
  return getToken(myParser::CATCH, 0);
}

myParser::Code_blockContext* myParser::Catch_clauseContext::code_block() {
  return getRuleContext<myParser::Code_blockContext>(0);
}

myParser::Catch_pattern_listContext* myParser::Catch_clauseContext::catch_pattern_list() {
  return getRuleContext<myParser::Catch_pattern_listContext>(0);
}


size_t myParser::Catch_clauseContext::getRuleIndex() const {
  return myParser::RuleCatch_clause;
}

void myParser::Catch_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCatch_clause(this);
}

void myParser::Catch_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCatch_clause(this);
}

myParser::Catch_clauseContext* myParser::catch_clause() {
  Catch_clauseContext *_localctx = _tracker.createInstance<Catch_clauseContext>(_ctx, getState());
  enterRule(_localctx, 80, myParser::RuleCatch_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(856);
    match(myParser::CATCH);
    setState(858);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
    case 1: {
      setState(857);
      catch_pattern_list();
      break;
    }

    default:
      break;
    }
    setState(860);
    code_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Catch_pattern_listContext ------------------------------------------------------------------

myParser::Catch_pattern_listContext::Catch_pattern_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Catch_patternContext *> myParser::Catch_pattern_listContext::catch_pattern() {
  return getRuleContexts<myParser::Catch_patternContext>();
}

myParser::Catch_patternContext* myParser::Catch_pattern_listContext::catch_pattern(size_t i) {
  return getRuleContext<myParser::Catch_patternContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Catch_pattern_listContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Catch_pattern_listContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Catch_pattern_listContext::getRuleIndex() const {
  return myParser::RuleCatch_pattern_list;
}

void myParser::Catch_pattern_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCatch_pattern_list(this);
}

void myParser::Catch_pattern_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCatch_pattern_list(this);
}

myParser::Catch_pattern_listContext* myParser::catch_pattern_list() {
  Catch_pattern_listContext *_localctx = _tracker.createInstance<Catch_pattern_listContext>(_ctx, getState());
  enterRule(_localctx, 82, myParser::RuleCatch_pattern_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(862);
    catch_pattern();
    setState(869);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(863);
        catch_pattern();
        setState(864);
        match(myParser::COMMA);
        setState(865);
        catch_pattern(); 
      }
      setState(871);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Catch_patternContext ------------------------------------------------------------------

myParser::Catch_patternContext::Catch_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::PatternContext* myParser::Catch_patternContext::pattern() {
  return getRuleContext<myParser::PatternContext>(0);
}

myParser::Where_clauseContext* myParser::Catch_patternContext::where_clause() {
  return getRuleContext<myParser::Where_clauseContext>(0);
}


size_t myParser::Catch_patternContext::getRuleIndex() const {
  return myParser::RuleCatch_pattern;
}

void myParser::Catch_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCatch_pattern(this);
}

void myParser::Catch_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCatch_pattern(this);
}

myParser::Catch_patternContext* myParser::catch_pattern() {
  Catch_patternContext *_localctx = _tracker.createInstance<Catch_patternContext>(_ctx, getState());
  enterRule(_localctx, 84, myParser::RuleCatch_pattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(872);
    pattern(0);
    setState(874);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
    case 1: {
      setState(873);
      where_clause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Compiler_control_statementContext ------------------------------------------------------------------

myParser::Compiler_control_statementContext::Compiler_control_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Conditional_compilation_blockContext* myParser::Compiler_control_statementContext::conditional_compilation_block() {
  return getRuleContext<myParser::Conditional_compilation_blockContext>(0);
}

myParser::Line_control_statementContext* myParser::Compiler_control_statementContext::line_control_statement() {
  return getRuleContext<myParser::Line_control_statementContext>(0);
}

myParser::Diagnostic_statementContext* myParser::Compiler_control_statementContext::diagnostic_statement() {
  return getRuleContext<myParser::Diagnostic_statementContext>(0);
}


size_t myParser::Compiler_control_statementContext::getRuleIndex() const {
  return myParser::RuleCompiler_control_statement;
}

void myParser::Compiler_control_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompiler_control_statement(this);
}

void myParser::Compiler_control_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompiler_control_statement(this);
}

myParser::Compiler_control_statementContext* myParser::compiler_control_statement() {
  Compiler_control_statementContext *_localctx = _tracker.createInstance<Compiler_control_statementContext>(_ctx, getState());
  enterRule(_localctx, 86, myParser::RuleCompiler_control_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(879);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::HASH_IF: {
        enterOuterAlt(_localctx, 1);
        setState(876);
        conditional_compilation_block();
        break;
      }

      case myParser::SOURCE_LOCATION: {
        enterOuterAlt(_localctx, 2);
        setState(877);
        line_control_statement();
        break;
      }

      case myParser::ERROR:
      case myParser::WARNING: {
        enterOuterAlt(_localctx, 3);
        setState(878);
        diagnostic_statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Conditional_compilation_blockContext ------------------------------------------------------------------

myParser::Conditional_compilation_blockContext::Conditional_compilation_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::If_directive_clauseContext* myParser::Conditional_compilation_blockContext::if_directive_clause() {
  return getRuleContext<myParser::If_directive_clauseContext>(0);
}

tree::TerminalNode* myParser::Conditional_compilation_blockContext::HASH_ENDIF() {
  return getToken(myParser::HASH_ENDIF, 0);
}

myParser::Elseif_directive_clausesContext* myParser::Conditional_compilation_blockContext::elseif_directive_clauses() {
  return getRuleContext<myParser::Elseif_directive_clausesContext>(0);
}

myParser::Else_directive_clauseContext* myParser::Conditional_compilation_blockContext::else_directive_clause() {
  return getRuleContext<myParser::Else_directive_clauseContext>(0);
}


size_t myParser::Conditional_compilation_blockContext::getRuleIndex() const {
  return myParser::RuleConditional_compilation_block;
}

void myParser::Conditional_compilation_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditional_compilation_block(this);
}

void myParser::Conditional_compilation_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditional_compilation_block(this);
}

myParser::Conditional_compilation_blockContext* myParser::conditional_compilation_block() {
  Conditional_compilation_blockContext *_localctx = _tracker.createInstance<Conditional_compilation_blockContext>(_ctx, getState());
  enterRule(_localctx, 88, myParser::RuleConditional_compilation_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(881);
    if_directive_clause();
    setState(883);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::HASH_ELSEIF) {
      setState(882);
      elseif_directive_clauses();
    }
    setState(886);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::HASH_ELSE) {
      setState(885);
      else_directive_clause();
    }
    setState(888);
    match(myParser::HASH_ENDIF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_directive_clauseContext ------------------------------------------------------------------

myParser::If_directive_clauseContext::If_directive_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::If_directive_clauseContext::HASH_IF() {
  return getToken(myParser::HASH_IF, 0);
}

myParser::Compilation_conditionContext* myParser::If_directive_clauseContext::compilation_condition() {
  return getRuleContext<myParser::Compilation_conditionContext>(0);
}

myParser::StatementsContext* myParser::If_directive_clauseContext::statements() {
  return getRuleContext<myParser::StatementsContext>(0);
}


size_t myParser::If_directive_clauseContext::getRuleIndex() const {
  return myParser::RuleIf_directive_clause;
}

void myParser::If_directive_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_directive_clause(this);
}

void myParser::If_directive_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_directive_clause(this);
}

myParser::If_directive_clauseContext* myParser::if_directive_clause() {
  If_directive_clauseContext *_localctx = _tracker.createInstance<If_directive_clauseContext>(_ctx, getState());
  enterRule(_localctx, 90, myParser::RuleIf_directive_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(890);
    match(myParser::HASH_IF);
    setState(891);
    compilation_condition(0);
    setState(893);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx)) {
    case 1: {
      setState(892);
      statements();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Elseif_directive_clausesContext ------------------------------------------------------------------

myParser::Elseif_directive_clausesContext::Elseif_directive_clausesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Elseif_directive_clauseContext *> myParser::Elseif_directive_clausesContext::elseif_directive_clause() {
  return getRuleContexts<myParser::Elseif_directive_clauseContext>();
}

myParser::Elseif_directive_clauseContext* myParser::Elseif_directive_clausesContext::elseif_directive_clause(size_t i) {
  return getRuleContext<myParser::Elseif_directive_clauseContext>(i);
}


size_t myParser::Elseif_directive_clausesContext::getRuleIndex() const {
  return myParser::RuleElseif_directive_clauses;
}

void myParser::Elseif_directive_clausesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElseif_directive_clauses(this);
}

void myParser::Elseif_directive_clausesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElseif_directive_clauses(this);
}

myParser::Elseif_directive_clausesContext* myParser::elseif_directive_clauses() {
  Elseif_directive_clausesContext *_localctx = _tracker.createInstance<Elseif_directive_clausesContext>(_ctx, getState());
  enterRule(_localctx, 92, myParser::RuleElseif_directive_clauses);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(896); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(895);
      elseif_directive_clause();
      setState(898); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == myParser::HASH_ELSEIF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Elseif_directive_clauseContext ------------------------------------------------------------------

myParser::Elseif_directive_clauseContext::Elseif_directive_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Elseif_directive_clauseContext::HASH_ELSEIF() {
  return getToken(myParser::HASH_ELSEIF, 0);
}

myParser::Compilation_conditionContext* myParser::Elseif_directive_clauseContext::compilation_condition() {
  return getRuleContext<myParser::Compilation_conditionContext>(0);
}

myParser::StatementsContext* myParser::Elseif_directive_clauseContext::statements() {
  return getRuleContext<myParser::StatementsContext>(0);
}


size_t myParser::Elseif_directive_clauseContext::getRuleIndex() const {
  return myParser::RuleElseif_directive_clause;
}

void myParser::Elseif_directive_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElseif_directive_clause(this);
}

void myParser::Elseif_directive_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElseif_directive_clause(this);
}

myParser::Elseif_directive_clauseContext* myParser::elseif_directive_clause() {
  Elseif_directive_clauseContext *_localctx = _tracker.createInstance<Elseif_directive_clauseContext>(_ctx, getState());
  enterRule(_localctx, 94, myParser::RuleElseif_directive_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(900);
    match(myParser::HASH_ELSEIF);
    setState(901);
    compilation_condition(0);
    setState(903);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
    case 1: {
      setState(902);
      statements();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Else_directive_clauseContext ------------------------------------------------------------------

myParser::Else_directive_clauseContext::Else_directive_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Else_directive_clauseContext::HASH_ELSE() {
  return getToken(myParser::HASH_ELSE, 0);
}

myParser::StatementsContext* myParser::Else_directive_clauseContext::statements() {
  return getRuleContext<myParser::StatementsContext>(0);
}


size_t myParser::Else_directive_clauseContext::getRuleIndex() const {
  return myParser::RuleElse_directive_clause;
}

void myParser::Else_directive_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElse_directive_clause(this);
}

void myParser::Else_directive_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElse_directive_clause(this);
}

myParser::Else_directive_clauseContext* myParser::else_directive_clause() {
  Else_directive_clauseContext *_localctx = _tracker.createInstance<Else_directive_clauseContext>(_ctx, getState());
  enterRule(_localctx, 96, myParser::RuleElse_directive_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(905);
    match(myParser::HASH_ELSE);
    setState(907);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
    case 1: {
      setState(906);
      statements();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Compilation_conditionContext ------------------------------------------------------------------

myParser::Compilation_conditionContext::Compilation_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Platform_conditionContext* myParser::Compilation_conditionContext::platform_condition() {
  return getRuleContext<myParser::Platform_conditionContext>(0);
}

myParser::IdentifierContext* myParser::Compilation_conditionContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::Boolean_literalContext* myParser::Compilation_conditionContext::boolean_literal() {
  return getRuleContext<myParser::Boolean_literalContext>(0);
}

tree::TerminalNode* myParser::Compilation_conditionContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

std::vector<myParser::Compilation_conditionContext *> myParser::Compilation_conditionContext::compilation_condition() {
  return getRuleContexts<myParser::Compilation_conditionContext>();
}

myParser::Compilation_conditionContext* myParser::Compilation_conditionContext::compilation_condition(size_t i) {
  return getRuleContext<myParser::Compilation_conditionContext>(i);
}

tree::TerminalNode* myParser::Compilation_conditionContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

tree::TerminalNode* myParser::Compilation_conditionContext::BANG() {
  return getToken(myParser::BANG, 0);
}

myParser::Compilation_condition_ANDContext* myParser::Compilation_conditionContext::compilation_condition_AND() {
  return getRuleContext<myParser::Compilation_condition_ANDContext>(0);
}

myParser::Compilation_condition_ORContext* myParser::Compilation_conditionContext::compilation_condition_OR() {
  return getRuleContext<myParser::Compilation_condition_ORContext>(0);
}


size_t myParser::Compilation_conditionContext::getRuleIndex() const {
  return myParser::RuleCompilation_condition;
}

void myParser::Compilation_conditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompilation_condition(this);
}

void myParser::Compilation_conditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompilation_condition(this);
}


myParser::Compilation_conditionContext* myParser::compilation_condition() {
   return compilation_condition(0);
}

myParser::Compilation_conditionContext* myParser::compilation_condition(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  myParser::Compilation_conditionContext *_localctx = _tracker.createInstance<Compilation_conditionContext>(_ctx, parentState);
  myParser::Compilation_conditionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 98;
  enterRecursionRule(_localctx, 98, myParser::RuleCompilation_condition, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(919);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx)) {
    case 1: {
      setState(910);
      platform_condition();
      break;
    }

    case 2: {
      setState(911);
      identifier();
      break;
    }

    case 3: {
      setState(912);
      boolean_literal();
      break;
    }

    case 4: {
      setState(913);
      match(myParser::LPAREN);
      setState(914);
      compilation_condition(0);
      setState(915);
      match(myParser::RPAREN);
      break;
    }

    case 5: {
      setState(917);
      match(myParser::BANG);
      setState(918);
      compilation_condition(2);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(930);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<Compilation_conditionContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleCompilation_condition);
        setState(921);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(924);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx)) {
        case 1: {
          setState(922);
          compilation_condition_AND();
          break;
        }

        case 2: {
          setState(923);
          compilation_condition_OR();
          break;
        }

        default:
          break;
        }
        setState(926);
        compilation_condition(2); 
      }
      setState(932);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Platform_conditionContext ------------------------------------------------------------------

myParser::Platform_conditionContext::Platform_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Platform_conditionContext::OS() {
  return getToken(myParser::OS, 0);
}

tree::TerminalNode* myParser::Platform_conditionContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::Operating_systemContext* myParser::Platform_conditionContext::operating_system() {
  return getRuleContext<myParser::Operating_systemContext>(0);
}

tree::TerminalNode* myParser::Platform_conditionContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

tree::TerminalNode* myParser::Platform_conditionContext::ARCH() {
  return getToken(myParser::ARCH, 0);
}

myParser::ArchitectureContext* myParser::Platform_conditionContext::architecture() {
  return getRuleContext<myParser::ArchitectureContext>(0);
}

myParser::Swift_versionContext* myParser::Platform_conditionContext::swift_version() {
  return getRuleContext<myParser::Swift_versionContext>(0);
}

tree::TerminalNode* myParser::Platform_conditionContext::SWIFT() {
  return getToken(myParser::SWIFT, 0);
}

tree::TerminalNode* myParser::Platform_conditionContext::COMPILER() {
  return getToken(myParser::COMPILER, 0);
}

myParser::Compilation_condition_GEContext* myParser::Platform_conditionContext::compilation_condition_GE() {
  return getRuleContext<myParser::Compilation_condition_GEContext>(0);
}

myParser::Compilation_condition_LContext* myParser::Platform_conditionContext::compilation_condition_L() {
  return getRuleContext<myParser::Compilation_condition_LContext>(0);
}

tree::TerminalNode* myParser::Platform_conditionContext::CAN_IMPORT() {
  return getToken(myParser::CAN_IMPORT, 0);
}

myParser::Module_nameContext* myParser::Platform_conditionContext::module_name() {
  return getRuleContext<myParser::Module_nameContext>(0);
}

tree::TerminalNode* myParser::Platform_conditionContext::TARGET_ENVIRONMENT() {
  return getToken(myParser::TARGET_ENVIRONMENT, 0);
}

myParser::EnvironmentContext* myParser::Platform_conditionContext::environment() {
  return getRuleContext<myParser::EnvironmentContext>(0);
}


size_t myParser::Platform_conditionContext::getRuleIndex() const {
  return myParser::RulePlatform_condition;
}

void myParser::Platform_conditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlatform_condition(this);
}

void myParser::Platform_conditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlatform_condition(this);
}

myParser::Platform_conditionContext* myParser::platform_condition() {
  Platform_conditionContext *_localctx = _tracker.createInstance<Platform_conditionContext>(_ctx, getState());
  enterRule(_localctx, 100, myParser::RulePlatform_condition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(962);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::OS: {
        enterOuterAlt(_localctx, 1);
        setState(933);
        match(myParser::OS);
        setState(934);
        match(myParser::LPAREN);
        setState(935);
        operating_system();
        setState(936);
        match(myParser::RPAREN);
        break;
      }

      case myParser::ARCH: {
        enterOuterAlt(_localctx, 2);
        setState(938);
        match(myParser::ARCH);
        setState(939);
        match(myParser::LPAREN);
        setState(940);
        architecture();
        setState(941);
        match(myParser::RPAREN);
        break;
      }

      case myParser::SWIFT:
      case myParser::COMPILER: {
        enterOuterAlt(_localctx, 3);
        setState(943);
        _la = _input->LA(1);
        if (!(_la == myParser::SWIFT

        || _la == myParser::COMPILER)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(944);
        match(myParser::LPAREN);
        setState(947);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx)) {
        case 1: {
          setState(945);
          compilation_condition_GE();
          break;
        }

        case 2: {
          setState(946);
          compilation_condition_L();
          break;
        }

        default:
          break;
        }
        setState(949);
        swift_version();
        setState(950);
        match(myParser::RPAREN);
        break;
      }

      case myParser::CAN_IMPORT: {
        enterOuterAlt(_localctx, 4);
        setState(952);
        match(myParser::CAN_IMPORT);
        setState(953);
        match(myParser::LPAREN);
        setState(954);
        module_name();
        setState(955);
        match(myParser::RPAREN);
        break;
      }

      case myParser::TARGET_ENVIRONMENT: {
        enterOuterAlt(_localctx, 5);
        setState(957);
        match(myParser::TARGET_ENVIRONMENT);
        setState(958);
        match(myParser::LPAREN);
        setState(959);
        environment();
        setState(960);
        match(myParser::RPAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Swift_versionContext ------------------------------------------------------------------

myParser::Swift_versionContext::Swift_versionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Swift_versionContext::Decimal_digits() {
  return getToken(myParser::Decimal_digits, 0);
}

myParser::Swift_version_continuationContext* myParser::Swift_versionContext::swift_version_continuation() {
  return getRuleContext<myParser::Swift_version_continuationContext>(0);
}


size_t myParser::Swift_versionContext::getRuleIndex() const {
  return myParser::RuleSwift_version;
}

void myParser::Swift_versionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwift_version(this);
}

void myParser::Swift_versionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwift_version(this);
}

myParser::Swift_versionContext* myParser::swift_version() {
  Swift_versionContext *_localctx = _tracker.createInstance<Swift_versionContext>(_ctx, getState());
  enterRule(_localctx, 102, myParser::RuleSwift_version);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(964);
    match(myParser::Decimal_digits);
    setState(966);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::DOT) {
      setState(965);
      swift_version_continuation();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Swift_version_continuationContext ------------------------------------------------------------------

myParser::Swift_version_continuationContext::Swift_version_continuationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Swift_version_continuationContext::DOT() {
  return getToken(myParser::DOT, 0);
}

tree::TerminalNode* myParser::Swift_version_continuationContext::Decimal_digits() {
  return getToken(myParser::Decimal_digits, 0);
}

myParser::Swift_version_continuationContext* myParser::Swift_version_continuationContext::swift_version_continuation() {
  return getRuleContext<myParser::Swift_version_continuationContext>(0);
}


size_t myParser::Swift_version_continuationContext::getRuleIndex() const {
  return myParser::RuleSwift_version_continuation;
}

void myParser::Swift_version_continuationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwift_version_continuation(this);
}

void myParser::Swift_version_continuationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwift_version_continuation(this);
}

myParser::Swift_version_continuationContext* myParser::swift_version_continuation() {
  Swift_version_continuationContext *_localctx = _tracker.createInstance<Swift_version_continuationContext>(_ctx, getState());
  enterRule(_localctx, 104, myParser::RuleSwift_version_continuation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(968);
    match(myParser::DOT);
    setState(969);
    match(myParser::Decimal_digits);
    setState(971);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::DOT) {
      setState(970);
      swift_version_continuation();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Operating_systemContext ------------------------------------------------------------------

myParser::Operating_systemContext::Operating_systemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Operating_systemContext::MAC_OS() {
  return getToken(myParser::MAC_OS, 0);
}

tree::TerminalNode* myParser::Operating_systemContext::I_OS() {
  return getToken(myParser::I_OS, 0);
}

tree::TerminalNode* myParser::Operating_systemContext::OSX() {
  return getToken(myParser::OSX, 0);
}

tree::TerminalNode* myParser::Operating_systemContext::WATCH_OS() {
  return getToken(myParser::WATCH_OS, 0);
}

tree::TerminalNode* myParser::Operating_systemContext::TV_OS() {
  return getToken(myParser::TV_OS, 0);
}

tree::TerminalNode* myParser::Operating_systemContext::LINUX() {
  return getToken(myParser::LINUX, 0);
}

tree::TerminalNode* myParser::Operating_systemContext::WINDOWS() {
  return getToken(myParser::WINDOWS, 0);
}


size_t myParser::Operating_systemContext::getRuleIndex() const {
  return myParser::RuleOperating_system;
}

void myParser::Operating_systemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOperating_system(this);
}

void myParser::Operating_systemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOperating_system(this);
}

myParser::Operating_systemContext* myParser::operating_system() {
  Operating_systemContext *_localctx = _tracker.createInstance<Operating_systemContext>(_ctx, getState());
  enterRule(_localctx, 106, myParser::RuleOperating_system);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(973);
    _la = _input->LA(1);
    if (!(((((_la - 97) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 97)) & 127) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArchitectureContext ------------------------------------------------------------------

myParser::ArchitectureContext::ArchitectureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ArchitectureContext::I386() {
  return getToken(myParser::I386, 0);
}

tree::TerminalNode* myParser::ArchitectureContext::X86_64() {
  return getToken(myParser::X86_64, 0);
}

tree::TerminalNode* myParser::ArchitectureContext::ARM() {
  return getToken(myParser::ARM, 0);
}

tree::TerminalNode* myParser::ArchitectureContext::ARM64() {
  return getToken(myParser::ARM64, 0);
}


size_t myParser::ArchitectureContext::getRuleIndex() const {
  return myParser::RuleArchitecture;
}

void myParser::ArchitectureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArchitecture(this);
}

void myParser::ArchitectureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArchitecture(this);
}

myParser::ArchitectureContext* myParser::architecture() {
  ArchitectureContext *_localctx = _tracker.createInstance<ArchitectureContext>(_ctx, getState());
  enterRule(_localctx, 108, myParser::RuleArchitecture);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(975);
    _la = _input->LA(1);
    if (!(((((_la - 104) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 104)) & 15) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_nameContext ------------------------------------------------------------------

myParser::Module_nameContext::Module_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::IdentifierContext *> myParser::Module_nameContext::identifier() {
  return getRuleContexts<myParser::IdentifierContext>();
}

myParser::IdentifierContext* myParser::Module_nameContext::identifier(size_t i) {
  return getRuleContext<myParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Module_nameContext::DOT() {
  return getTokens(myParser::DOT);
}

tree::TerminalNode* myParser::Module_nameContext::DOT(size_t i) {
  return getToken(myParser::DOT, i);
}


size_t myParser::Module_nameContext::getRuleIndex() const {
  return myParser::RuleModule_name;
}

void myParser::Module_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_name(this);
}

void myParser::Module_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_name(this);
}

myParser::Module_nameContext* myParser::module_name() {
  Module_nameContext *_localctx = _tracker.createInstance<Module_nameContext>(_ctx, getState());
  enterRule(_localctx, 110, myParser::RuleModule_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(977);
    identifier();
    setState(982);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::DOT) {
      setState(978);
      match(myParser::DOT);
      setState(979);
      identifier();
      setState(984);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnvironmentContext ------------------------------------------------------------------

myParser::EnvironmentContext::EnvironmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::EnvironmentContext::SIMULATOR() {
  return getToken(myParser::SIMULATOR, 0);
}

tree::TerminalNode* myParser::EnvironmentContext::MAC_CATALYST() {
  return getToken(myParser::MAC_CATALYST, 0);
}


size_t myParser::EnvironmentContext::getRuleIndex() const {
  return myParser::RuleEnvironment;
}

void myParser::EnvironmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnvironment(this);
}

void myParser::EnvironmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnvironment(this);
}

myParser::EnvironmentContext* myParser::environment() {
  EnvironmentContext *_localctx = _tracker.createInstance<EnvironmentContext>(_ctx, getState());
  enterRule(_localctx, 112, myParser::RuleEnvironment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(985);
    _la = _input->LA(1);
    if (!(_la == myParser::SIMULATOR

    || _la == myParser::MAC_CATALYST)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Line_control_statementContext ------------------------------------------------------------------

myParser::Line_control_statementContext::Line_control_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Line_control_statementContext::SOURCE_LOCATION() {
  return getToken(myParser::SOURCE_LOCATION, 0);
}

tree::TerminalNode* myParser::Line_control_statementContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::Line_control_statementContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

tree::TerminalNode* myParser::Line_control_statementContext::FILE() {
  return getToken(myParser::FILE, 0);
}

std::vector<tree::TerminalNode *> myParser::Line_control_statementContext::COLON() {
  return getTokens(myParser::COLON);
}

tree::TerminalNode* myParser::Line_control_statementContext::COLON(size_t i) {
  return getToken(myParser::COLON, i);
}

myParser::File_nameContext* myParser::Line_control_statementContext::file_name() {
  return getRuleContext<myParser::File_nameContext>(0);
}

tree::TerminalNode* myParser::Line_control_statementContext::COMMA() {
  return getToken(myParser::COMMA, 0);
}

tree::TerminalNode* myParser::Line_control_statementContext::LINE() {
  return getToken(myParser::LINE, 0);
}

myParser::Line_numberContext* myParser::Line_control_statementContext::line_number() {
  return getRuleContext<myParser::Line_numberContext>(0);
}


size_t myParser::Line_control_statementContext::getRuleIndex() const {
  return myParser::RuleLine_control_statement;
}

void myParser::Line_control_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLine_control_statement(this);
}

void myParser::Line_control_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLine_control_statement(this);
}

myParser::Line_control_statementContext* myParser::line_control_statement() {
  Line_control_statementContext *_localctx = _tracker.createInstance<Line_control_statementContext>(_ctx, getState());
  enterRule(_localctx, 114, myParser::RuleLine_control_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(987);
    match(myParser::SOURCE_LOCATION);
    setState(988);
    match(myParser::LPAREN);
    setState(997);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::FILE) {
      setState(989);
      match(myParser::FILE);
      setState(990);
      match(myParser::COLON);
      setState(991);
      file_name();
      setState(992);
      match(myParser::COMMA);
      setState(993);
      match(myParser::LINE);
      setState(994);
      match(myParser::COLON);
      setState(995);
      line_number();
    }
    setState(999);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Line_numberContext ------------------------------------------------------------------

myParser::Line_numberContext::Line_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Line_numberContext::Decimal_literal() {
  return getToken(myParser::Decimal_literal, 0);
}


size_t myParser::Line_numberContext::getRuleIndex() const {
  return myParser::RuleLine_number;
}

void myParser::Line_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLine_number(this);
}

void myParser::Line_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLine_number(this);
}

myParser::Line_numberContext* myParser::line_number() {
  Line_numberContext *_localctx = _tracker.createInstance<Line_numberContext>(_ctx, getState());
  enterRule(_localctx, 116, myParser::RuleLine_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1001);
    match(myParser::Decimal_literal);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_nameContext ------------------------------------------------------------------

myParser::File_nameContext::File_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Static_string_literalContext* myParser::File_nameContext::static_string_literal() {
  return getRuleContext<myParser::Static_string_literalContext>(0);
}


size_t myParser::File_nameContext::getRuleIndex() const {
  return myParser::RuleFile_name;
}

void myParser::File_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFile_name(this);
}

void myParser::File_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFile_name(this);
}

myParser::File_nameContext* myParser::file_name() {
  File_nameContext *_localctx = _tracker.createInstance<File_nameContext>(_ctx, getState());
  enterRule(_localctx, 118, myParser::RuleFile_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1003);
    static_string_literal();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Diagnostic_statementContext ------------------------------------------------------------------

myParser::Diagnostic_statementContext::Diagnostic_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Diagnostic_statementContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::Diagnostic_messageContext* myParser::Diagnostic_statementContext::diagnostic_message() {
  return getRuleContext<myParser::Diagnostic_messageContext>(0);
}

tree::TerminalNode* myParser::Diagnostic_statementContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

tree::TerminalNode* myParser::Diagnostic_statementContext::ERROR() {
  return getToken(myParser::ERROR, 0);
}

tree::TerminalNode* myParser::Diagnostic_statementContext::WARNING() {
  return getToken(myParser::WARNING, 0);
}


size_t myParser::Diagnostic_statementContext::getRuleIndex() const {
  return myParser::RuleDiagnostic_statement;
}

void myParser::Diagnostic_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDiagnostic_statement(this);
}

void myParser::Diagnostic_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDiagnostic_statement(this);
}

myParser::Diagnostic_statementContext* myParser::diagnostic_statement() {
  Diagnostic_statementContext *_localctx = _tracker.createInstance<Diagnostic_statementContext>(_ctx, getState());
  enterRule(_localctx, 120, myParser::RuleDiagnostic_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1005);
    _la = _input->LA(1);
    if (!(_la == myParser::ERROR

    || _la == myParser::WARNING)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1006);
    match(myParser::LPAREN);
    setState(1007);
    diagnostic_message();
    setState(1008);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Diagnostic_messageContext ------------------------------------------------------------------

myParser::Diagnostic_messageContext::Diagnostic_messageContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Static_string_literalContext* myParser::Diagnostic_messageContext::static_string_literal() {
  return getRuleContext<myParser::Static_string_literalContext>(0);
}


size_t myParser::Diagnostic_messageContext::getRuleIndex() const {
  return myParser::RuleDiagnostic_message;
}

void myParser::Diagnostic_messageContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDiagnostic_message(this);
}

void myParser::Diagnostic_messageContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDiagnostic_message(this);
}

myParser::Diagnostic_messageContext* myParser::diagnostic_message() {
  Diagnostic_messageContext *_localctx = _tracker.createInstance<Diagnostic_messageContext>(_ctx, getState());
  enterRule(_localctx, 122, myParser::RuleDiagnostic_message);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1010);
    static_string_literal();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Availability_conditionContext ------------------------------------------------------------------

myParser::Availability_conditionContext::Availability_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Availability_conditionContext::AVAILABLE() {
  return getToken(myParser::AVAILABLE, 0);
}

tree::TerminalNode* myParser::Availability_conditionContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::Availability_argumentsContext* myParser::Availability_conditionContext::availability_arguments() {
  return getRuleContext<myParser::Availability_argumentsContext>(0);
}

tree::TerminalNode* myParser::Availability_conditionContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}


size_t myParser::Availability_conditionContext::getRuleIndex() const {
  return myParser::RuleAvailability_condition;
}

void myParser::Availability_conditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAvailability_condition(this);
}

void myParser::Availability_conditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAvailability_condition(this);
}

myParser::Availability_conditionContext* myParser::availability_condition() {
  Availability_conditionContext *_localctx = _tracker.createInstance<Availability_conditionContext>(_ctx, getState());
  enterRule(_localctx, 124, myParser::RuleAvailability_condition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1012);
    match(myParser::AVAILABLE);
    setState(1013);
    match(myParser::LPAREN);
    setState(1014);
    availability_arguments();
    setState(1015);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Availability_argumentsContext ------------------------------------------------------------------

myParser::Availability_argumentsContext::Availability_argumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Availability_argumentContext *> myParser::Availability_argumentsContext::availability_argument() {
  return getRuleContexts<myParser::Availability_argumentContext>();
}

myParser::Availability_argumentContext* myParser::Availability_argumentsContext::availability_argument(size_t i) {
  return getRuleContext<myParser::Availability_argumentContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Availability_argumentsContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Availability_argumentsContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Availability_argumentsContext::getRuleIndex() const {
  return myParser::RuleAvailability_arguments;
}

void myParser::Availability_argumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAvailability_arguments(this);
}

void myParser::Availability_argumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAvailability_arguments(this);
}

myParser::Availability_argumentsContext* myParser::availability_arguments() {
  Availability_argumentsContext *_localctx = _tracker.createInstance<Availability_argumentsContext>(_ctx, getState());
  enterRule(_localctx, 126, myParser::RuleAvailability_arguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1017);
    availability_argument();
    setState(1022);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(1018);
      match(myParser::COMMA);
      setState(1019);
      availability_argument();
      setState(1024);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Availability_argumentContext ------------------------------------------------------------------

myParser::Availability_argumentContext::Availability_argumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Platform_nameContext* myParser::Availability_argumentContext::platform_name() {
  return getRuleContext<myParser::Platform_nameContext>(0);
}

myParser::Platform_versionContext* myParser::Availability_argumentContext::platform_version() {
  return getRuleContext<myParser::Platform_versionContext>(0);
}

tree::TerminalNode* myParser::Availability_argumentContext::MUL() {
  return getToken(myParser::MUL, 0);
}


size_t myParser::Availability_argumentContext::getRuleIndex() const {
  return myParser::RuleAvailability_argument;
}

void myParser::Availability_argumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAvailability_argument(this);
}

void myParser::Availability_argumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAvailability_argument(this);
}

myParser::Availability_argumentContext* myParser::availability_argument() {
  Availability_argumentContext *_localctx = _tracker.createInstance<Availability_argumentContext>(_ctx, getState());
  enterRule(_localctx, 128, myParser::RuleAvailability_argument);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1029);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::MAC_OS:
      case myParser::I_OS:
      case myParser::OSX:
      case myParser::WATCH_OS:
      case myParser::TV_OS:
      case myParser::MAC_CATALYST:
      case myParser::I_OS_APPLICATION_EXTENSION:
      case myParser::MAC_CATALYST_APPLICATION_EXTENSION:
      case myParser::MAC_OS_APPLICATION_EXTENSION: {
        enterOuterAlt(_localctx, 1);
        setState(1025);
        platform_name();
        setState(1026);
        platform_version();
        break;
      }

      case myParser::MUL: {
        enterOuterAlt(_localctx, 2);
        setState(1028);
        match(myParser::MUL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Platform_nameContext ------------------------------------------------------------------

myParser::Platform_nameContext::Platform_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Platform_nameContext::I_OS() {
  return getToken(myParser::I_OS, 0);
}

tree::TerminalNode* myParser::Platform_nameContext::OSX() {
  return getToken(myParser::OSX, 0);
}

tree::TerminalNode* myParser::Platform_nameContext::I_OS_APPLICATION_EXTENSION() {
  return getToken(myParser::I_OS_APPLICATION_EXTENSION, 0);
}

tree::TerminalNode* myParser::Platform_nameContext::MAC_OS() {
  return getToken(myParser::MAC_OS, 0);
}

tree::TerminalNode* myParser::Platform_nameContext::MAC_OS_APPLICATION_EXTENSION() {
  return getToken(myParser::MAC_OS_APPLICATION_EXTENSION, 0);
}

tree::TerminalNode* myParser::Platform_nameContext::MAC_CATALYST() {
  return getToken(myParser::MAC_CATALYST, 0);
}

tree::TerminalNode* myParser::Platform_nameContext::MAC_CATALYST_APPLICATION_EXTENSION() {
  return getToken(myParser::MAC_CATALYST_APPLICATION_EXTENSION, 0);
}

tree::TerminalNode* myParser::Platform_nameContext::WATCH_OS() {
  return getToken(myParser::WATCH_OS, 0);
}

tree::TerminalNode* myParser::Platform_nameContext::TV_OS() {
  return getToken(myParser::TV_OS, 0);
}


size_t myParser::Platform_nameContext::getRuleIndex() const {
  return myParser::RulePlatform_name;
}

void myParser::Platform_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlatform_name(this);
}

void myParser::Platform_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlatform_name(this);
}

myParser::Platform_nameContext* myParser::platform_name() {
  Platform_nameContext *_localctx = _tracker.createInstance<Platform_nameContext>(_ctx, getState());
  enterRule(_localctx, 130, myParser::RulePlatform_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1031);
    _la = _input->LA(1);
    if (!(((((_la - 97) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 97)) & 61471) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Platform_versionContext ------------------------------------------------------------------

myParser::Platform_versionContext::Platform_versionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Platform_versionContext::Decimal_literal() {
  return getToken(myParser::Decimal_literal, 0);
}

tree::TerminalNode* myParser::Platform_versionContext::Decimal_digits() {
  return getToken(myParser::Decimal_digits, 0);
}

tree::TerminalNode* myParser::Platform_versionContext::Floating_point_literal() {
  return getToken(myParser::Floating_point_literal, 0);
}

tree::TerminalNode* myParser::Platform_versionContext::DOT() {
  return getToken(myParser::DOT, 0);
}


size_t myParser::Platform_versionContext::getRuleIndex() const {
  return myParser::RulePlatform_version;
}

void myParser::Platform_versionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlatform_version(this);
}

void myParser::Platform_versionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlatform_version(this);
}

myParser::Platform_versionContext* myParser::platform_version() {
  Platform_versionContext *_localctx = _tracker.createInstance<Platform_versionContext>(_ctx, getState());
  enterRule(_localctx, 132, myParser::RulePlatform_version);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1040);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Decimal_literal: {
        enterOuterAlt(_localctx, 1);
        setState(1033);
        match(myParser::Decimal_literal);
        break;
      }

      case myParser::Decimal_digits: {
        enterOuterAlt(_localctx, 2);
        setState(1034);
        match(myParser::Decimal_digits);
        break;
      }

      case myParser::Floating_point_literal: {
        enterOuterAlt(_localctx, 3);
        setState(1035);
        match(myParser::Floating_point_literal);
        setState(1038);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::DOT) {
          setState(1036);
          match(myParser::DOT);
          setState(1037);
          match(myParser::Decimal_digits);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generic_parameter_clauseContext ------------------------------------------------------------------

myParser::Generic_parameter_clauseContext::Generic_parameter_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Generic_parameter_clauseContext::LT() {
  return getToken(myParser::LT, 0);
}

myParser::Generic_parameter_listContext* myParser::Generic_parameter_clauseContext::generic_parameter_list() {
  return getRuleContext<myParser::Generic_parameter_listContext>(0);
}

tree::TerminalNode* myParser::Generic_parameter_clauseContext::GT() {
  return getToken(myParser::GT, 0);
}


size_t myParser::Generic_parameter_clauseContext::getRuleIndex() const {
  return myParser::RuleGeneric_parameter_clause;
}

void myParser::Generic_parameter_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneric_parameter_clause(this);
}

void myParser::Generic_parameter_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneric_parameter_clause(this);
}

myParser::Generic_parameter_clauseContext* myParser::generic_parameter_clause() {
  Generic_parameter_clauseContext *_localctx = _tracker.createInstance<Generic_parameter_clauseContext>(_ctx, getState());
  enterRule(_localctx, 134, myParser::RuleGeneric_parameter_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1042);
    match(myParser::LT);
    setState(1043);
    generic_parameter_list();
    setState(1044);
    match(myParser::GT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generic_parameter_listContext ------------------------------------------------------------------

myParser::Generic_parameter_listContext::Generic_parameter_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Generic_parameterContext *> myParser::Generic_parameter_listContext::generic_parameter() {
  return getRuleContexts<myParser::Generic_parameterContext>();
}

myParser::Generic_parameterContext* myParser::Generic_parameter_listContext::generic_parameter(size_t i) {
  return getRuleContext<myParser::Generic_parameterContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Generic_parameter_listContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Generic_parameter_listContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Generic_parameter_listContext::getRuleIndex() const {
  return myParser::RuleGeneric_parameter_list;
}

void myParser::Generic_parameter_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneric_parameter_list(this);
}

void myParser::Generic_parameter_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneric_parameter_list(this);
}

myParser::Generic_parameter_listContext* myParser::generic_parameter_list() {
  Generic_parameter_listContext *_localctx = _tracker.createInstance<Generic_parameter_listContext>(_ctx, getState());
  enterRule(_localctx, 136, myParser::RuleGeneric_parameter_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1046);
    generic_parameter();
    setState(1051);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(1047);
      match(myParser::COMMA);
      setState(1048);
      generic_parameter();
      setState(1053);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generic_parameterContext ------------------------------------------------------------------

myParser::Generic_parameterContext::Generic_parameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Type_nameContext* myParser::Generic_parameterContext::type_name() {
  return getRuleContext<myParser::Type_nameContext>(0);
}

tree::TerminalNode* myParser::Generic_parameterContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::Type_identifierContext* myParser::Generic_parameterContext::type_identifier() {
  return getRuleContext<myParser::Type_identifierContext>(0);
}

myParser::Protocol_composition_typeContext* myParser::Generic_parameterContext::protocol_composition_type() {
  return getRuleContext<myParser::Protocol_composition_typeContext>(0);
}


size_t myParser::Generic_parameterContext::getRuleIndex() const {
  return myParser::RuleGeneric_parameter;
}

void myParser::Generic_parameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneric_parameter(this);
}

void myParser::Generic_parameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneric_parameter(this);
}

myParser::Generic_parameterContext* myParser::generic_parameter() {
  Generic_parameterContext *_localctx = _tracker.createInstance<Generic_parameterContext>(_ctx, getState());
  enterRule(_localctx, 138, myParser::RuleGeneric_parameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1054);
    type_name();
    setState(1060);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::COLON) {
      setState(1055);
      match(myParser::COLON);
      setState(1058);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
      case 1: {
        setState(1056);
        type_identifier();
        break;
      }

      case 2: {
        setState(1057);
        protocol_composition_type();
        break;
      }

      default:
        break;
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generic_where_clauseContext ------------------------------------------------------------------

myParser::Generic_where_clauseContext::Generic_where_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Generic_where_clauseContext::WHERE() {
  return getToken(myParser::WHERE, 0);
}

myParser::Requirement_listContext* myParser::Generic_where_clauseContext::requirement_list() {
  return getRuleContext<myParser::Requirement_listContext>(0);
}


size_t myParser::Generic_where_clauseContext::getRuleIndex() const {
  return myParser::RuleGeneric_where_clause;
}

void myParser::Generic_where_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneric_where_clause(this);
}

void myParser::Generic_where_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneric_where_clause(this);
}

myParser::Generic_where_clauseContext* myParser::generic_where_clause() {
  Generic_where_clauseContext *_localctx = _tracker.createInstance<Generic_where_clauseContext>(_ctx, getState());
  enterRule(_localctx, 140, myParser::RuleGeneric_where_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1062);
    match(myParser::WHERE);
    setState(1063);
    requirement_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Requirement_listContext ------------------------------------------------------------------

myParser::Requirement_listContext::Requirement_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::RequirementContext *> myParser::Requirement_listContext::requirement() {
  return getRuleContexts<myParser::RequirementContext>();
}

myParser::RequirementContext* myParser::Requirement_listContext::requirement(size_t i) {
  return getRuleContext<myParser::RequirementContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Requirement_listContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Requirement_listContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Requirement_listContext::getRuleIndex() const {
  return myParser::RuleRequirement_list;
}

void myParser::Requirement_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRequirement_list(this);
}

void myParser::Requirement_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRequirement_list(this);
}

myParser::Requirement_listContext* myParser::requirement_list() {
  Requirement_listContext *_localctx = _tracker.createInstance<Requirement_listContext>(_ctx, getState());
  enterRule(_localctx, 142, myParser::RuleRequirement_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1065);
    requirement();
    setState(1070);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1066);
        match(myParser::COMMA);
        setState(1067);
        requirement(); 
      }
      setState(1072);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RequirementContext ------------------------------------------------------------------

myParser::RequirementContext::RequirementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Conformance_requirementContext* myParser::RequirementContext::conformance_requirement() {
  return getRuleContext<myParser::Conformance_requirementContext>(0);
}

myParser::Same_type_requirementContext* myParser::RequirementContext::same_type_requirement() {
  return getRuleContext<myParser::Same_type_requirementContext>(0);
}


size_t myParser::RequirementContext::getRuleIndex() const {
  return myParser::RuleRequirement;
}

void myParser::RequirementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRequirement(this);
}

void myParser::RequirementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRequirement(this);
}

myParser::RequirementContext* myParser::requirement() {
  RequirementContext *_localctx = _tracker.createInstance<RequirementContext>(_ctx, getState());
  enterRule(_localctx, 144, myParser::RuleRequirement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1075);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1073);
      conformance_requirement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1074);
      same_type_requirement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Conformance_requirementContext ------------------------------------------------------------------

myParser::Conformance_requirementContext::Conformance_requirementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Type_identifierContext *> myParser::Conformance_requirementContext::type_identifier() {
  return getRuleContexts<myParser::Type_identifierContext>();
}

myParser::Type_identifierContext* myParser::Conformance_requirementContext::type_identifier(size_t i) {
  return getRuleContext<myParser::Type_identifierContext>(i);
}

tree::TerminalNode* myParser::Conformance_requirementContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::Protocol_composition_typeContext* myParser::Conformance_requirementContext::protocol_composition_type() {
  return getRuleContext<myParser::Protocol_composition_typeContext>(0);
}


size_t myParser::Conformance_requirementContext::getRuleIndex() const {
  return myParser::RuleConformance_requirement;
}

void myParser::Conformance_requirementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConformance_requirement(this);
}

void myParser::Conformance_requirementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConformance_requirement(this);
}

myParser::Conformance_requirementContext* myParser::conformance_requirement() {
  Conformance_requirementContext *_localctx = _tracker.createInstance<Conformance_requirementContext>(_ctx, getState());
  enterRule(_localctx, 146, myParser::RuleConformance_requirement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1077);
    type_identifier();
    setState(1078);
    match(myParser::COLON);
    setState(1081);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx)) {
    case 1: {
      setState(1079);
      type_identifier();
      break;
    }

    case 2: {
      setState(1080);
      protocol_composition_type();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Same_type_requirementContext ------------------------------------------------------------------

myParser::Same_type_requirementContext::Same_type_requirementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Type_identifierContext *> myParser::Same_type_requirementContext::type_identifier() {
  return getRuleContexts<myParser::Type_identifierContext>();
}

myParser::Type_identifierContext* myParser::Same_type_requirementContext::type_identifier(size_t i) {
  return getRuleContext<myParser::Type_identifierContext>(i);
}

myParser::Same_type_equalsContext* myParser::Same_type_requirementContext::same_type_equals() {
  return getRuleContext<myParser::Same_type_equalsContext>(0);
}

myParser::TypeContext* myParser::Same_type_requirementContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}


size_t myParser::Same_type_requirementContext::getRuleIndex() const {
  return myParser::RuleSame_type_requirement;
}

void myParser::Same_type_requirementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSame_type_requirement(this);
}

void myParser::Same_type_requirementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSame_type_requirement(this);
}

myParser::Same_type_requirementContext* myParser::same_type_requirement() {
  Same_type_requirementContext *_localctx = _tracker.createInstance<Same_type_requirementContext>(_ctx, getState());
  enterRule(_localctx, 148, myParser::RuleSame_type_requirement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1083);
    type_identifier();
    setState(1084);
    same_type_equals();
    setState(1087);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
    case 1: {
      setState(1085);
      type_identifier();
      break;
    }

    case 2: {
      setState(1086);
      type(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generic_argument_clauseContext ------------------------------------------------------------------

myParser::Generic_argument_clauseContext::Generic_argument_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Generic_argument_clauseContext::LT() {
  return getToken(myParser::LT, 0);
}

myParser::Generic_argument_listContext* myParser::Generic_argument_clauseContext::generic_argument_list() {
  return getRuleContext<myParser::Generic_argument_listContext>(0);
}

tree::TerminalNode* myParser::Generic_argument_clauseContext::GT() {
  return getToken(myParser::GT, 0);
}


size_t myParser::Generic_argument_clauseContext::getRuleIndex() const {
  return myParser::RuleGeneric_argument_clause;
}

void myParser::Generic_argument_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneric_argument_clause(this);
}

void myParser::Generic_argument_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneric_argument_clause(this);
}

myParser::Generic_argument_clauseContext* myParser::generic_argument_clause() {
  Generic_argument_clauseContext *_localctx = _tracker.createInstance<Generic_argument_clauseContext>(_ctx, getState());
  enterRule(_localctx, 150, myParser::RuleGeneric_argument_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1089);
    match(myParser::LT);
    setState(1090);
    generic_argument_list();
    setState(1091);
    match(myParser::GT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generic_argument_listContext ------------------------------------------------------------------

myParser::Generic_argument_listContext::Generic_argument_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Generic_argumentContext *> myParser::Generic_argument_listContext::generic_argument() {
  return getRuleContexts<myParser::Generic_argumentContext>();
}

myParser::Generic_argumentContext* myParser::Generic_argument_listContext::generic_argument(size_t i) {
  return getRuleContext<myParser::Generic_argumentContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Generic_argument_listContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Generic_argument_listContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Generic_argument_listContext::getRuleIndex() const {
  return myParser::RuleGeneric_argument_list;
}

void myParser::Generic_argument_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneric_argument_list(this);
}

void myParser::Generic_argument_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneric_argument_list(this);
}

myParser::Generic_argument_listContext* myParser::generic_argument_list() {
  Generic_argument_listContext *_localctx = _tracker.createInstance<Generic_argument_listContext>(_ctx, getState());
  enterRule(_localctx, 152, myParser::RuleGeneric_argument_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1093);
    generic_argument();
    setState(1098);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(1094);
      match(myParser::COMMA);
      setState(1095);
      generic_argument();
      setState(1100);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generic_argumentContext ------------------------------------------------------------------

myParser::Generic_argumentContext::Generic_argumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::TypeContext* myParser::Generic_argumentContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}


size_t myParser::Generic_argumentContext::getRuleIndex() const {
  return myParser::RuleGeneric_argument;
}

void myParser::Generic_argumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneric_argument(this);
}

void myParser::Generic_argumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneric_argument(this);
}

myParser::Generic_argumentContext* myParser::generic_argument() {
  Generic_argumentContext *_localctx = _tracker.createInstance<Generic_argumentContext>(_ctx, getState());
  enterRule(_localctx, 154, myParser::RuleGeneric_argument);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1101);
    type(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclarationContext ------------------------------------------------------------------

myParser::DeclarationContext::DeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Import_declarationContext* myParser::DeclarationContext::import_declaration() {
  return getRuleContext<myParser::Import_declarationContext>(0);
}

myParser::Constant_declarationContext* myParser::DeclarationContext::constant_declaration() {
  return getRuleContext<myParser::Constant_declarationContext>(0);
}

myParser::Variable_declarationContext* myParser::DeclarationContext::variable_declaration() {
  return getRuleContext<myParser::Variable_declarationContext>(0);
}

myParser::Typealias_declarationContext* myParser::DeclarationContext::typealias_declaration() {
  return getRuleContext<myParser::Typealias_declarationContext>(0);
}

myParser::Function_declarationContext* myParser::DeclarationContext::function_declaration() {
  return getRuleContext<myParser::Function_declarationContext>(0);
}

myParser::Enum_declarationContext* myParser::DeclarationContext::enum_declaration() {
  return getRuleContext<myParser::Enum_declarationContext>(0);
}

myParser::Struct_declarationContext* myParser::DeclarationContext::struct_declaration() {
  return getRuleContext<myParser::Struct_declarationContext>(0);
}

myParser::Class_declarationContext* myParser::DeclarationContext::class_declaration() {
  return getRuleContext<myParser::Class_declarationContext>(0);
}

myParser::Protocol_declarationContext* myParser::DeclarationContext::protocol_declaration() {
  return getRuleContext<myParser::Protocol_declarationContext>(0);
}

myParser::Initializer_declarationContext* myParser::DeclarationContext::initializer_declaration() {
  return getRuleContext<myParser::Initializer_declarationContext>(0);
}

myParser::Deinitializer_declarationContext* myParser::DeclarationContext::deinitializer_declaration() {
  return getRuleContext<myParser::Deinitializer_declarationContext>(0);
}

myParser::Extension_declarationContext* myParser::DeclarationContext::extension_declaration() {
  return getRuleContext<myParser::Extension_declarationContext>(0);
}

myParser::Subscript_declarationContext* myParser::DeclarationContext::subscript_declaration() {
  return getRuleContext<myParser::Subscript_declarationContext>(0);
}

myParser::Operator_declarationContext* myParser::DeclarationContext::operator_declaration() {
  return getRuleContext<myParser::Operator_declarationContext>(0);
}

myParser::Precedence_group_declarationContext* myParser::DeclarationContext::precedence_group_declaration() {
  return getRuleContext<myParser::Precedence_group_declarationContext>(0);
}

tree::TerminalNode* myParser::DeclarationContext::SEMI() {
  return getToken(myParser::SEMI, 0);
}


size_t myParser::DeclarationContext::getRuleIndex() const {
  return myParser::RuleDeclaration;
}

void myParser::DeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclaration(this);
}

void myParser::DeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclaration(this);
}

myParser::DeclarationContext* myParser::declaration() {
  DeclarationContext *_localctx = _tracker.createInstance<DeclarationContext>(_ctx, getState());
  enterRule(_localctx, 156, myParser::RuleDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1118);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx)) {
    case 1: {
      setState(1103);
      import_declaration();
      break;
    }

    case 2: {
      setState(1104);
      constant_declaration();
      break;
    }

    case 3: {
      setState(1105);
      variable_declaration();
      break;
    }

    case 4: {
      setState(1106);
      typealias_declaration();
      break;
    }

    case 5: {
      setState(1107);
      function_declaration();
      break;
    }

    case 6: {
      setState(1108);
      enum_declaration();
      break;
    }

    case 7: {
      setState(1109);
      struct_declaration();
      break;
    }

    case 8: {
      setState(1110);
      class_declaration();
      break;
    }

    case 9: {
      setState(1111);
      protocol_declaration();
      break;
    }

    case 10: {
      setState(1112);
      initializer_declaration();
      break;
    }

    case 11: {
      setState(1113);
      deinitializer_declaration();
      break;
    }

    case 12: {
      setState(1114);
      extension_declaration();
      break;
    }

    case 13: {
      setState(1115);
      subscript_declaration();
      break;
    }

    case 14: {
      setState(1116);
      operator_declaration();
      break;
    }

    case 15: {
      setState(1117);
      precedence_group_declaration();
      break;
    }

    default:
      break;
    }
    setState(1121);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx)) {
    case 1: {
      setState(1120);
      match(myParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclarationsContext ------------------------------------------------------------------

myParser::DeclarationsContext::DeclarationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::DeclarationContext *> myParser::DeclarationsContext::declaration() {
  return getRuleContexts<myParser::DeclarationContext>();
}

myParser::DeclarationContext* myParser::DeclarationsContext::declaration(size_t i) {
  return getRuleContext<myParser::DeclarationContext>(i);
}


size_t myParser::DeclarationsContext::getRuleIndex() const {
  return myParser::RuleDeclarations;
}

void myParser::DeclarationsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclarations(this);
}

void myParser::DeclarationsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclarations(this);
}

myParser::DeclarationsContext* myParser::declarations() {
  DeclarationsContext *_localctx = _tracker.createInstance<DeclarationsContext>(_ctx, getState());
  enterRule(_localctx, 158, myParser::RuleDeclarations);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1124); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1123);
      declaration();
      setState(1126); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 725622768442875968) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 14847) != 0) || _la == myParser::AT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Top_level_declarationContext ------------------------------------------------------------------

myParser::Top_level_declarationContext::Top_level_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::StatementsContext* myParser::Top_level_declarationContext::statements() {
  return getRuleContext<myParser::StatementsContext>(0);
}


size_t myParser::Top_level_declarationContext::getRuleIndex() const {
  return myParser::RuleTop_level_declaration;
}

void myParser::Top_level_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTop_level_declaration(this);
}

void myParser::Top_level_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTop_level_declaration(this);
}

myParser::Top_level_declarationContext* myParser::top_level_declaration() {
  Top_level_declarationContext *_localctx = _tracker.createInstance<Top_level_declarationContext>(_ctx, getState());
  enterRule(_localctx, 160, myParser::RuleTop_level_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1129);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
    case 1: {
      setState(1128);
      statements();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Code_blockContext ------------------------------------------------------------------

myParser::Code_blockContext::Code_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Code_blockContext::LCURLY() {
  return getToken(myParser::LCURLY, 0);
}

tree::TerminalNode* myParser::Code_blockContext::RCURLY() {
  return getToken(myParser::RCURLY, 0);
}

myParser::StatementsContext* myParser::Code_blockContext::statements() {
  return getRuleContext<myParser::StatementsContext>(0);
}


size_t myParser::Code_blockContext::getRuleIndex() const {
  return myParser::RuleCode_block;
}

void myParser::Code_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCode_block(this);
}

void myParser::Code_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCode_block(this);
}

myParser::Code_blockContext* myParser::code_block() {
  Code_blockContext *_localctx = _tracker.createInstance<Code_blockContext>(_ctx, getState());
  enterRule(_localctx, 162, myParser::RuleCode_block);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1131);
    match(myParser::LCURLY);
    setState(1133);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx)) {
    case 1: {
      setState(1132);
      statements();
      break;
    }

    default:
      break;
    }
    setState(1135);
    match(myParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_declarationContext ------------------------------------------------------------------

myParser::Import_declarationContext::Import_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Import_declarationContext::IMPORT() {
  return getToken(myParser::IMPORT, 0);
}

myParser::Import_pathContext* myParser::Import_declarationContext::import_path() {
  return getRuleContext<myParser::Import_pathContext>(0);
}

myParser::AttributesContext* myParser::Import_declarationContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

myParser::Import_kindContext* myParser::Import_declarationContext::import_kind() {
  return getRuleContext<myParser::Import_kindContext>(0);
}


size_t myParser::Import_declarationContext::getRuleIndex() const {
  return myParser::RuleImport_declaration;
}

void myParser::Import_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_declaration(this);
}

void myParser::Import_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_declaration(this);
}

myParser::Import_declarationContext* myParser::import_declaration() {
  Import_declarationContext *_localctx = _tracker.createInstance<Import_declarationContext>(_ctx, getState());
  enterRule(_localctx, 164, myParser::RuleImport_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1138);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1137);
      attributes();
    }
    setState(1140);
    match(myParser::IMPORT);
    setState(1142);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
    case 1: {
      setState(1141);
      import_kind();
      break;
    }

    default:
      break;
    }
    setState(1144);
    import_path();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_kindContext ------------------------------------------------------------------

myParser::Import_kindContext::Import_kindContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Import_kindContext::TYPEALIAS() {
  return getToken(myParser::TYPEALIAS, 0);
}

tree::TerminalNode* myParser::Import_kindContext::STRUCT() {
  return getToken(myParser::STRUCT, 0);
}

tree::TerminalNode* myParser::Import_kindContext::CLASS() {
  return getToken(myParser::CLASS, 0);
}

tree::TerminalNode* myParser::Import_kindContext::ENUM() {
  return getToken(myParser::ENUM, 0);
}

tree::TerminalNode* myParser::Import_kindContext::PROTOCOL() {
  return getToken(myParser::PROTOCOL, 0);
}

tree::TerminalNode* myParser::Import_kindContext::LET() {
  return getToken(myParser::LET, 0);
}

tree::TerminalNode* myParser::Import_kindContext::VAR() {
  return getToken(myParser::VAR, 0);
}

tree::TerminalNode* myParser::Import_kindContext::FUNC() {
  return getToken(myParser::FUNC, 0);
}


size_t myParser::Import_kindContext::getRuleIndex() const {
  return myParser::RuleImport_kind;
}

void myParser::Import_kindContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_kind(this);
}

void myParser::Import_kindContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_kind(this);
}

myParser::Import_kindContext* myParser::import_kind() {
  Import_kindContext *_localctx = _tracker.createInstance<Import_kindContext>(_ctx, getState());
  enterRule(_localctx, 166, myParser::RuleImport_kind);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1146);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 576460821962498112) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_pathContext ------------------------------------------------------------------

myParser::Import_pathContext::Import_pathContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Import_path_identifierContext *> myParser::Import_pathContext::import_path_identifier() {
  return getRuleContexts<myParser::Import_path_identifierContext>();
}

myParser::Import_path_identifierContext* myParser::Import_pathContext::import_path_identifier(size_t i) {
  return getRuleContext<myParser::Import_path_identifierContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Import_pathContext::DOT() {
  return getTokens(myParser::DOT);
}

tree::TerminalNode* myParser::Import_pathContext::DOT(size_t i) {
  return getToken(myParser::DOT, i);
}


size_t myParser::Import_pathContext::getRuleIndex() const {
  return myParser::RuleImport_path;
}

void myParser::Import_pathContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_path(this);
}

void myParser::Import_pathContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_path(this);
}

myParser::Import_pathContext* myParser::import_path() {
  Import_pathContext *_localctx = _tracker.createInstance<Import_pathContext>(_ctx, getState());
  enterRule(_localctx, 168, myParser::RuleImport_path);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1148);
    import_path_identifier();
    setState(1153);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1149);
        match(myParser::DOT);
        setState(1150);
        import_path_identifier(); 
      }
      setState(1155);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_path_identifierContext ------------------------------------------------------------------

myParser::Import_path_identifierContext::Import_path_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::Import_path_identifierContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::OperatorContext* myParser::Import_path_identifierContext::operator_() {
  return getRuleContext<myParser::OperatorContext>(0);
}


size_t myParser::Import_path_identifierContext::getRuleIndex() const {
  return myParser::RuleImport_path_identifier;
}

void myParser::Import_path_identifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_path_identifier(this);
}

void myParser::Import_path_identifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_path_identifier(this);
}

myParser::Import_path_identifierContext* myParser::import_path_identifier() {
  Import_path_identifierContext *_localctx = _tracker.createInstance<Import_path_identifierContext>(_ctx, getState());
  enterRule(_localctx, 170, myParser::RuleImport_path_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1158);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::AS:
      case myParser::ALPHA:
      case myParser::CATCH:
      case myParser::CLASS:
      case myParser::DEFAULT:
      case myParser::DO:
      case myParser::GUARD:
      case myParser::FOR:
      case myParser::IN:
      case myParser::INTERNAL:
      case myParser::FINAL:
      case myParser::OPEN:
      case myParser::PRIVATE:
      case myParser::PUBLIC:
      case myParser::WHERE:
      case myParser::WHILE:
      case myParser::PROTOCOL:
      case myParser::GET:
      case myParser::SET:
      case myParser::WILL_SET:
      case myParser::DID_SET:
      case myParser::INDIRECT:
      case myParser::PREFIX:
      case myParser::INFIX:
      case myParser::LEFT:
      case myParser::RIGHT:
      case myParser::NONE:
      case myParser::PRECEDENCE_GROUP:
      case myParser::HIGHER_THAN:
      case myParser::LOWER_THAN:
      case myParser::ASSIGNMENT:
      case myParser::ASSOCIATIVITY:
      case myParser::POSTFIX:
      case myParser::OPERATOR:
      case myParser::OS:
      case myParser::ARCH:
      case myParser::SWIFT:
      case myParser::COMPILER:
      case myParser::CAN_IMPORT:
      case myParser::TARGET_ENVIRONMENT:
      case myParser::CONVENIENCE:
      case myParser::DYNAMIC:
      case myParser::LAZY:
      case myParser::OPTIONAL:
      case myParser::OVERRIDE:
      case myParser::REQUIRED:
      case myParser::WEAK:
      case myParser::UNOWNED:
      case myParser::SAFE:
      case myParser::UNSAFE:
      case myParser::MUTATING:
      case myParser::NONMUTATING:
      case myParser::RED:
      case myParser::BLUE:
      case myParser::GREEN:
      case myParser::RESOURCE_NAME:
      case myParser::SOME:
      case myParser::TYPE:
      case myParser::PRECEDENCE:
      case myParser::SELF:
      case myParser::SELF_BIG:
      case myParser::MAC_OS:
      case myParser::I_OS:
      case myParser::OSX:
      case myParser::WATCH_OS:
      case myParser::TV_OS:
      case myParser::LINUX:
      case myParser::WINDOWS:
      case myParser::I386:
      case myParser::X86_64:
      case myParser::ARM:
      case myParser::ARM64:
      case myParser::SIMULATOR:
      case myParser::MAC_CATALYST:
      case myParser::I_OS_APPLICATION_EXTENSION:
      case myParser::MAC_CATALYST_APPLICATION_EXTENSION:
      case myParser::MAC_OS_APPLICATION_EXTENSION:
      case myParser::FILE:
      case myParser::LINE:
      case myParser::GETTER:
      case myParser::SETTER:
      case myParser::Identifier:
      case myParser::BACKTICK: {
        enterOuterAlt(_localctx, 1);
        setState(1156);
        identifier();
        break;
      }

      case myParser::DOT:
      case myParser::LT:
      case myParser::GT:
      case myParser::BANG:
      case myParser::QUESTION:
      case myParser::AND:
      case myParser::SUB:
      case myParser::EQUAL:
      case myParser::OR:
      case myParser::DIV:
      case myParser::ADD:
      case myParser::MUL:
      case myParser::MOD:
      case myParser::CARET:
      case myParser::TILDE:
      case myParser::Operator_head_other: {
        enterOuterAlt(_localctx, 2);
        setState(1157);
        operator_();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_declarationContext ------------------------------------------------------------------

myParser::Constant_declarationContext::Constant_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Constant_declarationContext::LET() {
  return getToken(myParser::LET, 0);
}

myParser::Pattern_initializer_listContext* myParser::Constant_declarationContext::pattern_initializer_list() {
  return getRuleContext<myParser::Pattern_initializer_listContext>(0);
}

myParser::AttributesContext* myParser::Constant_declarationContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

myParser::Declaration_modifiersContext* myParser::Constant_declarationContext::declaration_modifiers() {
  return getRuleContext<myParser::Declaration_modifiersContext>(0);
}


size_t myParser::Constant_declarationContext::getRuleIndex() const {
  return myParser::RuleConstant_declaration;
}

void myParser::Constant_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_declaration(this);
}

void myParser::Constant_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_declaration(this);
}

myParser::Constant_declarationContext* myParser::constant_declaration() {
  Constant_declarationContext *_localctx = _tracker.createInstance<Constant_declarationContext>(_ctx, getState());
  enterRule(_localctx, 172, myParser::RuleConstant_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1161);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1160);
      attributes();
    }
    setState(1164);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 144537400573427776) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 14847) != 0)) {
      setState(1163);
      declaration_modifiers();
    }
    setState(1166);
    match(myParser::LET);
    setState(1167);
    pattern_initializer_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pattern_initializer_listContext ------------------------------------------------------------------

myParser::Pattern_initializer_listContext::Pattern_initializer_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Pattern_initializerContext *> myParser::Pattern_initializer_listContext::pattern_initializer() {
  return getRuleContexts<myParser::Pattern_initializerContext>();
}

myParser::Pattern_initializerContext* myParser::Pattern_initializer_listContext::pattern_initializer(size_t i) {
  return getRuleContext<myParser::Pattern_initializerContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Pattern_initializer_listContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Pattern_initializer_listContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Pattern_initializer_listContext::getRuleIndex() const {
  return myParser::RulePattern_initializer_list;
}

void myParser::Pattern_initializer_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPattern_initializer_list(this);
}

void myParser::Pattern_initializer_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPattern_initializer_list(this);
}

myParser::Pattern_initializer_listContext* myParser::pattern_initializer_list() {
  Pattern_initializer_listContext *_localctx = _tracker.createInstance<Pattern_initializer_listContext>(_ctx, getState());
  enterRule(_localctx, 174, myParser::RulePattern_initializer_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1169);
    pattern_initializer();
    setState(1174);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1170);
        match(myParser::COMMA);
        setState(1171);
        pattern_initializer(); 
      }
      setState(1176);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pattern_initializerContext ------------------------------------------------------------------

myParser::Pattern_initializerContext::Pattern_initializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::PatternContext* myParser::Pattern_initializerContext::pattern() {
  return getRuleContext<myParser::PatternContext>(0);
}

myParser::InitializerContext* myParser::Pattern_initializerContext::initializer() {
  return getRuleContext<myParser::InitializerContext>(0);
}


size_t myParser::Pattern_initializerContext::getRuleIndex() const {
  return myParser::RulePattern_initializer;
}

void myParser::Pattern_initializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPattern_initializer(this);
}

void myParser::Pattern_initializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPattern_initializer(this);
}

myParser::Pattern_initializerContext* myParser::pattern_initializer() {
  Pattern_initializerContext *_localctx = _tracker.createInstance<Pattern_initializerContext>(_ctx, getState());
  enterRule(_localctx, 176, myParser::RulePattern_initializer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1177);
    pattern(0);
    setState(1179);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx)) {
    case 1: {
      setState(1178);
      initializer();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InitializerContext ------------------------------------------------------------------

myParser::InitializerContext::InitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::InitializerContext::EQUAL() {
  return getToken(myParser::EQUAL, 0);
}

myParser::ExpressionContext* myParser::InitializerContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}


size_t myParser::InitializerContext::getRuleIndex() const {
  return myParser::RuleInitializer;
}

void myParser::InitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitializer(this);
}

void myParser::InitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitializer(this);
}

myParser::InitializerContext* myParser::initializer() {
  InitializerContext *_localctx = _tracker.createInstance<InitializerContext>(_ctx, getState());
  enterRule(_localctx, 178, myParser::RuleInitializer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1181);
    match(myParser::EQUAL);
    setState(1182);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_declarationContext ------------------------------------------------------------------

myParser::Variable_declarationContext::Variable_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Variable_declaration_headContext* myParser::Variable_declarationContext::variable_declaration_head() {
  return getRuleContext<myParser::Variable_declaration_headContext>(0);
}

myParser::Variable_nameContext* myParser::Variable_declarationContext::variable_name() {
  return getRuleContext<myParser::Variable_nameContext>(0);
}

myParser::Pattern_initializer_listContext* myParser::Variable_declarationContext::pattern_initializer_list() {
  return getRuleContext<myParser::Pattern_initializer_listContext>(0);
}

myParser::InitializerContext* myParser::Variable_declarationContext::initializer() {
  return getRuleContext<myParser::InitializerContext>(0);
}

myParser::WillSet_didSet_blockContext* myParser::Variable_declarationContext::willSet_didSet_block() {
  return getRuleContext<myParser::WillSet_didSet_blockContext>(0);
}

myParser::Type_annotationContext* myParser::Variable_declarationContext::type_annotation() {
  return getRuleContext<myParser::Type_annotationContext>(0);
}

myParser::Getter_setter_blockContext* myParser::Variable_declarationContext::getter_setter_block() {
  return getRuleContext<myParser::Getter_setter_blockContext>(0);
}

myParser::Getter_setter_keyword_blockContext* myParser::Variable_declarationContext::getter_setter_keyword_block() {
  return getRuleContext<myParser::Getter_setter_keyword_blockContext>(0);
}


size_t myParser::Variable_declarationContext::getRuleIndex() const {
  return myParser::RuleVariable_declaration;
}

void myParser::Variable_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_declaration(this);
}

void myParser::Variable_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_declaration(this);
}

myParser::Variable_declarationContext* myParser::variable_declaration() {
  Variable_declarationContext *_localctx = _tracker.createInstance<Variable_declarationContext>(_ctx, getState());
  enterRule(_localctx, 180, myParser::RuleVariable_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1184);
    variable_declaration_head();
    setState(1201);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx)) {
    case 1: {
      setState(1185);
      variable_name();
      setState(1198);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case myParser::EQUAL: {
          setState(1186);
          initializer();
          setState(1187);
          willSet_didSet_block();
          break;
        }

        case myParser::COLON: {
          setState(1189);
          type_annotation();
          setState(1196);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx)) {
          case 1: {
            setState(1191);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == myParser::EQUAL) {
              setState(1190);
              initializer();
            }
            setState(1193);
            willSet_didSet_block();
            break;
          }

          case 2: {
            setState(1194);
            getter_setter_block();
            break;
          }

          case 3: {
            setState(1195);
            getter_setter_keyword_block();
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      setState(1200);
      pattern_initializer_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_declaration_headContext ------------------------------------------------------------------

myParser::Variable_declaration_headContext::Variable_declaration_headContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Variable_declaration_headContext::VAR() {
  return getToken(myParser::VAR, 0);
}

myParser::AttributesContext* myParser::Variable_declaration_headContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

myParser::Declaration_modifiersContext* myParser::Variable_declaration_headContext::declaration_modifiers() {
  return getRuleContext<myParser::Declaration_modifiersContext>(0);
}


size_t myParser::Variable_declaration_headContext::getRuleIndex() const {
  return myParser::RuleVariable_declaration_head;
}

void myParser::Variable_declaration_headContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_declaration_head(this);
}

void myParser::Variable_declaration_headContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_declaration_head(this);
}

myParser::Variable_declaration_headContext* myParser::variable_declaration_head() {
  Variable_declaration_headContext *_localctx = _tracker.createInstance<Variable_declaration_headContext>(_ctx, getState());
  enterRule(_localctx, 182, myParser::RuleVariable_declaration_head);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1204);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1203);
      attributes();
    }
    setState(1207);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 144537400573427776) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 14847) != 0)) {
      setState(1206);
      declaration_modifiers();
    }
    setState(1209);
    match(myParser::VAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_nameContext ------------------------------------------------------------------

myParser::Variable_nameContext::Variable_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::Variable_nameContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}


size_t myParser::Variable_nameContext::getRuleIndex() const {
  return myParser::RuleVariable_name;
}

void myParser::Variable_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_name(this);
}

void myParser::Variable_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_name(this);
}

myParser::Variable_nameContext* myParser::variable_name() {
  Variable_nameContext *_localctx = _tracker.createInstance<Variable_nameContext>(_ctx, getState());
  enterRule(_localctx, 184, myParser::RuleVariable_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1211);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Getter_setter_blockContext ------------------------------------------------------------------

myParser::Getter_setter_blockContext::Getter_setter_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Getter_setter_blockContext::LCURLY() {
  return getToken(myParser::LCURLY, 0);
}

tree::TerminalNode* myParser::Getter_setter_blockContext::RCURLY() {
  return getToken(myParser::RCURLY, 0);
}

myParser::Getter_clauseContext* myParser::Getter_setter_blockContext::getter_clause() {
  return getRuleContext<myParser::Getter_clauseContext>(0);
}

myParser::Setter_clauseContext* myParser::Getter_setter_blockContext::setter_clause() {
  return getRuleContext<myParser::Setter_clauseContext>(0);
}

myParser::Code_blockContext* myParser::Getter_setter_blockContext::code_block() {
  return getRuleContext<myParser::Code_blockContext>(0);
}


size_t myParser::Getter_setter_blockContext::getRuleIndex() const {
  return myParser::RuleGetter_setter_block;
}

void myParser::Getter_setter_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGetter_setter_block(this);
}

void myParser::Getter_setter_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGetter_setter_block(this);
}

myParser::Getter_setter_blockContext* myParser::getter_setter_block() {
  Getter_setter_blockContext *_localctx = _tracker.createInstance<Getter_setter_blockContext>(_ctx, getState());
  enterRule(_localctx, 186, myParser::RuleGetter_setter_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1226);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1213);
      match(myParser::LCURLY);
      setState(1221);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
      case 1: {
        setState(1214);
        getter_clause();
        setState(1216);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 31) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 31)) & 211106232532993) != 0) || _la == myParser::AT) {
          setState(1215);
          setter_clause();
        }
        break;
      }

      case 2: {
        setState(1218);
        setter_clause();
        setState(1219);
        getter_clause();
        break;
      }

      default:
        break;
      }
      setState(1223);
      match(myParser::RCURLY);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1225);
      code_block();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Getter_clauseContext ------------------------------------------------------------------

myParser::Getter_clauseContext::Getter_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Getter_clauseContext::GET() {
  return getToken(myParser::GET, 0);
}

myParser::AttributesContext* myParser::Getter_clauseContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

myParser::Mutation_modifierContext* myParser::Getter_clauseContext::mutation_modifier() {
  return getRuleContext<myParser::Mutation_modifierContext>(0);
}

myParser::Code_blockContext* myParser::Getter_clauseContext::code_block() {
  return getRuleContext<myParser::Code_blockContext>(0);
}


size_t myParser::Getter_clauseContext::getRuleIndex() const {
  return myParser::RuleGetter_clause;
}

void myParser::Getter_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGetter_clause(this);
}

void myParser::Getter_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGetter_clause(this);
}

myParser::Getter_clauseContext* myParser::getter_clause() {
  Getter_clauseContext *_localctx = _tracker.createInstance<Getter_clauseContext>(_ctx, getState());
  enterRule(_localctx, 188, myParser::RuleGetter_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1229);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1228);
      attributes();
    }
    setState(1232);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::MUTATING

    || _la == myParser::NONMUTATING) {
      setState(1231);
      mutation_modifier();
    }
    setState(1234);
    match(myParser::GET);
    setState(1236);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LCURLY) {
      setState(1235);
      code_block();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Setter_clauseContext ------------------------------------------------------------------

myParser::Setter_clauseContext::Setter_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Setter_clauseContext::SET() {
  return getToken(myParser::SET, 0);
}

myParser::AttributesContext* myParser::Setter_clauseContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

myParser::Mutation_modifierContext* myParser::Setter_clauseContext::mutation_modifier() {
  return getRuleContext<myParser::Mutation_modifierContext>(0);
}

myParser::Setter_nameContext* myParser::Setter_clauseContext::setter_name() {
  return getRuleContext<myParser::Setter_nameContext>(0);
}

myParser::Code_blockContext* myParser::Setter_clauseContext::code_block() {
  return getRuleContext<myParser::Code_blockContext>(0);
}


size_t myParser::Setter_clauseContext::getRuleIndex() const {
  return myParser::RuleSetter_clause;
}

void myParser::Setter_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetter_clause(this);
}

void myParser::Setter_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetter_clause(this);
}

myParser::Setter_clauseContext* myParser::setter_clause() {
  Setter_clauseContext *_localctx = _tracker.createInstance<Setter_clauseContext>(_ctx, getState());
  enterRule(_localctx, 190, myParser::RuleSetter_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1239);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1238);
      attributes();
    }
    setState(1242);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::MUTATING

    || _la == myParser::NONMUTATING) {
      setState(1241);
      mutation_modifier();
    }
    setState(1244);
    match(myParser::SET);
    setState(1246);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LPAREN) {
      setState(1245);
      setter_name();
    }
    setState(1249);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LCURLY) {
      setState(1248);
      code_block();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Setter_nameContext ------------------------------------------------------------------

myParser::Setter_nameContext::Setter_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Setter_nameContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::IdentifierContext* myParser::Setter_nameContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

tree::TerminalNode* myParser::Setter_nameContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}


size_t myParser::Setter_nameContext::getRuleIndex() const {
  return myParser::RuleSetter_name;
}

void myParser::Setter_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetter_name(this);
}

void myParser::Setter_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetter_name(this);
}

myParser::Setter_nameContext* myParser::setter_name() {
  Setter_nameContext *_localctx = _tracker.createInstance<Setter_nameContext>(_ctx, getState());
  enterRule(_localctx, 192, myParser::RuleSetter_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1251);
    match(myParser::LPAREN);
    setState(1252);
    identifier();
    setState(1253);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Getter_setter_keyword_blockContext ------------------------------------------------------------------

myParser::Getter_setter_keyword_blockContext::Getter_setter_keyword_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Getter_setter_keyword_blockContext::LCURLY() {
  return getToken(myParser::LCURLY, 0);
}

tree::TerminalNode* myParser::Getter_setter_keyword_blockContext::RCURLY() {
  return getToken(myParser::RCURLY, 0);
}

myParser::Getter_keyword_clauseContext* myParser::Getter_setter_keyword_blockContext::getter_keyword_clause() {
  return getRuleContext<myParser::Getter_keyword_clauseContext>(0);
}

myParser::Setter_keyword_clauseContext* myParser::Getter_setter_keyword_blockContext::setter_keyword_clause() {
  return getRuleContext<myParser::Setter_keyword_clauseContext>(0);
}


size_t myParser::Getter_setter_keyword_blockContext::getRuleIndex() const {
  return myParser::RuleGetter_setter_keyword_block;
}

void myParser::Getter_setter_keyword_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGetter_setter_keyword_block(this);
}

void myParser::Getter_setter_keyword_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGetter_setter_keyword_block(this);
}

myParser::Getter_setter_keyword_blockContext* myParser::getter_setter_keyword_block() {
  Getter_setter_keyword_blockContext *_localctx = _tracker.createInstance<Getter_setter_keyword_blockContext>(_ctx, getState());
  enterRule(_localctx, 194, myParser::RuleGetter_setter_keyword_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1255);
    match(myParser::LCURLY);
    setState(1263);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 96, _ctx)) {
    case 1: {
      setState(1256);
      getter_keyword_clause();
      setState(1258);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 31) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 31)) & 211106232532993) != 0) || _la == myParser::AT) {
        setState(1257);
        setter_keyword_clause();
      }
      break;
    }

    case 2: {
      setState(1260);
      setter_keyword_clause();
      setState(1261);
      getter_keyword_clause();
      break;
    }

    default:
      break;
    }
    setState(1265);
    match(myParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Getter_keyword_clauseContext ------------------------------------------------------------------

myParser::Getter_keyword_clauseContext::Getter_keyword_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Getter_keyword_clauseContext::GET() {
  return getToken(myParser::GET, 0);
}

myParser::AttributesContext* myParser::Getter_keyword_clauseContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

myParser::Mutation_modifierContext* myParser::Getter_keyword_clauseContext::mutation_modifier() {
  return getRuleContext<myParser::Mutation_modifierContext>(0);
}


size_t myParser::Getter_keyword_clauseContext::getRuleIndex() const {
  return myParser::RuleGetter_keyword_clause;
}

void myParser::Getter_keyword_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGetter_keyword_clause(this);
}

void myParser::Getter_keyword_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGetter_keyword_clause(this);
}

myParser::Getter_keyword_clauseContext* myParser::getter_keyword_clause() {
  Getter_keyword_clauseContext *_localctx = _tracker.createInstance<Getter_keyword_clauseContext>(_ctx, getState());
  enterRule(_localctx, 196, myParser::RuleGetter_keyword_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1268);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1267);
      attributes();
    }
    setState(1271);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::MUTATING

    || _la == myParser::NONMUTATING) {
      setState(1270);
      mutation_modifier();
    }
    setState(1273);
    match(myParser::GET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Setter_keyword_clauseContext ------------------------------------------------------------------

myParser::Setter_keyword_clauseContext::Setter_keyword_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Setter_keyword_clauseContext::SET() {
  return getToken(myParser::SET, 0);
}

myParser::AttributesContext* myParser::Setter_keyword_clauseContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

myParser::Mutation_modifierContext* myParser::Setter_keyword_clauseContext::mutation_modifier() {
  return getRuleContext<myParser::Mutation_modifierContext>(0);
}


size_t myParser::Setter_keyword_clauseContext::getRuleIndex() const {
  return myParser::RuleSetter_keyword_clause;
}

void myParser::Setter_keyword_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetter_keyword_clause(this);
}

void myParser::Setter_keyword_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetter_keyword_clause(this);
}

myParser::Setter_keyword_clauseContext* myParser::setter_keyword_clause() {
  Setter_keyword_clauseContext *_localctx = _tracker.createInstance<Setter_keyword_clauseContext>(_ctx, getState());
  enterRule(_localctx, 198, myParser::RuleSetter_keyword_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1276);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1275);
      attributes();
    }
    setState(1279);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::MUTATING

    || _la == myParser::NONMUTATING) {
      setState(1278);
      mutation_modifier();
    }
    setState(1281);
    match(myParser::SET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WillSet_didSet_blockContext ------------------------------------------------------------------

myParser::WillSet_didSet_blockContext::WillSet_didSet_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::WillSet_didSet_blockContext::LCURLY() {
  return getToken(myParser::LCURLY, 0);
}

tree::TerminalNode* myParser::WillSet_didSet_blockContext::RCURLY() {
  return getToken(myParser::RCURLY, 0);
}

myParser::WillSet_clauseContext* myParser::WillSet_didSet_blockContext::willSet_clause() {
  return getRuleContext<myParser::WillSet_clauseContext>(0);
}

myParser::DidSet_clauseContext* myParser::WillSet_didSet_blockContext::didSet_clause() {
  return getRuleContext<myParser::DidSet_clauseContext>(0);
}


size_t myParser::WillSet_didSet_blockContext::getRuleIndex() const {
  return myParser::RuleWillSet_didSet_block;
}

void myParser::WillSet_didSet_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWillSet_didSet_block(this);
}

void myParser::WillSet_didSet_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWillSet_didSet_block(this);
}

myParser::WillSet_didSet_blockContext* myParser::willSet_didSet_block() {
  WillSet_didSet_blockContext *_localctx = _tracker.createInstance<WillSet_didSet_blockContext>(_ctx, getState());
  enterRule(_localctx, 200, myParser::RuleWillSet_didSet_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1283);
    match(myParser::LCURLY);
    setState(1292);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, _ctx)) {
    case 1: {
      setState(1284);
      willSet_clause();
      setState(1286);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::DID_SET || _la == myParser::AT) {
        setState(1285);
        didSet_clause();
      }
      break;
    }

    case 2: {
      setState(1288);
      didSet_clause();
      setState(1290);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::WILL_SET || _la == myParser::AT) {
        setState(1289);
        willSet_clause();
      }
      break;
    }

    default:
      break;
    }
    setState(1294);
    match(myParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WillSet_clauseContext ------------------------------------------------------------------

myParser::WillSet_clauseContext::WillSet_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::WillSet_clauseContext::WILL_SET() {
  return getToken(myParser::WILL_SET, 0);
}

myParser::Code_blockContext* myParser::WillSet_clauseContext::code_block() {
  return getRuleContext<myParser::Code_blockContext>(0);
}

myParser::AttributesContext* myParser::WillSet_clauseContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

myParser::Setter_nameContext* myParser::WillSet_clauseContext::setter_name() {
  return getRuleContext<myParser::Setter_nameContext>(0);
}


size_t myParser::WillSet_clauseContext::getRuleIndex() const {
  return myParser::RuleWillSet_clause;
}

void myParser::WillSet_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWillSet_clause(this);
}

void myParser::WillSet_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWillSet_clause(this);
}

myParser::WillSet_clauseContext* myParser::willSet_clause() {
  WillSet_clauseContext *_localctx = _tracker.createInstance<WillSet_clauseContext>(_ctx, getState());
  enterRule(_localctx, 202, myParser::RuleWillSet_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1297);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1296);
      attributes();
    }
    setState(1299);
    match(myParser::WILL_SET);
    setState(1301);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LPAREN) {
      setState(1300);
      setter_name();
    }
    setState(1303);
    code_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DidSet_clauseContext ------------------------------------------------------------------

myParser::DidSet_clauseContext::DidSet_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::DidSet_clauseContext::DID_SET() {
  return getToken(myParser::DID_SET, 0);
}

myParser::Code_blockContext* myParser::DidSet_clauseContext::code_block() {
  return getRuleContext<myParser::Code_blockContext>(0);
}

myParser::AttributesContext* myParser::DidSet_clauseContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

myParser::Setter_nameContext* myParser::DidSet_clauseContext::setter_name() {
  return getRuleContext<myParser::Setter_nameContext>(0);
}


size_t myParser::DidSet_clauseContext::getRuleIndex() const {
  return myParser::RuleDidSet_clause;
}

void myParser::DidSet_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDidSet_clause(this);
}

void myParser::DidSet_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDidSet_clause(this);
}

myParser::DidSet_clauseContext* myParser::didSet_clause() {
  DidSet_clauseContext *_localctx = _tracker.createInstance<DidSet_clauseContext>(_ctx, getState());
  enterRule(_localctx, 204, myParser::RuleDidSet_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1306);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1305);
      attributes();
    }
    setState(1308);
    match(myParser::DID_SET);
    setState(1310);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LPAREN) {
      setState(1309);
      setter_name();
    }
    setState(1312);
    code_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Typealias_declarationContext ------------------------------------------------------------------

myParser::Typealias_declarationContext::Typealias_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Typealias_declarationContext::TYPEALIAS() {
  return getToken(myParser::TYPEALIAS, 0);
}

myParser::Typealias_nameContext* myParser::Typealias_declarationContext::typealias_name() {
  return getRuleContext<myParser::Typealias_nameContext>(0);
}

myParser::Typealias_assignmentContext* myParser::Typealias_declarationContext::typealias_assignment() {
  return getRuleContext<myParser::Typealias_assignmentContext>(0);
}

myParser::AttributesContext* myParser::Typealias_declarationContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

myParser::Access_level_modifierContext* myParser::Typealias_declarationContext::access_level_modifier() {
  return getRuleContext<myParser::Access_level_modifierContext>(0);
}

myParser::Generic_parameter_clauseContext* myParser::Typealias_declarationContext::generic_parameter_clause() {
  return getRuleContext<myParser::Generic_parameter_clauseContext>(0);
}


size_t myParser::Typealias_declarationContext::getRuleIndex() const {
  return myParser::RuleTypealias_declaration;
}

void myParser::Typealias_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypealias_declaration(this);
}

void myParser::Typealias_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypealias_declaration(this);
}

myParser::Typealias_declarationContext* myParser::typealias_declaration() {
  Typealias_declarationContext *_localctx = _tracker.createInstance<Typealias_declarationContext>(_ctx, getState());
  enterRule(_localctx, 206, myParser::RuleTypealias_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1315);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1314);
      attributes();
    }
    setState(1318);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 20) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 20)) & 576460752303423517) != 0)) {
      setState(1317);
      access_level_modifier();
    }
    setState(1320);
    match(myParser::TYPEALIAS);
    setState(1321);
    typealias_name();
    setState(1323);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LT) {
      setState(1322);
      generic_parameter_clause();
    }
    setState(1325);
    typealias_assignment();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Typealias_nameContext ------------------------------------------------------------------

myParser::Typealias_nameContext::Typealias_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::Typealias_nameContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}


size_t myParser::Typealias_nameContext::getRuleIndex() const {
  return myParser::RuleTypealias_name;
}

void myParser::Typealias_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypealias_name(this);
}

void myParser::Typealias_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypealias_name(this);
}

myParser::Typealias_nameContext* myParser::typealias_name() {
  Typealias_nameContext *_localctx = _tracker.createInstance<Typealias_nameContext>(_ctx, getState());
  enterRule(_localctx, 208, myParser::RuleTypealias_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1327);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Typealias_assignmentContext ------------------------------------------------------------------

myParser::Typealias_assignmentContext::Typealias_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Typealias_assignmentContext::EQUAL() {
  return getToken(myParser::EQUAL, 0);
}

myParser::TypeContext* myParser::Typealias_assignmentContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}


size_t myParser::Typealias_assignmentContext::getRuleIndex() const {
  return myParser::RuleTypealias_assignment;
}

void myParser::Typealias_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypealias_assignment(this);
}

void myParser::Typealias_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypealias_assignment(this);
}

myParser::Typealias_assignmentContext* myParser::typealias_assignment() {
  Typealias_assignmentContext *_localctx = _tracker.createInstance<Typealias_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 210, myParser::RuleTypealias_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1329);
    match(myParser::EQUAL);
    setState(1330);
    type(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_declarationContext ------------------------------------------------------------------

myParser::Function_declarationContext::Function_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Function_headContext* myParser::Function_declarationContext::function_head() {
  return getRuleContext<myParser::Function_headContext>(0);
}

myParser::Function_nameContext* myParser::Function_declarationContext::function_name() {
  return getRuleContext<myParser::Function_nameContext>(0);
}

myParser::Function_signatureContext* myParser::Function_declarationContext::function_signature() {
  return getRuleContext<myParser::Function_signatureContext>(0);
}

myParser::Generic_parameter_clauseContext* myParser::Function_declarationContext::generic_parameter_clause() {
  return getRuleContext<myParser::Generic_parameter_clauseContext>(0);
}

myParser::Generic_where_clauseContext* myParser::Function_declarationContext::generic_where_clause() {
  return getRuleContext<myParser::Generic_where_clauseContext>(0);
}

myParser::Function_bodyContext* myParser::Function_declarationContext::function_body() {
  return getRuleContext<myParser::Function_bodyContext>(0);
}


size_t myParser::Function_declarationContext::getRuleIndex() const {
  return myParser::RuleFunction_declaration;
}

void myParser::Function_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_declaration(this);
}

void myParser::Function_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_declaration(this);
}

myParser::Function_declarationContext* myParser::function_declaration() {
  Function_declarationContext *_localctx = _tracker.createInstance<Function_declarationContext>(_ctx, getState());
  enterRule(_localctx, 212, myParser::RuleFunction_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1332);
    function_head();
    setState(1333);
    function_name();
    setState(1335);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LT) {
      setState(1334);
      generic_parameter_clause();
    }
    setState(1337);
    function_signature();
    setState(1339);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 112, _ctx)) {
    case 1: {
      setState(1338);
      generic_where_clause();
      break;
    }

    default:
      break;
    }
    setState(1342);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx)) {
    case 1: {
      setState(1341);
      function_body();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_headContext ------------------------------------------------------------------

myParser::Function_headContext::Function_headContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Function_headContext::FUNC() {
  return getToken(myParser::FUNC, 0);
}

myParser::AttributesContext* myParser::Function_headContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

myParser::Declaration_modifiersContext* myParser::Function_headContext::declaration_modifiers() {
  return getRuleContext<myParser::Declaration_modifiersContext>(0);
}


size_t myParser::Function_headContext::getRuleIndex() const {
  return myParser::RuleFunction_head;
}

void myParser::Function_headContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_head(this);
}

void myParser::Function_headContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_head(this);
}

myParser::Function_headContext* myParser::function_head() {
  Function_headContext *_localctx = _tracker.createInstance<Function_headContext>(_ctx, getState());
  enterRule(_localctx, 214, myParser::RuleFunction_head);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1345);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1344);
      attributes();
    }
    setState(1348);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 144537400573427776) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 14847) != 0)) {
      setState(1347);
      declaration_modifiers();
    }
    setState(1350);
    match(myParser::FUNC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_nameContext ------------------------------------------------------------------

myParser::Function_nameContext::Function_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::Function_nameContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::OperatorContext* myParser::Function_nameContext::operator_() {
  return getRuleContext<myParser::OperatorContext>(0);
}


size_t myParser::Function_nameContext::getRuleIndex() const {
  return myParser::RuleFunction_name;
}

void myParser::Function_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_name(this);
}

void myParser::Function_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_name(this);
}

myParser::Function_nameContext* myParser::function_name() {
  Function_nameContext *_localctx = _tracker.createInstance<Function_nameContext>(_ctx, getState());
  enterRule(_localctx, 216, myParser::RuleFunction_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1354);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::AS:
      case myParser::ALPHA:
      case myParser::CATCH:
      case myParser::CLASS:
      case myParser::DEFAULT:
      case myParser::DO:
      case myParser::GUARD:
      case myParser::FOR:
      case myParser::IN:
      case myParser::INTERNAL:
      case myParser::FINAL:
      case myParser::OPEN:
      case myParser::PRIVATE:
      case myParser::PUBLIC:
      case myParser::WHERE:
      case myParser::WHILE:
      case myParser::PROTOCOL:
      case myParser::GET:
      case myParser::SET:
      case myParser::WILL_SET:
      case myParser::DID_SET:
      case myParser::INDIRECT:
      case myParser::PREFIX:
      case myParser::INFIX:
      case myParser::LEFT:
      case myParser::RIGHT:
      case myParser::NONE:
      case myParser::PRECEDENCE_GROUP:
      case myParser::HIGHER_THAN:
      case myParser::LOWER_THAN:
      case myParser::ASSIGNMENT:
      case myParser::ASSOCIATIVITY:
      case myParser::POSTFIX:
      case myParser::OPERATOR:
      case myParser::OS:
      case myParser::ARCH:
      case myParser::SWIFT:
      case myParser::COMPILER:
      case myParser::CAN_IMPORT:
      case myParser::TARGET_ENVIRONMENT:
      case myParser::CONVENIENCE:
      case myParser::DYNAMIC:
      case myParser::LAZY:
      case myParser::OPTIONAL:
      case myParser::OVERRIDE:
      case myParser::REQUIRED:
      case myParser::WEAK:
      case myParser::UNOWNED:
      case myParser::SAFE:
      case myParser::UNSAFE:
      case myParser::MUTATING:
      case myParser::NONMUTATING:
      case myParser::RED:
      case myParser::BLUE:
      case myParser::GREEN:
      case myParser::RESOURCE_NAME:
      case myParser::SOME:
      case myParser::TYPE:
      case myParser::PRECEDENCE:
      case myParser::SELF:
      case myParser::SELF_BIG:
      case myParser::MAC_OS:
      case myParser::I_OS:
      case myParser::OSX:
      case myParser::WATCH_OS:
      case myParser::TV_OS:
      case myParser::LINUX:
      case myParser::WINDOWS:
      case myParser::I386:
      case myParser::X86_64:
      case myParser::ARM:
      case myParser::ARM64:
      case myParser::SIMULATOR:
      case myParser::MAC_CATALYST:
      case myParser::I_OS_APPLICATION_EXTENSION:
      case myParser::MAC_CATALYST_APPLICATION_EXTENSION:
      case myParser::MAC_OS_APPLICATION_EXTENSION:
      case myParser::FILE:
      case myParser::LINE:
      case myParser::GETTER:
      case myParser::SETTER:
      case myParser::Identifier:
      case myParser::BACKTICK: {
        enterOuterAlt(_localctx, 1);
        setState(1352);
        identifier();
        break;
      }

      case myParser::DOT:
      case myParser::LT:
      case myParser::GT:
      case myParser::BANG:
      case myParser::QUESTION:
      case myParser::AND:
      case myParser::SUB:
      case myParser::EQUAL:
      case myParser::OR:
      case myParser::DIV:
      case myParser::ADD:
      case myParser::MUL:
      case myParser::MOD:
      case myParser::CARET:
      case myParser::TILDE:
      case myParser::Operator_head_other: {
        enterOuterAlt(_localctx, 2);
        setState(1353);
        operator_();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_signatureContext ------------------------------------------------------------------

myParser::Function_signatureContext::Function_signatureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Parameter_clauseContext* myParser::Function_signatureContext::parameter_clause() {
  return getRuleContext<myParser::Parameter_clauseContext>(0);
}

tree::TerminalNode* myParser::Function_signatureContext::RETHROWS() {
  return getToken(myParser::RETHROWS, 0);
}

myParser::Function_resultContext* myParser::Function_signatureContext::function_result() {
  return getRuleContext<myParser::Function_resultContext>(0);
}

tree::TerminalNode* myParser::Function_signatureContext::THROWS() {
  return getToken(myParser::THROWS, 0);
}


size_t myParser::Function_signatureContext::getRuleIndex() const {
  return myParser::RuleFunction_signature;
}

void myParser::Function_signatureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_signature(this);
}

void myParser::Function_signatureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_signature(this);
}

myParser::Function_signatureContext* myParser::function_signature() {
  Function_signatureContext *_localctx = _tracker.createInstance<Function_signatureContext>(_ctx, getState());
  enterRule(_localctx, 218, myParser::RuleFunction_signature);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1356);
    parameter_clause();
    setState(1361);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx)) {
    case 1: {
      setState(1358);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx)) {
      case 1: {
        setState(1357);
        match(myParser::THROWS);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      setState(1360);
      match(myParser::RETHROWS);
      break;
    }

    default:
      break;
    }
    setState(1364);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 119, _ctx)) {
    case 1: {
      setState(1363);
      function_result();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_resultContext ------------------------------------------------------------------

myParser::Function_resultContext::Function_resultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Arrow_operatorContext* myParser::Function_resultContext::arrow_operator() {
  return getRuleContext<myParser::Arrow_operatorContext>(0);
}

myParser::TypeContext* myParser::Function_resultContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

myParser::AttributesContext* myParser::Function_resultContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}


size_t myParser::Function_resultContext::getRuleIndex() const {
  return myParser::RuleFunction_result;
}

void myParser::Function_resultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_result(this);
}

void myParser::Function_resultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_result(this);
}

myParser::Function_resultContext* myParser::function_result() {
  Function_resultContext *_localctx = _tracker.createInstance<Function_resultContext>(_ctx, getState());
  enterRule(_localctx, 220, myParser::RuleFunction_result);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1366);
    arrow_operator();
    setState(1368);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx)) {
    case 1: {
      setState(1367);
      attributes();
      break;
    }

    default:
      break;
    }
    setState(1370);
    type(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_bodyContext ------------------------------------------------------------------

myParser::Function_bodyContext::Function_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Code_blockContext* myParser::Function_bodyContext::code_block() {
  return getRuleContext<myParser::Code_blockContext>(0);
}


size_t myParser::Function_bodyContext::getRuleIndex() const {
  return myParser::RuleFunction_body;
}

void myParser::Function_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_body(this);
}

void myParser::Function_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_body(this);
}

myParser::Function_bodyContext* myParser::function_body() {
  Function_bodyContext *_localctx = _tracker.createInstance<Function_bodyContext>(_ctx, getState());
  enterRule(_localctx, 222, myParser::RuleFunction_body);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1372);
    code_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_clauseContext ------------------------------------------------------------------

myParser::Parameter_clauseContext::Parameter_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Parameter_clauseContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::Parameter_clauseContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

myParser::Parameter_listContext* myParser::Parameter_clauseContext::parameter_list() {
  return getRuleContext<myParser::Parameter_listContext>(0);
}


size_t myParser::Parameter_clauseContext::getRuleIndex() const {
  return myParser::RuleParameter_clause;
}

void myParser::Parameter_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter_clause(this);
}

void myParser::Parameter_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter_clause(this);
}

myParser::Parameter_clauseContext* myParser::parameter_clause() {
  Parameter_clauseContext *_localctx = _tracker.createInstance<Parameter_clauseContext>(_ctx, getState());
  enterRule(_localctx, 224, myParser::RuleParameter_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1374);
    match(myParser::LPAREN);
    setState(1376);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -576599273992204954) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3940649437003519) != 0) || ((((_la - 135) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 135)) & 1074003975) != 0)) {
      setState(1375);
      parameter_list();
    }
    setState(1378);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_listContext ------------------------------------------------------------------

myParser::Parameter_listContext::Parameter_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::ParameterContext *> myParser::Parameter_listContext::parameter() {
  return getRuleContexts<myParser::ParameterContext>();
}

myParser::ParameterContext* myParser::Parameter_listContext::parameter(size_t i) {
  return getRuleContext<myParser::ParameterContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Parameter_listContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Parameter_listContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Parameter_listContext::getRuleIndex() const {
  return myParser::RuleParameter_list;
}

void myParser::Parameter_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter_list(this);
}

void myParser::Parameter_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter_list(this);
}

myParser::Parameter_listContext* myParser::parameter_list() {
  Parameter_listContext *_localctx = _tracker.createInstance<Parameter_listContext>(_ctx, getState());
  enterRule(_localctx, 226, myParser::RuleParameter_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1380);
    parameter();
    setState(1385);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(1381);
      match(myParser::COMMA);
      setState(1382);
      parameter();
      setState(1387);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterContext ------------------------------------------------------------------

myParser::ParameterContext::ParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Local_parameter_nameContext* myParser::ParameterContext::local_parameter_name() {
  return getRuleContext<myParser::Local_parameter_nameContext>(0);
}

myParser::Type_annotationContext* myParser::ParameterContext::type_annotation() {
  return getRuleContext<myParser::Type_annotationContext>(0);
}

myParser::Range_operatorContext* myParser::ParameterContext::range_operator() {
  return getRuleContext<myParser::Range_operatorContext>(0);
}

myParser::AttributesContext* myParser::ParameterContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

myParser::External_parameter_nameContext* myParser::ParameterContext::external_parameter_name() {
  return getRuleContext<myParser::External_parameter_nameContext>(0);
}

myParser::Default_argument_clauseContext* myParser::ParameterContext::default_argument_clause() {
  return getRuleContext<myParser::Default_argument_clauseContext>(0);
}


size_t myParser::ParameterContext::getRuleIndex() const {
  return myParser::RuleParameter;
}

void myParser::ParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter(this);
}

void myParser::ParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter(this);
}

myParser::ParameterContext* myParser::parameter() {
  ParameterContext *_localctx = _tracker.createInstance<ParameterContext>(_ctx, getState());
  enterRule(_localctx, 228, myParser::RuleParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1389);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1388);
      attributes();
    }
    setState(1392);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 124, _ctx)) {
    case 1: {
      setState(1391);
      external_parameter_name();
      break;
    }

    default:
      break;
    }
    setState(1394);
    local_parameter_name();
    setState(1395);
    type_annotation();
    setState(1400);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx)) {
    case 1: {
      setState(1397);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::EQUAL) {
        setState(1396);
        default_argument_clause();
      }
      break;
    }

    case 2: {
      setState(1399);
      range_operator();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- External_parameter_nameContext ------------------------------------------------------------------

myParser::External_parameter_nameContext::External_parameter_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::External_parameter_nameContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}


size_t myParser::External_parameter_nameContext::getRuleIndex() const {
  return myParser::RuleExternal_parameter_name;
}

void myParser::External_parameter_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExternal_parameter_name(this);
}

void myParser::External_parameter_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExternal_parameter_name(this);
}

myParser::External_parameter_nameContext* myParser::external_parameter_name() {
  External_parameter_nameContext *_localctx = _tracker.createInstance<External_parameter_nameContext>(_ctx, getState());
  enterRule(_localctx, 230, myParser::RuleExternal_parameter_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1402);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Local_parameter_nameContext ------------------------------------------------------------------

myParser::Local_parameter_nameContext::Local_parameter_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::Local_parameter_nameContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}


size_t myParser::Local_parameter_nameContext::getRuleIndex() const {
  return myParser::RuleLocal_parameter_name;
}

void myParser::Local_parameter_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLocal_parameter_name(this);
}

void myParser::Local_parameter_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLocal_parameter_name(this);
}

myParser::Local_parameter_nameContext* myParser::local_parameter_name() {
  Local_parameter_nameContext *_localctx = _tracker.createInstance<Local_parameter_nameContext>(_ctx, getState());
  enterRule(_localctx, 232, myParser::RuleLocal_parameter_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1404);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Default_argument_clauseContext ------------------------------------------------------------------

myParser::Default_argument_clauseContext::Default_argument_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Default_argument_clauseContext::EQUAL() {
  return getToken(myParser::EQUAL, 0);
}

myParser::ExpressionContext* myParser::Default_argument_clauseContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}


size_t myParser::Default_argument_clauseContext::getRuleIndex() const {
  return myParser::RuleDefault_argument_clause;
}

void myParser::Default_argument_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefault_argument_clause(this);
}

void myParser::Default_argument_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefault_argument_clause(this);
}

myParser::Default_argument_clauseContext* myParser::default_argument_clause() {
  Default_argument_clauseContext *_localctx = _tracker.createInstance<Default_argument_clauseContext>(_ctx, getState());
  enterRule(_localctx, 234, myParser::RuleDefault_argument_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1406);
    match(myParser::EQUAL);
    setState(1407);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enum_declarationContext ------------------------------------------------------------------

myParser::Enum_declarationContext::Enum_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Union_style_enumContext* myParser::Enum_declarationContext::union_style_enum() {
  return getRuleContext<myParser::Union_style_enumContext>(0);
}

myParser::Raw_value_style_enumContext* myParser::Enum_declarationContext::raw_value_style_enum() {
  return getRuleContext<myParser::Raw_value_style_enumContext>(0);
}

myParser::AttributesContext* myParser::Enum_declarationContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

myParser::Access_level_modifierContext* myParser::Enum_declarationContext::access_level_modifier() {
  return getRuleContext<myParser::Access_level_modifierContext>(0);
}


size_t myParser::Enum_declarationContext::getRuleIndex() const {
  return myParser::RuleEnum_declaration;
}

void myParser::Enum_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnum_declaration(this);
}

void myParser::Enum_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnum_declaration(this);
}

myParser::Enum_declarationContext* myParser::enum_declaration() {
  Enum_declarationContext *_localctx = _tracker.createInstance<Enum_declarationContext>(_ctx, getState());
  enterRule(_localctx, 236, myParser::RuleEnum_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1410);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1409);
      attributes();
    }
    setState(1413);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 20) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 20)) & 576460752303423517) != 0)) {
      setState(1412);
      access_level_modifier();
    }
    setState(1417);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx)) {
    case 1: {
      setState(1415);
      union_style_enum();
      break;
    }

    case 2: {
      setState(1416);
      raw_value_style_enum();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Union_style_enumContext ------------------------------------------------------------------

myParser::Union_style_enumContext::Union_style_enumContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Union_style_enumContext::ENUM() {
  return getToken(myParser::ENUM, 0);
}

myParser::Enum_nameContext* myParser::Union_style_enumContext::enum_name() {
  return getRuleContext<myParser::Enum_nameContext>(0);
}

tree::TerminalNode* myParser::Union_style_enumContext::LCURLY() {
  return getToken(myParser::LCURLY, 0);
}

tree::TerminalNode* myParser::Union_style_enumContext::RCURLY() {
  return getToken(myParser::RCURLY, 0);
}

tree::TerminalNode* myParser::Union_style_enumContext::INDIRECT() {
  return getToken(myParser::INDIRECT, 0);
}

myParser::Generic_parameter_clauseContext* myParser::Union_style_enumContext::generic_parameter_clause() {
  return getRuleContext<myParser::Generic_parameter_clauseContext>(0);
}

myParser::Type_inheritance_clauseContext* myParser::Union_style_enumContext::type_inheritance_clause() {
  return getRuleContext<myParser::Type_inheritance_clauseContext>(0);
}

myParser::Generic_where_clauseContext* myParser::Union_style_enumContext::generic_where_clause() {
  return getRuleContext<myParser::Generic_where_clauseContext>(0);
}

myParser::Union_style_enum_membersContext* myParser::Union_style_enumContext::union_style_enum_members() {
  return getRuleContext<myParser::Union_style_enum_membersContext>(0);
}


size_t myParser::Union_style_enumContext::getRuleIndex() const {
  return myParser::RuleUnion_style_enum;
}

void myParser::Union_style_enumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnion_style_enum(this);
}

void myParser::Union_style_enumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnion_style_enum(this);
}

myParser::Union_style_enumContext* myParser::union_style_enum() {
  Union_style_enumContext *_localctx = _tracker.createInstance<Union_style_enumContext>(_ctx, getState());
  enterRule(_localctx, 238, myParser::RuleUnion_style_enum);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1420);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::INDIRECT) {
      setState(1419);
      match(myParser::INDIRECT);
    }
    setState(1422);
    match(myParser::ENUM);
    setState(1423);
    enum_name();
    setState(1425);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LT) {
      setState(1424);
      generic_parameter_clause();
    }
    setState(1428);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::COLON) {
      setState(1427);
      type_inheritance_clause();
    }
    setState(1431);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::WHERE) {
      setState(1430);
      generic_where_clause();
    }
    setState(1433);
    match(myParser::LCURLY);
    setState(1435);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 725622768442875984) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 12525636463639039) != 0) || _la == myParser::AT) {
      setState(1434);
      union_style_enum_members();
    }
    setState(1437);
    match(myParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Union_style_enum_membersContext ------------------------------------------------------------------

myParser::Union_style_enum_membersContext::Union_style_enum_membersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Union_style_enum_memberContext *> myParser::Union_style_enum_membersContext::union_style_enum_member() {
  return getRuleContexts<myParser::Union_style_enum_memberContext>();
}

myParser::Union_style_enum_memberContext* myParser::Union_style_enum_membersContext::union_style_enum_member(size_t i) {
  return getRuleContext<myParser::Union_style_enum_memberContext>(i);
}


size_t myParser::Union_style_enum_membersContext::getRuleIndex() const {
  return myParser::RuleUnion_style_enum_members;
}

void myParser::Union_style_enum_membersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnion_style_enum_members(this);
}

void myParser::Union_style_enum_membersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnion_style_enum_members(this);
}

myParser::Union_style_enum_membersContext* myParser::union_style_enum_members() {
  Union_style_enum_membersContext *_localctx = _tracker.createInstance<Union_style_enum_membersContext>(_ctx, getState());
  enterRule(_localctx, 240, myParser::RuleUnion_style_enum_members);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1440); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1439);
      union_style_enum_member();
      setState(1442); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 725622768442875984) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 12525636463639039) != 0) || _la == myParser::AT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Union_style_enum_memberContext ------------------------------------------------------------------

myParser::Union_style_enum_memberContext::Union_style_enum_memberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::DeclarationContext* myParser::Union_style_enum_memberContext::declaration() {
  return getRuleContext<myParser::DeclarationContext>(0);
}

myParser::Union_style_enum_case_clauseContext* myParser::Union_style_enum_memberContext::union_style_enum_case_clause() {
  return getRuleContext<myParser::Union_style_enum_case_clauseContext>(0);
}

myParser::Compiler_control_statementContext* myParser::Union_style_enum_memberContext::compiler_control_statement() {
  return getRuleContext<myParser::Compiler_control_statementContext>(0);
}


size_t myParser::Union_style_enum_memberContext::getRuleIndex() const {
  return myParser::RuleUnion_style_enum_member;
}

void myParser::Union_style_enum_memberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnion_style_enum_member(this);
}

void myParser::Union_style_enum_memberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnion_style_enum_member(this);
}

myParser::Union_style_enum_memberContext* myParser::union_style_enum_member() {
  Union_style_enum_memberContext *_localctx = _tracker.createInstance<Union_style_enum_memberContext>(_ctx, getState());
  enterRule(_localctx, 242, myParser::RuleUnion_style_enum_member);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1447);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1444);
      declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1445);
      union_style_enum_case_clause();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1446);
      compiler_control_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Union_style_enum_case_clauseContext ------------------------------------------------------------------

myParser::Union_style_enum_case_clauseContext::Union_style_enum_case_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Union_style_enum_case_clauseContext::CASE() {
  return getToken(myParser::CASE, 0);
}

myParser::Union_style_enum_case_listContext* myParser::Union_style_enum_case_clauseContext::union_style_enum_case_list() {
  return getRuleContext<myParser::Union_style_enum_case_listContext>(0);
}

myParser::AttributesContext* myParser::Union_style_enum_case_clauseContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

tree::TerminalNode* myParser::Union_style_enum_case_clauseContext::INDIRECT() {
  return getToken(myParser::INDIRECT, 0);
}


size_t myParser::Union_style_enum_case_clauseContext::getRuleIndex() const {
  return myParser::RuleUnion_style_enum_case_clause;
}

void myParser::Union_style_enum_case_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnion_style_enum_case_clause(this);
}

void myParser::Union_style_enum_case_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnion_style_enum_case_clause(this);
}

myParser::Union_style_enum_case_clauseContext* myParser::union_style_enum_case_clause() {
  Union_style_enum_case_clauseContext *_localctx = _tracker.createInstance<Union_style_enum_case_clauseContext>(_ctx, getState());
  enterRule(_localctx, 244, myParser::RuleUnion_style_enum_case_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1450);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1449);
      attributes();
    }
    setState(1453);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::INDIRECT) {
      setState(1452);
      match(myParser::INDIRECT);
    }
    setState(1455);
    match(myParser::CASE);
    setState(1456);
    union_style_enum_case_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Union_style_enum_case_listContext ------------------------------------------------------------------

myParser::Union_style_enum_case_listContext::Union_style_enum_case_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Union_style_enum_caseContext *> myParser::Union_style_enum_case_listContext::union_style_enum_case() {
  return getRuleContexts<myParser::Union_style_enum_caseContext>();
}

myParser::Union_style_enum_caseContext* myParser::Union_style_enum_case_listContext::union_style_enum_case(size_t i) {
  return getRuleContext<myParser::Union_style_enum_caseContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Union_style_enum_case_listContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Union_style_enum_case_listContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Union_style_enum_case_listContext::getRuleIndex() const {
  return myParser::RuleUnion_style_enum_case_list;
}

void myParser::Union_style_enum_case_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnion_style_enum_case_list(this);
}

void myParser::Union_style_enum_case_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnion_style_enum_case_list(this);
}

myParser::Union_style_enum_case_listContext* myParser::union_style_enum_case_list() {
  Union_style_enum_case_listContext *_localctx = _tracker.createInstance<Union_style_enum_case_listContext>(_ctx, getState());
  enterRule(_localctx, 246, myParser::RuleUnion_style_enum_case_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1458);
    union_style_enum_case();
    setState(1463);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(1459);
      match(myParser::COMMA);
      setState(1460);
      union_style_enum_case();
      setState(1465);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Union_style_enum_caseContext ------------------------------------------------------------------

myParser::Union_style_enum_caseContext::Union_style_enum_caseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Opaque_typeContext* myParser::Union_style_enum_caseContext::opaque_type() {
  return getRuleContext<myParser::Opaque_typeContext>(0);
}

myParser::Enum_case_nameContext* myParser::Union_style_enum_caseContext::enum_case_name() {
  return getRuleContext<myParser::Enum_case_nameContext>(0);
}

myParser::Tuple_typeContext* myParser::Union_style_enum_caseContext::tuple_type() {
  return getRuleContext<myParser::Tuple_typeContext>(0);
}

tree::TerminalNode* myParser::Union_style_enum_caseContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::TypeContext* myParser::Union_style_enum_caseContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

tree::TerminalNode* myParser::Union_style_enum_caseContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}


size_t myParser::Union_style_enum_caseContext::getRuleIndex() const {
  return myParser::RuleUnion_style_enum_case;
}

void myParser::Union_style_enum_caseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnion_style_enum_case(this);
}

void myParser::Union_style_enum_caseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnion_style_enum_case(this);
}

myParser::Union_style_enum_caseContext* myParser::union_style_enum_case() {
  Union_style_enum_caseContext *_localctx = _tracker.createInstance<Union_style_enum_caseContext>(_ctx, getState());
  enterRule(_localctx, 248, myParser::RuleUnion_style_enum_case);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1475);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1466);
      opaque_type();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1467);
      enum_case_name();
      setState(1473);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 140, _ctx)) {
      case 1: {
        setState(1468);
        tuple_type();
        break;
      }

      case 2: {
        setState(1469);
        match(myParser::LPAREN);
        setState(1470);
        type(0);
        setState(1471);
        match(myParser::RPAREN);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enum_nameContext ------------------------------------------------------------------

myParser::Enum_nameContext::Enum_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::Enum_nameContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}


size_t myParser::Enum_nameContext::getRuleIndex() const {
  return myParser::RuleEnum_name;
}

void myParser::Enum_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnum_name(this);
}

void myParser::Enum_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnum_name(this);
}

myParser::Enum_nameContext* myParser::enum_name() {
  Enum_nameContext *_localctx = _tracker.createInstance<Enum_nameContext>(_ctx, getState());
  enterRule(_localctx, 250, myParser::RuleEnum_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1477);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enum_case_nameContext ------------------------------------------------------------------

myParser::Enum_case_nameContext::Enum_case_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::Enum_case_nameContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}


size_t myParser::Enum_case_nameContext::getRuleIndex() const {
  return myParser::RuleEnum_case_name;
}

void myParser::Enum_case_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnum_case_name(this);
}

void myParser::Enum_case_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnum_case_name(this);
}

myParser::Enum_case_nameContext* myParser::enum_case_name() {
  Enum_case_nameContext *_localctx = _tracker.createInstance<Enum_case_nameContext>(_ctx, getState());
  enterRule(_localctx, 252, myParser::RuleEnum_case_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1479);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Raw_value_style_enumContext ------------------------------------------------------------------

myParser::Raw_value_style_enumContext::Raw_value_style_enumContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Raw_value_style_enumContext::ENUM() {
  return getToken(myParser::ENUM, 0);
}

myParser::Enum_nameContext* myParser::Raw_value_style_enumContext::enum_name() {
  return getRuleContext<myParser::Enum_nameContext>(0);
}

myParser::Type_inheritance_clauseContext* myParser::Raw_value_style_enumContext::type_inheritance_clause() {
  return getRuleContext<myParser::Type_inheritance_clauseContext>(0);
}

tree::TerminalNode* myParser::Raw_value_style_enumContext::LCURLY() {
  return getToken(myParser::LCURLY, 0);
}

myParser::Raw_value_style_enum_membersContext* myParser::Raw_value_style_enumContext::raw_value_style_enum_members() {
  return getRuleContext<myParser::Raw_value_style_enum_membersContext>(0);
}

tree::TerminalNode* myParser::Raw_value_style_enumContext::RCURLY() {
  return getToken(myParser::RCURLY, 0);
}

myParser::Generic_parameter_clauseContext* myParser::Raw_value_style_enumContext::generic_parameter_clause() {
  return getRuleContext<myParser::Generic_parameter_clauseContext>(0);
}

myParser::Generic_where_clauseContext* myParser::Raw_value_style_enumContext::generic_where_clause() {
  return getRuleContext<myParser::Generic_where_clauseContext>(0);
}


size_t myParser::Raw_value_style_enumContext::getRuleIndex() const {
  return myParser::RuleRaw_value_style_enum;
}

void myParser::Raw_value_style_enumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRaw_value_style_enum(this);
}

void myParser::Raw_value_style_enumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRaw_value_style_enum(this);
}

myParser::Raw_value_style_enumContext* myParser::raw_value_style_enum() {
  Raw_value_style_enumContext *_localctx = _tracker.createInstance<Raw_value_style_enumContext>(_ctx, getState());
  enterRule(_localctx, 254, myParser::RuleRaw_value_style_enum);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1481);
    match(myParser::ENUM);
    setState(1482);
    enum_name();
    setState(1484);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LT) {
      setState(1483);
      generic_parameter_clause();
    }
    setState(1486);
    type_inheritance_clause();
    setState(1488);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::WHERE) {
      setState(1487);
      generic_where_clause();
    }
    setState(1490);
    match(myParser::LCURLY);
    setState(1491);
    raw_value_style_enum_members();
    setState(1492);
    match(myParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Raw_value_style_enum_membersContext ------------------------------------------------------------------

myParser::Raw_value_style_enum_membersContext::Raw_value_style_enum_membersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Raw_value_style_enum_memberContext *> myParser::Raw_value_style_enum_membersContext::raw_value_style_enum_member() {
  return getRuleContexts<myParser::Raw_value_style_enum_memberContext>();
}

myParser::Raw_value_style_enum_memberContext* myParser::Raw_value_style_enum_membersContext::raw_value_style_enum_member(size_t i) {
  return getRuleContext<myParser::Raw_value_style_enum_memberContext>(i);
}


size_t myParser::Raw_value_style_enum_membersContext::getRuleIndex() const {
  return myParser::RuleRaw_value_style_enum_members;
}

void myParser::Raw_value_style_enum_membersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRaw_value_style_enum_members(this);
}

void myParser::Raw_value_style_enum_membersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRaw_value_style_enum_members(this);
}

myParser::Raw_value_style_enum_membersContext* myParser::raw_value_style_enum_members() {
  Raw_value_style_enum_membersContext *_localctx = _tracker.createInstance<Raw_value_style_enum_membersContext>(_ctx, getState());
  enterRule(_localctx, 256, myParser::RuleRaw_value_style_enum_members);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1495); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1494);
      raw_value_style_enum_member();
      setState(1497); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 725622768442875984) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 12525636463639039) != 0) || _la == myParser::AT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Raw_value_style_enum_memberContext ------------------------------------------------------------------

myParser::Raw_value_style_enum_memberContext::Raw_value_style_enum_memberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::DeclarationContext* myParser::Raw_value_style_enum_memberContext::declaration() {
  return getRuleContext<myParser::DeclarationContext>(0);
}

myParser::Raw_value_style_enum_case_clauseContext* myParser::Raw_value_style_enum_memberContext::raw_value_style_enum_case_clause() {
  return getRuleContext<myParser::Raw_value_style_enum_case_clauseContext>(0);
}

myParser::Compiler_control_statementContext* myParser::Raw_value_style_enum_memberContext::compiler_control_statement() {
  return getRuleContext<myParser::Compiler_control_statementContext>(0);
}


size_t myParser::Raw_value_style_enum_memberContext::getRuleIndex() const {
  return myParser::RuleRaw_value_style_enum_member;
}

void myParser::Raw_value_style_enum_memberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRaw_value_style_enum_member(this);
}

void myParser::Raw_value_style_enum_memberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRaw_value_style_enum_member(this);
}

myParser::Raw_value_style_enum_memberContext* myParser::raw_value_style_enum_member() {
  Raw_value_style_enum_memberContext *_localctx = _tracker.createInstance<Raw_value_style_enum_memberContext>(_ctx, getState());
  enterRule(_localctx, 258, myParser::RuleRaw_value_style_enum_member);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1502);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 145, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1499);
      declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1500);
      raw_value_style_enum_case_clause();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1501);
      compiler_control_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Raw_value_style_enum_case_clauseContext ------------------------------------------------------------------

myParser::Raw_value_style_enum_case_clauseContext::Raw_value_style_enum_case_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Raw_value_style_enum_case_clauseContext::CASE() {
  return getToken(myParser::CASE, 0);
}

myParser::Raw_value_style_enum_case_listContext* myParser::Raw_value_style_enum_case_clauseContext::raw_value_style_enum_case_list() {
  return getRuleContext<myParser::Raw_value_style_enum_case_listContext>(0);
}

myParser::AttributesContext* myParser::Raw_value_style_enum_case_clauseContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}


size_t myParser::Raw_value_style_enum_case_clauseContext::getRuleIndex() const {
  return myParser::RuleRaw_value_style_enum_case_clause;
}

void myParser::Raw_value_style_enum_case_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRaw_value_style_enum_case_clause(this);
}

void myParser::Raw_value_style_enum_case_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRaw_value_style_enum_case_clause(this);
}

myParser::Raw_value_style_enum_case_clauseContext* myParser::raw_value_style_enum_case_clause() {
  Raw_value_style_enum_case_clauseContext *_localctx = _tracker.createInstance<Raw_value_style_enum_case_clauseContext>(_ctx, getState());
  enterRule(_localctx, 260, myParser::RuleRaw_value_style_enum_case_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1505);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1504);
      attributes();
    }
    setState(1507);
    match(myParser::CASE);
    setState(1508);
    raw_value_style_enum_case_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Raw_value_style_enum_case_listContext ------------------------------------------------------------------

myParser::Raw_value_style_enum_case_listContext::Raw_value_style_enum_case_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Raw_value_style_enum_caseContext *> myParser::Raw_value_style_enum_case_listContext::raw_value_style_enum_case() {
  return getRuleContexts<myParser::Raw_value_style_enum_caseContext>();
}

myParser::Raw_value_style_enum_caseContext* myParser::Raw_value_style_enum_case_listContext::raw_value_style_enum_case(size_t i) {
  return getRuleContext<myParser::Raw_value_style_enum_caseContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Raw_value_style_enum_case_listContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Raw_value_style_enum_case_listContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Raw_value_style_enum_case_listContext::getRuleIndex() const {
  return myParser::RuleRaw_value_style_enum_case_list;
}

void myParser::Raw_value_style_enum_case_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRaw_value_style_enum_case_list(this);
}

void myParser::Raw_value_style_enum_case_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRaw_value_style_enum_case_list(this);
}

myParser::Raw_value_style_enum_case_listContext* myParser::raw_value_style_enum_case_list() {
  Raw_value_style_enum_case_listContext *_localctx = _tracker.createInstance<Raw_value_style_enum_case_listContext>(_ctx, getState());
  enterRule(_localctx, 262, myParser::RuleRaw_value_style_enum_case_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1510);
    raw_value_style_enum_case();
    setState(1515);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(1511);
      match(myParser::COMMA);
      setState(1512);
      raw_value_style_enum_case();
      setState(1517);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Raw_value_style_enum_caseContext ------------------------------------------------------------------

myParser::Raw_value_style_enum_caseContext::Raw_value_style_enum_caseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Enum_case_nameContext* myParser::Raw_value_style_enum_caseContext::enum_case_name() {
  return getRuleContext<myParser::Enum_case_nameContext>(0);
}

myParser::Raw_value_assignmentContext* myParser::Raw_value_style_enum_caseContext::raw_value_assignment() {
  return getRuleContext<myParser::Raw_value_assignmentContext>(0);
}


size_t myParser::Raw_value_style_enum_caseContext::getRuleIndex() const {
  return myParser::RuleRaw_value_style_enum_case;
}

void myParser::Raw_value_style_enum_caseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRaw_value_style_enum_case(this);
}

void myParser::Raw_value_style_enum_caseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRaw_value_style_enum_case(this);
}

myParser::Raw_value_style_enum_caseContext* myParser::raw_value_style_enum_case() {
  Raw_value_style_enum_caseContext *_localctx = _tracker.createInstance<Raw_value_style_enum_caseContext>(_ctx, getState());
  enterRule(_localctx, 264, myParser::RuleRaw_value_style_enum_case);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1518);
    enum_case_name();
    setState(1520);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::EQUAL) {
      setState(1519);
      raw_value_assignment();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Raw_value_assignmentContext ------------------------------------------------------------------

myParser::Raw_value_assignmentContext::Raw_value_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Raw_value_assignmentContext::EQUAL() {
  return getToken(myParser::EQUAL, 0);
}

myParser::Raw_value_literalContext* myParser::Raw_value_assignmentContext::raw_value_literal() {
  return getRuleContext<myParser::Raw_value_literalContext>(0);
}


size_t myParser::Raw_value_assignmentContext::getRuleIndex() const {
  return myParser::RuleRaw_value_assignment;
}

void myParser::Raw_value_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRaw_value_assignment(this);
}

void myParser::Raw_value_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRaw_value_assignment(this);
}

myParser::Raw_value_assignmentContext* myParser::raw_value_assignment() {
  Raw_value_assignmentContext *_localctx = _tracker.createInstance<Raw_value_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 266, myParser::RuleRaw_value_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1522);
    match(myParser::EQUAL);
    setState(1523);
    raw_value_literal();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Raw_value_literalContext ------------------------------------------------------------------

myParser::Raw_value_literalContext::Raw_value_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Numeric_literalContext* myParser::Raw_value_literalContext::numeric_literal() {
  return getRuleContext<myParser::Numeric_literalContext>(0);
}

myParser::Static_string_literalContext* myParser::Raw_value_literalContext::static_string_literal() {
  return getRuleContext<myParser::Static_string_literalContext>(0);
}

myParser::Boolean_literalContext* myParser::Raw_value_literalContext::boolean_literal() {
  return getRuleContext<myParser::Boolean_literalContext>(0);
}


size_t myParser::Raw_value_literalContext::getRuleIndex() const {
  return myParser::RuleRaw_value_literal;
}

void myParser::Raw_value_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRaw_value_literal(this);
}

void myParser::Raw_value_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRaw_value_literal(this);
}

myParser::Raw_value_literalContext* myParser::raw_value_literal() {
  Raw_value_literalContext *_localctx = _tracker.createInstance<Raw_value_literalContext>(_ctx, getState());
  enterRule(_localctx, 268, myParser::RuleRaw_value_literal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1528);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 149, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1525);
      numeric_literal();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1526);
      static_string_literal();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1527);
      boolean_literal();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Struct_declarationContext ------------------------------------------------------------------

myParser::Struct_declarationContext::Struct_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Struct_declarationContext::STRUCT() {
  return getToken(myParser::STRUCT, 0);
}

myParser::Struct_nameContext* myParser::Struct_declarationContext::struct_name() {
  return getRuleContext<myParser::Struct_nameContext>(0);
}

myParser::Struct_bodyContext* myParser::Struct_declarationContext::struct_body() {
  return getRuleContext<myParser::Struct_bodyContext>(0);
}

myParser::AttributesContext* myParser::Struct_declarationContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

myParser::Access_level_modifierContext* myParser::Struct_declarationContext::access_level_modifier() {
  return getRuleContext<myParser::Access_level_modifierContext>(0);
}

myParser::Generic_parameter_clauseContext* myParser::Struct_declarationContext::generic_parameter_clause() {
  return getRuleContext<myParser::Generic_parameter_clauseContext>(0);
}

myParser::Type_inheritance_clauseContext* myParser::Struct_declarationContext::type_inheritance_clause() {
  return getRuleContext<myParser::Type_inheritance_clauseContext>(0);
}

myParser::Generic_where_clauseContext* myParser::Struct_declarationContext::generic_where_clause() {
  return getRuleContext<myParser::Generic_where_clauseContext>(0);
}


size_t myParser::Struct_declarationContext::getRuleIndex() const {
  return myParser::RuleStruct_declaration;
}

void myParser::Struct_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStruct_declaration(this);
}

void myParser::Struct_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStruct_declaration(this);
}

myParser::Struct_declarationContext* myParser::struct_declaration() {
  Struct_declarationContext *_localctx = _tracker.createInstance<Struct_declarationContext>(_ctx, getState());
  enterRule(_localctx, 270, myParser::RuleStruct_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1531);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1530);
      attributes();
    }
    setState(1534);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 20) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 20)) & 576460752303423517) != 0)) {
      setState(1533);
      access_level_modifier();
    }
    setState(1536);
    match(myParser::STRUCT);
    setState(1537);
    struct_name();
    setState(1539);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LT) {
      setState(1538);
      generic_parameter_clause();
    }
    setState(1542);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::COLON) {
      setState(1541);
      type_inheritance_clause();
    }
    setState(1545);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::WHERE) {
      setState(1544);
      generic_where_clause();
    }
    setState(1547);
    struct_body();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Struct_nameContext ------------------------------------------------------------------

myParser::Struct_nameContext::Struct_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::Struct_nameContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}


size_t myParser::Struct_nameContext::getRuleIndex() const {
  return myParser::RuleStruct_name;
}

void myParser::Struct_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStruct_name(this);
}

void myParser::Struct_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStruct_name(this);
}

myParser::Struct_nameContext* myParser::struct_name() {
  Struct_nameContext *_localctx = _tracker.createInstance<Struct_nameContext>(_ctx, getState());
  enterRule(_localctx, 272, myParser::RuleStruct_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1549);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Struct_bodyContext ------------------------------------------------------------------

myParser::Struct_bodyContext::Struct_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Struct_bodyContext::LCURLY() {
  return getToken(myParser::LCURLY, 0);
}

myParser::Struct_membersContext* myParser::Struct_bodyContext::struct_members() {
  return getRuleContext<myParser::Struct_membersContext>(0);
}

tree::TerminalNode* myParser::Struct_bodyContext::RCURLY() {
  return getToken(myParser::RCURLY, 0);
}


size_t myParser::Struct_bodyContext::getRuleIndex() const {
  return myParser::RuleStruct_body;
}

void myParser::Struct_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStruct_body(this);
}

void myParser::Struct_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStruct_body(this);
}

myParser::Struct_bodyContext* myParser::struct_body() {
  Struct_bodyContext *_localctx = _tracker.createInstance<Struct_bodyContext>(_ctx, getState());
  enterRule(_localctx, 274, myParser::RuleStruct_body);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1551);
    match(myParser::LCURLY);
    setState(1552);
    struct_members();
    setState(1553);
    match(myParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Struct_membersContext ------------------------------------------------------------------

myParser::Struct_membersContext::Struct_membersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Struct_memberContext *> myParser::Struct_membersContext::struct_member() {
  return getRuleContexts<myParser::Struct_memberContext>();
}

myParser::Struct_memberContext* myParser::Struct_membersContext::struct_member(size_t i) {
  return getRuleContext<myParser::Struct_memberContext>(i);
}


size_t myParser::Struct_membersContext::getRuleIndex() const {
  return myParser::RuleStruct_members;
}

void myParser::Struct_membersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStruct_members(this);
}

void myParser::Struct_membersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStruct_members(this);
}

myParser::Struct_membersContext* myParser::struct_members() {
  Struct_membersContext *_localctx = _tracker.createInstance<Struct_membersContext>(_ctx, getState());
  enterRule(_localctx, 276, myParser::RuleStruct_members);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1558);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 725622768442875968) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 12525636463639039) != 0) || _la == myParser::AT) {
      setState(1555);
      struct_member();
      setState(1560);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Struct_memberContext ------------------------------------------------------------------

myParser::Struct_memberContext::Struct_memberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::DeclarationContext* myParser::Struct_memberContext::declaration() {
  return getRuleContext<myParser::DeclarationContext>(0);
}

myParser::Compiler_control_statementContext* myParser::Struct_memberContext::compiler_control_statement() {
  return getRuleContext<myParser::Compiler_control_statementContext>(0);
}


size_t myParser::Struct_memberContext::getRuleIndex() const {
  return myParser::RuleStruct_member;
}

void myParser::Struct_memberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStruct_member(this);
}

void myParser::Struct_memberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStruct_member(this);
}

myParser::Struct_memberContext* myParser::struct_member() {
  Struct_memberContext *_localctx = _tracker.createInstance<Struct_memberContext>(_ctx, getState());
  enterRule(_localctx, 278, myParser::RuleStruct_member);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1563);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::CLASS:
      case myParser::ENUM:
      case myParser::FUNC:
      case myParser::IMPORT:
      case myParser::INTERNAL:
      case myParser::FINAL:
      case myParser::OPEN:
      case myParser::PRIVATE:
      case myParser::PUBLIC:
      case myParser::LET:
      case myParser::VAR:
      case myParser::PROTOCOL:
      case myParser::STRUCT:
      case myParser::INDIRECT:
      case myParser::INIT:
      case myParser::DEINIT:
      case myParser::EXTENSION:
      case myParser::SUBSCRIPT:
      case myParser::PREFIX:
      case myParser::INFIX:
      case myParser::PRECEDENCE_GROUP:
      case myParser::POSTFIX:
      case myParser::TYPEALIAS:
      case myParser::CONVENIENCE:
      case myParser::DYNAMIC:
      case myParser::LAZY:
      case myParser::OPTIONAL:
      case myParser::OVERRIDE:
      case myParser::REQUIRED:
      case myParser::STATIC:
      case myParser::WEAK:
      case myParser::UNOWNED:
      case myParser::MUTATING:
      case myParser::NONMUTATING:
      case myParser::FILE_PRIVATE:
      case myParser::AT: {
        enterOuterAlt(_localctx, 1);
        setState(1561);
        declaration();
        break;
      }

      case myParser::SOURCE_LOCATION:
      case myParser::ERROR:
      case myParser::WARNING:
      case myParser::HASH_IF: {
        enterOuterAlt(_localctx, 2);
        setState(1562);
        compiler_control_statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_declarationContext ------------------------------------------------------------------

myParser::Class_declarationContext::Class_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Class_declarationContext::CLASS() {
  return getToken(myParser::CLASS, 0);
}

myParser::Class_nameContext* myParser::Class_declarationContext::class_name() {
  return getRuleContext<myParser::Class_nameContext>(0);
}

myParser::Class_bodyContext* myParser::Class_declarationContext::class_body() {
  return getRuleContext<myParser::Class_bodyContext>(0);
}

tree::TerminalNode* myParser::Class_declarationContext::FINAL() {
  return getToken(myParser::FINAL, 0);
}

myParser::AttributesContext* myParser::Class_declarationContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

myParser::Generic_parameter_clauseContext* myParser::Class_declarationContext::generic_parameter_clause() {
  return getRuleContext<myParser::Generic_parameter_clauseContext>(0);
}

myParser::Type_inheritance_clauseContext* myParser::Class_declarationContext::type_inheritance_clause() {
  return getRuleContext<myParser::Type_inheritance_clauseContext>(0);
}

myParser::Generic_where_clauseContext* myParser::Class_declarationContext::generic_where_clause() {
  return getRuleContext<myParser::Generic_where_clauseContext>(0);
}

myParser::Access_level_modifierContext* myParser::Class_declarationContext::access_level_modifier() {
  return getRuleContext<myParser::Access_level_modifierContext>(0);
}


size_t myParser::Class_declarationContext::getRuleIndex() const {
  return myParser::RuleClass_declaration;
}

void myParser::Class_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_declaration(this);
}

void myParser::Class_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_declaration(this);
}

myParser::Class_declarationContext* myParser::class_declaration() {
  Class_declarationContext *_localctx = _tracker.createInstance<Class_declarationContext>(_ctx, getState());
  enterRule(_localctx, 280, myParser::RuleClass_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1566);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1565);
      attributes();
    }
    setState(1578);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx)) {
    case 1: {
      setState(1569);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 20) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 20)) & 576460752303423517) != 0)) {
        setState(1568);
        access_level_modifier();
      }
      setState(1572);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::FINAL) {
        setState(1571);
        match(myParser::FINAL);
      }
      break;
    }

    case 2: {
      setState(1574);
      match(myParser::FINAL);
      setState(1576);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 20) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 20)) & 576460752303423517) != 0)) {
        setState(1575);
        access_level_modifier();
      }
      break;
    }

    default:
      break;
    }
    setState(1580);
    match(myParser::CLASS);
    setState(1581);
    class_name();
    setState(1583);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LT) {
      setState(1582);
      generic_parameter_clause();
    }
    setState(1586);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::COLON) {
      setState(1585);
      type_inheritance_clause();
    }
    setState(1589);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::WHERE) {
      setState(1588);
      generic_where_clause();
    }
    setState(1591);
    class_body();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_nameContext ------------------------------------------------------------------

myParser::Class_nameContext::Class_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::Class_nameContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}


size_t myParser::Class_nameContext::getRuleIndex() const {
  return myParser::RuleClass_name;
}

void myParser::Class_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_name(this);
}

void myParser::Class_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_name(this);
}

myParser::Class_nameContext* myParser::class_name() {
  Class_nameContext *_localctx = _tracker.createInstance<Class_nameContext>(_ctx, getState());
  enterRule(_localctx, 282, myParser::RuleClass_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1593);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_bodyContext ------------------------------------------------------------------

myParser::Class_bodyContext::Class_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Class_bodyContext::LCURLY() {
  return getToken(myParser::LCURLY, 0);
}

myParser::Class_membersContext* myParser::Class_bodyContext::class_members() {
  return getRuleContext<myParser::Class_membersContext>(0);
}

tree::TerminalNode* myParser::Class_bodyContext::RCURLY() {
  return getToken(myParser::RCURLY, 0);
}


size_t myParser::Class_bodyContext::getRuleIndex() const {
  return myParser::RuleClass_body;
}

void myParser::Class_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_body(this);
}

void myParser::Class_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_body(this);
}

myParser::Class_bodyContext* myParser::class_body() {
  Class_bodyContext *_localctx = _tracker.createInstance<Class_bodyContext>(_ctx, getState());
  enterRule(_localctx, 284, myParser::RuleClass_body);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1595);
    match(myParser::LCURLY);
    setState(1596);
    class_members();
    setState(1597);
    match(myParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_membersContext ------------------------------------------------------------------

myParser::Class_membersContext::Class_membersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Class_memberContext *> myParser::Class_membersContext::class_member() {
  return getRuleContexts<myParser::Class_memberContext>();
}

myParser::Class_memberContext* myParser::Class_membersContext::class_member(size_t i) {
  return getRuleContext<myParser::Class_memberContext>(i);
}


size_t myParser::Class_membersContext::getRuleIndex() const {
  return myParser::RuleClass_members;
}

void myParser::Class_membersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_members(this);
}

void myParser::Class_membersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_members(this);
}

myParser::Class_membersContext* myParser::class_members() {
  Class_membersContext *_localctx = _tracker.createInstance<Class_membersContext>(_ctx, getState());
  enterRule(_localctx, 286, myParser::RuleClass_members);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1602);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 725622768442875968) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 12525636463639039) != 0) || _la == myParser::AT) {
      setState(1599);
      class_member();
      setState(1604);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_memberContext ------------------------------------------------------------------

myParser::Class_memberContext::Class_memberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::DeclarationContext* myParser::Class_memberContext::declaration() {
  return getRuleContext<myParser::DeclarationContext>(0);
}

myParser::Compiler_control_statementContext* myParser::Class_memberContext::compiler_control_statement() {
  return getRuleContext<myParser::Compiler_control_statementContext>(0);
}


size_t myParser::Class_memberContext::getRuleIndex() const {
  return myParser::RuleClass_member;
}

void myParser::Class_memberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_member(this);
}

void myParser::Class_memberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_member(this);
}

myParser::Class_memberContext* myParser::class_member() {
  Class_memberContext *_localctx = _tracker.createInstance<Class_memberContext>(_ctx, getState());
  enterRule(_localctx, 288, myParser::RuleClass_member);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1607);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::CLASS:
      case myParser::ENUM:
      case myParser::FUNC:
      case myParser::IMPORT:
      case myParser::INTERNAL:
      case myParser::FINAL:
      case myParser::OPEN:
      case myParser::PRIVATE:
      case myParser::PUBLIC:
      case myParser::LET:
      case myParser::VAR:
      case myParser::PROTOCOL:
      case myParser::STRUCT:
      case myParser::INDIRECT:
      case myParser::INIT:
      case myParser::DEINIT:
      case myParser::EXTENSION:
      case myParser::SUBSCRIPT:
      case myParser::PREFIX:
      case myParser::INFIX:
      case myParser::PRECEDENCE_GROUP:
      case myParser::POSTFIX:
      case myParser::TYPEALIAS:
      case myParser::CONVENIENCE:
      case myParser::DYNAMIC:
      case myParser::LAZY:
      case myParser::OPTIONAL:
      case myParser::OVERRIDE:
      case myParser::REQUIRED:
      case myParser::STATIC:
      case myParser::WEAK:
      case myParser::UNOWNED:
      case myParser::MUTATING:
      case myParser::NONMUTATING:
      case myParser::FILE_PRIVATE:
      case myParser::AT: {
        enterOuterAlt(_localctx, 1);
        setState(1605);
        declaration();
        break;
      }

      case myParser::SOURCE_LOCATION:
      case myParser::ERROR:
      case myParser::WARNING:
      case myParser::HASH_IF: {
        enterOuterAlt(_localctx, 2);
        setState(1606);
        compiler_control_statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Protocol_declarationContext ------------------------------------------------------------------

myParser::Protocol_declarationContext::Protocol_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Protocol_declarationContext::PROTOCOL() {
  return getToken(myParser::PROTOCOL, 0);
}

myParser::Protocol_nameContext* myParser::Protocol_declarationContext::protocol_name() {
  return getRuleContext<myParser::Protocol_nameContext>(0);
}

myParser::Protocol_bodyContext* myParser::Protocol_declarationContext::protocol_body() {
  return getRuleContext<myParser::Protocol_bodyContext>(0);
}

myParser::AttributesContext* myParser::Protocol_declarationContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

myParser::Access_level_modifierContext* myParser::Protocol_declarationContext::access_level_modifier() {
  return getRuleContext<myParser::Access_level_modifierContext>(0);
}

tree::TerminalNode* myParser::Protocol_declarationContext::COLON() {
  return getToken(myParser::COLON, 0);
}

tree::TerminalNode* myParser::Protocol_declarationContext::CLASS() {
  return getToken(myParser::CLASS, 0);
}

myParser::Type_inheritance_clauseContext* myParser::Protocol_declarationContext::type_inheritance_clause() {
  return getRuleContext<myParser::Type_inheritance_clauseContext>(0);
}

myParser::Generic_where_clauseContext* myParser::Protocol_declarationContext::generic_where_clause() {
  return getRuleContext<myParser::Generic_where_clauseContext>(0);
}


size_t myParser::Protocol_declarationContext::getRuleIndex() const {
  return myParser::RuleProtocol_declaration;
}

void myParser::Protocol_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProtocol_declaration(this);
}

void myParser::Protocol_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProtocol_declaration(this);
}

myParser::Protocol_declarationContext* myParser::protocol_declaration() {
  Protocol_declarationContext *_localctx = _tracker.createInstance<Protocol_declarationContext>(_ctx, getState());
  enterRule(_localctx, 290, myParser::RuleProtocol_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1610);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1609);
      attributes();
    }
    setState(1613);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 20) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 20)) & 576460752303423517) != 0)) {
      setState(1612);
      access_level_modifier();
    }
    setState(1615);
    match(myParser::PROTOCOL);
    setState(1616);
    protocol_name();
    setState(1620);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx)) {
    case 1: {
      setState(1617);
      match(myParser::COLON);
      setState(1618);
      match(myParser::CLASS);
      break;
    }

    case 2: {
      setState(1619);
      type_inheritance_clause();
      break;
    }

    default:
      break;
    }
    setState(1623);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::WHERE) {
      setState(1622);
      generic_where_clause();
    }
    setState(1625);
    protocol_body();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Protocol_nameContext ------------------------------------------------------------------

myParser::Protocol_nameContext::Protocol_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::Protocol_nameContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}


size_t myParser::Protocol_nameContext::getRuleIndex() const {
  return myParser::RuleProtocol_name;
}

void myParser::Protocol_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProtocol_name(this);
}

void myParser::Protocol_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProtocol_name(this);
}

myParser::Protocol_nameContext* myParser::protocol_name() {
  Protocol_nameContext *_localctx = _tracker.createInstance<Protocol_nameContext>(_ctx, getState());
  enterRule(_localctx, 292, myParser::RuleProtocol_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1627);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Protocol_bodyContext ------------------------------------------------------------------

myParser::Protocol_bodyContext::Protocol_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Protocol_bodyContext::LCURLY() {
  return getToken(myParser::LCURLY, 0);
}

myParser::Protocol_membersContext* myParser::Protocol_bodyContext::protocol_members() {
  return getRuleContext<myParser::Protocol_membersContext>(0);
}

tree::TerminalNode* myParser::Protocol_bodyContext::RCURLY() {
  return getToken(myParser::RCURLY, 0);
}


size_t myParser::Protocol_bodyContext::getRuleIndex() const {
  return myParser::RuleProtocol_body;
}

void myParser::Protocol_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProtocol_body(this);
}

void myParser::Protocol_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProtocol_body(this);
}

myParser::Protocol_bodyContext* myParser::protocol_body() {
  Protocol_bodyContext *_localctx = _tracker.createInstance<Protocol_bodyContext>(_ctx, getState());
  enterRule(_localctx, 294, myParser::RuleProtocol_body);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1629);
    match(myParser::LCURLY);
    setState(1630);
    protocol_members();
    setState(1631);
    match(myParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Protocol_membersContext ------------------------------------------------------------------

myParser::Protocol_membersContext::Protocol_membersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Protocol_memberContext *> myParser::Protocol_membersContext::protocol_member() {
  return getRuleContexts<myParser::Protocol_memberContext>();
}

myParser::Protocol_memberContext* myParser::Protocol_membersContext::protocol_member(size_t i) {
  return getRuleContext<myParser::Protocol_memberContext>(i);
}


size_t myParser::Protocol_membersContext::getRuleIndex() const {
  return myParser::RuleProtocol_members;
}

void myParser::Protocol_membersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProtocol_members(this);
}

void myParser::Protocol_membersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProtocol_members(this);
}

myParser::Protocol_membersContext* myParser::protocol_members() {
  Protocol_membersContext *_localctx = _tracker.createInstance<Protocol_membersContext>(_ctx, getState());
  enterRule(_localctx, 296, myParser::RuleProtocol_members);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1636);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 721090512122085440) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 12525636463639039) != 0) || _la == myParser::AT) {
      setState(1633);
      protocol_member();
      setState(1638);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Protocol_memberContext ------------------------------------------------------------------

myParser::Protocol_memberContext::Protocol_memberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Protocol_member_declarationContext* myParser::Protocol_memberContext::protocol_member_declaration() {
  return getRuleContext<myParser::Protocol_member_declarationContext>(0);
}

myParser::Compiler_control_statementContext* myParser::Protocol_memberContext::compiler_control_statement() {
  return getRuleContext<myParser::Compiler_control_statementContext>(0);
}


size_t myParser::Protocol_memberContext::getRuleIndex() const {
  return myParser::RuleProtocol_member;
}

void myParser::Protocol_memberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProtocol_member(this);
}

void myParser::Protocol_memberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProtocol_member(this);
}

myParser::Protocol_memberContext* myParser::protocol_member() {
  Protocol_memberContext *_localctx = _tracker.createInstance<Protocol_memberContext>(_ctx, getState());
  enterRule(_localctx, 298, myParser::RuleProtocol_member);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1641);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::CLASS:
      case myParser::FUNC:
      case myParser::INTERNAL:
      case myParser::FINAL:
      case myParser::OPEN:
      case myParser::PRIVATE:
      case myParser::PUBLIC:
      case myParser::VAR:
      case myParser::INIT:
      case myParser::ASSOCIATED_TYPE:
      case myParser::SUBSCRIPT:
      case myParser::PREFIX:
      case myParser::INFIX:
      case myParser::POSTFIX:
      case myParser::TYPEALIAS:
      case myParser::CONVENIENCE:
      case myParser::DYNAMIC:
      case myParser::LAZY:
      case myParser::OPTIONAL:
      case myParser::OVERRIDE:
      case myParser::REQUIRED:
      case myParser::STATIC:
      case myParser::WEAK:
      case myParser::UNOWNED:
      case myParser::MUTATING:
      case myParser::NONMUTATING:
      case myParser::FILE_PRIVATE:
      case myParser::AT: {
        enterOuterAlt(_localctx, 1);
        setState(1639);
        protocol_member_declaration();
        break;
      }

      case myParser::SOURCE_LOCATION:
      case myParser::ERROR:
      case myParser::WARNING:
      case myParser::HASH_IF: {
        enterOuterAlt(_localctx, 2);
        setState(1640);
        compiler_control_statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Protocol_member_declarationContext ------------------------------------------------------------------

myParser::Protocol_member_declarationContext::Protocol_member_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Protocol_property_declarationContext* myParser::Protocol_member_declarationContext::protocol_property_declaration() {
  return getRuleContext<myParser::Protocol_property_declarationContext>(0);
}

myParser::Protocol_method_declarationContext* myParser::Protocol_member_declarationContext::protocol_method_declaration() {
  return getRuleContext<myParser::Protocol_method_declarationContext>(0);
}

myParser::Protocol_initializer_declarationContext* myParser::Protocol_member_declarationContext::protocol_initializer_declaration() {
  return getRuleContext<myParser::Protocol_initializer_declarationContext>(0);
}

myParser::Protocol_subscript_declarationContext* myParser::Protocol_member_declarationContext::protocol_subscript_declaration() {
  return getRuleContext<myParser::Protocol_subscript_declarationContext>(0);
}

myParser::Protocol_associated_type_declarationContext* myParser::Protocol_member_declarationContext::protocol_associated_type_declaration() {
  return getRuleContext<myParser::Protocol_associated_type_declarationContext>(0);
}

myParser::Typealias_declarationContext* myParser::Protocol_member_declarationContext::typealias_declaration() {
  return getRuleContext<myParser::Typealias_declarationContext>(0);
}


size_t myParser::Protocol_member_declarationContext::getRuleIndex() const {
  return myParser::RuleProtocol_member_declaration;
}

void myParser::Protocol_member_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProtocol_member_declaration(this);
}

void myParser::Protocol_member_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProtocol_member_declaration(this);
}

myParser::Protocol_member_declarationContext* myParser::protocol_member_declaration() {
  Protocol_member_declarationContext *_localctx = _tracker.createInstance<Protocol_member_declarationContext>(_ctx, getState());
  enterRule(_localctx, 300, myParser::RuleProtocol_member_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1649);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 173, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1643);
      protocol_property_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1644);
      protocol_method_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1645);
      protocol_initializer_declaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1646);
      protocol_subscript_declaration();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1647);
      protocol_associated_type_declaration();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1648);
      typealias_declaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Protocol_property_declarationContext ------------------------------------------------------------------

myParser::Protocol_property_declarationContext::Protocol_property_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Variable_declaration_headContext* myParser::Protocol_property_declarationContext::variable_declaration_head() {
  return getRuleContext<myParser::Variable_declaration_headContext>(0);
}

myParser::Variable_nameContext* myParser::Protocol_property_declarationContext::variable_name() {
  return getRuleContext<myParser::Variable_nameContext>(0);
}

myParser::Type_annotationContext* myParser::Protocol_property_declarationContext::type_annotation() {
  return getRuleContext<myParser::Type_annotationContext>(0);
}

myParser::Getter_setter_keyword_blockContext* myParser::Protocol_property_declarationContext::getter_setter_keyword_block() {
  return getRuleContext<myParser::Getter_setter_keyword_blockContext>(0);
}


size_t myParser::Protocol_property_declarationContext::getRuleIndex() const {
  return myParser::RuleProtocol_property_declaration;
}

void myParser::Protocol_property_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProtocol_property_declaration(this);
}

void myParser::Protocol_property_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProtocol_property_declaration(this);
}

myParser::Protocol_property_declarationContext* myParser::protocol_property_declaration() {
  Protocol_property_declarationContext *_localctx = _tracker.createInstance<Protocol_property_declarationContext>(_ctx, getState());
  enterRule(_localctx, 302, myParser::RuleProtocol_property_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1651);
    variable_declaration_head();
    setState(1652);
    variable_name();
    setState(1653);
    type_annotation();
    setState(1654);
    getter_setter_keyword_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Protocol_method_declarationContext ------------------------------------------------------------------

myParser::Protocol_method_declarationContext::Protocol_method_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Function_headContext* myParser::Protocol_method_declarationContext::function_head() {
  return getRuleContext<myParser::Function_headContext>(0);
}

myParser::Function_nameContext* myParser::Protocol_method_declarationContext::function_name() {
  return getRuleContext<myParser::Function_nameContext>(0);
}

myParser::Function_signatureContext* myParser::Protocol_method_declarationContext::function_signature() {
  return getRuleContext<myParser::Function_signatureContext>(0);
}

myParser::Generic_parameter_clauseContext* myParser::Protocol_method_declarationContext::generic_parameter_clause() {
  return getRuleContext<myParser::Generic_parameter_clauseContext>(0);
}

myParser::Generic_where_clauseContext* myParser::Protocol_method_declarationContext::generic_where_clause() {
  return getRuleContext<myParser::Generic_where_clauseContext>(0);
}


size_t myParser::Protocol_method_declarationContext::getRuleIndex() const {
  return myParser::RuleProtocol_method_declaration;
}

void myParser::Protocol_method_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProtocol_method_declaration(this);
}

void myParser::Protocol_method_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProtocol_method_declaration(this);
}

myParser::Protocol_method_declarationContext* myParser::protocol_method_declaration() {
  Protocol_method_declarationContext *_localctx = _tracker.createInstance<Protocol_method_declarationContext>(_ctx, getState());
  enterRule(_localctx, 304, myParser::RuleProtocol_method_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1656);
    function_head();
    setState(1657);
    function_name();
    setState(1659);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LT) {
      setState(1658);
      generic_parameter_clause();
    }
    setState(1661);
    function_signature();
    setState(1663);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::WHERE) {
      setState(1662);
      generic_where_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Protocol_initializer_declarationContext ------------------------------------------------------------------

myParser::Protocol_initializer_declarationContext::Protocol_initializer_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Initializer_headContext* myParser::Protocol_initializer_declarationContext::initializer_head() {
  return getRuleContext<myParser::Initializer_headContext>(0);
}

myParser::Parameter_clauseContext* myParser::Protocol_initializer_declarationContext::parameter_clause() {
  return getRuleContext<myParser::Parameter_clauseContext>(0);
}

tree::TerminalNode* myParser::Protocol_initializer_declarationContext::RETHROWS() {
  return getToken(myParser::RETHROWS, 0);
}

myParser::Generic_parameter_clauseContext* myParser::Protocol_initializer_declarationContext::generic_parameter_clause() {
  return getRuleContext<myParser::Generic_parameter_clauseContext>(0);
}

myParser::Generic_where_clauseContext* myParser::Protocol_initializer_declarationContext::generic_where_clause() {
  return getRuleContext<myParser::Generic_where_clauseContext>(0);
}

tree::TerminalNode* myParser::Protocol_initializer_declarationContext::THROWS() {
  return getToken(myParser::THROWS, 0);
}


size_t myParser::Protocol_initializer_declarationContext::getRuleIndex() const {
  return myParser::RuleProtocol_initializer_declaration;
}

void myParser::Protocol_initializer_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProtocol_initializer_declaration(this);
}

void myParser::Protocol_initializer_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProtocol_initializer_declaration(this);
}

myParser::Protocol_initializer_declarationContext* myParser::protocol_initializer_declaration() {
  Protocol_initializer_declarationContext *_localctx = _tracker.createInstance<Protocol_initializer_declarationContext>(_ctx, getState());
  enterRule(_localctx, 306, myParser::RuleProtocol_initializer_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1665);
    initializer_head();
    setState(1667);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LT) {
      setState(1666);
      generic_parameter_clause();
    }
    setState(1669);
    parameter_clause();
    setState(1674);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::CLASS:
      case myParser::FUNC:
      case myParser::INTERNAL:
      case myParser::FINAL:
      case myParser::OPEN:
      case myParser::PRIVATE:
      case myParser::PUBLIC:
      case myParser::WHERE:
      case myParser::VAR:
      case myParser::THROWS:
      case myParser::INIT:
      case myParser::ASSOCIATED_TYPE:
      case myParser::SUBSCRIPT:
      case myParser::PREFIX:
      case myParser::INFIX:
      case myParser::POSTFIX:
      case myParser::TYPEALIAS:
      case myParser::CONVENIENCE:
      case myParser::DYNAMIC:
      case myParser::LAZY:
      case myParser::OPTIONAL:
      case myParser::OVERRIDE:
      case myParser::REQUIRED:
      case myParser::STATIC:
      case myParser::WEAK:
      case myParser::UNOWNED:
      case myParser::MUTATING:
      case myParser::NONMUTATING:
      case myParser::FILE_PRIVATE:
      case myParser::SOURCE_LOCATION:
      case myParser::ERROR:
      case myParser::WARNING:
      case myParser::HASH_IF:
      case myParser::RCURLY:
      case myParser::AT: {
        setState(1671);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::THROWS) {
          setState(1670);
          match(myParser::THROWS);
        }
        break;
      }

      case myParser::RETHROWS: {
        setState(1673);
        match(myParser::RETHROWS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1677);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::WHERE) {
      setState(1676);
      generic_where_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Protocol_subscript_declarationContext ------------------------------------------------------------------

myParser::Protocol_subscript_declarationContext::Protocol_subscript_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Subscript_headContext* myParser::Protocol_subscript_declarationContext::subscript_head() {
  return getRuleContext<myParser::Subscript_headContext>(0);
}

myParser::Subscript_resultContext* myParser::Protocol_subscript_declarationContext::subscript_result() {
  return getRuleContext<myParser::Subscript_resultContext>(0);
}

myParser::Getter_setter_keyword_blockContext* myParser::Protocol_subscript_declarationContext::getter_setter_keyword_block() {
  return getRuleContext<myParser::Getter_setter_keyword_blockContext>(0);
}

myParser::Generic_where_clauseContext* myParser::Protocol_subscript_declarationContext::generic_where_clause() {
  return getRuleContext<myParser::Generic_where_clauseContext>(0);
}


size_t myParser::Protocol_subscript_declarationContext::getRuleIndex() const {
  return myParser::RuleProtocol_subscript_declaration;
}

void myParser::Protocol_subscript_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProtocol_subscript_declaration(this);
}

void myParser::Protocol_subscript_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProtocol_subscript_declaration(this);
}

myParser::Protocol_subscript_declarationContext* myParser::protocol_subscript_declaration() {
  Protocol_subscript_declarationContext *_localctx = _tracker.createInstance<Protocol_subscript_declarationContext>(_ctx, getState());
  enterRule(_localctx, 308, myParser::RuleProtocol_subscript_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1679);
    subscript_head();
    setState(1680);
    subscript_result();
    setState(1682);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::WHERE) {
      setState(1681);
      generic_where_clause();
    }
    setState(1684);
    getter_setter_keyword_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Protocol_associated_type_declarationContext ------------------------------------------------------------------

myParser::Protocol_associated_type_declarationContext::Protocol_associated_type_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Protocol_associated_type_declarationContext::ASSOCIATED_TYPE() {
  return getToken(myParser::ASSOCIATED_TYPE, 0);
}

myParser::Typealias_nameContext* myParser::Protocol_associated_type_declarationContext::typealias_name() {
  return getRuleContext<myParser::Typealias_nameContext>(0);
}

myParser::AttributesContext* myParser::Protocol_associated_type_declarationContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

myParser::Access_level_modifierContext* myParser::Protocol_associated_type_declarationContext::access_level_modifier() {
  return getRuleContext<myParser::Access_level_modifierContext>(0);
}

myParser::Type_inheritance_clauseContext* myParser::Protocol_associated_type_declarationContext::type_inheritance_clause() {
  return getRuleContext<myParser::Type_inheritance_clauseContext>(0);
}

myParser::Typealias_assignmentContext* myParser::Protocol_associated_type_declarationContext::typealias_assignment() {
  return getRuleContext<myParser::Typealias_assignmentContext>(0);
}

myParser::Generic_where_clauseContext* myParser::Protocol_associated_type_declarationContext::generic_where_clause() {
  return getRuleContext<myParser::Generic_where_clauseContext>(0);
}


size_t myParser::Protocol_associated_type_declarationContext::getRuleIndex() const {
  return myParser::RuleProtocol_associated_type_declaration;
}

void myParser::Protocol_associated_type_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProtocol_associated_type_declaration(this);
}

void myParser::Protocol_associated_type_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProtocol_associated_type_declaration(this);
}

myParser::Protocol_associated_type_declarationContext* myParser::protocol_associated_type_declaration() {
  Protocol_associated_type_declarationContext *_localctx = _tracker.createInstance<Protocol_associated_type_declarationContext>(_ctx, getState());
  enterRule(_localctx, 310, myParser::RuleProtocol_associated_type_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1687);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1686);
      attributes();
    }
    setState(1690);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 20) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 20)) & 576460752303423517) != 0)) {
      setState(1689);
      access_level_modifier();
    }
    setState(1692);
    match(myParser::ASSOCIATED_TYPE);
    setState(1693);
    typealias_name();
    setState(1695);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::COLON) {
      setState(1694);
      type_inheritance_clause();
    }
    setState(1698);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::EQUAL) {
      setState(1697);
      typealias_assignment();
    }
    setState(1701);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::WHERE) {
      setState(1700);
      generic_where_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Initializer_declarationContext ------------------------------------------------------------------

myParser::Initializer_declarationContext::Initializer_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Initializer_headContext* myParser::Initializer_declarationContext::initializer_head() {
  return getRuleContext<myParser::Initializer_headContext>(0);
}

myParser::Parameter_clauseContext* myParser::Initializer_declarationContext::parameter_clause() {
  return getRuleContext<myParser::Parameter_clauseContext>(0);
}

myParser::Initializer_bodyContext* myParser::Initializer_declarationContext::initializer_body() {
  return getRuleContext<myParser::Initializer_bodyContext>(0);
}

myParser::Generic_parameter_clauseContext* myParser::Initializer_declarationContext::generic_parameter_clause() {
  return getRuleContext<myParser::Generic_parameter_clauseContext>(0);
}

myParser::Generic_where_clauseContext* myParser::Initializer_declarationContext::generic_where_clause() {
  return getRuleContext<myParser::Generic_where_clauseContext>(0);
}

tree::TerminalNode* myParser::Initializer_declarationContext::THROWS() {
  return getToken(myParser::THROWS, 0);
}

tree::TerminalNode* myParser::Initializer_declarationContext::RETHROWS() {
  return getToken(myParser::RETHROWS, 0);
}


size_t myParser::Initializer_declarationContext::getRuleIndex() const {
  return myParser::RuleInitializer_declaration;
}

void myParser::Initializer_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitializer_declaration(this);
}

void myParser::Initializer_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitializer_declaration(this);
}

myParser::Initializer_declarationContext* myParser::initializer_declaration() {
  Initializer_declarationContext *_localctx = _tracker.createInstance<Initializer_declarationContext>(_ctx, getState());
  enterRule(_localctx, 312, myParser::RuleInitializer_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1703);
    initializer_head();
    setState(1705);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LT) {
      setState(1704);
      generic_parameter_clause();
    }
    setState(1707);
    parameter_clause();
    setState(1709);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::THROWS

    || _la == myParser::RETHROWS) {
      setState(1708);
      _la = _input->LA(1);
      if (!(_la == myParser::THROWS

      || _la == myParser::RETHROWS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1712);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::WHERE) {
      setState(1711);
      generic_where_clause();
    }
    setState(1714);
    initializer_body();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Initializer_headContext ------------------------------------------------------------------

myParser::Initializer_headContext::Initializer_headContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Initializer_headContext::INIT() {
  return getToken(myParser::INIT, 0);
}

myParser::AttributesContext* myParser::Initializer_headContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

myParser::Declaration_modifiersContext* myParser::Initializer_headContext::declaration_modifiers() {
  return getRuleContext<myParser::Declaration_modifiersContext>(0);
}

tree::TerminalNode* myParser::Initializer_headContext::QUESTION() {
  return getToken(myParser::QUESTION, 0);
}

tree::TerminalNode* myParser::Initializer_headContext::BANG() {
  return getToken(myParser::BANG, 0);
}


size_t myParser::Initializer_headContext::getRuleIndex() const {
  return myParser::RuleInitializer_head;
}

void myParser::Initializer_headContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitializer_head(this);
}

void myParser::Initializer_headContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitializer_head(this);
}

myParser::Initializer_headContext* myParser::initializer_head() {
  Initializer_headContext *_localctx = _tracker.createInstance<Initializer_headContext>(_ctx, getState());
  enterRule(_localctx, 314, myParser::RuleInitializer_head);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1717);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1716);
      attributes();
    }
    setState(1720);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 144537400573427776) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 14847) != 0)) {
      setState(1719);
      declaration_modifiers();
    }
    setState(1722);
    match(myParser::INIT);
    setState(1724);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::BANG

    || _la == myParser::QUESTION) {
      setState(1723);
      _la = _input->LA(1);
      if (!(_la == myParser::BANG

      || _la == myParser::QUESTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Initializer_bodyContext ------------------------------------------------------------------

myParser::Initializer_bodyContext::Initializer_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Code_blockContext* myParser::Initializer_bodyContext::code_block() {
  return getRuleContext<myParser::Code_blockContext>(0);
}


size_t myParser::Initializer_bodyContext::getRuleIndex() const {
  return myParser::RuleInitializer_body;
}

void myParser::Initializer_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitializer_body(this);
}

void myParser::Initializer_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitializer_body(this);
}

myParser::Initializer_bodyContext* myParser::initializer_body() {
  Initializer_bodyContext *_localctx = _tracker.createInstance<Initializer_bodyContext>(_ctx, getState());
  enterRule(_localctx, 316, myParser::RuleInitializer_body);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1726);
    code_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Deinitializer_declarationContext ------------------------------------------------------------------

myParser::Deinitializer_declarationContext::Deinitializer_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Deinitializer_declarationContext::DEINIT() {
  return getToken(myParser::DEINIT, 0);
}

myParser::Code_blockContext* myParser::Deinitializer_declarationContext::code_block() {
  return getRuleContext<myParser::Code_blockContext>(0);
}

myParser::AttributesContext* myParser::Deinitializer_declarationContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}


size_t myParser::Deinitializer_declarationContext::getRuleIndex() const {
  return myParser::RuleDeinitializer_declaration;
}

void myParser::Deinitializer_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeinitializer_declaration(this);
}

void myParser::Deinitializer_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeinitializer_declaration(this);
}

myParser::Deinitializer_declarationContext* myParser::deinitializer_declaration() {
  Deinitializer_declarationContext *_localctx = _tracker.createInstance<Deinitializer_declarationContext>(_ctx, getState());
  enterRule(_localctx, 318, myParser::RuleDeinitializer_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1729);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1728);
      attributes();
    }
    setState(1731);
    match(myParser::DEINIT);
    setState(1732);
    code_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Extension_declarationContext ------------------------------------------------------------------

myParser::Extension_declarationContext::Extension_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Extension_declarationContext::EXTENSION() {
  return getToken(myParser::EXTENSION, 0);
}

myParser::Type_identifierContext* myParser::Extension_declarationContext::type_identifier() {
  return getRuleContext<myParser::Type_identifierContext>(0);
}

myParser::Extension_bodyContext* myParser::Extension_declarationContext::extension_body() {
  return getRuleContext<myParser::Extension_bodyContext>(0);
}

myParser::AttributesContext* myParser::Extension_declarationContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

myParser::Access_level_modifierContext* myParser::Extension_declarationContext::access_level_modifier() {
  return getRuleContext<myParser::Access_level_modifierContext>(0);
}

myParser::Type_inheritance_clauseContext* myParser::Extension_declarationContext::type_inheritance_clause() {
  return getRuleContext<myParser::Type_inheritance_clauseContext>(0);
}

myParser::Generic_where_clauseContext* myParser::Extension_declarationContext::generic_where_clause() {
  return getRuleContext<myParser::Generic_where_clauseContext>(0);
}


size_t myParser::Extension_declarationContext::getRuleIndex() const {
  return myParser::RuleExtension_declaration;
}

void myParser::Extension_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExtension_declaration(this);
}

void myParser::Extension_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExtension_declaration(this);
}

myParser::Extension_declarationContext* myParser::extension_declaration() {
  Extension_declarationContext *_localctx = _tracker.createInstance<Extension_declarationContext>(_ctx, getState());
  enterRule(_localctx, 320, myParser::RuleExtension_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1735);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1734);
      attributes();
    }
    setState(1738);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 20) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 20)) & 576460752303423517) != 0)) {
      setState(1737);
      access_level_modifier();
    }
    setState(1740);
    match(myParser::EXTENSION);
    setState(1741);
    type_identifier();
    setState(1743);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::COLON) {
      setState(1742);
      type_inheritance_clause();
    }
    setState(1746);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::WHERE) {
      setState(1745);
      generic_where_clause();
    }
    setState(1748);
    extension_body();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Extension_bodyContext ------------------------------------------------------------------

myParser::Extension_bodyContext::Extension_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Extension_bodyContext::LCURLY() {
  return getToken(myParser::LCURLY, 0);
}

myParser::Extension_membersContext* myParser::Extension_bodyContext::extension_members() {
  return getRuleContext<myParser::Extension_membersContext>(0);
}

tree::TerminalNode* myParser::Extension_bodyContext::RCURLY() {
  return getToken(myParser::RCURLY, 0);
}


size_t myParser::Extension_bodyContext::getRuleIndex() const {
  return myParser::RuleExtension_body;
}

void myParser::Extension_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExtension_body(this);
}

void myParser::Extension_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExtension_body(this);
}

myParser::Extension_bodyContext* myParser::extension_body() {
  Extension_bodyContext *_localctx = _tracker.createInstance<Extension_bodyContext>(_ctx, getState());
  enterRule(_localctx, 322, myParser::RuleExtension_body);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1750);
    match(myParser::LCURLY);
    setState(1751);
    extension_members();
    setState(1752);
    match(myParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Extension_membersContext ------------------------------------------------------------------

myParser::Extension_membersContext::Extension_membersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Extension_memberContext *> myParser::Extension_membersContext::extension_member() {
  return getRuleContexts<myParser::Extension_memberContext>();
}

myParser::Extension_memberContext* myParser::Extension_membersContext::extension_member(size_t i) {
  return getRuleContext<myParser::Extension_memberContext>(i);
}


size_t myParser::Extension_membersContext::getRuleIndex() const {
  return myParser::RuleExtension_members;
}

void myParser::Extension_membersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExtension_members(this);
}

void myParser::Extension_membersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExtension_members(this);
}

myParser::Extension_membersContext* myParser::extension_members() {
  Extension_membersContext *_localctx = _tracker.createInstance<Extension_membersContext>(_ctx, getState());
  enterRule(_localctx, 324, myParser::RuleExtension_members);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1757);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 725622768442875968) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 12525636463639039) != 0) || _la == myParser::AT) {
      setState(1754);
      extension_member();
      setState(1759);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Extension_memberContext ------------------------------------------------------------------

myParser::Extension_memberContext::Extension_memberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::DeclarationContext* myParser::Extension_memberContext::declaration() {
  return getRuleContext<myParser::DeclarationContext>(0);
}

myParser::Compiler_control_statementContext* myParser::Extension_memberContext::compiler_control_statement() {
  return getRuleContext<myParser::Compiler_control_statementContext>(0);
}


size_t myParser::Extension_memberContext::getRuleIndex() const {
  return myParser::RuleExtension_member;
}

void myParser::Extension_memberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExtension_member(this);
}

void myParser::Extension_memberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExtension_member(this);
}

myParser::Extension_memberContext* myParser::extension_member() {
  Extension_memberContext *_localctx = _tracker.createInstance<Extension_memberContext>(_ctx, getState());
  enterRule(_localctx, 326, myParser::RuleExtension_member);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1762);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::CLASS:
      case myParser::ENUM:
      case myParser::FUNC:
      case myParser::IMPORT:
      case myParser::INTERNAL:
      case myParser::FINAL:
      case myParser::OPEN:
      case myParser::PRIVATE:
      case myParser::PUBLIC:
      case myParser::LET:
      case myParser::VAR:
      case myParser::PROTOCOL:
      case myParser::STRUCT:
      case myParser::INDIRECT:
      case myParser::INIT:
      case myParser::DEINIT:
      case myParser::EXTENSION:
      case myParser::SUBSCRIPT:
      case myParser::PREFIX:
      case myParser::INFIX:
      case myParser::PRECEDENCE_GROUP:
      case myParser::POSTFIX:
      case myParser::TYPEALIAS:
      case myParser::CONVENIENCE:
      case myParser::DYNAMIC:
      case myParser::LAZY:
      case myParser::OPTIONAL:
      case myParser::OVERRIDE:
      case myParser::REQUIRED:
      case myParser::STATIC:
      case myParser::WEAK:
      case myParser::UNOWNED:
      case myParser::MUTATING:
      case myParser::NONMUTATING:
      case myParser::FILE_PRIVATE:
      case myParser::AT: {
        enterOuterAlt(_localctx, 1);
        setState(1760);
        declaration();
        break;
      }

      case myParser::SOURCE_LOCATION:
      case myParser::ERROR:
      case myParser::WARNING:
      case myParser::HASH_IF: {
        enterOuterAlt(_localctx, 2);
        setState(1761);
        compiler_control_statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subscript_declarationContext ------------------------------------------------------------------

myParser::Subscript_declarationContext::Subscript_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Subscript_headContext* myParser::Subscript_declarationContext::subscript_head() {
  return getRuleContext<myParser::Subscript_headContext>(0);
}

myParser::Subscript_resultContext* myParser::Subscript_declarationContext::subscript_result() {
  return getRuleContext<myParser::Subscript_resultContext>(0);
}

myParser::Code_blockContext* myParser::Subscript_declarationContext::code_block() {
  return getRuleContext<myParser::Code_blockContext>(0);
}

myParser::Getter_setter_blockContext* myParser::Subscript_declarationContext::getter_setter_block() {
  return getRuleContext<myParser::Getter_setter_blockContext>(0);
}

myParser::Getter_setter_keyword_blockContext* myParser::Subscript_declarationContext::getter_setter_keyword_block() {
  return getRuleContext<myParser::Getter_setter_keyword_blockContext>(0);
}

myParser::Generic_where_clauseContext* myParser::Subscript_declarationContext::generic_where_clause() {
  return getRuleContext<myParser::Generic_where_clauseContext>(0);
}


size_t myParser::Subscript_declarationContext::getRuleIndex() const {
  return myParser::RuleSubscript_declaration;
}

void myParser::Subscript_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubscript_declaration(this);
}

void myParser::Subscript_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubscript_declaration(this);
}

myParser::Subscript_declarationContext* myParser::subscript_declaration() {
  Subscript_declarationContext *_localctx = _tracker.createInstance<Subscript_declarationContext>(_ctx, getState());
  enterRule(_localctx, 328, myParser::RuleSubscript_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1764);
    subscript_head();
    setState(1765);
    subscript_result();
    setState(1767);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::WHERE) {
      setState(1766);
      generic_where_clause();
    }
    setState(1772);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx)) {
    case 1: {
      setState(1769);
      code_block();
      break;
    }

    case 2: {
      setState(1770);
      getter_setter_block();
      break;
    }

    case 3: {
      setState(1771);
      getter_setter_keyword_block();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subscript_headContext ------------------------------------------------------------------

myParser::Subscript_headContext::Subscript_headContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Subscript_headContext::SUBSCRIPT() {
  return getToken(myParser::SUBSCRIPT, 0);
}

myParser::Parameter_clauseContext* myParser::Subscript_headContext::parameter_clause() {
  return getRuleContext<myParser::Parameter_clauseContext>(0);
}

myParser::AttributesContext* myParser::Subscript_headContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

myParser::Declaration_modifiersContext* myParser::Subscript_headContext::declaration_modifiers() {
  return getRuleContext<myParser::Declaration_modifiersContext>(0);
}

myParser::Generic_parameter_clauseContext* myParser::Subscript_headContext::generic_parameter_clause() {
  return getRuleContext<myParser::Generic_parameter_clauseContext>(0);
}


size_t myParser::Subscript_headContext::getRuleIndex() const {
  return myParser::RuleSubscript_head;
}

void myParser::Subscript_headContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubscript_head(this);
}

void myParser::Subscript_headContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubscript_head(this);
}

myParser::Subscript_headContext* myParser::subscript_head() {
  Subscript_headContext *_localctx = _tracker.createInstance<Subscript_headContext>(_ctx, getState());
  enterRule(_localctx, 330, myParser::RuleSubscript_head);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1775);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(1774);
      attributes();
    }
    setState(1778);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 144537400573427776) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 14847) != 0)) {
      setState(1777);
      declaration_modifiers();
    }
    setState(1780);
    match(myParser::SUBSCRIPT);
    setState(1782);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LT) {
      setState(1781);
      generic_parameter_clause();
    }
    setState(1784);
    parameter_clause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subscript_resultContext ------------------------------------------------------------------

myParser::Subscript_resultContext::Subscript_resultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Arrow_operatorContext* myParser::Subscript_resultContext::arrow_operator() {
  return getRuleContext<myParser::Arrow_operatorContext>(0);
}

myParser::TypeContext* myParser::Subscript_resultContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

myParser::AttributesContext* myParser::Subscript_resultContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}


size_t myParser::Subscript_resultContext::getRuleIndex() const {
  return myParser::RuleSubscript_result;
}

void myParser::Subscript_resultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubscript_result(this);
}

void myParser::Subscript_resultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubscript_result(this);
}

myParser::Subscript_resultContext* myParser::subscript_result() {
  Subscript_resultContext *_localctx = _tracker.createInstance<Subscript_resultContext>(_ctx, getState());
  enterRule(_localctx, 332, myParser::RuleSubscript_result);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1786);
    arrow_operator();
    setState(1788);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 204, _ctx)) {
    case 1: {
      setState(1787);
      attributes();
      break;
    }

    default:
      break;
    }
    setState(1790);
    type(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Operator_declarationContext ------------------------------------------------------------------

myParser::Operator_declarationContext::Operator_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Prefix_operator_declarationContext* myParser::Operator_declarationContext::prefix_operator_declaration() {
  return getRuleContext<myParser::Prefix_operator_declarationContext>(0);
}

myParser::Postfix_operator_declarationContext* myParser::Operator_declarationContext::postfix_operator_declaration() {
  return getRuleContext<myParser::Postfix_operator_declarationContext>(0);
}

myParser::Infix_operator_declarationContext* myParser::Operator_declarationContext::infix_operator_declaration() {
  return getRuleContext<myParser::Infix_operator_declarationContext>(0);
}


size_t myParser::Operator_declarationContext::getRuleIndex() const {
  return myParser::RuleOperator_declaration;
}

void myParser::Operator_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOperator_declaration(this);
}

void myParser::Operator_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOperator_declaration(this);
}

myParser::Operator_declarationContext* myParser::operator_declaration() {
  Operator_declarationContext *_localctx = _tracker.createInstance<Operator_declarationContext>(_ctx, getState());
  enterRule(_localctx, 334, myParser::RuleOperator_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1795);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::PREFIX: {
        enterOuterAlt(_localctx, 1);
        setState(1792);
        prefix_operator_declaration();
        break;
      }

      case myParser::POSTFIX: {
        enterOuterAlt(_localctx, 2);
        setState(1793);
        postfix_operator_declaration();
        break;
      }

      case myParser::INFIX: {
        enterOuterAlt(_localctx, 3);
        setState(1794);
        infix_operator_declaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Prefix_operator_declarationContext ------------------------------------------------------------------

myParser::Prefix_operator_declarationContext::Prefix_operator_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Prefix_operator_declarationContext::PREFIX() {
  return getToken(myParser::PREFIX, 0);
}

tree::TerminalNode* myParser::Prefix_operator_declarationContext::OPERATOR() {
  return getToken(myParser::OPERATOR, 0);
}

myParser::OperatorContext* myParser::Prefix_operator_declarationContext::operator_() {
  return getRuleContext<myParser::OperatorContext>(0);
}


size_t myParser::Prefix_operator_declarationContext::getRuleIndex() const {
  return myParser::RulePrefix_operator_declaration;
}

void myParser::Prefix_operator_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrefix_operator_declaration(this);
}

void myParser::Prefix_operator_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrefix_operator_declaration(this);
}

myParser::Prefix_operator_declarationContext* myParser::prefix_operator_declaration() {
  Prefix_operator_declarationContext *_localctx = _tracker.createInstance<Prefix_operator_declarationContext>(_ctx, getState());
  enterRule(_localctx, 336, myParser::RulePrefix_operator_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1797);
    match(myParser::PREFIX);
    setState(1798);
    match(myParser::OPERATOR);
    setState(1799);
    operator_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Postfix_operator_declarationContext ------------------------------------------------------------------

myParser::Postfix_operator_declarationContext::Postfix_operator_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Postfix_operator_declarationContext::POSTFIX() {
  return getToken(myParser::POSTFIX, 0);
}

tree::TerminalNode* myParser::Postfix_operator_declarationContext::OPERATOR() {
  return getToken(myParser::OPERATOR, 0);
}

myParser::OperatorContext* myParser::Postfix_operator_declarationContext::operator_() {
  return getRuleContext<myParser::OperatorContext>(0);
}


size_t myParser::Postfix_operator_declarationContext::getRuleIndex() const {
  return myParser::RulePostfix_operator_declaration;
}

void myParser::Postfix_operator_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostfix_operator_declaration(this);
}

void myParser::Postfix_operator_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostfix_operator_declaration(this);
}

myParser::Postfix_operator_declarationContext* myParser::postfix_operator_declaration() {
  Postfix_operator_declarationContext *_localctx = _tracker.createInstance<Postfix_operator_declarationContext>(_ctx, getState());
  enterRule(_localctx, 338, myParser::RulePostfix_operator_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1801);
    match(myParser::POSTFIX);
    setState(1802);
    match(myParser::OPERATOR);
    setState(1803);
    operator_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Infix_operator_declarationContext ------------------------------------------------------------------

myParser::Infix_operator_declarationContext::Infix_operator_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Infix_operator_declarationContext::INFIX() {
  return getToken(myParser::INFIX, 0);
}

tree::TerminalNode* myParser::Infix_operator_declarationContext::OPERATOR() {
  return getToken(myParser::OPERATOR, 0);
}

myParser::OperatorContext* myParser::Infix_operator_declarationContext::operator_() {
  return getRuleContext<myParser::OperatorContext>(0);
}

myParser::Infix_operator_groupContext* myParser::Infix_operator_declarationContext::infix_operator_group() {
  return getRuleContext<myParser::Infix_operator_groupContext>(0);
}


size_t myParser::Infix_operator_declarationContext::getRuleIndex() const {
  return myParser::RuleInfix_operator_declaration;
}

void myParser::Infix_operator_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInfix_operator_declaration(this);
}

void myParser::Infix_operator_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInfix_operator_declaration(this);
}

myParser::Infix_operator_declarationContext* myParser::infix_operator_declaration() {
  Infix_operator_declarationContext *_localctx = _tracker.createInstance<Infix_operator_declarationContext>(_ctx, getState());
  enterRule(_localctx, 340, myParser::RuleInfix_operator_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1805);
    match(myParser::INFIX);
    setState(1806);
    match(myParser::OPERATOR);
    setState(1807);
    operator_();
    setState(1809);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 206, _ctx)) {
    case 1: {
      setState(1808);
      infix_operator_group();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Infix_operator_groupContext ------------------------------------------------------------------

myParser::Infix_operator_groupContext::Infix_operator_groupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Infix_operator_groupContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::Precedence_group_nameContext* myParser::Infix_operator_groupContext::precedence_group_name() {
  return getRuleContext<myParser::Precedence_group_nameContext>(0);
}


size_t myParser::Infix_operator_groupContext::getRuleIndex() const {
  return myParser::RuleInfix_operator_group;
}

void myParser::Infix_operator_groupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInfix_operator_group(this);
}

void myParser::Infix_operator_groupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInfix_operator_group(this);
}

myParser::Infix_operator_groupContext* myParser::infix_operator_group() {
  Infix_operator_groupContext *_localctx = _tracker.createInstance<Infix_operator_groupContext>(_ctx, getState());
  enterRule(_localctx, 342, myParser::RuleInfix_operator_group);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1811);
    match(myParser::COLON);
    setState(1812);
    precedence_group_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Precedence_group_declarationContext ------------------------------------------------------------------

myParser::Precedence_group_declarationContext::Precedence_group_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Precedence_group_declarationContext::PRECEDENCE_GROUP() {
  return getToken(myParser::PRECEDENCE_GROUP, 0);
}

myParser::Precedence_group_nameContext* myParser::Precedence_group_declarationContext::precedence_group_name() {
  return getRuleContext<myParser::Precedence_group_nameContext>(0);
}

tree::TerminalNode* myParser::Precedence_group_declarationContext::LCURLY() {
  return getToken(myParser::LCURLY, 0);
}

tree::TerminalNode* myParser::Precedence_group_declarationContext::RCURLY() {
  return getToken(myParser::RCURLY, 0);
}

myParser::Precedence_group_attributesContext* myParser::Precedence_group_declarationContext::precedence_group_attributes() {
  return getRuleContext<myParser::Precedence_group_attributesContext>(0);
}


size_t myParser::Precedence_group_declarationContext::getRuleIndex() const {
  return myParser::RulePrecedence_group_declaration;
}

void myParser::Precedence_group_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrecedence_group_declaration(this);
}

void myParser::Precedence_group_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrecedence_group_declaration(this);
}

myParser::Precedence_group_declarationContext* myParser::precedence_group_declaration() {
  Precedence_group_declarationContext *_localctx = _tracker.createInstance<Precedence_group_declarationContext>(_ctx, getState());
  enterRule(_localctx, 344, myParser::RulePrecedence_group_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1814);
    match(myParser::PRECEDENCE_GROUP);
    setState(1815);
    precedence_group_name();
    setState(1816);
    match(myParser::LCURLY);
    setState(1818);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 135107988821114880) != 0)) {
      setState(1817);
      precedence_group_attributes();
    }
    setState(1820);
    match(myParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Precedence_group_attributesContext ------------------------------------------------------------------

myParser::Precedence_group_attributesContext::Precedence_group_attributesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Precedence_group_attributeContext *> myParser::Precedence_group_attributesContext::precedence_group_attribute() {
  return getRuleContexts<myParser::Precedence_group_attributeContext>();
}

myParser::Precedence_group_attributeContext* myParser::Precedence_group_attributesContext::precedence_group_attribute(size_t i) {
  return getRuleContext<myParser::Precedence_group_attributeContext>(i);
}


size_t myParser::Precedence_group_attributesContext::getRuleIndex() const {
  return myParser::RulePrecedence_group_attributes;
}

void myParser::Precedence_group_attributesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrecedence_group_attributes(this);
}

void myParser::Precedence_group_attributesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrecedence_group_attributes(this);
}

myParser::Precedence_group_attributesContext* myParser::precedence_group_attributes() {
  Precedence_group_attributesContext *_localctx = _tracker.createInstance<Precedence_group_attributesContext>(_ctx, getState());
  enterRule(_localctx, 346, myParser::RulePrecedence_group_attributes);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1823); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1822);
      precedence_group_attribute();
      setState(1825); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 135107988821114880) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Precedence_group_attributeContext ------------------------------------------------------------------

myParser::Precedence_group_attributeContext::Precedence_group_attributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Precedence_group_relationContext* myParser::Precedence_group_attributeContext::precedence_group_relation() {
  return getRuleContext<myParser::Precedence_group_relationContext>(0);
}

myParser::Precedence_group_assignmentContext* myParser::Precedence_group_attributeContext::precedence_group_assignment() {
  return getRuleContext<myParser::Precedence_group_assignmentContext>(0);
}

myParser::Precedence_group_associativityContext* myParser::Precedence_group_attributeContext::precedence_group_associativity() {
  return getRuleContext<myParser::Precedence_group_associativityContext>(0);
}


size_t myParser::Precedence_group_attributeContext::getRuleIndex() const {
  return myParser::RulePrecedence_group_attribute;
}

void myParser::Precedence_group_attributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrecedence_group_attribute(this);
}

void myParser::Precedence_group_attributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrecedence_group_attribute(this);
}

myParser::Precedence_group_attributeContext* myParser::precedence_group_attribute() {
  Precedence_group_attributeContext *_localctx = _tracker.createInstance<Precedence_group_attributeContext>(_ctx, getState());
  enterRule(_localctx, 348, myParser::RulePrecedence_group_attribute);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1830);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::HIGHER_THAN:
      case myParser::LOWER_THAN: {
        enterOuterAlt(_localctx, 1);
        setState(1827);
        precedence_group_relation();
        break;
      }

      case myParser::ASSIGNMENT: {
        enterOuterAlt(_localctx, 2);
        setState(1828);
        precedence_group_assignment();
        break;
      }

      case myParser::ASSOCIATIVITY: {
        enterOuterAlt(_localctx, 3);
        setState(1829);
        precedence_group_associativity();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Precedence_group_relationContext ------------------------------------------------------------------

myParser::Precedence_group_relationContext::Precedence_group_relationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Precedence_group_relationContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::Precedence_group_namesContext* myParser::Precedence_group_relationContext::precedence_group_names() {
  return getRuleContext<myParser::Precedence_group_namesContext>(0);
}

tree::TerminalNode* myParser::Precedence_group_relationContext::HIGHER_THAN() {
  return getToken(myParser::HIGHER_THAN, 0);
}

tree::TerminalNode* myParser::Precedence_group_relationContext::LOWER_THAN() {
  return getToken(myParser::LOWER_THAN, 0);
}


size_t myParser::Precedence_group_relationContext::getRuleIndex() const {
  return myParser::RulePrecedence_group_relation;
}

void myParser::Precedence_group_relationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrecedence_group_relation(this);
}

void myParser::Precedence_group_relationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrecedence_group_relation(this);
}

myParser::Precedence_group_relationContext* myParser::precedence_group_relation() {
  Precedence_group_relationContext *_localctx = _tracker.createInstance<Precedence_group_relationContext>(_ctx, getState());
  enterRule(_localctx, 350, myParser::RulePrecedence_group_relation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1832);
    _la = _input->LA(1);
    if (!(_la == myParser::HIGHER_THAN

    || _la == myParser::LOWER_THAN)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1833);
    match(myParser::COLON);
    setState(1834);
    precedence_group_names();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Precedence_group_assignmentContext ------------------------------------------------------------------

myParser::Precedence_group_assignmentContext::Precedence_group_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Precedence_group_assignmentContext::ASSIGNMENT() {
  return getToken(myParser::ASSIGNMENT, 0);
}

tree::TerminalNode* myParser::Precedence_group_assignmentContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::Boolean_literalContext* myParser::Precedence_group_assignmentContext::boolean_literal() {
  return getRuleContext<myParser::Boolean_literalContext>(0);
}


size_t myParser::Precedence_group_assignmentContext::getRuleIndex() const {
  return myParser::RulePrecedence_group_assignment;
}

void myParser::Precedence_group_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrecedence_group_assignment(this);
}

void myParser::Precedence_group_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrecedence_group_assignment(this);
}

myParser::Precedence_group_assignmentContext* myParser::precedence_group_assignment() {
  Precedence_group_assignmentContext *_localctx = _tracker.createInstance<Precedence_group_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 352, myParser::RulePrecedence_group_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1836);
    match(myParser::ASSIGNMENT);
    setState(1837);
    match(myParser::COLON);
    setState(1838);
    boolean_literal();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Precedence_group_associativityContext ------------------------------------------------------------------

myParser::Precedence_group_associativityContext::Precedence_group_associativityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Precedence_group_associativityContext::ASSOCIATIVITY() {
  return getToken(myParser::ASSOCIATIVITY, 0);
}

tree::TerminalNode* myParser::Precedence_group_associativityContext::COLON() {
  return getToken(myParser::COLON, 0);
}

tree::TerminalNode* myParser::Precedence_group_associativityContext::LEFT() {
  return getToken(myParser::LEFT, 0);
}

tree::TerminalNode* myParser::Precedence_group_associativityContext::RIGHT() {
  return getToken(myParser::RIGHT, 0);
}

tree::TerminalNode* myParser::Precedence_group_associativityContext::NONE() {
  return getToken(myParser::NONE, 0);
}


size_t myParser::Precedence_group_associativityContext::getRuleIndex() const {
  return myParser::RulePrecedence_group_associativity;
}

void myParser::Precedence_group_associativityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrecedence_group_associativity(this);
}

void myParser::Precedence_group_associativityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrecedence_group_associativity(this);
}

myParser::Precedence_group_associativityContext* myParser::precedence_group_associativity() {
  Precedence_group_associativityContext *_localctx = _tracker.createInstance<Precedence_group_associativityContext>(_ctx, getState());
  enterRule(_localctx, 354, myParser::RulePrecedence_group_associativity);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1840);
    match(myParser::ASSOCIATIVITY);
    setState(1841);
    match(myParser::COLON);
    setState(1842);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 3940649673949184) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Precedence_group_namesContext ------------------------------------------------------------------

myParser::Precedence_group_namesContext::Precedence_group_namesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Precedence_group_nameContext *> myParser::Precedence_group_namesContext::precedence_group_name() {
  return getRuleContexts<myParser::Precedence_group_nameContext>();
}

myParser::Precedence_group_nameContext* myParser::Precedence_group_namesContext::precedence_group_name(size_t i) {
  return getRuleContext<myParser::Precedence_group_nameContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Precedence_group_namesContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Precedence_group_namesContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Precedence_group_namesContext::getRuleIndex() const {
  return myParser::RulePrecedence_group_names;
}

void myParser::Precedence_group_namesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrecedence_group_names(this);
}

void myParser::Precedence_group_namesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrecedence_group_names(this);
}

myParser::Precedence_group_namesContext* myParser::precedence_group_names() {
  Precedence_group_namesContext *_localctx = _tracker.createInstance<Precedence_group_namesContext>(_ctx, getState());
  enterRule(_localctx, 356, myParser::RulePrecedence_group_names);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1844);
    precedence_group_name();
    setState(1849);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(1845);
      match(myParser::COMMA);
      setState(1846);
      precedence_group_name();
      setState(1851);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Precedence_group_nameContext ------------------------------------------------------------------

myParser::Precedence_group_nameContext::Precedence_group_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::IdentifierContext *> myParser::Precedence_group_nameContext::identifier() {
  return getRuleContexts<myParser::IdentifierContext>();
}

myParser::IdentifierContext* myParser::Precedence_group_nameContext::identifier(size_t i) {
  return getRuleContext<myParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Precedence_group_nameContext::DOT() {
  return getTokens(myParser::DOT);
}

tree::TerminalNode* myParser::Precedence_group_nameContext::DOT(size_t i) {
  return getToken(myParser::DOT, i);
}


size_t myParser::Precedence_group_nameContext::getRuleIndex() const {
  return myParser::RulePrecedence_group_name;
}

void myParser::Precedence_group_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrecedence_group_name(this);
}

void myParser::Precedence_group_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrecedence_group_name(this);
}

myParser::Precedence_group_nameContext* myParser::precedence_group_name() {
  Precedence_group_nameContext *_localctx = _tracker.createInstance<Precedence_group_nameContext>(_ctx, getState());
  enterRule(_localctx, 358, myParser::RulePrecedence_group_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1852);
    identifier();
    setState(1857);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 211, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1853);
        match(myParser::DOT);
        setState(1854);
        identifier(); 
      }
      setState(1859);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 211, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declaration_modifierContext ------------------------------------------------------------------

myParser::Declaration_modifierContext::Declaration_modifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Declaration_modifierContext::CLASS() {
  return getToken(myParser::CLASS, 0);
}

tree::TerminalNode* myParser::Declaration_modifierContext::CONVENIENCE() {
  return getToken(myParser::CONVENIENCE, 0);
}

tree::TerminalNode* myParser::Declaration_modifierContext::DYNAMIC() {
  return getToken(myParser::DYNAMIC, 0);
}

tree::TerminalNode* myParser::Declaration_modifierContext::FINAL() {
  return getToken(myParser::FINAL, 0);
}

tree::TerminalNode* myParser::Declaration_modifierContext::INFIX() {
  return getToken(myParser::INFIX, 0);
}

tree::TerminalNode* myParser::Declaration_modifierContext::LAZY() {
  return getToken(myParser::LAZY, 0);
}

tree::TerminalNode* myParser::Declaration_modifierContext::OPTIONAL() {
  return getToken(myParser::OPTIONAL, 0);
}

tree::TerminalNode* myParser::Declaration_modifierContext::OVERRIDE() {
  return getToken(myParser::OVERRIDE, 0);
}

tree::TerminalNode* myParser::Declaration_modifierContext::POSTFIX() {
  return getToken(myParser::POSTFIX, 0);
}

tree::TerminalNode* myParser::Declaration_modifierContext::PREFIX() {
  return getToken(myParser::PREFIX, 0);
}

tree::TerminalNode* myParser::Declaration_modifierContext::REQUIRED() {
  return getToken(myParser::REQUIRED, 0);
}

tree::TerminalNode* myParser::Declaration_modifierContext::STATIC() {
  return getToken(myParser::STATIC, 0);
}

tree::TerminalNode* myParser::Declaration_modifierContext::UNOWNED() {
  return getToken(myParser::UNOWNED, 0);
}

tree::TerminalNode* myParser::Declaration_modifierContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::Declaration_modifierContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

tree::TerminalNode* myParser::Declaration_modifierContext::SAFE() {
  return getToken(myParser::SAFE, 0);
}

tree::TerminalNode* myParser::Declaration_modifierContext::UNSAFE() {
  return getToken(myParser::UNSAFE, 0);
}

tree::TerminalNode* myParser::Declaration_modifierContext::WEAK() {
  return getToken(myParser::WEAK, 0);
}

myParser::Access_level_modifierContext* myParser::Declaration_modifierContext::access_level_modifier() {
  return getRuleContext<myParser::Access_level_modifierContext>(0);
}

myParser::Mutation_modifierContext* myParser::Declaration_modifierContext::mutation_modifier() {
  return getRuleContext<myParser::Mutation_modifierContext>(0);
}


size_t myParser::Declaration_modifierContext::getRuleIndex() const {
  return myParser::RuleDeclaration_modifier;
}

void myParser::Declaration_modifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclaration_modifier(this);
}

void myParser::Declaration_modifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclaration_modifier(this);
}

myParser::Declaration_modifierContext* myParser::declaration_modifier() {
  Declaration_modifierContext *_localctx = _tracker.createInstance<Declaration_modifierContext>(_ctx, getState());
  enterRule(_localctx, 360, myParser::RuleDeclaration_modifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1881);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::CLASS: {
        enterOuterAlt(_localctx, 1);
        setState(1860);
        match(myParser::CLASS);
        break;
      }

      case myParser::CONVENIENCE: {
        enterOuterAlt(_localctx, 2);
        setState(1861);
        match(myParser::CONVENIENCE);
        break;
      }

      case myParser::DYNAMIC: {
        enterOuterAlt(_localctx, 3);
        setState(1862);
        match(myParser::DYNAMIC);
        break;
      }

      case myParser::FINAL: {
        enterOuterAlt(_localctx, 4);
        setState(1863);
        match(myParser::FINAL);
        break;
      }

      case myParser::INFIX: {
        enterOuterAlt(_localctx, 5);
        setState(1864);
        match(myParser::INFIX);
        break;
      }

      case myParser::LAZY: {
        enterOuterAlt(_localctx, 6);
        setState(1865);
        match(myParser::LAZY);
        break;
      }

      case myParser::OPTIONAL: {
        enterOuterAlt(_localctx, 7);
        setState(1866);
        match(myParser::OPTIONAL);
        break;
      }

      case myParser::OVERRIDE: {
        enterOuterAlt(_localctx, 8);
        setState(1867);
        match(myParser::OVERRIDE);
        break;
      }

      case myParser::POSTFIX: {
        enterOuterAlt(_localctx, 9);
        setState(1868);
        match(myParser::POSTFIX);
        break;
      }

      case myParser::PREFIX: {
        enterOuterAlt(_localctx, 10);
        setState(1869);
        match(myParser::PREFIX);
        break;
      }

      case myParser::REQUIRED: {
        enterOuterAlt(_localctx, 11);
        setState(1870);
        match(myParser::REQUIRED);
        break;
      }

      case myParser::STATIC: {
        enterOuterAlt(_localctx, 12);
        setState(1871);
        match(myParser::STATIC);
        break;
      }

      case myParser::UNOWNED: {
        enterOuterAlt(_localctx, 13);
        setState(1872);
        match(myParser::UNOWNED);
        setState(1876);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::LPAREN) {
          setState(1873);
          match(myParser::LPAREN);
          setState(1874);
          _la = _input->LA(1);
          if (!(_la == myParser::SAFE

          || _la == myParser::UNSAFE)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1875);
          match(myParser::RPAREN);
        }
        break;
      }

      case myParser::WEAK: {
        enterOuterAlt(_localctx, 14);
        setState(1878);
        match(myParser::WEAK);
        break;
      }

      case myParser::INTERNAL:
      case myParser::OPEN:
      case myParser::PRIVATE:
      case myParser::PUBLIC:
      case myParser::FILE_PRIVATE: {
        enterOuterAlt(_localctx, 15);
        setState(1879);
        access_level_modifier();
        break;
      }

      case myParser::MUTATING:
      case myParser::NONMUTATING: {
        enterOuterAlt(_localctx, 16);
        setState(1880);
        mutation_modifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declaration_modifiersContext ------------------------------------------------------------------

myParser::Declaration_modifiersContext::Declaration_modifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Declaration_modifierContext *> myParser::Declaration_modifiersContext::declaration_modifier() {
  return getRuleContexts<myParser::Declaration_modifierContext>();
}

myParser::Declaration_modifierContext* myParser::Declaration_modifiersContext::declaration_modifier(size_t i) {
  return getRuleContext<myParser::Declaration_modifierContext>(i);
}


size_t myParser::Declaration_modifiersContext::getRuleIndex() const {
  return myParser::RuleDeclaration_modifiers;
}

void myParser::Declaration_modifiersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclaration_modifiers(this);
}

void myParser::Declaration_modifiersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclaration_modifiers(this);
}

myParser::Declaration_modifiersContext* myParser::declaration_modifiers() {
  Declaration_modifiersContext *_localctx = _tracker.createInstance<Declaration_modifiersContext>(_ctx, getState());
  enterRule(_localctx, 362, myParser::RuleDeclaration_modifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1884); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1883);
      declaration_modifier();
      setState(1886); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 144537400573427776) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 14847) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Access_level_modifierContext ------------------------------------------------------------------

myParser::Access_level_modifierContext::Access_level_modifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Access_level_modifierContext::PRIVATE() {
  return getToken(myParser::PRIVATE, 0);
}

tree::TerminalNode* myParser::Access_level_modifierContext::FILE_PRIVATE() {
  return getToken(myParser::FILE_PRIVATE, 0);
}

tree::TerminalNode* myParser::Access_level_modifierContext::INTERNAL() {
  return getToken(myParser::INTERNAL, 0);
}

tree::TerminalNode* myParser::Access_level_modifierContext::PUBLIC() {
  return getToken(myParser::PUBLIC, 0);
}

tree::TerminalNode* myParser::Access_level_modifierContext::OPEN() {
  return getToken(myParser::OPEN, 0);
}

tree::TerminalNode* myParser::Access_level_modifierContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::Access_level_modifierContext::SET() {
  return getToken(myParser::SET, 0);
}

tree::TerminalNode* myParser::Access_level_modifierContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}


size_t myParser::Access_level_modifierContext::getRuleIndex() const {
  return myParser::RuleAccess_level_modifier;
}

void myParser::Access_level_modifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAccess_level_modifier(this);
}

void myParser::Access_level_modifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAccess_level_modifier(this);
}

myParser::Access_level_modifierContext* myParser::access_level_modifier() {
  Access_level_modifierContext *_localctx = _tracker.createInstance<Access_level_modifierContext>(_ctx, getState());
  enterRule(_localctx, 364, myParser::RuleAccess_level_modifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1888);
    _la = _input->LA(1);
    if (!(((((_la - 20) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 20)) & 576460752303423517) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1892);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LPAREN) {
      setState(1889);
      match(myParser::LPAREN);
      setState(1890);
      match(myParser::SET);
      setState(1891);
      match(myParser::RPAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mutation_modifierContext ------------------------------------------------------------------

myParser::Mutation_modifierContext::Mutation_modifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Mutation_modifierContext::MUTATING() {
  return getToken(myParser::MUTATING, 0);
}

tree::TerminalNode* myParser::Mutation_modifierContext::NONMUTATING() {
  return getToken(myParser::NONMUTATING, 0);
}


size_t myParser::Mutation_modifierContext::getRuleIndex() const {
  return myParser::RuleMutation_modifier;
}

void myParser::Mutation_modifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMutation_modifier(this);
}

void myParser::Mutation_modifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMutation_modifier(this);
}

myParser::Mutation_modifierContext* myParser::mutation_modifier() {
  Mutation_modifierContext *_localctx = _tracker.createInstance<Mutation_modifierContext>(_ctx, getState());
  enterRule(_localctx, 366, myParser::RuleMutation_modifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1894);
    _la = _input->LA(1);
    if (!(_la == myParser::MUTATING

    || _la == myParser::NONMUTATING)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatternContext ------------------------------------------------------------------

myParser::PatternContext::PatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Wildcard_patternContext* myParser::PatternContext::wildcard_pattern() {
  return getRuleContext<myParser::Wildcard_patternContext>(0);
}

myParser::Identifier_patternContext* myParser::PatternContext::identifier_pattern() {
  return getRuleContext<myParser::Identifier_patternContext>(0);
}

myParser::Tuple_patternContext* myParser::PatternContext::tuple_pattern() {
  return getRuleContext<myParser::Tuple_patternContext>(0);
}

myParser::Type_annotationContext* myParser::PatternContext::type_annotation() {
  return getRuleContext<myParser::Type_annotationContext>(0);
}

myParser::Value_binding_patternContext* myParser::PatternContext::value_binding_pattern() {
  return getRuleContext<myParser::Value_binding_patternContext>(0);
}

myParser::Enum_case_patternContext* myParser::PatternContext::enum_case_pattern() {
  return getRuleContext<myParser::Enum_case_patternContext>(0);
}

myParser::Optional_patternContext* myParser::PatternContext::optional_pattern() {
  return getRuleContext<myParser::Optional_patternContext>(0);
}

tree::TerminalNode* myParser::PatternContext::IS() {
  return getToken(myParser::IS, 0);
}

myParser::TypeContext* myParser::PatternContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

myParser::Expression_patternContext* myParser::PatternContext::expression_pattern() {
  return getRuleContext<myParser::Expression_patternContext>(0);
}

myParser::PatternContext* myParser::PatternContext::pattern() {
  return getRuleContext<myParser::PatternContext>(0);
}

tree::TerminalNode* myParser::PatternContext::AS() {
  return getToken(myParser::AS, 0);
}


size_t myParser::PatternContext::getRuleIndex() const {
  return myParser::RulePattern;
}

void myParser::PatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPattern(this);
}

void myParser::PatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPattern(this);
}


myParser::PatternContext* myParser::pattern() {
   return pattern(0);
}

myParser::PatternContext* myParser::pattern(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  myParser::PatternContext *_localctx = _tracker.createInstance<PatternContext>(_ctx, parentState);
  myParser::PatternContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 368;
  enterRecursionRule(_localctx, 368, myParser::RulePattern, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1911);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 218, _ctx)) {
    case 1: {
      setState(1900);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case myParser::UNDERSCORE: {
          setState(1897);
          wildcard_pattern();
          break;
        }

        case myParser::AS:
        case myParser::ALPHA:
        case myParser::CATCH:
        case myParser::CLASS:
        case myParser::DEFAULT:
        case myParser::DO:
        case myParser::GUARD:
        case myParser::FOR:
        case myParser::IN:
        case myParser::INTERNAL:
        case myParser::FINAL:
        case myParser::OPEN:
        case myParser::PRIVATE:
        case myParser::PUBLIC:
        case myParser::WHERE:
        case myParser::WHILE:
        case myParser::PROTOCOL:
        case myParser::GET:
        case myParser::SET:
        case myParser::WILL_SET:
        case myParser::DID_SET:
        case myParser::INDIRECT:
        case myParser::PREFIX:
        case myParser::INFIX:
        case myParser::LEFT:
        case myParser::RIGHT:
        case myParser::NONE:
        case myParser::PRECEDENCE_GROUP:
        case myParser::HIGHER_THAN:
        case myParser::LOWER_THAN:
        case myParser::ASSIGNMENT:
        case myParser::ASSOCIATIVITY:
        case myParser::POSTFIX:
        case myParser::OPERATOR:
        case myParser::OS:
        case myParser::ARCH:
        case myParser::SWIFT:
        case myParser::COMPILER:
        case myParser::CAN_IMPORT:
        case myParser::TARGET_ENVIRONMENT:
        case myParser::CONVENIENCE:
        case myParser::DYNAMIC:
        case myParser::LAZY:
        case myParser::OPTIONAL:
        case myParser::OVERRIDE:
        case myParser::REQUIRED:
        case myParser::WEAK:
        case myParser::UNOWNED:
        case myParser::SAFE:
        case myParser::UNSAFE:
        case myParser::MUTATING:
        case myParser::NONMUTATING:
        case myParser::RED:
        case myParser::BLUE:
        case myParser::GREEN:
        case myParser::RESOURCE_NAME:
        case myParser::SOME:
        case myParser::TYPE:
        case myParser::PRECEDENCE:
        case myParser::SELF:
        case myParser::SELF_BIG:
        case myParser::MAC_OS:
        case myParser::I_OS:
        case myParser::OSX:
        case myParser::WATCH_OS:
        case myParser::TV_OS:
        case myParser::LINUX:
        case myParser::WINDOWS:
        case myParser::I386:
        case myParser::X86_64:
        case myParser::ARM:
        case myParser::ARM64:
        case myParser::SIMULATOR:
        case myParser::MAC_CATALYST:
        case myParser::I_OS_APPLICATION_EXTENSION:
        case myParser::MAC_CATALYST_APPLICATION_EXTENSION:
        case myParser::MAC_OS_APPLICATION_EXTENSION:
        case myParser::FILE:
        case myParser::LINE:
        case myParser::GETTER:
        case myParser::SETTER:
        case myParser::Identifier:
        case myParser::BACKTICK: {
          setState(1898);
          identifier_pattern();
          break;
        }

        case myParser::LPAREN: {
          setState(1899);
          tuple_pattern();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1903);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 217, _ctx)) {
      case 1: {
        setState(1902);
        type_annotation();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      setState(1905);
      value_binding_pattern();
      break;
    }

    case 3: {
      setState(1906);
      enum_case_pattern();
      break;
    }

    case 4: {
      setState(1907);
      optional_pattern();
      break;
    }

    case 5: {
      setState(1908);
      match(myParser::IS);
      setState(1909);
      type(0);
      break;
    }

    case 6: {
      setState(1910);
      expression_pattern();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(1918);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 219, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<PatternContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RulePattern);
        setState(1913);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(1914);
        match(myParser::AS);
        setState(1915);
        type(0); 
      }
      setState(1920);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 219, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Wildcard_patternContext ------------------------------------------------------------------

myParser::Wildcard_patternContext::Wildcard_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Wildcard_patternContext::UNDERSCORE() {
  return getToken(myParser::UNDERSCORE, 0);
}


size_t myParser::Wildcard_patternContext::getRuleIndex() const {
  return myParser::RuleWildcard_pattern;
}

void myParser::Wildcard_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWildcard_pattern(this);
}

void myParser::Wildcard_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWildcard_pattern(this);
}

myParser::Wildcard_patternContext* myParser::wildcard_pattern() {
  Wildcard_patternContext *_localctx = _tracker.createInstance<Wildcard_patternContext>(_ctx, getState());
  enterRule(_localctx, 370, myParser::RuleWildcard_pattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1921);
    match(myParser::UNDERSCORE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Identifier_patternContext ------------------------------------------------------------------

myParser::Identifier_patternContext::Identifier_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::Identifier_patternContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}


size_t myParser::Identifier_patternContext::getRuleIndex() const {
  return myParser::RuleIdentifier_pattern;
}

void myParser::Identifier_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier_pattern(this);
}

void myParser::Identifier_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier_pattern(this);
}

myParser::Identifier_patternContext* myParser::identifier_pattern() {
  Identifier_patternContext *_localctx = _tracker.createInstance<Identifier_patternContext>(_ctx, getState());
  enterRule(_localctx, 372, myParser::RuleIdentifier_pattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1923);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Value_binding_patternContext ------------------------------------------------------------------

myParser::Value_binding_patternContext::Value_binding_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Value_binding_patternContext::VAR() {
  return getToken(myParser::VAR, 0);
}

myParser::PatternContext* myParser::Value_binding_patternContext::pattern() {
  return getRuleContext<myParser::PatternContext>(0);
}

tree::TerminalNode* myParser::Value_binding_patternContext::LET() {
  return getToken(myParser::LET, 0);
}


size_t myParser::Value_binding_patternContext::getRuleIndex() const {
  return myParser::RuleValue_binding_pattern;
}

void myParser::Value_binding_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValue_binding_pattern(this);
}

void myParser::Value_binding_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValue_binding_pattern(this);
}

myParser::Value_binding_patternContext* myParser::value_binding_pattern() {
  Value_binding_patternContext *_localctx = _tracker.createInstance<Value_binding_patternContext>(_ctx, getState());
  enterRule(_localctx, 374, myParser::RuleValue_binding_pattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1929);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::VAR: {
        enterOuterAlt(_localctx, 1);
        setState(1925);
        match(myParser::VAR);
        setState(1926);
        pattern(0);
        break;
      }

      case myParser::LET: {
        enterOuterAlt(_localctx, 2);
        setState(1927);
        match(myParser::LET);
        setState(1928);
        pattern(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tuple_patternContext ------------------------------------------------------------------

myParser::Tuple_patternContext::Tuple_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Tuple_patternContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::Tuple_patternContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

myParser::Tuple_pattern_element_listContext* myParser::Tuple_patternContext::tuple_pattern_element_list() {
  return getRuleContext<myParser::Tuple_pattern_element_listContext>(0);
}


size_t myParser::Tuple_patternContext::getRuleIndex() const {
  return myParser::RuleTuple_pattern;
}

void myParser::Tuple_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTuple_pattern(this);
}

void myParser::Tuple_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTuple_pattern(this);
}

myParser::Tuple_patternContext* myParser::tuple_pattern() {
  Tuple_patternContext *_localctx = _tracker.createInstance<Tuple_patternContext>(_ctx, getState());
  enterRule(_localctx, 376, myParser::RuleTuple_pattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1931);
    match(myParser::LPAREN);
    setState(1933);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx)) {
    case 1: {
      setState(1932);
      tuple_pattern_element_list();
      break;
    }

    default:
      break;
    }
    setState(1935);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tuple_pattern_element_listContext ------------------------------------------------------------------

myParser::Tuple_pattern_element_listContext::Tuple_pattern_element_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Tuple_pattern_elementContext *> myParser::Tuple_pattern_element_listContext::tuple_pattern_element() {
  return getRuleContexts<myParser::Tuple_pattern_elementContext>();
}

myParser::Tuple_pattern_elementContext* myParser::Tuple_pattern_element_listContext::tuple_pattern_element(size_t i) {
  return getRuleContext<myParser::Tuple_pattern_elementContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Tuple_pattern_element_listContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Tuple_pattern_element_listContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Tuple_pattern_element_listContext::getRuleIndex() const {
  return myParser::RuleTuple_pattern_element_list;
}

void myParser::Tuple_pattern_element_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTuple_pattern_element_list(this);
}

void myParser::Tuple_pattern_element_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTuple_pattern_element_list(this);
}

myParser::Tuple_pattern_element_listContext* myParser::tuple_pattern_element_list() {
  Tuple_pattern_element_listContext *_localctx = _tracker.createInstance<Tuple_pattern_element_listContext>(_ctx, getState());
  enterRule(_localctx, 378, myParser::RuleTuple_pattern_element_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1937);
    tuple_pattern_element();
    setState(1942);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(1938);
      match(myParser::COMMA);
      setState(1939);
      tuple_pattern_element();
      setState(1944);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tuple_pattern_elementContext ------------------------------------------------------------------

myParser::Tuple_pattern_elementContext::Tuple_pattern_elementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::PatternContext* myParser::Tuple_pattern_elementContext::pattern() {
  return getRuleContext<myParser::PatternContext>(0);
}

myParser::IdentifierContext* myParser::Tuple_pattern_elementContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

tree::TerminalNode* myParser::Tuple_pattern_elementContext::COLON() {
  return getToken(myParser::COLON, 0);
}


size_t myParser::Tuple_pattern_elementContext::getRuleIndex() const {
  return myParser::RuleTuple_pattern_element;
}

void myParser::Tuple_pattern_elementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTuple_pattern_element(this);
}

void myParser::Tuple_pattern_elementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTuple_pattern_element(this);
}

myParser::Tuple_pattern_elementContext* myParser::tuple_pattern_element() {
  Tuple_pattern_elementContext *_localctx = _tracker.createInstance<Tuple_pattern_elementContext>(_ctx, getState());
  enterRule(_localctx, 380, myParser::RuleTuple_pattern_element);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1948);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 223, _ctx)) {
    case 1: {
      setState(1945);
      identifier();
      setState(1946);
      match(myParser::COLON);
      break;
    }

    default:
      break;
    }
    setState(1950);
    pattern(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enum_case_patternContext ------------------------------------------------------------------

myParser::Enum_case_patternContext::Enum_case_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Enum_case_patternContext::DOT() {
  return getToken(myParser::DOT, 0);
}

myParser::Enum_case_nameContext* myParser::Enum_case_patternContext::enum_case_name() {
  return getRuleContext<myParser::Enum_case_nameContext>(0);
}

myParser::Type_identifierContext* myParser::Enum_case_patternContext::type_identifier() {
  return getRuleContext<myParser::Type_identifierContext>(0);
}

myParser::Tuple_patternContext* myParser::Enum_case_patternContext::tuple_pattern() {
  return getRuleContext<myParser::Tuple_patternContext>(0);
}


size_t myParser::Enum_case_patternContext::getRuleIndex() const {
  return myParser::RuleEnum_case_pattern;
}

void myParser::Enum_case_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnum_case_pattern(this);
}

void myParser::Enum_case_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnum_case_pattern(this);
}

myParser::Enum_case_patternContext* myParser::enum_case_pattern() {
  Enum_case_patternContext *_localctx = _tracker.createInstance<Enum_case_patternContext>(_ctx, getState());
  enterRule(_localctx, 382, myParser::RuleEnum_case_pattern);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1953);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -576599273992204954) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3940649437003519) != 0) || ((((_la - 135) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 135)) & 1073741831) != 0)) {
      setState(1952);
      type_identifier();
    }
    setState(1955);
    match(myParser::DOT);
    setState(1956);
    enum_case_name();
    setState(1958);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 225, _ctx)) {
    case 1: {
      setState(1957);
      tuple_pattern();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Optional_patternContext ------------------------------------------------------------------

myParser::Optional_patternContext::Optional_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Identifier_patternContext* myParser::Optional_patternContext::identifier_pattern() {
  return getRuleContext<myParser::Identifier_patternContext>(0);
}

tree::TerminalNode* myParser::Optional_patternContext::QUESTION() {
  return getToken(myParser::QUESTION, 0);
}


size_t myParser::Optional_patternContext::getRuleIndex() const {
  return myParser::RuleOptional_pattern;
}

void myParser::Optional_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptional_pattern(this);
}

void myParser::Optional_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptional_pattern(this);
}

myParser::Optional_patternContext* myParser::optional_pattern() {
  Optional_patternContext *_localctx = _tracker.createInstance<Optional_patternContext>(_ctx, getState());
  enterRule(_localctx, 384, myParser::RuleOptional_pattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1960);
    identifier_pattern();
    setState(1961);
    match(myParser::QUESTION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_patternContext ------------------------------------------------------------------

myParser::Expression_patternContext::Expression_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionContext* myParser::Expression_patternContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}


size_t myParser::Expression_patternContext::getRuleIndex() const {
  return myParser::RuleExpression_pattern;
}

void myParser::Expression_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_pattern(this);
}

void myParser::Expression_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_pattern(this);
}

myParser::Expression_patternContext* myParser::expression_pattern() {
  Expression_patternContext *_localctx = _tracker.createInstance<Expression_patternContext>(_ctx, getState());
  enterRule(_localctx, 386, myParser::RuleExpression_pattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1963);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeContext ------------------------------------------------------------------

myParser::AttributeContext::AttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::AttributeContext::AT() {
  return getToken(myParser::AT, 0);
}

myParser::Attribute_nameContext* myParser::AttributeContext::attribute_name() {
  return getRuleContext<myParser::Attribute_nameContext>(0);
}

myParser::Attribute_argument_clauseContext* myParser::AttributeContext::attribute_argument_clause() {
  return getRuleContext<myParser::Attribute_argument_clauseContext>(0);
}


size_t myParser::AttributeContext::getRuleIndex() const {
  return myParser::RuleAttribute;
}

void myParser::AttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttribute(this);
}

void myParser::AttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttribute(this);
}

myParser::AttributeContext* myParser::attribute() {
  AttributeContext *_localctx = _tracker.createInstance<AttributeContext>(_ctx, getState());
  enterRule(_localctx, 388, myParser::RuleAttribute);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1965);
    match(myParser::AT);
    setState(1966);
    attribute_name();
    setState(1968);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 226, _ctx)) {
    case 1: {
      setState(1967);
      attribute_argument_clause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Attribute_nameContext ------------------------------------------------------------------

myParser::Attribute_nameContext::Attribute_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::IdentifierContext *> myParser::Attribute_nameContext::identifier() {
  return getRuleContexts<myParser::IdentifierContext>();
}

myParser::IdentifierContext* myParser::Attribute_nameContext::identifier(size_t i) {
  return getRuleContext<myParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Attribute_nameContext::DOT() {
  return getTokens(myParser::DOT);
}

tree::TerminalNode* myParser::Attribute_nameContext::DOT(size_t i) {
  return getToken(myParser::DOT, i);
}


size_t myParser::Attribute_nameContext::getRuleIndex() const {
  return myParser::RuleAttribute_name;
}

void myParser::Attribute_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttribute_name(this);
}

void myParser::Attribute_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttribute_name(this);
}

myParser::Attribute_nameContext* myParser::attribute_name() {
  Attribute_nameContext *_localctx = _tracker.createInstance<Attribute_nameContext>(_ctx, getState());
  enterRule(_localctx, 390, myParser::RuleAttribute_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1970);
    identifier();
    setState(1975);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::DOT) {
      setState(1971);
      match(myParser::DOT);
      setState(1972);
      identifier();
      setState(1977);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Attribute_argument_clauseContext ------------------------------------------------------------------

myParser::Attribute_argument_clauseContext::Attribute_argument_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Attribute_argument_clauseContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::Attribute_argument_clauseContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

myParser::Balanced_tokensContext* myParser::Attribute_argument_clauseContext::balanced_tokens() {
  return getRuleContext<myParser::Balanced_tokensContext>(0);
}


size_t myParser::Attribute_argument_clauseContext::getRuleIndex() const {
  return myParser::RuleAttribute_argument_clause;
}

void myParser::Attribute_argument_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttribute_argument_clause(this);
}

void myParser::Attribute_argument_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttribute_argument_clause(this);
}

myParser::Attribute_argument_clauseContext* myParser::attribute_argument_clause() {
  Attribute_argument_clauseContext *_localctx = _tracker.createInstance<Attribute_argument_clauseContext>(_ctx, getState());
  enterRule(_localctx, 392, myParser::RuleAttribute_argument_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1978);
    match(myParser::LPAREN);
    setState(1980);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 228, _ctx)) {
    case 1: {
      setState(1979);
      balanced_tokens();
      break;
    }

    default:
      break;
    }
    setState(1982);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributesContext ------------------------------------------------------------------

myParser::AttributesContext::AttributesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::AttributeContext *> myParser::AttributesContext::attribute() {
  return getRuleContexts<myParser::AttributeContext>();
}

myParser::AttributeContext* myParser::AttributesContext::attribute(size_t i) {
  return getRuleContext<myParser::AttributeContext>(i);
}


size_t myParser::AttributesContext::getRuleIndex() const {
  return myParser::RuleAttributes;
}

void myParser::AttributesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributes(this);
}

void myParser::AttributesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributes(this);
}

myParser::AttributesContext* myParser::attributes() {
  AttributesContext *_localctx = _tracker.createInstance<AttributesContext>(_ctx, getState());
  enterRule(_localctx, 394, myParser::RuleAttributes);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1985); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1984);
              attribute();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1987); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 229, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Balanced_tokensContext ------------------------------------------------------------------

myParser::Balanced_tokensContext::Balanced_tokensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Balanced_tokenContext *> myParser::Balanced_tokensContext::balanced_token() {
  return getRuleContexts<myParser::Balanced_tokenContext>();
}

myParser::Balanced_tokenContext* myParser::Balanced_tokensContext::balanced_token(size_t i) {
  return getRuleContext<myParser::Balanced_tokenContext>(i);
}


size_t myParser::Balanced_tokensContext::getRuleIndex() const {
  return myParser::RuleBalanced_tokens;
}

void myParser::Balanced_tokensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBalanced_tokens(this);
}

void myParser::Balanced_tokensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBalanced_tokens(this);
}

myParser::Balanced_tokensContext* myParser::balanced_tokens() {
  Balanced_tokensContext *_localctx = _tracker.createInstance<Balanced_tokensContext>(_ctx, getState());
  enterRule(_localctx, 396, myParser::RuleBalanced_tokens);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1990); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1989);
              balanced_token();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1992); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 230, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Balanced_tokenContext ------------------------------------------------------------------

myParser::Balanced_tokenContext::Balanced_tokenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Balanced_tokenContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::Balanced_tokenContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

myParser::Balanced_tokensContext* myParser::Balanced_tokenContext::balanced_tokens() {
  return getRuleContext<myParser::Balanced_tokensContext>(0);
}

tree::TerminalNode* myParser::Balanced_tokenContext::LBRACK() {
  return getToken(myParser::LBRACK, 0);
}

tree::TerminalNode* myParser::Balanced_tokenContext::RBRACK() {
  return getToken(myParser::RBRACK, 0);
}

tree::TerminalNode* myParser::Balanced_tokenContext::LCURLY() {
  return getToken(myParser::LCURLY, 0);
}

tree::TerminalNode* myParser::Balanced_tokenContext::RCURLY() {
  return getToken(myParser::RCURLY, 0);
}

myParser::IdentifierContext* myParser::Balanced_tokenContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::KeywordContext* myParser::Balanced_tokenContext::keyword() {
  return getRuleContext<myParser::KeywordContext>(0);
}

myParser::LiteralContext* myParser::Balanced_tokenContext::literal() {
  return getRuleContext<myParser::LiteralContext>(0);
}

myParser::OperatorContext* myParser::Balanced_tokenContext::operator_() {
  return getRuleContext<myParser::OperatorContext>(0);
}

myParser::Balanced_token_punctuationContext* myParser::Balanced_tokenContext::balanced_token_punctuation() {
  return getRuleContext<myParser::Balanced_token_punctuationContext>(0);
}


size_t myParser::Balanced_tokenContext::getRuleIndex() const {
  return myParser::RuleBalanced_token;
}

void myParser::Balanced_tokenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBalanced_token(this);
}

void myParser::Balanced_tokenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBalanced_token(this);
}

myParser::Balanced_tokenContext* myParser::balanced_token() {
  Balanced_tokenContext *_localctx = _tracker.createInstance<Balanced_tokenContext>(_ctx, getState());
  enterRule(_localctx, 398, myParser::RuleBalanced_token);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2014);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 234, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1994);
      match(myParser::LPAREN);
      setState(1996);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 231, _ctx)) {
      case 1: {
        setState(1995);
        balanced_tokens();
        break;
      }

      default:
        break;
      }
      setState(1998);
      match(myParser::RPAREN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1999);
      match(myParser::LBRACK);
      setState(2001);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 232, _ctx)) {
      case 1: {
        setState(2000);
        balanced_tokens();
        break;
      }

      default:
        break;
      }
      setState(2003);
      match(myParser::RBRACK);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2004);
      match(myParser::LCURLY);
      setState(2006);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 233, _ctx)) {
      case 1: {
        setState(2005);
        balanced_tokens();
        break;
      }

      default:
        break;
      }
      setState(2008);
      match(myParser::RCURLY);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2009);
      identifier();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2010);
      keyword();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2011);
      literal();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2012);
      operator_();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2013);
      balanced_token_punctuation();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Balanced_token_punctuationContext ------------------------------------------------------------------

myParser::Balanced_token_punctuationContext::Balanced_token_punctuationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Balanced_token_punctuationContext::DOT() {
  return getToken(myParser::DOT, 0);
}

tree::TerminalNode* myParser::Balanced_token_punctuationContext::COMMA() {
  return getToken(myParser::COMMA, 0);
}

tree::TerminalNode* myParser::Balanced_token_punctuationContext::COLON() {
  return getToken(myParser::COLON, 0);
}

tree::TerminalNode* myParser::Balanced_token_punctuationContext::SEMI() {
  return getToken(myParser::SEMI, 0);
}

tree::TerminalNode* myParser::Balanced_token_punctuationContext::EQUAL() {
  return getToken(myParser::EQUAL, 0);
}

tree::TerminalNode* myParser::Balanced_token_punctuationContext::AT() {
  return getToken(myParser::AT, 0);
}

tree::TerminalNode* myParser::Balanced_token_punctuationContext::HASH() {
  return getToken(myParser::HASH, 0);
}

tree::TerminalNode* myParser::Balanced_token_punctuationContext::BACKTICK() {
  return getToken(myParser::BACKTICK, 0);
}

tree::TerminalNode* myParser::Balanced_token_punctuationContext::QUESTION() {
  return getToken(myParser::QUESTION, 0);
}

myParser::Arrow_operatorContext* myParser::Balanced_token_punctuationContext::arrow_operator() {
  return getRuleContext<myParser::Arrow_operatorContext>(0);
}

tree::TerminalNode* myParser::Balanced_token_punctuationContext::AND() {
  return getToken(myParser::AND, 0);
}

tree::TerminalNode* myParser::Balanced_token_punctuationContext::BANG() {
  return getToken(myParser::BANG, 0);
}


size_t myParser::Balanced_token_punctuationContext::getRuleIndex() const {
  return myParser::RuleBalanced_token_punctuation;
}

void myParser::Balanced_token_punctuationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBalanced_token_punctuation(this);
}

void myParser::Balanced_token_punctuationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBalanced_token_punctuation(this);
}

myParser::Balanced_token_punctuationContext* myParser::balanced_token_punctuation() {
  Balanced_token_punctuationContext *_localctx = _tracker.createInstance<Balanced_token_punctuationContext>(_ctx, getState());
  enterRule(_localctx, 400, myParser::RuleBalanced_token_punctuation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2022);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 235, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2016);
      _la = _input->LA(1);
      if (!(((((_la - 138) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 138)) & 201638785) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2017);
      arrow_operator();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2018);

      if (!(SwiftSupport.isPrefixOp(_input))) throw FailedPredicateException(this, "SwiftSupport.isPrefixOp(_input)");
      setState(2019);
      match(myParser::AND);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2020);

      if (!(SwiftSupport.isPostfixOp(_input))) throw FailedPredicateException(this, "SwiftSupport.isPostfixOp(_input)");
      setState(2021);
      match(myParser::BANG);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

myParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Prefix_expressionContext* myParser::ExpressionContext::prefix_expression() {
  return getRuleContext<myParser::Prefix_expressionContext>(0);
}

myParser::Try_operatorContext* myParser::ExpressionContext::try_operator() {
  return getRuleContext<myParser::Try_operatorContext>(0);
}

myParser::Binary_expressionsContext* myParser::ExpressionContext::binary_expressions() {
  return getRuleContext<myParser::Binary_expressionsContext>(0);
}


size_t myParser::ExpressionContext::getRuleIndex() const {
  return myParser::RuleExpression;
}

void myParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void myParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}

myParser::ExpressionContext* myParser::expression() {
  ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, getState());
  enterRule(_localctx, 402, myParser::RuleExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2025);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 236, _ctx)) {
    case 1: {
      setState(2024);
      try_operator();
      break;
    }

    default:
      break;
    }
    setState(2027);
    prefix_expression();
    setState(2029);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx)) {
    case 1: {
      setState(2028);
      binary_expressions();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_listContext ------------------------------------------------------------------

myParser::Expression_listContext::Expression_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::ExpressionContext *> myParser::Expression_listContext::expression() {
  return getRuleContexts<myParser::ExpressionContext>();
}

myParser::ExpressionContext* myParser::Expression_listContext::expression(size_t i) {
  return getRuleContext<myParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Expression_listContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Expression_listContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Expression_listContext::getRuleIndex() const {
  return myParser::RuleExpression_list;
}

void myParser::Expression_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_list(this);
}

void myParser::Expression_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_list(this);
}

myParser::Expression_listContext* myParser::expression_list() {
  Expression_listContext *_localctx = _tracker.createInstance<Expression_listContext>(_ctx, getState());
  enterRule(_localctx, 404, myParser::RuleExpression_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2031);
    expression();
    setState(2036);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(2032);
      match(myParser::COMMA);
      setState(2033);
      expression();
      setState(2038);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Prefix_expressionContext ------------------------------------------------------------------

myParser::Prefix_expressionContext::Prefix_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Postfix_expressionContext* myParser::Prefix_expressionContext::postfix_expression() {
  return getRuleContext<myParser::Postfix_expressionContext>(0);
}

myParser::Prefix_operatorContext* myParser::Prefix_expressionContext::prefix_operator() {
  return getRuleContext<myParser::Prefix_operatorContext>(0);
}

myParser::In_out_expressionContext* myParser::Prefix_expressionContext::in_out_expression() {
  return getRuleContext<myParser::In_out_expressionContext>(0);
}


size_t myParser::Prefix_expressionContext::getRuleIndex() const {
  return myParser::RulePrefix_expression;
}

void myParser::Prefix_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrefix_expression(this);
}

void myParser::Prefix_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrefix_expression(this);
}

myParser::Prefix_expressionContext* myParser::prefix_expression() {
  Prefix_expressionContext *_localctx = _tracker.createInstance<Prefix_expressionContext>(_ctx, getState());
  enterRule(_localctx, 406, myParser::RulePrefix_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2044);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 240, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2040);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 239, _ctx)) {
      case 1: {
        setState(2039);
        prefix_operator();
        break;
      }

      default:
        break;
      }
      setState(2042);
      postfix_expression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2043);
      in_out_expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- In_out_expressionContext ------------------------------------------------------------------

myParser::In_out_expressionContext::In_out_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::In_out_expressionContext::AND() {
  return getToken(myParser::AND, 0);
}

myParser::IdentifierContext* myParser::In_out_expressionContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}


size_t myParser::In_out_expressionContext::getRuleIndex() const {
  return myParser::RuleIn_out_expression;
}

void myParser::In_out_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIn_out_expression(this);
}

void myParser::In_out_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIn_out_expression(this);
}

myParser::In_out_expressionContext* myParser::in_out_expression() {
  In_out_expressionContext *_localctx = _tracker.createInstance<In_out_expressionContext>(_ctx, getState());
  enterRule(_localctx, 408, myParser::RuleIn_out_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2046);
    match(myParser::AND);
    setState(2047);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Try_operatorContext ------------------------------------------------------------------

myParser::Try_operatorContext::Try_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Try_operatorContext::TRY() {
  return getToken(myParser::TRY, 0);
}

tree::TerminalNode* myParser::Try_operatorContext::QUESTION() {
  return getToken(myParser::QUESTION, 0);
}

tree::TerminalNode* myParser::Try_operatorContext::BANG() {
  return getToken(myParser::BANG, 0);
}


size_t myParser::Try_operatorContext::getRuleIndex() const {
  return myParser::RuleTry_operator;
}

void myParser::Try_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTry_operator(this);
}

void myParser::Try_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTry_operator(this);
}

myParser::Try_operatorContext* myParser::try_operator() {
  Try_operatorContext *_localctx = _tracker.createInstance<Try_operatorContext>(_ctx, getState());
  enterRule(_localctx, 410, myParser::RuleTry_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2049);
    match(myParser::TRY);
    setState(2051);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 241, _ctx)) {
    case 1: {
      setState(2050);
      _la = _input->LA(1);
      if (!(_la == myParser::BANG

      || _la == myParser::QUESTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Binary_expressionContext ------------------------------------------------------------------

myParser::Binary_expressionContext::Binary_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Binary_operatorContext* myParser::Binary_expressionContext::binary_operator() {
  return getRuleContext<myParser::Binary_operatorContext>(0);
}

myParser::Prefix_expressionContext* myParser::Binary_expressionContext::prefix_expression() {
  return getRuleContext<myParser::Prefix_expressionContext>(0);
}

myParser::Assignment_operatorContext* myParser::Binary_expressionContext::assignment_operator() {
  return getRuleContext<myParser::Assignment_operatorContext>(0);
}

myParser::Conditional_operatorContext* myParser::Binary_expressionContext::conditional_operator() {
  return getRuleContext<myParser::Conditional_operatorContext>(0);
}

myParser::Try_operatorContext* myParser::Binary_expressionContext::try_operator() {
  return getRuleContext<myParser::Try_operatorContext>(0);
}

myParser::Type_casting_operatorContext* myParser::Binary_expressionContext::type_casting_operator() {
  return getRuleContext<myParser::Type_casting_operatorContext>(0);
}


size_t myParser::Binary_expressionContext::getRuleIndex() const {
  return myParser::RuleBinary_expression;
}

void myParser::Binary_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinary_expression(this);
}

void myParser::Binary_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinary_expression(this);
}

myParser::Binary_expressionContext* myParser::binary_expression() {
  Binary_expressionContext *_localctx = _tracker.createInstance<Binary_expressionContext>(_ctx, getState());
  enterRule(_localctx, 412, myParser::RuleBinary_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2066);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 244, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2053);
      binary_operator();
      setState(2054);
      prefix_expression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2058);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx)) {
      case 1: {
        setState(2056);
        assignment_operator();
        break;
      }

      case 2: {
        setState(2057);
        conditional_operator();
        break;
      }

      default:
        break;
      }
      setState(2061);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 243, _ctx)) {
      case 1: {
        setState(2060);
        try_operator();
        break;
      }

      default:
        break;
      }
      setState(2063);
      prefix_expression();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2065);
      type_casting_operator();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Binary_expressionsContext ------------------------------------------------------------------

myParser::Binary_expressionsContext::Binary_expressionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Binary_expressionContext *> myParser::Binary_expressionsContext::binary_expression() {
  return getRuleContexts<myParser::Binary_expressionContext>();
}

myParser::Binary_expressionContext* myParser::Binary_expressionsContext::binary_expression(size_t i) {
  return getRuleContext<myParser::Binary_expressionContext>(i);
}


size_t myParser::Binary_expressionsContext::getRuleIndex() const {
  return myParser::RuleBinary_expressions;
}

void myParser::Binary_expressionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinary_expressions(this);
}

void myParser::Binary_expressionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinary_expressions(this);
}

myParser::Binary_expressionsContext* myParser::binary_expressions() {
  Binary_expressionsContext *_localctx = _tracker.createInstance<Binary_expressionsContext>(_ctx, getState());
  enterRule(_localctx, 414, myParser::RuleBinary_expressions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2069); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(2068);
              binary_expression();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(2071); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 245, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Conditional_operatorContext ------------------------------------------------------------------

myParser::Conditional_operatorContext::Conditional_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Conditional_operatorContext::QUESTION() {
  return getToken(myParser::QUESTION, 0);
}

myParser::ExpressionContext* myParser::Conditional_operatorContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

tree::TerminalNode* myParser::Conditional_operatorContext::COLON() {
  return getToken(myParser::COLON, 0);
}


size_t myParser::Conditional_operatorContext::getRuleIndex() const {
  return myParser::RuleConditional_operator;
}

void myParser::Conditional_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditional_operator(this);
}

void myParser::Conditional_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditional_operator(this);
}

myParser::Conditional_operatorContext* myParser::conditional_operator() {
  Conditional_operatorContext *_localctx = _tracker.createInstance<Conditional_operatorContext>(_ctx, getState());
  enterRule(_localctx, 416, myParser::RuleConditional_operator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2073);
    match(myParser::QUESTION);
    setState(2074);
    expression();
    setState(2075);
    match(myParser::COLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_casting_operatorContext ------------------------------------------------------------------

myParser::Type_casting_operatorContext::Type_casting_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::TypeContext* myParser::Type_casting_operatorContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

tree::TerminalNode* myParser::Type_casting_operatorContext::IS() {
  return getToken(myParser::IS, 0);
}

tree::TerminalNode* myParser::Type_casting_operatorContext::AS() {
  return getToken(myParser::AS, 0);
}

tree::TerminalNode* myParser::Type_casting_operatorContext::QUESTION() {
  return getToken(myParser::QUESTION, 0);
}

tree::TerminalNode* myParser::Type_casting_operatorContext::BANG() {
  return getToken(myParser::BANG, 0);
}


size_t myParser::Type_casting_operatorContext::getRuleIndex() const {
  return myParser::RuleType_casting_operator;
}

void myParser::Type_casting_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_casting_operator(this);
}

void myParser::Type_casting_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_casting_operator(this);
}

myParser::Type_casting_operatorContext* myParser::type_casting_operator() {
  Type_casting_operatorContext *_localctx = _tracker.createInstance<Type_casting_operatorContext>(_ctx, getState());
  enterRule(_localctx, 418, myParser::RuleType_casting_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2082);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::IS: {
        setState(2077);
        match(myParser::IS);
        break;
      }

      case myParser::AS: {
        setState(2078);
        match(myParser::AS);
        setState(2080);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::BANG

        || _la == myParser::QUESTION) {
          setState(2079);
          _la = _input->LA(1);
          if (!(_la == myParser::BANG

          || _la == myParser::QUESTION)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2084);
    type(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Primary_expressionContext ------------------------------------------------------------------

myParser::Primary_expressionContext::Primary_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Unqualified_nameContext* myParser::Primary_expressionContext::unqualified_name() {
  return getRuleContext<myParser::Unqualified_nameContext>(0);
}

myParser::Generic_argument_clauseContext* myParser::Primary_expressionContext::generic_argument_clause() {
  return getRuleContext<myParser::Generic_argument_clauseContext>(0);
}

myParser::Array_typeContext* myParser::Primary_expressionContext::array_type() {
  return getRuleContext<myParser::Array_typeContext>(0);
}

myParser::Dictionary_typeContext* myParser::Primary_expressionContext::dictionary_type() {
  return getRuleContext<myParser::Dictionary_typeContext>(0);
}

myParser::Literal_expressionContext* myParser::Primary_expressionContext::literal_expression() {
  return getRuleContext<myParser::Literal_expressionContext>(0);
}

myParser::Self_expressionContext* myParser::Primary_expressionContext::self_expression() {
  return getRuleContext<myParser::Self_expressionContext>(0);
}

myParser::Superclass_expressionContext* myParser::Primary_expressionContext::superclass_expression() {
  return getRuleContext<myParser::Superclass_expressionContext>(0);
}

myParser::Closure_expressionContext* myParser::Primary_expressionContext::closure_expression() {
  return getRuleContext<myParser::Closure_expressionContext>(0);
}

myParser::Parenthesized_operatorContext* myParser::Primary_expressionContext::parenthesized_operator() {
  return getRuleContext<myParser::Parenthesized_operatorContext>(0);
}

myParser::Parenthesized_expressionContext* myParser::Primary_expressionContext::parenthesized_expression() {
  return getRuleContext<myParser::Parenthesized_expressionContext>(0);
}

myParser::Tuple_expressionContext* myParser::Primary_expressionContext::tuple_expression() {
  return getRuleContext<myParser::Tuple_expressionContext>(0);
}

myParser::Implicit_member_expressionContext* myParser::Primary_expressionContext::implicit_member_expression() {
  return getRuleContext<myParser::Implicit_member_expressionContext>(0);
}

myParser::Wildcard_expressionContext* myParser::Primary_expressionContext::wildcard_expression() {
  return getRuleContext<myParser::Wildcard_expressionContext>(0);
}

myParser::Key_path_expressionContext* myParser::Primary_expressionContext::key_path_expression() {
  return getRuleContext<myParser::Key_path_expressionContext>(0);
}

myParser::Selector_expressionContext* myParser::Primary_expressionContext::selector_expression() {
  return getRuleContext<myParser::Selector_expressionContext>(0);
}

myParser::Key_path_string_expressionContext* myParser::Primary_expressionContext::key_path_string_expression() {
  return getRuleContext<myParser::Key_path_string_expressionContext>(0);
}


size_t myParser::Primary_expressionContext::getRuleIndex() const {
  return myParser::RulePrimary_expression;
}

void myParser::Primary_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimary_expression(this);
}

void myParser::Primary_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimary_expression(this);
}

myParser::Primary_expressionContext* myParser::primary_expression() {
  Primary_expressionContext *_localctx = _tracker.createInstance<Primary_expressionContext>(_ctx, getState());
  enterRule(_localctx, 420, myParser::RulePrimary_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2104);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 249, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2086);
      unqualified_name();
      setState(2088);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 248, _ctx)) {
      case 1: {
        setState(2087);
        generic_argument_clause();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2090);
      array_type();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2091);
      dictionary_type();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2092);
      literal_expression();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2093);
      self_expression();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2094);
      superclass_expression();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2095);
      closure_expression();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2096);
      parenthesized_operator();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2097);
      parenthesized_expression();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(2098);
      tuple_expression();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(2099);
      implicit_member_expression();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(2100);
      wildcard_expression();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(2101);
      key_path_expression();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(2102);
      selector_expression();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(2103);
      key_path_string_expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unqualified_nameContext ------------------------------------------------------------------

myParser::Unqualified_nameContext::Unqualified_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::Unqualified_nameContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

tree::TerminalNode* myParser::Unqualified_nameContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::Argument_namesContext* myParser::Unqualified_nameContext::argument_names() {
  return getRuleContext<myParser::Argument_namesContext>(0);
}

tree::TerminalNode* myParser::Unqualified_nameContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}


size_t myParser::Unqualified_nameContext::getRuleIndex() const {
  return myParser::RuleUnqualified_name;
}

void myParser::Unqualified_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnqualified_name(this);
}

void myParser::Unqualified_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnqualified_name(this);
}

myParser::Unqualified_nameContext* myParser::unqualified_name() {
  Unqualified_nameContext *_localctx = _tracker.createInstance<Unqualified_nameContext>(_ctx, getState());
  enterRule(_localctx, 422, myParser::RuleUnqualified_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2106);
    identifier();
    setState(2111);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 250, _ctx)) {
    case 1: {
      setState(2107);
      match(myParser::LPAREN);
      setState(2108);
      argument_names();
      setState(2109);
      match(myParser::RPAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Literal_expressionContext ------------------------------------------------------------------

myParser::Literal_expressionContext::Literal_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::LiteralContext* myParser::Literal_expressionContext::literal() {
  return getRuleContext<myParser::LiteralContext>(0);
}

myParser::Array_literalContext* myParser::Literal_expressionContext::array_literal() {
  return getRuleContext<myParser::Array_literalContext>(0);
}

myParser::Dictionary_literalContext* myParser::Literal_expressionContext::dictionary_literal() {
  return getRuleContext<myParser::Dictionary_literalContext>(0);
}

myParser::Playground_literalContext* myParser::Literal_expressionContext::playground_literal() {
  return getRuleContext<myParser::Playground_literalContext>(0);
}

tree::TerminalNode* myParser::Literal_expressionContext::HASH_FILE() {
  return getToken(myParser::HASH_FILE, 0);
}

tree::TerminalNode* myParser::Literal_expressionContext::HASH_FILE_ID() {
  return getToken(myParser::HASH_FILE_ID, 0);
}

tree::TerminalNode* myParser::Literal_expressionContext::HASH_FILE_PATH() {
  return getToken(myParser::HASH_FILE_PATH, 0);
}

tree::TerminalNode* myParser::Literal_expressionContext::HASH_LINE() {
  return getToken(myParser::HASH_LINE, 0);
}

tree::TerminalNode* myParser::Literal_expressionContext::HASH_COLUMN() {
  return getToken(myParser::HASH_COLUMN, 0);
}

tree::TerminalNode* myParser::Literal_expressionContext::HASH_FUNCTION() {
  return getToken(myParser::HASH_FUNCTION, 0);
}

tree::TerminalNode* myParser::Literal_expressionContext::HASH_DSO_HANDLE() {
  return getToken(myParser::HASH_DSO_HANDLE, 0);
}


size_t myParser::Literal_expressionContext::getRuleIndex() const {
  return myParser::RuleLiteral_expression;
}

void myParser::Literal_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral_expression(this);
}

void myParser::Literal_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral_expression(this);
}

myParser::Literal_expressionContext* myParser::literal_expression() {
  Literal_expressionContext *_localctx = _tracker.createInstance<Literal_expressionContext>(_ctx, getState());
  enterRule(_localctx, 424, myParser::RuleLiteral_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2124);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 251, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2113);
      literal();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2114);
      array_literal();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2115);
      dictionary_literal();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2116);
      playground_literal();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2117);
      match(myParser::HASH_FILE);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2118);
      match(myParser::HASH_FILE_ID);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2119);
      match(myParser::HASH_FILE_PATH);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2120);
      match(myParser::HASH_LINE);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2121);
      match(myParser::HASH_COLUMN);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(2122);
      match(myParser::HASH_FUNCTION);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(2123);
      match(myParser::HASH_DSO_HANDLE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_literalContext ------------------------------------------------------------------

myParser::Array_literalContext::Array_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Array_literalContext::LBRACK() {
  return getToken(myParser::LBRACK, 0);
}

tree::TerminalNode* myParser::Array_literalContext::RBRACK() {
  return getToken(myParser::RBRACK, 0);
}

myParser::Array_literal_itemsContext* myParser::Array_literalContext::array_literal_items() {
  return getRuleContext<myParser::Array_literal_itemsContext>(0);
}


size_t myParser::Array_literalContext::getRuleIndex() const {
  return myParser::RuleArray_literal;
}

void myParser::Array_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_literal(this);
}

void myParser::Array_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_literal(this);
}

myParser::Array_literalContext* myParser::array_literal() {
  Array_literalContext *_localctx = _tracker.createInstance<Array_literalContext>(_ctx, getState());
  enterRule(_localctx, 426, myParser::RuleArray_literal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2126);
    match(myParser::LBRACK);
    setState(2128);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 252, _ctx)) {
    case 1: {
      setState(2127);
      array_literal_items();
      break;
    }

    default:
      break;
    }
    setState(2130);
    match(myParser::RBRACK);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_literal_itemsContext ------------------------------------------------------------------

myParser::Array_literal_itemsContext::Array_literal_itemsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Array_literal_itemContext *> myParser::Array_literal_itemsContext::array_literal_item() {
  return getRuleContexts<myParser::Array_literal_itemContext>();
}

myParser::Array_literal_itemContext* myParser::Array_literal_itemsContext::array_literal_item(size_t i) {
  return getRuleContext<myParser::Array_literal_itemContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Array_literal_itemsContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Array_literal_itemsContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Array_literal_itemsContext::getRuleIndex() const {
  return myParser::RuleArray_literal_items;
}

void myParser::Array_literal_itemsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_literal_items(this);
}

void myParser::Array_literal_itemsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_literal_items(this);
}

myParser::Array_literal_itemsContext* myParser::array_literal_items() {
  Array_literal_itemsContext *_localctx = _tracker.createInstance<Array_literal_itemsContext>(_ctx, getState());
  enterRule(_localctx, 428, myParser::RuleArray_literal_items);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2132);
    array_literal_item();
    setState(2137);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 253, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2133);
        match(myParser::COMMA);
        setState(2134);
        array_literal_item(); 
      }
      setState(2139);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 253, _ctx);
    }
    setState(2141);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::COMMA) {
      setState(2140);
      match(myParser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_literal_itemContext ------------------------------------------------------------------

myParser::Array_literal_itemContext::Array_literal_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionContext* myParser::Array_literal_itemContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}


size_t myParser::Array_literal_itemContext::getRuleIndex() const {
  return myParser::RuleArray_literal_item;
}

void myParser::Array_literal_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_literal_item(this);
}

void myParser::Array_literal_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_literal_item(this);
}

myParser::Array_literal_itemContext* myParser::array_literal_item() {
  Array_literal_itemContext *_localctx = _tracker.createInstance<Array_literal_itemContext>(_ctx, getState());
  enterRule(_localctx, 430, myParser::RuleArray_literal_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2143);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dictionary_literalContext ------------------------------------------------------------------

myParser::Dictionary_literalContext::Dictionary_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Dictionary_literalContext::LBRACK() {
  return getToken(myParser::LBRACK, 0);
}

tree::TerminalNode* myParser::Dictionary_literalContext::RBRACK() {
  return getToken(myParser::RBRACK, 0);
}

myParser::Dictionary_literal_itemsContext* myParser::Dictionary_literalContext::dictionary_literal_items() {
  return getRuleContext<myParser::Dictionary_literal_itemsContext>(0);
}

tree::TerminalNode* myParser::Dictionary_literalContext::COLON() {
  return getToken(myParser::COLON, 0);
}


size_t myParser::Dictionary_literalContext::getRuleIndex() const {
  return myParser::RuleDictionary_literal;
}

void myParser::Dictionary_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDictionary_literal(this);
}

void myParser::Dictionary_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDictionary_literal(this);
}

myParser::Dictionary_literalContext* myParser::dictionary_literal() {
  Dictionary_literalContext *_localctx = _tracker.createInstance<Dictionary_literalContext>(_ctx, getState());
  enterRule(_localctx, 432, myParser::RuleDictionary_literal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2145);
    match(myParser::LBRACK);
    setState(2148);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 255, _ctx)) {
    case 1: {
      setState(2146);
      dictionary_literal_items();
      break;
    }

    case 2: {
      setState(2147);
      match(myParser::COLON);
      break;
    }

    default:
      break;
    }
    setState(2150);
    match(myParser::RBRACK);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dictionary_literal_itemsContext ------------------------------------------------------------------

myParser::Dictionary_literal_itemsContext::Dictionary_literal_itemsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Dictionary_literal_itemContext *> myParser::Dictionary_literal_itemsContext::dictionary_literal_item() {
  return getRuleContexts<myParser::Dictionary_literal_itemContext>();
}

myParser::Dictionary_literal_itemContext* myParser::Dictionary_literal_itemsContext::dictionary_literal_item(size_t i) {
  return getRuleContext<myParser::Dictionary_literal_itemContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Dictionary_literal_itemsContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Dictionary_literal_itemsContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Dictionary_literal_itemsContext::getRuleIndex() const {
  return myParser::RuleDictionary_literal_items;
}

void myParser::Dictionary_literal_itemsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDictionary_literal_items(this);
}

void myParser::Dictionary_literal_itemsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDictionary_literal_items(this);
}

myParser::Dictionary_literal_itemsContext* myParser::dictionary_literal_items() {
  Dictionary_literal_itemsContext *_localctx = _tracker.createInstance<Dictionary_literal_itemsContext>(_ctx, getState());
  enterRule(_localctx, 434, myParser::RuleDictionary_literal_items);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2152);
    dictionary_literal_item();
    setState(2157);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 256, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2153);
        match(myParser::COMMA);
        setState(2154);
        dictionary_literal_item(); 
      }
      setState(2159);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 256, _ctx);
    }
    setState(2161);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::COMMA) {
      setState(2160);
      match(myParser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dictionary_literal_itemContext ------------------------------------------------------------------

myParser::Dictionary_literal_itemContext::Dictionary_literal_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::ExpressionContext *> myParser::Dictionary_literal_itemContext::expression() {
  return getRuleContexts<myParser::ExpressionContext>();
}

myParser::ExpressionContext* myParser::Dictionary_literal_itemContext::expression(size_t i) {
  return getRuleContext<myParser::ExpressionContext>(i);
}

tree::TerminalNode* myParser::Dictionary_literal_itemContext::COLON() {
  return getToken(myParser::COLON, 0);
}


size_t myParser::Dictionary_literal_itemContext::getRuleIndex() const {
  return myParser::RuleDictionary_literal_item;
}

void myParser::Dictionary_literal_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDictionary_literal_item(this);
}

void myParser::Dictionary_literal_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDictionary_literal_item(this);
}

myParser::Dictionary_literal_itemContext* myParser::dictionary_literal_item() {
  Dictionary_literal_itemContext *_localctx = _tracker.createInstance<Dictionary_literal_itemContext>(_ctx, getState());
  enterRule(_localctx, 436, myParser::RuleDictionary_literal_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2163);
    expression();
    setState(2164);
    match(myParser::COLON);
    setState(2165);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Playground_literalContext ------------------------------------------------------------------

myParser::Playground_literalContext::Playground_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Playground_literalContext::HASH_COLOR_LITERAL() {
  return getToken(myParser::HASH_COLOR_LITERAL, 0);
}

tree::TerminalNode* myParser::Playground_literalContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::Playground_literalContext::RED() {
  return getToken(myParser::RED, 0);
}

std::vector<tree::TerminalNode *> myParser::Playground_literalContext::COLON() {
  return getTokens(myParser::COLON);
}

tree::TerminalNode* myParser::Playground_literalContext::COLON(size_t i) {
  return getToken(myParser::COLON, i);
}

std::vector<myParser::ExpressionContext *> myParser::Playground_literalContext::expression() {
  return getRuleContexts<myParser::ExpressionContext>();
}

myParser::ExpressionContext* myParser::Playground_literalContext::expression(size_t i) {
  return getRuleContext<myParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Playground_literalContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Playground_literalContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}

tree::TerminalNode* myParser::Playground_literalContext::GREEN() {
  return getToken(myParser::GREEN, 0);
}

tree::TerminalNode* myParser::Playground_literalContext::BLUE() {
  return getToken(myParser::BLUE, 0);
}

tree::TerminalNode* myParser::Playground_literalContext::ALPHA() {
  return getToken(myParser::ALPHA, 0);
}

tree::TerminalNode* myParser::Playground_literalContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

tree::TerminalNode* myParser::Playground_literalContext::HASH_FILE_LITERAL() {
  return getToken(myParser::HASH_FILE_LITERAL, 0);
}

tree::TerminalNode* myParser::Playground_literalContext::RESOURCE_NAME() {
  return getToken(myParser::RESOURCE_NAME, 0);
}

tree::TerminalNode* myParser::Playground_literalContext::HASH_IMAGE_LITERAL() {
  return getToken(myParser::HASH_IMAGE_LITERAL, 0);
}


size_t myParser::Playground_literalContext::getRuleIndex() const {
  return myParser::RulePlayground_literal;
}

void myParser::Playground_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlayground_literal(this);
}

void myParser::Playground_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlayground_literal(this);
}

myParser::Playground_literalContext* myParser::playground_literal() {
  Playground_literalContext *_localctx = _tracker.createInstance<Playground_literalContext>(_ctx, getState());
  enterRule(_localctx, 438, myParser::RulePlayground_literal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2200);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::HASH_COLOR_LITERAL: {
        enterOuterAlt(_localctx, 1);
        setState(2167);
        match(myParser::HASH_COLOR_LITERAL);
        setState(2168);
        match(myParser::LPAREN);
        setState(2169);
        match(myParser::RED);
        setState(2170);
        match(myParser::COLON);
        setState(2171);
        expression();
        setState(2172);
        match(myParser::COMMA);
        setState(2173);
        match(myParser::GREEN);
        setState(2174);
        match(myParser::COLON);
        setState(2175);
        expression();
        setState(2176);
        match(myParser::COMMA);
        setState(2177);
        match(myParser::BLUE);
        setState(2178);
        match(myParser::COLON);
        setState(2179);
        expression();
        setState(2180);
        match(myParser::COMMA);
        setState(2181);
        match(myParser::ALPHA);
        setState(2182);
        match(myParser::COLON);
        setState(2183);
        expression();
        setState(2184);
        match(myParser::RPAREN);
        break;
      }

      case myParser::HASH_FILE_LITERAL: {
        enterOuterAlt(_localctx, 2);
        setState(2186);
        match(myParser::HASH_FILE_LITERAL);
        setState(2187);
        match(myParser::LPAREN);
        setState(2188);
        match(myParser::RESOURCE_NAME);
        setState(2189);
        match(myParser::COLON);
        setState(2190);
        expression();
        setState(2191);
        match(myParser::RPAREN);
        break;
      }

      case myParser::HASH_IMAGE_LITERAL: {
        enterOuterAlt(_localctx, 3);
        setState(2193);
        match(myParser::HASH_IMAGE_LITERAL);
        setState(2194);
        match(myParser::LPAREN);
        setState(2195);
        match(myParser::RESOURCE_NAME);
        setState(2196);
        match(myParser::COLON);
        setState(2197);
        expression();
        setState(2198);
        match(myParser::RPAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Self_expressionContext ------------------------------------------------------------------

myParser::Self_expressionContext::Self_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t myParser::Self_expressionContext::getRuleIndex() const {
  return myParser::RuleSelf_expression;
}

void myParser::Self_expressionContext::copyFrom(Self_expressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Self_initializer_expressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::Self_initializer_expressionContext::SELF() {
  return getToken(myParser::SELF, 0);
}

tree::TerminalNode* myParser::Self_initializer_expressionContext::DOT() {
  return getToken(myParser::DOT, 0);
}

tree::TerminalNode* myParser::Self_initializer_expressionContext::INIT() {
  return getToken(myParser::INIT, 0);
}

myParser::Self_initializer_expressionContext::Self_initializer_expressionContext(Self_expressionContext *ctx) { copyFrom(ctx); }

void myParser::Self_initializer_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelf_initializer_expression(this);
}
void myParser::Self_initializer_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelf_initializer_expression(this);
}
//----------------- Self_pure_expressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::Self_pure_expressionContext::SELF() {
  return getToken(myParser::SELF, 0);
}

myParser::Self_pure_expressionContext::Self_pure_expressionContext(Self_expressionContext *ctx) { copyFrom(ctx); }

void myParser::Self_pure_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelf_pure_expression(this);
}
void myParser::Self_pure_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelf_pure_expression(this);
}
//----------------- Self_subscript_expressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::Self_subscript_expressionContext::SELF() {
  return getToken(myParser::SELF, 0);
}

tree::TerminalNode* myParser::Self_subscript_expressionContext::LBRACK() {
  return getToken(myParser::LBRACK, 0);
}

myParser::Function_call_argument_listContext* myParser::Self_subscript_expressionContext::function_call_argument_list() {
  return getRuleContext<myParser::Function_call_argument_listContext>(0);
}

tree::TerminalNode* myParser::Self_subscript_expressionContext::RBRACK() {
  return getToken(myParser::RBRACK, 0);
}

myParser::Self_subscript_expressionContext::Self_subscript_expressionContext(Self_expressionContext *ctx) { copyFrom(ctx); }

void myParser::Self_subscript_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelf_subscript_expression(this);
}
void myParser::Self_subscript_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelf_subscript_expression(this);
}
//----------------- Self_method_expressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::Self_method_expressionContext::SELF() {
  return getToken(myParser::SELF, 0);
}

tree::TerminalNode* myParser::Self_method_expressionContext::DOT() {
  return getToken(myParser::DOT, 0);
}

myParser::IdentifierContext* myParser::Self_method_expressionContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::Self_method_expressionContext::Self_method_expressionContext(Self_expressionContext *ctx) { copyFrom(ctx); }

void myParser::Self_method_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelf_method_expression(this);
}
void myParser::Self_method_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelf_method_expression(this);
}
myParser::Self_expressionContext* myParser::self_expression() {
  Self_expressionContext *_localctx = _tracker.createInstance<Self_expressionContext>(_ctx, getState());
  enterRule(_localctx, 440, myParser::RuleSelf_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2214);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 259, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<myParser::Self_pure_expressionContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(2202);
      match(myParser::SELF);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<myParser::Self_method_expressionContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(2203);
      match(myParser::SELF);
      setState(2204);
      match(myParser::DOT);
      setState(2205);
      identifier();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<myParser::Self_subscript_expressionContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(2206);
      match(myParser::SELF);
      setState(2207);
      match(myParser::LBRACK);
      setState(2208);
      function_call_argument_list();
      setState(2209);
      match(myParser::RBRACK);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<myParser::Self_initializer_expressionContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(2211);
      match(myParser::SELF);
      setState(2212);
      match(myParser::DOT);
      setState(2213);
      match(myParser::INIT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Superclass_expressionContext ------------------------------------------------------------------

myParser::Superclass_expressionContext::Superclass_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t myParser::Superclass_expressionContext::getRuleIndex() const {
  return myParser::RuleSuperclass_expression;
}

void myParser::Superclass_expressionContext::copyFrom(Superclass_expressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Superclass_subscript_expressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::Superclass_subscript_expressionContext::SUPER() {
  return getToken(myParser::SUPER, 0);
}

tree::TerminalNode* myParser::Superclass_subscript_expressionContext::LBRACK() {
  return getToken(myParser::LBRACK, 0);
}

myParser::Function_call_argument_listContext* myParser::Superclass_subscript_expressionContext::function_call_argument_list() {
  return getRuleContext<myParser::Function_call_argument_listContext>(0);
}

tree::TerminalNode* myParser::Superclass_subscript_expressionContext::RBRACK() {
  return getToken(myParser::RBRACK, 0);
}

myParser::Superclass_subscript_expressionContext::Superclass_subscript_expressionContext(Superclass_expressionContext *ctx) { copyFrom(ctx); }

void myParser::Superclass_subscript_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSuperclass_subscript_expression(this);
}
void myParser::Superclass_subscript_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSuperclass_subscript_expression(this);
}
//----------------- Superclass_initializer_expressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::Superclass_initializer_expressionContext::SUPER() {
  return getToken(myParser::SUPER, 0);
}

tree::TerminalNode* myParser::Superclass_initializer_expressionContext::DOT() {
  return getToken(myParser::DOT, 0);
}

tree::TerminalNode* myParser::Superclass_initializer_expressionContext::INIT() {
  return getToken(myParser::INIT, 0);
}

myParser::Superclass_initializer_expressionContext::Superclass_initializer_expressionContext(Superclass_expressionContext *ctx) { copyFrom(ctx); }

void myParser::Superclass_initializer_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSuperclass_initializer_expression(this);
}
void myParser::Superclass_initializer_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSuperclass_initializer_expression(this);
}
//----------------- Superclass_method_expressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::Superclass_method_expressionContext::SUPER() {
  return getToken(myParser::SUPER, 0);
}

tree::TerminalNode* myParser::Superclass_method_expressionContext::DOT() {
  return getToken(myParser::DOT, 0);
}

myParser::IdentifierContext* myParser::Superclass_method_expressionContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::Superclass_method_expressionContext::Superclass_method_expressionContext(Superclass_expressionContext *ctx) { copyFrom(ctx); }

void myParser::Superclass_method_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSuperclass_method_expression(this);
}
void myParser::Superclass_method_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSuperclass_method_expression(this);
}
myParser::Superclass_expressionContext* myParser::superclass_expression() {
  Superclass_expressionContext *_localctx = _tracker.createInstance<Superclass_expressionContext>(_ctx, getState());
  enterRule(_localctx, 442, myParser::RuleSuperclass_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2227);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 260, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<myParser::Superclass_method_expressionContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(2216);
      match(myParser::SUPER);
      setState(2217);
      match(myParser::DOT);
      setState(2218);
      identifier();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<myParser::Superclass_subscript_expressionContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(2219);
      match(myParser::SUPER);
      setState(2220);
      match(myParser::LBRACK);
      setState(2221);
      function_call_argument_list();
      setState(2222);
      match(myParser::RBRACK);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<myParser::Superclass_initializer_expressionContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(2224);
      match(myParser::SUPER);
      setState(2225);
      match(myParser::DOT);
      setState(2226);
      match(myParser::INIT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Closure_expressionContext ------------------------------------------------------------------

myParser::Closure_expressionContext::Closure_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Closure_expressionContext::LCURLY() {
  return getToken(myParser::LCURLY, 0);
}

tree::TerminalNode* myParser::Closure_expressionContext::RCURLY() {
  return getToken(myParser::RCURLY, 0);
}

myParser::Closure_signatureContext* myParser::Closure_expressionContext::closure_signature() {
  return getRuleContext<myParser::Closure_signatureContext>(0);
}

myParser::StatementsContext* myParser::Closure_expressionContext::statements() {
  return getRuleContext<myParser::StatementsContext>(0);
}


size_t myParser::Closure_expressionContext::getRuleIndex() const {
  return myParser::RuleClosure_expression;
}

void myParser::Closure_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClosure_expression(this);
}

void myParser::Closure_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClosure_expression(this);
}

myParser::Closure_expressionContext* myParser::closure_expression() {
  Closure_expressionContext *_localctx = _tracker.createInstance<Closure_expressionContext>(_ctx, getState());
  enterRule(_localctx, 444, myParser::RuleClosure_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2229);
    match(myParser::LCURLY);
    setState(2231);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 261, _ctx)) {
    case 1: {
      setState(2230);
      closure_signature();
      break;
    }

    default:
      break;
    }
    setState(2234);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 262, _ctx)) {
    case 1: {
      setState(2233);
      statements();
      break;
    }

    default:
      break;
    }
    setState(2236);
    match(myParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Closure_signatureContext ------------------------------------------------------------------

myParser::Closure_signatureContext::Closure_signatureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Closure_parameter_clauseContext* myParser::Closure_signatureContext::closure_parameter_clause() {
  return getRuleContext<myParser::Closure_parameter_clauseContext>(0);
}

tree::TerminalNode* myParser::Closure_signatureContext::IN() {
  return getToken(myParser::IN, 0);
}

myParser::Capture_listContext* myParser::Closure_signatureContext::capture_list() {
  return getRuleContext<myParser::Capture_listContext>(0);
}

tree::TerminalNode* myParser::Closure_signatureContext::THROWS() {
  return getToken(myParser::THROWS, 0);
}

myParser::Function_resultContext* myParser::Closure_signatureContext::function_result() {
  return getRuleContext<myParser::Function_resultContext>(0);
}


size_t myParser::Closure_signatureContext::getRuleIndex() const {
  return myParser::RuleClosure_signature;
}

void myParser::Closure_signatureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClosure_signature(this);
}

void myParser::Closure_signatureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClosure_signature(this);
}

myParser::Closure_signatureContext* myParser::closure_signature() {
  Closure_signatureContext *_localctx = _tracker.createInstance<Closure_signatureContext>(_ctx, getState());
  enterRule(_localctx, 446, myParser::RuleClosure_signature);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2253);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 266, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2239);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::LBRACK) {
        setState(2238);
        capture_list();
      }
      setState(2241);
      closure_parameter_clause();
      setState(2243);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 264, _ctx)) {
      case 1: {
        setState(2242);
        match(myParser::THROWS);
        break;
      }

      default:
        break;
      }
      setState(2246);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 265, _ctx)) {
      case 1: {
        setState(2245);
        function_result();
        break;
      }

      default:
        break;
      }
      setState(2248);
      match(myParser::IN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2250);
      capture_list();
      setState(2251);
      match(myParser::IN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Closure_parameter_clauseContext ------------------------------------------------------------------

myParser::Closure_parameter_clauseContext::Closure_parameter_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Closure_parameter_clauseContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::Closure_parameter_clauseContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

myParser::Closure_parameter_listContext* myParser::Closure_parameter_clauseContext::closure_parameter_list() {
  return getRuleContext<myParser::Closure_parameter_listContext>(0);
}

myParser::Identifier_listContext* myParser::Closure_parameter_clauseContext::identifier_list() {
  return getRuleContext<myParser::Identifier_listContext>(0);
}


size_t myParser::Closure_parameter_clauseContext::getRuleIndex() const {
  return myParser::RuleClosure_parameter_clause;
}

void myParser::Closure_parameter_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClosure_parameter_clause(this);
}

void myParser::Closure_parameter_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClosure_parameter_clause(this);
}

myParser::Closure_parameter_clauseContext* myParser::closure_parameter_clause() {
  Closure_parameter_clauseContext *_localctx = _tracker.createInstance<Closure_parameter_clauseContext>(_ctx, getState());
  enterRule(_localctx, 448, myParser::RuleClosure_parameter_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2261);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::LPAREN: {
        enterOuterAlt(_localctx, 1);
        setState(2255);
        match(myParser::LPAREN);
        setState(2257);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & -576599273992204954) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 3940649437003519) != 0) || ((((_la - 135) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 135)) & 1073741831) != 0)) {
          setState(2256);
          closure_parameter_list();
        }
        setState(2259);
        match(myParser::RPAREN);
        break;
      }

      case myParser::AS:
      case myParser::ALPHA:
      case myParser::CATCH:
      case myParser::CLASS:
      case myParser::DEFAULT:
      case myParser::DO:
      case myParser::GUARD:
      case myParser::FOR:
      case myParser::IN:
      case myParser::INTERNAL:
      case myParser::FINAL:
      case myParser::OPEN:
      case myParser::PRIVATE:
      case myParser::PUBLIC:
      case myParser::WHERE:
      case myParser::WHILE:
      case myParser::PROTOCOL:
      case myParser::GET:
      case myParser::SET:
      case myParser::WILL_SET:
      case myParser::DID_SET:
      case myParser::INDIRECT:
      case myParser::PREFIX:
      case myParser::INFIX:
      case myParser::LEFT:
      case myParser::RIGHT:
      case myParser::NONE:
      case myParser::PRECEDENCE_GROUP:
      case myParser::HIGHER_THAN:
      case myParser::LOWER_THAN:
      case myParser::ASSIGNMENT:
      case myParser::ASSOCIATIVITY:
      case myParser::POSTFIX:
      case myParser::OPERATOR:
      case myParser::OS:
      case myParser::ARCH:
      case myParser::SWIFT:
      case myParser::COMPILER:
      case myParser::CAN_IMPORT:
      case myParser::TARGET_ENVIRONMENT:
      case myParser::CONVENIENCE:
      case myParser::DYNAMIC:
      case myParser::LAZY:
      case myParser::OPTIONAL:
      case myParser::OVERRIDE:
      case myParser::REQUIRED:
      case myParser::WEAK:
      case myParser::UNOWNED:
      case myParser::SAFE:
      case myParser::UNSAFE:
      case myParser::MUTATING:
      case myParser::NONMUTATING:
      case myParser::RED:
      case myParser::BLUE:
      case myParser::GREEN:
      case myParser::RESOURCE_NAME:
      case myParser::SOME:
      case myParser::TYPE:
      case myParser::PRECEDENCE:
      case myParser::SELF:
      case myParser::SELF_BIG:
      case myParser::MAC_OS:
      case myParser::I_OS:
      case myParser::OSX:
      case myParser::WATCH_OS:
      case myParser::TV_OS:
      case myParser::LINUX:
      case myParser::WINDOWS:
      case myParser::I386:
      case myParser::X86_64:
      case myParser::ARM:
      case myParser::ARM64:
      case myParser::SIMULATOR:
      case myParser::MAC_CATALYST:
      case myParser::I_OS_APPLICATION_EXTENSION:
      case myParser::MAC_CATALYST_APPLICATION_EXTENSION:
      case myParser::MAC_OS_APPLICATION_EXTENSION:
      case myParser::FILE:
      case myParser::LINE:
      case myParser::GETTER:
      case myParser::SETTER:
      case myParser::Identifier:
      case myParser::BACKTICK: {
        enterOuterAlt(_localctx, 2);
        setState(2260);
        identifier_list();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Closure_parameter_listContext ------------------------------------------------------------------

myParser::Closure_parameter_listContext::Closure_parameter_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Closure_parameterContext *> myParser::Closure_parameter_listContext::closure_parameter() {
  return getRuleContexts<myParser::Closure_parameterContext>();
}

myParser::Closure_parameterContext* myParser::Closure_parameter_listContext::closure_parameter(size_t i) {
  return getRuleContext<myParser::Closure_parameterContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Closure_parameter_listContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Closure_parameter_listContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Closure_parameter_listContext::getRuleIndex() const {
  return myParser::RuleClosure_parameter_list;
}

void myParser::Closure_parameter_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClosure_parameter_list(this);
}

void myParser::Closure_parameter_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClosure_parameter_list(this);
}

myParser::Closure_parameter_listContext* myParser::closure_parameter_list() {
  Closure_parameter_listContext *_localctx = _tracker.createInstance<Closure_parameter_listContext>(_ctx, getState());
  enterRule(_localctx, 450, myParser::RuleClosure_parameter_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2263);
    closure_parameter();
    setState(2268);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(2264);
      match(myParser::COMMA);
      setState(2265);
      closure_parameter();
      setState(2270);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Closure_parameterContext ------------------------------------------------------------------

myParser::Closure_parameterContext::Closure_parameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::Closure_parameterContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::Type_annotationContext* myParser::Closure_parameterContext::type_annotation() {
  return getRuleContext<myParser::Type_annotationContext>(0);
}

myParser::Range_operatorContext* myParser::Closure_parameterContext::range_operator() {
  return getRuleContext<myParser::Range_operatorContext>(0);
}


size_t myParser::Closure_parameterContext::getRuleIndex() const {
  return myParser::RuleClosure_parameter;
}

void myParser::Closure_parameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClosure_parameter(this);
}

void myParser::Closure_parameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClosure_parameter(this);
}

myParser::Closure_parameterContext* myParser::closure_parameter() {
  Closure_parameterContext *_localctx = _tracker.createInstance<Closure_parameterContext>(_ctx, getState());
  enterRule(_localctx, 452, myParser::RuleClosure_parameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2271);
    antlrcpp::downCast<Closure_parameterContext *>(_localctx)->closure_parameter_name = identifier();
    setState(2276);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::COLON) {
      setState(2272);
      type_annotation();
      setState(2274);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 270, _ctx)) {
      case 1: {
        setState(2273);
        range_operator();
        break;
      }

      default:
        break;
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Capture_listContext ------------------------------------------------------------------

myParser::Capture_listContext::Capture_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Capture_listContext::LBRACK() {
  return getToken(myParser::LBRACK, 0);
}

myParser::Capture_list_itemsContext* myParser::Capture_listContext::capture_list_items() {
  return getRuleContext<myParser::Capture_list_itemsContext>(0);
}

tree::TerminalNode* myParser::Capture_listContext::RBRACK() {
  return getToken(myParser::RBRACK, 0);
}


size_t myParser::Capture_listContext::getRuleIndex() const {
  return myParser::RuleCapture_list;
}

void myParser::Capture_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCapture_list(this);
}

void myParser::Capture_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCapture_list(this);
}

myParser::Capture_listContext* myParser::capture_list() {
  Capture_listContext *_localctx = _tracker.createInstance<Capture_listContext>(_ctx, getState());
  enterRule(_localctx, 454, myParser::RuleCapture_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2278);
    match(myParser::LBRACK);
    setState(2279);
    capture_list_items();
    setState(2280);
    match(myParser::RBRACK);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Capture_list_itemsContext ------------------------------------------------------------------

myParser::Capture_list_itemsContext::Capture_list_itemsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Capture_list_itemContext *> myParser::Capture_list_itemsContext::capture_list_item() {
  return getRuleContexts<myParser::Capture_list_itemContext>();
}

myParser::Capture_list_itemContext* myParser::Capture_list_itemsContext::capture_list_item(size_t i) {
  return getRuleContext<myParser::Capture_list_itemContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Capture_list_itemsContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Capture_list_itemsContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Capture_list_itemsContext::getRuleIndex() const {
  return myParser::RuleCapture_list_items;
}

void myParser::Capture_list_itemsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCapture_list_items(this);
}

void myParser::Capture_list_itemsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCapture_list_items(this);
}

myParser::Capture_list_itemsContext* myParser::capture_list_items() {
  Capture_list_itemsContext *_localctx = _tracker.createInstance<Capture_list_itemsContext>(_ctx, getState());
  enterRule(_localctx, 456, myParser::RuleCapture_list_items);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2282);
    capture_list_item();
    setState(2287);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(2283);
      match(myParser::COMMA);
      setState(2284);
      capture_list_item();
      setState(2289);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Capture_list_itemContext ------------------------------------------------------------------

myParser::Capture_list_itemContext::Capture_list_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::Capture_list_itemContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::ExpressionContext* myParser::Capture_list_itemContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

myParser::Self_expressionContext* myParser::Capture_list_itemContext::self_expression() {
  return getRuleContext<myParser::Self_expressionContext>(0);
}

myParser::Capture_specifierContext* myParser::Capture_list_itemContext::capture_specifier() {
  return getRuleContext<myParser::Capture_specifierContext>(0);
}

tree::TerminalNode* myParser::Capture_list_itemContext::EQUAL() {
  return getToken(myParser::EQUAL, 0);
}


size_t myParser::Capture_list_itemContext::getRuleIndex() const {
  return myParser::RuleCapture_list_item;
}

void myParser::Capture_list_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCapture_list_item(this);
}

void myParser::Capture_list_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCapture_list_item(this);
}

myParser::Capture_list_itemContext* myParser::capture_list_item() {
  Capture_list_itemContext *_localctx = _tracker.createInstance<Capture_list_itemContext>(_ctx, getState());
  enterRule(_localctx, 458, myParser::RuleCapture_list_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2291);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 273, _ctx)) {
    case 1: {
      setState(2290);
      capture_specifier();
      break;
    }

    default:
      break;
    }
    setState(2300);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 275, _ctx)) {
    case 1: {
      setState(2293);
      identifier();
      setState(2295);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 274, _ctx)) {
      case 1: {
        setState(2294);
        match(myParser::EQUAL);
        break;
      }

      default:
        break;
      }
      setState(2297);
      expression();
      break;
    }

    case 2: {
      setState(2299);
      self_expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Capture_specifierContext ------------------------------------------------------------------

myParser::Capture_specifierContext::Capture_specifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Capture_specifierContext::WEAK() {
  return getToken(myParser::WEAK, 0);
}

tree::TerminalNode* myParser::Capture_specifierContext::UNOWNED() {
  return getToken(myParser::UNOWNED, 0);
}

tree::TerminalNode* myParser::Capture_specifierContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::Capture_specifierContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

tree::TerminalNode* myParser::Capture_specifierContext::SAFE() {
  return getToken(myParser::SAFE, 0);
}

tree::TerminalNode* myParser::Capture_specifierContext::UNSAFE() {
  return getToken(myParser::UNSAFE, 0);
}


size_t myParser::Capture_specifierContext::getRuleIndex() const {
  return myParser::RuleCapture_specifier;
}

void myParser::Capture_specifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCapture_specifier(this);
}

void myParser::Capture_specifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCapture_specifier(this);
}

myParser::Capture_specifierContext* myParser::capture_specifier() {
  Capture_specifierContext *_localctx = _tracker.createInstance<Capture_specifierContext>(_ctx, getState());
  enterRule(_localctx, 460, myParser::RuleCapture_specifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2309);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::WEAK: {
        enterOuterAlt(_localctx, 1);
        setState(2302);
        match(myParser::WEAK);
        break;
      }

      case myParser::UNOWNED: {
        enterOuterAlt(_localctx, 2);
        setState(2303);
        match(myParser::UNOWNED);
        setState(2307);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::LPAREN) {
          setState(2304);
          match(myParser::LPAREN);
          setState(2305);
          _la = _input->LA(1);
          if (!(_la == myParser::SAFE

          || _la == myParser::UNSAFE)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(2306);
          match(myParser::RPAREN);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Implicit_member_expressionContext ------------------------------------------------------------------

myParser::Implicit_member_expressionContext::Implicit_member_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> myParser::Implicit_member_expressionContext::DOT() {
  return getTokens(myParser::DOT);
}

tree::TerminalNode* myParser::Implicit_member_expressionContext::DOT(size_t i) {
  return getToken(myParser::DOT, i);
}

myParser::IdentifierContext* myParser::Implicit_member_expressionContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::KeywordContext* myParser::Implicit_member_expressionContext::keyword() {
  return getRuleContext<myParser::KeywordContext>(0);
}

myParser::Postfix_expressionContext* myParser::Implicit_member_expressionContext::postfix_expression() {
  return getRuleContext<myParser::Postfix_expressionContext>(0);
}


size_t myParser::Implicit_member_expressionContext::getRuleIndex() const {
  return myParser::RuleImplicit_member_expression;
}

void myParser::Implicit_member_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImplicit_member_expression(this);
}

void myParser::Implicit_member_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImplicit_member_expression(this);
}

myParser::Implicit_member_expressionContext* myParser::implicit_member_expression() {
  Implicit_member_expressionContext *_localctx = _tracker.createInstance<Implicit_member_expressionContext>(_ctx, getState());
  enterRule(_localctx, 462, myParser::RuleImplicit_member_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2311);
    match(myParser::DOT);
    setState(2314);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 278, _ctx)) {
    case 1: {
      setState(2312);
      identifier();
      break;
    }

    case 2: {
      setState(2313);
      keyword();
      break;
    }

    default:
      break;
    }
    setState(2318);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 279, _ctx)) {
    case 1: {
      setState(2316);
      match(myParser::DOT);
      setState(2317);
      postfix_expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parenthesized_operatorContext ------------------------------------------------------------------

myParser::Parenthesized_operatorContext::Parenthesized_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Parenthesized_operatorContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::OperatorContext* myParser::Parenthesized_operatorContext::operator_() {
  return getRuleContext<myParser::OperatorContext>(0);
}

tree::TerminalNode* myParser::Parenthesized_operatorContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}


size_t myParser::Parenthesized_operatorContext::getRuleIndex() const {
  return myParser::RuleParenthesized_operator;
}

void myParser::Parenthesized_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParenthesized_operator(this);
}

void myParser::Parenthesized_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParenthesized_operator(this);
}

myParser::Parenthesized_operatorContext* myParser::parenthesized_operator() {
  Parenthesized_operatorContext *_localctx = _tracker.createInstance<Parenthesized_operatorContext>(_ctx, getState());
  enterRule(_localctx, 464, myParser::RuleParenthesized_operator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2320);
    match(myParser::LPAREN);
    setState(2321);
    operator_();
    setState(2322);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parenthesized_expressionContext ------------------------------------------------------------------

myParser::Parenthesized_expressionContext::Parenthesized_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Parenthesized_expressionContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::ExpressionContext* myParser::Parenthesized_expressionContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

tree::TerminalNode* myParser::Parenthesized_expressionContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}


size_t myParser::Parenthesized_expressionContext::getRuleIndex() const {
  return myParser::RuleParenthesized_expression;
}

void myParser::Parenthesized_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParenthesized_expression(this);
}

void myParser::Parenthesized_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParenthesized_expression(this);
}

myParser::Parenthesized_expressionContext* myParser::parenthesized_expression() {
  Parenthesized_expressionContext *_localctx = _tracker.createInstance<Parenthesized_expressionContext>(_ctx, getState());
  enterRule(_localctx, 466, myParser::RuleParenthesized_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2324);
    match(myParser::LPAREN);
    setState(2325);
    expression();
    setState(2326);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tuple_expressionContext ------------------------------------------------------------------

myParser::Tuple_expressionContext::Tuple_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Tuple_expressionContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::Tuple_expressionContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

myParser::Tuple_elementContext* myParser::Tuple_expressionContext::tuple_element() {
  return getRuleContext<myParser::Tuple_elementContext>(0);
}

tree::TerminalNode* myParser::Tuple_expressionContext::COMMA() {
  return getToken(myParser::COMMA, 0);
}

myParser::Tuple_element_listContext* myParser::Tuple_expressionContext::tuple_element_list() {
  return getRuleContext<myParser::Tuple_element_listContext>(0);
}


size_t myParser::Tuple_expressionContext::getRuleIndex() const {
  return myParser::RuleTuple_expression;
}

void myParser::Tuple_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTuple_expression(this);
}

void myParser::Tuple_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTuple_expression(this);
}

myParser::Tuple_expressionContext* myParser::tuple_expression() {
  Tuple_expressionContext *_localctx = _tracker.createInstance<Tuple_expressionContext>(_ctx, getState());
  enterRule(_localctx, 468, myParser::RuleTuple_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2336);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 280, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2328);
      match(myParser::LPAREN);
      setState(2329);
      match(myParser::RPAREN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2330);
      match(myParser::LPAREN);
      setState(2331);
      tuple_element();
      setState(2332);
      match(myParser::COMMA);
      setState(2333);
      tuple_element_list();
      setState(2334);
      match(myParser::RPAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tuple_element_listContext ------------------------------------------------------------------

myParser::Tuple_element_listContext::Tuple_element_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Tuple_elementContext *> myParser::Tuple_element_listContext::tuple_element() {
  return getRuleContexts<myParser::Tuple_elementContext>();
}

myParser::Tuple_elementContext* myParser::Tuple_element_listContext::tuple_element(size_t i) {
  return getRuleContext<myParser::Tuple_elementContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Tuple_element_listContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Tuple_element_listContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Tuple_element_listContext::getRuleIndex() const {
  return myParser::RuleTuple_element_list;
}

void myParser::Tuple_element_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTuple_element_list(this);
}

void myParser::Tuple_element_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTuple_element_list(this);
}

myParser::Tuple_element_listContext* myParser::tuple_element_list() {
  Tuple_element_listContext *_localctx = _tracker.createInstance<Tuple_element_listContext>(_ctx, getState());
  enterRule(_localctx, 470, myParser::RuleTuple_element_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2338);
    tuple_element();
    setState(2343);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(2339);
      match(myParser::COMMA);
      setState(2340);
      tuple_element();
      setState(2345);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tuple_elementContext ------------------------------------------------------------------

myParser::Tuple_elementContext::Tuple_elementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionContext* myParser::Tuple_elementContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

myParser::IdentifierContext* myParser::Tuple_elementContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

tree::TerminalNode* myParser::Tuple_elementContext::COLON() {
  return getToken(myParser::COLON, 0);
}


size_t myParser::Tuple_elementContext::getRuleIndex() const {
  return myParser::RuleTuple_element;
}

void myParser::Tuple_elementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTuple_element(this);
}

void myParser::Tuple_elementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTuple_element(this);
}

myParser::Tuple_elementContext* myParser::tuple_element() {
  Tuple_elementContext *_localctx = _tracker.createInstance<Tuple_elementContext>(_ctx, getState());
  enterRule(_localctx, 472, myParser::RuleTuple_element);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2349);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 282, _ctx)) {
    case 1: {
      setState(2346);
      identifier();
      setState(2347);
      match(myParser::COLON);
      break;
    }

    default:
      break;
    }
    setState(2351);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Wildcard_expressionContext ------------------------------------------------------------------

myParser::Wildcard_expressionContext::Wildcard_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Wildcard_expressionContext::UNDERSCORE() {
  return getToken(myParser::UNDERSCORE, 0);
}


size_t myParser::Wildcard_expressionContext::getRuleIndex() const {
  return myParser::RuleWildcard_expression;
}

void myParser::Wildcard_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWildcard_expression(this);
}

void myParser::Wildcard_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWildcard_expression(this);
}

myParser::Wildcard_expressionContext* myParser::wildcard_expression() {
  Wildcard_expressionContext *_localctx = _tracker.createInstance<Wildcard_expressionContext>(_ctx, getState());
  enterRule(_localctx, 474, myParser::RuleWildcard_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2353);
    match(myParser::UNDERSCORE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Key_path_expressionContext ------------------------------------------------------------------

myParser::Key_path_expressionContext::Key_path_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Key_path_expressionContext::BACKSLASH() {
  return getToken(myParser::BACKSLASH, 0);
}

tree::TerminalNode* myParser::Key_path_expressionContext::DOT() {
  return getToken(myParser::DOT, 0);
}

myParser::Key_path_componentsContext* myParser::Key_path_expressionContext::key_path_components() {
  return getRuleContext<myParser::Key_path_componentsContext>(0);
}

myParser::TypeContext* myParser::Key_path_expressionContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}


size_t myParser::Key_path_expressionContext::getRuleIndex() const {
  return myParser::RuleKey_path_expression;
}

void myParser::Key_path_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKey_path_expression(this);
}

void myParser::Key_path_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKey_path_expression(this);
}

myParser::Key_path_expressionContext* myParser::key_path_expression() {
  Key_path_expressionContext *_localctx = _tracker.createInstance<Key_path_expressionContext>(_ctx, getState());
  enterRule(_localctx, 476, myParser::RuleKey_path_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2355);
    match(myParser::BACKSLASH);
    setState(2357);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -576599273992204954) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3940649437527807) != 0) || ((((_la - 135) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 135)) & 1074004071) != 0)) {
      setState(2356);
      type(0);
    }
    setState(2359);
    match(myParser::DOT);
    setState(2360);
    key_path_components();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Key_path_componentsContext ------------------------------------------------------------------

myParser::Key_path_componentsContext::Key_path_componentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Key_path_componentContext *> myParser::Key_path_componentsContext::key_path_component() {
  return getRuleContexts<myParser::Key_path_componentContext>();
}

myParser::Key_path_componentContext* myParser::Key_path_componentsContext::key_path_component(size_t i) {
  return getRuleContext<myParser::Key_path_componentContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Key_path_componentsContext::DOT() {
  return getTokens(myParser::DOT);
}

tree::TerminalNode* myParser::Key_path_componentsContext::DOT(size_t i) {
  return getToken(myParser::DOT, i);
}


size_t myParser::Key_path_componentsContext::getRuleIndex() const {
  return myParser::RuleKey_path_components;
}

void myParser::Key_path_componentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKey_path_components(this);
}

void myParser::Key_path_componentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKey_path_components(this);
}

myParser::Key_path_componentsContext* myParser::key_path_components() {
  Key_path_componentsContext *_localctx = _tracker.createInstance<Key_path_componentsContext>(_ctx, getState());
  enterRule(_localctx, 478, myParser::RuleKey_path_components);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2362);
    key_path_component();
    setState(2367);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 284, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2363);
        match(myParser::DOT);
        setState(2364);
        key_path_component(); 
      }
      setState(2369);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 284, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Key_path_componentContext ------------------------------------------------------------------

myParser::Key_path_componentContext::Key_path_componentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::Key_path_componentContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::Key_path_postfixesContext* myParser::Key_path_componentContext::key_path_postfixes() {
  return getRuleContext<myParser::Key_path_postfixesContext>(0);
}


size_t myParser::Key_path_componentContext::getRuleIndex() const {
  return myParser::RuleKey_path_component;
}

void myParser::Key_path_componentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKey_path_component(this);
}

void myParser::Key_path_componentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKey_path_component(this);
}

myParser::Key_path_componentContext* myParser::key_path_component() {
  Key_path_componentContext *_localctx = _tracker.createInstance<Key_path_componentContext>(_ctx, getState());
  enterRule(_localctx, 480, myParser::RuleKey_path_component);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2375);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 286, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2370);
      identifier();
      setState(2372);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 285, _ctx)) {
      case 1: {
        setState(2371);
        key_path_postfixes();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2374);
      key_path_postfixes();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Key_path_postfixesContext ------------------------------------------------------------------

myParser::Key_path_postfixesContext::Key_path_postfixesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Key_path_postfixContext *> myParser::Key_path_postfixesContext::key_path_postfix() {
  return getRuleContexts<myParser::Key_path_postfixContext>();
}

myParser::Key_path_postfixContext* myParser::Key_path_postfixesContext::key_path_postfix(size_t i) {
  return getRuleContext<myParser::Key_path_postfixContext>(i);
}


size_t myParser::Key_path_postfixesContext::getRuleIndex() const {
  return myParser::RuleKey_path_postfixes;
}

void myParser::Key_path_postfixesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKey_path_postfixes(this);
}

void myParser::Key_path_postfixesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKey_path_postfixes(this);
}

myParser::Key_path_postfixesContext* myParser::key_path_postfixes() {
  Key_path_postfixesContext *_localctx = _tracker.createInstance<Key_path_postfixesContext>(_ctx, getState());
  enterRule(_localctx, 482, myParser::RuleKey_path_postfixes);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2378); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(2377);
              key_path_postfix();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(2380); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 287, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Key_path_postfixContext ------------------------------------------------------------------

myParser::Key_path_postfixContext::Key_path_postfixContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Key_path_postfixContext::QUESTION() {
  return getToken(myParser::QUESTION, 0);
}

tree::TerminalNode* myParser::Key_path_postfixContext::BANG() {
  return getToken(myParser::BANG, 0);
}

tree::TerminalNode* myParser::Key_path_postfixContext::SELF() {
  return getToken(myParser::SELF, 0);
}

tree::TerminalNode* myParser::Key_path_postfixContext::LBRACK() {
  return getToken(myParser::LBRACK, 0);
}

myParser::Function_call_argument_listContext* myParser::Key_path_postfixContext::function_call_argument_list() {
  return getRuleContext<myParser::Function_call_argument_listContext>(0);
}

tree::TerminalNode* myParser::Key_path_postfixContext::RBRACK() {
  return getToken(myParser::RBRACK, 0);
}


size_t myParser::Key_path_postfixContext::getRuleIndex() const {
  return myParser::RuleKey_path_postfix;
}

void myParser::Key_path_postfixContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKey_path_postfix(this);
}

void myParser::Key_path_postfixContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKey_path_postfix(this);
}

myParser::Key_path_postfixContext* myParser::key_path_postfix() {
  Key_path_postfixContext *_localctx = _tracker.createInstance<Key_path_postfixContext>(_ctx, getState());
  enterRule(_localctx, 484, myParser::RuleKey_path_postfix);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2389);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::QUESTION: {
        enterOuterAlt(_localctx, 1);
        setState(2382);
        match(myParser::QUESTION);
        break;
      }

      case myParser::BANG: {
        enterOuterAlt(_localctx, 2);
        setState(2383);
        match(myParser::BANG);
        break;
      }

      case myParser::SELF: {
        enterOuterAlt(_localctx, 3);
        setState(2384);
        match(myParser::SELF);
        break;
      }

      case myParser::LBRACK: {
        enterOuterAlt(_localctx, 4);
        setState(2385);
        match(myParser::LBRACK);
        setState(2386);
        function_call_argument_list();
        setState(2387);
        match(myParser::RBRACK);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Selector_expressionContext ------------------------------------------------------------------

myParser::Selector_expressionContext::Selector_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Selector_expressionContext::HASH_SELECTOR() {
  return getToken(myParser::HASH_SELECTOR, 0);
}

tree::TerminalNode* myParser::Selector_expressionContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::ExpressionContext* myParser::Selector_expressionContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

tree::TerminalNode* myParser::Selector_expressionContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

tree::TerminalNode* myParser::Selector_expressionContext::COLON() {
  return getToken(myParser::COLON, 0);
}

tree::TerminalNode* myParser::Selector_expressionContext::GETTER() {
  return getToken(myParser::GETTER, 0);
}

tree::TerminalNode* myParser::Selector_expressionContext::SETTER() {
  return getToken(myParser::SETTER, 0);
}


size_t myParser::Selector_expressionContext::getRuleIndex() const {
  return myParser::RuleSelector_expression;
}

void myParser::Selector_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelector_expression(this);
}

void myParser::Selector_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelector_expression(this);
}

myParser::Selector_expressionContext* myParser::selector_expression() {
  Selector_expressionContext *_localctx = _tracker.createInstance<Selector_expressionContext>(_ctx, getState());
  enterRule(_localctx, 486, myParser::RuleSelector_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2391);
    match(myParser::HASH_SELECTOR);
    setState(2392);
    match(myParser::LPAREN);
    setState(2395);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 289, _ctx)) {
    case 1: {
      setState(2393);
      _la = _input->LA(1);
      if (!(_la == myParser::GETTER

      || _la == myParser::SETTER)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2394);
      match(myParser::COLON);
      break;
    }

    default:
      break;
    }
    setState(2397);
    expression();
    setState(2398);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Key_path_string_expressionContext ------------------------------------------------------------------

myParser::Key_path_string_expressionContext::Key_path_string_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Key_path_string_expressionContext::HASH_KEYPATH() {
  return getToken(myParser::HASH_KEYPATH, 0);
}

tree::TerminalNode* myParser::Key_path_string_expressionContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::ExpressionContext* myParser::Key_path_string_expressionContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

tree::TerminalNode* myParser::Key_path_string_expressionContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}


size_t myParser::Key_path_string_expressionContext::getRuleIndex() const {
  return myParser::RuleKey_path_string_expression;
}

void myParser::Key_path_string_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKey_path_string_expression(this);
}

void myParser::Key_path_string_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKey_path_string_expression(this);
}

myParser::Key_path_string_expressionContext* myParser::key_path_string_expression() {
  Key_path_string_expressionContext *_localctx = _tracker.createInstance<Key_path_string_expressionContext>(_ctx, getState());
  enterRule(_localctx, 488, myParser::RuleKey_path_string_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2400);
    match(myParser::HASH_KEYPATH);
    setState(2401);
    match(myParser::LPAREN);
    setState(2402);
    expression();
    setState(2403);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Postfix_expressionContext ------------------------------------------------------------------

myParser::Postfix_expressionContext::Postfix_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Primary_expressionContext* myParser::Postfix_expressionContext::primary_expression() {
  return getRuleContext<myParser::Primary_expressionContext>(0);
}

std::vector<myParser::Function_call_suffixContext *> myParser::Postfix_expressionContext::function_call_suffix() {
  return getRuleContexts<myParser::Function_call_suffixContext>();
}

myParser::Function_call_suffixContext* myParser::Postfix_expressionContext::function_call_suffix(size_t i) {
  return getRuleContext<myParser::Function_call_suffixContext>(i);
}

std::vector<myParser::Initializer_suffixContext *> myParser::Postfix_expressionContext::initializer_suffix() {
  return getRuleContexts<myParser::Initializer_suffixContext>();
}

myParser::Initializer_suffixContext* myParser::Postfix_expressionContext::initializer_suffix(size_t i) {
  return getRuleContext<myParser::Initializer_suffixContext>(i);
}

std::vector<myParser::Explicit_member_suffixContext *> myParser::Postfix_expressionContext::explicit_member_suffix() {
  return getRuleContexts<myParser::Explicit_member_suffixContext>();
}

myParser::Explicit_member_suffixContext* myParser::Postfix_expressionContext::explicit_member_suffix(size_t i) {
  return getRuleContext<myParser::Explicit_member_suffixContext>(i);
}

std::vector<myParser::Postfix_self_suffixContext *> myParser::Postfix_expressionContext::postfix_self_suffix() {
  return getRuleContexts<myParser::Postfix_self_suffixContext>();
}

myParser::Postfix_self_suffixContext* myParser::Postfix_expressionContext::postfix_self_suffix(size_t i) {
  return getRuleContext<myParser::Postfix_self_suffixContext>(i);
}

std::vector<myParser::Subscript_suffixContext *> myParser::Postfix_expressionContext::subscript_suffix() {
  return getRuleContexts<myParser::Subscript_suffixContext>();
}

myParser::Subscript_suffixContext* myParser::Postfix_expressionContext::subscript_suffix(size_t i) {
  return getRuleContext<myParser::Subscript_suffixContext>(i);
}

std::vector<myParser::Forced_value_suffixContext *> myParser::Postfix_expressionContext::forced_value_suffix() {
  return getRuleContexts<myParser::Forced_value_suffixContext>();
}

myParser::Forced_value_suffixContext* myParser::Postfix_expressionContext::forced_value_suffix(size_t i) {
  return getRuleContext<myParser::Forced_value_suffixContext>(i);
}

std::vector<myParser::Optional_chaining_suffixContext *> myParser::Postfix_expressionContext::optional_chaining_suffix() {
  return getRuleContexts<myParser::Optional_chaining_suffixContext>();
}

myParser::Optional_chaining_suffixContext* myParser::Postfix_expressionContext::optional_chaining_suffix(size_t i) {
  return getRuleContext<myParser::Optional_chaining_suffixContext>(i);
}

std::vector<myParser::Postfix_operatorContext *> myParser::Postfix_expressionContext::postfix_operator() {
  return getRuleContexts<myParser::Postfix_operatorContext>();
}

myParser::Postfix_operatorContext* myParser::Postfix_expressionContext::postfix_operator(size_t i) {
  return getRuleContext<myParser::Postfix_operatorContext>(i);
}


size_t myParser::Postfix_expressionContext::getRuleIndex() const {
  return myParser::RulePostfix_expression;
}

void myParser::Postfix_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostfix_expression(this);
}

void myParser::Postfix_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostfix_expression(this);
}

myParser::Postfix_expressionContext* myParser::postfix_expression() {
  Postfix_expressionContext *_localctx = _tracker.createInstance<Postfix_expressionContext>(_ctx, getState());
  enterRule(_localctx, 490, myParser::RulePostfix_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2405);
    primary_expression();
    setState(2415);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 291, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2413);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 290, _ctx)) {
        case 1: {
          setState(2406);
          function_call_suffix();
          break;
        }

        case 2: {
          setState(2407);
          initializer_suffix();
          break;
        }

        case 3: {
          setState(2408);
          explicit_member_suffix();
          break;
        }

        case 4: {
          setState(2409);
          postfix_self_suffix();
          break;
        }

        case 5: {
          setState(2410);
          subscript_suffix();
          break;
        }

        case 6: {
          setState(2411);
          forced_value_suffix();
          break;
        }

        case 7: {
          setState(2412);
          optional_chaining_suffix();
          break;
        }

        default:
          break;
        } 
      }
      setState(2417);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 291, _ctx);
    }
    setState(2421);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 292, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(2418);
        postfix_operator(); 
      }
      setState(2423);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 292, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_call_suffixContext ------------------------------------------------------------------

myParser::Function_call_suffixContext::Function_call_suffixContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Trailing_closuresContext* myParser::Function_call_suffixContext::trailing_closures() {
  return getRuleContext<myParser::Trailing_closuresContext>(0);
}

myParser::Function_call_argument_clauseContext* myParser::Function_call_suffixContext::function_call_argument_clause() {
  return getRuleContext<myParser::Function_call_argument_clauseContext>(0);
}


size_t myParser::Function_call_suffixContext::getRuleIndex() const {
  return myParser::RuleFunction_call_suffix;
}

void myParser::Function_call_suffixContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_call_suffix(this);
}

void myParser::Function_call_suffixContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_call_suffix(this);
}

myParser::Function_call_suffixContext* myParser::function_call_suffix() {
  Function_call_suffixContext *_localctx = _tracker.createInstance<Function_call_suffixContext>(_ctx, getState());
  enterRule(_localctx, 492, myParser::RuleFunction_call_suffix);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2429);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 294, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2425);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::LPAREN) {
        setState(2424);
        function_call_argument_clause();
      }
      setState(2427);
      trailing_closures();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2428);
      function_call_argument_clause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Initializer_suffixContext ------------------------------------------------------------------

myParser::Initializer_suffixContext::Initializer_suffixContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Initializer_suffixContext::DOT() {
  return getToken(myParser::DOT, 0);
}

tree::TerminalNode* myParser::Initializer_suffixContext::INIT() {
  return getToken(myParser::INIT, 0);
}

tree::TerminalNode* myParser::Initializer_suffixContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::Argument_namesContext* myParser::Initializer_suffixContext::argument_names() {
  return getRuleContext<myParser::Argument_namesContext>(0);
}

tree::TerminalNode* myParser::Initializer_suffixContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}


size_t myParser::Initializer_suffixContext::getRuleIndex() const {
  return myParser::RuleInitializer_suffix;
}

void myParser::Initializer_suffixContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitializer_suffix(this);
}

void myParser::Initializer_suffixContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitializer_suffix(this);
}

myParser::Initializer_suffixContext* myParser::initializer_suffix() {
  Initializer_suffixContext *_localctx = _tracker.createInstance<Initializer_suffixContext>(_ctx, getState());
  enterRule(_localctx, 494, myParser::RuleInitializer_suffix);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2431);
    match(myParser::DOT);
    setState(2432);
    match(myParser::INIT);
    setState(2437);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 295, _ctx)) {
    case 1: {
      setState(2433);
      match(myParser::LPAREN);
      setState(2434);
      argument_names();
      setState(2435);
      match(myParser::RPAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Explicit_member_suffixContext ------------------------------------------------------------------

myParser::Explicit_member_suffixContext::Explicit_member_suffixContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Explicit_member_suffixContext::DOT() {
  return getToken(myParser::DOT, 0);
}

tree::TerminalNode* myParser::Explicit_member_suffixContext::Decimal_digits() {
  return getToken(myParser::Decimal_digits, 0);
}

myParser::IdentifierContext* myParser::Explicit_member_suffixContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::Generic_argument_clauseContext* myParser::Explicit_member_suffixContext::generic_argument_clause() {
  return getRuleContext<myParser::Generic_argument_clauseContext>(0);
}

tree::TerminalNode* myParser::Explicit_member_suffixContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::Argument_namesContext* myParser::Explicit_member_suffixContext::argument_names() {
  return getRuleContext<myParser::Argument_namesContext>(0);
}

tree::TerminalNode* myParser::Explicit_member_suffixContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}


size_t myParser::Explicit_member_suffixContext::getRuleIndex() const {
  return myParser::RuleExplicit_member_suffix;
}

void myParser::Explicit_member_suffixContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplicit_member_suffix(this);
}

void myParser::Explicit_member_suffixContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplicit_member_suffix(this);
}

myParser::Explicit_member_suffixContext* myParser::explicit_member_suffix() {
  Explicit_member_suffixContext *_localctx = _tracker.createInstance<Explicit_member_suffixContext>(_ctx, getState());
  enterRule(_localctx, 496, myParser::RuleExplicit_member_suffix);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2439);
    match(myParser::DOT);
    setState(2449);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Decimal_digits: {
        setState(2440);
        match(myParser::Decimal_digits);
        break;
      }

      case myParser::AS:
      case myParser::ALPHA:
      case myParser::CATCH:
      case myParser::CLASS:
      case myParser::DEFAULT:
      case myParser::DO:
      case myParser::GUARD:
      case myParser::FOR:
      case myParser::IN:
      case myParser::INTERNAL:
      case myParser::FINAL:
      case myParser::OPEN:
      case myParser::PRIVATE:
      case myParser::PUBLIC:
      case myParser::WHERE:
      case myParser::WHILE:
      case myParser::PROTOCOL:
      case myParser::GET:
      case myParser::SET:
      case myParser::WILL_SET:
      case myParser::DID_SET:
      case myParser::INDIRECT:
      case myParser::PREFIX:
      case myParser::INFIX:
      case myParser::LEFT:
      case myParser::RIGHT:
      case myParser::NONE:
      case myParser::PRECEDENCE_GROUP:
      case myParser::HIGHER_THAN:
      case myParser::LOWER_THAN:
      case myParser::ASSIGNMENT:
      case myParser::ASSOCIATIVITY:
      case myParser::POSTFIX:
      case myParser::OPERATOR:
      case myParser::OS:
      case myParser::ARCH:
      case myParser::SWIFT:
      case myParser::COMPILER:
      case myParser::CAN_IMPORT:
      case myParser::TARGET_ENVIRONMENT:
      case myParser::CONVENIENCE:
      case myParser::DYNAMIC:
      case myParser::LAZY:
      case myParser::OPTIONAL:
      case myParser::OVERRIDE:
      case myParser::REQUIRED:
      case myParser::WEAK:
      case myParser::UNOWNED:
      case myParser::SAFE:
      case myParser::UNSAFE:
      case myParser::MUTATING:
      case myParser::NONMUTATING:
      case myParser::RED:
      case myParser::BLUE:
      case myParser::GREEN:
      case myParser::RESOURCE_NAME:
      case myParser::SOME:
      case myParser::TYPE:
      case myParser::PRECEDENCE:
      case myParser::SELF:
      case myParser::SELF_BIG:
      case myParser::MAC_OS:
      case myParser::I_OS:
      case myParser::OSX:
      case myParser::WATCH_OS:
      case myParser::TV_OS:
      case myParser::LINUX:
      case myParser::WINDOWS:
      case myParser::I386:
      case myParser::X86_64:
      case myParser::ARM:
      case myParser::ARM64:
      case myParser::SIMULATOR:
      case myParser::MAC_CATALYST:
      case myParser::I_OS_APPLICATION_EXTENSION:
      case myParser::MAC_CATALYST_APPLICATION_EXTENSION:
      case myParser::MAC_OS_APPLICATION_EXTENSION:
      case myParser::FILE:
      case myParser::LINE:
      case myParser::GETTER:
      case myParser::SETTER:
      case myParser::Identifier:
      case myParser::BACKTICK: {
        setState(2441);
        identifier();
        setState(2447);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 296, _ctx)) {
        case 1: {
          setState(2442);
          generic_argument_clause();
          break;
        }

        case 2: {
          setState(2443);
          match(myParser::LPAREN);
          setState(2444);
          argument_names();
          setState(2445);
          match(myParser::RPAREN);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Postfix_self_suffixContext ------------------------------------------------------------------

myParser::Postfix_self_suffixContext::Postfix_self_suffixContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Postfix_self_suffixContext::DOT() {
  return getToken(myParser::DOT, 0);
}

tree::TerminalNode* myParser::Postfix_self_suffixContext::SELF() {
  return getToken(myParser::SELF, 0);
}


size_t myParser::Postfix_self_suffixContext::getRuleIndex() const {
  return myParser::RulePostfix_self_suffix;
}

void myParser::Postfix_self_suffixContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostfix_self_suffix(this);
}

void myParser::Postfix_self_suffixContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostfix_self_suffix(this);
}

myParser::Postfix_self_suffixContext* myParser::postfix_self_suffix() {
  Postfix_self_suffixContext *_localctx = _tracker.createInstance<Postfix_self_suffixContext>(_ctx, getState());
  enterRule(_localctx, 498, myParser::RulePostfix_self_suffix);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2451);
    match(myParser::DOT);
    setState(2452);
    match(myParser::SELF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subscript_suffixContext ------------------------------------------------------------------

myParser::Subscript_suffixContext::Subscript_suffixContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Subscript_suffixContext::LBRACK() {
  return getToken(myParser::LBRACK, 0);
}

myParser::Function_call_argument_listContext* myParser::Subscript_suffixContext::function_call_argument_list() {
  return getRuleContext<myParser::Function_call_argument_listContext>(0);
}

tree::TerminalNode* myParser::Subscript_suffixContext::RBRACK() {
  return getToken(myParser::RBRACK, 0);
}


size_t myParser::Subscript_suffixContext::getRuleIndex() const {
  return myParser::RuleSubscript_suffix;
}

void myParser::Subscript_suffixContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubscript_suffix(this);
}

void myParser::Subscript_suffixContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubscript_suffix(this);
}

myParser::Subscript_suffixContext* myParser::subscript_suffix() {
  Subscript_suffixContext *_localctx = _tracker.createInstance<Subscript_suffixContext>(_ctx, getState());
  enterRule(_localctx, 500, myParser::RuleSubscript_suffix);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2454);
    match(myParser::LBRACK);
    setState(2455);
    function_call_argument_list();
    setState(2456);
    match(myParser::RBRACK);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Forced_value_suffixContext ------------------------------------------------------------------

myParser::Forced_value_suffixContext::Forced_value_suffixContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Forced_value_suffixContext::BANG() {
  return getToken(myParser::BANG, 0);
}


size_t myParser::Forced_value_suffixContext::getRuleIndex() const {
  return myParser::RuleForced_value_suffix;
}

void myParser::Forced_value_suffixContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForced_value_suffix(this);
}

void myParser::Forced_value_suffixContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForced_value_suffix(this);
}

myParser::Forced_value_suffixContext* myParser::forced_value_suffix() {
  Forced_value_suffixContext *_localctx = _tracker.createInstance<Forced_value_suffixContext>(_ctx, getState());
  enterRule(_localctx, 502, myParser::RuleForced_value_suffix);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2458);

    if (!(!SwiftSupport.isBinaryOp(_input))) throw FailedPredicateException(this, "!SwiftSupport.isBinaryOp(_input)");
    setState(2459);
    match(myParser::BANG);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Optional_chaining_suffixContext ------------------------------------------------------------------

myParser::Optional_chaining_suffixContext::Optional_chaining_suffixContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Optional_chaining_suffixContext::QUESTION() {
  return getToken(myParser::QUESTION, 0);
}


size_t myParser::Optional_chaining_suffixContext::getRuleIndex() const {
  return myParser::RuleOptional_chaining_suffix;
}

void myParser::Optional_chaining_suffixContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptional_chaining_suffix(this);
}

void myParser::Optional_chaining_suffixContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptional_chaining_suffix(this);
}

myParser::Optional_chaining_suffixContext* myParser::optional_chaining_suffix() {
  Optional_chaining_suffixContext *_localctx = _tracker.createInstance<Optional_chaining_suffixContext>(_ctx, getState());
  enterRule(_localctx, 504, myParser::RuleOptional_chaining_suffix);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2461);

    if (!(!SwiftSupport.isBinaryOp(_input))) throw FailedPredicateException(this, "!SwiftSupport.isBinaryOp(_input)");
    setState(2462);
    match(myParser::QUESTION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_call_argument_clauseContext ------------------------------------------------------------------

myParser::Function_call_argument_clauseContext::Function_call_argument_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Function_call_argument_clauseContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::Function_call_argument_clauseContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

myParser::Function_call_argument_listContext* myParser::Function_call_argument_clauseContext::function_call_argument_list() {
  return getRuleContext<myParser::Function_call_argument_listContext>(0);
}


size_t myParser::Function_call_argument_clauseContext::getRuleIndex() const {
  return myParser::RuleFunction_call_argument_clause;
}

void myParser::Function_call_argument_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_call_argument_clause(this);
}

void myParser::Function_call_argument_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_call_argument_clause(this);
}

myParser::Function_call_argument_clauseContext* myParser::function_call_argument_clause() {
  Function_call_argument_clauseContext *_localctx = _tracker.createInstance<Function_call_argument_clauseContext>(_ctx, getState());
  enterRule(_localctx, 506, myParser::RuleFunction_call_argument_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2464);
    match(myParser::LPAREN);
    setState(2466);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 298, _ctx)) {
    case 1: {
      setState(2465);
      function_call_argument_list();
      break;
    }

    default:
      break;
    }
    setState(2468);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_call_argument_listContext ------------------------------------------------------------------

myParser::Function_call_argument_listContext::Function_call_argument_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Function_call_argumentContext *> myParser::Function_call_argument_listContext::function_call_argument() {
  return getRuleContexts<myParser::Function_call_argumentContext>();
}

myParser::Function_call_argumentContext* myParser::Function_call_argument_listContext::function_call_argument(size_t i) {
  return getRuleContext<myParser::Function_call_argumentContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Function_call_argument_listContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Function_call_argument_listContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Function_call_argument_listContext::getRuleIndex() const {
  return myParser::RuleFunction_call_argument_list;
}

void myParser::Function_call_argument_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_call_argument_list(this);
}

void myParser::Function_call_argument_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_call_argument_list(this);
}

myParser::Function_call_argument_listContext* myParser::function_call_argument_list() {
  Function_call_argument_listContext *_localctx = _tracker.createInstance<Function_call_argument_listContext>(_ctx, getState());
  enterRule(_localctx, 508, myParser::RuleFunction_call_argument_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2470);
    function_call_argument();
    setState(2475);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(2471);
      match(myParser::COMMA);
      setState(2472);
      function_call_argument();
      setState(2477);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_call_argumentContext ------------------------------------------------------------------

myParser::Function_call_argumentContext::Function_call_argumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::Function_call_argumentContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::ExpressionContext* myParser::Function_call_argumentContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

myParser::OperatorContext* myParser::Function_call_argumentContext::operator_() {
  return getRuleContext<myParser::OperatorContext>(0);
}

myParser::Argument_nameContext* myParser::Function_call_argumentContext::argument_name() {
  return getRuleContext<myParser::Argument_nameContext>(0);
}


size_t myParser::Function_call_argumentContext::getRuleIndex() const {
  return myParser::RuleFunction_call_argument;
}

void myParser::Function_call_argumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_call_argument(this);
}

void myParser::Function_call_argumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_call_argument(this);
}

myParser::Function_call_argumentContext* myParser::function_call_argument() {
  Function_call_argumentContext *_localctx = _tracker.createInstance<Function_call_argumentContext>(_ctx, getState());
  enterRule(_localctx, 510, myParser::RuleFunction_call_argument);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2479);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 300, _ctx)) {
    case 1: {
      setState(2478);
      argument_name();
      break;
    }

    default:
      break;
    }
    setState(2484);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 301, _ctx)) {
    case 1: {
      setState(2481);
      identifier();
      break;
    }

    case 2: {
      setState(2482);
      expression();
      break;
    }

    case 3: {
      setState(2483);
      operator_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trailing_closuresContext ------------------------------------------------------------------

myParser::Trailing_closuresContext::Trailing_closuresContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Closure_expressionContext* myParser::Trailing_closuresContext::closure_expression() {
  return getRuleContext<myParser::Closure_expressionContext>(0);
}

myParser::Labeled_trailing_closuresContext* myParser::Trailing_closuresContext::labeled_trailing_closures() {
  return getRuleContext<myParser::Labeled_trailing_closuresContext>(0);
}


size_t myParser::Trailing_closuresContext::getRuleIndex() const {
  return myParser::RuleTrailing_closures;
}

void myParser::Trailing_closuresContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrailing_closures(this);
}

void myParser::Trailing_closuresContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrailing_closures(this);
}

myParser::Trailing_closuresContext* myParser::trailing_closures() {
  Trailing_closuresContext *_localctx = _tracker.createInstance<Trailing_closuresContext>(_ctx, getState());
  enterRule(_localctx, 512, myParser::RuleTrailing_closures);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2486);
    closure_expression();
    setState(2488);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 302, _ctx)) {
    case 1: {
      setState(2487);
      labeled_trailing_closures();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Labeled_trailing_closuresContext ------------------------------------------------------------------

myParser::Labeled_trailing_closuresContext::Labeled_trailing_closuresContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Labeled_trailing_closureContext *> myParser::Labeled_trailing_closuresContext::labeled_trailing_closure() {
  return getRuleContexts<myParser::Labeled_trailing_closureContext>();
}

myParser::Labeled_trailing_closureContext* myParser::Labeled_trailing_closuresContext::labeled_trailing_closure(size_t i) {
  return getRuleContext<myParser::Labeled_trailing_closureContext>(i);
}


size_t myParser::Labeled_trailing_closuresContext::getRuleIndex() const {
  return myParser::RuleLabeled_trailing_closures;
}

void myParser::Labeled_trailing_closuresContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabeled_trailing_closures(this);
}

void myParser::Labeled_trailing_closuresContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabeled_trailing_closures(this);
}

myParser::Labeled_trailing_closuresContext* myParser::labeled_trailing_closures() {
  Labeled_trailing_closuresContext *_localctx = _tracker.createInstance<Labeled_trailing_closuresContext>(_ctx, getState());
  enterRule(_localctx, 514, myParser::RuleLabeled_trailing_closures);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2491); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(2490);
              labeled_trailing_closure();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(2493); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 303, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Labeled_trailing_closureContext ------------------------------------------------------------------

myParser::Labeled_trailing_closureContext::Labeled_trailing_closureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::Labeled_trailing_closureContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

tree::TerminalNode* myParser::Labeled_trailing_closureContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::Closure_expressionContext* myParser::Labeled_trailing_closureContext::closure_expression() {
  return getRuleContext<myParser::Closure_expressionContext>(0);
}


size_t myParser::Labeled_trailing_closureContext::getRuleIndex() const {
  return myParser::RuleLabeled_trailing_closure;
}

void myParser::Labeled_trailing_closureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabeled_trailing_closure(this);
}

void myParser::Labeled_trailing_closureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabeled_trailing_closure(this);
}

myParser::Labeled_trailing_closureContext* myParser::labeled_trailing_closure() {
  Labeled_trailing_closureContext *_localctx = _tracker.createInstance<Labeled_trailing_closureContext>(_ctx, getState());
  enterRule(_localctx, 516, myParser::RuleLabeled_trailing_closure);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2495);
    identifier();
    setState(2496);
    match(myParser::COLON);
    setState(2497);
    closure_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Argument_namesContext ------------------------------------------------------------------

myParser::Argument_namesContext::Argument_namesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Argument_nameContext *> myParser::Argument_namesContext::argument_name() {
  return getRuleContexts<myParser::Argument_nameContext>();
}

myParser::Argument_nameContext* myParser::Argument_namesContext::argument_name(size_t i) {
  return getRuleContext<myParser::Argument_nameContext>(i);
}


size_t myParser::Argument_namesContext::getRuleIndex() const {
  return myParser::RuleArgument_names;
}

void myParser::Argument_namesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgument_names(this);
}

void myParser::Argument_namesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgument_names(this);
}

myParser::Argument_namesContext* myParser::argument_names() {
  Argument_namesContext *_localctx = _tracker.createInstance<Argument_namesContext>(_ctx, getState());
  enterRule(_localctx, 518, myParser::RuleArgument_names);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2500); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2499);
      argument_name();
      setState(2502); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -576599273992204954) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3940649437003519) != 0) || ((((_la - 135) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 135)) & 1073741831) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Argument_nameContext ------------------------------------------------------------------

myParser::Argument_nameContext::Argument_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::Argument_nameContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

tree::TerminalNode* myParser::Argument_nameContext::COLON() {
  return getToken(myParser::COLON, 0);
}


size_t myParser::Argument_nameContext::getRuleIndex() const {
  return myParser::RuleArgument_name;
}

void myParser::Argument_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgument_name(this);
}

void myParser::Argument_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgument_name(this);
}

myParser::Argument_nameContext* myParser::argument_name() {
  Argument_nameContext *_localctx = _tracker.createInstance<Argument_nameContext>(_ctx, getState());
  enterRule(_localctx, 520, myParser::RuleArgument_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2504);
    identifier();
    setState(2505);
    match(myParser::COLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeContext ------------------------------------------------------------------

myParser::TypeContext::TypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Function_typeContext* myParser::TypeContext::function_type() {
  return getRuleContext<myParser::Function_typeContext>(0);
}

myParser::Array_typeContext* myParser::TypeContext::array_type() {
  return getRuleContext<myParser::Array_typeContext>(0);
}

myParser::Dictionary_typeContext* myParser::TypeContext::dictionary_type() {
  return getRuleContext<myParser::Dictionary_typeContext>(0);
}

myParser::Protocol_composition_typeContext* myParser::TypeContext::protocol_composition_type() {
  return getRuleContext<myParser::Protocol_composition_typeContext>(0);
}

myParser::Type_identifierContext* myParser::TypeContext::type_identifier() {
  return getRuleContext<myParser::Type_identifierContext>(0);
}

myParser::Tuple_typeContext* myParser::TypeContext::tuple_type() {
  return getRuleContext<myParser::Tuple_typeContext>(0);
}

myParser::Opaque_typeContext* myParser::TypeContext::opaque_type() {
  return getRuleContext<myParser::Opaque_typeContext>(0);
}

myParser::Any_typeContext* myParser::TypeContext::any_type() {
  return getRuleContext<myParser::Any_typeContext>(0);
}

myParser::Self_typeContext* myParser::TypeContext::self_type() {
  return getRuleContext<myParser::Self_typeContext>(0);
}

tree::TerminalNode* myParser::TypeContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::TypeContext* myParser::TypeContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

tree::TerminalNode* myParser::TypeContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

tree::TerminalNode* myParser::TypeContext::QUESTION() {
  return getToken(myParser::QUESTION, 0);
}

tree::TerminalNode* myParser::TypeContext::BANG() {
  return getToken(myParser::BANG, 0);
}

tree::TerminalNode* myParser::TypeContext::DOT() {
  return getToken(myParser::DOT, 0);
}

tree::TerminalNode* myParser::TypeContext::TYPE() {
  return getToken(myParser::TYPE, 0);
}

tree::TerminalNode* myParser::TypeContext::PROTOCOL() {
  return getToken(myParser::PROTOCOL, 0);
}


size_t myParser::TypeContext::getRuleIndex() const {
  return myParser::RuleType;
}

void myParser::TypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType(this);
}

void myParser::TypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType(this);
}


myParser::TypeContext* myParser::type() {
   return type(0);
}

myParser::TypeContext* myParser::type(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  myParser::TypeContext *_localctx = _tracker.createInstance<TypeContext>(_ctx, parentState);
  myParser::TypeContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 522;
  enterRecursionRule(_localctx, 522, myParser::RuleType, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2521);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 305, _ctx)) {
    case 1: {
      setState(2508);
      function_type();
      break;
    }

    case 2: {
      setState(2509);
      array_type();
      break;
    }

    case 3: {
      setState(2510);
      dictionary_type();
      break;
    }

    case 4: {
      setState(2511);
      protocol_composition_type();
      break;
    }

    case 5: {
      setState(2512);
      type_identifier();
      break;
    }

    case 6: {
      setState(2513);
      tuple_type();
      break;
    }

    case 7: {
      setState(2514);
      opaque_type();
      break;
    }

    case 8: {
      setState(2515);
      any_type();
      break;
    }

    case 9: {
      setState(2516);
      self_type();
      break;
    }

    case 10: {
      setState(2517);
      match(myParser::LPAREN);
      setState(2518);
      type(0);
      setState(2519);
      match(myParser::RPAREN);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(2536);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 307, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<TypeContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleType);
        setState(2523);

        if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
        setState(2532);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 306, _ctx)) {
        case 1: {
          setState(2524);

          if (!(!SwiftSupport.isBinaryOp(_input))) throw FailedPredicateException(this, "!SwiftSupport.isBinaryOp(_input)");
          setState(2525);
          match(myParser::QUESTION);
          break;
        }

        case 2: {
          setState(2526);

          if (!(!SwiftSupport.isBinaryOp(_input))) throw FailedPredicateException(this, "!SwiftSupport.isBinaryOp(_input)");
          setState(2527);
          match(myParser::BANG);
          break;
        }

        case 3: {
          setState(2528);
          match(myParser::DOT);
          setState(2529);
          match(myParser::TYPE);
          break;
        }

        case 4: {
          setState(2530);
          match(myParser::DOT);
          setState(2531);
          match(myParser::PROTOCOL);
          break;
        }

        default:
          break;
        } 
      }
      setState(2538);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 307, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Type_annotationContext ------------------------------------------------------------------

myParser::Type_annotationContext::Type_annotationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Type_annotationContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::TypeContext* myParser::Type_annotationContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

myParser::AttributesContext* myParser::Type_annotationContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

tree::TerminalNode* myParser::Type_annotationContext::INOUT() {
  return getToken(myParser::INOUT, 0);
}


size_t myParser::Type_annotationContext::getRuleIndex() const {
  return myParser::RuleType_annotation;
}

void myParser::Type_annotationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_annotation(this);
}

void myParser::Type_annotationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_annotation(this);
}

myParser::Type_annotationContext* myParser::type_annotation() {
  Type_annotationContext *_localctx = _tracker.createInstance<Type_annotationContext>(_ctx, getState());
  enterRule(_localctx, 524, myParser::RuleType_annotation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2539);
    match(myParser::COLON);
    setState(2541);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 308, _ctx)) {
    case 1: {
      setState(2540);
      attributes();
      break;
    }

    default:
      break;
    }
    setState(2544);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::INOUT) {
      setState(2543);
      match(myParser::INOUT);
    }
    setState(2546);
    type(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_identifierContext ------------------------------------------------------------------

myParser::Type_identifierContext::Type_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Type_nameContext* myParser::Type_identifierContext::type_name() {
  return getRuleContext<myParser::Type_nameContext>(0);
}

myParser::Generic_argument_clauseContext* myParser::Type_identifierContext::generic_argument_clause() {
  return getRuleContext<myParser::Generic_argument_clauseContext>(0);
}

tree::TerminalNode* myParser::Type_identifierContext::DOT() {
  return getToken(myParser::DOT, 0);
}

myParser::Type_identifierContext* myParser::Type_identifierContext::type_identifier() {
  return getRuleContext<myParser::Type_identifierContext>(0);
}


size_t myParser::Type_identifierContext::getRuleIndex() const {
  return myParser::RuleType_identifier;
}

void myParser::Type_identifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_identifier(this);
}

void myParser::Type_identifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_identifier(this);
}

myParser::Type_identifierContext* myParser::type_identifier() {
  Type_identifierContext *_localctx = _tracker.createInstance<Type_identifierContext>(_ctx, getState());
  enterRule(_localctx, 526, myParser::RuleType_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2548);
    type_name();
    setState(2550);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 310, _ctx)) {
    case 1: {
      setState(2549);
      generic_argument_clause();
      break;
    }

    default:
      break;
    }
    setState(2554);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 311, _ctx)) {
    case 1: {
      setState(2552);
      match(myParser::DOT);
      setState(2553);
      type_identifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_nameContext ------------------------------------------------------------------

myParser::Type_nameContext::Type_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::Type_nameContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}


size_t myParser::Type_nameContext::getRuleIndex() const {
  return myParser::RuleType_name;
}

void myParser::Type_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_name(this);
}

void myParser::Type_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_name(this);
}

myParser::Type_nameContext* myParser::type_name() {
  Type_nameContext *_localctx = _tracker.createInstance<Type_nameContext>(_ctx, getState());
  enterRule(_localctx, 528, myParser::RuleType_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2556);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tuple_typeContext ------------------------------------------------------------------

myParser::Tuple_typeContext::Tuple_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Tuple_typeContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::Tuple_typeContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

myParser::Tuple_type_element_listContext* myParser::Tuple_typeContext::tuple_type_element_list() {
  return getRuleContext<myParser::Tuple_type_element_listContext>(0);
}


size_t myParser::Tuple_typeContext::getRuleIndex() const {
  return myParser::RuleTuple_type;
}

void myParser::Tuple_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTuple_type(this);
}

void myParser::Tuple_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTuple_type(this);
}

myParser::Tuple_typeContext* myParser::tuple_type() {
  Tuple_typeContext *_localctx = _tracker.createInstance<Tuple_typeContext>(_ctx, getState());
  enterRule(_localctx, 530, myParser::RuleTuple_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2558);
    match(myParser::LPAREN);
    setState(2560);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -576599273992204954) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3940649437527807) != 0) || ((((_la - 135) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 135)) & 1074004071) != 0)) {
      setState(2559);
      tuple_type_element_list();
    }
    setState(2562);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tuple_type_element_listContext ------------------------------------------------------------------

myParser::Tuple_type_element_listContext::Tuple_type_element_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Tuple_type_elementContext *> myParser::Tuple_type_element_listContext::tuple_type_element() {
  return getRuleContexts<myParser::Tuple_type_elementContext>();
}

myParser::Tuple_type_elementContext* myParser::Tuple_type_element_listContext::tuple_type_element(size_t i) {
  return getRuleContext<myParser::Tuple_type_elementContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Tuple_type_element_listContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Tuple_type_element_listContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Tuple_type_element_listContext::getRuleIndex() const {
  return myParser::RuleTuple_type_element_list;
}

void myParser::Tuple_type_element_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTuple_type_element_list(this);
}

void myParser::Tuple_type_element_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTuple_type_element_list(this);
}

myParser::Tuple_type_element_listContext* myParser::tuple_type_element_list() {
  Tuple_type_element_listContext *_localctx = _tracker.createInstance<Tuple_type_element_listContext>(_ctx, getState());
  enterRule(_localctx, 532, myParser::RuleTuple_type_element_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2564);
    tuple_type_element();
    setState(2569);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(2565);
      match(myParser::COMMA);
      setState(2566);
      tuple_type_element();
      setState(2571);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tuple_type_elementContext ------------------------------------------------------------------

myParser::Tuple_type_elementContext::Tuple_type_elementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Element_nameContext* myParser::Tuple_type_elementContext::element_name() {
  return getRuleContext<myParser::Element_nameContext>(0);
}

myParser::Type_annotationContext* myParser::Tuple_type_elementContext::type_annotation() {
  return getRuleContext<myParser::Type_annotationContext>(0);
}

myParser::TypeContext* myParser::Tuple_type_elementContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

tree::TerminalNode* myParser::Tuple_type_elementContext::EQUAL() {
  return getToken(myParser::EQUAL, 0);
}

myParser::ExpressionContext* myParser::Tuple_type_elementContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}


size_t myParser::Tuple_type_elementContext::getRuleIndex() const {
  return myParser::RuleTuple_type_element;
}

void myParser::Tuple_type_elementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTuple_type_element(this);
}

void myParser::Tuple_type_elementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTuple_type_element(this);
}

myParser::Tuple_type_elementContext* myParser::tuple_type_element() {
  Tuple_type_elementContext *_localctx = _tracker.createInstance<Tuple_type_elementContext>(_ctx, getState());
  enterRule(_localctx, 534, myParser::RuleTuple_type_element);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2576);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 314, _ctx)) {
    case 1: {
      setState(2572);
      element_name();
      setState(2573);
      type_annotation();
      break;
    }

    case 2: {
      setState(2575);
      type(0);
      break;
    }

    default:
      break;
    }
    setState(2580);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::EQUAL) {
      setState(2578);
      match(myParser::EQUAL);
      setState(2579);
      expression();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Element_nameContext ------------------------------------------------------------------

myParser::Element_nameContext::Element_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::IdentifierContext *> myParser::Element_nameContext::identifier() {
  return getRuleContexts<myParser::IdentifierContext>();
}

myParser::IdentifierContext* myParser::Element_nameContext::identifier(size_t i) {
  return getRuleContext<myParser::IdentifierContext>(i);
}


size_t myParser::Element_nameContext::getRuleIndex() const {
  return myParser::RuleElement_name;
}

void myParser::Element_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElement_name(this);
}

void myParser::Element_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElement_name(this);
}

myParser::Element_nameContext* myParser::element_name() {
  Element_nameContext *_localctx = _tracker.createInstance<Element_nameContext>(_ctx, getState());
  enterRule(_localctx, 536, myParser::RuleElement_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2583); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2582);
      identifier();
      setState(2585); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -576599273992204954) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3940649437003519) != 0) || ((((_la - 135) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 135)) & 1073741831) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_typeContext ------------------------------------------------------------------

myParser::Function_typeContext::Function_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Function_type_argument_clauseContext* myParser::Function_typeContext::function_type_argument_clause() {
  return getRuleContext<myParser::Function_type_argument_clauseContext>(0);
}

myParser::Arrow_operatorContext* myParser::Function_typeContext::arrow_operator() {
  return getRuleContext<myParser::Arrow_operatorContext>(0);
}

myParser::TypeContext* myParser::Function_typeContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

myParser::AttributesContext* myParser::Function_typeContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

tree::TerminalNode* myParser::Function_typeContext::THROWS() {
  return getToken(myParser::THROWS, 0);
}


size_t myParser::Function_typeContext::getRuleIndex() const {
  return myParser::RuleFunction_type;
}

void myParser::Function_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_type(this);
}

void myParser::Function_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_type(this);
}

myParser::Function_typeContext* myParser::function_type() {
  Function_typeContext *_localctx = _tracker.createInstance<Function_typeContext>(_ctx, getState());
  enterRule(_localctx, 538, myParser::RuleFunction_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2588);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT) {
      setState(2587);
      attributes();
    }
    setState(2590);
    function_type_argument_clause();
    setState(2592);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 318, _ctx)) {
    case 1: {
      setState(2591);
      match(myParser::THROWS);
      break;
    }

    default:
      break;
    }
    setState(2594);
    arrow_operator();
    setState(2595);
    type(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_type_argument_clauseContext ------------------------------------------------------------------

myParser::Function_type_argument_clauseContext::Function_type_argument_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Function_type_argument_clauseContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::Function_type_argument_clauseContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

myParser::Function_type_argument_listContext* myParser::Function_type_argument_clauseContext::function_type_argument_list() {
  return getRuleContext<myParser::Function_type_argument_listContext>(0);
}

myParser::Range_operatorContext* myParser::Function_type_argument_clauseContext::range_operator() {
  return getRuleContext<myParser::Range_operatorContext>(0);
}


size_t myParser::Function_type_argument_clauseContext::getRuleIndex() const {
  return myParser::RuleFunction_type_argument_clause;
}

void myParser::Function_type_argument_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_type_argument_clause(this);
}

void myParser::Function_type_argument_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_type_argument_clause(this);
}

myParser::Function_type_argument_clauseContext* myParser::function_type_argument_clause() {
  Function_type_argument_clauseContext *_localctx = _tracker.createInstance<Function_type_argument_clauseContext>(_ctx, getState());
  enterRule(_localctx, 540, myParser::RuleFunction_type_argument_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2597);
    match(myParser::LPAREN);
    setState(2602);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -576599273992204954) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3940649571745535) != 0) || ((((_la - 135) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 135)) & 1074004071) != 0)) {
      setState(2598);
      function_type_argument_list();
      setState(2600);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 319, _ctx)) {
      case 1: {
        setState(2599);
        range_operator();
        break;
      }

      default:
        break;
      }
    }
    setState(2604);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_type_argument_listContext ------------------------------------------------------------------

myParser::Function_type_argument_listContext::Function_type_argument_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Function_type_argumentContext *> myParser::Function_type_argument_listContext::function_type_argument() {
  return getRuleContexts<myParser::Function_type_argumentContext>();
}

myParser::Function_type_argumentContext* myParser::Function_type_argument_listContext::function_type_argument(size_t i) {
  return getRuleContext<myParser::Function_type_argumentContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Function_type_argument_listContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Function_type_argument_listContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Function_type_argument_listContext::getRuleIndex() const {
  return myParser::RuleFunction_type_argument_list;
}

void myParser::Function_type_argument_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_type_argument_list(this);
}

void myParser::Function_type_argument_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_type_argument_list(this);
}

myParser::Function_type_argument_listContext* myParser::function_type_argument_list() {
  Function_type_argument_listContext *_localctx = _tracker.createInstance<Function_type_argument_listContext>(_ctx, getState());
  enterRule(_localctx, 542, myParser::RuleFunction_type_argument_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2606);
    function_type_argument();
    setState(2611);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 321, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2607);
        match(myParser::COMMA);
        setState(2608);
        function_type_argument(); 
      }
      setState(2613);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 321, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_type_argumentContext ------------------------------------------------------------------

myParser::Function_type_argumentContext::Function_type_argumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::TypeContext* myParser::Function_type_argumentContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

myParser::AttributesContext* myParser::Function_type_argumentContext::attributes() {
  return getRuleContext<myParser::AttributesContext>(0);
}

tree::TerminalNode* myParser::Function_type_argumentContext::INOUT() {
  return getToken(myParser::INOUT, 0);
}

myParser::Argument_labelContext* myParser::Function_type_argumentContext::argument_label() {
  return getRuleContext<myParser::Argument_labelContext>(0);
}

myParser::Type_annotationContext* myParser::Function_type_argumentContext::type_annotation() {
  return getRuleContext<myParser::Type_annotationContext>(0);
}


size_t myParser::Function_type_argumentContext::getRuleIndex() const {
  return myParser::RuleFunction_type_argument;
}

void myParser::Function_type_argumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_type_argument(this);
}

void myParser::Function_type_argumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_type_argument(this);
}

myParser::Function_type_argumentContext* myParser::function_type_argument() {
  Function_type_argumentContext *_localctx = _tracker.createInstance<Function_type_argumentContext>(_ctx, getState());
  enterRule(_localctx, 544, myParser::RuleFunction_type_argument);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2624);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 324, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2615);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 322, _ctx)) {
      case 1: {
        setState(2614);
        attributes();
        break;
      }

      default:
        break;
      }
      setState(2618);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::INOUT) {
        setState(2617);
        match(myParser::INOUT);
      }
      setState(2620);
      type(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2621);
      argument_label();
      setState(2622);
      type_annotation();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Argument_labelContext ------------------------------------------------------------------

myParser::Argument_labelContext::Argument_labelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::IdentifierContext *> myParser::Argument_labelContext::identifier() {
  return getRuleContexts<myParser::IdentifierContext>();
}

myParser::IdentifierContext* myParser::Argument_labelContext::identifier(size_t i) {
  return getRuleContext<myParser::IdentifierContext>(i);
}


size_t myParser::Argument_labelContext::getRuleIndex() const {
  return myParser::RuleArgument_label;
}

void myParser::Argument_labelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgument_label(this);
}

void myParser::Argument_labelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgument_label(this);
}

myParser::Argument_labelContext* myParser::argument_label() {
  Argument_labelContext *_localctx = _tracker.createInstance<Argument_labelContext>(_ctx, getState());
  enterRule(_localctx, 546, myParser::RuleArgument_label);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2627); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2626);
      identifier();
      setState(2629); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -576599273992204954) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3940649437003519) != 0) || ((((_la - 135) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 135)) & 1073741831) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_typeContext ------------------------------------------------------------------

myParser::Array_typeContext::Array_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Array_typeContext::LBRACK() {
  return getToken(myParser::LBRACK, 0);
}

myParser::TypeContext* myParser::Array_typeContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

tree::TerminalNode* myParser::Array_typeContext::RBRACK() {
  return getToken(myParser::RBRACK, 0);
}


size_t myParser::Array_typeContext::getRuleIndex() const {
  return myParser::RuleArray_type;
}

void myParser::Array_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_type(this);
}

void myParser::Array_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_type(this);
}

myParser::Array_typeContext* myParser::array_type() {
  Array_typeContext *_localctx = _tracker.createInstance<Array_typeContext>(_ctx, getState());
  enterRule(_localctx, 548, myParser::RuleArray_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2631);
    match(myParser::LBRACK);
    setState(2632);
    type(0);
    setState(2633);
    match(myParser::RBRACK);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dictionary_typeContext ------------------------------------------------------------------

myParser::Dictionary_typeContext::Dictionary_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Dictionary_typeContext::LBRACK() {
  return getToken(myParser::LBRACK, 0);
}

std::vector<myParser::TypeContext *> myParser::Dictionary_typeContext::type() {
  return getRuleContexts<myParser::TypeContext>();
}

myParser::TypeContext* myParser::Dictionary_typeContext::type(size_t i) {
  return getRuleContext<myParser::TypeContext>(i);
}

tree::TerminalNode* myParser::Dictionary_typeContext::COLON() {
  return getToken(myParser::COLON, 0);
}

tree::TerminalNode* myParser::Dictionary_typeContext::RBRACK() {
  return getToken(myParser::RBRACK, 0);
}


size_t myParser::Dictionary_typeContext::getRuleIndex() const {
  return myParser::RuleDictionary_type;
}

void myParser::Dictionary_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDictionary_type(this);
}

void myParser::Dictionary_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDictionary_type(this);
}

myParser::Dictionary_typeContext* myParser::dictionary_type() {
  Dictionary_typeContext *_localctx = _tracker.createInstance<Dictionary_typeContext>(_ctx, getState());
  enterRule(_localctx, 550, myParser::RuleDictionary_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2635);
    match(myParser::LBRACK);
    setState(2636);
    type(0);
    setState(2637);
    match(myParser::COLON);
    setState(2638);
    type(0);
    setState(2639);
    match(myParser::RBRACK);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Protocol_composition_typeContext ------------------------------------------------------------------

myParser::Protocol_composition_typeContext::Protocol_composition_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Type_identifierContext *> myParser::Protocol_composition_typeContext::type_identifier() {
  return getRuleContexts<myParser::Type_identifierContext>();
}

myParser::Type_identifierContext* myParser::Protocol_composition_typeContext::type_identifier(size_t i) {
  return getRuleContext<myParser::Type_identifierContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Protocol_composition_typeContext::AND() {
  return getTokens(myParser::AND);
}

tree::TerminalNode* myParser::Protocol_composition_typeContext::AND(size_t i) {
  return getToken(myParser::AND, i);
}

myParser::Trailing_composition_andContext* myParser::Protocol_composition_typeContext::trailing_composition_and() {
  return getRuleContext<myParser::Trailing_composition_andContext>(0);
}


size_t myParser::Protocol_composition_typeContext::getRuleIndex() const {
  return myParser::RuleProtocol_composition_type;
}

void myParser::Protocol_composition_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProtocol_composition_type(this);
}

void myParser::Protocol_composition_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProtocol_composition_type(this);
}

myParser::Protocol_composition_typeContext* myParser::protocol_composition_type() {
  Protocol_composition_typeContext *_localctx = _tracker.createInstance<Protocol_composition_typeContext>(_ctx, getState());
  enterRule(_localctx, 552, myParser::RuleProtocol_composition_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2641);
    type_identifier();
    setState(2646);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 326, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2642);
        match(myParser::AND);
        setState(2643);
        type_identifier(); 
      }
      setState(2648);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 326, _ctx);
    }
    setState(2650);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 327, _ctx)) {
    case 1: {
      setState(2649);
      trailing_composition_and();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trailing_composition_andContext ------------------------------------------------------------------

myParser::Trailing_composition_andContext::Trailing_composition_andContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Trailing_composition_andContext::AND() {
  return getToken(myParser::AND, 0);
}


size_t myParser::Trailing_composition_andContext::getRuleIndex() const {
  return myParser::RuleTrailing_composition_and;
}

void myParser::Trailing_composition_andContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrailing_composition_and(this);
}

void myParser::Trailing_composition_andContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrailing_composition_and(this);
}

myParser::Trailing_composition_andContext* myParser::trailing_composition_and() {
  Trailing_composition_andContext *_localctx = _tracker.createInstance<Trailing_composition_andContext>(_ctx, getState());
  enterRule(_localctx, 554, myParser::RuleTrailing_composition_and);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2652);

    if (!(!SwiftSupport.isBinaryOp(_input))) throw FailedPredicateException(this, "!SwiftSupport.isBinaryOp(_input)");
    setState(2653);
    match(myParser::AND);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opaque_typeContext ------------------------------------------------------------------

myParser::Opaque_typeContext::Opaque_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Opaque_typeContext::SOME() {
  return getToken(myParser::SOME, 0);
}

myParser::TypeContext* myParser::Opaque_typeContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}


size_t myParser::Opaque_typeContext::getRuleIndex() const {
  return myParser::RuleOpaque_type;
}

void myParser::Opaque_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpaque_type(this);
}

void myParser::Opaque_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpaque_type(this);
}

myParser::Opaque_typeContext* myParser::opaque_type() {
  Opaque_typeContext *_localctx = _tracker.createInstance<Opaque_typeContext>(_ctx, getState());
  enterRule(_localctx, 556, myParser::RuleOpaque_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2655);
    match(myParser::SOME);
    setState(2656);
    type(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Any_typeContext ------------------------------------------------------------------

myParser::Any_typeContext::Any_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Any_typeContext::ANY() {
  return getToken(myParser::ANY, 0);
}


size_t myParser::Any_typeContext::getRuleIndex() const {
  return myParser::RuleAny_type;
}

void myParser::Any_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAny_type(this);
}

void myParser::Any_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAny_type(this);
}

myParser::Any_typeContext* myParser::any_type() {
  Any_typeContext *_localctx = _tracker.createInstance<Any_typeContext>(_ctx, getState());
  enterRule(_localctx, 558, myParser::RuleAny_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2658);
    match(myParser::ANY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Self_typeContext ------------------------------------------------------------------

myParser::Self_typeContext::Self_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Self_typeContext::SELF_BIG() {
  return getToken(myParser::SELF_BIG, 0);
}


size_t myParser::Self_typeContext::getRuleIndex() const {
  return myParser::RuleSelf_type;
}

void myParser::Self_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelf_type(this);
}

void myParser::Self_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelf_type(this);
}

myParser::Self_typeContext* myParser::self_type() {
  Self_typeContext *_localctx = _tracker.createInstance<Self_typeContext>(_ctx, getState());
  enterRule(_localctx, 560, myParser::RuleSelf_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2660);
    match(myParser::SELF_BIG);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_inheritance_clauseContext ------------------------------------------------------------------

myParser::Type_inheritance_clauseContext::Type_inheritance_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Type_inheritance_clauseContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::Type_inheritance_listContext* myParser::Type_inheritance_clauseContext::type_inheritance_list() {
  return getRuleContext<myParser::Type_inheritance_listContext>(0);
}


size_t myParser::Type_inheritance_clauseContext::getRuleIndex() const {
  return myParser::RuleType_inheritance_clause;
}

void myParser::Type_inheritance_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_inheritance_clause(this);
}

void myParser::Type_inheritance_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_inheritance_clause(this);
}

myParser::Type_inheritance_clauseContext* myParser::type_inheritance_clause() {
  Type_inheritance_clauseContext *_localctx = _tracker.createInstance<Type_inheritance_clauseContext>(_ctx, getState());
  enterRule(_localctx, 562, myParser::RuleType_inheritance_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2662);
    match(myParser::COLON);
    setState(2663);
    type_inheritance_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_inheritance_listContext ------------------------------------------------------------------

myParser::Type_inheritance_listContext::Type_inheritance_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Type_identifierContext *> myParser::Type_inheritance_listContext::type_identifier() {
  return getRuleContexts<myParser::Type_identifierContext>();
}

myParser::Type_identifierContext* myParser::Type_inheritance_listContext::type_identifier(size_t i) {
  return getRuleContext<myParser::Type_identifierContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Type_inheritance_listContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Type_inheritance_listContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Type_inheritance_listContext::getRuleIndex() const {
  return myParser::RuleType_inheritance_list;
}

void myParser::Type_inheritance_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_inheritance_list(this);
}

void myParser::Type_inheritance_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_inheritance_list(this);
}

myParser::Type_inheritance_listContext* myParser::type_inheritance_list() {
  Type_inheritance_listContext *_localctx = _tracker.createInstance<Type_inheritance_listContext>(_ctx, getState());
  enterRule(_localctx, 564, myParser::RuleType_inheritance_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2665);
    type_identifier();
    setState(2670);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(2666);
      match(myParser::COMMA);
      setState(2667);
      type_identifier();
      setState(2672);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

myParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::IdentifierContext::LINUX() {
  return getToken(myParser::LINUX, 0);
}

tree::TerminalNode* myParser::IdentifierContext::WINDOWS() {
  return getToken(myParser::WINDOWS, 0);
}

tree::TerminalNode* myParser::IdentifierContext::ALPHA() {
  return getToken(myParser::ALPHA, 0);
}

tree::TerminalNode* myParser::IdentifierContext::ARCH() {
  return getToken(myParser::ARCH, 0);
}

tree::TerminalNode* myParser::IdentifierContext::ARM() {
  return getToken(myParser::ARM, 0);
}

tree::TerminalNode* myParser::IdentifierContext::ARM64() {
  return getToken(myParser::ARM64, 0);
}

tree::TerminalNode* myParser::IdentifierContext::ASSIGNMENT() {
  return getToken(myParser::ASSIGNMENT, 0);
}

tree::TerminalNode* myParser::IdentifierContext::BLUE() {
  return getToken(myParser::BLUE, 0);
}

tree::TerminalNode* myParser::IdentifierContext::CAN_IMPORT() {
  return getToken(myParser::CAN_IMPORT, 0);
}

tree::TerminalNode* myParser::IdentifierContext::COMPILER() {
  return getToken(myParser::COMPILER, 0);
}

tree::TerminalNode* myParser::IdentifierContext::FILE() {
  return getToken(myParser::FILE, 0);
}

tree::TerminalNode* myParser::IdentifierContext::GREEN() {
  return getToken(myParser::GREEN, 0);
}

tree::TerminalNode* myParser::IdentifierContext::HIGHER_THAN() {
  return getToken(myParser::HIGHER_THAN, 0);
}

tree::TerminalNode* myParser::IdentifierContext::I386() {
  return getToken(myParser::I386, 0);
}

tree::TerminalNode* myParser::IdentifierContext::I_OS() {
  return getToken(myParser::I_OS, 0);
}

tree::TerminalNode* myParser::IdentifierContext::OSX() {
  return getToken(myParser::OSX, 0);
}

tree::TerminalNode* myParser::IdentifierContext::I_OS_APPLICATION_EXTENSION() {
  return getToken(myParser::I_OS_APPLICATION_EXTENSION, 0);
}

tree::TerminalNode* myParser::IdentifierContext::LINE() {
  return getToken(myParser::LINE, 0);
}

tree::TerminalNode* myParser::IdentifierContext::LOWER_THAN() {
  return getToken(myParser::LOWER_THAN, 0);
}

tree::TerminalNode* myParser::IdentifierContext::MAC_CATALYST() {
  return getToken(myParser::MAC_CATALYST, 0);
}

tree::TerminalNode* myParser::IdentifierContext::MAC_CATALYST_APPLICATION_EXTENSION() {
  return getToken(myParser::MAC_CATALYST_APPLICATION_EXTENSION, 0);
}

tree::TerminalNode* myParser::IdentifierContext::MAC_OS() {
  return getToken(myParser::MAC_OS, 0);
}

tree::TerminalNode* myParser::IdentifierContext::MAC_OS_APPLICATION_EXTENSION() {
  return getToken(myParser::MAC_OS_APPLICATION_EXTENSION, 0);
}

tree::TerminalNode* myParser::IdentifierContext::OS() {
  return getToken(myParser::OS, 0);
}

tree::TerminalNode* myParser::IdentifierContext::PRECEDENCE_GROUP() {
  return getToken(myParser::PRECEDENCE_GROUP, 0);
}

tree::TerminalNode* myParser::IdentifierContext::RED() {
  return getToken(myParser::RED, 0);
}

tree::TerminalNode* myParser::IdentifierContext::RESOURCE_NAME() {
  return getToken(myParser::RESOURCE_NAME, 0);
}

tree::TerminalNode* myParser::IdentifierContext::SAFE() {
  return getToken(myParser::SAFE, 0);
}

tree::TerminalNode* myParser::IdentifierContext::SIMULATOR() {
  return getToken(myParser::SIMULATOR, 0);
}

tree::TerminalNode* myParser::IdentifierContext::SOME() {
  return getToken(myParser::SOME, 0);
}

tree::TerminalNode* myParser::IdentifierContext::SWIFT() {
  return getToken(myParser::SWIFT, 0);
}

tree::TerminalNode* myParser::IdentifierContext::TARGET_ENVIRONMENT() {
  return getToken(myParser::TARGET_ENVIRONMENT, 0);
}

tree::TerminalNode* myParser::IdentifierContext::TV_OS() {
  return getToken(myParser::TV_OS, 0);
}

tree::TerminalNode* myParser::IdentifierContext::UNSAFE() {
  return getToken(myParser::UNSAFE, 0);
}

tree::TerminalNode* myParser::IdentifierContext::WATCH_OS() {
  return getToken(myParser::WATCH_OS, 0);
}

tree::TerminalNode* myParser::IdentifierContext::X86_64() {
  return getToken(myParser::X86_64, 0);
}

tree::TerminalNode* myParser::IdentifierContext::ASSOCIATIVITY() {
  return getToken(myParser::ASSOCIATIVITY, 0);
}

tree::TerminalNode* myParser::IdentifierContext::CONVENIENCE() {
  return getToken(myParser::CONVENIENCE, 0);
}

tree::TerminalNode* myParser::IdentifierContext::DYNAMIC() {
  return getToken(myParser::DYNAMIC, 0);
}

tree::TerminalNode* myParser::IdentifierContext::DID_SET() {
  return getToken(myParser::DID_SET, 0);
}

tree::TerminalNode* myParser::IdentifierContext::FINAL() {
  return getToken(myParser::FINAL, 0);
}

tree::TerminalNode* myParser::IdentifierContext::GET() {
  return getToken(myParser::GET, 0);
}

tree::TerminalNode* myParser::IdentifierContext::INFIX() {
  return getToken(myParser::INFIX, 0);
}

tree::TerminalNode* myParser::IdentifierContext::INDIRECT() {
  return getToken(myParser::INDIRECT, 0);
}

tree::TerminalNode* myParser::IdentifierContext::LAZY() {
  return getToken(myParser::LAZY, 0);
}

tree::TerminalNode* myParser::IdentifierContext::LEFT() {
  return getToken(myParser::LEFT, 0);
}

tree::TerminalNode* myParser::IdentifierContext::MUTATING() {
  return getToken(myParser::MUTATING, 0);
}

tree::TerminalNode* myParser::IdentifierContext::NONE() {
  return getToken(myParser::NONE, 0);
}

tree::TerminalNode* myParser::IdentifierContext::NONMUTATING() {
  return getToken(myParser::NONMUTATING, 0);
}

tree::TerminalNode* myParser::IdentifierContext::OPTIONAL() {
  return getToken(myParser::OPTIONAL, 0);
}

tree::TerminalNode* myParser::IdentifierContext::OVERRIDE() {
  return getToken(myParser::OVERRIDE, 0);
}

tree::TerminalNode* myParser::IdentifierContext::POSTFIX() {
  return getToken(myParser::POSTFIX, 0);
}

tree::TerminalNode* myParser::IdentifierContext::PRECEDENCE() {
  return getToken(myParser::PRECEDENCE, 0);
}

tree::TerminalNode* myParser::IdentifierContext::PREFIX() {
  return getToken(myParser::PREFIX, 0);
}

tree::TerminalNode* myParser::IdentifierContext::PROTOCOL() {
  return getToken(myParser::PROTOCOL, 0);
}

tree::TerminalNode* myParser::IdentifierContext::REQUIRED() {
  return getToken(myParser::REQUIRED, 0);
}

tree::TerminalNode* myParser::IdentifierContext::RIGHT() {
  return getToken(myParser::RIGHT, 0);
}

tree::TerminalNode* myParser::IdentifierContext::SET() {
  return getToken(myParser::SET, 0);
}

tree::TerminalNode* myParser::IdentifierContext::TYPE() {
  return getToken(myParser::TYPE, 0);
}

tree::TerminalNode* myParser::IdentifierContext::UNOWNED() {
  return getToken(myParser::UNOWNED, 0);
}

tree::TerminalNode* myParser::IdentifierContext::WEAK() {
  return getToken(myParser::WEAK, 0);
}

tree::TerminalNode* myParser::IdentifierContext::WILL_SET() {
  return getToken(myParser::WILL_SET, 0);
}

tree::TerminalNode* myParser::IdentifierContext::IN() {
  return getToken(myParser::IN, 0);
}

tree::TerminalNode* myParser::IdentifierContext::FOR() {
  return getToken(myParser::FOR, 0);
}

tree::TerminalNode* myParser::IdentifierContext::GUARD() {
  return getToken(myParser::GUARD, 0);
}

tree::TerminalNode* myParser::IdentifierContext::WHERE() {
  return getToken(myParser::WHERE, 0);
}

tree::TerminalNode* myParser::IdentifierContext::DEFAULT() {
  return getToken(myParser::DEFAULT, 0);
}

tree::TerminalNode* myParser::IdentifierContext::INTERNAL() {
  return getToken(myParser::INTERNAL, 0);
}

tree::TerminalNode* myParser::IdentifierContext::PRIVATE() {
  return getToken(myParser::PRIVATE, 0);
}

tree::TerminalNode* myParser::IdentifierContext::PUBLIC() {
  return getToken(myParser::PUBLIC, 0);
}

tree::TerminalNode* myParser::IdentifierContext::OPEN() {
  return getToken(myParser::OPEN, 0);
}

tree::TerminalNode* myParser::IdentifierContext::AS() {
  return getToken(myParser::AS, 0);
}

tree::TerminalNode* myParser::IdentifierContext::WHILE() {
  return getToken(myParser::WHILE, 0);
}

tree::TerminalNode* myParser::IdentifierContext::SELF() {
  return getToken(myParser::SELF, 0);
}

tree::TerminalNode* myParser::IdentifierContext::SELF_BIG() {
  return getToken(myParser::SELF_BIG, 0);
}

tree::TerminalNode* myParser::IdentifierContext::CLASS() {
  return getToken(myParser::CLASS, 0);
}

tree::TerminalNode* myParser::IdentifierContext::GETTER() {
  return getToken(myParser::GETTER, 0);
}

tree::TerminalNode* myParser::IdentifierContext::SETTER() {
  return getToken(myParser::SETTER, 0);
}

tree::TerminalNode* myParser::IdentifierContext::OPERATOR() {
  return getToken(myParser::OPERATOR, 0);
}

tree::TerminalNode* myParser::IdentifierContext::DO() {
  return getToken(myParser::DO, 0);
}

tree::TerminalNode* myParser::IdentifierContext::CATCH() {
  return getToken(myParser::CATCH, 0);
}

tree::TerminalNode* myParser::IdentifierContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

std::vector<tree::TerminalNode *> myParser::IdentifierContext::BACKTICK() {
  return getTokens(myParser::BACKTICK);
}

tree::TerminalNode* myParser::IdentifierContext::BACKTICK(size_t i) {
  return getToken(myParser::BACKTICK, i);
}

myParser::KeywordContext* myParser::IdentifierContext::keyword() {
  return getRuleContext<myParser::KeywordContext>(0);
}

tree::TerminalNode* myParser::IdentifierContext::DOLLAR() {
  return getToken(myParser::DOLLAR, 0);
}


size_t myParser::IdentifierContext::getRuleIndex() const {
  return myParser::RuleIdentifier;
}

void myParser::IdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier(this);
}

void myParser::IdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier(this);
}

myParser::IdentifierContext* myParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 566, myParser::RuleIdentifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2682);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::AS:
      case myParser::ALPHA:
      case myParser::CATCH:
      case myParser::CLASS:
      case myParser::DEFAULT:
      case myParser::DO:
      case myParser::GUARD:
      case myParser::FOR:
      case myParser::IN:
      case myParser::INTERNAL:
      case myParser::FINAL:
      case myParser::OPEN:
      case myParser::PRIVATE:
      case myParser::PUBLIC:
      case myParser::WHERE:
      case myParser::WHILE:
      case myParser::PROTOCOL:
      case myParser::GET:
      case myParser::SET:
      case myParser::WILL_SET:
      case myParser::DID_SET:
      case myParser::INDIRECT:
      case myParser::PREFIX:
      case myParser::INFIX:
      case myParser::LEFT:
      case myParser::RIGHT:
      case myParser::NONE:
      case myParser::PRECEDENCE_GROUP:
      case myParser::HIGHER_THAN:
      case myParser::LOWER_THAN:
      case myParser::ASSIGNMENT:
      case myParser::ASSOCIATIVITY:
      case myParser::POSTFIX:
      case myParser::OPERATOR:
      case myParser::OS:
      case myParser::ARCH:
      case myParser::SWIFT:
      case myParser::COMPILER:
      case myParser::CAN_IMPORT:
      case myParser::TARGET_ENVIRONMENT:
      case myParser::CONVENIENCE:
      case myParser::DYNAMIC:
      case myParser::LAZY:
      case myParser::OPTIONAL:
      case myParser::OVERRIDE:
      case myParser::REQUIRED:
      case myParser::WEAK:
      case myParser::UNOWNED:
      case myParser::SAFE:
      case myParser::UNSAFE:
      case myParser::MUTATING:
      case myParser::NONMUTATING:
      case myParser::RED:
      case myParser::BLUE:
      case myParser::GREEN:
      case myParser::RESOURCE_NAME:
      case myParser::SOME:
      case myParser::TYPE:
      case myParser::PRECEDENCE:
      case myParser::SELF:
      case myParser::SELF_BIG:
      case myParser::MAC_OS:
      case myParser::I_OS:
      case myParser::OSX:
      case myParser::WATCH_OS:
      case myParser::TV_OS:
      case myParser::LINUX:
      case myParser::WINDOWS:
      case myParser::I386:
      case myParser::X86_64:
      case myParser::ARM:
      case myParser::ARM64:
      case myParser::SIMULATOR:
      case myParser::MAC_CATALYST:
      case myParser::I_OS_APPLICATION_EXTENSION:
      case myParser::MAC_CATALYST_APPLICATION_EXTENSION:
      case myParser::MAC_OS_APPLICATION_EXTENSION:
      case myParser::FILE:
      case myParser::LINE:
      case myParser::GETTER:
      case myParser::SETTER: {
        enterOuterAlt(_localctx, 1);
        setState(2673);
        _la = _input->LA(1);
        if (!((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & -576599273992204954) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 3940649437003519) != 0) || _la == myParser::GETTER

        || _la == myParser::SETTER)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case myParser::Identifier: {
        enterOuterAlt(_localctx, 2);
        setState(2674);
        match(myParser::Identifier);
        break;
      }

      case myParser::BACKTICK: {
        enterOuterAlt(_localctx, 3);
        setState(2675);
        match(myParser::BACKTICK);
        setState(2679);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case myParser::AS:
          case myParser::BREAK:
          case myParser::CASE:
          case myParser::CATCH:
          case myParser::CLASS:
          case myParser::CONTINUE:
          case myParser::DEFAULT:
          case myParser::DEFER:
          case myParser::DO:
          case myParser::GUARD:
          case myParser::ELSE:
          case myParser::ENUM:
          case myParser::FOR:
          case myParser::FALLTHROUGH:
          case myParser::FUNC:
          case myParser::IN:
          case myParser::IF:
          case myParser::IMPORT:
          case myParser::INTERNAL:
          case myParser::OPEN:
          case myParser::PRIVATE:
          case myParser::PUBLIC:
          case myParser::WHERE:
          case myParser::WHILE:
          case myParser::LET:
          case myParser::VAR:
          case myParser::PROTOCOL:
          case myParser::REPEAT:
          case myParser::SWITCH:
          case myParser::STRUCT:
          case myParser::RETURN:
          case myParser::THROW:
          case myParser::THROWS:
          case myParser::RETHROWS:
          case myParser::INIT:
          case myParser::DEINIT:
          case myParser::ASSOCIATED_TYPE:
          case myParser::EXTENSION:
          case myParser::SUBSCRIPT:
          case myParser::OPERATOR:
          case myParser::TYPEALIAS:
          case myParser::STATIC:
          case myParser::FILE_PRIVATE:
          case myParser::IS:
          case myParser::TRY:
          case myParser::SUPER:
          case myParser::ANY:
          case myParser::FALSE:
          case myParser::TRUE:
          case myParser::NIL:
          case myParser::INOUT:
          case myParser::SELF:
          case myParser::SELF_BIG:
          case myParser::SOURCE_LOCATION:
          case myParser::ERROR:
          case myParser::WARNING:
          case myParser::AVAILABLE:
          case myParser::HASH_IF:
          case myParser::HASH_ELSEIF:
          case myParser::HASH_ELSE:
          case myParser::HASH_ENDIF:
          case myParser::HASH_FILE:
          case myParser::HASH_FILE_ID:
          case myParser::HASH_FILE_PATH:
          case myParser::HASH_LINE:
          case myParser::HASH_COLUMN:
          case myParser::HASH_FUNCTION:
          case myParser::HASH_SELECTOR:
          case myParser::HASH_COLOR_LITERAL:
          case myParser::HASH_FILE_LITERAL:
          case myParser::HASH_IMAGE_LITERAL:
          case myParser::UNDERSCORE: {
            setState(2676);
            keyword();
            break;
          }

          case myParser::Identifier: {
            setState(2677);
            match(myParser::Identifier);
            break;
          }

          case myParser::DOLLAR: {
            setState(2678);
            match(myParser::DOLLAR);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(2681);
        match(myParser::BACKTICK);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Identifier_listContext ------------------------------------------------------------------

myParser::Identifier_listContext::Identifier_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::IdentifierContext *> myParser::Identifier_listContext::identifier() {
  return getRuleContexts<myParser::IdentifierContext>();
}

myParser::IdentifierContext* myParser::Identifier_listContext::identifier(size_t i) {
  return getRuleContext<myParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Identifier_listContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Identifier_listContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Identifier_listContext::getRuleIndex() const {
  return myParser::RuleIdentifier_list;
}

void myParser::Identifier_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier_list(this);
}

void myParser::Identifier_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier_list(this);
}

myParser::Identifier_listContext* myParser::identifier_list() {
  Identifier_listContext *_localctx = _tracker.createInstance<Identifier_listContext>(_ctx, getState());
  enterRule(_localctx, 568, myParser::RuleIdentifier_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2684);
    identifier();
    setState(2689);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 331, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2685);
        match(myParser::COMMA);
        setState(2686);
        identifier(); 
      }
      setState(2691);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 331, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeywordContext ------------------------------------------------------------------

myParser::KeywordContext::KeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::KeywordContext::ASSOCIATED_TYPE() {
  return getToken(myParser::ASSOCIATED_TYPE, 0);
}

tree::TerminalNode* myParser::KeywordContext::CLASS() {
  return getToken(myParser::CLASS, 0);
}

tree::TerminalNode* myParser::KeywordContext::DEINIT() {
  return getToken(myParser::DEINIT, 0);
}

tree::TerminalNode* myParser::KeywordContext::ENUM() {
  return getToken(myParser::ENUM, 0);
}

tree::TerminalNode* myParser::KeywordContext::EXTENSION() {
  return getToken(myParser::EXTENSION, 0);
}

tree::TerminalNode* myParser::KeywordContext::FILE_PRIVATE() {
  return getToken(myParser::FILE_PRIVATE, 0);
}

tree::TerminalNode* myParser::KeywordContext::FUNC() {
  return getToken(myParser::FUNC, 0);
}

tree::TerminalNode* myParser::KeywordContext::IMPORT() {
  return getToken(myParser::IMPORT, 0);
}

tree::TerminalNode* myParser::KeywordContext::INIT() {
  return getToken(myParser::INIT, 0);
}

tree::TerminalNode* myParser::KeywordContext::INOUT() {
  return getToken(myParser::INOUT, 0);
}

tree::TerminalNode* myParser::KeywordContext::INTERNAL() {
  return getToken(myParser::INTERNAL, 0);
}

tree::TerminalNode* myParser::KeywordContext::LET() {
  return getToken(myParser::LET, 0);
}

tree::TerminalNode* myParser::KeywordContext::OPEN() {
  return getToken(myParser::OPEN, 0);
}

tree::TerminalNode* myParser::KeywordContext::OPERATOR() {
  return getToken(myParser::OPERATOR, 0);
}

tree::TerminalNode* myParser::KeywordContext::PRIVATE() {
  return getToken(myParser::PRIVATE, 0);
}

tree::TerminalNode* myParser::KeywordContext::PROTOCOL() {
  return getToken(myParser::PROTOCOL, 0);
}

tree::TerminalNode* myParser::KeywordContext::PUBLIC() {
  return getToken(myParser::PUBLIC, 0);
}

tree::TerminalNode* myParser::KeywordContext::RETHROWS() {
  return getToken(myParser::RETHROWS, 0);
}

tree::TerminalNode* myParser::KeywordContext::STATIC() {
  return getToken(myParser::STATIC, 0);
}

tree::TerminalNode* myParser::KeywordContext::STRUCT() {
  return getToken(myParser::STRUCT, 0);
}

tree::TerminalNode* myParser::KeywordContext::SUBSCRIPT() {
  return getToken(myParser::SUBSCRIPT, 0);
}

tree::TerminalNode* myParser::KeywordContext::TYPEALIAS() {
  return getToken(myParser::TYPEALIAS, 0);
}

tree::TerminalNode* myParser::KeywordContext::VAR() {
  return getToken(myParser::VAR, 0);
}

tree::TerminalNode* myParser::KeywordContext::BREAK() {
  return getToken(myParser::BREAK, 0);
}

tree::TerminalNode* myParser::KeywordContext::CASE() {
  return getToken(myParser::CASE, 0);
}

tree::TerminalNode* myParser::KeywordContext::CONTINUE() {
  return getToken(myParser::CONTINUE, 0);
}

tree::TerminalNode* myParser::KeywordContext::DEFAULT() {
  return getToken(myParser::DEFAULT, 0);
}

tree::TerminalNode* myParser::KeywordContext::DEFER() {
  return getToken(myParser::DEFER, 0);
}

tree::TerminalNode* myParser::KeywordContext::DO() {
  return getToken(myParser::DO, 0);
}

tree::TerminalNode* myParser::KeywordContext::ELSE() {
  return getToken(myParser::ELSE, 0);
}

tree::TerminalNode* myParser::KeywordContext::FALLTHROUGH() {
  return getToken(myParser::FALLTHROUGH, 0);
}

tree::TerminalNode* myParser::KeywordContext::FOR() {
  return getToken(myParser::FOR, 0);
}

tree::TerminalNode* myParser::KeywordContext::GUARD() {
  return getToken(myParser::GUARD, 0);
}

tree::TerminalNode* myParser::KeywordContext::IF() {
  return getToken(myParser::IF, 0);
}

tree::TerminalNode* myParser::KeywordContext::IN() {
  return getToken(myParser::IN, 0);
}

tree::TerminalNode* myParser::KeywordContext::REPEAT() {
  return getToken(myParser::REPEAT, 0);
}

tree::TerminalNode* myParser::KeywordContext::RETURN() {
  return getToken(myParser::RETURN, 0);
}

tree::TerminalNode* myParser::KeywordContext::SWITCH() {
  return getToken(myParser::SWITCH, 0);
}

tree::TerminalNode* myParser::KeywordContext::WHERE() {
  return getToken(myParser::WHERE, 0);
}

tree::TerminalNode* myParser::KeywordContext::WHILE() {
  return getToken(myParser::WHILE, 0);
}

tree::TerminalNode* myParser::KeywordContext::AS() {
  return getToken(myParser::AS, 0);
}

tree::TerminalNode* myParser::KeywordContext::ANY() {
  return getToken(myParser::ANY, 0);
}

tree::TerminalNode* myParser::KeywordContext::CATCH() {
  return getToken(myParser::CATCH, 0);
}

tree::TerminalNode* myParser::KeywordContext::FALSE() {
  return getToken(myParser::FALSE, 0);
}

tree::TerminalNode* myParser::KeywordContext::IS() {
  return getToken(myParser::IS, 0);
}

tree::TerminalNode* myParser::KeywordContext::NIL() {
  return getToken(myParser::NIL, 0);
}

tree::TerminalNode* myParser::KeywordContext::SUPER() {
  return getToken(myParser::SUPER, 0);
}

tree::TerminalNode* myParser::KeywordContext::SELF() {
  return getToken(myParser::SELF, 0);
}

tree::TerminalNode* myParser::KeywordContext::SELF_BIG() {
  return getToken(myParser::SELF_BIG, 0);
}

tree::TerminalNode* myParser::KeywordContext::THROW() {
  return getToken(myParser::THROW, 0);
}

tree::TerminalNode* myParser::KeywordContext::THROWS() {
  return getToken(myParser::THROWS, 0);
}

tree::TerminalNode* myParser::KeywordContext::TRUE() {
  return getToken(myParser::TRUE, 0);
}

tree::TerminalNode* myParser::KeywordContext::TRY() {
  return getToken(myParser::TRY, 0);
}

tree::TerminalNode* myParser::KeywordContext::UNDERSCORE() {
  return getToken(myParser::UNDERSCORE, 0);
}

tree::TerminalNode* myParser::KeywordContext::AVAILABLE() {
  return getToken(myParser::AVAILABLE, 0);
}

tree::TerminalNode* myParser::KeywordContext::HASH_COLOR_LITERAL() {
  return getToken(myParser::HASH_COLOR_LITERAL, 0);
}

tree::TerminalNode* myParser::KeywordContext::HASH_COLUMN() {
  return getToken(myParser::HASH_COLUMN, 0);
}

tree::TerminalNode* myParser::KeywordContext::HASH_ELSE() {
  return getToken(myParser::HASH_ELSE, 0);
}

tree::TerminalNode* myParser::KeywordContext::HASH_ELSEIF() {
  return getToken(myParser::HASH_ELSEIF, 0);
}

tree::TerminalNode* myParser::KeywordContext::HASH_ENDIF() {
  return getToken(myParser::HASH_ENDIF, 0);
}

tree::TerminalNode* myParser::KeywordContext::ERROR() {
  return getToken(myParser::ERROR, 0);
}

tree::TerminalNode* myParser::KeywordContext::HASH_FILE() {
  return getToken(myParser::HASH_FILE, 0);
}

tree::TerminalNode* myParser::KeywordContext::HASH_FILE_ID() {
  return getToken(myParser::HASH_FILE_ID, 0);
}

tree::TerminalNode* myParser::KeywordContext::HASH_FILE_LITERAL() {
  return getToken(myParser::HASH_FILE_LITERAL, 0);
}

tree::TerminalNode* myParser::KeywordContext::HASH_FILE_PATH() {
  return getToken(myParser::HASH_FILE_PATH, 0);
}

tree::TerminalNode* myParser::KeywordContext::HASH_FUNCTION() {
  return getToken(myParser::HASH_FUNCTION, 0);
}

tree::TerminalNode* myParser::KeywordContext::HASH_IF() {
  return getToken(myParser::HASH_IF, 0);
}

tree::TerminalNode* myParser::KeywordContext::HASH_IMAGE_LITERAL() {
  return getToken(myParser::HASH_IMAGE_LITERAL, 0);
}

tree::TerminalNode* myParser::KeywordContext::HASH_LINE() {
  return getToken(myParser::HASH_LINE, 0);
}

tree::TerminalNode* myParser::KeywordContext::HASH_SELECTOR() {
  return getToken(myParser::HASH_SELECTOR, 0);
}

tree::TerminalNode* myParser::KeywordContext::SOURCE_LOCATION() {
  return getToken(myParser::SOURCE_LOCATION, 0);
}

tree::TerminalNode* myParser::KeywordContext::WARNING() {
  return getToken(myParser::WARNING, 0);
}


size_t myParser::KeywordContext::getRuleIndex() const {
  return myParser::RuleKeyword;
}

void myParser::KeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword(this);
}

void myParser::KeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword(this);
}

myParser::KeywordContext* myParser::keyword() {
  KeywordContext *_localctx = _tracker.createInstance<KeywordContext>(_ctx, getState());
  enterRule(_localctx, 570, myParser::RuleKeyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2692);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 864829650812010490) != 0) || ((((_la - 72) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 72)) & 8502780703338798977) != 0) || _la == myParser::UNDERSCORE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assignment_operatorContext ------------------------------------------------------------------

myParser::Assignment_operatorContext::Assignment_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Assignment_operatorContext::EQUAL() {
  return getToken(myParser::EQUAL, 0);
}


size_t myParser::Assignment_operatorContext::getRuleIndex() const {
  return myParser::RuleAssignment_operator;
}

void myParser::Assignment_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment_operator(this);
}

void myParser::Assignment_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment_operator(this);
}

myParser::Assignment_operatorContext* myParser::assignment_operator() {
  Assignment_operatorContext *_localctx = _tracker.createInstance<Assignment_operatorContext>(_ctx, getState());
  enterRule(_localctx, 572, myParser::RuleAssignment_operator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2694);

    if (!(SwiftSupport.isBinaryOp(_input))) throw FailedPredicateException(this, "SwiftSupport.isBinaryOp(_input)");
    setState(2695);
    match(myParser::EQUAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Negate_prefix_operatorContext ------------------------------------------------------------------

myParser::Negate_prefix_operatorContext::Negate_prefix_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Negate_prefix_operatorContext::SUB() {
  return getToken(myParser::SUB, 0);
}


size_t myParser::Negate_prefix_operatorContext::getRuleIndex() const {
  return myParser::RuleNegate_prefix_operator;
}

void myParser::Negate_prefix_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNegate_prefix_operator(this);
}

void myParser::Negate_prefix_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNegate_prefix_operator(this);
}

myParser::Negate_prefix_operatorContext* myParser::negate_prefix_operator() {
  Negate_prefix_operatorContext *_localctx = _tracker.createInstance<Negate_prefix_operatorContext>(_ctx, getState());
  enterRule(_localctx, 574, myParser::RuleNegate_prefix_operator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2697);

    if (!(SwiftSupport.isPrefixOp(_input))) throw FailedPredicateException(this, "SwiftSupport.isPrefixOp(_input)");
    setState(2698);
    match(myParser::SUB);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Compilation_condition_ANDContext ------------------------------------------------------------------

myParser::Compilation_condition_ANDContext::Compilation_condition_ANDContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> myParser::Compilation_condition_ANDContext::AND() {
  return getTokens(myParser::AND);
}

tree::TerminalNode* myParser::Compilation_condition_ANDContext::AND(size_t i) {
  return getToken(myParser::AND, i);
}


size_t myParser::Compilation_condition_ANDContext::getRuleIndex() const {
  return myParser::RuleCompilation_condition_AND;
}

void myParser::Compilation_condition_ANDContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompilation_condition_AND(this);
}

void myParser::Compilation_condition_ANDContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompilation_condition_AND(this);
}

myParser::Compilation_condition_ANDContext* myParser::compilation_condition_AND() {
  Compilation_condition_ANDContext *_localctx = _tracker.createInstance<Compilation_condition_ANDContext>(_ctx, getState());
  enterRule(_localctx, 576, myParser::RuleCompilation_condition_AND);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2700);

    if (!(SwiftSupport.isOperator(_input,"&&"))) throw FailedPredicateException(this, "SwiftSupport.isOperator(_input,\"&&\")");
    setState(2701);
    match(myParser::AND);
    setState(2702);
    match(myParser::AND);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Compilation_condition_ORContext ------------------------------------------------------------------

myParser::Compilation_condition_ORContext::Compilation_condition_ORContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> myParser::Compilation_condition_ORContext::OR() {
  return getTokens(myParser::OR);
}

tree::TerminalNode* myParser::Compilation_condition_ORContext::OR(size_t i) {
  return getToken(myParser::OR, i);
}


size_t myParser::Compilation_condition_ORContext::getRuleIndex() const {
  return myParser::RuleCompilation_condition_OR;
}

void myParser::Compilation_condition_ORContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompilation_condition_OR(this);
}

void myParser::Compilation_condition_ORContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompilation_condition_OR(this);
}

myParser::Compilation_condition_ORContext* myParser::compilation_condition_OR() {
  Compilation_condition_ORContext *_localctx = _tracker.createInstance<Compilation_condition_ORContext>(_ctx, getState());
  enterRule(_localctx, 578, myParser::RuleCompilation_condition_OR);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2704);

    if (!(SwiftSupport.isOperator(_input,"||"))) throw FailedPredicateException(this, "SwiftSupport.isOperator(_input,\"||\")");
    setState(2705);
    match(myParser::OR);
    setState(2706);
    match(myParser::OR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Compilation_condition_GEContext ------------------------------------------------------------------

myParser::Compilation_condition_GEContext::Compilation_condition_GEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Compilation_condition_GEContext::GT() {
  return getToken(myParser::GT, 0);
}

tree::TerminalNode* myParser::Compilation_condition_GEContext::EQUAL() {
  return getToken(myParser::EQUAL, 0);
}


size_t myParser::Compilation_condition_GEContext::getRuleIndex() const {
  return myParser::RuleCompilation_condition_GE;
}

void myParser::Compilation_condition_GEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompilation_condition_GE(this);
}

void myParser::Compilation_condition_GEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompilation_condition_GE(this);
}

myParser::Compilation_condition_GEContext* myParser::compilation_condition_GE() {
  Compilation_condition_GEContext *_localctx = _tracker.createInstance<Compilation_condition_GEContext>(_ctx, getState());
  enterRule(_localctx, 580, myParser::RuleCompilation_condition_GE);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2708);

    if (!(SwiftSupport.isOperator(_input,">="))) throw FailedPredicateException(this, "SwiftSupport.isOperator(_input,\">=\")");
    setState(2709);
    match(myParser::GT);
    setState(2710);
    match(myParser::EQUAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Compilation_condition_LContext ------------------------------------------------------------------

myParser::Compilation_condition_LContext::Compilation_condition_LContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Compilation_condition_LContext::LT() {
  return getToken(myParser::LT, 0);
}


size_t myParser::Compilation_condition_LContext::getRuleIndex() const {
  return myParser::RuleCompilation_condition_L;
}

void myParser::Compilation_condition_LContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompilation_condition_L(this);
}

void myParser::Compilation_condition_LContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompilation_condition_L(this);
}

myParser::Compilation_condition_LContext* myParser::compilation_condition_L() {
  Compilation_condition_LContext *_localctx = _tracker.createInstance<Compilation_condition_LContext>(_ctx, getState());
  enterRule(_localctx, 582, myParser::RuleCompilation_condition_L);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2712);

    if (!(SwiftSupport.isOperator(_input,"<"))) throw FailedPredicateException(this, "SwiftSupport.isOperator(_input,\"<\")");
    setState(2713);
    match(myParser::LT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Arrow_operatorContext ------------------------------------------------------------------

myParser::Arrow_operatorContext::Arrow_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Arrow_operatorContext::SUB() {
  return getToken(myParser::SUB, 0);
}

tree::TerminalNode* myParser::Arrow_operatorContext::GT() {
  return getToken(myParser::GT, 0);
}


size_t myParser::Arrow_operatorContext::getRuleIndex() const {
  return myParser::RuleArrow_operator;
}

void myParser::Arrow_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrow_operator(this);
}

void myParser::Arrow_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrow_operator(this);
}

myParser::Arrow_operatorContext* myParser::arrow_operator() {
  Arrow_operatorContext *_localctx = _tracker.createInstance<Arrow_operatorContext>(_ctx, getState());
  enterRule(_localctx, 584, myParser::RuleArrow_operator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2715);

    if (!(SwiftSupport.isOperator(_input,"->"))) throw FailedPredicateException(this, "SwiftSupport.isOperator(_input,\"->\")");
    setState(2716);
    match(myParser::SUB);
    setState(2717);
    match(myParser::GT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Range_operatorContext ------------------------------------------------------------------

myParser::Range_operatorContext::Range_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> myParser::Range_operatorContext::DOT() {
  return getTokens(myParser::DOT);
}

tree::TerminalNode* myParser::Range_operatorContext::DOT(size_t i) {
  return getToken(myParser::DOT, i);
}


size_t myParser::Range_operatorContext::getRuleIndex() const {
  return myParser::RuleRange_operator;
}

void myParser::Range_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRange_operator(this);
}

void myParser::Range_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRange_operator(this);
}

myParser::Range_operatorContext* myParser::range_operator() {
  Range_operatorContext *_localctx = _tracker.createInstance<Range_operatorContext>(_ctx, getState());
  enterRule(_localctx, 586, myParser::RuleRange_operator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2719);

    if (!(SwiftSupport.isOperator(_input,"..."))) throw FailedPredicateException(this, "SwiftSupport.isOperator(_input,\"...\")");
    setState(2720);
    match(myParser::DOT);
    setState(2721);
    match(myParser::DOT);
    setState(2722);
    match(myParser::DOT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Same_type_equalsContext ------------------------------------------------------------------

myParser::Same_type_equalsContext::Same_type_equalsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> myParser::Same_type_equalsContext::EQUAL() {
  return getTokens(myParser::EQUAL);
}

tree::TerminalNode* myParser::Same_type_equalsContext::EQUAL(size_t i) {
  return getToken(myParser::EQUAL, i);
}


size_t myParser::Same_type_equalsContext::getRuleIndex() const {
  return myParser::RuleSame_type_equals;
}

void myParser::Same_type_equalsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSame_type_equals(this);
}

void myParser::Same_type_equalsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSame_type_equals(this);
}

myParser::Same_type_equalsContext* myParser::same_type_equals() {
  Same_type_equalsContext *_localctx = _tracker.createInstance<Same_type_equalsContext>(_ctx, getState());
  enterRule(_localctx, 588, myParser::RuleSame_type_equals);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2724);

    if (!(SwiftSupport.isOperator(_input,"=="))) throw FailedPredicateException(this, "SwiftSupport.isOperator(_input,\"==\")");
    setState(2725);
    match(myParser::EQUAL);
    setState(2726);
    match(myParser::EQUAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Binary_operatorContext ------------------------------------------------------------------

myParser::Binary_operatorContext::Binary_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::OperatorContext* myParser::Binary_operatorContext::operator_() {
  return getRuleContext<myParser::OperatorContext>(0);
}


size_t myParser::Binary_operatorContext::getRuleIndex() const {
  return myParser::RuleBinary_operator;
}

void myParser::Binary_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinary_operator(this);
}

void myParser::Binary_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinary_operator(this);
}

myParser::Binary_operatorContext* myParser::binary_operator() {
  Binary_operatorContext *_localctx = _tracker.createInstance<Binary_operatorContext>(_ctx, getState());
  enterRule(_localctx, 590, myParser::RuleBinary_operator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2728);

    if (!(SwiftSupport.isBinaryOp(_input))) throw FailedPredicateException(this, "SwiftSupport.isBinaryOp(_input)");
    setState(2729);
    operator_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Prefix_operatorContext ------------------------------------------------------------------

myParser::Prefix_operatorContext::Prefix_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::OperatorContext* myParser::Prefix_operatorContext::operator_() {
  return getRuleContext<myParser::OperatorContext>(0);
}


size_t myParser::Prefix_operatorContext::getRuleIndex() const {
  return myParser::RulePrefix_operator;
}

void myParser::Prefix_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrefix_operator(this);
}

void myParser::Prefix_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrefix_operator(this);
}

myParser::Prefix_operatorContext* myParser::prefix_operator() {
  Prefix_operatorContext *_localctx = _tracker.createInstance<Prefix_operatorContext>(_ctx, getState());
  enterRule(_localctx, 592, myParser::RulePrefix_operator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2731);

    if (!(SwiftSupport.isPrefixOp(_input))) throw FailedPredicateException(this, "SwiftSupport.isPrefixOp(_input)");
    setState(2732);
    operator_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Postfix_operatorContext ------------------------------------------------------------------

myParser::Postfix_operatorContext::Postfix_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::OperatorContext* myParser::Postfix_operatorContext::operator_() {
  return getRuleContext<myParser::OperatorContext>(0);
}


size_t myParser::Postfix_operatorContext::getRuleIndex() const {
  return myParser::RulePostfix_operator;
}

void myParser::Postfix_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostfix_operator(this);
}

void myParser::Postfix_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostfix_operator(this);
}

myParser::Postfix_operatorContext* myParser::postfix_operator() {
  Postfix_operatorContext *_localctx = _tracker.createInstance<Postfix_operatorContext>(_ctx, getState());
  enterRule(_localctx, 594, myParser::RulePostfix_operator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2734);

    if (!(SwiftSupport.isPostfixOp(_input))) throw FailedPredicateException(this, "SwiftSupport.isPostfixOp(_input)");
    setState(2735);
    operator_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OperatorContext ------------------------------------------------------------------

myParser::OperatorContext::OperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Operator_headContext* myParser::OperatorContext::operator_head() {
  return getRuleContext<myParser::Operator_headContext>(0);
}

myParser::Operator_charactersContext* myParser::OperatorContext::operator_characters() {
  return getRuleContext<myParser::Operator_charactersContext>(0);
}

myParser::Dot_operator_headContext* myParser::OperatorContext::dot_operator_head() {
  return getRuleContext<myParser::Dot_operator_headContext>(0);
}

myParser::Dot_operator_charactersContext* myParser::OperatorContext::dot_operator_characters() {
  return getRuleContext<myParser::Dot_operator_charactersContext>(0);
}


size_t myParser::OperatorContext::getRuleIndex() const {
  return myParser::RuleOperator;
}

void myParser::OperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOperator(this);
}

void myParser::OperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOperator(this);
}

myParser::OperatorContext* myParser::operator_() {
  OperatorContext *_localctx = _tracker.createInstance<OperatorContext>(_ctx, getState());
  enterRule(_localctx, 596, myParser::RuleOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2744);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::LT:
      case myParser::GT:
      case myParser::BANG:
      case myParser::QUESTION:
      case myParser::AND:
      case myParser::SUB:
      case myParser::EQUAL:
      case myParser::OR:
      case myParser::DIV:
      case myParser::ADD:
      case myParser::MUL:
      case myParser::MOD:
      case myParser::CARET:
      case myParser::TILDE:
      case myParser::Operator_head_other: {
        enterOuterAlt(_localctx, 1);
        setState(2737);
        operator_head();
        setState(2739);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 332, _ctx)) {
        case 1: {
          setState(2738);
          operator_characters();
          break;
        }

        default:
          break;
        }
        break;
      }

      case myParser::DOT: {
        enterOuterAlt(_localctx, 2);
        setState(2741);
        dot_operator_head();
        setState(2742);
        dot_operator_characters();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Operator_headContext ------------------------------------------------------------------

myParser::Operator_headContext::Operator_headContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Operator_headContext::DIV() {
  return getToken(myParser::DIV, 0);
}

tree::TerminalNode* myParser::Operator_headContext::EQUAL() {
  return getToken(myParser::EQUAL, 0);
}

tree::TerminalNode* myParser::Operator_headContext::SUB() {
  return getToken(myParser::SUB, 0);
}

tree::TerminalNode* myParser::Operator_headContext::ADD() {
  return getToken(myParser::ADD, 0);
}

tree::TerminalNode* myParser::Operator_headContext::BANG() {
  return getToken(myParser::BANG, 0);
}

tree::TerminalNode* myParser::Operator_headContext::MUL() {
  return getToken(myParser::MUL, 0);
}

tree::TerminalNode* myParser::Operator_headContext::MOD() {
  return getToken(myParser::MOD, 0);
}

tree::TerminalNode* myParser::Operator_headContext::AND() {
  return getToken(myParser::AND, 0);
}

tree::TerminalNode* myParser::Operator_headContext::OR() {
  return getToken(myParser::OR, 0);
}

tree::TerminalNode* myParser::Operator_headContext::LT() {
  return getToken(myParser::LT, 0);
}

tree::TerminalNode* myParser::Operator_headContext::GT() {
  return getToken(myParser::GT, 0);
}

tree::TerminalNode* myParser::Operator_headContext::CARET() {
  return getToken(myParser::CARET, 0);
}

tree::TerminalNode* myParser::Operator_headContext::TILDE() {
  return getToken(myParser::TILDE, 0);
}

tree::TerminalNode* myParser::Operator_headContext::QUESTION() {
  return getToken(myParser::QUESTION, 0);
}

tree::TerminalNode* myParser::Operator_headContext::Operator_head_other() {
  return getToken(myParser::Operator_head_other, 0);
}


size_t myParser::Operator_headContext::getRuleIndex() const {
  return myParser::RuleOperator_head;
}

void myParser::Operator_headContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOperator_head(this);
}

void myParser::Operator_headContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOperator_head(this);
}

myParser::Operator_headContext* myParser::operator_head() {
  Operator_headContext *_localctx = _tracker.createInstance<Operator_headContext>(_ctx, getState());
  enterRule(_localctx, 598, myParser::RuleOperator_head);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2748);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::LT:
      case myParser::GT:
      case myParser::BANG:
      case myParser::QUESTION:
      case myParser::AND:
      case myParser::SUB:
      case myParser::EQUAL:
      case myParser::OR:
      case myParser::DIV:
      case myParser::ADD:
      case myParser::MUL:
      case myParser::MOD:
      case myParser::CARET:
      case myParser::TILDE: {
        enterOuterAlt(_localctx, 1);
        setState(2746);
        _la = _input->LA(1);
        if (!(((((_la - 148) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 148)) & 65499) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case myParser::Operator_head_other: {
        enterOuterAlt(_localctx, 2);
        setState(2747);
        match(myParser::Operator_head_other);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Operator_characterContext ------------------------------------------------------------------

myParser::Operator_characterContext::Operator_characterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Operator_headContext* myParser::Operator_characterContext::operator_head() {
  return getRuleContext<myParser::Operator_headContext>(0);
}

tree::TerminalNode* myParser::Operator_characterContext::Operator_following_character() {
  return getToken(myParser::Operator_following_character, 0);
}


size_t myParser::Operator_characterContext::getRuleIndex() const {
  return myParser::RuleOperator_character;
}

void myParser::Operator_characterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOperator_character(this);
}

void myParser::Operator_characterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOperator_character(this);
}

myParser::Operator_characterContext* myParser::operator_character() {
  Operator_characterContext *_localctx = _tracker.createInstance<Operator_characterContext>(_ctx, getState());
  enterRule(_localctx, 600, myParser::RuleOperator_character);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2752);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::LT:
      case myParser::GT:
      case myParser::BANG:
      case myParser::QUESTION:
      case myParser::AND:
      case myParser::SUB:
      case myParser::EQUAL:
      case myParser::OR:
      case myParser::DIV:
      case myParser::ADD:
      case myParser::MUL:
      case myParser::MOD:
      case myParser::CARET:
      case myParser::TILDE:
      case myParser::Operator_head_other: {
        enterOuterAlt(_localctx, 1);
        setState(2750);
        operator_head();
        break;
      }

      case myParser::Operator_following_character: {
        enterOuterAlt(_localctx, 2);
        setState(2751);
        match(myParser::Operator_following_character);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Operator_charactersContext ------------------------------------------------------------------

myParser::Operator_charactersContext::Operator_charactersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Operator_characterContext *> myParser::Operator_charactersContext::operator_character() {
  return getRuleContexts<myParser::Operator_characterContext>();
}

myParser::Operator_characterContext* myParser::Operator_charactersContext::operator_character(size_t i) {
  return getRuleContext<myParser::Operator_characterContext>(i);
}


size_t myParser::Operator_charactersContext::getRuleIndex() const {
  return myParser::RuleOperator_characters;
}

void myParser::Operator_charactersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOperator_characters(this);
}

void myParser::Operator_charactersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOperator_characters(this);
}

myParser::Operator_charactersContext* myParser::operator_characters() {
  Operator_charactersContext *_localctx = _tracker.createInstance<Operator_charactersContext>(_ctx, getState());
  enterRule(_localctx, 602, myParser::RuleOperator_characters);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2756); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(2754);

              if (!(_input.get(_input.index()-1).getType()!=WS)) throw FailedPredicateException(this, "_input.get(_input.index()-1).getType()!=WS");
              setState(2755);
              operator_character();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(2758); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 336, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dot_operator_headContext ------------------------------------------------------------------

myParser::Dot_operator_headContext::Dot_operator_headContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Dot_operator_headContext::DOT() {
  return getToken(myParser::DOT, 0);
}


size_t myParser::Dot_operator_headContext::getRuleIndex() const {
  return myParser::RuleDot_operator_head;
}

void myParser::Dot_operator_headContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDot_operator_head(this);
}

void myParser::Dot_operator_headContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDot_operator_head(this);
}

myParser::Dot_operator_headContext* myParser::dot_operator_head() {
  Dot_operator_headContext *_localctx = _tracker.createInstance<Dot_operator_headContext>(_ctx, getState());
  enterRule(_localctx, 604, myParser::RuleDot_operator_head);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2760);
    match(myParser::DOT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dot_operator_characterContext ------------------------------------------------------------------

myParser::Dot_operator_characterContext::Dot_operator_characterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Dot_operator_characterContext::DOT() {
  return getToken(myParser::DOT, 0);
}

myParser::Operator_characterContext* myParser::Dot_operator_characterContext::operator_character() {
  return getRuleContext<myParser::Operator_characterContext>(0);
}


size_t myParser::Dot_operator_characterContext::getRuleIndex() const {
  return myParser::RuleDot_operator_character;
}

void myParser::Dot_operator_characterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDot_operator_character(this);
}

void myParser::Dot_operator_characterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDot_operator_character(this);
}

myParser::Dot_operator_characterContext* myParser::dot_operator_character() {
  Dot_operator_characterContext *_localctx = _tracker.createInstance<Dot_operator_characterContext>(_ctx, getState());
  enterRule(_localctx, 606, myParser::RuleDot_operator_character);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2764);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::DOT: {
        enterOuterAlt(_localctx, 1);
        setState(2762);
        match(myParser::DOT);
        break;
      }

      case myParser::LT:
      case myParser::GT:
      case myParser::BANG:
      case myParser::QUESTION:
      case myParser::AND:
      case myParser::SUB:
      case myParser::EQUAL:
      case myParser::OR:
      case myParser::DIV:
      case myParser::ADD:
      case myParser::MUL:
      case myParser::MOD:
      case myParser::CARET:
      case myParser::TILDE:
      case myParser::Operator_head_other:
      case myParser::Operator_following_character: {
        enterOuterAlt(_localctx, 2);
        setState(2763);
        operator_character();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dot_operator_charactersContext ------------------------------------------------------------------

myParser::Dot_operator_charactersContext::Dot_operator_charactersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Dot_operator_characterContext *> myParser::Dot_operator_charactersContext::dot_operator_character() {
  return getRuleContexts<myParser::Dot_operator_characterContext>();
}

myParser::Dot_operator_characterContext* myParser::Dot_operator_charactersContext::dot_operator_character(size_t i) {
  return getRuleContext<myParser::Dot_operator_characterContext>(i);
}


size_t myParser::Dot_operator_charactersContext::getRuleIndex() const {
  return myParser::RuleDot_operator_characters;
}

void myParser::Dot_operator_charactersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDot_operator_characters(this);
}

void myParser::Dot_operator_charactersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDot_operator_characters(this);
}

myParser::Dot_operator_charactersContext* myParser::dot_operator_characters() {
  Dot_operator_charactersContext *_localctx = _tracker.createInstance<Dot_operator_charactersContext>(_ctx, getState());
  enterRule(_localctx, 608, myParser::RuleDot_operator_characters);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2768); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(2766);

              if (!(_input.get(_input.index()-1).getType()!=WS)) throw FailedPredicateException(this, "_input.get(_input.index()-1).getType()!=WS");
              setState(2767);
              dot_operator_character();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(2770); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 338, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

myParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Numeric_literalContext* myParser::LiteralContext::numeric_literal() {
  return getRuleContext<myParser::Numeric_literalContext>(0);
}

myParser::String_literalContext* myParser::LiteralContext::string_literal() {
  return getRuleContext<myParser::String_literalContext>(0);
}

myParser::Boolean_literalContext* myParser::LiteralContext::boolean_literal() {
  return getRuleContext<myParser::Boolean_literalContext>(0);
}

myParser::Nil_literalContext* myParser::LiteralContext::nil_literal() {
  return getRuleContext<myParser::Nil_literalContext>(0);
}


size_t myParser::LiteralContext::getRuleIndex() const {
  return myParser::RuleLiteral;
}

void myParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void myParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}

myParser::LiteralContext* myParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 610, myParser::RuleLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2776);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 339, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2772);
      numeric_literal();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2773);
      string_literal();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2774);
      boolean_literal();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2775);
      nil_literal();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Numeric_literalContext ------------------------------------------------------------------

myParser::Numeric_literalContext::Numeric_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Integer_literalContext* myParser::Numeric_literalContext::integer_literal() {
  return getRuleContext<myParser::Integer_literalContext>(0);
}

myParser::Negate_prefix_operatorContext* myParser::Numeric_literalContext::negate_prefix_operator() {
  return getRuleContext<myParser::Negate_prefix_operatorContext>(0);
}

tree::TerminalNode* myParser::Numeric_literalContext::Floating_point_literal() {
  return getToken(myParser::Floating_point_literal, 0);
}


size_t myParser::Numeric_literalContext::getRuleIndex() const {
  return myParser::RuleNumeric_literal;
}

void myParser::Numeric_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumeric_literal(this);
}

void myParser::Numeric_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumeric_literal(this);
}

myParser::Numeric_literalContext* myParser::numeric_literal() {
  Numeric_literalContext *_localctx = _tracker.createInstance<Numeric_literalContext>(_ctx, getState());
  enterRule(_localctx, 612, myParser::RuleNumeric_literal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2786);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 342, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2779);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 340, _ctx)) {
      case 1: {
        setState(2778);
        negate_prefix_operator();
        break;
      }

      default:
        break;
      }
      setState(2781);
      integer_literal();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2783);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 341, _ctx)) {
      case 1: {
        setState(2782);
        negate_prefix_operator();
        break;
      }

      default:
        break;
      }
      setState(2785);
      match(myParser::Floating_point_literal);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Boolean_literalContext ------------------------------------------------------------------

myParser::Boolean_literalContext::Boolean_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Boolean_literalContext::TRUE() {
  return getToken(myParser::TRUE, 0);
}

tree::TerminalNode* myParser::Boolean_literalContext::FALSE() {
  return getToken(myParser::FALSE, 0);
}


size_t myParser::Boolean_literalContext::getRuleIndex() const {
  return myParser::RuleBoolean_literal;
}

void myParser::Boolean_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBoolean_literal(this);
}

void myParser::Boolean_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBoolean_literal(this);
}

myParser::Boolean_literalContext* myParser::boolean_literal() {
  Boolean_literalContext *_localctx = _tracker.createInstance<Boolean_literalContext>(_ctx, getState());
  enterRule(_localctx, 614, myParser::RuleBoolean_literal);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2788);
    _la = _input->LA(1);
    if (!(_la == myParser::FALSE

    || _la == myParser::TRUE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nil_literalContext ------------------------------------------------------------------

myParser::Nil_literalContext::Nil_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Nil_literalContext::NIL() {
  return getToken(myParser::NIL, 0);
}


size_t myParser::Nil_literalContext::getRuleIndex() const {
  return myParser::RuleNil_literal;
}

void myParser::Nil_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNil_literal(this);
}

void myParser::Nil_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNil_literal(this);
}

myParser::Nil_literalContext* myParser::nil_literal() {
  Nil_literalContext *_localctx = _tracker.createInstance<Nil_literalContext>(_ctx, getState());
  enterRule(_localctx, 616, myParser::RuleNil_literal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2790);
    match(myParser::NIL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Integer_literalContext ------------------------------------------------------------------

myParser::Integer_literalContext::Integer_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Integer_literalContext::Decimal_digits() {
  return getToken(myParser::Decimal_digits, 0);
}

tree::TerminalNode* myParser::Integer_literalContext::Decimal_literal() {
  return getToken(myParser::Decimal_literal, 0);
}

tree::TerminalNode* myParser::Integer_literalContext::Binary_literal() {
  return getToken(myParser::Binary_literal, 0);
}

tree::TerminalNode* myParser::Integer_literalContext::Octal_literal() {
  return getToken(myParser::Octal_literal, 0);
}

tree::TerminalNode* myParser::Integer_literalContext::Hexadecimal_literal() {
  return getToken(myParser::Hexadecimal_literal, 0);
}


size_t myParser::Integer_literalContext::getRuleIndex() const {
  return myParser::RuleInteger_literal;
}

void myParser::Integer_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInteger_literal(this);
}

void myParser::Integer_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInteger_literal(this);
}

myParser::Integer_literalContext* myParser::integer_literal() {
  Integer_literalContext *_localctx = _tracker.createInstance<Integer_literalContext>(_ctx, getState());
  enterRule(_localctx, 618, myParser::RuleInteger_literal);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2792);
    _la = _input->LA(1);
    if (!(((((_la - 170) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 170)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- String_literalContext ------------------------------------------------------------------

myParser::String_literalContext::String_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Extended_string_literalContext* myParser::String_literalContext::extended_string_literal() {
  return getRuleContext<myParser::Extended_string_literalContext>(0);
}

myParser::Interpolated_string_literalContext* myParser::String_literalContext::interpolated_string_literal() {
  return getRuleContext<myParser::Interpolated_string_literalContext>(0);
}

myParser::Static_string_literalContext* myParser::String_literalContext::static_string_literal() {
  return getRuleContext<myParser::Static_string_literalContext>(0);
}


size_t myParser::String_literalContext::getRuleIndex() const {
  return myParser::RuleString_literal;
}

void myParser::String_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterString_literal(this);
}

void myParser::String_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitString_literal(this);
}

myParser::String_literalContext* myParser::string_literal() {
  String_literalContext *_localctx = _tracker.createInstance<String_literalContext>(_ctx, getState());
  enterRule(_localctx, 620, myParser::RuleString_literal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2797);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 343, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2794);
      extended_string_literal();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2795);
      interpolated_string_literal();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2796);
      static_string_literal();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Extended_string_literalContext ------------------------------------------------------------------

myParser::Extended_string_literalContext::Extended_string_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Extended_string_literalContext::Multi_line_extended_string_open() {
  return getToken(myParser::Multi_line_extended_string_open, 0);
}

tree::TerminalNode* myParser::Extended_string_literalContext::Multi_line_extended_string_close() {
  return getToken(myParser::Multi_line_extended_string_close, 0);
}

std::vector<tree::TerminalNode *> myParser::Extended_string_literalContext::Quoted_multi_line_extended_text() {
  return getTokens(myParser::Quoted_multi_line_extended_text);
}

tree::TerminalNode* myParser::Extended_string_literalContext::Quoted_multi_line_extended_text(size_t i) {
  return getToken(myParser::Quoted_multi_line_extended_text, i);
}

tree::TerminalNode* myParser::Extended_string_literalContext::Single_line_extended_string_open() {
  return getToken(myParser::Single_line_extended_string_open, 0);
}

tree::TerminalNode* myParser::Extended_string_literalContext::Single_line_extended_string_close() {
  return getToken(myParser::Single_line_extended_string_close, 0);
}

std::vector<tree::TerminalNode *> myParser::Extended_string_literalContext::Quoted_single_line_extended_text() {
  return getTokens(myParser::Quoted_single_line_extended_text);
}

tree::TerminalNode* myParser::Extended_string_literalContext::Quoted_single_line_extended_text(size_t i) {
  return getToken(myParser::Quoted_single_line_extended_text, i);
}


size_t myParser::Extended_string_literalContext::getRuleIndex() const {
  return myParser::RuleExtended_string_literal;
}

void myParser::Extended_string_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExtended_string_literal(this);
}

void myParser::Extended_string_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExtended_string_literal(this);
}

myParser::Extended_string_literalContext* myParser::extended_string_literal() {
  Extended_string_literalContext *_localctx = _tracker.createInstance<Extended_string_literalContext>(_ctx, getState());
  enterRule(_localctx, 622, myParser::RuleExtended_string_literal);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2813);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Multi_line_extended_string_open: {
        enterOuterAlt(_localctx, 1);
        setState(2799);
        match(myParser::Multi_line_extended_string_open);
        setState(2801); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(2800);
          match(myParser::Quoted_multi_line_extended_text);
          setState(2803); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == myParser::Quoted_multi_line_extended_text);
        setState(2805);
        match(myParser::Multi_line_extended_string_close);
        break;
      }

      case myParser::Single_line_extended_string_open: {
        enterOuterAlt(_localctx, 2);
        setState(2806);
        match(myParser::Single_line_extended_string_open);
        setState(2808); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(2807);
          match(myParser::Quoted_single_line_extended_text);
          setState(2810); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == myParser::Quoted_single_line_extended_text);
        setState(2812);
        match(myParser::Single_line_extended_string_close);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Static_string_literalContext ------------------------------------------------------------------

myParser::Static_string_literalContext::Static_string_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Static_string_literalContext::Single_line_string_open() {
  return getToken(myParser::Single_line_string_open, 0);
}

tree::TerminalNode* myParser::Static_string_literalContext::Single_line_string_close() {
  return getToken(myParser::Single_line_string_close, 0);
}

std::vector<tree::TerminalNode *> myParser::Static_string_literalContext::Quoted_single_line_text() {
  return getTokens(myParser::Quoted_single_line_text);
}

tree::TerminalNode* myParser::Static_string_literalContext::Quoted_single_line_text(size_t i) {
  return getToken(myParser::Quoted_single_line_text, i);
}

tree::TerminalNode* myParser::Static_string_literalContext::Multi_line_string_open() {
  return getToken(myParser::Multi_line_string_open, 0);
}

tree::TerminalNode* myParser::Static_string_literalContext::Multi_line_string_close() {
  return getToken(myParser::Multi_line_string_close, 0);
}

std::vector<tree::TerminalNode *> myParser::Static_string_literalContext::Quoted_multi_line_text() {
  return getTokens(myParser::Quoted_multi_line_text);
}

tree::TerminalNode* myParser::Static_string_literalContext::Quoted_multi_line_text(size_t i) {
  return getToken(myParser::Quoted_multi_line_text, i);
}


size_t myParser::Static_string_literalContext::getRuleIndex() const {
  return myParser::RuleStatic_string_literal;
}

void myParser::Static_string_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatic_string_literal(this);
}

void myParser::Static_string_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatic_string_literal(this);
}

myParser::Static_string_literalContext* myParser::static_string_literal() {
  Static_string_literalContext *_localctx = _tracker.createInstance<Static_string_literalContext>(_ctx, getState());
  enterRule(_localctx, 624, myParser::RuleStatic_string_literal);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2831);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Single_line_string_open: {
        enterOuterAlt(_localctx, 1);
        setState(2815);
        match(myParser::Single_line_string_open);
        setState(2819);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::Quoted_single_line_text) {
          setState(2816);
          match(myParser::Quoted_single_line_text);
          setState(2821);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2822);
        match(myParser::Single_line_string_close);
        break;
      }

      case myParser::Multi_line_string_open: {
        enterOuterAlt(_localctx, 2);
        setState(2823);
        match(myParser::Multi_line_string_open);
        setState(2827);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::Quoted_multi_line_text) {
          setState(2824);
          match(myParser::Quoted_multi_line_text);
          setState(2829);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2830);
        match(myParser::Multi_line_string_close);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Interpolated_string_literalContext ------------------------------------------------------------------

myParser::Interpolated_string_literalContext::Interpolated_string_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Interpolated_string_literalContext::Single_line_string_open() {
  return getToken(myParser::Single_line_string_open, 0);
}

tree::TerminalNode* myParser::Interpolated_string_literalContext::Single_line_string_close() {
  return getToken(myParser::Single_line_string_close, 0);
}

std::vector<tree::TerminalNode *> myParser::Interpolated_string_literalContext::Quoted_single_line_text() {
  return getTokens(myParser::Quoted_single_line_text);
}

tree::TerminalNode* myParser::Interpolated_string_literalContext::Quoted_single_line_text(size_t i) {
  return getToken(myParser::Quoted_single_line_text, i);
}

std::vector<tree::TerminalNode *> myParser::Interpolated_string_literalContext::Interpolataion_single_line() {
  return getTokens(myParser::Interpolataion_single_line);
}

tree::TerminalNode* myParser::Interpolated_string_literalContext::Interpolataion_single_line(size_t i) {
  return getToken(myParser::Interpolataion_single_line, i);
}

std::vector<tree::TerminalNode *> myParser::Interpolated_string_literalContext::RPAREN() {
  return getTokens(myParser::RPAREN);
}

tree::TerminalNode* myParser::Interpolated_string_literalContext::RPAREN(size_t i) {
  return getToken(myParser::RPAREN, i);
}

std::vector<myParser::ExpressionContext *> myParser::Interpolated_string_literalContext::expression() {
  return getRuleContexts<myParser::ExpressionContext>();
}

myParser::ExpressionContext* myParser::Interpolated_string_literalContext::expression(size_t i) {
  return getRuleContext<myParser::ExpressionContext>(i);
}

std::vector<myParser::Tuple_elementContext *> myParser::Interpolated_string_literalContext::tuple_element() {
  return getRuleContexts<myParser::Tuple_elementContext>();
}

myParser::Tuple_elementContext* myParser::Interpolated_string_literalContext::tuple_element(size_t i) {
  return getRuleContext<myParser::Tuple_elementContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Interpolated_string_literalContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Interpolated_string_literalContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}

std::vector<myParser::Tuple_element_listContext *> myParser::Interpolated_string_literalContext::tuple_element_list() {
  return getRuleContexts<myParser::Tuple_element_listContext>();
}

myParser::Tuple_element_listContext* myParser::Interpolated_string_literalContext::tuple_element_list(size_t i) {
  return getRuleContext<myParser::Tuple_element_listContext>(i);
}

tree::TerminalNode* myParser::Interpolated_string_literalContext::Multi_line_string_open() {
  return getToken(myParser::Multi_line_string_open, 0);
}

tree::TerminalNode* myParser::Interpolated_string_literalContext::Multi_line_string_close() {
  return getToken(myParser::Multi_line_string_close, 0);
}

std::vector<tree::TerminalNode *> myParser::Interpolated_string_literalContext::Quoted_multi_line_text() {
  return getTokens(myParser::Quoted_multi_line_text);
}

tree::TerminalNode* myParser::Interpolated_string_literalContext::Quoted_multi_line_text(size_t i) {
  return getToken(myParser::Quoted_multi_line_text, i);
}

std::vector<tree::TerminalNode *> myParser::Interpolated_string_literalContext::Interpolataion_multi_line() {
  return getTokens(myParser::Interpolataion_multi_line);
}

tree::TerminalNode* myParser::Interpolated_string_literalContext::Interpolataion_multi_line(size_t i) {
  return getToken(myParser::Interpolataion_multi_line, i);
}


size_t myParser::Interpolated_string_literalContext::getRuleIndex() const {
  return myParser::RuleInterpolated_string_literal;
}

void myParser::Interpolated_string_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterpolated_string_literal(this);
}

void myParser::Interpolated_string_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterpolated_string_literal(this);
}

myParser::Interpolated_string_literalContext* myParser::interpolated_string_literal() {
  Interpolated_string_literalContext *_localctx = _tracker.createInstance<Interpolated_string_literalContext>(_ctx, getState());
  enterRule(_localctx, 626, myParser::RuleInterpolated_string_literal);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2869);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Single_line_string_open: {
        enterOuterAlt(_localctx, 1);
        setState(2833);
        match(myParser::Single_line_string_open);
        setState(2847);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::Interpolataion_single_line

        || _la == myParser::Quoted_single_line_text) {
          setState(2845);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case myParser::Quoted_single_line_text: {
              setState(2834);
              match(myParser::Quoted_single_line_text);
              break;
            }

            case myParser::Interpolataion_single_line: {
              setState(2835);
              match(myParser::Interpolataion_single_line);
              setState(2841);
              _errHandler->sync(this);
              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 350, _ctx)) {
              case 1: {
                setState(2836);
                expression();
                break;
              }

              case 2: {
                setState(2837);
                tuple_element();
                setState(2838);
                match(myParser::COMMA);
                setState(2839);
                tuple_element_list();
                break;
              }

              default:
                break;
              }
              setState(2843);
              match(myParser::RPAREN);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          setState(2849);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2850);
        match(myParser::Single_line_string_close);
        break;
      }

      case myParser::Multi_line_string_open: {
        enterOuterAlt(_localctx, 2);
        setState(2851);
        match(myParser::Multi_line_string_open);
        setState(2865);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::Interpolataion_multi_line

        || _la == myParser::Quoted_multi_line_text) {
          setState(2863);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case myParser::Quoted_multi_line_text: {
              setState(2852);
              match(myParser::Quoted_multi_line_text);
              break;
            }

            case myParser::Interpolataion_multi_line: {
              setState(2853);
              match(myParser::Interpolataion_multi_line);
              setState(2859);
              _errHandler->sync(this);
              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 353, _ctx)) {
              case 1: {
                setState(2854);
                expression();
                break;
              }

              case 2: {
                setState(2855);
                tuple_element();
                setState(2856);
                match(myParser::COMMA);
                setState(2857);
                tuple_element_list();
                break;
              }

              default:
                break;
              }
              setState(2861);
              match(myParser::RPAREN);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          setState(2867);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2868);
        match(myParser::Multi_line_string_close);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool myParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 2: return statementsSempred(antlrcpp::downCast<StatementsContext *>(context), predicateIndex);
    case 49: return compilation_conditionSempred(antlrcpp::downCast<Compilation_conditionContext *>(context), predicateIndex);
    case 184: return patternSempred(antlrcpp::downCast<PatternContext *>(context), predicateIndex);
    case 200: return balanced_token_punctuationSempred(antlrcpp::downCast<Balanced_token_punctuationContext *>(context), predicateIndex);
    case 251: return forced_value_suffixSempred(antlrcpp::downCast<Forced_value_suffixContext *>(context), predicateIndex);
    case 252: return optional_chaining_suffixSempred(antlrcpp::downCast<Optional_chaining_suffixContext *>(context), predicateIndex);
    case 261: return typeSempred(antlrcpp::downCast<TypeContext *>(context), predicateIndex);
    case 277: return trailing_composition_andSempred(antlrcpp::downCast<Trailing_composition_andContext *>(context), predicateIndex);
    case 286: return assignment_operatorSempred(antlrcpp::downCast<Assignment_operatorContext *>(context), predicateIndex);
    case 287: return negate_prefix_operatorSempred(antlrcpp::downCast<Negate_prefix_operatorContext *>(context), predicateIndex);
    case 288: return compilation_condition_ANDSempred(antlrcpp::downCast<Compilation_condition_ANDContext *>(context), predicateIndex);
    case 289: return compilation_condition_ORSempred(antlrcpp::downCast<Compilation_condition_ORContext *>(context), predicateIndex);
    case 290: return compilation_condition_GESempred(antlrcpp::downCast<Compilation_condition_GEContext *>(context), predicateIndex);
    case 291: return compilation_condition_LSempred(antlrcpp::downCast<Compilation_condition_LContext *>(context), predicateIndex);
    case 292: return arrow_operatorSempred(antlrcpp::downCast<Arrow_operatorContext *>(context), predicateIndex);
    case 293: return range_operatorSempred(antlrcpp::downCast<Range_operatorContext *>(context), predicateIndex);
    case 294: return same_type_equalsSempred(antlrcpp::downCast<Same_type_equalsContext *>(context), predicateIndex);
    case 295: return binary_operatorSempred(antlrcpp::downCast<Binary_operatorContext *>(context), predicateIndex);
    case 296: return prefix_operatorSempred(antlrcpp::downCast<Prefix_operatorContext *>(context), predicateIndex);
    case 297: return postfix_operatorSempred(antlrcpp::downCast<Postfix_operatorContext *>(context), predicateIndex);
    case 301: return operator_charactersSempred(antlrcpp::downCast<Operator_charactersContext *>(context), predicateIndex);
    case 304: return dot_operator_charactersSempred(antlrcpp::downCast<Dot_operator_charactersContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool myParser::statementsSempred(StatementsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return SwiftSupport.isSeparatedStatement(_input, _localctx->indexBefore);

  default:
    break;
  }
  return true;
}

bool myParser::compilation_conditionSempred(Compilation_conditionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool myParser::patternSempred(PatternContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 2: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool myParser::balanced_token_punctuationSempred(Balanced_token_punctuationContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 3: return SwiftSupport.isPrefixOp(_input);
    case 4: return SwiftSupport.isPostfixOp(_input);

  default:
    break;
  }
  return true;
}

bool myParser::forced_value_suffixSempred(Forced_value_suffixContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 5: return !SwiftSupport.isBinaryOp(_input);

  default:
    break;
  }
  return true;
}

bool myParser::optional_chaining_suffixSempred(Optional_chaining_suffixContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 6: return !SwiftSupport.isBinaryOp(_input);

  default:
    break;
  }
  return true;
}

bool myParser::typeSempred(TypeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 7: return precpred(_ctx, 4);
    case 8: return !SwiftSupport.isBinaryOp(_input);
    case 9: return !SwiftSupport.isBinaryOp(_input);

  default:
    break;
  }
  return true;
}

bool myParser::trailing_composition_andSempred(Trailing_composition_andContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 10: return !SwiftSupport.isBinaryOp(_input);

  default:
    break;
  }
  return true;
}

bool myParser::assignment_operatorSempred(Assignment_operatorContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 11: return SwiftSupport.isBinaryOp(_input);

  default:
    break;
  }
  return true;
}

bool myParser::negate_prefix_operatorSempred(Negate_prefix_operatorContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 12: return SwiftSupport.isPrefixOp(_input);

  default:
    break;
  }
  return true;
}

bool myParser::compilation_condition_ANDSempred(Compilation_condition_ANDContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 13: return SwiftSupport.isOperator(_input,"&&");

  default:
    break;
  }
  return true;
}

bool myParser::compilation_condition_ORSempred(Compilation_condition_ORContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 14: return SwiftSupport.isOperator(_input,"||");

  default:
    break;
  }
  return true;
}

bool myParser::compilation_condition_GESempred(Compilation_condition_GEContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 15: return SwiftSupport.isOperator(_input,">=");

  default:
    break;
  }
  return true;
}

bool myParser::compilation_condition_LSempred(Compilation_condition_LContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 16: return SwiftSupport.isOperator(_input,"<");

  default:
    break;
  }
  return true;
}

bool myParser::arrow_operatorSempred(Arrow_operatorContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 17: return SwiftSupport.isOperator(_input,"->");

  default:
    break;
  }
  return true;
}

bool myParser::range_operatorSempred(Range_operatorContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 18: return SwiftSupport.isOperator(_input,"...");

  default:
    break;
  }
  return true;
}

bool myParser::same_type_equalsSempred(Same_type_equalsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 19: return SwiftSupport.isOperator(_input,"==");

  default:
    break;
  }
  return true;
}

bool myParser::binary_operatorSempred(Binary_operatorContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 20: return SwiftSupport.isBinaryOp(_input);

  default:
    break;
  }
  return true;
}

bool myParser::prefix_operatorSempred(Prefix_operatorContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 21: return SwiftSupport.isPrefixOp(_input);

  default:
    break;
  }
  return true;
}

bool myParser::postfix_operatorSempred(Postfix_operatorContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 22: return SwiftSupport.isPostfixOp(_input);

  default:
    break;
  }
  return true;
}

bool myParser::operator_charactersSempred(Operator_charactersContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 23: return _input.get(_input.index()-1).getType()!=WS;

  default:
    break;
  }
  return true;
}

bool myParser::dot_operator_charactersSempred(Dot_operator_charactersContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 24: return _input.get(_input.index()-1).getType()!=WS;

  default:
    break;
  }
  return true;
}

void myParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  myparserParserInitialize();
#else
  ::antlr4::internal::call_once(myparserParserOnceFlag, myparserParserInitialize);
#endif
}

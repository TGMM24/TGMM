
// Generated from myParser.g4 by ANTLR 4.11.1


#include "myParserListener.h"

#include "myParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct MyParserStaticData final {
  MyParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  MyParserStaticData(const MyParserStaticData&) = delete;
  MyParserStaticData(MyParserStaticData&&) = delete;
  MyParserStaticData& operator=(const MyParserStaticData&) = delete;
  MyParserStaticData& operator=(MyParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag myparserParserOnceFlag;
MyParserStaticData *myparserParserStaticData = nullptr;

void myparserParserInitialize() {
  assert(myparserParserStaticData == nullptr);
  auto staticData = std::make_unique<MyParserStaticData>(
    std::vector<std::string>{
      "kotlinFile", "script", "preamble", "fileAnnotations", "fileAnnotation", 
      "packageHeader", "importList", "importHeader", "importAlias", "topLevelObject", 
      "classDeclaration", "primaryConstructor", "classParameters", "classParameter", 
      "delegationSpecifiers", "delegationSpecifier", "constructorInvocation", 
      "explicitDelegation", "classBody", "classMemberDeclaration", "anonymousInitializer", 
      "secondaryConstructor", "constructorDelegationCall", "enumClassBody", 
      "enumEntries", "enumEntry", "functionDeclaration", "functionValueParameters", 
      "functionValueParameter", "parameter", "functionBody", "objectDeclaration", 
      "companionObject", "propertyDeclaration", "multiVariableDeclaration", 
      "variableDeclaration", "getter", "setter", "typeAlias", "typeParameters", 
      "typeParameter", "type", "typeModifierList", "parenthesizedType", 
      "nullableType", "typeReference", "functionType", "functionTypeReceiver", 
      "userType", "simpleUserType", "functionTypeParameters", "typeConstraints", 
      "typeConstraint", "block", "statements", "statement", "blockLevelExpression", 
      "declaration", "expression", "disjunction", "conjunction", "equalityComparison", 
      "comparison", "namedInfix", "elvisExpression", "infixFunctionCall", 
      "rangeExpression", "additiveExpression", "multiplicativeExpression", 
      "typeRHS", "prefixUnaryExpression", "postfixUnaryExpression", "atomicExpression", 
      "parenthesizedExpression", "callSuffix", "annotatedLambda", "arrayAccess", 
      "valueArguments", "typeArguments", "typeProjection", "typeProjectionModifierList", 
      "valueArgument", "literalConstant", "stringLiteral", "lineStringLiteral", 
      "multiLineStringLiteral", "lineStringContent", "lineStringExpression", 
      "multiLineStringContent", "multiLineStringExpression", "functionLiteral", 
      "lambdaParameters", "lambdaParameter", "objectLiteral", "collectionLiteral", 
      "thisExpression", "superExpression", "conditionalExpression", "ifExpression", 
      "controlStructureBody", "whenExpression", "whenEntry", "whenCondition", 
      "rangeTest", "typeTest", "tryExpression", "catchBlock", "finallyBlock", 
      "loopExpression", "forExpression", "whileExpression", "doWhileExpression", 
      "jumpExpression", "callableReference", "assignmentOperator", "equalityOperation", 
      "comparisonOperator", "inOperator", "isOperator", "additiveOperator", 
      "multiplicativeOperation", "typeOperation", "prefixUnaryOperation", 
      "postfixUnaryOperation", "memberAccessOperator", "modifierList", "modifier", 
      "classModifier", "memberModifier", "visibilityModifier", "varianceAnnotation", 
      "functionModifier", "propertyModifier", "inheritanceModifier", "parameterModifier", 
      "typeParameterModifier", "labelDefinition", "annotations", "annotation", 
      "annotationList", "annotationUseSiteTarget", "unescapedAnnotation", 
      "identifier", "simpleIdentifier", "semi", "anysemi"
    },
    std::vector<std::string>{
      "", "", "", "", "", "", "'...'", "'.'", "','", "'('", "", "'['", "", 
      "'{'", "'}'", "'*'", "'%'", "'/'", "'+'", "'-'", "'++'", "'--'", "'&&'", 
      "'||'", "'!'", "':'", "';'", "'='", "'+='", "'-='", "'*='", "'/='", 
      "'%='", "'->'", "'=>'", "'..'", "'::'", "'\\u003F::'", "';;'", "'#'", 
      "'@'", "'\\u003F'", "'\\u003F:'", "'<'", "'>'", "'<='", "'>='", "'!='", 
      "'!=='", "'as\\u003F'", "'=='", "'==='", "'''", "", "", "", "'@file'", 
      "'package'", "'import'", "'class'", "'interface'", "'fun'", "'object'", 
      "'val'", "'var'", "'typealias'", "'constructor'", "'by'", "'companion'", 
      "'init'", "'this'", "'super'", "'typeof'", "'where'", "'if'", "'else'", 
      "'when'", "'try'", "'catch'", "'finally'", "'for'", "'do'", "'while'", 
      "'throw'", "'return'", "'continue'", "'break'", "'as'", "'is'", "'in'", 
      "", "", "'out'", "'@field'", "'@property'", "'@get'", "'@set'", "'get'", 
      "'set'", "'@receiver'", "'@param'", "'@setparam'", "'@delegate'", 
      "'dynamic'", "'public'", "'private'", "'protected'", "'internal'", 
      "'enum'", "'sealed'", "'annotation'", "'data'", "'inner'", "'tailrec'", 
      "'operator'", "'inline'", "'infix'", "'external'", "'suspend'", "'override'", 
      "'abstract'", "'final'", "'open'", "'const'", "'lateinit'", "'vararg'", 
      "'noinline'", "'crossinline'", "'reified'", "", "'\"\"\"'", "", "", 
      "", "", "", "", "", "", "'null'"
    },
    std::vector<std::string>{
      "", "ShebangLine", "DelimitedComment", "LineComment", "WS", "NL", 
      "RESERVED", "DOT", "COMMA", "LPAREN", "RPAREN", "LSQUARE", "RSQUARE", 
      "LCURL", "RCURL", "MULT", "MOD", "DIV", "ADD", "SUB", "INCR", "DECR", 
      "CONJ", "DISJ", "EXCL", "COLON", "SEMICOLON", "ASSIGNMENT", "ADD_ASSIGNMENT", 
      "SUB_ASSIGNMENT", "MULT_ASSIGNMENT", "DIV_ASSIGNMENT", "MOD_ASSIGNMENT", 
      "ARROW", "DOUBLE_ARROW", "RANGE", "COLONCOLON", "Q_COLONCOLON", "DOUBLE_SEMICOLON", 
      "HASH", "AT", "QUEST", "ELVIS", "LANGLE", "RANGLE", "LE", "GE", "EXCL_EQ", 
      "EXCL_EQEQ", "AS_SAFE", "EQEQ", "EQEQEQ", "SINGLE_QUOTE", "RETURN_AT", 
      "CONTINUE_AT", "BREAK_AT", "FILE", "PACKAGE", "IMPORT", "CLASS", "INTERFACE", 
      "FUN", "OBJECT", "VAL", "VAR", "TYPE_ALIAS", "CONSTRUCTOR", "BY", 
      "COMPANION", "INIT", "THIS", "SUPER", "TYPEOF", "WHERE", "IF", "ELSE", 
      "WHEN", "TRY", "CATCH", "FINALLY", "FOR", "DO", "WHILE", "THROW", 
      "RETURN", "CONTINUE", "BREAK", "AS", "IS", "IN", "NOT_IS", "NOT_IN", 
      "OUT", "FIELD", "PROPERTY", "GET", "SET", "GETTER", "SETTER", "RECEIVER", 
      "PARAM", "SETPARAM", "DELEGATE", "DYNAMIC", "PUBLIC", "PRIVATE", "PROTECTED", 
      "INTERNAL", "ENUM", "SEALED", "ANNOTATION", "DATA", "INNER", "TAILREC", 
      "OPERATOR", "INLINE", "INFIX", "EXTERNAL", "SUSPEND", "OVERRIDE", 
      "ABSTRACT", "FINAL", "OPEN", "CONST", "LATEINIT", "VARARG", "NOINLINE", 
      "CROSSINLINE", "REIFIED", "QUOTE_OPEN", "TRIPLE_QUOTE_OPEN", "RealLiteral", 
      "FloatLiteral", "DoubleLiteral", "LongLiteral", "IntegerLiteral", 
      "HexLiteral", "BinLiteral", "BooleanLiteral", "NullLiteral", "Identifier", 
      "LabelReference", "LabelDefinition", "FieldIdentifier", "CharacterLiteral", 
      "UNICODE_CLASS_LL", "UNICODE_CLASS_LM", "UNICODE_CLASS_LO", "UNICODE_CLASS_LT", 
      "UNICODE_CLASS_LU", "UNICODE_CLASS_ND", "UNICODE_CLASS_NL", "Inside_Comment", 
      "Inside_WS", "Inside_NL", "QUOTE_CLOSE", "LineStrRef", "LineStrText", 
      "LineStrEscapedChar", "LineStrExprStart", "TRIPLE_QUOTE_CLOSE", "MultiLineStringQuote", 
      "MultiLineStrRef", "MultiLineStrText", "MultiLineStrEscapedChar", 
      "MultiLineStrExprStart", "MultiLineNL", "StrExpr_IN", "StrExpr_Comment", 
      "StrExpr_WS", "StrExpr_NL"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,170,2638,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,
  	7,134,2,135,7,135,2,136,7,136,2,137,7,137,2,138,7,138,2,139,7,139,2,140,
  	7,140,2,141,7,141,2,142,7,142,2,143,7,143,2,144,7,144,2,145,7,145,1,0,
  	5,0,294,8,0,10,0,12,0,297,9,0,1,0,1,0,5,0,301,8,0,10,0,12,0,304,9,0,1,
  	0,1,0,4,0,308,8,0,11,0,12,0,309,1,0,3,0,313,8,0,5,0,315,8,0,10,0,12,0,
  	318,9,0,3,0,320,8,0,1,0,1,0,1,1,5,1,325,8,1,10,1,12,1,328,9,1,1,1,1,1,
  	5,1,332,8,1,10,1,12,1,335,9,1,1,1,1,1,4,1,339,8,1,11,1,12,1,340,1,1,3,
  	1,344,8,1,5,1,346,8,1,10,1,12,1,349,9,1,3,1,351,8,1,1,1,1,1,1,2,3,2,356,
  	8,2,1,2,1,2,1,2,1,3,4,3,362,8,3,11,3,12,3,363,1,4,1,4,1,4,1,4,4,4,370,
  	8,4,11,4,12,4,371,1,4,1,4,1,4,3,4,377,8,4,1,4,3,4,380,8,4,4,4,382,8,4,
  	11,4,12,4,383,1,5,3,5,387,8,5,1,5,1,5,1,5,3,5,392,8,5,3,5,394,8,5,1,6,
  	5,6,397,8,6,10,6,12,6,400,9,6,1,7,1,7,1,7,1,7,1,7,3,7,407,8,7,1,7,3,7,
  	410,8,7,1,8,1,8,1,8,1,9,1,9,1,9,1,9,1,9,3,9,420,8,9,1,10,3,10,423,8,10,
  	1,10,1,10,5,10,427,8,10,10,10,12,10,430,9,10,1,10,1,10,5,10,434,8,10,
  	10,10,12,10,437,9,10,1,10,3,10,440,8,10,1,10,5,10,443,8,10,10,10,12,10,
  	446,9,10,1,10,3,10,449,8,10,1,10,5,10,452,8,10,10,10,12,10,455,9,10,1,
  	10,1,10,5,10,459,8,10,10,10,12,10,462,9,10,1,10,3,10,465,8,10,1,10,5,
  	10,468,8,10,10,10,12,10,471,9,10,1,10,3,10,474,8,10,1,10,5,10,477,8,10,
  	10,10,12,10,480,9,10,1,10,1,10,5,10,484,8,10,10,10,12,10,487,9,10,1,10,
  	3,10,490,8,10,1,11,3,11,493,8,11,1,11,1,11,5,11,497,8,11,10,11,12,11,
  	500,9,11,3,11,502,8,11,1,11,1,11,1,12,1,12,1,12,1,12,5,12,510,8,12,10,
  	12,12,12,513,9,12,3,12,515,8,12,1,12,1,12,1,13,3,13,520,8,13,1,13,3,13,
  	523,8,13,1,13,1,13,1,13,1,13,1,13,3,13,530,8,13,1,14,5,14,533,8,14,10,
  	14,12,14,536,9,14,1,14,1,14,5,14,540,8,14,10,14,12,14,543,9,14,1,14,1,
  	14,5,14,547,8,14,10,14,12,14,550,9,14,1,14,5,14,553,8,14,10,14,12,14,
  	556,9,14,1,15,1,15,1,15,3,15,561,8,15,1,16,1,16,1,16,1,17,1,17,5,17,568,
  	8,17,10,17,12,17,571,9,17,1,17,1,17,5,17,575,8,17,10,17,12,17,578,9,17,
  	1,17,1,17,1,18,1,18,5,18,584,8,18,10,18,12,18,587,9,18,1,18,5,18,590,
  	8,18,10,18,12,18,593,9,18,1,18,5,18,596,8,18,10,18,12,18,599,9,18,1,18,
  	1,18,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,3,19,611,8,19,1,19,4,19,
  	614,8,19,11,19,12,19,615,1,20,1,20,5,20,620,8,20,10,20,12,20,623,9,20,
  	1,20,1,20,1,21,3,21,628,8,21,1,21,1,21,5,21,632,8,21,10,21,12,21,635,
  	9,21,1,21,1,21,5,21,639,8,21,10,21,12,21,642,9,21,1,21,1,21,5,21,646,
  	8,21,10,21,12,21,649,9,21,1,21,3,21,652,8,21,1,21,5,21,655,8,21,10,21,
  	12,21,658,9,21,1,21,3,21,661,8,21,1,22,1,22,5,22,665,8,22,10,22,12,22,
  	668,9,22,1,22,1,22,1,22,5,22,673,8,22,10,22,12,22,676,9,22,1,22,3,22,
  	679,8,22,1,23,1,23,5,23,683,8,23,10,23,12,23,686,9,23,1,23,3,23,689,8,
  	23,1,23,5,23,692,8,23,10,23,12,23,695,9,23,1,23,1,23,5,23,699,8,23,10,
  	23,12,23,702,9,23,1,23,5,23,705,8,23,10,23,12,23,708,9,23,3,23,710,8,
  	23,1,23,5,23,713,8,23,10,23,12,23,716,9,23,1,23,1,23,1,24,1,24,5,24,722,
  	8,24,10,24,12,24,725,9,24,4,24,727,8,24,11,24,12,24,728,1,24,3,24,732,
  	8,24,1,25,1,25,5,25,736,8,25,10,25,12,25,739,9,25,1,25,3,25,742,8,25,
  	1,25,5,25,745,8,25,10,25,12,25,748,9,25,1,25,3,25,751,8,25,1,25,5,25,
  	754,8,25,10,25,12,25,757,9,25,1,25,3,25,760,8,25,1,26,3,26,763,8,26,1,
  	26,1,26,5,26,767,8,26,10,26,12,26,770,9,26,1,26,1,26,5,26,774,8,26,10,
  	26,12,26,777,9,26,1,26,1,26,3,26,781,8,26,1,26,5,26,784,8,26,10,26,12,
  	26,787,9,26,1,26,3,26,790,8,26,1,26,5,26,793,8,26,10,26,12,26,796,9,26,
  	1,26,3,26,799,8,26,1,26,5,26,802,8,26,10,26,12,26,805,9,26,1,26,1,26,
  	5,26,809,8,26,10,26,12,26,812,9,26,1,26,1,26,5,26,816,8,26,10,26,12,26,
  	819,9,26,1,26,3,26,822,8,26,1,26,5,26,825,8,26,10,26,12,26,828,9,26,1,
  	26,3,26,831,8,26,1,26,5,26,834,8,26,10,26,12,26,837,9,26,1,26,3,26,840,
  	8,26,1,27,1,27,1,27,1,27,5,27,846,8,27,10,27,12,27,849,9,27,3,27,851,
  	8,27,1,27,1,27,1,28,3,28,856,8,28,1,28,1,28,1,28,3,28,861,8,28,1,29,1,
  	29,1,29,1,29,1,30,1,30,1,30,5,30,870,8,30,10,30,12,30,873,9,30,1,30,3,
  	30,876,8,30,1,31,3,31,879,8,31,1,31,1,31,5,31,883,8,31,10,31,12,31,886,
  	9,31,1,31,1,31,5,31,890,8,31,10,31,12,31,893,9,31,1,31,3,31,896,8,31,
  	1,31,5,31,899,8,31,10,31,12,31,902,9,31,1,31,1,31,5,31,906,8,31,10,31,
  	12,31,909,9,31,1,31,3,31,912,8,31,1,31,5,31,915,8,31,10,31,12,31,918,
  	9,31,1,31,3,31,921,8,31,1,32,3,32,924,8,32,1,32,1,32,5,32,928,8,32,10,
  	32,12,32,931,9,32,1,32,3,32,934,8,32,1,32,1,32,5,32,938,8,32,10,32,12,
  	32,941,9,32,1,32,3,32,944,8,32,1,32,5,32,947,8,32,10,32,12,32,950,9,32,
  	1,32,1,32,5,32,954,8,32,10,32,12,32,957,9,32,1,32,3,32,960,8,32,1,32,
  	5,32,963,8,32,10,32,12,32,966,9,32,1,32,3,32,969,8,32,1,33,3,33,972,8,
  	33,1,33,1,33,5,33,976,8,33,10,33,12,33,979,9,33,1,33,3,33,982,8,33,1,
  	33,5,33,985,8,33,10,33,12,33,988,9,33,1,33,1,33,5,33,992,8,33,10,33,12,
  	33,995,9,33,1,33,1,33,3,33,999,8,33,1,33,5,33,1002,8,33,10,33,12,33,1005,
  	9,33,1,33,1,33,3,33,1009,8,33,1,33,5,33,1012,8,33,10,33,12,33,1015,9,
  	33,1,33,3,33,1018,8,33,1,33,5,33,1021,8,33,10,33,12,33,1024,9,33,1,33,
  	1,33,5,33,1028,8,33,10,33,12,33,1031,9,33,1,33,3,33,1034,8,33,1,33,1,
  	33,1,33,1,33,3,33,1040,8,33,1,33,1,33,1,33,1,33,3,33,1046,8,33,3,33,1048,
  	8,33,1,34,1,34,1,34,1,34,5,34,1054,8,34,10,34,12,34,1057,9,34,1,34,1,
  	34,1,35,1,35,1,35,3,35,1064,8,35,1,36,3,36,1067,8,36,1,36,1,36,3,36,1071,
  	8,36,1,36,1,36,5,36,1075,8,36,10,36,12,36,1078,9,36,1,36,1,36,1,36,5,
  	36,1083,8,36,10,36,12,36,1086,9,36,1,36,1,36,5,36,1090,8,36,10,36,12,
  	36,1093,9,36,1,36,3,36,1096,8,36,1,36,5,36,1099,8,36,10,36,12,36,1102,
  	9,36,1,36,1,36,1,36,5,36,1107,8,36,10,36,12,36,1110,9,36,1,36,3,36,1113,
  	8,36,3,36,1115,8,36,1,37,3,37,1118,8,37,1,37,1,37,3,37,1122,8,37,1,37,
  	1,37,5,37,1126,8,37,10,37,12,37,1129,9,37,1,37,1,37,1,37,5,37,1134,8,
  	37,10,37,12,37,1137,9,37,1,37,1,37,3,37,1141,8,37,1,37,1,37,5,37,1145,
  	8,37,10,37,12,37,1148,9,37,1,37,1,37,3,37,1152,8,37,1,38,3,38,1155,8,
  	38,1,38,1,38,5,38,1159,8,38,10,38,12,38,1162,9,38,1,38,1,38,5,38,1166,
  	8,38,10,38,12,38,1169,9,38,1,38,3,38,1172,8,38,1,38,5,38,1175,8,38,10,
  	38,12,38,1178,9,38,1,38,1,38,5,38,1182,8,38,10,38,12,38,1185,9,38,1,38,
  	1,38,1,39,1,39,5,39,1191,8,39,10,39,12,39,1194,9,39,1,39,1,39,5,39,1198,
  	8,39,10,39,12,39,1201,9,39,1,39,1,39,5,39,1205,8,39,10,39,12,39,1208,
  	9,39,1,39,5,39,1211,8,39,10,39,12,39,1214,9,39,1,39,5,39,1217,8,39,10,
  	39,12,39,1220,9,39,1,39,1,39,1,40,3,40,1225,8,40,1,40,5,40,1228,8,40,
  	10,40,12,40,1231,9,40,1,40,1,40,5,40,1235,8,40,10,40,12,40,1238,9,40,
  	1,40,1,40,5,40,1242,8,40,10,40,12,40,1245,9,40,1,40,3,40,1248,8,40,1,
  	41,3,41,1251,8,41,1,41,1,41,1,41,1,41,3,41,1257,8,41,1,42,1,42,1,42,5,
  	42,1262,8,42,10,42,12,42,1265,9,42,4,42,1267,8,42,11,42,12,42,1268,1,
  	43,1,43,1,43,1,43,1,44,1,44,3,44,1277,8,44,1,44,5,44,1280,8,44,10,44,
  	12,44,1283,9,44,1,44,4,44,1286,8,44,11,44,12,44,1287,1,45,1,45,1,45,1,
  	45,1,45,1,45,3,45,1296,8,45,1,46,1,46,5,46,1300,8,46,10,46,12,46,1303,
  	9,46,1,46,1,46,5,46,1307,8,46,10,46,12,46,1310,9,46,3,46,1312,8,46,1,
  	46,1,46,5,46,1316,8,46,10,46,12,46,1319,9,46,1,46,1,46,5,46,1323,8,46,
  	10,46,12,46,1326,9,46,1,46,1,46,1,47,1,47,1,47,3,47,1333,8,47,1,48,1,
  	48,5,48,1337,8,48,10,48,12,48,1340,9,48,1,48,1,48,5,48,1344,8,48,10,48,
  	12,48,1347,9,48,1,48,5,48,1350,8,48,10,48,12,48,1353,9,48,1,49,1,49,5,
  	49,1357,8,49,10,49,12,49,1360,9,49,1,49,3,49,1363,8,49,1,50,1,50,1,50,
  	3,50,1368,8,50,1,50,1,50,1,50,3,50,1373,8,50,5,50,1375,8,50,10,50,12,
  	50,1378,9,50,1,50,1,50,1,51,1,51,5,51,1384,8,51,10,51,12,51,1387,9,51,
  	1,51,1,51,5,51,1391,8,51,10,51,12,51,1394,9,51,1,51,1,51,5,51,1398,8,
  	51,10,51,12,51,1401,9,51,1,51,5,51,1404,8,51,10,51,12,51,1407,9,51,1,
  	52,5,52,1410,8,52,10,52,12,52,1413,9,52,1,52,1,52,5,52,1417,8,52,10,52,
  	12,52,1420,9,52,1,52,1,52,5,52,1424,8,52,10,52,12,52,1427,9,52,1,52,1,
  	52,1,53,1,53,1,53,1,53,1,54,5,54,1436,8,54,10,54,12,54,1439,9,54,1,54,
  	1,54,4,54,1443,8,54,11,54,12,54,1444,1,54,3,54,1448,8,54,5,54,1450,8,
  	54,10,54,12,54,1453,9,54,3,54,1455,8,54,1,55,1,55,3,55,1459,8,55,1,56,
  	5,56,1462,8,56,10,56,12,56,1465,9,56,1,56,5,56,1468,8,56,10,56,12,56,
  	1471,9,56,1,56,1,56,1,57,5,57,1476,8,57,10,57,12,57,1479,9,57,1,57,1,
  	57,1,57,1,57,3,57,1485,8,57,1,58,1,58,1,58,1,58,5,58,1491,8,58,10,58,
  	12,58,1494,9,58,1,59,1,59,5,59,1498,8,59,10,59,12,59,1501,9,59,1,59,1,
  	59,5,59,1505,8,59,10,59,12,59,1508,9,59,1,59,5,59,1511,8,59,10,59,12,
  	59,1514,9,59,1,60,1,60,5,60,1518,8,60,10,60,12,60,1521,9,60,1,60,1,60,
  	5,60,1525,8,60,10,60,12,60,1528,9,60,1,60,5,60,1531,8,60,10,60,12,60,
  	1534,9,60,1,61,1,61,1,61,5,61,1539,8,61,10,61,12,61,1542,9,61,1,61,1,
  	61,5,61,1546,8,61,10,61,12,61,1549,9,61,1,62,1,62,1,62,5,62,1554,8,62,
  	10,62,12,62,1557,9,62,1,62,1,62,3,62,1561,8,62,1,63,1,63,1,63,5,63,1566,
  	8,63,10,63,12,63,1569,9,63,1,63,1,63,4,63,1573,8,63,11,63,12,63,1574,
  	1,63,1,63,5,63,1579,8,63,10,63,12,63,1582,9,63,1,63,1,63,3,63,1586,8,
  	63,1,64,1,64,5,64,1590,8,64,10,64,12,64,1593,9,64,1,64,1,64,5,64,1597,
  	8,64,10,64,12,64,1600,9,64,1,64,5,64,1603,8,64,10,64,12,64,1606,9,64,
  	1,65,1,65,1,65,5,65,1611,8,65,10,65,12,65,1614,9,65,1,65,1,65,5,65,1618,
  	8,65,10,65,12,65,1621,9,65,1,66,1,66,1,66,5,66,1626,8,66,10,66,12,66,
  	1629,9,66,1,66,5,66,1632,8,66,10,66,12,66,1635,9,66,1,67,1,67,1,67,5,
  	67,1640,8,67,10,67,12,67,1643,9,67,1,67,1,67,5,67,1647,8,67,10,67,12,
  	67,1650,9,67,1,68,1,68,1,68,5,68,1655,8,68,10,68,12,68,1658,9,68,1,68,
  	1,68,5,68,1662,8,68,10,68,12,68,1665,9,68,1,69,1,69,5,69,1669,8,69,10,
  	69,12,69,1672,9,69,1,69,1,69,1,69,5,69,1677,8,69,10,69,12,69,1680,9,69,
  	1,70,5,70,1683,8,70,10,70,12,70,1686,9,70,1,70,1,70,1,71,1,71,3,71,1692,
  	8,71,1,71,5,71,1695,8,71,10,71,12,71,1698,9,71,1,72,1,72,1,72,1,72,1,
  	72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,3,72,1712,8,72,1,73,1,73,1,73,1,
  	73,1,74,1,74,3,74,1720,8,74,1,74,5,74,1723,8,74,10,74,12,74,1726,9,74,
  	1,74,1,74,5,74,1730,8,74,10,74,12,74,1733,9,74,1,74,4,74,1736,8,74,11,
  	74,12,74,1737,3,74,1740,8,74,1,75,5,75,1743,8,75,10,75,12,75,1746,9,75,
  	1,75,3,75,1749,8,75,1,75,5,75,1752,8,75,10,75,12,75,1755,9,75,1,75,1,
  	75,1,76,1,76,1,76,1,76,5,76,1763,8,76,10,76,12,76,1766,9,76,3,76,1768,
  	8,76,1,76,1,76,1,77,1,77,1,77,1,77,5,77,1776,8,77,10,77,12,77,1779,9,
  	77,3,77,1781,8,77,1,77,1,77,1,78,1,78,5,78,1787,8,78,10,78,12,78,1790,
  	9,78,1,78,1,78,5,78,1794,8,78,10,78,12,78,1797,9,78,1,78,1,78,5,78,1801,
  	8,78,10,78,12,78,1804,9,78,1,78,5,78,1807,8,78,10,78,12,78,1810,9,78,
  	1,78,1,78,1,79,3,79,1815,8,79,1,79,1,79,3,79,1819,8,79,1,80,4,80,1822,
  	8,80,11,80,12,80,1823,1,81,1,81,5,81,1828,8,81,10,81,12,81,1831,9,81,
  	1,81,1,81,5,81,1835,8,81,10,81,12,81,1838,9,81,3,81,1840,8,81,1,81,3,
  	81,1843,8,81,1,81,5,81,1846,8,81,10,81,12,81,1849,9,81,1,81,1,81,1,82,
  	1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,3,82,1862,8,82,1,83,1,83,3,83,
  	1866,8,83,1,84,1,84,1,84,5,84,1871,8,84,10,84,12,84,1874,9,84,1,84,1,
  	84,1,85,1,85,1,85,1,85,1,85,5,85,1883,8,85,10,85,12,85,1886,9,85,1,85,
  	1,85,1,86,1,86,1,87,1,87,1,87,1,87,1,88,1,88,1,89,1,89,1,89,1,89,1,90,
  	5,90,1903,8,90,10,90,12,90,1906,9,90,1,90,1,90,5,90,1910,8,90,10,90,12,
  	90,1913,9,90,1,90,1,90,5,90,1917,8,90,10,90,12,90,1920,9,90,1,90,1,90,
  	1,90,1,90,5,90,1926,8,90,10,90,12,90,1929,9,90,1,90,1,90,5,90,1933,8,
  	90,10,90,12,90,1936,9,90,1,90,1,90,5,90,1940,8,90,10,90,12,90,1943,9,
  	90,1,90,1,90,5,90,1947,8,90,10,90,12,90,1950,9,90,1,90,1,90,3,90,1954,
  	8,90,1,91,3,91,1957,8,91,1,91,5,91,1960,8,91,10,91,12,91,1963,9,91,1,
  	91,1,91,5,91,1967,8,91,10,91,12,91,1970,9,91,1,91,5,91,1973,8,91,10,91,
  	12,91,1976,9,91,1,92,1,92,1,92,5,92,1981,8,92,10,92,12,92,1984,9,92,1,
  	92,1,92,5,92,1988,8,92,10,92,12,92,1991,9,92,1,92,3,92,1994,8,92,3,92,
  	1996,8,92,1,93,1,93,5,93,2000,8,93,10,93,12,93,2003,9,93,1,93,1,93,5,
  	93,2007,8,93,10,93,12,93,2010,9,93,1,93,3,93,2013,8,93,1,93,5,93,2016,
  	8,93,10,93,12,93,2019,9,93,1,93,1,93,1,94,1,94,3,94,2025,8,94,1,94,1,
  	94,5,94,2029,8,94,10,94,12,94,2032,9,94,1,94,1,94,1,95,1,95,3,95,2038,
  	8,95,1,96,1,96,1,96,5,96,2043,8,96,10,96,12,96,2046,9,96,1,96,1,96,5,
  	96,2050,8,96,10,96,12,96,2053,9,96,1,96,1,96,3,96,2057,8,96,1,96,3,96,
  	2060,8,96,1,97,1,97,3,97,2064,8,97,1,98,1,98,5,98,2068,8,98,10,98,12,
  	98,2071,9,98,1,98,1,98,1,98,1,98,5,98,2077,8,98,10,98,12,98,2080,9,98,
  	1,98,3,98,2083,8,98,1,98,3,98,2086,8,98,1,98,5,98,2089,8,98,10,98,12,
  	98,2092,9,98,1,98,1,98,5,98,2096,8,98,10,98,12,98,2099,9,98,1,98,3,98,
  	2102,8,98,3,98,2104,8,98,1,99,1,99,3,99,2108,8,99,1,100,1,100,5,100,2112,
  	8,100,10,100,12,100,2115,9,100,1,100,1,100,1,100,1,100,3,100,2121,8,100,
  	1,100,5,100,2124,8,100,10,100,12,100,2127,9,100,1,100,1,100,5,100,2131,
  	8,100,10,100,12,100,2134,9,100,1,100,1,100,5,100,2138,8,100,10,100,12,
  	100,2141,9,100,5,100,2143,8,100,10,100,12,100,2146,9,100,1,100,5,100,
  	2149,8,100,10,100,12,100,2152,9,100,1,100,1,100,1,101,1,101,5,101,2158,
  	8,101,10,101,12,101,2161,9,101,1,101,1,101,5,101,2165,8,101,10,101,12,
  	101,2168,9,101,1,101,5,101,2171,8,101,10,101,12,101,2174,9,101,1,101,
  	5,101,2177,8,101,10,101,12,101,2180,9,101,1,101,1,101,5,101,2184,8,101,
  	10,101,12,101,2187,9,101,1,101,1,101,3,101,2191,8,101,1,101,1,101,5,101,
  	2195,8,101,10,101,12,101,2198,9,101,1,101,1,101,5,101,2202,8,101,10,101,
  	12,101,2205,9,101,1,101,3,101,2208,8,101,1,102,1,102,1,102,3,102,2213,
  	8,102,1,103,1,103,5,103,2217,8,103,10,103,12,103,2220,9,103,1,103,1,103,
  	1,104,1,104,5,104,2226,8,104,10,104,12,104,2229,9,104,1,104,1,104,1,105,
  	1,105,5,105,2235,8,105,10,105,12,105,2238,9,105,1,105,1,105,5,105,2242,
  	8,105,10,105,12,105,2245,9,105,1,105,5,105,2248,8,105,10,105,12,105,2251,
  	9,105,1,105,5,105,2254,8,105,10,105,12,105,2257,9,105,1,105,3,105,2260,
  	8,105,1,106,1,106,5,106,2264,8,106,10,106,12,106,2267,9,106,1,106,1,106,
  	5,106,2271,8,106,10,106,12,106,2274,9,106,1,106,1,106,1,106,1,106,1,106,
  	5,106,2281,8,106,10,106,12,106,2284,9,106,1,106,1,106,1,107,1,107,5,107,
  	2290,8,107,10,107,12,107,2293,9,107,1,107,1,107,1,108,1,108,1,108,3,108,
  	2300,8,108,1,109,1,109,5,109,2304,8,109,10,109,12,109,2307,9,109,1,109,
  	1,109,5,109,2311,8,109,10,109,12,109,2314,9,109,1,109,1,109,3,109,2318,
  	8,109,1,109,1,109,1,109,1,109,5,109,2324,8,109,10,109,12,109,2327,9,109,
  	1,109,3,109,2330,8,109,1,110,1,110,5,110,2334,8,110,10,110,12,110,2337,
  	9,110,1,110,1,110,1,110,1,110,5,110,2343,8,110,10,110,12,110,2346,9,110,
  	1,110,3,110,2349,8,110,1,111,1,111,5,111,2353,8,111,10,111,12,111,2356,
  	9,111,1,111,3,111,2359,8,111,1,111,5,111,2362,8,111,10,111,12,111,2365,
  	9,111,1,111,1,111,5,111,2369,8,111,10,111,12,111,2372,9,111,1,111,1,111,
  	1,111,1,111,1,112,1,112,5,112,2380,8,112,10,112,12,112,2383,9,112,1,112,
  	1,112,1,112,3,112,2388,8,112,1,112,1,112,1,112,1,112,3,112,2394,8,112,
  	1,113,1,113,1,113,5,113,2399,8,113,10,113,12,113,2402,9,113,5,113,2404,
  	8,113,10,113,12,113,2407,9,113,3,113,2409,8,113,1,113,5,113,2412,8,113,
  	10,113,12,113,2415,9,113,1,113,1,113,5,113,2419,8,113,10,113,12,113,2422,
  	9,113,1,113,1,113,3,113,2426,8,113,1,114,1,114,1,115,1,115,1,116,1,116,
  	1,117,1,117,1,118,1,118,1,119,1,119,1,120,1,120,1,121,1,121,1,122,1,122,
  	1,122,1,122,1,122,1,122,1,122,3,122,2451,8,122,1,123,1,123,1,123,1,123,
  	1,123,1,123,1,123,5,123,2460,8,123,10,123,12,123,2463,9,123,1,123,1,123,
  	1,123,3,123,2468,8,123,1,124,1,124,1,124,3,124,2473,8,124,1,125,1,125,
  	4,125,2477,8,125,11,125,12,125,2478,1,126,1,126,1,126,1,126,1,126,1,126,
  	1,126,1,126,1,126,3,126,2490,8,126,1,126,5,126,2493,8,126,10,126,12,126,
  	2496,9,126,1,127,1,127,1,128,1,128,1,129,1,129,1,130,1,130,1,131,1,131,
  	1,132,1,132,1,133,1,133,1,134,1,134,1,135,1,135,1,136,1,136,5,136,2518,
  	8,136,10,136,12,136,2521,9,136,1,137,1,137,3,137,2525,8,137,1,137,5,137,
  	2528,8,137,10,137,12,137,2531,9,137,1,138,1,138,5,138,2535,8,138,10,138,
  	12,138,2538,9,138,1,138,1,138,5,138,2542,8,138,10,138,12,138,2545,9,138,
  	1,138,1,138,1,138,1,138,5,138,2551,8,138,10,138,12,138,2554,9,138,1,138,
  	3,138,2557,8,138,1,138,5,138,2560,8,138,10,138,12,138,2563,9,138,1,138,
  	3,138,2566,8,138,3,138,2568,8,138,1,139,1,139,1,139,1,139,4,139,2574,
  	8,139,11,139,12,139,2575,1,139,1,139,1,139,1,139,1,139,4,139,2583,8,139,
  	11,139,12,139,2584,1,139,1,139,3,139,2589,8,139,1,140,1,140,1,141,1,141,
  	3,141,2595,8,141,1,141,3,141,2598,8,141,1,142,1,142,5,142,2602,8,142,
  	10,142,12,142,2605,9,142,1,142,1,142,5,142,2609,8,142,10,142,12,142,2612,
  	9,142,1,143,1,143,1,144,4,144,2617,8,144,11,144,12,144,2618,1,144,5,144,
  	2622,8,144,10,144,12,144,2625,9,144,1,144,1,144,5,144,2629,8,144,10,144,
  	12,144,2632,9,144,3,144,2634,8,144,1,145,1,145,1,145,0,0,146,0,2,4,6,
  	8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,
  	56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,
  	102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,
  	138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,
  	174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,
  	210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,
  	246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,
  	282,284,286,288,290,0,25,1,0,59,60,1,0,63,64,2,0,27,27,67,67,1,0,156,
  	158,1,0,162,164,2,0,53,53,84,84,1,0,36,37,1,0,27,32,2,0,47,48,50,51,1,
  	0,43,46,2,0,89,89,91,91,2,0,88,88,90,90,1,0,18,19,1,0,15,17,3,0,25,25,
  	49,49,87,87,1,0,108,112,2,0,119,119,124,124,1,0,104,107,2,0,89,89,92,
  	92,1,0,113,118,1,0,120,122,1,0,125,127,3,0,56,56,93,96,99,102,8,0,58,
  	58,66,69,73,73,78,79,92,92,97,98,103,128,140,140,2,0,5,5,26,26,2951,0,
  	295,1,0,0,0,2,326,1,0,0,0,4,355,1,0,0,0,6,361,1,0,0,0,8,381,1,0,0,0,10,
  	393,1,0,0,0,12,398,1,0,0,0,14,401,1,0,0,0,16,411,1,0,0,0,18,419,1,0,0,
  	0,20,422,1,0,0,0,22,492,1,0,0,0,24,505,1,0,0,0,26,519,1,0,0,0,28,534,
  	1,0,0,0,30,560,1,0,0,0,32,562,1,0,0,0,34,565,1,0,0,0,36,581,1,0,0,0,38,
  	610,1,0,0,0,40,617,1,0,0,0,42,627,1,0,0,0,44,678,1,0,0,0,46,680,1,0,0,
  	0,48,726,1,0,0,0,50,733,1,0,0,0,52,762,1,0,0,0,54,841,1,0,0,0,56,855,
  	1,0,0,0,58,862,1,0,0,0,60,875,1,0,0,0,62,878,1,0,0,0,64,923,1,0,0,0,66,
  	971,1,0,0,0,68,1049,1,0,0,0,70,1060,1,0,0,0,72,1114,1,0,0,0,74,1151,1,
  	0,0,0,76,1154,1,0,0,0,78,1188,1,0,0,0,80,1224,1,0,0,0,82,1250,1,0,0,0,
  	84,1266,1,0,0,0,86,1270,1,0,0,0,88,1276,1,0,0,0,90,1295,1,0,0,0,92,1311,
  	1,0,0,0,94,1332,1,0,0,0,96,1334,1,0,0,0,98,1354,1,0,0,0,100,1364,1,0,
  	0,0,102,1381,1,0,0,0,104,1411,1,0,0,0,106,1430,1,0,0,0,108,1437,1,0,0,
  	0,110,1458,1,0,0,0,112,1463,1,0,0,0,114,1477,1,0,0,0,116,1486,1,0,0,0,
  	118,1495,1,0,0,0,120,1515,1,0,0,0,122,1535,1,0,0,0,124,1550,1,0,0,0,126,
  	1562,1,0,0,0,128,1587,1,0,0,0,130,1607,1,0,0,0,132,1622,1,0,0,0,134,1636,
  	1,0,0,0,136,1651,1,0,0,0,138,1666,1,0,0,0,140,1684,1,0,0,0,142,1691,1,
  	0,0,0,144,1711,1,0,0,0,146,1713,1,0,0,0,148,1739,1,0,0,0,150,1744,1,0,
  	0,0,152,1758,1,0,0,0,154,1771,1,0,0,0,156,1784,1,0,0,0,158,1818,1,0,0,
  	0,160,1821,1,0,0,0,162,1839,1,0,0,0,164,1861,1,0,0,0,166,1865,1,0,0,0,
  	168,1867,1,0,0,0,170,1877,1,0,0,0,172,1889,1,0,0,0,174,1891,1,0,0,0,176,
  	1895,1,0,0,0,178,1897,1,0,0,0,180,1904,1,0,0,0,182,1956,1,0,0,0,184,1995,
  	1,0,0,0,186,1997,1,0,0,0,188,2022,1,0,0,0,190,2035,1,0,0,0,192,2039,1,
  	0,0,0,194,2063,1,0,0,0,196,2065,1,0,0,0,198,2107,1,0,0,0,200,2109,1,0,
  	0,0,202,2207,1,0,0,0,204,2212,1,0,0,0,206,2214,1,0,0,0,208,2223,1,0,0,
  	0,210,2232,1,0,0,0,212,2261,1,0,0,0,214,2287,1,0,0,0,216,2299,1,0,0,0,
  	218,2301,1,0,0,0,220,2331,1,0,0,0,222,2350,1,0,0,0,224,2393,1,0,0,0,226,
  	2408,1,0,0,0,228,2427,1,0,0,0,230,2429,1,0,0,0,232,2431,1,0,0,0,234,2433,
  	1,0,0,0,236,2435,1,0,0,0,238,2437,1,0,0,0,240,2439,1,0,0,0,242,2441,1,
  	0,0,0,244,2450,1,0,0,0,246,2467,1,0,0,0,248,2472,1,0,0,0,250,2476,1,0,
  	0,0,252,2489,1,0,0,0,254,2497,1,0,0,0,256,2499,1,0,0,0,258,2501,1,0,0,
  	0,260,2503,1,0,0,0,262,2505,1,0,0,0,264,2507,1,0,0,0,266,2509,1,0,0,0,
  	268,2511,1,0,0,0,270,2513,1,0,0,0,272,2515,1,0,0,0,274,2524,1,0,0,0,276,
  	2567,1,0,0,0,278,2588,1,0,0,0,280,2590,1,0,0,0,282,2592,1,0,0,0,284,2599,
  	1,0,0,0,286,2613,1,0,0,0,288,2633,1,0,0,0,290,2635,1,0,0,0,292,294,5,
  	5,0,0,293,292,1,0,0,0,294,297,1,0,0,0,295,293,1,0,0,0,295,296,1,0,0,0,
  	296,298,1,0,0,0,297,295,1,0,0,0,298,302,3,4,2,0,299,301,3,290,145,0,300,
  	299,1,0,0,0,301,304,1,0,0,0,302,300,1,0,0,0,302,303,1,0,0,0,303,319,1,
  	0,0,0,304,302,1,0,0,0,305,316,3,18,9,0,306,308,3,290,145,0,307,306,1,
  	0,0,0,308,309,1,0,0,0,309,307,1,0,0,0,309,310,1,0,0,0,310,312,1,0,0,0,
  	311,313,3,18,9,0,312,311,1,0,0,0,312,313,1,0,0,0,313,315,1,0,0,0,314,
  	307,1,0,0,0,315,318,1,0,0,0,316,314,1,0,0,0,316,317,1,0,0,0,317,320,1,
  	0,0,0,318,316,1,0,0,0,319,305,1,0,0,0,319,320,1,0,0,0,320,321,1,0,0,0,
  	321,322,5,0,0,1,322,1,1,0,0,0,323,325,5,5,0,0,324,323,1,0,0,0,325,328,
  	1,0,0,0,326,324,1,0,0,0,326,327,1,0,0,0,327,329,1,0,0,0,328,326,1,0,0,
  	0,329,333,3,4,2,0,330,332,3,290,145,0,331,330,1,0,0,0,332,335,1,0,0,0,
  	333,331,1,0,0,0,333,334,1,0,0,0,334,350,1,0,0,0,335,333,1,0,0,0,336,347,
  	3,116,58,0,337,339,3,290,145,0,338,337,1,0,0,0,339,340,1,0,0,0,340,338,
  	1,0,0,0,340,341,1,0,0,0,341,343,1,0,0,0,342,344,3,116,58,0,343,342,1,
  	0,0,0,343,344,1,0,0,0,344,346,1,0,0,0,345,338,1,0,0,0,346,349,1,0,0,0,
  	347,345,1,0,0,0,347,348,1,0,0,0,348,351,1,0,0,0,349,347,1,0,0,0,350,336,
  	1,0,0,0,350,351,1,0,0,0,351,352,1,0,0,0,352,353,5,0,0,1,353,3,1,0,0,0,
  	354,356,3,6,3,0,355,354,1,0,0,0,355,356,1,0,0,0,356,357,1,0,0,0,357,358,
  	3,10,5,0,358,359,3,12,6,0,359,5,1,0,0,0,360,362,3,8,4,0,361,360,1,0,0,
  	0,362,363,1,0,0,0,363,361,1,0,0,0,363,364,1,0,0,0,364,7,1,0,0,0,365,366,
  	5,56,0,0,366,376,5,25,0,0,367,369,5,11,0,0,368,370,3,282,141,0,369,368,
  	1,0,0,0,370,371,1,0,0,0,371,369,1,0,0,0,371,372,1,0,0,0,372,373,1,0,0,
  	0,373,374,5,12,0,0,374,377,1,0,0,0,375,377,3,282,141,0,376,367,1,0,0,
  	0,376,375,1,0,0,0,377,379,1,0,0,0,378,380,3,288,144,0,379,378,1,0,0,0,
  	379,380,1,0,0,0,380,382,1,0,0,0,381,365,1,0,0,0,382,383,1,0,0,0,383,381,
  	1,0,0,0,383,384,1,0,0,0,384,9,1,0,0,0,385,387,3,250,125,0,386,385,1,0,
  	0,0,386,387,1,0,0,0,387,388,1,0,0,0,388,389,5,57,0,0,389,391,3,284,142,
  	0,390,392,3,288,144,0,391,390,1,0,0,0,391,392,1,0,0,0,392,394,1,0,0,0,
  	393,386,1,0,0,0,393,394,1,0,0,0,394,11,1,0,0,0,395,397,3,14,7,0,396,395,
  	1,0,0,0,397,400,1,0,0,0,398,396,1,0,0,0,398,399,1,0,0,0,399,13,1,0,0,
  	0,400,398,1,0,0,0,401,402,5,58,0,0,402,406,3,284,142,0,403,404,5,7,0,
  	0,404,407,5,15,0,0,405,407,3,16,8,0,406,403,1,0,0,0,406,405,1,0,0,0,406,
  	407,1,0,0,0,407,409,1,0,0,0,408,410,3,288,144,0,409,408,1,0,0,0,409,410,
  	1,0,0,0,410,15,1,0,0,0,411,412,5,87,0,0,412,413,3,286,143,0,413,17,1,
  	0,0,0,414,420,3,20,10,0,415,420,3,62,31,0,416,420,3,52,26,0,417,420,3,
  	66,33,0,418,420,3,76,38,0,419,414,1,0,0,0,419,415,1,0,0,0,419,416,1,0,
  	0,0,419,417,1,0,0,0,419,418,1,0,0,0,420,19,1,0,0,0,421,423,3,250,125,
  	0,422,421,1,0,0,0,422,423,1,0,0,0,423,424,1,0,0,0,424,428,7,0,0,0,425,
  	427,5,5,0,0,426,425,1,0,0,0,427,430,1,0,0,0,428,426,1,0,0,0,428,429,1,
  	0,0,0,429,431,1,0,0,0,430,428,1,0,0,0,431,439,3,286,143,0,432,434,5,5,
  	0,0,433,432,1,0,0,0,434,437,1,0,0,0,435,433,1,0,0,0,435,436,1,0,0,0,436,
  	438,1,0,0,0,437,435,1,0,0,0,438,440,3,78,39,0,439,435,1,0,0,0,439,440,
  	1,0,0,0,440,448,1,0,0,0,441,443,5,5,0,0,442,441,1,0,0,0,443,446,1,0,0,
  	0,444,442,1,0,0,0,444,445,1,0,0,0,445,447,1,0,0,0,446,444,1,0,0,0,447,
  	449,3,22,11,0,448,444,1,0,0,0,448,449,1,0,0,0,449,464,1,0,0,0,450,452,
  	5,5,0,0,451,450,1,0,0,0,452,455,1,0,0,0,453,451,1,0,0,0,453,454,1,0,0,
  	0,454,456,1,0,0,0,455,453,1,0,0,0,456,460,5,25,0,0,457,459,5,5,0,0,458,
  	457,1,0,0,0,459,462,1,0,0,0,460,458,1,0,0,0,460,461,1,0,0,0,461,463,1,
  	0,0,0,462,460,1,0,0,0,463,465,3,28,14,0,464,453,1,0,0,0,464,465,1,0,0,
  	0,465,473,1,0,0,0,466,468,5,5,0,0,467,466,1,0,0,0,468,471,1,0,0,0,469,
  	467,1,0,0,0,469,470,1,0,0,0,470,472,1,0,0,0,471,469,1,0,0,0,472,474,3,
  	102,51,0,473,469,1,0,0,0,473,474,1,0,0,0,474,489,1,0,0,0,475,477,5,5,
  	0,0,476,475,1,0,0,0,477,480,1,0,0,0,478,476,1,0,0,0,478,479,1,0,0,0,479,
  	481,1,0,0,0,480,478,1,0,0,0,481,490,3,36,18,0,482,484,5,5,0,0,483,482,
  	1,0,0,0,484,487,1,0,0,0,485,483,1,0,0,0,485,486,1,0,0,0,486,488,1,0,0,
  	0,487,485,1,0,0,0,488,490,3,46,23,0,489,478,1,0,0,0,489,485,1,0,0,0,489,
  	490,1,0,0,0,490,21,1,0,0,0,491,493,3,250,125,0,492,491,1,0,0,0,492,493,
  	1,0,0,0,493,501,1,0,0,0,494,498,5,66,0,0,495,497,5,5,0,0,496,495,1,0,
  	0,0,497,500,1,0,0,0,498,496,1,0,0,0,498,499,1,0,0,0,499,502,1,0,0,0,500,
  	498,1,0,0,0,501,494,1,0,0,0,501,502,1,0,0,0,502,503,1,0,0,0,503,504,3,
  	24,12,0,504,23,1,0,0,0,505,514,5,9,0,0,506,511,3,26,13,0,507,508,5,8,
  	0,0,508,510,3,26,13,0,509,507,1,0,0,0,510,513,1,0,0,0,511,509,1,0,0,0,
  	511,512,1,0,0,0,512,515,1,0,0,0,513,511,1,0,0,0,514,506,1,0,0,0,514,515,
  	1,0,0,0,515,516,1,0,0,0,516,517,5,10,0,0,517,25,1,0,0,0,518,520,3,250,
  	125,0,519,518,1,0,0,0,519,520,1,0,0,0,520,522,1,0,0,0,521,523,7,1,0,0,
  	522,521,1,0,0,0,522,523,1,0,0,0,523,524,1,0,0,0,524,525,3,286,143,0,525,
  	526,5,25,0,0,526,529,3,82,41,0,527,528,5,27,0,0,528,530,3,116,58,0,529,
  	527,1,0,0,0,529,530,1,0,0,0,530,27,1,0,0,0,531,533,3,274,137,0,532,531,
  	1,0,0,0,533,536,1,0,0,0,534,532,1,0,0,0,534,535,1,0,0,0,535,537,1,0,0,
  	0,536,534,1,0,0,0,537,554,3,30,15,0,538,540,5,5,0,0,539,538,1,0,0,0,540,
  	543,1,0,0,0,541,539,1,0,0,0,541,542,1,0,0,0,542,544,1,0,0,0,543,541,1,
  	0,0,0,544,548,5,8,0,0,545,547,5,5,0,0,546,545,1,0,0,0,547,550,1,0,0,0,
  	548,546,1,0,0,0,548,549,1,0,0,0,549,551,1,0,0,0,550,548,1,0,0,0,551,553,
  	3,30,15,0,552,541,1,0,0,0,553,556,1,0,0,0,554,552,1,0,0,0,554,555,1,0,
  	0,0,555,29,1,0,0,0,556,554,1,0,0,0,557,561,3,32,16,0,558,561,3,96,48,
  	0,559,561,3,34,17,0,560,557,1,0,0,0,560,558,1,0,0,0,560,559,1,0,0,0,561,
  	31,1,0,0,0,562,563,3,96,48,0,563,564,3,148,74,0,564,33,1,0,0,0,565,569,
  	3,96,48,0,566,568,5,5,0,0,567,566,1,0,0,0,568,571,1,0,0,0,569,567,1,0,
  	0,0,569,570,1,0,0,0,570,572,1,0,0,0,571,569,1,0,0,0,572,576,5,67,0,0,
  	573,575,5,5,0,0,574,573,1,0,0,0,575,578,1,0,0,0,576,574,1,0,0,0,576,577,
  	1,0,0,0,577,579,1,0,0,0,578,576,1,0,0,0,579,580,3,116,58,0,580,35,1,0,
  	0,0,581,585,5,13,0,0,582,584,5,5,0,0,583,582,1,0,0,0,584,587,1,0,0,0,
  	585,583,1,0,0,0,585,586,1,0,0,0,586,591,1,0,0,0,587,585,1,0,0,0,588,590,
  	3,38,19,0,589,588,1,0,0,0,590,593,1,0,0,0,591,589,1,0,0,0,591,592,1,0,
  	0,0,592,597,1,0,0,0,593,591,1,0,0,0,594,596,5,5,0,0,595,594,1,0,0,0,596,
  	599,1,0,0,0,597,595,1,0,0,0,597,598,1,0,0,0,598,600,1,0,0,0,599,597,1,
  	0,0,0,600,601,5,14,0,0,601,37,1,0,0,0,602,611,3,20,10,0,603,611,3,52,
  	26,0,604,611,3,62,31,0,605,611,3,64,32,0,606,611,3,66,33,0,607,611,3,
  	40,20,0,608,611,3,42,21,0,609,611,3,76,38,0,610,602,1,0,0,0,610,603,1,
  	0,0,0,610,604,1,0,0,0,610,605,1,0,0,0,610,606,1,0,0,0,610,607,1,0,0,0,
  	610,608,1,0,0,0,610,609,1,0,0,0,611,613,1,0,0,0,612,614,3,290,145,0,613,
  	612,1,0,0,0,614,615,1,0,0,0,615,613,1,0,0,0,615,616,1,0,0,0,616,39,1,
  	0,0,0,617,621,5,69,0,0,618,620,5,5,0,0,619,618,1,0,0,0,620,623,1,0,0,
  	0,621,619,1,0,0,0,621,622,1,0,0,0,622,624,1,0,0,0,623,621,1,0,0,0,624,
  	625,3,106,53,0,625,41,1,0,0,0,626,628,3,250,125,0,627,626,1,0,0,0,627,
  	628,1,0,0,0,628,629,1,0,0,0,629,633,5,66,0,0,630,632,5,5,0,0,631,630,
  	1,0,0,0,632,635,1,0,0,0,633,631,1,0,0,0,633,634,1,0,0,0,634,636,1,0,0,
  	0,635,633,1,0,0,0,636,651,3,54,27,0,637,639,5,5,0,0,638,637,1,0,0,0,639,
  	642,1,0,0,0,640,638,1,0,0,0,640,641,1,0,0,0,641,643,1,0,0,0,642,640,1,
  	0,0,0,643,647,5,25,0,0,644,646,5,5,0,0,645,644,1,0,0,0,646,649,1,0,0,
  	0,647,645,1,0,0,0,647,648,1,0,0,0,648,650,1,0,0,0,649,647,1,0,0,0,650,
  	652,3,44,22,0,651,640,1,0,0,0,651,652,1,0,0,0,652,656,1,0,0,0,653,655,
  	5,5,0,0,654,653,1,0,0,0,655,658,1,0,0,0,656,654,1,0,0,0,656,657,1,0,0,
  	0,657,660,1,0,0,0,658,656,1,0,0,0,659,661,3,106,53,0,660,659,1,0,0,0,
  	660,661,1,0,0,0,661,43,1,0,0,0,662,666,5,70,0,0,663,665,5,5,0,0,664,663,
  	1,0,0,0,665,668,1,0,0,0,666,664,1,0,0,0,666,667,1,0,0,0,667,669,1,0,0,
  	0,668,666,1,0,0,0,669,679,3,154,77,0,670,674,5,71,0,0,671,673,5,5,0,0,
  	672,671,1,0,0,0,673,676,1,0,0,0,674,672,1,0,0,0,674,675,1,0,0,0,675,677,
  	1,0,0,0,676,674,1,0,0,0,677,679,3,154,77,0,678,662,1,0,0,0,678,670,1,
  	0,0,0,679,45,1,0,0,0,680,684,5,13,0,0,681,683,5,5,0,0,682,681,1,0,0,0,
  	683,686,1,0,0,0,684,682,1,0,0,0,684,685,1,0,0,0,685,688,1,0,0,0,686,684,
  	1,0,0,0,687,689,3,48,24,0,688,687,1,0,0,0,688,689,1,0,0,0,689,709,1,0,
  	0,0,690,692,5,5,0,0,691,690,1,0,0,0,692,695,1,0,0,0,693,691,1,0,0,0,693,
  	694,1,0,0,0,694,696,1,0,0,0,695,693,1,0,0,0,696,700,5,26,0,0,697,699,
  	5,5,0,0,698,697,1,0,0,0,699,702,1,0,0,0,700,698,1,0,0,0,700,701,1,0,0,
  	0,701,706,1,0,0,0,702,700,1,0,0,0,703,705,3,38,19,0,704,703,1,0,0,0,705,
  	708,1,0,0,0,706,704,1,0,0,0,706,707,1,0,0,0,707,710,1,0,0,0,708,706,1,
  	0,0,0,709,693,1,0,0,0,709,710,1,0,0,0,710,714,1,0,0,0,711,713,5,5,0,0,
  	712,711,1,0,0,0,713,716,1,0,0,0,714,712,1,0,0,0,714,715,1,0,0,0,715,717,
  	1,0,0,0,716,714,1,0,0,0,717,718,5,14,0,0,718,47,1,0,0,0,719,723,3,50,
  	25,0,720,722,5,5,0,0,721,720,1,0,0,0,722,725,1,0,0,0,723,721,1,0,0,0,
  	723,724,1,0,0,0,724,727,1,0,0,0,725,723,1,0,0,0,726,719,1,0,0,0,727,728,
  	1,0,0,0,728,726,1,0,0,0,728,729,1,0,0,0,729,731,1,0,0,0,730,732,5,26,
  	0,0,731,730,1,0,0,0,731,732,1,0,0,0,732,49,1,0,0,0,733,741,3,286,143,
  	0,734,736,5,5,0,0,735,734,1,0,0,0,736,739,1,0,0,0,737,735,1,0,0,0,737,
  	738,1,0,0,0,738,740,1,0,0,0,739,737,1,0,0,0,740,742,3,154,77,0,741,737,
  	1,0,0,0,741,742,1,0,0,0,742,750,1,0,0,0,743,745,5,5,0,0,744,743,1,0,0,
  	0,745,748,1,0,0,0,746,744,1,0,0,0,746,747,1,0,0,0,747,749,1,0,0,0,748,
  	746,1,0,0,0,749,751,3,36,18,0,750,746,1,0,0,0,750,751,1,0,0,0,751,759,
  	1,0,0,0,752,754,5,5,0,0,753,752,1,0,0,0,754,757,1,0,0,0,755,753,1,0,0,
  	0,755,756,1,0,0,0,756,758,1,0,0,0,757,755,1,0,0,0,758,760,5,8,0,0,759,
  	755,1,0,0,0,759,760,1,0,0,0,760,51,1,0,0,0,761,763,3,250,125,0,762,761,
  	1,0,0,0,762,763,1,0,0,0,763,764,1,0,0,0,764,780,5,61,0,0,765,767,5,5,
  	0,0,766,765,1,0,0,0,767,770,1,0,0,0,768,766,1,0,0,0,768,769,1,0,0,0,769,
  	771,1,0,0,0,770,768,1,0,0,0,771,775,3,82,41,0,772,774,5,5,0,0,773,772,
  	1,0,0,0,774,777,1,0,0,0,775,773,1,0,0,0,775,776,1,0,0,0,776,778,1,0,0,
  	0,777,775,1,0,0,0,778,779,5,7,0,0,779,781,1,0,0,0,780,768,1,0,0,0,780,
  	781,1,0,0,0,781,789,1,0,0,0,782,784,5,5,0,0,783,782,1,0,0,0,784,787,1,
  	0,0,0,785,783,1,0,0,0,785,786,1,0,0,0,786,788,1,0,0,0,787,785,1,0,0,0,
  	788,790,3,78,39,0,789,785,1,0,0,0,789,790,1,0,0,0,790,798,1,0,0,0,791,
  	793,5,5,0,0,792,791,1,0,0,0,793,796,1,0,0,0,794,792,1,0,0,0,794,795,1,
  	0,0,0,795,797,1,0,0,0,796,794,1,0,0,0,797,799,3,284,142,0,798,794,1,0,
  	0,0,798,799,1,0,0,0,799,803,1,0,0,0,800,802,5,5,0,0,801,800,1,0,0,0,802,
  	805,1,0,0,0,803,801,1,0,0,0,803,804,1,0,0,0,804,806,1,0,0,0,805,803,1,
  	0,0,0,806,821,3,54,27,0,807,809,5,5,0,0,808,807,1,0,0,0,809,812,1,0,0,
  	0,810,808,1,0,0,0,810,811,1,0,0,0,811,813,1,0,0,0,812,810,1,0,0,0,813,
  	817,5,25,0,0,814,816,5,5,0,0,815,814,1,0,0,0,816,819,1,0,0,0,817,815,
  	1,0,0,0,817,818,1,0,0,0,818,820,1,0,0,0,819,817,1,0,0,0,820,822,3,82,
  	41,0,821,810,1,0,0,0,821,822,1,0,0,0,822,830,1,0,0,0,823,825,5,5,0,0,
  	824,823,1,0,0,0,825,828,1,0,0,0,826,824,1,0,0,0,826,827,1,0,0,0,827,829,
  	1,0,0,0,828,826,1,0,0,0,829,831,3,102,51,0,830,826,1,0,0,0,830,831,1,
  	0,0,0,831,839,1,0,0,0,832,834,5,5,0,0,833,832,1,0,0,0,834,837,1,0,0,0,
  	835,833,1,0,0,0,835,836,1,0,0,0,836,838,1,0,0,0,837,835,1,0,0,0,838,840,
  	3,60,30,0,839,835,1,0,0,0,839,840,1,0,0,0,840,53,1,0,0,0,841,850,5,9,
  	0,0,842,847,3,56,28,0,843,844,5,8,0,0,844,846,3,56,28,0,845,843,1,0,0,
  	0,846,849,1,0,0,0,847,845,1,0,0,0,847,848,1,0,0,0,848,851,1,0,0,0,849,
  	847,1,0,0,0,850,842,1,0,0,0,850,851,1,0,0,0,851,852,1,0,0,0,852,853,5,
  	10,0,0,853,55,1,0,0,0,854,856,3,250,125,0,855,854,1,0,0,0,855,856,1,0,
  	0,0,856,857,1,0,0,0,857,860,3,58,29,0,858,859,5,27,0,0,859,861,3,116,
  	58,0,860,858,1,0,0,0,860,861,1,0,0,0,861,57,1,0,0,0,862,863,3,286,143,
  	0,863,864,5,25,0,0,864,865,3,82,41,0,865,59,1,0,0,0,866,876,3,106,53,
  	0,867,871,5,27,0,0,868,870,5,5,0,0,869,868,1,0,0,0,870,873,1,0,0,0,871,
  	869,1,0,0,0,871,872,1,0,0,0,872,874,1,0,0,0,873,871,1,0,0,0,874,876,3,
  	116,58,0,875,866,1,0,0,0,875,867,1,0,0,0,876,61,1,0,0,0,877,879,3,250,
  	125,0,878,877,1,0,0,0,878,879,1,0,0,0,879,880,1,0,0,0,880,884,5,62,0,
  	0,881,883,5,5,0,0,882,881,1,0,0,0,883,886,1,0,0,0,884,882,1,0,0,0,884,
  	885,1,0,0,0,885,887,1,0,0,0,886,884,1,0,0,0,887,895,3,286,143,0,888,890,
  	5,5,0,0,889,888,1,0,0,0,890,893,1,0,0,0,891,889,1,0,0,0,891,892,1,0,0,
  	0,892,894,1,0,0,0,893,891,1,0,0,0,894,896,3,22,11,0,895,891,1,0,0,0,895,
  	896,1,0,0,0,896,911,1,0,0,0,897,899,5,5,0,0,898,897,1,0,0,0,899,902,1,
  	0,0,0,900,898,1,0,0,0,900,901,1,0,0,0,901,903,1,0,0,0,902,900,1,0,0,0,
  	903,907,5,25,0,0,904,906,5,5,0,0,905,904,1,0,0,0,906,909,1,0,0,0,907,
  	905,1,0,0,0,907,908,1,0,0,0,908,910,1,0,0,0,909,907,1,0,0,0,910,912,3,
  	28,14,0,911,900,1,0,0,0,911,912,1,0,0,0,912,920,1,0,0,0,913,915,5,5,0,
  	0,914,913,1,0,0,0,915,918,1,0,0,0,916,914,1,0,0,0,916,917,1,0,0,0,917,
  	919,1,0,0,0,918,916,1,0,0,0,919,921,3,36,18,0,920,916,1,0,0,0,920,921,
  	1,0,0,0,921,63,1,0,0,0,922,924,3,250,125,0,923,922,1,0,0,0,923,924,1,
  	0,0,0,924,925,1,0,0,0,925,929,5,68,0,0,926,928,5,5,0,0,927,926,1,0,0,
  	0,928,931,1,0,0,0,929,927,1,0,0,0,929,930,1,0,0,0,930,933,1,0,0,0,931,
  	929,1,0,0,0,932,934,3,250,125,0,933,932,1,0,0,0,933,934,1,0,0,0,934,935,
  	1,0,0,0,935,943,5,62,0,0,936,938,5,5,0,0,937,936,1,0,0,0,938,941,1,0,
  	0,0,939,937,1,0,0,0,939,940,1,0,0,0,940,942,1,0,0,0,941,939,1,0,0,0,942,
  	944,3,286,143,0,943,939,1,0,0,0,943,944,1,0,0,0,944,959,1,0,0,0,945,947,
  	5,5,0,0,946,945,1,0,0,0,947,950,1,0,0,0,948,946,1,0,0,0,948,949,1,0,0,
  	0,949,951,1,0,0,0,950,948,1,0,0,0,951,955,5,25,0,0,952,954,5,5,0,0,953,
  	952,1,0,0,0,954,957,1,0,0,0,955,953,1,0,0,0,955,956,1,0,0,0,956,958,1,
  	0,0,0,957,955,1,0,0,0,958,960,3,28,14,0,959,948,1,0,0,0,959,960,1,0,0,
  	0,960,968,1,0,0,0,961,963,5,5,0,0,962,961,1,0,0,0,963,966,1,0,0,0,964,
  	962,1,0,0,0,964,965,1,0,0,0,965,967,1,0,0,0,966,964,1,0,0,0,967,969,3,
  	36,18,0,968,964,1,0,0,0,968,969,1,0,0,0,969,65,1,0,0,0,970,972,3,250,
  	125,0,971,970,1,0,0,0,971,972,1,0,0,0,972,973,1,0,0,0,973,981,7,1,0,0,
  	974,976,5,5,0,0,975,974,1,0,0,0,976,979,1,0,0,0,977,975,1,0,0,0,977,978,
  	1,0,0,0,978,980,1,0,0,0,979,977,1,0,0,0,980,982,3,78,39,0,981,977,1,0,
  	0,0,981,982,1,0,0,0,982,998,1,0,0,0,983,985,5,5,0,0,984,983,1,0,0,0,985,
  	988,1,0,0,0,986,984,1,0,0,0,986,987,1,0,0,0,987,989,1,0,0,0,988,986,1,
  	0,0,0,989,993,3,82,41,0,990,992,5,5,0,0,991,990,1,0,0,0,992,995,1,0,0,
  	0,993,991,1,0,0,0,993,994,1,0,0,0,994,996,1,0,0,0,995,993,1,0,0,0,996,
  	997,5,7,0,0,997,999,1,0,0,0,998,986,1,0,0,0,998,999,1,0,0,0,999,1003,
  	1,0,0,0,1000,1002,5,5,0,0,1001,1000,1,0,0,0,1002,1005,1,0,0,0,1003,1001,
  	1,0,0,0,1003,1004,1,0,0,0,1004,1008,1,0,0,0,1005,1003,1,0,0,0,1006,1009,
  	3,68,34,0,1007,1009,3,70,35,0,1008,1006,1,0,0,0,1008,1007,1,0,0,0,1009,
  	1017,1,0,0,0,1010,1012,5,5,0,0,1011,1010,1,0,0,0,1012,1015,1,0,0,0,1013,
  	1011,1,0,0,0,1013,1014,1,0,0,0,1014,1016,1,0,0,0,1015,1013,1,0,0,0,1016,
  	1018,3,102,51,0,1017,1013,1,0,0,0,1017,1018,1,0,0,0,1018,1033,1,0,0,0,
  	1019,1021,5,5,0,0,1020,1019,1,0,0,0,1021,1024,1,0,0,0,1022,1020,1,0,0,
  	0,1022,1023,1,0,0,0,1023,1025,1,0,0,0,1024,1022,1,0,0,0,1025,1029,7,2,
  	0,0,1026,1028,5,5,0,0,1027,1026,1,0,0,0,1028,1031,1,0,0,0,1029,1027,1,
  	0,0,0,1029,1030,1,0,0,0,1030,1032,1,0,0,0,1031,1029,1,0,0,0,1032,1034,
  	3,116,58,0,1033,1022,1,0,0,0,1033,1034,1,0,0,0,1034,1047,1,0,0,0,1035,
  	1039,3,72,36,0,1036,1037,3,288,144,0,1037,1038,3,74,37,0,1038,1040,1,
  	0,0,0,1039,1036,1,0,0,0,1039,1040,1,0,0,0,1040,1048,1,0,0,0,1041,1045,
  	3,74,37,0,1042,1043,3,288,144,0,1043,1044,3,72,36,0,1044,1046,1,0,0,0,
  	1045,1042,1,0,0,0,1045,1046,1,0,0,0,1046,1048,1,0,0,0,1047,1035,1,0,0,
  	0,1047,1041,1,0,0,0,1047,1048,1,0,0,0,1048,67,1,0,0,0,1049,1050,5,9,0,
  	0,1050,1055,3,70,35,0,1051,1052,5,8,0,0,1052,1054,3,70,35,0,1053,1051,
  	1,0,0,0,1054,1057,1,0,0,0,1055,1053,1,0,0,0,1055,1056,1,0,0,0,1056,1058,
  	1,0,0,0,1057,1055,1,0,0,0,1058,1059,5,10,0,0,1059,69,1,0,0,0,1060,1063,
  	3,286,143,0,1061,1062,5,25,0,0,1062,1064,3,82,41,0,1063,1061,1,0,0,0,
  	1063,1064,1,0,0,0,1064,71,1,0,0,0,1065,1067,3,250,125,0,1066,1065,1,0,
  	0,0,1066,1067,1,0,0,0,1067,1068,1,0,0,0,1068,1115,5,97,0,0,1069,1071,
  	3,250,125,0,1070,1069,1,0,0,0,1070,1071,1,0,0,0,1071,1072,1,0,0,0,1072,
  	1076,5,97,0,0,1073,1075,5,5,0,0,1074,1073,1,0,0,0,1075,1078,1,0,0,0,1076,
  	1074,1,0,0,0,1076,1077,1,0,0,0,1077,1079,1,0,0,0,1078,1076,1,0,0,0,1079,
  	1080,5,9,0,0,1080,1095,5,10,0,0,1081,1083,5,5,0,0,1082,1081,1,0,0,0,1083,
  	1086,1,0,0,0,1084,1082,1,0,0,0,1084,1085,1,0,0,0,1085,1087,1,0,0,0,1086,
  	1084,1,0,0,0,1087,1091,5,25,0,0,1088,1090,5,5,0,0,1089,1088,1,0,0,0,1090,
  	1093,1,0,0,0,1091,1089,1,0,0,0,1091,1092,1,0,0,0,1092,1094,1,0,0,0,1093,
  	1091,1,0,0,0,1094,1096,3,82,41,0,1095,1084,1,0,0,0,1095,1096,1,0,0,0,
  	1096,1100,1,0,0,0,1097,1099,5,5,0,0,1098,1097,1,0,0,0,1099,1102,1,0,0,
  	0,1100,1098,1,0,0,0,1100,1101,1,0,0,0,1101,1112,1,0,0,0,1102,1100,1,0,
  	0,0,1103,1113,3,106,53,0,1104,1108,5,27,0,0,1105,1107,5,5,0,0,1106,1105,
  	1,0,0,0,1107,1110,1,0,0,0,1108,1106,1,0,0,0,1108,1109,1,0,0,0,1109,1111,
  	1,0,0,0,1110,1108,1,0,0,0,1111,1113,3,116,58,0,1112,1103,1,0,0,0,1112,
  	1104,1,0,0,0,1113,1115,1,0,0,0,1114,1066,1,0,0,0,1114,1070,1,0,0,0,1115,
  	73,1,0,0,0,1116,1118,3,250,125,0,1117,1116,1,0,0,0,1117,1118,1,0,0,0,
  	1118,1119,1,0,0,0,1119,1152,5,98,0,0,1120,1122,3,250,125,0,1121,1120,
  	1,0,0,0,1121,1122,1,0,0,0,1122,1123,1,0,0,0,1123,1127,5,98,0,0,1124,1126,
  	5,5,0,0,1125,1124,1,0,0,0,1126,1129,1,0,0,0,1127,1125,1,0,0,0,1127,1128,
  	1,0,0,0,1128,1130,1,0,0,0,1129,1127,1,0,0,0,1130,1135,5,9,0,0,1131,1134,
  	3,274,137,0,1132,1134,3,268,134,0,1133,1131,1,0,0,0,1133,1132,1,0,0,0,
  	1134,1137,1,0,0,0,1135,1133,1,0,0,0,1135,1136,1,0,0,0,1136,1140,1,0,0,
  	0,1137,1135,1,0,0,0,1138,1141,3,286,143,0,1139,1141,3,58,29,0,1140,1138,
  	1,0,0,0,1140,1139,1,0,0,0,1141,1142,1,0,0,0,1142,1146,5,10,0,0,1143,1145,
  	5,5,0,0,1144,1143,1,0,0,0,1145,1148,1,0,0,0,1146,1144,1,0,0,0,1146,1147,
  	1,0,0,0,1147,1149,1,0,0,0,1148,1146,1,0,0,0,1149,1150,3,60,30,0,1150,
  	1152,1,0,0,0,1151,1117,1,0,0,0,1151,1121,1,0,0,0,1152,75,1,0,0,0,1153,
  	1155,3,250,125,0,1154,1153,1,0,0,0,1154,1155,1,0,0,0,1155,1156,1,0,0,
  	0,1156,1160,5,65,0,0,1157,1159,5,5,0,0,1158,1157,1,0,0,0,1159,1162,1,
  	0,0,0,1160,1158,1,0,0,0,1160,1161,1,0,0,0,1161,1163,1,0,0,0,1162,1160,
  	1,0,0,0,1163,1171,3,286,143,0,1164,1166,5,5,0,0,1165,1164,1,0,0,0,1166,
  	1169,1,0,0,0,1167,1165,1,0,0,0,1167,1168,1,0,0,0,1168,1170,1,0,0,0,1169,
  	1167,1,0,0,0,1170,1172,3,78,39,0,1171,1167,1,0,0,0,1171,1172,1,0,0,0,
  	1172,1176,1,0,0,0,1173,1175,5,5,0,0,1174,1173,1,0,0,0,1175,1178,1,0,0,
  	0,1176,1174,1,0,0,0,1176,1177,1,0,0,0,1177,1179,1,0,0,0,1178,1176,1,0,
  	0,0,1179,1183,5,27,0,0,1180,1182,5,5,0,0,1181,1180,1,0,0,0,1182,1185,
  	1,0,0,0,1183,1181,1,0,0,0,1183,1184,1,0,0,0,1184,1186,1,0,0,0,1185,1183,
  	1,0,0,0,1186,1187,3,82,41,0,1187,77,1,0,0,0,1188,1192,5,43,0,0,1189,1191,
  	5,5,0,0,1190,1189,1,0,0,0,1191,1194,1,0,0,0,1192,1190,1,0,0,0,1192,1193,
  	1,0,0,0,1193,1195,1,0,0,0,1194,1192,1,0,0,0,1195,1212,3,80,40,0,1196,
  	1198,5,5,0,0,1197,1196,1,0,0,0,1198,1201,1,0,0,0,1199,1197,1,0,0,0,1199,
  	1200,1,0,0,0,1200,1202,1,0,0,0,1201,1199,1,0,0,0,1202,1206,5,8,0,0,1203,
  	1205,5,5,0,0,1204,1203,1,0,0,0,1205,1208,1,0,0,0,1206,1204,1,0,0,0,1206,
  	1207,1,0,0,0,1207,1209,1,0,0,0,1208,1206,1,0,0,0,1209,1211,3,80,40,0,
  	1210,1199,1,0,0,0,1211,1214,1,0,0,0,1212,1210,1,0,0,0,1212,1213,1,0,0,
  	0,1213,1218,1,0,0,0,1214,1212,1,0,0,0,1215,1217,5,5,0,0,1216,1215,1,0,
  	0,0,1217,1220,1,0,0,0,1218,1216,1,0,0,0,1218,1219,1,0,0,0,1219,1221,1,
  	0,0,0,1220,1218,1,0,0,0,1221,1222,5,44,0,0,1222,79,1,0,0,0,1223,1225,
  	3,250,125,0,1224,1223,1,0,0,0,1224,1225,1,0,0,0,1225,1229,1,0,0,0,1226,
  	1228,5,5,0,0,1227,1226,1,0,0,0,1228,1231,1,0,0,0,1229,1227,1,0,0,0,1229,
  	1230,1,0,0,0,1230,1232,1,0,0,0,1231,1229,1,0,0,0,1232,1247,3,286,143,
  	0,1233,1235,5,5,0,0,1234,1233,1,0,0,0,1235,1238,1,0,0,0,1236,1234,1,0,
  	0,0,1236,1237,1,0,0,0,1237,1239,1,0,0,0,1238,1236,1,0,0,0,1239,1243,5,
  	25,0,0,1240,1242,5,5,0,0,1241,1240,1,0,0,0,1242,1245,1,0,0,0,1243,1241,
  	1,0,0,0,1243,1244,1,0,0,0,1244,1246,1,0,0,0,1245,1243,1,0,0,0,1246,1248,
  	3,82,41,0,1247,1236,1,0,0,0,1247,1248,1,0,0,0,1248,81,1,0,0,0,1249,1251,
  	3,84,42,0,1250,1249,1,0,0,0,1250,1251,1,0,0,0,1251,1256,1,0,0,0,1252,
  	1257,3,92,46,0,1253,1257,3,86,43,0,1254,1257,3,88,44,0,1255,1257,3,90,
  	45,0,1256,1252,1,0,0,0,1256,1253,1,0,0,0,1256,1254,1,0,0,0,1256,1255,
  	1,0,0,0,1257,83,1,0,0,0,1258,1267,3,274,137,0,1259,1263,5,118,0,0,1260,
  	1262,5,5,0,0,1261,1260,1,0,0,0,1262,1265,1,0,0,0,1263,1261,1,0,0,0,1263,
  	1264,1,0,0,0,1264,1267,1,0,0,0,1265,1263,1,0,0,0,1266,1258,1,0,0,0,1266,
  	1259,1,0,0,0,1267,1268,1,0,0,0,1268,1266,1,0,0,0,1268,1269,1,0,0,0,1269,
  	85,1,0,0,0,1270,1271,5,9,0,0,1271,1272,3,82,41,0,1272,1273,5,10,0,0,1273,
  	87,1,0,0,0,1274,1277,3,90,45,0,1275,1277,3,86,43,0,1276,1274,1,0,0,0,
  	1276,1275,1,0,0,0,1277,1281,1,0,0,0,1278,1280,5,5,0,0,1279,1278,1,0,0,
  	0,1280,1283,1,0,0,0,1281,1279,1,0,0,0,1281,1282,1,0,0,0,1282,1285,1,0,
  	0,0,1283,1281,1,0,0,0,1284,1286,5,41,0,0,1285,1284,1,0,0,0,1286,1287,
  	1,0,0,0,1287,1285,1,0,0,0,1287,1288,1,0,0,0,1288,89,1,0,0,0,1289,1290,
  	5,9,0,0,1290,1291,3,90,45,0,1291,1292,5,10,0,0,1292,1296,1,0,0,0,1293,
  	1296,3,96,48,0,1294,1296,5,103,0,0,1295,1289,1,0,0,0,1295,1293,1,0,0,
  	0,1295,1294,1,0,0,0,1296,91,1,0,0,0,1297,1301,3,94,47,0,1298,1300,5,5,
  	0,0,1299,1298,1,0,0,0,1300,1303,1,0,0,0,1301,1299,1,0,0,0,1301,1302,1,
  	0,0,0,1302,1304,1,0,0,0,1303,1301,1,0,0,0,1304,1308,5,7,0,0,1305,1307,
  	5,5,0,0,1306,1305,1,0,0,0,1307,1310,1,0,0,0,1308,1306,1,0,0,0,1308,1309,
  	1,0,0,0,1309,1312,1,0,0,0,1310,1308,1,0,0,0,1311,1297,1,0,0,0,1311,1312,
  	1,0,0,0,1312,1313,1,0,0,0,1313,1317,3,100,50,0,1314,1316,5,5,0,0,1315,
  	1314,1,0,0,0,1316,1319,1,0,0,0,1317,1315,1,0,0,0,1317,1318,1,0,0,0,1318,
  	1320,1,0,0,0,1319,1317,1,0,0,0,1320,1324,5,33,0,0,1321,1323,5,5,0,0,1322,
  	1321,1,0,0,0,1323,1326,1,0,0,0,1324,1322,1,0,0,0,1324,1325,1,0,0,0,1325,
  	1327,1,0,0,0,1326,1324,1,0,0,0,1327,1328,3,82,41,0,1328,93,1,0,0,0,1329,
  	1333,3,86,43,0,1330,1333,3,88,44,0,1331,1333,3,90,45,0,1332,1329,1,0,
  	0,0,1332,1330,1,0,0,0,1332,1331,1,0,0,0,1333,95,1,0,0,0,1334,1351,3,98,
  	49,0,1335,1337,5,5,0,0,1336,1335,1,0,0,0,1337,1340,1,0,0,0,1338,1336,
  	1,0,0,0,1338,1339,1,0,0,0,1339,1341,1,0,0,0,1340,1338,1,0,0,0,1341,1345,
  	5,7,0,0,1342,1344,5,5,0,0,1343,1342,1,0,0,0,1344,1347,1,0,0,0,1345,1343,
  	1,0,0,0,1345,1346,1,0,0,0,1346,1348,1,0,0,0,1347,1345,1,0,0,0,1348,1350,
  	3,98,49,0,1349,1338,1,0,0,0,1350,1353,1,0,0,0,1351,1349,1,0,0,0,1351,
  	1352,1,0,0,0,1352,97,1,0,0,0,1353,1351,1,0,0,0,1354,1362,3,286,143,0,
  	1355,1357,5,5,0,0,1356,1355,1,0,0,0,1357,1360,1,0,0,0,1358,1356,1,0,0,
  	0,1358,1359,1,0,0,0,1359,1361,1,0,0,0,1360,1358,1,0,0,0,1361,1363,3,156,
  	78,0,1362,1358,1,0,0,0,1362,1363,1,0,0,0,1363,99,1,0,0,0,1364,1367,5,
  	9,0,0,1365,1368,3,58,29,0,1366,1368,3,82,41,0,1367,1365,1,0,0,0,1367,
  	1366,1,0,0,0,1367,1368,1,0,0,0,1368,1376,1,0,0,0,1369,1372,5,8,0,0,1370,
  	1373,3,58,29,0,1371,1373,3,82,41,0,1372,1370,1,0,0,0,1372,1371,1,0,0,
  	0,1373,1375,1,0,0,0,1374,1369,1,0,0,0,1375,1378,1,0,0,0,1376,1374,1,0,
  	0,0,1376,1377,1,0,0,0,1377,1379,1,0,0,0,1378,1376,1,0,0,0,1379,1380,5,
  	10,0,0,1380,101,1,0,0,0,1381,1385,5,73,0,0,1382,1384,5,5,0,0,1383,1382,
  	1,0,0,0,1384,1387,1,0,0,0,1385,1383,1,0,0,0,1385,1386,1,0,0,0,1386,1388,
  	1,0,0,0,1387,1385,1,0,0,0,1388,1405,3,104,52,0,1389,1391,5,5,0,0,1390,
  	1389,1,0,0,0,1391,1394,1,0,0,0,1392,1390,1,0,0,0,1392,1393,1,0,0,0,1393,
  	1395,1,0,0,0,1394,1392,1,0,0,0,1395,1399,5,8,0,0,1396,1398,5,5,0,0,1397,
  	1396,1,0,0,0,1398,1401,1,0,0,0,1399,1397,1,0,0,0,1399,1400,1,0,0,0,1400,
  	1402,1,0,0,0,1401,1399,1,0,0,0,1402,1404,3,104,52,0,1403,1392,1,0,0,0,
  	1404,1407,1,0,0,0,1405,1403,1,0,0,0,1405,1406,1,0,0,0,1406,103,1,0,0,
  	0,1407,1405,1,0,0,0,1408,1410,3,274,137,0,1409,1408,1,0,0,0,1410,1413,
  	1,0,0,0,1411,1409,1,0,0,0,1411,1412,1,0,0,0,1412,1414,1,0,0,0,1413,1411,
  	1,0,0,0,1414,1418,3,286,143,0,1415,1417,5,5,0,0,1416,1415,1,0,0,0,1417,
  	1420,1,0,0,0,1418,1416,1,0,0,0,1418,1419,1,0,0,0,1419,1421,1,0,0,0,1420,
  	1418,1,0,0,0,1421,1425,5,25,0,0,1422,1424,5,5,0,0,1423,1422,1,0,0,0,1424,
  	1427,1,0,0,0,1425,1423,1,0,0,0,1425,1426,1,0,0,0,1426,1428,1,0,0,0,1427,
  	1425,1,0,0,0,1428,1429,3,82,41,0,1429,105,1,0,0,0,1430,1431,5,13,0,0,
  	1431,1432,3,108,54,0,1432,1433,5,14,0,0,1433,107,1,0,0,0,1434,1436,3,
  	290,145,0,1435,1434,1,0,0,0,1436,1439,1,0,0,0,1437,1435,1,0,0,0,1437,
  	1438,1,0,0,0,1438,1454,1,0,0,0,1439,1437,1,0,0,0,1440,1451,3,110,55,0,
  	1441,1443,3,290,145,0,1442,1441,1,0,0,0,1443,1444,1,0,0,0,1444,1442,1,
  	0,0,0,1444,1445,1,0,0,0,1445,1447,1,0,0,0,1446,1448,3,110,55,0,1447,1446,
  	1,0,0,0,1447,1448,1,0,0,0,1448,1450,1,0,0,0,1449,1442,1,0,0,0,1450,1453,
  	1,0,0,0,1451,1449,1,0,0,0,1451,1452,1,0,0,0,1452,1455,1,0,0,0,1453,1451,
  	1,0,0,0,1454,1440,1,0,0,0,1454,1455,1,0,0,0,1455,109,1,0,0,0,1456,1459,
  	3,114,57,0,1457,1459,3,112,56,0,1458,1456,1,0,0,0,1458,1457,1,0,0,0,1459,
  	111,1,0,0,0,1460,1462,3,274,137,0,1461,1460,1,0,0,0,1462,1465,1,0,0,0,
  	1463,1461,1,0,0,0,1463,1464,1,0,0,0,1464,1469,1,0,0,0,1465,1463,1,0,0,
  	0,1466,1468,5,5,0,0,1467,1466,1,0,0,0,1468,1471,1,0,0,0,1469,1467,1,0,
  	0,0,1469,1470,1,0,0,0,1470,1472,1,0,0,0,1471,1469,1,0,0,0,1472,1473,3,
  	116,58,0,1473,113,1,0,0,0,1474,1476,3,272,136,0,1475,1474,1,0,0,0,1476,
  	1479,1,0,0,0,1477,1475,1,0,0,0,1477,1478,1,0,0,0,1478,1484,1,0,0,0,1479,
  	1477,1,0,0,0,1480,1485,3,20,10,0,1481,1485,3,52,26,0,1482,1485,3,66,33,
  	0,1483,1485,3,76,38,0,1484,1480,1,0,0,0,1484,1481,1,0,0,0,1484,1482,1,
  	0,0,0,1484,1483,1,0,0,0,1485,115,1,0,0,0,1486,1492,3,118,59,0,1487,1488,
  	3,228,114,0,1488,1489,3,118,59,0,1489,1491,1,0,0,0,1490,1487,1,0,0,0,
  	1491,1494,1,0,0,0,1492,1490,1,0,0,0,1492,1493,1,0,0,0,1493,117,1,0,0,
  	0,1494,1492,1,0,0,0,1495,1512,3,120,60,0,1496,1498,5,5,0,0,1497,1496,
  	1,0,0,0,1498,1501,1,0,0,0,1499,1497,1,0,0,0,1499,1500,1,0,0,0,1500,1502,
  	1,0,0,0,1501,1499,1,0,0,0,1502,1506,5,23,0,0,1503,1505,5,5,0,0,1504,1503,
  	1,0,0,0,1505,1508,1,0,0,0,1506,1504,1,0,0,0,1506,1507,1,0,0,0,1507,1509,
  	1,0,0,0,1508,1506,1,0,0,0,1509,1511,3,120,60,0,1510,1499,1,0,0,0,1511,
  	1514,1,0,0,0,1512,1510,1,0,0,0,1512,1513,1,0,0,0,1513,119,1,0,0,0,1514,
  	1512,1,0,0,0,1515,1532,3,122,61,0,1516,1518,5,5,0,0,1517,1516,1,0,0,0,
  	1518,1521,1,0,0,0,1519,1517,1,0,0,0,1519,1520,1,0,0,0,1520,1522,1,0,0,
  	0,1521,1519,1,0,0,0,1522,1526,5,22,0,0,1523,1525,5,5,0,0,1524,1523,1,
  	0,0,0,1525,1528,1,0,0,0,1526,1524,1,0,0,0,1526,1527,1,0,0,0,1527,1529,
  	1,0,0,0,1528,1526,1,0,0,0,1529,1531,3,122,61,0,1530,1519,1,0,0,0,1531,
  	1534,1,0,0,0,1532,1530,1,0,0,0,1532,1533,1,0,0,0,1533,121,1,0,0,0,1534,
  	1532,1,0,0,0,1535,1547,3,124,62,0,1536,1540,3,230,115,0,1537,1539,5,5,
  	0,0,1538,1537,1,0,0,0,1539,1542,1,0,0,0,1540,1538,1,0,0,0,1540,1541,1,
  	0,0,0,1541,1543,1,0,0,0,1542,1540,1,0,0,0,1543,1544,3,124,62,0,1544,1546,
  	1,0,0,0,1545,1536,1,0,0,0,1546,1549,1,0,0,0,1547,1545,1,0,0,0,1547,1548,
  	1,0,0,0,1548,123,1,0,0,0,1549,1547,1,0,0,0,1550,1560,3,126,63,0,1551,
  	1555,3,232,116,0,1552,1554,5,5,0,0,1553,1552,1,0,0,0,1554,1557,1,0,0,
  	0,1555,1553,1,0,0,0,1555,1556,1,0,0,0,1556,1558,1,0,0,0,1557,1555,1,0,
  	0,0,1558,1559,3,126,63,0,1559,1561,1,0,0,0,1560,1551,1,0,0,0,1560,1561,
  	1,0,0,0,1561,125,1,0,0,0,1562,1585,3,128,64,0,1563,1567,3,234,117,0,1564,
  	1566,5,5,0,0,1565,1564,1,0,0,0,1566,1569,1,0,0,0,1567,1565,1,0,0,0,1567,
  	1568,1,0,0,0,1568,1570,1,0,0,0,1569,1567,1,0,0,0,1570,1571,3,128,64,0,
  	1571,1573,1,0,0,0,1572,1563,1,0,0,0,1573,1574,1,0,0,0,1574,1572,1,0,0,
  	0,1574,1575,1,0,0,0,1575,1586,1,0,0,0,1576,1580,3,236,118,0,1577,1579,
  	5,5,0,0,1578,1577,1,0,0,0,1579,1582,1,0,0,0,1580,1578,1,0,0,0,1580,1581,
  	1,0,0,0,1581,1583,1,0,0,0,1582,1580,1,0,0,0,1583,1584,3,82,41,0,1584,
  	1586,1,0,0,0,1585,1572,1,0,0,0,1585,1576,1,0,0,0,1585,1586,1,0,0,0,1586,
  	127,1,0,0,0,1587,1604,3,130,65,0,1588,1590,5,5,0,0,1589,1588,1,0,0,0,
  	1590,1593,1,0,0,0,1591,1589,1,0,0,0,1591,1592,1,0,0,0,1592,1594,1,0,0,
  	0,1593,1591,1,0,0,0,1594,1598,5,42,0,0,1595,1597,5,5,0,0,1596,1595,1,
  	0,0,0,1597,1600,1,0,0,0,1598,1596,1,0,0,0,1598,1599,1,0,0,0,1599,1601,
  	1,0,0,0,1600,1598,1,0,0,0,1601,1603,3,130,65,0,1602,1591,1,0,0,0,1603,
  	1606,1,0,0,0,1604,1602,1,0,0,0,1604,1605,1,0,0,0,1605,129,1,0,0,0,1606,
  	1604,1,0,0,0,1607,1619,3,132,66,0,1608,1612,3,286,143,0,1609,1611,5,5,
  	0,0,1610,1609,1,0,0,0,1611,1614,1,0,0,0,1612,1610,1,0,0,0,1612,1613,1,
  	0,0,0,1613,1615,1,0,0,0,1614,1612,1,0,0,0,1615,1616,3,132,66,0,1616,1618,
  	1,0,0,0,1617,1608,1,0,0,0,1618,1621,1,0,0,0,1619,1617,1,0,0,0,1619,1620,
  	1,0,0,0,1620,131,1,0,0,0,1621,1619,1,0,0,0,1622,1633,3,134,67,0,1623,
  	1627,5,35,0,0,1624,1626,5,5,0,0,1625,1624,1,0,0,0,1626,1629,1,0,0,0,1627,
  	1625,1,0,0,0,1627,1628,1,0,0,0,1628,1630,1,0,0,0,1629,1627,1,0,0,0,1630,
  	1632,3,134,67,0,1631,1623,1,0,0,0,1632,1635,1,0,0,0,1633,1631,1,0,0,0,
  	1633,1634,1,0,0,0,1634,133,1,0,0,0,1635,1633,1,0,0,0,1636,1648,3,136,
  	68,0,1637,1641,3,238,119,0,1638,1640,5,5,0,0,1639,1638,1,0,0,0,1640,1643,
  	1,0,0,0,1641,1639,1,0,0,0,1641,1642,1,0,0,0,1642,1644,1,0,0,0,1643,1641,
  	1,0,0,0,1644,1645,3,136,68,0,1645,1647,1,0,0,0,1646,1637,1,0,0,0,1647,
  	1650,1,0,0,0,1648,1646,1,0,0,0,1648,1649,1,0,0,0,1649,135,1,0,0,0,1650,
  	1648,1,0,0,0,1651,1663,3,138,69,0,1652,1656,3,240,120,0,1653,1655,5,5,
  	0,0,1654,1653,1,0,0,0,1655,1658,1,0,0,0,1656,1654,1,0,0,0,1656,1657,1,
  	0,0,0,1657,1659,1,0,0,0,1658,1656,1,0,0,0,1659,1660,3,138,69,0,1660,1662,
  	1,0,0,0,1661,1652,1,0,0,0,1662,1665,1,0,0,0,1663,1661,1,0,0,0,1663,1664,
  	1,0,0,0,1664,137,1,0,0,0,1665,1663,1,0,0,0,1666,1678,3,140,70,0,1667,
  	1669,5,5,0,0,1668,1667,1,0,0,0,1669,1672,1,0,0,0,1670,1668,1,0,0,0,1670,
  	1671,1,0,0,0,1671,1673,1,0,0,0,1672,1670,1,0,0,0,1673,1674,3,242,121,
  	0,1674,1675,3,140,70,0,1675,1677,1,0,0,0,1676,1670,1,0,0,0,1677,1680,
  	1,0,0,0,1678,1676,1,0,0,0,1678,1679,1,0,0,0,1679,139,1,0,0,0,1680,1678,
  	1,0,0,0,1681,1683,3,244,122,0,1682,1681,1,0,0,0,1683,1686,1,0,0,0,1684,
  	1682,1,0,0,0,1684,1685,1,0,0,0,1685,1687,1,0,0,0,1686,1684,1,0,0,0,1687,
  	1688,3,142,71,0,1688,141,1,0,0,0,1689,1692,3,144,72,0,1690,1692,3,226,
  	113,0,1691,1689,1,0,0,0,1691,1690,1,0,0,0,1692,1696,1,0,0,0,1693,1695,
  	3,246,123,0,1694,1693,1,0,0,0,1695,1698,1,0,0,0,1696,1694,1,0,0,0,1696,
  	1697,1,0,0,0,1697,143,1,0,0,0,1698,1696,1,0,0,0,1699,1712,3,146,73,0,
  	1700,1712,3,164,82,0,1701,1712,3,180,90,0,1702,1712,3,190,95,0,1703,1712,
  	3,192,96,0,1704,1712,3,194,97,0,1705,1712,3,210,105,0,1706,1712,3,186,
  	93,0,1707,1712,3,224,112,0,1708,1712,3,216,108,0,1709,1712,3,188,94,0,
  	1710,1712,3,286,143,0,1711,1699,1,0,0,0,1711,1700,1,0,0,0,1711,1701,1,
  	0,0,0,1711,1702,1,0,0,0,1711,1703,1,0,0,0,1711,1704,1,0,0,0,1711,1705,
  	1,0,0,0,1711,1706,1,0,0,0,1711,1707,1,0,0,0,1711,1708,1,0,0,0,1711,1709,
  	1,0,0,0,1711,1710,1,0,0,0,1712,145,1,0,0,0,1713,1714,5,9,0,0,1714,1715,
  	3,116,58,0,1715,1716,5,10,0,0,1716,147,1,0,0,0,1717,1719,3,156,78,0,1718,
  	1720,3,154,77,0,1719,1718,1,0,0,0,1719,1720,1,0,0,0,1720,1724,1,0,0,0,
  	1721,1723,3,150,75,0,1722,1721,1,0,0,0,1723,1726,1,0,0,0,1724,1722,1,
  	0,0,0,1724,1725,1,0,0,0,1725,1740,1,0,0,0,1726,1724,1,0,0,0,1727,1731,
  	3,154,77,0,1728,1730,3,150,75,0,1729,1728,1,0,0,0,1730,1733,1,0,0,0,1731,
  	1729,1,0,0,0,1731,1732,1,0,0,0,1732,1740,1,0,0,0,1733,1731,1,0,0,0,1734,
  	1736,3,150,75,0,1735,1734,1,0,0,0,1736,1737,1,0,0,0,1737,1735,1,0,0,0,
  	1737,1738,1,0,0,0,1738,1740,1,0,0,0,1739,1717,1,0,0,0,1739,1727,1,0,0,
  	0,1739,1735,1,0,0,0,1740,149,1,0,0,0,1741,1743,3,282,141,0,1742,1741,
  	1,0,0,0,1743,1746,1,0,0,0,1744,1742,1,0,0,0,1744,1745,1,0,0,0,1745,1748,
  	1,0,0,0,1746,1744,1,0,0,0,1747,1749,5,142,0,0,1748,1747,1,0,0,0,1748,
  	1749,1,0,0,0,1749,1753,1,0,0,0,1750,1752,5,5,0,0,1751,1750,1,0,0,0,1752,
  	1755,1,0,0,0,1753,1751,1,0,0,0,1753,1754,1,0,0,0,1754,1756,1,0,0,0,1755,
  	1753,1,0,0,0,1756,1757,3,180,90,0,1757,151,1,0,0,0,1758,1767,5,11,0,0,
  	1759,1764,3,116,58,0,1760,1761,5,8,0,0,1761,1763,3,116,58,0,1762,1760,
  	1,0,0,0,1763,1766,1,0,0,0,1764,1762,1,0,0,0,1764,1765,1,0,0,0,1765,1768,
  	1,0,0,0,1766,1764,1,0,0,0,1767,1759,1,0,0,0,1767,1768,1,0,0,0,1768,1769,
  	1,0,0,0,1769,1770,5,12,0,0,1770,153,1,0,0,0,1771,1780,5,9,0,0,1772,1777,
  	3,162,81,0,1773,1774,5,8,0,0,1774,1776,3,162,81,0,1775,1773,1,0,0,0,1776,
  	1779,1,0,0,0,1777,1775,1,0,0,0,1777,1778,1,0,0,0,1778,1781,1,0,0,0,1779,
  	1777,1,0,0,0,1780,1772,1,0,0,0,1780,1781,1,0,0,0,1781,1782,1,0,0,0,1782,
  	1783,5,10,0,0,1783,155,1,0,0,0,1784,1788,5,43,0,0,1785,1787,5,5,0,0,1786,
  	1785,1,0,0,0,1787,1790,1,0,0,0,1788,1786,1,0,0,0,1788,1789,1,0,0,0,1789,
  	1791,1,0,0,0,1790,1788,1,0,0,0,1791,1802,3,158,79,0,1792,1794,5,5,0,0,
  	1793,1792,1,0,0,0,1794,1797,1,0,0,0,1795,1793,1,0,0,0,1795,1796,1,0,0,
  	0,1796,1798,1,0,0,0,1797,1795,1,0,0,0,1798,1799,5,8,0,0,1799,1801,3,158,
  	79,0,1800,1795,1,0,0,0,1801,1804,1,0,0,0,1802,1800,1,0,0,0,1802,1803,
  	1,0,0,0,1803,1808,1,0,0,0,1804,1802,1,0,0,0,1805,1807,5,5,0,0,1806,1805,
  	1,0,0,0,1807,1810,1,0,0,0,1808,1806,1,0,0,0,1808,1809,1,0,0,0,1809,1811,
  	1,0,0,0,1810,1808,1,0,0,0,1811,1812,5,44,0,0,1812,157,1,0,0,0,1813,1815,
  	3,160,80,0,1814,1813,1,0,0,0,1814,1815,1,0,0,0,1815,1816,1,0,0,0,1816,
  	1819,3,82,41,0,1817,1819,5,15,0,0,1818,1814,1,0,0,0,1818,1817,1,0,0,0,
  	1819,159,1,0,0,0,1820,1822,3,260,130,0,1821,1820,1,0,0,0,1822,1823,1,
  	0,0,0,1823,1821,1,0,0,0,1823,1824,1,0,0,0,1824,161,1,0,0,0,1825,1829,
  	3,286,143,0,1826,1828,5,5,0,0,1827,1826,1,0,0,0,1828,1831,1,0,0,0,1829,
  	1827,1,0,0,0,1829,1830,1,0,0,0,1830,1832,1,0,0,0,1831,1829,1,0,0,0,1832,
  	1836,5,27,0,0,1833,1835,5,5,0,0,1834,1833,1,0,0,0,1835,1838,1,0,0,0,1836,
  	1834,1,0,0,0,1836,1837,1,0,0,0,1837,1840,1,0,0,0,1838,1836,1,0,0,0,1839,
  	1825,1,0,0,0,1839,1840,1,0,0,0,1840,1842,1,0,0,0,1841,1843,5,15,0,0,1842,
  	1841,1,0,0,0,1842,1843,1,0,0,0,1843,1847,1,0,0,0,1844,1846,5,5,0,0,1845,
  	1844,1,0,0,0,1846,1849,1,0,0,0,1847,1845,1,0,0,0,1847,1848,1,0,0,0,1848,
  	1850,1,0,0,0,1849,1847,1,0,0,0,1850,1851,3,116,58,0,1851,163,1,0,0,0,
  	1852,1862,5,138,0,0,1853,1862,5,135,0,0,1854,1862,3,166,83,0,1855,1862,
  	5,136,0,0,1856,1862,5,137,0,0,1857,1862,5,144,0,0,1858,1862,5,131,0,0,
  	1859,1862,5,139,0,0,1860,1862,5,134,0,0,1861,1852,1,0,0,0,1861,1853,1,
  	0,0,0,1861,1854,1,0,0,0,1861,1855,1,0,0,0,1861,1856,1,0,0,0,1861,1857,
  	1,0,0,0,1861,1858,1,0,0,0,1861,1859,1,0,0,0,1861,1860,1,0,0,0,1862,165,
  	1,0,0,0,1863,1866,3,168,84,0,1864,1866,3,170,85,0,1865,1863,1,0,0,0,1865,
  	1864,1,0,0,0,1866,167,1,0,0,0,1867,1872,5,129,0,0,1868,1871,3,172,86,
  	0,1869,1871,3,174,87,0,1870,1868,1,0,0,0,1870,1869,1,0,0,0,1871,1874,
  	1,0,0,0,1872,1870,1,0,0,0,1872,1873,1,0,0,0,1873,1875,1,0,0,0,1874,1872,
  	1,0,0,0,1875,1876,5,155,0,0,1876,169,1,0,0,0,1877,1884,5,130,0,0,1878,
  	1883,3,176,88,0,1879,1883,3,178,89,0,1880,1883,3,168,84,0,1881,1883,5,
  	161,0,0,1882,1878,1,0,0,0,1882,1879,1,0,0,0,1882,1880,1,0,0,0,1882,1881,
  	1,0,0,0,1883,1886,1,0,0,0,1884,1882,1,0,0,0,1884,1885,1,0,0,0,1885,1887,
  	1,0,0,0,1886,1884,1,0,0,0,1887,1888,5,160,0,0,1888,171,1,0,0,0,1889,1890,
  	7,3,0,0,1890,173,1,0,0,0,1891,1892,5,159,0,0,1892,1893,3,116,58,0,1893,
  	1894,5,14,0,0,1894,175,1,0,0,0,1895,1896,7,4,0,0,1896,177,1,0,0,0,1897,
  	1898,5,165,0,0,1898,1899,3,116,58,0,1899,1900,5,14,0,0,1900,179,1,0,0,
  	0,1901,1903,3,274,137,0,1902,1901,1,0,0,0,1903,1906,1,0,0,0,1904,1902,
  	1,0,0,0,1904,1905,1,0,0,0,1905,1953,1,0,0,0,1906,1904,1,0,0,0,1907,1911,
  	5,13,0,0,1908,1910,5,5,0,0,1909,1908,1,0,0,0,1910,1913,1,0,0,0,1911,1909,
  	1,0,0,0,1911,1912,1,0,0,0,1912,1914,1,0,0,0,1913,1911,1,0,0,0,1914,1918,
  	3,108,54,0,1915,1917,5,5,0,0,1916,1915,1,0,0,0,1917,1920,1,0,0,0,1918,
  	1916,1,0,0,0,1918,1919,1,0,0,0,1919,1921,1,0,0,0,1920,1918,1,0,0,0,1921,
  	1922,5,14,0,0,1922,1954,1,0,0,0,1923,1927,5,13,0,0,1924,1926,5,5,0,0,
  	1925,1924,1,0,0,0,1926,1929,1,0,0,0,1927,1925,1,0,0,0,1927,1928,1,0,0,
  	0,1928,1930,1,0,0,0,1929,1927,1,0,0,0,1930,1934,3,182,91,0,1931,1933,
  	5,5,0,0,1932,1931,1,0,0,0,1933,1936,1,0,0,0,1934,1932,1,0,0,0,1934,1935,
  	1,0,0,0,1935,1937,1,0,0,0,1936,1934,1,0,0,0,1937,1941,5,33,0,0,1938,1940,
  	5,5,0,0,1939,1938,1,0,0,0,1940,1943,1,0,0,0,1941,1939,1,0,0,0,1941,1942,
  	1,0,0,0,1942,1944,1,0,0,0,1943,1941,1,0,0,0,1944,1948,3,108,54,0,1945,
  	1947,5,5,0,0,1946,1945,1,0,0,0,1947,1950,1,0,0,0,1948,1946,1,0,0,0,1948,
  	1949,1,0,0,0,1949,1951,1,0,0,0,1950,1948,1,0,0,0,1951,1952,5,14,0,0,1952,
  	1954,1,0,0,0,1953,1907,1,0,0,0,1953,1923,1,0,0,0,1954,181,1,0,0,0,1955,
  	1957,3,184,92,0,1956,1955,1,0,0,0,1956,1957,1,0,0,0,1957,1974,1,0,0,0,
  	1958,1960,5,5,0,0,1959,1958,1,0,0,0,1960,1963,1,0,0,0,1961,1959,1,0,0,
  	0,1961,1962,1,0,0,0,1962,1964,1,0,0,0,1963,1961,1,0,0,0,1964,1968,5,8,
  	0,0,1965,1967,5,5,0,0,1966,1965,1,0,0,0,1967,1970,1,0,0,0,1968,1966,1,
  	0,0,0,1968,1969,1,0,0,0,1969,1971,1,0,0,0,1970,1968,1,0,0,0,1971,1973,
  	3,184,92,0,1972,1961,1,0,0,0,1973,1976,1,0,0,0,1974,1972,1,0,0,0,1974,
  	1975,1,0,0,0,1975,183,1,0,0,0,1976,1974,1,0,0,0,1977,1996,3,70,35,0,1978,
  	1993,3,68,34,0,1979,1981,5,5,0,0,1980,1979,1,0,0,0,1981,1984,1,0,0,0,
  	1982,1980,1,0,0,0,1982,1983,1,0,0,0,1983,1985,1,0,0,0,1984,1982,1,0,0,
  	0,1985,1989,5,25,0,0,1986,1988,5,5,0,0,1987,1986,1,0,0,0,1988,1991,1,
  	0,0,0,1989,1987,1,0,0,0,1989,1990,1,0,0,0,1990,1992,1,0,0,0,1991,1989,
  	1,0,0,0,1992,1994,3,82,41,0,1993,1982,1,0,0,0,1993,1994,1,0,0,0,1994,
  	1996,1,0,0,0,1995,1977,1,0,0,0,1995,1978,1,0,0,0,1996,185,1,0,0,0,1997,
  	2012,5,62,0,0,1998,2000,5,5,0,0,1999,1998,1,0,0,0,2000,2003,1,0,0,0,2001,
  	1999,1,0,0,0,2001,2002,1,0,0,0,2002,2004,1,0,0,0,2003,2001,1,0,0,0,2004,
  	2008,5,25,0,0,2005,2007,5,5,0,0,2006,2005,1,0,0,0,2007,2010,1,0,0,0,2008,
  	2006,1,0,0,0,2008,2009,1,0,0,0,2009,2011,1,0,0,0,2010,2008,1,0,0,0,2011,
  	2013,3,28,14,0,2012,2001,1,0,0,0,2012,2013,1,0,0,0,2013,2017,1,0,0,0,
  	2014,2016,5,5,0,0,2015,2014,1,0,0,0,2016,2019,1,0,0,0,2017,2015,1,0,0,
  	0,2017,2018,1,0,0,0,2018,2020,1,0,0,0,2019,2017,1,0,0,0,2020,2021,3,36,
  	18,0,2021,187,1,0,0,0,2022,2024,5,11,0,0,2023,2025,3,116,58,0,2024,2023,
  	1,0,0,0,2024,2025,1,0,0,0,2025,2030,1,0,0,0,2026,2027,5,8,0,0,2027,2029,
  	3,116,58,0,2028,2026,1,0,0,0,2029,2032,1,0,0,0,2030,2028,1,0,0,0,2030,
  	2031,1,0,0,0,2031,2033,1,0,0,0,2032,2030,1,0,0,0,2033,2034,5,12,0,0,2034,
  	189,1,0,0,0,2035,2037,5,70,0,0,2036,2038,5,141,0,0,2037,2036,1,0,0,0,
  	2037,2038,1,0,0,0,2038,191,1,0,0,0,2039,2056,5,71,0,0,2040,2044,5,43,
  	0,0,2041,2043,5,5,0,0,2042,2041,1,0,0,0,2043,2046,1,0,0,0,2044,2042,1,
  	0,0,0,2044,2045,1,0,0,0,2045,2047,1,0,0,0,2046,2044,1,0,0,0,2047,2051,
  	3,82,41,0,2048,2050,5,5,0,0,2049,2048,1,0,0,0,2050,2053,1,0,0,0,2051,
  	2049,1,0,0,0,2051,2052,1,0,0,0,2052,2054,1,0,0,0,2053,2051,1,0,0,0,2054,
  	2055,5,44,0,0,2055,2057,1,0,0,0,2056,2040,1,0,0,0,2056,2057,1,0,0,0,2057,
  	2059,1,0,0,0,2058,2060,5,141,0,0,2059,2058,1,0,0,0,2059,2060,1,0,0,0,
  	2060,193,1,0,0,0,2061,2064,3,196,98,0,2062,2064,3,200,100,0,2063,2061,
  	1,0,0,0,2063,2062,1,0,0,0,2064,195,1,0,0,0,2065,2069,5,74,0,0,2066,2068,
  	5,5,0,0,2067,2066,1,0,0,0,2068,2071,1,0,0,0,2069,2067,1,0,0,0,2069,2070,
  	1,0,0,0,2070,2072,1,0,0,0,2071,2069,1,0,0,0,2072,2073,5,9,0,0,2073,2074,
  	3,116,58,0,2074,2078,5,10,0,0,2075,2077,5,5,0,0,2076,2075,1,0,0,0,2077,
  	2080,1,0,0,0,2078,2076,1,0,0,0,2078,2079,1,0,0,0,2079,2082,1,0,0,0,2080,
  	2078,1,0,0,0,2081,2083,3,198,99,0,2082,2081,1,0,0,0,2082,2083,1,0,0,0,
  	2083,2085,1,0,0,0,2084,2086,5,26,0,0,2085,2084,1,0,0,0,2085,2086,1,0,
  	0,0,2086,2103,1,0,0,0,2087,2089,5,5,0,0,2088,2087,1,0,0,0,2089,2092,1,
  	0,0,0,2090,2088,1,0,0,0,2090,2091,1,0,0,0,2091,2093,1,0,0,0,2092,2090,
  	1,0,0,0,2093,2097,5,75,0,0,2094,2096,5,5,0,0,2095,2094,1,0,0,0,2096,2099,
  	1,0,0,0,2097,2095,1,0,0,0,2097,2098,1,0,0,0,2098,2101,1,0,0,0,2099,2097,
  	1,0,0,0,2100,2102,3,198,99,0,2101,2100,1,0,0,0,2101,2102,1,0,0,0,2102,
  	2104,1,0,0,0,2103,2090,1,0,0,0,2103,2104,1,0,0,0,2104,197,1,0,0,0,2105,
  	2108,3,106,53,0,2106,2108,3,116,58,0,2107,2105,1,0,0,0,2107,2106,1,0,
  	0,0,2108,199,1,0,0,0,2109,2113,5,76,0,0,2110,2112,5,5,0,0,2111,2110,1,
  	0,0,0,2112,2115,1,0,0,0,2113,2111,1,0,0,0,2113,2114,1,0,0,0,2114,2120,
  	1,0,0,0,2115,2113,1,0,0,0,2116,2117,5,9,0,0,2117,2118,3,116,58,0,2118,
  	2119,5,10,0,0,2119,2121,1,0,0,0,2120,2116,1,0,0,0,2120,2121,1,0,0,0,2121,
  	2125,1,0,0,0,2122,2124,5,5,0,0,2123,2122,1,0,0,0,2124,2127,1,0,0,0,2125,
  	2123,1,0,0,0,2125,2126,1,0,0,0,2126,2128,1,0,0,0,2127,2125,1,0,0,0,2128,
  	2132,5,13,0,0,2129,2131,5,5,0,0,2130,2129,1,0,0,0,2131,2134,1,0,0,0,2132,
  	2130,1,0,0,0,2132,2133,1,0,0,0,2133,2144,1,0,0,0,2134,2132,1,0,0,0,2135,
  	2139,3,202,101,0,2136,2138,5,5,0,0,2137,2136,1,0,0,0,2138,2141,1,0,0,
  	0,2139,2137,1,0,0,0,2139,2140,1,0,0,0,2140,2143,1,0,0,0,2141,2139,1,0,
  	0,0,2142,2135,1,0,0,0,2143,2146,1,0,0,0,2144,2142,1,0,0,0,2144,2145,1,
  	0,0,0,2145,2150,1,0,0,0,2146,2144,1,0,0,0,2147,2149,5,5,0,0,2148,2147,
  	1,0,0,0,2149,2152,1,0,0,0,2150,2148,1,0,0,0,2150,2151,1,0,0,0,2151,2153,
  	1,0,0,0,2152,2150,1,0,0,0,2153,2154,5,14,0,0,2154,201,1,0,0,0,2155,2172,
  	3,204,102,0,2156,2158,5,5,0,0,2157,2156,1,0,0,0,2158,2161,1,0,0,0,2159,
  	2157,1,0,0,0,2159,2160,1,0,0,0,2160,2162,1,0,0,0,2161,2159,1,0,0,0,2162,
  	2166,5,8,0,0,2163,2165,5,5,0,0,2164,2163,1,0,0,0,2165,2168,1,0,0,0,2166,
  	2164,1,0,0,0,2166,2167,1,0,0,0,2167,2169,1,0,0,0,2168,2166,1,0,0,0,2169,
  	2171,3,204,102,0,2170,2159,1,0,0,0,2171,2174,1,0,0,0,2172,2170,1,0,0,
  	0,2172,2173,1,0,0,0,2173,2178,1,0,0,0,2174,2172,1,0,0,0,2175,2177,5,5,
  	0,0,2176,2175,1,0,0,0,2177,2180,1,0,0,0,2178,2176,1,0,0,0,2178,2179,1,
  	0,0,0,2179,2181,1,0,0,0,2180,2178,1,0,0,0,2181,2185,5,33,0,0,2182,2184,
  	5,5,0,0,2183,2182,1,0,0,0,2184,2187,1,0,0,0,2185,2183,1,0,0,0,2185,2186,
  	1,0,0,0,2186,2188,1,0,0,0,2187,2185,1,0,0,0,2188,2190,3,198,99,0,2189,
  	2191,3,288,144,0,2190,2189,1,0,0,0,2190,2191,1,0,0,0,2191,2208,1,0,0,
  	0,2192,2196,5,75,0,0,2193,2195,5,5,0,0,2194,2193,1,0,0,0,2195,2198,1,
  	0,0,0,2196,2194,1,0,0,0,2196,2197,1,0,0,0,2197,2199,1,0,0,0,2198,2196,
  	1,0,0,0,2199,2203,5,33,0,0,2200,2202,5,5,0,0,2201,2200,1,0,0,0,2202,2205,
  	1,0,0,0,2203,2201,1,0,0,0,2203,2204,1,0,0,0,2204,2206,1,0,0,0,2205,2203,
  	1,0,0,0,2206,2208,3,198,99,0,2207,2155,1,0,0,0,2207,2192,1,0,0,0,2208,
  	203,1,0,0,0,2209,2213,3,116,58,0,2210,2213,3,206,103,0,2211,2213,3,208,
  	104,0,2212,2209,1,0,0,0,2212,2210,1,0,0,0,2212,2211,1,0,0,0,2213,205,
  	1,0,0,0,2214,2218,3,234,117,0,2215,2217,5,5,0,0,2216,2215,1,0,0,0,2217,
  	2220,1,0,0,0,2218,2216,1,0,0,0,2218,2219,1,0,0,0,2219,2221,1,0,0,0,2220,
  	2218,1,0,0,0,2221,2222,3,116,58,0,2222,207,1,0,0,0,2223,2227,3,236,118,
  	0,2224,2226,5,5,0,0,2225,2224,1,0,0,0,2226,2229,1,0,0,0,2227,2225,1,0,
  	0,0,2227,2228,1,0,0,0,2228,2230,1,0,0,0,2229,2227,1,0,0,0,2230,2231,3,
  	82,41,0,2231,209,1,0,0,0,2232,2236,5,77,0,0,2233,2235,5,5,0,0,2234,2233,
  	1,0,0,0,2235,2238,1,0,0,0,2236,2234,1,0,0,0,2236,2237,1,0,0,0,2237,2239,
  	1,0,0,0,2238,2236,1,0,0,0,2239,2249,3,106,53,0,2240,2242,5,5,0,0,2241,
  	2240,1,0,0,0,2242,2245,1,0,0,0,2243,2241,1,0,0,0,2243,2244,1,0,0,0,2244,
  	2246,1,0,0,0,2245,2243,1,0,0,0,2246,2248,3,212,106,0,2247,2243,1,0,0,
  	0,2248,2251,1,0,0,0,2249,2247,1,0,0,0,2249,2250,1,0,0,0,2250,2259,1,0,
  	0,0,2251,2249,1,0,0,0,2252,2254,5,5,0,0,2253,2252,1,0,0,0,2254,2257,1,
  	0,0,0,2255,2253,1,0,0,0,2255,2256,1,0,0,0,2256,2258,1,0,0,0,2257,2255,
  	1,0,0,0,2258,2260,3,214,107,0,2259,2255,1,0,0,0,2259,2260,1,0,0,0,2260,
  	211,1,0,0,0,2261,2265,5,78,0,0,2262,2264,5,5,0,0,2263,2262,1,0,0,0,2264,
  	2267,1,0,0,0,2265,2263,1,0,0,0,2265,2266,1,0,0,0,2266,2268,1,0,0,0,2267,
  	2265,1,0,0,0,2268,2272,5,9,0,0,2269,2271,3,274,137,0,2270,2269,1,0,0,
  	0,2271,2274,1,0,0,0,2272,2270,1,0,0,0,2272,2273,1,0,0,0,2273,2275,1,0,
  	0,0,2274,2272,1,0,0,0,2275,2276,3,286,143,0,2276,2277,5,25,0,0,2277,2278,
  	3,96,48,0,2278,2282,5,10,0,0,2279,2281,5,5,0,0,2280,2279,1,0,0,0,2281,
  	2284,1,0,0,0,2282,2280,1,0,0,0,2282,2283,1,0,0,0,2283,2285,1,0,0,0,2284,
  	2282,1,0,0,0,2285,2286,3,106,53,0,2286,213,1,0,0,0,2287,2291,5,79,0,0,
  	2288,2290,5,5,0,0,2289,2288,1,0,0,0,2290,2293,1,0,0,0,2291,2289,1,0,0,
  	0,2291,2292,1,0,0,0,2292,2294,1,0,0,0,2293,2291,1,0,0,0,2294,2295,3,106,
  	53,0,2295,215,1,0,0,0,2296,2300,3,218,109,0,2297,2300,3,220,110,0,2298,
  	2300,3,222,111,0,2299,2296,1,0,0,0,2299,2297,1,0,0,0,2299,2298,1,0,0,
  	0,2300,217,1,0,0,0,2301,2305,5,80,0,0,2302,2304,5,5,0,0,2303,2302,1,0,
  	0,0,2304,2307,1,0,0,0,2305,2303,1,0,0,0,2305,2306,1,0,0,0,2306,2308,1,
  	0,0,0,2307,2305,1,0,0,0,2308,2312,5,9,0,0,2309,2311,3,274,137,0,2310,
  	2309,1,0,0,0,2311,2314,1,0,0,0,2312,2310,1,0,0,0,2312,2313,1,0,0,0,2313,
  	2317,1,0,0,0,2314,2312,1,0,0,0,2315,2318,3,70,35,0,2316,2318,3,68,34,
  	0,2317,2315,1,0,0,0,2317,2316,1,0,0,0,2318,2319,1,0,0,0,2319,2320,5,89,
  	0,0,2320,2321,3,116,58,0,2321,2325,5,10,0,0,2322,2324,5,5,0,0,2323,2322,
  	1,0,0,0,2324,2327,1,0,0,0,2325,2323,1,0,0,0,2325,2326,1,0,0,0,2326,2329,
  	1,0,0,0,2327,2325,1,0,0,0,2328,2330,3,198,99,0,2329,2328,1,0,0,0,2329,
  	2330,1,0,0,0,2330,219,1,0,0,0,2331,2335,5,82,0,0,2332,2334,5,5,0,0,2333,
  	2332,1,0,0,0,2334,2337,1,0,0,0,2335,2333,1,0,0,0,2335,2336,1,0,0,0,2336,
  	2338,1,0,0,0,2337,2335,1,0,0,0,2338,2339,5,9,0,0,2339,2340,3,116,58,0,
  	2340,2344,5,10,0,0,2341,2343,5,5,0,0,2342,2341,1,0,0,0,2343,2346,1,0,
  	0,0,2344,2342,1,0,0,0,2344,2345,1,0,0,0,2345,2348,1,0,0,0,2346,2344,1,
  	0,0,0,2347,2349,3,198,99,0,2348,2347,1,0,0,0,2348,2349,1,0,0,0,2349,221,
  	1,0,0,0,2350,2354,5,81,0,0,2351,2353,5,5,0,0,2352,2351,1,0,0,0,2353,2356,
  	1,0,0,0,2354,2352,1,0,0,0,2354,2355,1,0,0,0,2355,2358,1,0,0,0,2356,2354,
  	1,0,0,0,2357,2359,3,198,99,0,2358,2357,1,0,0,0,2358,2359,1,0,0,0,2359,
  	2363,1,0,0,0,2360,2362,5,5,0,0,2361,2360,1,0,0,0,2362,2365,1,0,0,0,2363,
  	2361,1,0,0,0,2363,2364,1,0,0,0,2364,2366,1,0,0,0,2365,2363,1,0,0,0,2366,
  	2370,5,82,0,0,2367,2369,5,5,0,0,2368,2367,1,0,0,0,2369,2372,1,0,0,0,2370,
  	2368,1,0,0,0,2370,2371,1,0,0,0,2371,2373,1,0,0,0,2372,2370,1,0,0,0,2373,
  	2374,5,9,0,0,2374,2375,3,116,58,0,2375,2376,5,10,0,0,2376,223,1,0,0,0,
  	2377,2381,5,83,0,0,2378,2380,5,5,0,0,2379,2378,1,0,0,0,2380,2383,1,0,
  	0,0,2381,2379,1,0,0,0,2381,2382,1,0,0,0,2382,2384,1,0,0,0,2383,2381,1,
  	0,0,0,2384,2394,3,116,58,0,2385,2387,7,5,0,0,2386,2388,3,116,58,0,2387,
  	2386,1,0,0,0,2387,2388,1,0,0,0,2388,2394,1,0,0,0,2389,2394,5,85,0,0,2390,
  	2394,5,54,0,0,2391,2394,5,86,0,0,2392,2394,5,55,0,0,2393,2377,1,0,0,0,
  	2393,2385,1,0,0,0,2393,2389,1,0,0,0,2393,2390,1,0,0,0,2393,2391,1,0,0,
  	0,2393,2392,1,0,0,0,2394,225,1,0,0,0,2395,2405,3,96,48,0,2396,2400,5,
  	41,0,0,2397,2399,5,5,0,0,2398,2397,1,0,0,0,2399,2402,1,0,0,0,2400,2398,
  	1,0,0,0,2400,2401,1,0,0,0,2401,2404,1,0,0,0,2402,2400,1,0,0,0,2403,2396,
  	1,0,0,0,2404,2407,1,0,0,0,2405,2403,1,0,0,0,2405,2406,1,0,0,0,2406,2409,
  	1,0,0,0,2407,2405,1,0,0,0,2408,2395,1,0,0,0,2408,2409,1,0,0,0,2409,2413,
  	1,0,0,0,2410,2412,5,5,0,0,2411,2410,1,0,0,0,2412,2415,1,0,0,0,2413,2411,
  	1,0,0,0,2413,2414,1,0,0,0,2414,2416,1,0,0,0,2415,2413,1,0,0,0,2416,2420,
  	7,6,0,0,2417,2419,5,5,0,0,2418,2417,1,0,0,0,2419,2422,1,0,0,0,2420,2418,
  	1,0,0,0,2420,2421,1,0,0,0,2421,2425,1,0,0,0,2422,2420,1,0,0,0,2423,2426,
  	3,284,142,0,2424,2426,5,59,0,0,2425,2423,1,0,0,0,2425,2424,1,0,0,0,2426,
  	227,1,0,0,0,2427,2428,7,7,0,0,2428,229,1,0,0,0,2429,2430,7,8,0,0,2430,
  	231,1,0,0,0,2431,2432,7,9,0,0,2432,233,1,0,0,0,2433,2434,7,10,0,0,2434,
  	235,1,0,0,0,2435,2436,7,11,0,0,2436,237,1,0,0,0,2437,2438,7,12,0,0,2438,
  	239,1,0,0,0,2439,2440,7,13,0,0,2440,241,1,0,0,0,2441,2442,7,14,0,0,2442,
  	243,1,0,0,0,2443,2451,5,20,0,0,2444,2451,5,21,0,0,2445,2451,5,18,0,0,
  	2446,2451,5,19,0,0,2447,2451,5,24,0,0,2448,2451,3,274,137,0,2449,2451,
  	3,272,136,0,2450,2443,1,0,0,0,2450,2444,1,0,0,0,2450,2445,1,0,0,0,2450,
  	2446,1,0,0,0,2450,2447,1,0,0,0,2450,2448,1,0,0,0,2450,2449,1,0,0,0,2451,
  	245,1,0,0,0,2452,2468,5,20,0,0,2453,2468,5,21,0,0,2454,2455,5,24,0,0,
  	2455,2468,5,24,0,0,2456,2468,3,148,74,0,2457,2468,3,152,76,0,2458,2460,
  	5,5,0,0,2459,2458,1,0,0,0,2460,2463,1,0,0,0,2461,2459,1,0,0,0,2461,2462,
  	1,0,0,0,2462,2464,1,0,0,0,2463,2461,1,0,0,0,2464,2465,3,248,124,0,2465,
  	2466,3,142,71,0,2466,2468,1,0,0,0,2467,2452,1,0,0,0,2467,2453,1,0,0,0,
  	2467,2454,1,0,0,0,2467,2456,1,0,0,0,2467,2457,1,0,0,0,2467,2461,1,0,0,
  	0,2468,247,1,0,0,0,2469,2473,5,7,0,0,2470,2471,5,41,0,0,2471,2473,5,7,
  	0,0,2472,2469,1,0,0,0,2472,2470,1,0,0,0,2473,249,1,0,0,0,2474,2477,3,
  	274,137,0,2475,2477,3,252,126,0,2476,2474,1,0,0,0,2476,2475,1,0,0,0,2477,
  	2478,1,0,0,0,2478,2476,1,0,0,0,2478,2479,1,0,0,0,2479,251,1,0,0,0,2480,
  	2490,3,254,127,0,2481,2490,3,256,128,0,2482,2490,3,258,129,0,2483,2490,
  	3,260,130,0,2484,2490,3,262,131,0,2485,2490,3,264,132,0,2486,2490,3,266,
  	133,0,2487,2490,3,268,134,0,2488,2490,3,270,135,0,2489,2480,1,0,0,0,2489,
  	2481,1,0,0,0,2489,2482,1,0,0,0,2489,2483,1,0,0,0,2489,2484,1,0,0,0,2489,
  	2485,1,0,0,0,2489,2486,1,0,0,0,2489,2487,1,0,0,0,2489,2488,1,0,0,0,2490,
  	2494,1,0,0,0,2491,2493,5,5,0,0,2492,2491,1,0,0,0,2493,2496,1,0,0,0,2494,
  	2492,1,0,0,0,2494,2495,1,0,0,0,2495,253,1,0,0,0,2496,2494,1,0,0,0,2497,
  	2498,7,15,0,0,2498,255,1,0,0,0,2499,2500,7,16,0,0,2500,257,1,0,0,0,2501,
  	2502,7,17,0,0,2502,259,1,0,0,0,2503,2504,7,18,0,0,2504,261,1,0,0,0,2505,
  	2506,7,19,0,0,2506,263,1,0,0,0,2507,2508,5,123,0,0,2508,265,1,0,0,0,2509,
  	2510,7,20,0,0,2510,267,1,0,0,0,2511,2512,7,21,0,0,2512,269,1,0,0,0,2513,
  	2514,5,128,0,0,2514,271,1,0,0,0,2515,2519,5,142,0,0,2516,2518,5,5,0,0,
  	2517,2516,1,0,0,0,2518,2521,1,0,0,0,2519,2517,1,0,0,0,2519,2520,1,0,0,
  	0,2520,273,1,0,0,0,2521,2519,1,0,0,0,2522,2525,3,276,138,0,2523,2525,
  	3,278,139,0,2524,2522,1,0,0,0,2524,2523,1,0,0,0,2525,2529,1,0,0,0,2526,
  	2528,5,5,0,0,2527,2526,1,0,0,0,2528,2531,1,0,0,0,2529,2527,1,0,0,0,2529,
  	2530,1,0,0,0,2530,275,1,0,0,0,2531,2529,1,0,0,0,2532,2536,3,280,140,0,
  	2533,2535,5,5,0,0,2534,2533,1,0,0,0,2535,2538,1,0,0,0,2536,2534,1,0,0,
  	0,2536,2537,1,0,0,0,2537,2539,1,0,0,0,2538,2536,1,0,0,0,2539,2543,5,25,
  	0,0,2540,2542,5,5,0,0,2541,2540,1,0,0,0,2542,2545,1,0,0,0,2543,2541,1,
  	0,0,0,2543,2544,1,0,0,0,2544,2546,1,0,0,0,2545,2543,1,0,0,0,2546,2547,
  	3,282,141,0,2547,2568,1,0,0,0,2548,2556,5,141,0,0,2549,2551,5,5,0,0,2550,
  	2549,1,0,0,0,2551,2554,1,0,0,0,2552,2550,1,0,0,0,2552,2553,1,0,0,0,2553,
  	2555,1,0,0,0,2554,2552,1,0,0,0,2555,2557,3,156,78,0,2556,2552,1,0,0,0,
  	2556,2557,1,0,0,0,2557,2565,1,0,0,0,2558,2560,5,5,0,0,2559,2558,1,0,0,
  	0,2560,2563,1,0,0,0,2561,2559,1,0,0,0,2561,2562,1,0,0,0,2562,2564,1,0,
  	0,0,2563,2561,1,0,0,0,2564,2566,3,154,77,0,2565,2561,1,0,0,0,2565,2566,
  	1,0,0,0,2566,2568,1,0,0,0,2567,2532,1,0,0,0,2567,2548,1,0,0,0,2568,277,
  	1,0,0,0,2569,2570,3,280,140,0,2570,2571,5,25,0,0,2571,2573,5,11,0,0,2572,
  	2574,3,282,141,0,2573,2572,1,0,0,0,2574,2575,1,0,0,0,2575,2573,1,0,0,
  	0,2575,2576,1,0,0,0,2576,2577,1,0,0,0,2577,2578,5,12,0,0,2578,2589,1,
  	0,0,0,2579,2580,5,40,0,0,2580,2582,5,11,0,0,2581,2583,3,282,141,0,2582,
  	2581,1,0,0,0,2583,2584,1,0,0,0,2584,2582,1,0,0,0,2584,2585,1,0,0,0,2585,
  	2586,1,0,0,0,2586,2587,5,12,0,0,2587,2589,1,0,0,0,2588,2569,1,0,0,0,2588,
  	2579,1,0,0,0,2589,279,1,0,0,0,2590,2591,7,22,0,0,2591,281,1,0,0,0,2592,
  	2594,3,284,142,0,2593,2595,3,156,78,0,2594,2593,1,0,0,0,2594,2595,1,0,
  	0,0,2595,2597,1,0,0,0,2596,2598,3,154,77,0,2597,2596,1,0,0,0,2597,2598,
  	1,0,0,0,2598,283,1,0,0,0,2599,2610,3,286,143,0,2600,2602,5,5,0,0,2601,
  	2600,1,0,0,0,2602,2605,1,0,0,0,2603,2601,1,0,0,0,2603,2604,1,0,0,0,2604,
  	2606,1,0,0,0,2605,2603,1,0,0,0,2606,2607,5,7,0,0,2607,2609,3,286,143,
  	0,2608,2603,1,0,0,0,2609,2612,1,0,0,0,2610,2608,1,0,0,0,2610,2611,1,0,
  	0,0,2611,285,1,0,0,0,2612,2610,1,0,0,0,2613,2614,7,23,0,0,2614,287,1,
  	0,0,0,2615,2617,5,5,0,0,2616,2615,1,0,0,0,2617,2618,1,0,0,0,2618,2616,
  	1,0,0,0,2618,2619,1,0,0,0,2619,2634,1,0,0,0,2620,2622,5,5,0,0,2621,2620,
  	1,0,0,0,2622,2625,1,0,0,0,2623,2621,1,0,0,0,2623,2624,1,0,0,0,2624,2626,
  	1,0,0,0,2625,2623,1,0,0,0,2626,2630,5,26,0,0,2627,2629,5,5,0,0,2628,2627,
  	1,0,0,0,2629,2632,1,0,0,0,2630,2628,1,0,0,0,2630,2631,1,0,0,0,2631,2634,
  	1,0,0,0,2632,2630,1,0,0,0,2633,2616,1,0,0,0,2633,2623,1,0,0,0,2634,289,
  	1,0,0,0,2635,2636,7,24,0,0,2636,291,1,0,0,0,397,295,302,309,312,316,319,
  	326,333,340,343,347,350,355,363,371,376,379,383,386,391,393,398,406,409,
  	419,422,428,435,439,444,448,453,460,464,469,473,478,485,489,492,498,501,
  	511,514,519,522,529,534,541,548,554,560,569,576,585,591,597,610,615,621,
  	627,633,640,647,651,656,660,666,674,678,684,688,693,700,706,709,714,723,
  	728,731,737,741,746,750,755,759,762,768,775,780,785,789,794,798,803,810,
  	817,821,826,830,835,839,847,850,855,860,871,875,878,884,891,895,900,907,
  	911,916,920,923,929,933,939,943,948,955,959,964,968,971,977,981,986,993,
  	998,1003,1008,1013,1017,1022,1029,1033,1039,1045,1047,1055,1063,1066,
  	1070,1076,1084,1091,1095,1100,1108,1112,1114,1117,1121,1127,1133,1135,
  	1140,1146,1151,1154,1160,1167,1171,1176,1183,1192,1199,1206,1212,1218,
  	1224,1229,1236,1243,1247,1250,1256,1263,1266,1268,1276,1281,1287,1295,
  	1301,1308,1311,1317,1324,1332,1338,1345,1351,1358,1362,1367,1372,1376,
  	1385,1392,1399,1405,1411,1418,1425,1437,1444,1447,1451,1454,1458,1463,
  	1469,1477,1484,1492,1499,1506,1512,1519,1526,1532,1540,1547,1555,1560,
  	1567,1574,1580,1585,1591,1598,1604,1612,1619,1627,1633,1641,1648,1656,
  	1663,1670,1678,1684,1691,1696,1711,1719,1724,1731,1737,1739,1744,1748,
  	1753,1764,1767,1777,1780,1788,1795,1802,1808,1814,1818,1823,1829,1836,
  	1839,1842,1847,1861,1865,1870,1872,1882,1884,1904,1911,1918,1927,1934,
  	1941,1948,1953,1956,1961,1968,1974,1982,1989,1993,1995,2001,2008,2012,
  	2017,2024,2030,2037,2044,2051,2056,2059,2063,2069,2078,2082,2085,2090,
  	2097,2101,2103,2107,2113,2120,2125,2132,2139,2144,2150,2159,2166,2172,
  	2178,2185,2190,2196,2203,2207,2212,2218,2227,2236,2243,2249,2255,2259,
  	2265,2272,2282,2291,2299,2305,2312,2317,2325,2329,2335,2344,2348,2354,
  	2358,2363,2370,2381,2387,2393,2400,2405,2408,2413,2420,2425,2450,2461,
  	2467,2472,2476,2478,2489,2494,2519,2524,2529,2536,2543,2552,2556,2561,
  	2565,2567,2575,2584,2588,2594,2597,2603,2610,2618,2623,2630,2633
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  myparserParserStaticData = staticData.release();
}

}

myParser::myParser(TokenStream *input) : myParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

myParser::myParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  myParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *myparserParserStaticData->atn, myparserParserStaticData->decisionToDFA, myparserParserStaticData->sharedContextCache, options);
}

myParser::~myParser() {
  delete _interpreter;
}

const atn::ATN& myParser::getATN() const {
  return *myparserParserStaticData->atn;
}

std::string myParser::getGrammarFileName() const {
  return "myParser.g4";
}

const std::vector<std::string>& myParser::getRuleNames() const {
  return myparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& myParser::getVocabulary() const {
  return myparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView myParser::getSerializedATN() const {
  return myparserParserStaticData->serializedATN;
}


//----------------- KotlinFileContext ------------------------------------------------------------------

myParser::KotlinFileContext::KotlinFileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::PreambleContext* myParser::KotlinFileContext::preamble() {
  return getRuleContext<myParser::PreambleContext>(0);
}

tree::TerminalNode* myParser::KotlinFileContext::EOF() {
  return getToken(myParser::EOF, 0);
}

std::vector<tree::TerminalNode *> myParser::KotlinFileContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::KotlinFileContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

std::vector<myParser::AnysemiContext *> myParser::KotlinFileContext::anysemi() {
  return getRuleContexts<myParser::AnysemiContext>();
}

myParser::AnysemiContext* myParser::KotlinFileContext::anysemi(size_t i) {
  return getRuleContext<myParser::AnysemiContext>(i);
}

std::vector<myParser::TopLevelObjectContext *> myParser::KotlinFileContext::topLevelObject() {
  return getRuleContexts<myParser::TopLevelObjectContext>();
}

myParser::TopLevelObjectContext* myParser::KotlinFileContext::topLevelObject(size_t i) {
  return getRuleContext<myParser::TopLevelObjectContext>(i);
}


size_t myParser::KotlinFileContext::getRuleIndex() const {
  return myParser::RuleKotlinFile;
}

void myParser::KotlinFileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKotlinFile(this);
}

void myParser::KotlinFileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKotlinFile(this);
}

myParser::KotlinFileContext* myParser::kotlinFile() {
  KotlinFileContext *_localctx = _tracker.createInstance<KotlinFileContext>(_ctx, getState());
  enterRule(_localctx, 0, myParser::RuleKotlinFile);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(295);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(292);
        match(myParser::NL); 
      }
      setState(297);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx);
    }
    setState(298);
    preamble();
    setState(302);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL

    || _la == myParser::SEMICOLON) {
      setState(299);
      anysemi();
      setState(304);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(319);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la - 40) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 40)) & 8787085823019909121) != 0 || (((_la - 104) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 104)) & 137472507903) != 0) {
      setState(305);
      topLevelObject();
      setState(316);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL

      || _la == myParser::SEMICOLON) {
        setState(307); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(306);
                  anysemi();
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(309); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        setState(312);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la - 40) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 40)) & 8787085823019909121) != 0 || (((_la - 104) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 104)) & 137472507903) != 0) {
          setState(311);
          topLevelObject();
        }
        setState(318);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(321);
    match(myParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScriptContext ------------------------------------------------------------------

myParser::ScriptContext::ScriptContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::PreambleContext* myParser::ScriptContext::preamble() {
  return getRuleContext<myParser::PreambleContext>(0);
}

tree::TerminalNode* myParser::ScriptContext::EOF() {
  return getToken(myParser::EOF, 0);
}

std::vector<tree::TerminalNode *> myParser::ScriptContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::ScriptContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

std::vector<myParser::AnysemiContext *> myParser::ScriptContext::anysemi() {
  return getRuleContexts<myParser::AnysemiContext>();
}

myParser::AnysemiContext* myParser::ScriptContext::anysemi(size_t i) {
  return getRuleContext<myParser::AnysemiContext>(i);
}

std::vector<myParser::ExpressionContext *> myParser::ScriptContext::expression() {
  return getRuleContexts<myParser::ExpressionContext>();
}

myParser::ExpressionContext* myParser::ScriptContext::expression(size_t i) {
  return getRuleContext<myParser::ExpressionContext>(i);
}


size_t myParser::ScriptContext::getRuleIndex() const {
  return myParser::RuleScript;
}

void myParser::ScriptContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScript(this);
}

void myParser::ScriptContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScript(this);
}

myParser::ScriptContext* myParser::script() {
  ScriptContext *_localctx = _tracker.createInstance<ScriptContext>(_ctx, getState());
  enterRule(_localctx, 2, myParser::RuleScript);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(326);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(323);
        match(myParser::NL); 
      }
      setState(328);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
    }
    setState(329);
    preamble();
    setState(333);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(330);
        anysemi(); 
      }
      setState(335);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx);
    }
    setState(350);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 5035025689090992672) != 0 || (((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & -65012289) != 0 || (((_la - 130) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 130)) & 24563) != 0) {
      setState(336);
      expression();
      setState(347);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL

      || _la == myParser::SEMICOLON) {
        setState(338); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(337);
                  anysemi();
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(340); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        setState(343);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
        case 1: {
          setState(342);
          expression();
          break;
        }

        default:
          break;
        }
        setState(349);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(352);
    match(myParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PreambleContext ------------------------------------------------------------------

myParser::PreambleContext::PreambleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::PackageHeaderContext* myParser::PreambleContext::packageHeader() {
  return getRuleContext<myParser::PackageHeaderContext>(0);
}

myParser::ImportListContext* myParser::PreambleContext::importList() {
  return getRuleContext<myParser::ImportListContext>(0);
}

myParser::FileAnnotationsContext* myParser::PreambleContext::fileAnnotations() {
  return getRuleContext<myParser::FileAnnotationsContext>(0);
}


size_t myParser::PreambleContext::getRuleIndex() const {
  return myParser::RulePreamble;
}

void myParser::PreambleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreamble(this);
}

void myParser::PreambleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreamble(this);
}

myParser::PreambleContext* myParser::preamble() {
  PreambleContext *_localctx = _tracker.createInstance<PreambleContext>(_ctx, getState());
  enterRule(_localctx, 4, myParser::RulePreamble);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(355);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
    case 1: {
      setState(354);
      fileAnnotations();
      break;
    }

    default:
      break;
    }
    setState(357);
    packageHeader();
    setState(358);
    importList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FileAnnotationsContext ------------------------------------------------------------------

myParser::FileAnnotationsContext::FileAnnotationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::FileAnnotationContext *> myParser::FileAnnotationsContext::fileAnnotation() {
  return getRuleContexts<myParser::FileAnnotationContext>();
}

myParser::FileAnnotationContext* myParser::FileAnnotationsContext::fileAnnotation(size_t i) {
  return getRuleContext<myParser::FileAnnotationContext>(i);
}


size_t myParser::FileAnnotationsContext::getRuleIndex() const {
  return myParser::RuleFileAnnotations;
}

void myParser::FileAnnotationsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFileAnnotations(this);
}

void myParser::FileAnnotationsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFileAnnotations(this);
}

myParser::FileAnnotationsContext* myParser::fileAnnotations() {
  FileAnnotationsContext *_localctx = _tracker.createInstance<FileAnnotationsContext>(_ctx, getState());
  enterRule(_localctx, 6, myParser::RuleFileAnnotations);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(361); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(360);
              fileAnnotation();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(363); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FileAnnotationContext ------------------------------------------------------------------

myParser::FileAnnotationContext::FileAnnotationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> myParser::FileAnnotationContext::FILE() {
  return getTokens(myParser::FILE);
}

tree::TerminalNode* myParser::FileAnnotationContext::FILE(size_t i) {
  return getToken(myParser::FILE, i);
}

std::vector<tree::TerminalNode *> myParser::FileAnnotationContext::COLON() {
  return getTokens(myParser::COLON);
}

tree::TerminalNode* myParser::FileAnnotationContext::COLON(size_t i) {
  return getToken(myParser::COLON, i);
}

std::vector<tree::TerminalNode *> myParser::FileAnnotationContext::LSQUARE() {
  return getTokens(myParser::LSQUARE);
}

tree::TerminalNode* myParser::FileAnnotationContext::LSQUARE(size_t i) {
  return getToken(myParser::LSQUARE, i);
}

std::vector<tree::TerminalNode *> myParser::FileAnnotationContext::RSQUARE() {
  return getTokens(myParser::RSQUARE);
}

tree::TerminalNode* myParser::FileAnnotationContext::RSQUARE(size_t i) {
  return getToken(myParser::RSQUARE, i);
}

std::vector<myParser::UnescapedAnnotationContext *> myParser::FileAnnotationContext::unescapedAnnotation() {
  return getRuleContexts<myParser::UnescapedAnnotationContext>();
}

myParser::UnescapedAnnotationContext* myParser::FileAnnotationContext::unescapedAnnotation(size_t i) {
  return getRuleContext<myParser::UnescapedAnnotationContext>(i);
}

std::vector<myParser::SemiContext *> myParser::FileAnnotationContext::semi() {
  return getRuleContexts<myParser::SemiContext>();
}

myParser::SemiContext* myParser::FileAnnotationContext::semi(size_t i) {
  return getRuleContext<myParser::SemiContext>(i);
}


size_t myParser::FileAnnotationContext::getRuleIndex() const {
  return myParser::RuleFileAnnotation;
}

void myParser::FileAnnotationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFileAnnotation(this);
}

void myParser::FileAnnotationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFileAnnotation(this);
}

myParser::FileAnnotationContext* myParser::fileAnnotation() {
  FileAnnotationContext *_localctx = _tracker.createInstance<FileAnnotationContext>(_ctx, getState());
  enterRule(_localctx, 8, myParser::RuleFileAnnotation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(381); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(365);
              match(myParser::FILE);
              setState(366);
              match(myParser::COLON);
              setState(376);
              _errHandler->sync(this);
              switch (_input->LA(1)) {
                case myParser::LSQUARE: {
                  setState(367);
                  match(myParser::LSQUARE);
                  setState(369); 
                  _errHandler->sync(this);
                  _la = _input->LA(1);
                  do {
                    setState(368);
                    unescapedAnnotation();
                    setState(371); 
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                  } while ((((_la - 58) & ~ 0x3fULL) == 0) &&
                    ((1ULL << (_la - 58)) & -33517921595647) != 0 || (((_la - 122) & ~ 0x3fULL) == 0) &&
                    ((1ULL << (_la - 122)) & 262271) != 0);
                  setState(373);
                  match(myParser::RSQUARE);
                  break;
                }

                case myParser::IMPORT:
                case myParser::CONSTRUCTOR:
                case myParser::BY:
                case myParser::COMPANION:
                case myParser::INIT:
                case myParser::WHERE:
                case myParser::CATCH:
                case myParser::FINALLY:
                case myParser::OUT:
                case myParser::GETTER:
                case myParser::SETTER:
                case myParser::DYNAMIC:
                case myParser::PUBLIC:
                case myParser::PRIVATE:
                case myParser::PROTECTED:
                case myParser::INTERNAL:
                case myParser::ENUM:
                case myParser::SEALED:
                case myParser::ANNOTATION:
                case myParser::DATA:
                case myParser::INNER:
                case myParser::TAILREC:
                case myParser::OPERATOR:
                case myParser::INLINE:
                case myParser::INFIX:
                case myParser::EXTERNAL:
                case myParser::SUSPEND:
                case myParser::OVERRIDE:
                case myParser::ABSTRACT:
                case myParser::FINAL:
                case myParser::OPEN:
                case myParser::CONST:
                case myParser::LATEINIT:
                case myParser::VARARG:
                case myParser::NOINLINE:
                case myParser::CROSSINLINE:
                case myParser::REIFIED:
                case myParser::Identifier: {
                  setState(375);
                  unescapedAnnotation();
                  break;
                }

              default:
                throw NoViableAltException(this);
              }
              setState(379);
              _errHandler->sync(this);

              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx)) {
              case 1: {
                setState(378);
                semi();
                break;
              }

              default:
                break;
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(383); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PackageHeaderContext ------------------------------------------------------------------

myParser::PackageHeaderContext::PackageHeaderContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::PackageHeaderContext::PACKAGE() {
  return getToken(myParser::PACKAGE, 0);
}

myParser::IdentifierContext* myParser::PackageHeaderContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::ModifierListContext* myParser::PackageHeaderContext::modifierList() {
  return getRuleContext<myParser::ModifierListContext>(0);
}

myParser::SemiContext* myParser::PackageHeaderContext::semi() {
  return getRuleContext<myParser::SemiContext>(0);
}


size_t myParser::PackageHeaderContext::getRuleIndex() const {
  return myParser::RulePackageHeader;
}

void myParser::PackageHeaderContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPackageHeader(this);
}

void myParser::PackageHeaderContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPackageHeader(this);
}

myParser::PackageHeaderContext* myParser::packageHeader() {
  PackageHeaderContext *_localctx = _tracker.createInstance<PackageHeaderContext>(_ctx, getState());
  enterRule(_localctx, 10, myParser::RulePackageHeader);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(393);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
    case 1: {
      setState(386);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::AT

      || _la == myParser::FILE || (((_la - 89) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 89)) & 4504699138981113) != 0) {
        setState(385);
        modifierList();
      }
      setState(388);
      match(myParser::PACKAGE);
      setState(389);
      identifier();
      setState(391);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
      case 1: {
        setState(390);
        semi();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportListContext ------------------------------------------------------------------

myParser::ImportListContext::ImportListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::ImportHeaderContext *> myParser::ImportListContext::importHeader() {
  return getRuleContexts<myParser::ImportHeaderContext>();
}

myParser::ImportHeaderContext* myParser::ImportListContext::importHeader(size_t i) {
  return getRuleContext<myParser::ImportHeaderContext>(i);
}


size_t myParser::ImportListContext::getRuleIndex() const {
  return myParser::RuleImportList;
}

void myParser::ImportListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportList(this);
}

void myParser::ImportListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportList(this);
}

myParser::ImportListContext* myParser::importList() {
  ImportListContext *_localctx = _tracker.createInstance<ImportListContext>(_ctx, getState());
  enterRule(_localctx, 12, myParser::RuleImportList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(398);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(395);
        importHeader(); 
      }
      setState(400);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportHeaderContext ------------------------------------------------------------------

myParser::ImportHeaderContext::ImportHeaderContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ImportHeaderContext::IMPORT() {
  return getToken(myParser::IMPORT, 0);
}

myParser::IdentifierContext* myParser::ImportHeaderContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

tree::TerminalNode* myParser::ImportHeaderContext::DOT() {
  return getToken(myParser::DOT, 0);
}

tree::TerminalNode* myParser::ImportHeaderContext::MULT() {
  return getToken(myParser::MULT, 0);
}

myParser::ImportAliasContext* myParser::ImportHeaderContext::importAlias() {
  return getRuleContext<myParser::ImportAliasContext>(0);
}

myParser::SemiContext* myParser::ImportHeaderContext::semi() {
  return getRuleContext<myParser::SemiContext>(0);
}


size_t myParser::ImportHeaderContext::getRuleIndex() const {
  return myParser::RuleImportHeader;
}

void myParser::ImportHeaderContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportHeader(this);
}

void myParser::ImportHeaderContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportHeader(this);
}

myParser::ImportHeaderContext* myParser::importHeader() {
  ImportHeaderContext *_localctx = _tracker.createInstance<ImportHeaderContext>(_ctx, getState());
  enterRule(_localctx, 14, myParser::RuleImportHeader);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(401);
    match(myParser::IMPORT);
    setState(402);
    identifier();
    setState(406);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::DOT: {
        setState(403);
        match(myParser::DOT);
        setState(404);
        match(myParser::MULT);
        break;
      }

      case myParser::AS: {
        setState(405);
        importAlias();
        break;
      }

      case myParser::EOF:
      case myParser::NL:
      case myParser::LPAREN:
      case myParser::LSQUARE:
      case myParser::LCURL:
      case myParser::ADD:
      case myParser::SUB:
      case myParser::INCR:
      case myParser::DECR:
      case myParser::EXCL:
      case myParser::SEMICOLON:
      case myParser::COLONCOLON:
      case myParser::Q_COLONCOLON:
      case myParser::AT:
      case myParser::RETURN_AT:
      case myParser::CONTINUE_AT:
      case myParser::BREAK_AT:
      case myParser::FILE:
      case myParser::IMPORT:
      case myParser::CLASS:
      case myParser::INTERFACE:
      case myParser::FUN:
      case myParser::OBJECT:
      case myParser::VAL:
      case myParser::VAR:
      case myParser::TYPE_ALIAS:
      case myParser::CONSTRUCTOR:
      case myParser::BY:
      case myParser::COMPANION:
      case myParser::INIT:
      case myParser::THIS:
      case myParser::SUPER:
      case myParser::WHERE:
      case myParser::IF:
      case myParser::WHEN:
      case myParser::TRY:
      case myParser::CATCH:
      case myParser::FINALLY:
      case myParser::FOR:
      case myParser::DO:
      case myParser::WHILE:
      case myParser::THROW:
      case myParser::RETURN:
      case myParser::CONTINUE:
      case myParser::BREAK:
      case myParser::IN:
      case myParser::OUT:
      case myParser::FIELD:
      case myParser::PROPERTY:
      case myParser::GET:
      case myParser::SET:
      case myParser::GETTER:
      case myParser::SETTER:
      case myParser::RECEIVER:
      case myParser::PARAM:
      case myParser::SETPARAM:
      case myParser::DELEGATE:
      case myParser::DYNAMIC:
      case myParser::PUBLIC:
      case myParser::PRIVATE:
      case myParser::PROTECTED:
      case myParser::INTERNAL:
      case myParser::ENUM:
      case myParser::SEALED:
      case myParser::ANNOTATION:
      case myParser::DATA:
      case myParser::INNER:
      case myParser::TAILREC:
      case myParser::OPERATOR:
      case myParser::INLINE:
      case myParser::INFIX:
      case myParser::EXTERNAL:
      case myParser::SUSPEND:
      case myParser::OVERRIDE:
      case myParser::ABSTRACT:
      case myParser::FINAL:
      case myParser::OPEN:
      case myParser::CONST:
      case myParser::LATEINIT:
      case myParser::VARARG:
      case myParser::NOINLINE:
      case myParser::CROSSINLINE:
      case myParser::REIFIED:
      case myParser::QUOTE_OPEN:
      case myParser::TRIPLE_QUOTE_OPEN:
      case myParser::RealLiteral:
      case myParser::LongLiteral:
      case myParser::IntegerLiteral:
      case myParser::HexLiteral:
      case myParser::BinLiteral:
      case myParser::BooleanLiteral:
      case myParser::NullLiteral:
      case myParser::Identifier:
      case myParser::LabelReference:
      case myParser::LabelDefinition:
      case myParser::CharacterLiteral: {
        break;
      }

    default:
      break;
    }
    setState(409);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx)) {
    case 1: {
      setState(408);
      semi();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportAliasContext ------------------------------------------------------------------

myParser::ImportAliasContext::ImportAliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ImportAliasContext::AS() {
  return getToken(myParser::AS, 0);
}

myParser::SimpleIdentifierContext* myParser::ImportAliasContext::simpleIdentifier() {
  return getRuleContext<myParser::SimpleIdentifierContext>(0);
}


size_t myParser::ImportAliasContext::getRuleIndex() const {
  return myParser::RuleImportAlias;
}

void myParser::ImportAliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportAlias(this);
}

void myParser::ImportAliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportAlias(this);
}

myParser::ImportAliasContext* myParser::importAlias() {
  ImportAliasContext *_localctx = _tracker.createInstance<ImportAliasContext>(_ctx, getState());
  enterRule(_localctx, 16, myParser::RuleImportAlias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(411);
    match(myParser::AS);
    setState(412);
    simpleIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TopLevelObjectContext ------------------------------------------------------------------

myParser::TopLevelObjectContext::TopLevelObjectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ClassDeclarationContext* myParser::TopLevelObjectContext::classDeclaration() {
  return getRuleContext<myParser::ClassDeclarationContext>(0);
}

myParser::ObjectDeclarationContext* myParser::TopLevelObjectContext::objectDeclaration() {
  return getRuleContext<myParser::ObjectDeclarationContext>(0);
}

myParser::FunctionDeclarationContext* myParser::TopLevelObjectContext::functionDeclaration() {
  return getRuleContext<myParser::FunctionDeclarationContext>(0);
}

myParser::PropertyDeclarationContext* myParser::TopLevelObjectContext::propertyDeclaration() {
  return getRuleContext<myParser::PropertyDeclarationContext>(0);
}

myParser::TypeAliasContext* myParser::TopLevelObjectContext::typeAlias() {
  return getRuleContext<myParser::TypeAliasContext>(0);
}


size_t myParser::TopLevelObjectContext::getRuleIndex() const {
  return myParser::RuleTopLevelObject;
}

void myParser::TopLevelObjectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTopLevelObject(this);
}

void myParser::TopLevelObjectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTopLevelObject(this);
}

myParser::TopLevelObjectContext* myParser::topLevelObject() {
  TopLevelObjectContext *_localctx = _tracker.createInstance<TopLevelObjectContext>(_ctx, getState());
  enterRule(_localctx, 18, myParser::RuleTopLevelObject);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(419);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(414);
      classDeclaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(415);
      objectDeclaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(416);
      functionDeclaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(417);
      propertyDeclaration();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(418);
      typeAlias();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassDeclarationContext ------------------------------------------------------------------

myParser::ClassDeclarationContext::ClassDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SimpleIdentifierContext* myParser::ClassDeclarationContext::simpleIdentifier() {
  return getRuleContext<myParser::SimpleIdentifierContext>(0);
}

tree::TerminalNode* myParser::ClassDeclarationContext::CLASS() {
  return getToken(myParser::CLASS, 0);
}

tree::TerminalNode* myParser::ClassDeclarationContext::INTERFACE() {
  return getToken(myParser::INTERFACE, 0);
}

myParser::ModifierListContext* myParser::ClassDeclarationContext::modifierList() {
  return getRuleContext<myParser::ModifierListContext>(0);
}

std::vector<tree::TerminalNode *> myParser::ClassDeclarationContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::ClassDeclarationContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

myParser::TypeParametersContext* myParser::ClassDeclarationContext::typeParameters() {
  return getRuleContext<myParser::TypeParametersContext>(0);
}

myParser::PrimaryConstructorContext* myParser::ClassDeclarationContext::primaryConstructor() {
  return getRuleContext<myParser::PrimaryConstructorContext>(0);
}

tree::TerminalNode* myParser::ClassDeclarationContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::DelegationSpecifiersContext* myParser::ClassDeclarationContext::delegationSpecifiers() {
  return getRuleContext<myParser::DelegationSpecifiersContext>(0);
}

myParser::TypeConstraintsContext* myParser::ClassDeclarationContext::typeConstraints() {
  return getRuleContext<myParser::TypeConstraintsContext>(0);
}

myParser::ClassBodyContext* myParser::ClassDeclarationContext::classBody() {
  return getRuleContext<myParser::ClassBodyContext>(0);
}

myParser::EnumClassBodyContext* myParser::ClassDeclarationContext::enumClassBody() {
  return getRuleContext<myParser::EnumClassBodyContext>(0);
}


size_t myParser::ClassDeclarationContext::getRuleIndex() const {
  return myParser::RuleClassDeclaration;
}

void myParser::ClassDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassDeclaration(this);
}

void myParser::ClassDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassDeclaration(this);
}

myParser::ClassDeclarationContext* myParser::classDeclaration() {
  ClassDeclarationContext *_localctx = _tracker.createInstance<ClassDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 20, myParser::RuleClassDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(422);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT

    || _la == myParser::FILE || (((_la - 89) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 89)) & 4504699138981113) != 0) {
      setState(421);
      modifierList();
    }
    setState(424);
    _la = _input->LA(1);
    if (!(_la == myParser::CLASS

    || _la == myParser::INTERFACE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(428);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(425);
      match(myParser::NL);
      setState(430);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(431);
    simpleIdentifier();
    setState(439);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
    case 1: {
      setState(435);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(432);
        match(myParser::NL);
        setState(437);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(438);
      typeParameters();
      break;
    }

    default:
      break;
    }
    setState(448);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
    case 1: {
      setState(444);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(441);
        match(myParser::NL);
        setState(446);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(447);
      primaryConstructor();
      break;
    }

    default:
      break;
    }
    setState(464);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {
    case 1: {
      setState(453);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(450);
        match(myParser::NL);
        setState(455);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(456);
      match(myParser::COLON);
      setState(460);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(457);
        match(myParser::NL);
        setState(462);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(463);
      delegationSpecifiers();
      break;
    }

    default:
      break;
    }
    setState(473);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
    case 1: {
      setState(469);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(466);
        match(myParser::NL);
        setState(471);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(472);
      typeConstraints();
      break;
    }

    default:
      break;
    }
    setState(489);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx)) {
    case 1: {
      setState(478);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(475);
        match(myParser::NL);
        setState(480);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(481);
      classBody();
      break;
    }

    case 2: {
      setState(485);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(482);
        match(myParser::NL);
        setState(487);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(488);
      enumClassBody();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrimaryConstructorContext ------------------------------------------------------------------

myParser::PrimaryConstructorContext::PrimaryConstructorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ClassParametersContext* myParser::PrimaryConstructorContext::classParameters() {
  return getRuleContext<myParser::ClassParametersContext>(0);
}

myParser::ModifierListContext* myParser::PrimaryConstructorContext::modifierList() {
  return getRuleContext<myParser::ModifierListContext>(0);
}

tree::TerminalNode* myParser::PrimaryConstructorContext::CONSTRUCTOR() {
  return getToken(myParser::CONSTRUCTOR, 0);
}

std::vector<tree::TerminalNode *> myParser::PrimaryConstructorContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::PrimaryConstructorContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::PrimaryConstructorContext::getRuleIndex() const {
  return myParser::RulePrimaryConstructor;
}

void myParser::PrimaryConstructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryConstructor(this);
}

void myParser::PrimaryConstructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryConstructor(this);
}

myParser::PrimaryConstructorContext* myParser::primaryConstructor() {
  PrimaryConstructorContext *_localctx = _tracker.createInstance<PrimaryConstructorContext>(_ctx, getState());
  enterRule(_localctx, 22, myParser::RulePrimaryConstructor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(492);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT

    || _la == myParser::FILE || (((_la - 89) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 89)) & 4504699138981113) != 0) {
      setState(491);
      modifierList();
    }
    setState(501);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::CONSTRUCTOR) {
      setState(494);
      match(myParser::CONSTRUCTOR);
      setState(498);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(495);
        match(myParser::NL);
        setState(500);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(503);
    classParameters();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassParametersContext ------------------------------------------------------------------

myParser::ClassParametersContext::ClassParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ClassParametersContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::ClassParametersContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

std::vector<myParser::ClassParameterContext *> myParser::ClassParametersContext::classParameter() {
  return getRuleContexts<myParser::ClassParameterContext>();
}

myParser::ClassParameterContext* myParser::ClassParametersContext::classParameter(size_t i) {
  return getRuleContext<myParser::ClassParameterContext>(i);
}

std::vector<tree::TerminalNode *> myParser::ClassParametersContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::ClassParametersContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::ClassParametersContext::getRuleIndex() const {
  return myParser::RuleClassParameters;
}

void myParser::ClassParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassParameters(this);
}

void myParser::ClassParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassParameters(this);
}

myParser::ClassParametersContext* myParser::classParameters() {
  ClassParametersContext *_localctx = _tracker.createInstance<ClassParametersContext>(_ctx, getState());
  enterRule(_localctx, 24, myParser::RuleClassParameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(505);
    match(myParser::LPAREN);
    setState(514);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la - 40) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 40)) & -3939815418167295) != 0 || (((_la - 104) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 104)) & 206191984639) != 0) {
      setState(506);
      classParameter();
      setState(511);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::COMMA) {
        setState(507);
        match(myParser::COMMA);
        setState(508);
        classParameter();
        setState(513);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(516);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassParameterContext ------------------------------------------------------------------

myParser::ClassParameterContext::ClassParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SimpleIdentifierContext* myParser::ClassParameterContext::simpleIdentifier() {
  return getRuleContext<myParser::SimpleIdentifierContext>(0);
}

tree::TerminalNode* myParser::ClassParameterContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::TypeContext* myParser::ClassParameterContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

myParser::ModifierListContext* myParser::ClassParameterContext::modifierList() {
  return getRuleContext<myParser::ModifierListContext>(0);
}

tree::TerminalNode* myParser::ClassParameterContext::ASSIGNMENT() {
  return getToken(myParser::ASSIGNMENT, 0);
}

myParser::ExpressionContext* myParser::ClassParameterContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

tree::TerminalNode* myParser::ClassParameterContext::VAL() {
  return getToken(myParser::VAL, 0);
}

tree::TerminalNode* myParser::ClassParameterContext::VAR() {
  return getToken(myParser::VAR, 0);
}


size_t myParser::ClassParameterContext::getRuleIndex() const {
  return myParser::RuleClassParameter;
}

void myParser::ClassParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassParameter(this);
}

void myParser::ClassParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassParameter(this);
}

myParser::ClassParameterContext* myParser::classParameter() {
  ClassParameterContext *_localctx = _tracker.createInstance<ClassParameterContext>(_ctx, getState());
  enterRule(_localctx, 26, myParser::RuleClassParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(519);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
    case 1: {
      setState(518);
      modifierList();
      break;
    }

    default:
      break;
    }
    setState(522);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::VAL

    || _la == myParser::VAR) {
      setState(521);
      _la = _input->LA(1);
      if (!(_la == myParser::VAL

      || _la == myParser::VAR)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(524);
    simpleIdentifier();
    setState(525);
    match(myParser::COLON);
    setState(526);
    type();
    setState(529);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::ASSIGNMENT) {
      setState(527);
      match(myParser::ASSIGNMENT);
      setState(528);
      expression();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DelegationSpecifiersContext ------------------------------------------------------------------

myParser::DelegationSpecifiersContext::DelegationSpecifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::DelegationSpecifierContext *> myParser::DelegationSpecifiersContext::delegationSpecifier() {
  return getRuleContexts<myParser::DelegationSpecifierContext>();
}

myParser::DelegationSpecifierContext* myParser::DelegationSpecifiersContext::delegationSpecifier(size_t i) {
  return getRuleContext<myParser::DelegationSpecifierContext>(i);
}

std::vector<myParser::AnnotationsContext *> myParser::DelegationSpecifiersContext::annotations() {
  return getRuleContexts<myParser::AnnotationsContext>();
}

myParser::AnnotationsContext* myParser::DelegationSpecifiersContext::annotations(size_t i) {
  return getRuleContext<myParser::AnnotationsContext>(i);
}

std::vector<tree::TerminalNode *> myParser::DelegationSpecifiersContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::DelegationSpecifiersContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}

std::vector<tree::TerminalNode *> myParser::DelegationSpecifiersContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::DelegationSpecifiersContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::DelegationSpecifiersContext::getRuleIndex() const {
  return myParser::RuleDelegationSpecifiers;
}

void myParser::DelegationSpecifiersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelegationSpecifiers(this);
}

void myParser::DelegationSpecifiersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelegationSpecifiers(this);
}

myParser::DelegationSpecifiersContext* myParser::delegationSpecifiers() {
  DelegationSpecifiersContext *_localctx = _tracker.createInstance<DelegationSpecifiersContext>(_ctx, getState());
  enterRule(_localctx, 28, myParser::RuleDelegationSpecifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(534);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::AT

    || _la == myParser::FILE || (((_la - 93) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 93)) & 281474976711631) != 0) {
      setState(531);
      annotations();
      setState(536);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(537);
    delegationSpecifier();
    setState(554);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(541);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(538);
          match(myParser::NL);
          setState(543);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(544);
        match(myParser::COMMA);
        setState(548);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(545);
          match(myParser::NL);
          setState(550);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(551);
        delegationSpecifier(); 
      }
      setState(556);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DelegationSpecifierContext ------------------------------------------------------------------

myParser::DelegationSpecifierContext::DelegationSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ConstructorInvocationContext* myParser::DelegationSpecifierContext::constructorInvocation() {
  return getRuleContext<myParser::ConstructorInvocationContext>(0);
}

myParser::UserTypeContext* myParser::DelegationSpecifierContext::userType() {
  return getRuleContext<myParser::UserTypeContext>(0);
}

myParser::ExplicitDelegationContext* myParser::DelegationSpecifierContext::explicitDelegation() {
  return getRuleContext<myParser::ExplicitDelegationContext>(0);
}


size_t myParser::DelegationSpecifierContext::getRuleIndex() const {
  return myParser::RuleDelegationSpecifier;
}

void myParser::DelegationSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelegationSpecifier(this);
}

void myParser::DelegationSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelegationSpecifier(this);
}

myParser::DelegationSpecifierContext* myParser::delegationSpecifier() {
  DelegationSpecifierContext *_localctx = _tracker.createInstance<DelegationSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 30, myParser::RuleDelegationSpecifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(560);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(557);
      constructorInvocation();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(558);
      userType();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(559);
      explicitDelegation();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstructorInvocationContext ------------------------------------------------------------------

myParser::ConstructorInvocationContext::ConstructorInvocationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::UserTypeContext* myParser::ConstructorInvocationContext::userType() {
  return getRuleContext<myParser::UserTypeContext>(0);
}

myParser::CallSuffixContext* myParser::ConstructorInvocationContext::callSuffix() {
  return getRuleContext<myParser::CallSuffixContext>(0);
}


size_t myParser::ConstructorInvocationContext::getRuleIndex() const {
  return myParser::RuleConstructorInvocation;
}

void myParser::ConstructorInvocationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstructorInvocation(this);
}

void myParser::ConstructorInvocationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstructorInvocation(this);
}

myParser::ConstructorInvocationContext* myParser::constructorInvocation() {
  ConstructorInvocationContext *_localctx = _tracker.createInstance<ConstructorInvocationContext>(_ctx, getState());
  enterRule(_localctx, 32, myParser::RuleConstructorInvocation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(562);
    userType();
    setState(563);
    callSuffix();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplicitDelegationContext ------------------------------------------------------------------

myParser::ExplicitDelegationContext::ExplicitDelegationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::UserTypeContext* myParser::ExplicitDelegationContext::userType() {
  return getRuleContext<myParser::UserTypeContext>(0);
}

tree::TerminalNode* myParser::ExplicitDelegationContext::BY() {
  return getToken(myParser::BY, 0);
}

myParser::ExpressionContext* myParser::ExplicitDelegationContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

std::vector<tree::TerminalNode *> myParser::ExplicitDelegationContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::ExplicitDelegationContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::ExplicitDelegationContext::getRuleIndex() const {
  return myParser::RuleExplicitDelegation;
}

void myParser::ExplicitDelegationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplicitDelegation(this);
}

void myParser::ExplicitDelegationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplicitDelegation(this);
}

myParser::ExplicitDelegationContext* myParser::explicitDelegation() {
  ExplicitDelegationContext *_localctx = _tracker.createInstance<ExplicitDelegationContext>(_ctx, getState());
  enterRule(_localctx, 34, myParser::RuleExplicitDelegation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(565);
    userType();
    setState(569);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(566);
      match(myParser::NL);
      setState(571);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(572);
    match(myParser::BY);
    setState(576);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(573);
        match(myParser::NL); 
      }
      setState(578);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx);
    }
    setState(579);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassBodyContext ------------------------------------------------------------------

myParser::ClassBodyContext::ClassBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ClassBodyContext::LCURL() {
  return getToken(myParser::LCURL, 0);
}

tree::TerminalNode* myParser::ClassBodyContext::RCURL() {
  return getToken(myParser::RCURL, 0);
}

std::vector<tree::TerminalNode *> myParser::ClassBodyContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::ClassBodyContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

std::vector<myParser::ClassMemberDeclarationContext *> myParser::ClassBodyContext::classMemberDeclaration() {
  return getRuleContexts<myParser::ClassMemberDeclarationContext>();
}

myParser::ClassMemberDeclarationContext* myParser::ClassBodyContext::classMemberDeclaration(size_t i) {
  return getRuleContext<myParser::ClassMemberDeclarationContext>(i);
}


size_t myParser::ClassBodyContext::getRuleIndex() const {
  return myParser::RuleClassBody;
}

void myParser::ClassBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassBody(this);
}

void myParser::ClassBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassBody(this);
}

myParser::ClassBodyContext* myParser::classBody() {
  ClassBodyContext *_localctx = _tracker.createInstance<ClassBodyContext>(_ctx, getState());
  enterRule(_localctx, 36, myParser::RuleClassBody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(581);
    match(myParser::LCURL);
    setState(585);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(582);
        match(myParser::NL); 
      }
      setState(587);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx);
    }
    setState(591);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la - 40) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 40)) & 8787085823892324353) != 0 || (((_la - 104) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 104)) & 137472507903) != 0) {
      setState(588);
      classMemberDeclaration();
      setState(593);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(597);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(594);
      match(myParser::NL);
      setState(599);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(600);
    match(myParser::RCURL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassMemberDeclarationContext ------------------------------------------------------------------

myParser::ClassMemberDeclarationContext::ClassMemberDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ClassDeclarationContext* myParser::ClassMemberDeclarationContext::classDeclaration() {
  return getRuleContext<myParser::ClassDeclarationContext>(0);
}

myParser::FunctionDeclarationContext* myParser::ClassMemberDeclarationContext::functionDeclaration() {
  return getRuleContext<myParser::FunctionDeclarationContext>(0);
}

myParser::ObjectDeclarationContext* myParser::ClassMemberDeclarationContext::objectDeclaration() {
  return getRuleContext<myParser::ObjectDeclarationContext>(0);
}

myParser::CompanionObjectContext* myParser::ClassMemberDeclarationContext::companionObject() {
  return getRuleContext<myParser::CompanionObjectContext>(0);
}

myParser::PropertyDeclarationContext* myParser::ClassMemberDeclarationContext::propertyDeclaration() {
  return getRuleContext<myParser::PropertyDeclarationContext>(0);
}

myParser::AnonymousInitializerContext* myParser::ClassMemberDeclarationContext::anonymousInitializer() {
  return getRuleContext<myParser::AnonymousInitializerContext>(0);
}

myParser::SecondaryConstructorContext* myParser::ClassMemberDeclarationContext::secondaryConstructor() {
  return getRuleContext<myParser::SecondaryConstructorContext>(0);
}

myParser::TypeAliasContext* myParser::ClassMemberDeclarationContext::typeAlias() {
  return getRuleContext<myParser::TypeAliasContext>(0);
}

std::vector<myParser::AnysemiContext *> myParser::ClassMemberDeclarationContext::anysemi() {
  return getRuleContexts<myParser::AnysemiContext>();
}

myParser::AnysemiContext* myParser::ClassMemberDeclarationContext::anysemi(size_t i) {
  return getRuleContext<myParser::AnysemiContext>(i);
}


size_t myParser::ClassMemberDeclarationContext::getRuleIndex() const {
  return myParser::RuleClassMemberDeclaration;
}

void myParser::ClassMemberDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassMemberDeclaration(this);
}

void myParser::ClassMemberDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassMemberDeclaration(this);
}

myParser::ClassMemberDeclarationContext* myParser::classMemberDeclaration() {
  ClassMemberDeclarationContext *_localctx = _tracker.createInstance<ClassMemberDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 38, myParser::RuleClassMemberDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(610);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
    case 1: {
      setState(602);
      classDeclaration();
      break;
    }

    case 2: {
      setState(603);
      functionDeclaration();
      break;
    }

    case 3: {
      setState(604);
      objectDeclaration();
      break;
    }

    case 4: {
      setState(605);
      companionObject();
      break;
    }

    case 5: {
      setState(606);
      propertyDeclaration();
      break;
    }

    case 6: {
      setState(607);
      anonymousInitializer();
      break;
    }

    case 7: {
      setState(608);
      secondaryConstructor();
      break;
    }

    case 8: {
      setState(609);
      typeAlias();
      break;
    }

    default:
      break;
    }
    setState(613); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(612);
              anysemi();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(615); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnonymousInitializerContext ------------------------------------------------------------------

myParser::AnonymousInitializerContext::AnonymousInitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::AnonymousInitializerContext::INIT() {
  return getToken(myParser::INIT, 0);
}

myParser::BlockContext* myParser::AnonymousInitializerContext::block() {
  return getRuleContext<myParser::BlockContext>(0);
}

std::vector<tree::TerminalNode *> myParser::AnonymousInitializerContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::AnonymousInitializerContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::AnonymousInitializerContext::getRuleIndex() const {
  return myParser::RuleAnonymousInitializer;
}

void myParser::AnonymousInitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnonymousInitializer(this);
}

void myParser::AnonymousInitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnonymousInitializer(this);
}

myParser::AnonymousInitializerContext* myParser::anonymousInitializer() {
  AnonymousInitializerContext *_localctx = _tracker.createInstance<AnonymousInitializerContext>(_ctx, getState());
  enterRule(_localctx, 40, myParser::RuleAnonymousInitializer);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(617);
    match(myParser::INIT);
    setState(621);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(618);
      match(myParser::NL);
      setState(623);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(624);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SecondaryConstructorContext ------------------------------------------------------------------

myParser::SecondaryConstructorContext::SecondaryConstructorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::SecondaryConstructorContext::CONSTRUCTOR() {
  return getToken(myParser::CONSTRUCTOR, 0);
}

myParser::FunctionValueParametersContext* myParser::SecondaryConstructorContext::functionValueParameters() {
  return getRuleContext<myParser::FunctionValueParametersContext>(0);
}

myParser::ModifierListContext* myParser::SecondaryConstructorContext::modifierList() {
  return getRuleContext<myParser::ModifierListContext>(0);
}

std::vector<tree::TerminalNode *> myParser::SecondaryConstructorContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::SecondaryConstructorContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

tree::TerminalNode* myParser::SecondaryConstructorContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::ConstructorDelegationCallContext* myParser::SecondaryConstructorContext::constructorDelegationCall() {
  return getRuleContext<myParser::ConstructorDelegationCallContext>(0);
}

myParser::BlockContext* myParser::SecondaryConstructorContext::block() {
  return getRuleContext<myParser::BlockContext>(0);
}


size_t myParser::SecondaryConstructorContext::getRuleIndex() const {
  return myParser::RuleSecondaryConstructor;
}

void myParser::SecondaryConstructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSecondaryConstructor(this);
}

void myParser::SecondaryConstructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSecondaryConstructor(this);
}

myParser::SecondaryConstructorContext* myParser::secondaryConstructor() {
  SecondaryConstructorContext *_localctx = _tracker.createInstance<SecondaryConstructorContext>(_ctx, getState());
  enterRule(_localctx, 42, myParser::RuleSecondaryConstructor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(627);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT

    || _la == myParser::FILE || (((_la - 89) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 89)) & 4504699138981113) != 0) {
      setState(626);
      modifierList();
    }
    setState(629);
    match(myParser::CONSTRUCTOR);
    setState(633);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(630);
      match(myParser::NL);
      setState(635);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(636);
    functionValueParameters();
    setState(651);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
    case 1: {
      setState(640);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(637);
        match(myParser::NL);
        setState(642);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(643);
      match(myParser::COLON);
      setState(647);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(644);
        match(myParser::NL);
        setState(649);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(650);
      constructorDelegationCall();
      break;
    }

    default:
      break;
    }
    setState(656);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(653);
        match(myParser::NL); 
      }
      setState(658);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx);
    }
    setState(660);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LCURL) {
      setState(659);
      block();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstructorDelegationCallContext ------------------------------------------------------------------

myParser::ConstructorDelegationCallContext::ConstructorDelegationCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ConstructorDelegationCallContext::THIS() {
  return getToken(myParser::THIS, 0);
}

myParser::ValueArgumentsContext* myParser::ConstructorDelegationCallContext::valueArguments() {
  return getRuleContext<myParser::ValueArgumentsContext>(0);
}

std::vector<tree::TerminalNode *> myParser::ConstructorDelegationCallContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::ConstructorDelegationCallContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

tree::TerminalNode* myParser::ConstructorDelegationCallContext::SUPER() {
  return getToken(myParser::SUPER, 0);
}


size_t myParser::ConstructorDelegationCallContext::getRuleIndex() const {
  return myParser::RuleConstructorDelegationCall;
}

void myParser::ConstructorDelegationCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstructorDelegationCall(this);
}

void myParser::ConstructorDelegationCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstructorDelegationCall(this);
}

myParser::ConstructorDelegationCallContext* myParser::constructorDelegationCall() {
  ConstructorDelegationCallContext *_localctx = _tracker.createInstance<ConstructorDelegationCallContext>(_ctx, getState());
  enterRule(_localctx, 44, myParser::RuleConstructorDelegationCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(678);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::THIS: {
        enterOuterAlt(_localctx, 1);
        setState(662);
        match(myParser::THIS);
        setState(666);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(663);
          match(myParser::NL);
          setState(668);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(669);
        valueArguments();
        break;
      }

      case myParser::SUPER: {
        enterOuterAlt(_localctx, 2);
        setState(670);
        match(myParser::SUPER);
        setState(674);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(671);
          match(myParser::NL);
          setState(676);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(677);
        valueArguments();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumClassBodyContext ------------------------------------------------------------------

myParser::EnumClassBodyContext::EnumClassBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::EnumClassBodyContext::LCURL() {
  return getToken(myParser::LCURL, 0);
}

tree::TerminalNode* myParser::EnumClassBodyContext::RCURL() {
  return getToken(myParser::RCURL, 0);
}

std::vector<tree::TerminalNode *> myParser::EnumClassBodyContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::EnumClassBodyContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

myParser::EnumEntriesContext* myParser::EnumClassBodyContext::enumEntries() {
  return getRuleContext<myParser::EnumEntriesContext>(0);
}

tree::TerminalNode* myParser::EnumClassBodyContext::SEMICOLON() {
  return getToken(myParser::SEMICOLON, 0);
}

std::vector<myParser::ClassMemberDeclarationContext *> myParser::EnumClassBodyContext::classMemberDeclaration() {
  return getRuleContexts<myParser::ClassMemberDeclarationContext>();
}

myParser::ClassMemberDeclarationContext* myParser::EnumClassBodyContext::classMemberDeclaration(size_t i) {
  return getRuleContext<myParser::ClassMemberDeclarationContext>(i);
}


size_t myParser::EnumClassBodyContext::getRuleIndex() const {
  return myParser::RuleEnumClassBody;
}

void myParser::EnumClassBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumClassBody(this);
}

void myParser::EnumClassBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumClassBody(this);
}

myParser::EnumClassBodyContext* myParser::enumClassBody() {
  EnumClassBodyContext *_localctx = _tracker.createInstance<EnumClassBodyContext>(_ctx, getState());
  enterRule(_localctx, 46, myParser::RuleEnumClassBody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(680);
    match(myParser::LCURL);
    setState(684);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(681);
        match(myParser::NL); 
      }
      setState(686);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx);
    }
    setState(688);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la - 58) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 58)) & -33517921595647) != 0 || (((_la - 122) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 122)) & 262271) != 0) {
      setState(687);
      enumEntries();
    }
    setState(709);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
    case 1: {
      setState(693);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(690);
        match(myParser::NL);
        setState(695);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(696);
      match(myParser::SEMICOLON);
      setState(700);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(697);
          match(myParser::NL); 
        }
        setState(702);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx);
      }
      setState(706);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while ((((_la - 40) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 40)) & 8787085823892324353) != 0 || (((_la - 104) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 104)) & 137472507903) != 0) {
        setState(703);
        classMemberDeclaration();
        setState(708);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
    setState(714);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(711);
      match(myParser::NL);
      setState(716);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(717);
    match(myParser::RCURL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumEntriesContext ------------------------------------------------------------------

myParser::EnumEntriesContext::EnumEntriesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::EnumEntryContext *> myParser::EnumEntriesContext::enumEntry() {
  return getRuleContexts<myParser::EnumEntryContext>();
}

myParser::EnumEntryContext* myParser::EnumEntriesContext::enumEntry(size_t i) {
  return getRuleContext<myParser::EnumEntryContext>(i);
}

tree::TerminalNode* myParser::EnumEntriesContext::SEMICOLON() {
  return getToken(myParser::SEMICOLON, 0);
}

std::vector<tree::TerminalNode *> myParser::EnumEntriesContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::EnumEntriesContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::EnumEntriesContext::getRuleIndex() const {
  return myParser::RuleEnumEntries;
}

void myParser::EnumEntriesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumEntries(this);
}

void myParser::EnumEntriesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumEntries(this);
}

myParser::EnumEntriesContext* myParser::enumEntries() {
  EnumEntriesContext *_localctx = _tracker.createInstance<EnumEntriesContext>(_ctx, getState());
  enterRule(_localctx, 48, myParser::RuleEnumEntries);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(726); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(719);
      enumEntry();
      setState(723);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(720);
          match(myParser::NL); 
        }
        setState(725);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);
      }
      setState(728); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la - 58) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 58)) & -33517921595647) != 0 || (((_la - 122) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 122)) & 262271) != 0);
    setState(731);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx)) {
    case 1: {
      setState(730);
      match(myParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumEntryContext ------------------------------------------------------------------

myParser::EnumEntryContext::EnumEntryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SimpleIdentifierContext* myParser::EnumEntryContext::simpleIdentifier() {
  return getRuleContext<myParser::SimpleIdentifierContext>(0);
}

myParser::ValueArgumentsContext* myParser::EnumEntryContext::valueArguments() {
  return getRuleContext<myParser::ValueArgumentsContext>(0);
}

myParser::ClassBodyContext* myParser::EnumEntryContext::classBody() {
  return getRuleContext<myParser::ClassBodyContext>(0);
}

tree::TerminalNode* myParser::EnumEntryContext::COMMA() {
  return getToken(myParser::COMMA, 0);
}

std::vector<tree::TerminalNode *> myParser::EnumEntryContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::EnumEntryContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::EnumEntryContext::getRuleIndex() const {
  return myParser::RuleEnumEntry;
}

void myParser::EnumEntryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumEntry(this);
}

void myParser::EnumEntryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumEntry(this);
}

myParser::EnumEntryContext* myParser::enumEntry() {
  EnumEntryContext *_localctx = _tracker.createInstance<EnumEntryContext>(_ctx, getState());
  enterRule(_localctx, 50, myParser::RuleEnumEntry);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(733);
    simpleIdentifier();
    setState(741);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx)) {
    case 1: {
      setState(737);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(734);
        match(myParser::NL);
        setState(739);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(740);
      valueArguments();
      break;
    }

    default:
      break;
    }
    setState(750);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx)) {
    case 1: {
      setState(746);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(743);
        match(myParser::NL);
        setState(748);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(749);
      classBody();
      break;
    }

    default:
      break;
    }
    setState(759);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx)) {
    case 1: {
      setState(755);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(752);
        match(myParser::NL);
        setState(757);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(758);
      match(myParser::COMMA);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDeclarationContext ------------------------------------------------------------------

myParser::FunctionDeclarationContext::FunctionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::FunctionDeclarationContext::FUN() {
  return getToken(myParser::FUN, 0);
}

myParser::FunctionValueParametersContext* myParser::FunctionDeclarationContext::functionValueParameters() {
  return getRuleContext<myParser::FunctionValueParametersContext>(0);
}

myParser::ModifierListContext* myParser::FunctionDeclarationContext::modifierList() {
  return getRuleContext<myParser::ModifierListContext>(0);
}

std::vector<myParser::TypeContext *> myParser::FunctionDeclarationContext::type() {
  return getRuleContexts<myParser::TypeContext>();
}

myParser::TypeContext* myParser::FunctionDeclarationContext::type(size_t i) {
  return getRuleContext<myParser::TypeContext>(i);
}

tree::TerminalNode* myParser::FunctionDeclarationContext::DOT() {
  return getToken(myParser::DOT, 0);
}

myParser::TypeParametersContext* myParser::FunctionDeclarationContext::typeParameters() {
  return getRuleContext<myParser::TypeParametersContext>(0);
}

myParser::IdentifierContext* myParser::FunctionDeclarationContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

std::vector<tree::TerminalNode *> myParser::FunctionDeclarationContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::FunctionDeclarationContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

tree::TerminalNode* myParser::FunctionDeclarationContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::TypeConstraintsContext* myParser::FunctionDeclarationContext::typeConstraints() {
  return getRuleContext<myParser::TypeConstraintsContext>(0);
}

myParser::FunctionBodyContext* myParser::FunctionDeclarationContext::functionBody() {
  return getRuleContext<myParser::FunctionBodyContext>(0);
}


size_t myParser::FunctionDeclarationContext::getRuleIndex() const {
  return myParser::RuleFunctionDeclaration;
}

void myParser::FunctionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionDeclaration(this);
}

void myParser::FunctionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionDeclaration(this);
}

myParser::FunctionDeclarationContext* myParser::functionDeclaration() {
  FunctionDeclarationContext *_localctx = _tracker.createInstance<FunctionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 52, myParser::RuleFunctionDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(762);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT

    || _la == myParser::FILE || (((_la - 89) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 89)) & 4504699138981113) != 0) {
      setState(761);
      modifierList();
    }
    setState(764);
    match(myParser::FUN);
    setState(780);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx)) {
    case 1: {
      setState(768);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(765);
        match(myParser::NL);
        setState(770);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(771);
      type();
      setState(775);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(772);
        match(myParser::NL);
        setState(777);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(778);
      match(myParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(789);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 91, _ctx)) {
    case 1: {
      setState(785);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(782);
        match(myParser::NL);
        setState(787);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(788);
      typeParameters();
      break;
    }

    default:
      break;
    }
    setState(798);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx)) {
    case 1: {
      setState(794);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(791);
        match(myParser::NL);
        setState(796);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(797);
      identifier();
      break;
    }

    default:
      break;
    }
    setState(803);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(800);
      match(myParser::NL);
      setState(805);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(806);
    functionValueParameters();
    setState(821);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx)) {
    case 1: {
      setState(810);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(807);
        match(myParser::NL);
        setState(812);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(813);
      match(myParser::COLON);
      setState(817);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(814);
        match(myParser::NL);
        setState(819);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(820);
      type();
      break;
    }

    default:
      break;
    }
    setState(830);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 99, _ctx)) {
    case 1: {
      setState(826);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(823);
        match(myParser::NL);
        setState(828);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(829);
      typeConstraints();
      break;
    }

    default:
      break;
    }
    setState(839);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx)) {
    case 1: {
      setState(835);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(832);
        match(myParser::NL);
        setState(837);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(838);
      functionBody();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionValueParametersContext ------------------------------------------------------------------

myParser::FunctionValueParametersContext::FunctionValueParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::FunctionValueParametersContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::FunctionValueParametersContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

std::vector<myParser::FunctionValueParameterContext *> myParser::FunctionValueParametersContext::functionValueParameter() {
  return getRuleContexts<myParser::FunctionValueParameterContext>();
}

myParser::FunctionValueParameterContext* myParser::FunctionValueParametersContext::functionValueParameter(size_t i) {
  return getRuleContext<myParser::FunctionValueParameterContext>(i);
}

std::vector<tree::TerminalNode *> myParser::FunctionValueParametersContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::FunctionValueParametersContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::FunctionValueParametersContext::getRuleIndex() const {
  return myParser::RuleFunctionValueParameters;
}

void myParser::FunctionValueParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionValueParameters(this);
}

void myParser::FunctionValueParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionValueParameters(this);
}

myParser::FunctionValueParametersContext* myParser::functionValueParameters() {
  FunctionValueParametersContext *_localctx = _tracker.createInstance<FunctionValueParametersContext>(_ctx, getState());
  enterRule(_localctx, 54, myParser::RuleFunctionValueParameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(841);
    match(myParser::LPAREN);
    setState(850);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la - 40) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 40)) & -3939815443333119) != 0 || (((_la - 104) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 104)) & 206191984639) != 0) {
      setState(842);
      functionValueParameter();
      setState(847);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::COMMA) {
        setState(843);
        match(myParser::COMMA);
        setState(844);
        functionValueParameter();
        setState(849);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(852);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionValueParameterContext ------------------------------------------------------------------

myParser::FunctionValueParameterContext::FunctionValueParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ParameterContext* myParser::FunctionValueParameterContext::parameter() {
  return getRuleContext<myParser::ParameterContext>(0);
}

myParser::ModifierListContext* myParser::FunctionValueParameterContext::modifierList() {
  return getRuleContext<myParser::ModifierListContext>(0);
}

tree::TerminalNode* myParser::FunctionValueParameterContext::ASSIGNMENT() {
  return getToken(myParser::ASSIGNMENT, 0);
}

myParser::ExpressionContext* myParser::FunctionValueParameterContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}


size_t myParser::FunctionValueParameterContext::getRuleIndex() const {
  return myParser::RuleFunctionValueParameter;
}

void myParser::FunctionValueParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionValueParameter(this);
}

void myParser::FunctionValueParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionValueParameter(this);
}

myParser::FunctionValueParameterContext* myParser::functionValueParameter() {
  FunctionValueParameterContext *_localctx = _tracker.createInstance<FunctionValueParameterContext>(_ctx, getState());
  enterRule(_localctx, 56, myParser::RuleFunctionValueParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(855);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 104, _ctx)) {
    case 1: {
      setState(854);
      modifierList();
      break;
    }

    default:
      break;
    }
    setState(857);
    parameter();
    setState(860);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::ASSIGNMENT) {
      setState(858);
      match(myParser::ASSIGNMENT);
      setState(859);
      expression();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterContext ------------------------------------------------------------------

myParser::ParameterContext::ParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SimpleIdentifierContext* myParser::ParameterContext::simpleIdentifier() {
  return getRuleContext<myParser::SimpleIdentifierContext>(0);
}

tree::TerminalNode* myParser::ParameterContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::TypeContext* myParser::ParameterContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}


size_t myParser::ParameterContext::getRuleIndex() const {
  return myParser::RuleParameter;
}

void myParser::ParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter(this);
}

void myParser::ParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter(this);
}

myParser::ParameterContext* myParser::parameter() {
  ParameterContext *_localctx = _tracker.createInstance<ParameterContext>(_ctx, getState());
  enterRule(_localctx, 58, myParser::RuleParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(862);
    simpleIdentifier();
    setState(863);
    match(myParser::COLON);
    setState(864);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionBodyContext ------------------------------------------------------------------

myParser::FunctionBodyContext::FunctionBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::BlockContext* myParser::FunctionBodyContext::block() {
  return getRuleContext<myParser::BlockContext>(0);
}

tree::TerminalNode* myParser::FunctionBodyContext::ASSIGNMENT() {
  return getToken(myParser::ASSIGNMENT, 0);
}

myParser::ExpressionContext* myParser::FunctionBodyContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

std::vector<tree::TerminalNode *> myParser::FunctionBodyContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::FunctionBodyContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::FunctionBodyContext::getRuleIndex() const {
  return myParser::RuleFunctionBody;
}

void myParser::FunctionBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionBody(this);
}

void myParser::FunctionBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionBody(this);
}

myParser::FunctionBodyContext* myParser::functionBody() {
  FunctionBodyContext *_localctx = _tracker.createInstance<FunctionBodyContext>(_ctx, getState());
  enterRule(_localctx, 60, myParser::RuleFunctionBody);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(875);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::LCURL: {
        enterOuterAlt(_localctx, 1);
        setState(866);
        block();
        break;
      }

      case myParser::ASSIGNMENT: {
        enterOuterAlt(_localctx, 2);
        setState(867);
        match(myParser::ASSIGNMENT);
        setState(871);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(868);
            match(myParser::NL); 
          }
          setState(873);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx);
        }
        setState(874);
        expression();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectDeclarationContext ------------------------------------------------------------------

myParser::ObjectDeclarationContext::ObjectDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ObjectDeclarationContext::OBJECT() {
  return getToken(myParser::OBJECT, 0);
}

myParser::SimpleIdentifierContext* myParser::ObjectDeclarationContext::simpleIdentifier() {
  return getRuleContext<myParser::SimpleIdentifierContext>(0);
}

myParser::ModifierListContext* myParser::ObjectDeclarationContext::modifierList() {
  return getRuleContext<myParser::ModifierListContext>(0);
}

std::vector<tree::TerminalNode *> myParser::ObjectDeclarationContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::ObjectDeclarationContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

myParser::PrimaryConstructorContext* myParser::ObjectDeclarationContext::primaryConstructor() {
  return getRuleContext<myParser::PrimaryConstructorContext>(0);
}

tree::TerminalNode* myParser::ObjectDeclarationContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::DelegationSpecifiersContext* myParser::ObjectDeclarationContext::delegationSpecifiers() {
  return getRuleContext<myParser::DelegationSpecifiersContext>(0);
}

myParser::ClassBodyContext* myParser::ObjectDeclarationContext::classBody() {
  return getRuleContext<myParser::ClassBodyContext>(0);
}


size_t myParser::ObjectDeclarationContext::getRuleIndex() const {
  return myParser::RuleObjectDeclaration;
}

void myParser::ObjectDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectDeclaration(this);
}

void myParser::ObjectDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectDeclaration(this);
}

myParser::ObjectDeclarationContext* myParser::objectDeclaration() {
  ObjectDeclarationContext *_localctx = _tracker.createInstance<ObjectDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 62, myParser::RuleObjectDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(878);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT

    || _la == myParser::FILE || (((_la - 89) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 89)) & 4504699138981113) != 0) {
      setState(877);
      modifierList();
    }
    setState(880);
    match(myParser::OBJECT);
    setState(884);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(881);
      match(myParser::NL);
      setState(886);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(887);
    simpleIdentifier();
    setState(895);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx)) {
    case 1: {
      setState(891);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(888);
        match(myParser::NL);
        setState(893);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(894);
      primaryConstructor();
      break;
    }

    default:
      break;
    }
    setState(911);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx)) {
    case 1: {
      setState(900);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(897);
        match(myParser::NL);
        setState(902);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(903);
      match(myParser::COLON);
      setState(907);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(904);
        match(myParser::NL);
        setState(909);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(910);
      delegationSpecifiers();
      break;
    }

    default:
      break;
    }
    setState(920);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx)) {
    case 1: {
      setState(916);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(913);
        match(myParser::NL);
        setState(918);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(919);
      classBody();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompanionObjectContext ------------------------------------------------------------------

myParser::CompanionObjectContext::CompanionObjectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::CompanionObjectContext::COMPANION() {
  return getToken(myParser::COMPANION, 0);
}

tree::TerminalNode* myParser::CompanionObjectContext::OBJECT() {
  return getToken(myParser::OBJECT, 0);
}

std::vector<myParser::ModifierListContext *> myParser::CompanionObjectContext::modifierList() {
  return getRuleContexts<myParser::ModifierListContext>();
}

myParser::ModifierListContext* myParser::CompanionObjectContext::modifierList(size_t i) {
  return getRuleContext<myParser::ModifierListContext>(i);
}

std::vector<tree::TerminalNode *> myParser::CompanionObjectContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::CompanionObjectContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

myParser::SimpleIdentifierContext* myParser::CompanionObjectContext::simpleIdentifier() {
  return getRuleContext<myParser::SimpleIdentifierContext>(0);
}

tree::TerminalNode* myParser::CompanionObjectContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::DelegationSpecifiersContext* myParser::CompanionObjectContext::delegationSpecifiers() {
  return getRuleContext<myParser::DelegationSpecifiersContext>(0);
}

myParser::ClassBodyContext* myParser::CompanionObjectContext::classBody() {
  return getRuleContext<myParser::ClassBodyContext>(0);
}


size_t myParser::CompanionObjectContext::getRuleIndex() const {
  return myParser::RuleCompanionObject;
}

void myParser::CompanionObjectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompanionObject(this);
}

void myParser::CompanionObjectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompanionObject(this);
}

myParser::CompanionObjectContext* myParser::companionObject() {
  CompanionObjectContext *_localctx = _tracker.createInstance<CompanionObjectContext>(_ctx, getState());
  enterRule(_localctx, 64, myParser::RuleCompanionObject);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(923);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT

    || _la == myParser::FILE || (((_la - 89) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 89)) & 4504699138981113) != 0) {
      setState(922);
      modifierList();
    }
    setState(925);
    match(myParser::COMPANION);
    setState(929);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(926);
      match(myParser::NL);
      setState(931);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(933);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT

    || _la == myParser::FILE || (((_la - 89) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 89)) & 4504699138981113) != 0) {
      setState(932);
      modifierList();
    }
    setState(935);
    match(myParser::OBJECT);
    setState(943);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx)) {
    case 1: {
      setState(939);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(936);
        match(myParser::NL);
        setState(941);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(942);
      simpleIdentifier();
      break;
    }

    default:
      break;
    }
    setState(959);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 124, _ctx)) {
    case 1: {
      setState(948);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(945);
        match(myParser::NL);
        setState(950);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(951);
      match(myParser::COLON);
      setState(955);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(952);
        match(myParser::NL);
        setState(957);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(958);
      delegationSpecifiers();
      break;
    }

    default:
      break;
    }
    setState(968);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx)) {
    case 1: {
      setState(964);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(961);
        match(myParser::NL);
        setState(966);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(967);
      classBody();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyDeclarationContext ------------------------------------------------------------------

myParser::PropertyDeclarationContext::PropertyDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::PropertyDeclarationContext::VAL() {
  return getToken(myParser::VAL, 0);
}

tree::TerminalNode* myParser::PropertyDeclarationContext::VAR() {
  return getToken(myParser::VAR, 0);
}

myParser::ModifierListContext* myParser::PropertyDeclarationContext::modifierList() {
  return getRuleContext<myParser::ModifierListContext>(0);
}

myParser::TypeParametersContext* myParser::PropertyDeclarationContext::typeParameters() {
  return getRuleContext<myParser::TypeParametersContext>(0);
}

myParser::TypeContext* myParser::PropertyDeclarationContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

tree::TerminalNode* myParser::PropertyDeclarationContext::DOT() {
  return getToken(myParser::DOT, 0);
}

myParser::TypeConstraintsContext* myParser::PropertyDeclarationContext::typeConstraints() {
  return getRuleContext<myParser::TypeConstraintsContext>(0);
}

myParser::ExpressionContext* myParser::PropertyDeclarationContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

myParser::GetterContext* myParser::PropertyDeclarationContext::getter() {
  return getRuleContext<myParser::GetterContext>(0);
}

myParser::SetterContext* myParser::PropertyDeclarationContext::setter() {
  return getRuleContext<myParser::SetterContext>(0);
}

myParser::MultiVariableDeclarationContext* myParser::PropertyDeclarationContext::multiVariableDeclaration() {
  return getRuleContext<myParser::MultiVariableDeclarationContext>(0);
}

myParser::VariableDeclarationContext* myParser::PropertyDeclarationContext::variableDeclaration() {
  return getRuleContext<myParser::VariableDeclarationContext>(0);
}

tree::TerminalNode* myParser::PropertyDeclarationContext::BY() {
  return getToken(myParser::BY, 0);
}

tree::TerminalNode* myParser::PropertyDeclarationContext::ASSIGNMENT() {
  return getToken(myParser::ASSIGNMENT, 0);
}

std::vector<tree::TerminalNode *> myParser::PropertyDeclarationContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::PropertyDeclarationContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

myParser::SemiContext* myParser::PropertyDeclarationContext::semi() {
  return getRuleContext<myParser::SemiContext>(0);
}


size_t myParser::PropertyDeclarationContext::getRuleIndex() const {
  return myParser::RulePropertyDeclaration;
}

void myParser::PropertyDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyDeclaration(this);
}

void myParser::PropertyDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyDeclaration(this);
}

myParser::PropertyDeclarationContext* myParser::propertyDeclaration() {
  PropertyDeclarationContext *_localctx = _tracker.createInstance<PropertyDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 66, myParser::RulePropertyDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(971);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT

    || _la == myParser::FILE || (((_la - 89) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 89)) & 4504699138981113) != 0) {
      setState(970);
      modifierList();
    }
    setState(973);
    _la = _input->LA(1);
    if (!(_la == myParser::VAL

    || _la == myParser::VAR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(981);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx)) {
    case 1: {
      setState(977);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(974);
        match(myParser::NL);
        setState(979);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(980);
      typeParameters();
      break;
    }

    default:
      break;
    }
    setState(998);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx)) {
    case 1: {
      setState(986);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(983);
        match(myParser::NL);
        setState(988);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(989);
      type();
      setState(993);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(990);
        match(myParser::NL);
        setState(995);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(996);
      match(myParser::DOT);
      break;
    }

    default:
      break;
    }

    setState(1003);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(1000);
      match(myParser::NL);
      setState(1005);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1008);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::LPAREN: {
        setState(1006);
        multiVariableDeclaration();
        break;
      }

      case myParser::IMPORT:
      case myParser::CONSTRUCTOR:
      case myParser::BY:
      case myParser::COMPANION:
      case myParser::INIT:
      case myParser::WHERE:
      case myParser::CATCH:
      case myParser::FINALLY:
      case myParser::OUT:
      case myParser::GETTER:
      case myParser::SETTER:
      case myParser::DYNAMIC:
      case myParser::PUBLIC:
      case myParser::PRIVATE:
      case myParser::PROTECTED:
      case myParser::INTERNAL:
      case myParser::ENUM:
      case myParser::SEALED:
      case myParser::ANNOTATION:
      case myParser::DATA:
      case myParser::INNER:
      case myParser::TAILREC:
      case myParser::OPERATOR:
      case myParser::INLINE:
      case myParser::INFIX:
      case myParser::EXTERNAL:
      case myParser::SUSPEND:
      case myParser::OVERRIDE:
      case myParser::ABSTRACT:
      case myParser::FINAL:
      case myParser::OPEN:
      case myParser::CONST:
      case myParser::LATEINIT:
      case myParser::VARARG:
      case myParser::NOINLINE:
      case myParser::CROSSINLINE:
      case myParser::REIFIED:
      case myParser::Identifier: {
        setState(1007);
        variableDeclaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1017);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx)) {
    case 1: {
      setState(1013);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(1010);
        match(myParser::NL);
        setState(1015);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1016);
      typeConstraints();
      break;
    }

    default:
      break;
    }
    setState(1033);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 139, _ctx)) {
    case 1: {
      setState(1022);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(1019);
        match(myParser::NL);
        setState(1024);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1025);
      _la = _input->LA(1);
      if (!(_la == myParser::ASSIGNMENT

      || _la == myParser::BY)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1029);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 138, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1026);
          match(myParser::NL); 
        }
        setState(1031);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 138, _ctx);
      }
      setState(1032);
      expression();
      break;
    }

    default:
      break;
    }
    setState(1047);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, _ctx)) {
    case 1: {
      setState(1035);
      getter();
      setState(1039);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 140, _ctx)) {
      case 1: {
        setState(1036);
        semi();
        setState(1037);
        setter();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      setState(1041);
      setter();
      setState(1045);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx)) {
      case 1: {
        setState(1042);
        semi();
        setState(1043);
        getter();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultiVariableDeclarationContext ------------------------------------------------------------------

myParser::MultiVariableDeclarationContext::MultiVariableDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::MultiVariableDeclarationContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

std::vector<myParser::VariableDeclarationContext *> myParser::MultiVariableDeclarationContext::variableDeclaration() {
  return getRuleContexts<myParser::VariableDeclarationContext>();
}

myParser::VariableDeclarationContext* myParser::MultiVariableDeclarationContext::variableDeclaration(size_t i) {
  return getRuleContext<myParser::VariableDeclarationContext>(i);
}

tree::TerminalNode* myParser::MultiVariableDeclarationContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

std::vector<tree::TerminalNode *> myParser::MultiVariableDeclarationContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::MultiVariableDeclarationContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::MultiVariableDeclarationContext::getRuleIndex() const {
  return myParser::RuleMultiVariableDeclaration;
}

void myParser::MultiVariableDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiVariableDeclaration(this);
}

void myParser::MultiVariableDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiVariableDeclaration(this);
}

myParser::MultiVariableDeclarationContext* myParser::multiVariableDeclaration() {
  MultiVariableDeclarationContext *_localctx = _tracker.createInstance<MultiVariableDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 68, myParser::RuleMultiVariableDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1049);
    match(myParser::LPAREN);
    setState(1050);
    variableDeclaration();
    setState(1055);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(1051);
      match(myParser::COMMA);
      setState(1052);
      variableDeclaration();
      setState(1057);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1058);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationContext ------------------------------------------------------------------

myParser::VariableDeclarationContext::VariableDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SimpleIdentifierContext* myParser::VariableDeclarationContext::simpleIdentifier() {
  return getRuleContext<myParser::SimpleIdentifierContext>(0);
}

tree::TerminalNode* myParser::VariableDeclarationContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::TypeContext* myParser::VariableDeclarationContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}


size_t myParser::VariableDeclarationContext::getRuleIndex() const {
  return myParser::RuleVariableDeclaration;
}

void myParser::VariableDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclaration(this);
}

void myParser::VariableDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclaration(this);
}

myParser::VariableDeclarationContext* myParser::variableDeclaration() {
  VariableDeclarationContext *_localctx = _tracker.createInstance<VariableDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 70, myParser::RuleVariableDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1060);
    simpleIdentifier();
    setState(1063);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::COLON) {
      setState(1061);
      match(myParser::COLON);
      setState(1062);
      type();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GetterContext ------------------------------------------------------------------

myParser::GetterContext::GetterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::GetterContext::GETTER() {
  return getToken(myParser::GETTER, 0);
}

myParser::ModifierListContext* myParser::GetterContext::modifierList() {
  return getRuleContext<myParser::ModifierListContext>(0);
}

tree::TerminalNode* myParser::GetterContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::GetterContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

myParser::BlockContext* myParser::GetterContext::block() {
  return getRuleContext<myParser::BlockContext>(0);
}

tree::TerminalNode* myParser::GetterContext::ASSIGNMENT() {
  return getToken(myParser::ASSIGNMENT, 0);
}

myParser::ExpressionContext* myParser::GetterContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

std::vector<tree::TerminalNode *> myParser::GetterContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::GetterContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

tree::TerminalNode* myParser::GetterContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::TypeContext* myParser::GetterContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}


size_t myParser::GetterContext::getRuleIndex() const {
  return myParser::RuleGetter;
}

void myParser::GetterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGetter(this);
}

void myParser::GetterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGetter(this);
}

myParser::GetterContext* myParser::getter() {
  GetterContext *_localctx = _tracker.createInstance<GetterContext>(_ctx, getState());
  enterRule(_localctx, 72, myParser::RuleGetter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1114);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1066);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::AT

      || _la == myParser::FILE || (((_la - 89) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 89)) & 4504699138981113) != 0) {
        setState(1065);
        modifierList();
      }
      setState(1068);
      match(myParser::GETTER);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1070);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::AT

      || _la == myParser::FILE || (((_la - 89) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 89)) & 4504699138981113) != 0) {
        setState(1069);
        modifierList();
      }
      setState(1072);
      match(myParser::GETTER);
      setState(1076);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(1073);
        match(myParser::NL);
        setState(1078);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1079);
      match(myParser::LPAREN);
      setState(1080);
      match(myParser::RPAREN);
      setState(1095);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 150, _ctx)) {
      case 1: {
        setState(1084);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(1081);
          match(myParser::NL);
          setState(1086);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1087);
        match(myParser::COLON);
        setState(1091);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(1088);
          match(myParser::NL);
          setState(1093);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1094);
        type();
        break;
      }

      default:
        break;
      }
      setState(1100);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(1097);
        match(myParser::NL);
        setState(1102);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1112);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case myParser::LCURL: {
          setState(1103);
          block();
          break;
        }

        case myParser::ASSIGNMENT: {
          setState(1104);
          match(myParser::ASSIGNMENT);
          setState(1108);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 152, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(1105);
              match(myParser::NL); 
            }
            setState(1110);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 152, _ctx);
          }
          setState(1111);
          expression();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetterContext ------------------------------------------------------------------

myParser::SetterContext::SetterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::SetterContext::SETTER() {
  return getToken(myParser::SETTER, 0);
}

myParser::ModifierListContext* myParser::SetterContext::modifierList() {
  return getRuleContext<myParser::ModifierListContext>(0);
}

tree::TerminalNode* myParser::SetterContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::SetterContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

myParser::FunctionBodyContext* myParser::SetterContext::functionBody() {
  return getRuleContext<myParser::FunctionBodyContext>(0);
}

myParser::SimpleIdentifierContext* myParser::SetterContext::simpleIdentifier() {
  return getRuleContext<myParser::SimpleIdentifierContext>(0);
}

myParser::ParameterContext* myParser::SetterContext::parameter() {
  return getRuleContext<myParser::ParameterContext>(0);
}

std::vector<tree::TerminalNode *> myParser::SetterContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::SetterContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

std::vector<myParser::AnnotationsContext *> myParser::SetterContext::annotations() {
  return getRuleContexts<myParser::AnnotationsContext>();
}

myParser::AnnotationsContext* myParser::SetterContext::annotations(size_t i) {
  return getRuleContext<myParser::AnnotationsContext>(i);
}

std::vector<myParser::ParameterModifierContext *> myParser::SetterContext::parameterModifier() {
  return getRuleContexts<myParser::ParameterModifierContext>();
}

myParser::ParameterModifierContext* myParser::SetterContext::parameterModifier(size_t i) {
  return getRuleContext<myParser::ParameterModifierContext>(i);
}


size_t myParser::SetterContext::getRuleIndex() const {
  return myParser::RuleSetter;
}

void myParser::SetterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetter(this);
}

void myParser::SetterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetter(this);
}

myParser::SetterContext* myParser::setter() {
  SetterContext *_localctx = _tracker.createInstance<SetterContext>(_ctx, getState());
  enterRule(_localctx, 74, myParser::RuleSetter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1151);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 162, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1117);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::AT

      || _la == myParser::FILE || (((_la - 89) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 89)) & 4504699138981113) != 0) {
        setState(1116);
        modifierList();
      }
      setState(1119);
      match(myParser::SETTER);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1121);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::AT

      || _la == myParser::FILE || (((_la - 89) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 89)) & 4504699138981113) != 0) {
        setState(1120);
        modifierList();
      }
      setState(1123);
      match(myParser::SETTER);
      setState(1127);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(1124);
        match(myParser::NL);
        setState(1129);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1130);
      match(myParser::LPAREN);
      setState(1135);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 159, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1133);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case myParser::AT:
            case myParser::FILE:
            case myParser::FIELD:
            case myParser::PROPERTY:
            case myParser::GET:
            case myParser::SET:
            case myParser::RECEIVER:
            case myParser::PARAM:
            case myParser::SETPARAM:
            case myParser::DELEGATE:
            case myParser::LabelReference: {
              setState(1131);
              annotations();
              break;
            }

            case myParser::VARARG:
            case myParser::NOINLINE:
            case myParser::CROSSINLINE: {
              setState(1132);
              parameterModifier();
              break;
            }

          default:
            throw NoViableAltException(this);
          } 
        }
        setState(1137);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 159, _ctx);
      }
      setState(1140);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 160, _ctx)) {
      case 1: {
        setState(1138);
        simpleIdentifier();
        break;
      }

      case 2: {
        setState(1139);
        parameter();
        break;
      }

      default:
        break;
      }
      setState(1142);
      match(myParser::RPAREN);
      setState(1146);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(1143);
        match(myParser::NL);
        setState(1148);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1149);
      functionBody();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeAliasContext ------------------------------------------------------------------

myParser::TypeAliasContext::TypeAliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TypeAliasContext::TYPE_ALIAS() {
  return getToken(myParser::TYPE_ALIAS, 0);
}

myParser::SimpleIdentifierContext* myParser::TypeAliasContext::simpleIdentifier() {
  return getRuleContext<myParser::SimpleIdentifierContext>(0);
}

tree::TerminalNode* myParser::TypeAliasContext::ASSIGNMENT() {
  return getToken(myParser::ASSIGNMENT, 0);
}

myParser::TypeContext* myParser::TypeAliasContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

myParser::ModifierListContext* myParser::TypeAliasContext::modifierList() {
  return getRuleContext<myParser::ModifierListContext>(0);
}

std::vector<tree::TerminalNode *> myParser::TypeAliasContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::TypeAliasContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

myParser::TypeParametersContext* myParser::TypeAliasContext::typeParameters() {
  return getRuleContext<myParser::TypeParametersContext>(0);
}


size_t myParser::TypeAliasContext::getRuleIndex() const {
  return myParser::RuleTypeAlias;
}

void myParser::TypeAliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeAlias(this);
}

void myParser::TypeAliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeAlias(this);
}

myParser::TypeAliasContext* myParser::typeAlias() {
  TypeAliasContext *_localctx = _tracker.createInstance<TypeAliasContext>(_ctx, getState());
  enterRule(_localctx, 76, myParser::RuleTypeAlias);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1154);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AT

    || _la == myParser::FILE || (((_la - 89) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 89)) & 4504699138981113) != 0) {
      setState(1153);
      modifierList();
    }
    setState(1156);
    match(myParser::TYPE_ALIAS);
    setState(1160);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(1157);
      match(myParser::NL);
      setState(1162);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1163);
    simpleIdentifier();
    setState(1171);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 166, _ctx)) {
    case 1: {
      setState(1167);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(1164);
        match(myParser::NL);
        setState(1169);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1170);
      typeParameters();
      break;
    }

    default:
      break;
    }
    setState(1176);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(1173);
      match(myParser::NL);
      setState(1178);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1179);
    match(myParser::ASSIGNMENT);
    setState(1183);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(1180);
      match(myParser::NL);
      setState(1185);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1186);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeParametersContext ------------------------------------------------------------------

myParser::TypeParametersContext::TypeParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TypeParametersContext::LANGLE() {
  return getToken(myParser::LANGLE, 0);
}

std::vector<myParser::TypeParameterContext *> myParser::TypeParametersContext::typeParameter() {
  return getRuleContexts<myParser::TypeParameterContext>();
}

myParser::TypeParameterContext* myParser::TypeParametersContext::typeParameter(size_t i) {
  return getRuleContext<myParser::TypeParameterContext>(i);
}

tree::TerminalNode* myParser::TypeParametersContext::RANGLE() {
  return getToken(myParser::RANGLE, 0);
}

std::vector<tree::TerminalNode *> myParser::TypeParametersContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::TypeParametersContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

std::vector<tree::TerminalNode *> myParser::TypeParametersContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::TypeParametersContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::TypeParametersContext::getRuleIndex() const {
  return myParser::RuleTypeParameters;
}

void myParser::TypeParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeParameters(this);
}

void myParser::TypeParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeParameters(this);
}

myParser::TypeParametersContext* myParser::typeParameters() {
  TypeParametersContext *_localctx = _tracker.createInstance<TypeParametersContext>(_ctx, getState());
  enterRule(_localctx, 78, myParser::RuleTypeParameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1188);
    match(myParser::LANGLE);
    setState(1192);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1189);
        match(myParser::NL); 
      }
      setState(1194);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx);
    }
    setState(1195);
    typeParameter();
    setState(1212);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1199);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(1196);
          match(myParser::NL);
          setState(1201);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1202);
        match(myParser::COMMA);
        setState(1206);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 171, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1203);
            match(myParser::NL); 
          }
          setState(1208);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 171, _ctx);
        }
        setState(1209);
        typeParameter(); 
      }
      setState(1214);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, _ctx);
    }
    setState(1218);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(1215);
      match(myParser::NL);
      setState(1220);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1221);
    match(myParser::RANGLE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeParameterContext ------------------------------------------------------------------

myParser::TypeParameterContext::TypeParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SimpleIdentifierContext* myParser::TypeParameterContext::simpleIdentifier() {
  return getRuleContext<myParser::SimpleIdentifierContext>(0);
}

myParser::ModifierListContext* myParser::TypeParameterContext::modifierList() {
  return getRuleContext<myParser::ModifierListContext>(0);
}

std::vector<tree::TerminalNode *> myParser::TypeParameterContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::TypeParameterContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

tree::TerminalNode* myParser::TypeParameterContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::TypeContext* myParser::TypeParameterContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}


size_t myParser::TypeParameterContext::getRuleIndex() const {
  return myParser::RuleTypeParameter;
}

void myParser::TypeParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeParameter(this);
}

void myParser::TypeParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeParameter(this);
}

myParser::TypeParameterContext* myParser::typeParameter() {
  TypeParameterContext *_localctx = _tracker.createInstance<TypeParameterContext>(_ctx, getState());
  enterRule(_localctx, 80, myParser::RuleTypeParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1224);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 174, _ctx)) {
    case 1: {
      setState(1223);
      modifierList();
      break;
    }

    default:
      break;
    }
    setState(1229);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(1226);
      match(myParser::NL);
      setState(1231);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1232);
    simpleIdentifier();
    setState(1247);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 178, _ctx)) {
    case 1: {
      setState(1236);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(1233);
        match(myParser::NL);
        setState(1238);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1239);
      match(myParser::COLON);
      setState(1243);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(1240);
        match(myParser::NL);
        setState(1245);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1246);
      type();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeContext ------------------------------------------------------------------

myParser::TypeContext::TypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::FunctionTypeContext* myParser::TypeContext::functionType() {
  return getRuleContext<myParser::FunctionTypeContext>(0);
}

myParser::ParenthesizedTypeContext* myParser::TypeContext::parenthesizedType() {
  return getRuleContext<myParser::ParenthesizedTypeContext>(0);
}

myParser::NullableTypeContext* myParser::TypeContext::nullableType() {
  return getRuleContext<myParser::NullableTypeContext>(0);
}

myParser::TypeReferenceContext* myParser::TypeContext::typeReference() {
  return getRuleContext<myParser::TypeReferenceContext>(0);
}

myParser::TypeModifierListContext* myParser::TypeContext::typeModifierList() {
  return getRuleContext<myParser::TypeModifierListContext>(0);
}


size_t myParser::TypeContext::getRuleIndex() const {
  return myParser::RuleType;
}

void myParser::TypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType(this);
}

void myParser::TypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType(this);
}

myParser::TypeContext* myParser::type() {
  TypeContext *_localctx = _tracker.createInstance<TypeContext>(_ctx, getState());
  enterRule(_localctx, 82, myParser::RuleType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1250);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 179, _ctx)) {
    case 1: {
      setState(1249);
      typeModifierList();
      break;
    }

    default:
      break;
    }
    setState(1256);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 180, _ctx)) {
    case 1: {
      setState(1252);
      functionType();
      break;
    }

    case 2: {
      setState(1253);
      parenthesizedType();
      break;
    }

    case 3: {
      setState(1254);
      nullableType();
      break;
    }

    case 4: {
      setState(1255);
      typeReference();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeModifierListContext ------------------------------------------------------------------

myParser::TypeModifierListContext::TypeModifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::AnnotationsContext *> myParser::TypeModifierListContext::annotations() {
  return getRuleContexts<myParser::AnnotationsContext>();
}

myParser::AnnotationsContext* myParser::TypeModifierListContext::annotations(size_t i) {
  return getRuleContext<myParser::AnnotationsContext>(i);
}

std::vector<tree::TerminalNode *> myParser::TypeModifierListContext::SUSPEND() {
  return getTokens(myParser::SUSPEND);
}

tree::TerminalNode* myParser::TypeModifierListContext::SUSPEND(size_t i) {
  return getToken(myParser::SUSPEND, i);
}

std::vector<tree::TerminalNode *> myParser::TypeModifierListContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::TypeModifierListContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::TypeModifierListContext::getRuleIndex() const {
  return myParser::RuleTypeModifierList;
}

void myParser::TypeModifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeModifierList(this);
}

void myParser::TypeModifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeModifierList(this);
}

myParser::TypeModifierListContext* myParser::typeModifierList() {
  TypeModifierListContext *_localctx = _tracker.createInstance<TypeModifierListContext>(_ctx, getState());
  enterRule(_localctx, 84, myParser::RuleTypeModifierList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1266); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1266);
              _errHandler->sync(this);
              switch (_input->LA(1)) {
                case myParser::AT:
                case myParser::FILE:
                case myParser::FIELD:
                case myParser::PROPERTY:
                case myParser::GET:
                case myParser::SET:
                case myParser::RECEIVER:
                case myParser::PARAM:
                case myParser::SETPARAM:
                case myParser::DELEGATE:
                case myParser::LabelReference: {
                  setState(1258);
                  annotations();
                  break;
                }

                case myParser::SUSPEND: {
                  setState(1259);
                  match(myParser::SUSPEND);
                  setState(1263);
                  _errHandler->sync(this);
                  _la = _input->LA(1);
                  while (_la == myParser::NL) {
                    setState(1260);
                    match(myParser::NL);
                    setState(1265);
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                  }
                  break;
                }

              default:
                throw NoViableAltException(this);
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1268); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 183, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParenthesizedTypeContext ------------------------------------------------------------------

myParser::ParenthesizedTypeContext::ParenthesizedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ParenthesizedTypeContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::TypeContext* myParser::ParenthesizedTypeContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

tree::TerminalNode* myParser::ParenthesizedTypeContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}


size_t myParser::ParenthesizedTypeContext::getRuleIndex() const {
  return myParser::RuleParenthesizedType;
}

void myParser::ParenthesizedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParenthesizedType(this);
}

void myParser::ParenthesizedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParenthesizedType(this);
}

myParser::ParenthesizedTypeContext* myParser::parenthesizedType() {
  ParenthesizedTypeContext *_localctx = _tracker.createInstance<ParenthesizedTypeContext>(_ctx, getState());
  enterRule(_localctx, 86, myParser::RuleParenthesizedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1270);
    match(myParser::LPAREN);
    setState(1271);
    type();
    setState(1272);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullableTypeContext ------------------------------------------------------------------

myParser::NullableTypeContext::NullableTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::TypeReferenceContext* myParser::NullableTypeContext::typeReference() {
  return getRuleContext<myParser::TypeReferenceContext>(0);
}

myParser::ParenthesizedTypeContext* myParser::NullableTypeContext::parenthesizedType() {
  return getRuleContext<myParser::ParenthesizedTypeContext>(0);
}

std::vector<tree::TerminalNode *> myParser::NullableTypeContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::NullableTypeContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

std::vector<tree::TerminalNode *> myParser::NullableTypeContext::QUEST() {
  return getTokens(myParser::QUEST);
}

tree::TerminalNode* myParser::NullableTypeContext::QUEST(size_t i) {
  return getToken(myParser::QUEST, i);
}


size_t myParser::NullableTypeContext::getRuleIndex() const {
  return myParser::RuleNullableType;
}

void myParser::NullableTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullableType(this);
}

void myParser::NullableTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullableType(this);
}

myParser::NullableTypeContext* myParser::nullableType() {
  NullableTypeContext *_localctx = _tracker.createInstance<NullableTypeContext>(_ctx, getState());
  enterRule(_localctx, 88, myParser::RuleNullableType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1276);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 184, _ctx)) {
    case 1: {
      setState(1274);
      typeReference();
      break;
    }

    case 2: {
      setState(1275);
      parenthesizedType();
      break;
    }

    default:
      break;
    }
    setState(1281);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(1278);
      match(myParser::NL);
      setState(1283);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1285); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1284);
              match(myParser::QUEST);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1287); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 186, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeReferenceContext ------------------------------------------------------------------

myParser::TypeReferenceContext::TypeReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TypeReferenceContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::TypeReferenceContext* myParser::TypeReferenceContext::typeReference() {
  return getRuleContext<myParser::TypeReferenceContext>(0);
}

tree::TerminalNode* myParser::TypeReferenceContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

myParser::UserTypeContext* myParser::TypeReferenceContext::userType() {
  return getRuleContext<myParser::UserTypeContext>(0);
}

tree::TerminalNode* myParser::TypeReferenceContext::DYNAMIC() {
  return getToken(myParser::DYNAMIC, 0);
}


size_t myParser::TypeReferenceContext::getRuleIndex() const {
  return myParser::RuleTypeReference;
}

void myParser::TypeReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeReference(this);
}

void myParser::TypeReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeReference(this);
}

myParser::TypeReferenceContext* myParser::typeReference() {
  TypeReferenceContext *_localctx = _tracker.createInstance<TypeReferenceContext>(_ctx, getState());
  enterRule(_localctx, 90, myParser::RuleTypeReference);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1295);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 187, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1289);
      match(myParser::LPAREN);
      setState(1290);
      typeReference();
      setState(1291);
      match(myParser::RPAREN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1293);
      userType();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1294);
      match(myParser::DYNAMIC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionTypeContext ------------------------------------------------------------------

myParser::FunctionTypeContext::FunctionTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::FunctionTypeParametersContext* myParser::FunctionTypeContext::functionTypeParameters() {
  return getRuleContext<myParser::FunctionTypeParametersContext>(0);
}

tree::TerminalNode* myParser::FunctionTypeContext::ARROW() {
  return getToken(myParser::ARROW, 0);
}

myParser::TypeContext* myParser::FunctionTypeContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

myParser::FunctionTypeReceiverContext* myParser::FunctionTypeContext::functionTypeReceiver() {
  return getRuleContext<myParser::FunctionTypeReceiverContext>(0);
}

tree::TerminalNode* myParser::FunctionTypeContext::DOT() {
  return getToken(myParser::DOT, 0);
}

std::vector<tree::TerminalNode *> myParser::FunctionTypeContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::FunctionTypeContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::FunctionTypeContext::getRuleIndex() const {
  return myParser::RuleFunctionType;
}

void myParser::FunctionTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionType(this);
}

void myParser::FunctionTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionType(this);
}

myParser::FunctionTypeContext* myParser::functionType() {
  FunctionTypeContext *_localctx = _tracker.createInstance<FunctionTypeContext>(_ctx, getState());
  enterRule(_localctx, 92, myParser::RuleFunctionType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1311);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 190, _ctx)) {
    case 1: {
      setState(1297);
      functionTypeReceiver();
      setState(1301);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(1298);
        match(myParser::NL);
        setState(1303);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1304);
      match(myParser::DOT);
      setState(1308);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(1305);
        match(myParser::NL);
        setState(1310);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
    setState(1313);
    functionTypeParameters();
    setState(1317);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(1314);
      match(myParser::NL);
      setState(1319);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1320);
    match(myParser::ARROW);

    setState(1324);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(1321);
      match(myParser::NL);
      setState(1326);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1327);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionTypeReceiverContext ------------------------------------------------------------------

myParser::FunctionTypeReceiverContext::FunctionTypeReceiverContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ParenthesizedTypeContext* myParser::FunctionTypeReceiverContext::parenthesizedType() {
  return getRuleContext<myParser::ParenthesizedTypeContext>(0);
}

myParser::NullableTypeContext* myParser::FunctionTypeReceiverContext::nullableType() {
  return getRuleContext<myParser::NullableTypeContext>(0);
}

myParser::TypeReferenceContext* myParser::FunctionTypeReceiverContext::typeReference() {
  return getRuleContext<myParser::TypeReferenceContext>(0);
}


size_t myParser::FunctionTypeReceiverContext::getRuleIndex() const {
  return myParser::RuleFunctionTypeReceiver;
}

void myParser::FunctionTypeReceiverContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionTypeReceiver(this);
}

void myParser::FunctionTypeReceiverContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionTypeReceiver(this);
}

myParser::FunctionTypeReceiverContext* myParser::functionTypeReceiver() {
  FunctionTypeReceiverContext *_localctx = _tracker.createInstance<FunctionTypeReceiverContext>(_ctx, getState());
  enterRule(_localctx, 94, myParser::RuleFunctionTypeReceiver);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1332);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 193, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1329);
      parenthesizedType();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1330);
      nullableType();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1331);
      typeReference();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserTypeContext ------------------------------------------------------------------

myParser::UserTypeContext::UserTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::SimpleUserTypeContext *> myParser::UserTypeContext::simpleUserType() {
  return getRuleContexts<myParser::SimpleUserTypeContext>();
}

myParser::SimpleUserTypeContext* myParser::UserTypeContext::simpleUserType(size_t i) {
  return getRuleContext<myParser::SimpleUserTypeContext>(i);
}

std::vector<tree::TerminalNode *> myParser::UserTypeContext::DOT() {
  return getTokens(myParser::DOT);
}

tree::TerminalNode* myParser::UserTypeContext::DOT(size_t i) {
  return getToken(myParser::DOT, i);
}

std::vector<tree::TerminalNode *> myParser::UserTypeContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::UserTypeContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::UserTypeContext::getRuleIndex() const {
  return myParser::RuleUserType;
}

void myParser::UserTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserType(this);
}

void myParser::UserTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserType(this);
}

myParser::UserTypeContext* myParser::userType() {
  UserTypeContext *_localctx = _tracker.createInstance<UserTypeContext>(_ctx, getState());
  enterRule(_localctx, 96, myParser::RuleUserType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1334);
    simpleUserType();
    setState(1351);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 196, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1338);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(1335);
          match(myParser::NL);
          setState(1340);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1341);
        match(myParser::DOT);
        setState(1345);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(1342);
          match(myParser::NL);
          setState(1347);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1348);
        simpleUserType(); 
      }
      setState(1353);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 196, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleUserTypeContext ------------------------------------------------------------------

myParser::SimpleUserTypeContext::SimpleUserTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SimpleIdentifierContext* myParser::SimpleUserTypeContext::simpleIdentifier() {
  return getRuleContext<myParser::SimpleIdentifierContext>(0);
}

myParser::TypeArgumentsContext* myParser::SimpleUserTypeContext::typeArguments() {
  return getRuleContext<myParser::TypeArgumentsContext>(0);
}

std::vector<tree::TerminalNode *> myParser::SimpleUserTypeContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::SimpleUserTypeContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::SimpleUserTypeContext::getRuleIndex() const {
  return myParser::RuleSimpleUserType;
}

void myParser::SimpleUserTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleUserType(this);
}

void myParser::SimpleUserTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleUserType(this);
}

myParser::SimpleUserTypeContext* myParser::simpleUserType() {
  SimpleUserTypeContext *_localctx = _tracker.createInstance<SimpleUserTypeContext>(_ctx, getState());
  enterRule(_localctx, 98, myParser::RuleSimpleUserType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1354);
    simpleIdentifier();
    setState(1362);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 198, _ctx)) {
    case 1: {
      setState(1358);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(1355);
        match(myParser::NL);
        setState(1360);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1361);
      typeArguments();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionTypeParametersContext ------------------------------------------------------------------

myParser::FunctionTypeParametersContext::FunctionTypeParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::FunctionTypeParametersContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::FunctionTypeParametersContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

std::vector<myParser::ParameterContext *> myParser::FunctionTypeParametersContext::parameter() {
  return getRuleContexts<myParser::ParameterContext>();
}

myParser::ParameterContext* myParser::FunctionTypeParametersContext::parameter(size_t i) {
  return getRuleContext<myParser::ParameterContext>(i);
}

std::vector<myParser::TypeContext *> myParser::FunctionTypeParametersContext::type() {
  return getRuleContexts<myParser::TypeContext>();
}

myParser::TypeContext* myParser::FunctionTypeParametersContext::type(size_t i) {
  return getRuleContext<myParser::TypeContext>(i);
}

std::vector<tree::TerminalNode *> myParser::FunctionTypeParametersContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::FunctionTypeParametersContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::FunctionTypeParametersContext::getRuleIndex() const {
  return myParser::RuleFunctionTypeParameters;
}

void myParser::FunctionTypeParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionTypeParameters(this);
}

void myParser::FunctionTypeParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionTypeParameters(this);
}

myParser::FunctionTypeParametersContext* myParser::functionTypeParameters() {
  FunctionTypeParametersContext *_localctx = _tracker.createInstance<FunctionTypeParametersContext>(_ctx, getState());
  enterRule(_localctx, 100, myParser::RuleFunctionTypeParameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1364);
    match(myParser::LPAREN);
    setState(1367);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 199, _ctx)) {
    case 1: {
      setState(1365);
      parameter();
      break;
    }

    case 2: {
      setState(1366);
      type();
      break;
    }

    default:
      break;
    }
    setState(1376);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(1369);
      match(myParser::COMMA);
      setState(1372);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx)) {
      case 1: {
        setState(1370);
        parameter();
        break;
      }

      case 2: {
        setState(1371);
        type();
        break;
      }

      default:
        break;
      }
      setState(1378);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1379);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeConstraintsContext ------------------------------------------------------------------

myParser::TypeConstraintsContext::TypeConstraintsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TypeConstraintsContext::WHERE() {
  return getToken(myParser::WHERE, 0);
}

std::vector<myParser::TypeConstraintContext *> myParser::TypeConstraintsContext::typeConstraint() {
  return getRuleContexts<myParser::TypeConstraintContext>();
}

myParser::TypeConstraintContext* myParser::TypeConstraintsContext::typeConstraint(size_t i) {
  return getRuleContext<myParser::TypeConstraintContext>(i);
}

std::vector<tree::TerminalNode *> myParser::TypeConstraintsContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::TypeConstraintsContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

std::vector<tree::TerminalNode *> myParser::TypeConstraintsContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::TypeConstraintsContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::TypeConstraintsContext::getRuleIndex() const {
  return myParser::RuleTypeConstraints;
}

void myParser::TypeConstraintsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeConstraints(this);
}

void myParser::TypeConstraintsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeConstraints(this);
}

myParser::TypeConstraintsContext* myParser::typeConstraints() {
  TypeConstraintsContext *_localctx = _tracker.createInstance<TypeConstraintsContext>(_ctx, getState());
  enterRule(_localctx, 102, myParser::RuleTypeConstraints);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1381);
    match(myParser::WHERE);
    setState(1385);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(1382);
      match(myParser::NL);
      setState(1387);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1388);
    typeConstraint();
    setState(1405);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 205, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1392);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(1389);
          match(myParser::NL);
          setState(1394);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1395);
        match(myParser::COMMA);
        setState(1399);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(1396);
          match(myParser::NL);
          setState(1401);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1402);
        typeConstraint(); 
      }
      setState(1407);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 205, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeConstraintContext ------------------------------------------------------------------

myParser::TypeConstraintContext::TypeConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SimpleIdentifierContext* myParser::TypeConstraintContext::simpleIdentifier() {
  return getRuleContext<myParser::SimpleIdentifierContext>(0);
}

tree::TerminalNode* myParser::TypeConstraintContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::TypeContext* myParser::TypeConstraintContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

std::vector<myParser::AnnotationsContext *> myParser::TypeConstraintContext::annotations() {
  return getRuleContexts<myParser::AnnotationsContext>();
}

myParser::AnnotationsContext* myParser::TypeConstraintContext::annotations(size_t i) {
  return getRuleContext<myParser::AnnotationsContext>(i);
}

std::vector<tree::TerminalNode *> myParser::TypeConstraintContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::TypeConstraintContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::TypeConstraintContext::getRuleIndex() const {
  return myParser::RuleTypeConstraint;
}

void myParser::TypeConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeConstraint(this);
}

void myParser::TypeConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeConstraint(this);
}

myParser::TypeConstraintContext* myParser::typeConstraint() {
  TypeConstraintContext *_localctx = _tracker.createInstance<TypeConstraintContext>(_ctx, getState());
  enterRule(_localctx, 104, myParser::RuleTypeConstraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1411);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::AT

    || _la == myParser::FILE || (((_la - 93) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 93)) & 281474976711631) != 0) {
      setState(1408);
      annotations();
      setState(1413);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1414);
    simpleIdentifier();
    setState(1418);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(1415);
      match(myParser::NL);
      setState(1420);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1421);
    match(myParser::COLON);
    setState(1425);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(1422);
      match(myParser::NL);
      setState(1427);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1428);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContext ------------------------------------------------------------------

myParser::BlockContext::BlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::BlockContext::LCURL() {
  return getToken(myParser::LCURL, 0);
}

myParser::StatementsContext* myParser::BlockContext::statements() {
  return getRuleContext<myParser::StatementsContext>(0);
}

tree::TerminalNode* myParser::BlockContext::RCURL() {
  return getToken(myParser::RCURL, 0);
}


size_t myParser::BlockContext::getRuleIndex() const {
  return myParser::RuleBlock;
}

void myParser::BlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock(this);
}

void myParser::BlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock(this);
}

myParser::BlockContext* myParser::block() {
  BlockContext *_localctx = _tracker.createInstance<BlockContext>(_ctx, getState());
  enterRule(_localctx, 106, myParser::RuleBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1430);
    match(myParser::LCURL);
    setState(1431);
    statements();
    setState(1432);
    match(myParser::RCURL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementsContext ------------------------------------------------------------------

myParser::StatementsContext::StatementsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::AnysemiContext *> myParser::StatementsContext::anysemi() {
  return getRuleContexts<myParser::AnysemiContext>();
}

myParser::AnysemiContext* myParser::StatementsContext::anysemi(size_t i) {
  return getRuleContext<myParser::AnysemiContext>(i);
}

std::vector<myParser::StatementContext *> myParser::StatementsContext::statement() {
  return getRuleContexts<myParser::StatementContext>();
}

myParser::StatementContext* myParser::StatementsContext::statement(size_t i) {
  return getRuleContext<myParser::StatementContext>(i);
}


size_t myParser::StatementsContext::getRuleIndex() const {
  return myParser::RuleStatements;
}

void myParser::StatementsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatements(this);
}

void myParser::StatementsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatements(this);
}

myParser::StatementsContext* myParser::statements() {
  StatementsContext *_localctx = _tracker.createInstance<StatementsContext>(_ctx, getState());
  enterRule(_localctx, 108, myParser::RuleStatements);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1437);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 209, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1434);
        anysemi(); 
      }
      setState(1439);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 209, _ctx);
    }
    setState(1454);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 213, _ctx)) {
    case 1: {
      setState(1440);
      statement();
      setState(1451);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 212, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1442); 
          _errHandler->sync(this);
          alt = 1;
          do {
            switch (alt) {
              case 1: {
                    setState(1441);
                    anysemi();
                    break;
                  }

            default:
              throw NoViableAltException(this);
            }
            setState(1444); 
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 210, _ctx);
          } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
          setState(1447);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 211, _ctx)) {
          case 1: {
            setState(1446);
            statement();
            break;
          }

          default:
            break;
          } 
        }
        setState(1453);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 212, _ctx);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

myParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::DeclarationContext* myParser::StatementContext::declaration() {
  return getRuleContext<myParser::DeclarationContext>(0);
}

myParser::BlockLevelExpressionContext* myParser::StatementContext::blockLevelExpression() {
  return getRuleContext<myParser::BlockLevelExpressionContext>(0);
}


size_t myParser::StatementContext::getRuleIndex() const {
  return myParser::RuleStatement;
}

void myParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void myParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}

myParser::StatementContext* myParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 110, myParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1458);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 214, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1456);
      declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1457);
      blockLevelExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockLevelExpressionContext ------------------------------------------------------------------

myParser::BlockLevelExpressionContext::BlockLevelExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionContext* myParser::BlockLevelExpressionContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

std::vector<myParser::AnnotationsContext *> myParser::BlockLevelExpressionContext::annotations() {
  return getRuleContexts<myParser::AnnotationsContext>();
}

myParser::AnnotationsContext* myParser::BlockLevelExpressionContext::annotations(size_t i) {
  return getRuleContext<myParser::AnnotationsContext>(i);
}

std::vector<tree::TerminalNode *> myParser::BlockLevelExpressionContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::BlockLevelExpressionContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::BlockLevelExpressionContext::getRuleIndex() const {
  return myParser::RuleBlockLevelExpression;
}

void myParser::BlockLevelExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlockLevelExpression(this);
}

void myParser::BlockLevelExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlockLevelExpression(this);
}

myParser::BlockLevelExpressionContext* myParser::blockLevelExpression() {
  BlockLevelExpressionContext *_localctx = _tracker.createInstance<BlockLevelExpressionContext>(_ctx, getState());
  enterRule(_localctx, 112, myParser::RuleBlockLevelExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1463);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 215, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1460);
        annotations(); 
      }
      setState(1465);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 215, _ctx);
    }
    setState(1469);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 216, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1466);
        match(myParser::NL); 
      }
      setState(1471);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 216, _ctx);
    }
    setState(1472);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclarationContext ------------------------------------------------------------------

myParser::DeclarationContext::DeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ClassDeclarationContext* myParser::DeclarationContext::classDeclaration() {
  return getRuleContext<myParser::ClassDeclarationContext>(0);
}

myParser::FunctionDeclarationContext* myParser::DeclarationContext::functionDeclaration() {
  return getRuleContext<myParser::FunctionDeclarationContext>(0);
}

myParser::PropertyDeclarationContext* myParser::DeclarationContext::propertyDeclaration() {
  return getRuleContext<myParser::PropertyDeclarationContext>(0);
}

myParser::TypeAliasContext* myParser::DeclarationContext::typeAlias() {
  return getRuleContext<myParser::TypeAliasContext>(0);
}

std::vector<myParser::LabelDefinitionContext *> myParser::DeclarationContext::labelDefinition() {
  return getRuleContexts<myParser::LabelDefinitionContext>();
}

myParser::LabelDefinitionContext* myParser::DeclarationContext::labelDefinition(size_t i) {
  return getRuleContext<myParser::LabelDefinitionContext>(i);
}


size_t myParser::DeclarationContext::getRuleIndex() const {
  return myParser::RuleDeclaration;
}

void myParser::DeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclaration(this);
}

void myParser::DeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclaration(this);
}

myParser::DeclarationContext* myParser::declaration() {
  DeclarationContext *_localctx = _tracker.createInstance<DeclarationContext>(_ctx, getState());
  enterRule(_localctx, 114, myParser::RuleDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1477);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::LabelDefinition) {
      setState(1474);
      labelDefinition();
      setState(1479);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1484);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 218, _ctx)) {
    case 1: {
      setState(1480);
      classDeclaration();
      break;
    }

    case 2: {
      setState(1481);
      functionDeclaration();
      break;
    }

    case 3: {
      setState(1482);
      propertyDeclaration();
      break;
    }

    case 4: {
      setState(1483);
      typeAlias();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

myParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::DisjunctionContext *> myParser::ExpressionContext::disjunction() {
  return getRuleContexts<myParser::DisjunctionContext>();
}

myParser::DisjunctionContext* myParser::ExpressionContext::disjunction(size_t i) {
  return getRuleContext<myParser::DisjunctionContext>(i);
}

std::vector<myParser::AssignmentOperatorContext *> myParser::ExpressionContext::assignmentOperator() {
  return getRuleContexts<myParser::AssignmentOperatorContext>();
}

myParser::AssignmentOperatorContext* myParser::ExpressionContext::assignmentOperator(size_t i) {
  return getRuleContext<myParser::AssignmentOperatorContext>(i);
}


size_t myParser::ExpressionContext::getRuleIndex() const {
  return myParser::RuleExpression;
}

void myParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void myParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}

myParser::ExpressionContext* myParser::expression() {
  ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, getState());
  enterRule(_localctx, 116, myParser::RuleExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1486);
    disjunction();
    setState(1492);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 219, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1487);
        assignmentOperator();
        setState(1488);
        disjunction(); 
      }
      setState(1494);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 219, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DisjunctionContext ------------------------------------------------------------------

myParser::DisjunctionContext::DisjunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::ConjunctionContext *> myParser::DisjunctionContext::conjunction() {
  return getRuleContexts<myParser::ConjunctionContext>();
}

myParser::ConjunctionContext* myParser::DisjunctionContext::conjunction(size_t i) {
  return getRuleContext<myParser::ConjunctionContext>(i);
}

std::vector<tree::TerminalNode *> myParser::DisjunctionContext::DISJ() {
  return getTokens(myParser::DISJ);
}

tree::TerminalNode* myParser::DisjunctionContext::DISJ(size_t i) {
  return getToken(myParser::DISJ, i);
}

std::vector<tree::TerminalNode *> myParser::DisjunctionContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::DisjunctionContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::DisjunctionContext::getRuleIndex() const {
  return myParser::RuleDisjunction;
}

void myParser::DisjunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDisjunction(this);
}

void myParser::DisjunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDisjunction(this);
}

myParser::DisjunctionContext* myParser::disjunction() {
  DisjunctionContext *_localctx = _tracker.createInstance<DisjunctionContext>(_ctx, getState());
  enterRule(_localctx, 118, myParser::RuleDisjunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1495);
    conjunction();
    setState(1512);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 222, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1499);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(1496);
          match(myParser::NL);
          setState(1501);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1502);
        match(myParser::DISJ);
        setState(1506);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1503);
            match(myParser::NL); 
          }
          setState(1508);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx);
        }
        setState(1509);
        conjunction(); 
      }
      setState(1514);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 222, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConjunctionContext ------------------------------------------------------------------

myParser::ConjunctionContext::ConjunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::EqualityComparisonContext *> myParser::ConjunctionContext::equalityComparison() {
  return getRuleContexts<myParser::EqualityComparisonContext>();
}

myParser::EqualityComparisonContext* myParser::ConjunctionContext::equalityComparison(size_t i) {
  return getRuleContext<myParser::EqualityComparisonContext>(i);
}

std::vector<tree::TerminalNode *> myParser::ConjunctionContext::CONJ() {
  return getTokens(myParser::CONJ);
}

tree::TerminalNode* myParser::ConjunctionContext::CONJ(size_t i) {
  return getToken(myParser::CONJ, i);
}

std::vector<tree::TerminalNode *> myParser::ConjunctionContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::ConjunctionContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::ConjunctionContext::getRuleIndex() const {
  return myParser::RuleConjunction;
}

void myParser::ConjunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConjunction(this);
}

void myParser::ConjunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConjunction(this);
}

myParser::ConjunctionContext* myParser::conjunction() {
  ConjunctionContext *_localctx = _tracker.createInstance<ConjunctionContext>(_ctx, getState());
  enterRule(_localctx, 120, myParser::RuleConjunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1515);
    equalityComparison();
    setState(1532);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 225, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1519);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(1516);
          match(myParser::NL);
          setState(1521);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1522);
        match(myParser::CONJ);
        setState(1526);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 224, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1523);
            match(myParser::NL); 
          }
          setState(1528);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 224, _ctx);
        }
        setState(1529);
        equalityComparison(); 
      }
      setState(1534);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 225, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EqualityComparisonContext ------------------------------------------------------------------

myParser::EqualityComparisonContext::EqualityComparisonContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::ComparisonContext *> myParser::EqualityComparisonContext::comparison() {
  return getRuleContexts<myParser::ComparisonContext>();
}

myParser::ComparisonContext* myParser::EqualityComparisonContext::comparison(size_t i) {
  return getRuleContext<myParser::ComparisonContext>(i);
}

std::vector<myParser::EqualityOperationContext *> myParser::EqualityComparisonContext::equalityOperation() {
  return getRuleContexts<myParser::EqualityOperationContext>();
}

myParser::EqualityOperationContext* myParser::EqualityComparisonContext::equalityOperation(size_t i) {
  return getRuleContext<myParser::EqualityOperationContext>(i);
}

std::vector<tree::TerminalNode *> myParser::EqualityComparisonContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::EqualityComparisonContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::EqualityComparisonContext::getRuleIndex() const {
  return myParser::RuleEqualityComparison;
}

void myParser::EqualityComparisonContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEqualityComparison(this);
}

void myParser::EqualityComparisonContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEqualityComparison(this);
}

myParser::EqualityComparisonContext* myParser::equalityComparison() {
  EqualityComparisonContext *_localctx = _tracker.createInstance<EqualityComparisonContext>(_ctx, getState());
  enterRule(_localctx, 122, myParser::RuleEqualityComparison);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1535);
    comparison();
    setState(1547);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 227, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1536);
        equalityOperation();
        setState(1540);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 226, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1537);
            match(myParser::NL); 
          }
          setState(1542);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 226, _ctx);
        }
        setState(1543);
        comparison(); 
      }
      setState(1549);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 227, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComparisonContext ------------------------------------------------------------------

myParser::ComparisonContext::ComparisonContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::NamedInfixContext *> myParser::ComparisonContext::namedInfix() {
  return getRuleContexts<myParser::NamedInfixContext>();
}

myParser::NamedInfixContext* myParser::ComparisonContext::namedInfix(size_t i) {
  return getRuleContext<myParser::NamedInfixContext>(i);
}

myParser::ComparisonOperatorContext* myParser::ComparisonContext::comparisonOperator() {
  return getRuleContext<myParser::ComparisonOperatorContext>(0);
}

std::vector<tree::TerminalNode *> myParser::ComparisonContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::ComparisonContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::ComparisonContext::getRuleIndex() const {
  return myParser::RuleComparison;
}

void myParser::ComparisonContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparison(this);
}

void myParser::ComparisonContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparison(this);
}

myParser::ComparisonContext* myParser::comparison() {
  ComparisonContext *_localctx = _tracker.createInstance<ComparisonContext>(_ctx, getState());
  enterRule(_localctx, 124, myParser::RuleComparison);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1550);
    namedInfix();
    setState(1560);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 229, _ctx)) {
    case 1: {
      setState(1551);
      comparisonOperator();
      setState(1555);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 228, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1552);
          match(myParser::NL); 
        }
        setState(1557);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 228, _ctx);
      }
      setState(1558);
      namedInfix();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamedInfixContext ------------------------------------------------------------------

myParser::NamedInfixContext::NamedInfixContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::ElvisExpressionContext *> myParser::NamedInfixContext::elvisExpression() {
  return getRuleContexts<myParser::ElvisExpressionContext>();
}

myParser::ElvisExpressionContext* myParser::NamedInfixContext::elvisExpression(size_t i) {
  return getRuleContext<myParser::ElvisExpressionContext>(i);
}

myParser::IsOperatorContext* myParser::NamedInfixContext::isOperator() {
  return getRuleContext<myParser::IsOperatorContext>(0);
}

myParser::TypeContext* myParser::NamedInfixContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

std::vector<myParser::InOperatorContext *> myParser::NamedInfixContext::inOperator() {
  return getRuleContexts<myParser::InOperatorContext>();
}

myParser::InOperatorContext* myParser::NamedInfixContext::inOperator(size_t i) {
  return getRuleContext<myParser::InOperatorContext>(i);
}

std::vector<tree::TerminalNode *> myParser::NamedInfixContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::NamedInfixContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::NamedInfixContext::getRuleIndex() const {
  return myParser::RuleNamedInfix;
}

void myParser::NamedInfixContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamedInfix(this);
}

void myParser::NamedInfixContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamedInfix(this);
}

myParser::NamedInfixContext* myParser::namedInfix() {
  NamedInfixContext *_localctx = _tracker.createInstance<NamedInfixContext>(_ctx, getState());
  enterRule(_localctx, 126, myParser::RuleNamedInfix);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1562);
    elvisExpression();
    setState(1585);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 233, _ctx)) {
    case 1: {
      setState(1572); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(1563);
                inOperator();
                setState(1567);
                _errHandler->sync(this);
                alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 230, _ctx);
                while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
                  if (alt == 1) {
                    setState(1564);
                    match(myParser::NL); 
                  }
                  setState(1569);
                  _errHandler->sync(this);
                  alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 230, _ctx);
                }
                setState(1570);
                elvisExpression();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(1574); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 231, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    case 2: {
      setState(1576);
      isOperator();
      setState(1580);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(1577);
        match(myParser::NL);
        setState(1582);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1583);
      type();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElvisExpressionContext ------------------------------------------------------------------

myParser::ElvisExpressionContext::ElvisExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::InfixFunctionCallContext *> myParser::ElvisExpressionContext::infixFunctionCall() {
  return getRuleContexts<myParser::InfixFunctionCallContext>();
}

myParser::InfixFunctionCallContext* myParser::ElvisExpressionContext::infixFunctionCall(size_t i) {
  return getRuleContext<myParser::InfixFunctionCallContext>(i);
}

std::vector<tree::TerminalNode *> myParser::ElvisExpressionContext::ELVIS() {
  return getTokens(myParser::ELVIS);
}

tree::TerminalNode* myParser::ElvisExpressionContext::ELVIS(size_t i) {
  return getToken(myParser::ELVIS, i);
}

std::vector<tree::TerminalNode *> myParser::ElvisExpressionContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::ElvisExpressionContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::ElvisExpressionContext::getRuleIndex() const {
  return myParser::RuleElvisExpression;
}

void myParser::ElvisExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElvisExpression(this);
}

void myParser::ElvisExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElvisExpression(this);
}

myParser::ElvisExpressionContext* myParser::elvisExpression() {
  ElvisExpressionContext *_localctx = _tracker.createInstance<ElvisExpressionContext>(_ctx, getState());
  enterRule(_localctx, 128, myParser::RuleElvisExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1587);
    infixFunctionCall();
    setState(1604);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 236, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1591);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(1588);
          match(myParser::NL);
          setState(1593);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1594);
        match(myParser::ELVIS);
        setState(1598);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 235, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1595);
            match(myParser::NL); 
          }
          setState(1600);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 235, _ctx);
        }
        setState(1601);
        infixFunctionCall(); 
      }
      setState(1606);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 236, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InfixFunctionCallContext ------------------------------------------------------------------

myParser::InfixFunctionCallContext::InfixFunctionCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::RangeExpressionContext *> myParser::InfixFunctionCallContext::rangeExpression() {
  return getRuleContexts<myParser::RangeExpressionContext>();
}

myParser::RangeExpressionContext* myParser::InfixFunctionCallContext::rangeExpression(size_t i) {
  return getRuleContext<myParser::RangeExpressionContext>(i);
}

std::vector<myParser::SimpleIdentifierContext *> myParser::InfixFunctionCallContext::simpleIdentifier() {
  return getRuleContexts<myParser::SimpleIdentifierContext>();
}

myParser::SimpleIdentifierContext* myParser::InfixFunctionCallContext::simpleIdentifier(size_t i) {
  return getRuleContext<myParser::SimpleIdentifierContext>(i);
}

std::vector<tree::TerminalNode *> myParser::InfixFunctionCallContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::InfixFunctionCallContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::InfixFunctionCallContext::getRuleIndex() const {
  return myParser::RuleInfixFunctionCall;
}

void myParser::InfixFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInfixFunctionCall(this);
}

void myParser::InfixFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInfixFunctionCall(this);
}

myParser::InfixFunctionCallContext* myParser::infixFunctionCall() {
  InfixFunctionCallContext *_localctx = _tracker.createInstance<InfixFunctionCallContext>(_ctx, getState());
  enterRule(_localctx, 130, myParser::RuleInfixFunctionCall);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1607);
    rangeExpression();
    setState(1619);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 238, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1608);
        simpleIdentifier();
        setState(1612);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1609);
            match(myParser::NL); 
          }
          setState(1614);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx);
        }
        setState(1615);
        rangeExpression(); 
      }
      setState(1621);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 238, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RangeExpressionContext ------------------------------------------------------------------

myParser::RangeExpressionContext::RangeExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::AdditiveExpressionContext *> myParser::RangeExpressionContext::additiveExpression() {
  return getRuleContexts<myParser::AdditiveExpressionContext>();
}

myParser::AdditiveExpressionContext* myParser::RangeExpressionContext::additiveExpression(size_t i) {
  return getRuleContext<myParser::AdditiveExpressionContext>(i);
}

std::vector<tree::TerminalNode *> myParser::RangeExpressionContext::RANGE() {
  return getTokens(myParser::RANGE);
}

tree::TerminalNode* myParser::RangeExpressionContext::RANGE(size_t i) {
  return getToken(myParser::RANGE, i);
}

std::vector<tree::TerminalNode *> myParser::RangeExpressionContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::RangeExpressionContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::RangeExpressionContext::getRuleIndex() const {
  return myParser::RuleRangeExpression;
}

void myParser::RangeExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRangeExpression(this);
}

void myParser::RangeExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRangeExpression(this);
}

myParser::RangeExpressionContext* myParser::rangeExpression() {
  RangeExpressionContext *_localctx = _tracker.createInstance<RangeExpressionContext>(_ctx, getState());
  enterRule(_localctx, 132, myParser::RuleRangeExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1622);
    additiveExpression();
    setState(1633);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 240, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1623);
        match(myParser::RANGE);
        setState(1627);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 239, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1624);
            match(myParser::NL); 
          }
          setState(1629);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 239, _ctx);
        }
        setState(1630);
        additiveExpression(); 
      }
      setState(1635);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 240, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AdditiveExpressionContext ------------------------------------------------------------------

myParser::AdditiveExpressionContext::AdditiveExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::MultiplicativeExpressionContext *> myParser::AdditiveExpressionContext::multiplicativeExpression() {
  return getRuleContexts<myParser::MultiplicativeExpressionContext>();
}

myParser::MultiplicativeExpressionContext* myParser::AdditiveExpressionContext::multiplicativeExpression(size_t i) {
  return getRuleContext<myParser::MultiplicativeExpressionContext>(i);
}

std::vector<myParser::AdditiveOperatorContext *> myParser::AdditiveExpressionContext::additiveOperator() {
  return getRuleContexts<myParser::AdditiveOperatorContext>();
}

myParser::AdditiveOperatorContext* myParser::AdditiveExpressionContext::additiveOperator(size_t i) {
  return getRuleContext<myParser::AdditiveOperatorContext>(i);
}

std::vector<tree::TerminalNode *> myParser::AdditiveExpressionContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::AdditiveExpressionContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::AdditiveExpressionContext::getRuleIndex() const {
  return myParser::RuleAdditiveExpression;
}

void myParser::AdditiveExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAdditiveExpression(this);
}

void myParser::AdditiveExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAdditiveExpression(this);
}

myParser::AdditiveExpressionContext* myParser::additiveExpression() {
  AdditiveExpressionContext *_localctx = _tracker.createInstance<AdditiveExpressionContext>(_ctx, getState());
  enterRule(_localctx, 134, myParser::RuleAdditiveExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1636);
    multiplicativeExpression();
    setState(1648);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1637);
        additiveOperator();
        setState(1641);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 241, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1638);
            match(myParser::NL); 
          }
          setState(1643);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 241, _ctx);
        }
        setState(1644);
        multiplicativeExpression(); 
      }
      setState(1650);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultiplicativeExpressionContext ------------------------------------------------------------------

myParser::MultiplicativeExpressionContext::MultiplicativeExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::TypeRHSContext *> myParser::MultiplicativeExpressionContext::typeRHS() {
  return getRuleContexts<myParser::TypeRHSContext>();
}

myParser::TypeRHSContext* myParser::MultiplicativeExpressionContext::typeRHS(size_t i) {
  return getRuleContext<myParser::TypeRHSContext>(i);
}

std::vector<myParser::MultiplicativeOperationContext *> myParser::MultiplicativeExpressionContext::multiplicativeOperation() {
  return getRuleContexts<myParser::MultiplicativeOperationContext>();
}

myParser::MultiplicativeOperationContext* myParser::MultiplicativeExpressionContext::multiplicativeOperation(size_t i) {
  return getRuleContext<myParser::MultiplicativeOperationContext>(i);
}

std::vector<tree::TerminalNode *> myParser::MultiplicativeExpressionContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::MultiplicativeExpressionContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::MultiplicativeExpressionContext::getRuleIndex() const {
  return myParser::RuleMultiplicativeExpression;
}

void myParser::MultiplicativeExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiplicativeExpression(this);
}

void myParser::MultiplicativeExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiplicativeExpression(this);
}

myParser::MultiplicativeExpressionContext* myParser::multiplicativeExpression() {
  MultiplicativeExpressionContext *_localctx = _tracker.createInstance<MultiplicativeExpressionContext>(_ctx, getState());
  enterRule(_localctx, 136, myParser::RuleMultiplicativeExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1651);
    typeRHS();
    setState(1663);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 244, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1652);
        multiplicativeOperation();
        setState(1656);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 243, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1653);
            match(myParser::NL); 
          }
          setState(1658);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 243, _ctx);
        }
        setState(1659);
        typeRHS(); 
      }
      setState(1665);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 244, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeRHSContext ------------------------------------------------------------------

myParser::TypeRHSContext::TypeRHSContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::PrefixUnaryExpressionContext *> myParser::TypeRHSContext::prefixUnaryExpression() {
  return getRuleContexts<myParser::PrefixUnaryExpressionContext>();
}

myParser::PrefixUnaryExpressionContext* myParser::TypeRHSContext::prefixUnaryExpression(size_t i) {
  return getRuleContext<myParser::PrefixUnaryExpressionContext>(i);
}

std::vector<myParser::TypeOperationContext *> myParser::TypeRHSContext::typeOperation() {
  return getRuleContexts<myParser::TypeOperationContext>();
}

myParser::TypeOperationContext* myParser::TypeRHSContext::typeOperation(size_t i) {
  return getRuleContext<myParser::TypeOperationContext>(i);
}

std::vector<tree::TerminalNode *> myParser::TypeRHSContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::TypeRHSContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::TypeRHSContext::getRuleIndex() const {
  return myParser::RuleTypeRHS;
}

void myParser::TypeRHSContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeRHS(this);
}

void myParser::TypeRHSContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeRHS(this);
}

myParser::TypeRHSContext* myParser::typeRHS() {
  TypeRHSContext *_localctx = _tracker.createInstance<TypeRHSContext>(_ctx, getState());
  enterRule(_localctx, 138, myParser::RuleTypeRHS);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1666);
    prefixUnaryExpression();
    setState(1678);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 246, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1670);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(1667);
          match(myParser::NL);
          setState(1672);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1673);
        typeOperation();
        setState(1674);
        prefixUnaryExpression(); 
      }
      setState(1680);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 246, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrefixUnaryExpressionContext ------------------------------------------------------------------

myParser::PrefixUnaryExpressionContext::PrefixUnaryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::PostfixUnaryExpressionContext* myParser::PrefixUnaryExpressionContext::postfixUnaryExpression() {
  return getRuleContext<myParser::PostfixUnaryExpressionContext>(0);
}

std::vector<myParser::PrefixUnaryOperationContext *> myParser::PrefixUnaryExpressionContext::prefixUnaryOperation() {
  return getRuleContexts<myParser::PrefixUnaryOperationContext>();
}

myParser::PrefixUnaryOperationContext* myParser::PrefixUnaryExpressionContext::prefixUnaryOperation(size_t i) {
  return getRuleContext<myParser::PrefixUnaryOperationContext>(i);
}


size_t myParser::PrefixUnaryExpressionContext::getRuleIndex() const {
  return myParser::RulePrefixUnaryExpression;
}

void myParser::PrefixUnaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrefixUnaryExpression(this);
}

void myParser::PrefixUnaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrefixUnaryExpression(this);
}

myParser::PrefixUnaryExpressionContext* myParser::prefixUnaryExpression() {
  PrefixUnaryExpressionContext *_localctx = _tracker.createInstance<PrefixUnaryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 140, myParser::RulePrefixUnaryExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1684);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 247, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1681);
        prefixUnaryOperation(); 
      }
      setState(1686);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 247, _ctx);
    }
    setState(1687);
    postfixUnaryExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PostfixUnaryExpressionContext ------------------------------------------------------------------

myParser::PostfixUnaryExpressionContext::PostfixUnaryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::AtomicExpressionContext* myParser::PostfixUnaryExpressionContext::atomicExpression() {
  return getRuleContext<myParser::AtomicExpressionContext>(0);
}

myParser::CallableReferenceContext* myParser::PostfixUnaryExpressionContext::callableReference() {
  return getRuleContext<myParser::CallableReferenceContext>(0);
}

std::vector<myParser::PostfixUnaryOperationContext *> myParser::PostfixUnaryExpressionContext::postfixUnaryOperation() {
  return getRuleContexts<myParser::PostfixUnaryOperationContext>();
}

myParser::PostfixUnaryOperationContext* myParser::PostfixUnaryExpressionContext::postfixUnaryOperation(size_t i) {
  return getRuleContext<myParser::PostfixUnaryOperationContext>(i);
}


size_t myParser::PostfixUnaryExpressionContext::getRuleIndex() const {
  return myParser::RulePostfixUnaryExpression;
}

void myParser::PostfixUnaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostfixUnaryExpression(this);
}

void myParser::PostfixUnaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostfixUnaryExpression(this);
}

myParser::PostfixUnaryExpressionContext* myParser::postfixUnaryExpression() {
  PostfixUnaryExpressionContext *_localctx = _tracker.createInstance<PostfixUnaryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 142, myParser::RulePostfixUnaryExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1691);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 248, _ctx)) {
    case 1: {
      setState(1689);
      atomicExpression();
      break;
    }

    case 2: {
      setState(1690);
      callableReference();
      break;
    }

    default:
      break;
    }
    setState(1696);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 249, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1693);
        postfixUnaryOperation(); 
      }
      setState(1698);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 249, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AtomicExpressionContext ------------------------------------------------------------------

myParser::AtomicExpressionContext::AtomicExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ParenthesizedExpressionContext* myParser::AtomicExpressionContext::parenthesizedExpression() {
  return getRuleContext<myParser::ParenthesizedExpressionContext>(0);
}

myParser::LiteralConstantContext* myParser::AtomicExpressionContext::literalConstant() {
  return getRuleContext<myParser::LiteralConstantContext>(0);
}

myParser::FunctionLiteralContext* myParser::AtomicExpressionContext::functionLiteral() {
  return getRuleContext<myParser::FunctionLiteralContext>(0);
}

myParser::ThisExpressionContext* myParser::AtomicExpressionContext::thisExpression() {
  return getRuleContext<myParser::ThisExpressionContext>(0);
}

myParser::SuperExpressionContext* myParser::AtomicExpressionContext::superExpression() {
  return getRuleContext<myParser::SuperExpressionContext>(0);
}

myParser::ConditionalExpressionContext* myParser::AtomicExpressionContext::conditionalExpression() {
  return getRuleContext<myParser::ConditionalExpressionContext>(0);
}

myParser::TryExpressionContext* myParser::AtomicExpressionContext::tryExpression() {
  return getRuleContext<myParser::TryExpressionContext>(0);
}

myParser::ObjectLiteralContext* myParser::AtomicExpressionContext::objectLiteral() {
  return getRuleContext<myParser::ObjectLiteralContext>(0);
}

myParser::JumpExpressionContext* myParser::AtomicExpressionContext::jumpExpression() {
  return getRuleContext<myParser::JumpExpressionContext>(0);
}

myParser::LoopExpressionContext* myParser::AtomicExpressionContext::loopExpression() {
  return getRuleContext<myParser::LoopExpressionContext>(0);
}

myParser::CollectionLiteralContext* myParser::AtomicExpressionContext::collectionLiteral() {
  return getRuleContext<myParser::CollectionLiteralContext>(0);
}

myParser::SimpleIdentifierContext* myParser::AtomicExpressionContext::simpleIdentifier() {
  return getRuleContext<myParser::SimpleIdentifierContext>(0);
}


size_t myParser::AtomicExpressionContext::getRuleIndex() const {
  return myParser::RuleAtomicExpression;
}

void myParser::AtomicExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtomicExpression(this);
}

void myParser::AtomicExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtomicExpression(this);
}

myParser::AtomicExpressionContext* myParser::atomicExpression() {
  AtomicExpressionContext *_localctx = _tracker.createInstance<AtomicExpressionContext>(_ctx, getState());
  enterRule(_localctx, 144, myParser::RuleAtomicExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1711);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::LPAREN: {
        enterOuterAlt(_localctx, 1);
        setState(1699);
        parenthesizedExpression();
        break;
      }

      case myParser::QUOTE_OPEN:
      case myParser::TRIPLE_QUOTE_OPEN:
      case myParser::RealLiteral:
      case myParser::LongLiteral:
      case myParser::IntegerLiteral:
      case myParser::HexLiteral:
      case myParser::BinLiteral:
      case myParser::BooleanLiteral:
      case myParser::NullLiteral:
      case myParser::CharacterLiteral: {
        enterOuterAlt(_localctx, 2);
        setState(1700);
        literalConstant();
        break;
      }

      case myParser::LCURL:
      case myParser::AT:
      case myParser::FILE:
      case myParser::FIELD:
      case myParser::PROPERTY:
      case myParser::GET:
      case myParser::SET:
      case myParser::RECEIVER:
      case myParser::PARAM:
      case myParser::SETPARAM:
      case myParser::DELEGATE:
      case myParser::LabelReference: {
        enterOuterAlt(_localctx, 3);
        setState(1701);
        functionLiteral();
        break;
      }

      case myParser::THIS: {
        enterOuterAlt(_localctx, 4);
        setState(1702);
        thisExpression();
        break;
      }

      case myParser::SUPER: {
        enterOuterAlt(_localctx, 5);
        setState(1703);
        superExpression();
        break;
      }

      case myParser::IF:
      case myParser::WHEN: {
        enterOuterAlt(_localctx, 6);
        setState(1704);
        conditionalExpression();
        break;
      }

      case myParser::TRY: {
        enterOuterAlt(_localctx, 7);
        setState(1705);
        tryExpression();
        break;
      }

      case myParser::OBJECT: {
        enterOuterAlt(_localctx, 8);
        setState(1706);
        objectLiteral();
        break;
      }

      case myParser::RETURN_AT:
      case myParser::CONTINUE_AT:
      case myParser::BREAK_AT:
      case myParser::THROW:
      case myParser::RETURN:
      case myParser::CONTINUE:
      case myParser::BREAK: {
        enterOuterAlt(_localctx, 9);
        setState(1707);
        jumpExpression();
        break;
      }

      case myParser::FOR:
      case myParser::DO:
      case myParser::WHILE: {
        enterOuterAlt(_localctx, 10);
        setState(1708);
        loopExpression();
        break;
      }

      case myParser::LSQUARE: {
        enterOuterAlt(_localctx, 11);
        setState(1709);
        collectionLiteral();
        break;
      }

      case myParser::IMPORT:
      case myParser::CONSTRUCTOR:
      case myParser::BY:
      case myParser::COMPANION:
      case myParser::INIT:
      case myParser::WHERE:
      case myParser::CATCH:
      case myParser::FINALLY:
      case myParser::OUT:
      case myParser::GETTER:
      case myParser::SETTER:
      case myParser::DYNAMIC:
      case myParser::PUBLIC:
      case myParser::PRIVATE:
      case myParser::PROTECTED:
      case myParser::INTERNAL:
      case myParser::ENUM:
      case myParser::SEALED:
      case myParser::ANNOTATION:
      case myParser::DATA:
      case myParser::INNER:
      case myParser::TAILREC:
      case myParser::OPERATOR:
      case myParser::INLINE:
      case myParser::INFIX:
      case myParser::EXTERNAL:
      case myParser::SUSPEND:
      case myParser::OVERRIDE:
      case myParser::ABSTRACT:
      case myParser::FINAL:
      case myParser::OPEN:
      case myParser::CONST:
      case myParser::LATEINIT:
      case myParser::VARARG:
      case myParser::NOINLINE:
      case myParser::CROSSINLINE:
      case myParser::REIFIED:
      case myParser::Identifier: {
        enterOuterAlt(_localctx, 12);
        setState(1710);
        simpleIdentifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParenthesizedExpressionContext ------------------------------------------------------------------

myParser::ParenthesizedExpressionContext::ParenthesizedExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ParenthesizedExpressionContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::ExpressionContext* myParser::ParenthesizedExpressionContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

tree::TerminalNode* myParser::ParenthesizedExpressionContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}


size_t myParser::ParenthesizedExpressionContext::getRuleIndex() const {
  return myParser::RuleParenthesizedExpression;
}

void myParser::ParenthesizedExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParenthesizedExpression(this);
}

void myParser::ParenthesizedExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParenthesizedExpression(this);
}

myParser::ParenthesizedExpressionContext* myParser::parenthesizedExpression() {
  ParenthesizedExpressionContext *_localctx = _tracker.createInstance<ParenthesizedExpressionContext>(_ctx, getState());
  enterRule(_localctx, 146, myParser::RuleParenthesizedExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1713);
    match(myParser::LPAREN);
    setState(1714);
    expression();
    setState(1715);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CallSuffixContext ------------------------------------------------------------------

myParser::CallSuffixContext::CallSuffixContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::TypeArgumentsContext* myParser::CallSuffixContext::typeArguments() {
  return getRuleContext<myParser::TypeArgumentsContext>(0);
}

myParser::ValueArgumentsContext* myParser::CallSuffixContext::valueArguments() {
  return getRuleContext<myParser::ValueArgumentsContext>(0);
}

std::vector<myParser::AnnotatedLambdaContext *> myParser::CallSuffixContext::annotatedLambda() {
  return getRuleContexts<myParser::AnnotatedLambdaContext>();
}

myParser::AnnotatedLambdaContext* myParser::CallSuffixContext::annotatedLambda(size_t i) {
  return getRuleContext<myParser::AnnotatedLambdaContext>(i);
}


size_t myParser::CallSuffixContext::getRuleIndex() const {
  return myParser::RuleCallSuffix;
}

void myParser::CallSuffixContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCallSuffix(this);
}

void myParser::CallSuffixContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCallSuffix(this);
}

myParser::CallSuffixContext* myParser::callSuffix() {
  CallSuffixContext *_localctx = _tracker.createInstance<CallSuffixContext>(_ctx, getState());
  enterRule(_localctx, 148, myParser::RuleCallSuffix);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1739);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::LANGLE: {
        enterOuterAlt(_localctx, 1);
        setState(1717);
        typeArguments();
        setState(1719);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 251, _ctx)) {
        case 1: {
          setState(1718);
          valueArguments();
          break;
        }

        default:
          break;
        }
        setState(1724);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 252, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1721);
            annotatedLambda(); 
          }
          setState(1726);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 252, _ctx);
        }
        break;
      }

      case myParser::LPAREN: {
        enterOuterAlt(_localctx, 2);
        setState(1727);
        valueArguments();
        setState(1731);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 253, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1728);
            annotatedLambda(); 
          }
          setState(1733);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 253, _ctx);
        }
        break;
      }

      case myParser::NL:
      case myParser::LCURL:
      case myParser::AT:
      case myParser::FILE:
      case myParser::IMPORT:
      case myParser::CONSTRUCTOR:
      case myParser::BY:
      case myParser::COMPANION:
      case myParser::INIT:
      case myParser::WHERE:
      case myParser::CATCH:
      case myParser::FINALLY:
      case myParser::OUT:
      case myParser::FIELD:
      case myParser::PROPERTY:
      case myParser::GET:
      case myParser::SET:
      case myParser::GETTER:
      case myParser::SETTER:
      case myParser::RECEIVER:
      case myParser::PARAM:
      case myParser::SETPARAM:
      case myParser::DELEGATE:
      case myParser::DYNAMIC:
      case myParser::PUBLIC:
      case myParser::PRIVATE:
      case myParser::PROTECTED:
      case myParser::INTERNAL:
      case myParser::ENUM:
      case myParser::SEALED:
      case myParser::ANNOTATION:
      case myParser::DATA:
      case myParser::INNER:
      case myParser::TAILREC:
      case myParser::OPERATOR:
      case myParser::INLINE:
      case myParser::INFIX:
      case myParser::EXTERNAL:
      case myParser::SUSPEND:
      case myParser::OVERRIDE:
      case myParser::ABSTRACT:
      case myParser::FINAL:
      case myParser::OPEN:
      case myParser::CONST:
      case myParser::LATEINIT:
      case myParser::VARARG:
      case myParser::NOINLINE:
      case myParser::CROSSINLINE:
      case myParser::REIFIED:
      case myParser::Identifier:
      case myParser::LabelReference:
      case myParser::LabelDefinition: {
        enterOuterAlt(_localctx, 3);
        setState(1735); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(1734);
                  annotatedLambda();
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(1737); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 254, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnnotatedLambdaContext ------------------------------------------------------------------

myParser::AnnotatedLambdaContext::AnnotatedLambdaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::FunctionLiteralContext* myParser::AnnotatedLambdaContext::functionLiteral() {
  return getRuleContext<myParser::FunctionLiteralContext>(0);
}

std::vector<myParser::UnescapedAnnotationContext *> myParser::AnnotatedLambdaContext::unescapedAnnotation() {
  return getRuleContexts<myParser::UnescapedAnnotationContext>();
}

myParser::UnescapedAnnotationContext* myParser::AnnotatedLambdaContext::unescapedAnnotation(size_t i) {
  return getRuleContext<myParser::UnescapedAnnotationContext>(i);
}

tree::TerminalNode* myParser::AnnotatedLambdaContext::LabelDefinition() {
  return getToken(myParser::LabelDefinition, 0);
}

std::vector<tree::TerminalNode *> myParser::AnnotatedLambdaContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::AnnotatedLambdaContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::AnnotatedLambdaContext::getRuleIndex() const {
  return myParser::RuleAnnotatedLambda;
}

void myParser::AnnotatedLambdaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnnotatedLambda(this);
}

void myParser::AnnotatedLambdaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnnotatedLambda(this);
}

myParser::AnnotatedLambdaContext* myParser::annotatedLambda() {
  AnnotatedLambdaContext *_localctx = _tracker.createInstance<AnnotatedLambdaContext>(_ctx, getState());
  enterRule(_localctx, 150, myParser::RuleAnnotatedLambda);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1744);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la - 58) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 58)) & -33517921595647) != 0 || (((_la - 122) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 122)) & 262271) != 0) {
      setState(1741);
      unescapedAnnotation();
      setState(1746);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1748);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LabelDefinition) {
      setState(1747);
      match(myParser::LabelDefinition);
    }
    setState(1753);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(1750);
      match(myParser::NL);
      setState(1755);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1756);
    functionLiteral();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayAccessContext ------------------------------------------------------------------

myParser::ArrayAccessContext::ArrayAccessContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ArrayAccessContext::LSQUARE() {
  return getToken(myParser::LSQUARE, 0);
}

tree::TerminalNode* myParser::ArrayAccessContext::RSQUARE() {
  return getToken(myParser::RSQUARE, 0);
}

std::vector<myParser::ExpressionContext *> myParser::ArrayAccessContext::expression() {
  return getRuleContexts<myParser::ExpressionContext>();
}

myParser::ExpressionContext* myParser::ArrayAccessContext::expression(size_t i) {
  return getRuleContext<myParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> myParser::ArrayAccessContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::ArrayAccessContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::ArrayAccessContext::getRuleIndex() const {
  return myParser::RuleArrayAccess;
}

void myParser::ArrayAccessContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayAccess(this);
}

void myParser::ArrayAccessContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayAccess(this);
}

myParser::ArrayAccessContext* myParser::arrayAccess() {
  ArrayAccessContext *_localctx = _tracker.createInstance<ArrayAccessContext>(_ctx, getState());
  enterRule(_localctx, 152, myParser::RuleArrayAccess);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1758);
    match(myParser::LSQUARE);
    setState(1767);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 5035025689090992672) != 0 || (((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & -65012289) != 0 || (((_la - 130) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 130)) & 24563) != 0) {
      setState(1759);
      expression();
      setState(1764);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::COMMA) {
        setState(1760);
        match(myParser::COMMA);
        setState(1761);
        expression();
        setState(1766);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1769);
    match(myParser::RSQUARE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueArgumentsContext ------------------------------------------------------------------

myParser::ValueArgumentsContext::ValueArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ValueArgumentsContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::ValueArgumentsContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

std::vector<myParser::ValueArgumentContext *> myParser::ValueArgumentsContext::valueArgument() {
  return getRuleContexts<myParser::ValueArgumentContext>();
}

myParser::ValueArgumentContext* myParser::ValueArgumentsContext::valueArgument(size_t i) {
  return getRuleContext<myParser::ValueArgumentContext>(i);
}

std::vector<tree::TerminalNode *> myParser::ValueArgumentsContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::ValueArgumentsContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::ValueArgumentsContext::getRuleIndex() const {
  return myParser::RuleValueArguments;
}

void myParser::ValueArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueArguments(this);
}

void myParser::ValueArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueArguments(this);
}

myParser::ValueArgumentsContext* myParser::valueArguments() {
  ValueArgumentsContext *_localctx = _tracker.createInstance<ValueArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 154, myParser::RuleValueArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1771);
    match(myParser::LPAREN);
    setState(1780);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 5035025689091025440) != 0 || (((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & -65012289) != 0 || (((_la - 130) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 130)) & 24563) != 0) {
      setState(1772);
      valueArgument();
      setState(1777);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::COMMA) {
        setState(1773);
        match(myParser::COMMA);
        setState(1774);
        valueArgument();
        setState(1779);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1782);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeArgumentsContext ------------------------------------------------------------------

myParser::TypeArgumentsContext::TypeArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TypeArgumentsContext::LANGLE() {
  return getToken(myParser::LANGLE, 0);
}

std::vector<myParser::TypeProjectionContext *> myParser::TypeArgumentsContext::typeProjection() {
  return getRuleContexts<myParser::TypeProjectionContext>();
}

myParser::TypeProjectionContext* myParser::TypeArgumentsContext::typeProjection(size_t i) {
  return getRuleContext<myParser::TypeProjectionContext>(i);
}

tree::TerminalNode* myParser::TypeArgumentsContext::RANGLE() {
  return getToken(myParser::RANGLE, 0);
}

std::vector<tree::TerminalNode *> myParser::TypeArgumentsContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::TypeArgumentsContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

std::vector<tree::TerminalNode *> myParser::TypeArgumentsContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::TypeArgumentsContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::TypeArgumentsContext::getRuleIndex() const {
  return myParser::RuleTypeArguments;
}

void myParser::TypeArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeArguments(this);
}

void myParser::TypeArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeArguments(this);
}

myParser::TypeArgumentsContext* myParser::typeArguments() {
  TypeArgumentsContext *_localctx = _tracker.createInstance<TypeArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 156, myParser::RuleTypeArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1784);
    match(myParser::LANGLE);
    setState(1788);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(1785);
      match(myParser::NL);
      setState(1790);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1791);
    typeProjection();
    setState(1802);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 265, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1795);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(1792);
          match(myParser::NL);
          setState(1797);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1798);
        match(myParser::COMMA);
        setState(1799);
        typeProjection(); 
      }
      setState(1804);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 265, _ctx);
    }
    setState(1808);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(1805);
      match(myParser::NL);
      setState(1810);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1811);
    match(myParser::RANGLE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeProjectionContext ------------------------------------------------------------------

myParser::TypeProjectionContext::TypeProjectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::TypeContext* myParser::TypeProjectionContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

myParser::TypeProjectionModifierListContext* myParser::TypeProjectionContext::typeProjectionModifierList() {
  return getRuleContext<myParser::TypeProjectionModifierListContext>(0);
}

tree::TerminalNode* myParser::TypeProjectionContext::MULT() {
  return getToken(myParser::MULT, 0);
}


size_t myParser::TypeProjectionContext::getRuleIndex() const {
  return myParser::RuleTypeProjection;
}

void myParser::TypeProjectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeProjection(this);
}

void myParser::TypeProjectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeProjection(this);
}

myParser::TypeProjectionContext* myParser::typeProjection() {
  TypeProjectionContext *_localctx = _tracker.createInstance<TypeProjectionContext>(_ctx, getState());
  enterRule(_localctx, 158, myParser::RuleTypeProjection);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1818);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::LPAREN:
      case myParser::AT:
      case myParser::FILE:
      case myParser::IMPORT:
      case myParser::CONSTRUCTOR:
      case myParser::BY:
      case myParser::COMPANION:
      case myParser::INIT:
      case myParser::WHERE:
      case myParser::CATCH:
      case myParser::FINALLY:
      case myParser::IN:
      case myParser::OUT:
      case myParser::FIELD:
      case myParser::PROPERTY:
      case myParser::GET:
      case myParser::SET:
      case myParser::GETTER:
      case myParser::SETTER:
      case myParser::RECEIVER:
      case myParser::PARAM:
      case myParser::SETPARAM:
      case myParser::DELEGATE:
      case myParser::DYNAMIC:
      case myParser::PUBLIC:
      case myParser::PRIVATE:
      case myParser::PROTECTED:
      case myParser::INTERNAL:
      case myParser::ENUM:
      case myParser::SEALED:
      case myParser::ANNOTATION:
      case myParser::DATA:
      case myParser::INNER:
      case myParser::TAILREC:
      case myParser::OPERATOR:
      case myParser::INLINE:
      case myParser::INFIX:
      case myParser::EXTERNAL:
      case myParser::SUSPEND:
      case myParser::OVERRIDE:
      case myParser::ABSTRACT:
      case myParser::FINAL:
      case myParser::OPEN:
      case myParser::CONST:
      case myParser::LATEINIT:
      case myParser::VARARG:
      case myParser::NOINLINE:
      case myParser::CROSSINLINE:
      case myParser::REIFIED:
      case myParser::Identifier:
      case myParser::LabelReference: {
        enterOuterAlt(_localctx, 1);
        setState(1814);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 267, _ctx)) {
        case 1: {
          setState(1813);
          typeProjectionModifierList();
          break;
        }

        default:
          break;
        }
        setState(1816);
        type();
        break;
      }

      case myParser::MULT: {
        enterOuterAlt(_localctx, 2);
        setState(1817);
        match(myParser::MULT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeProjectionModifierListContext ------------------------------------------------------------------

myParser::TypeProjectionModifierListContext::TypeProjectionModifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::VarianceAnnotationContext *> myParser::TypeProjectionModifierListContext::varianceAnnotation() {
  return getRuleContexts<myParser::VarianceAnnotationContext>();
}

myParser::VarianceAnnotationContext* myParser::TypeProjectionModifierListContext::varianceAnnotation(size_t i) {
  return getRuleContext<myParser::VarianceAnnotationContext>(i);
}


size_t myParser::TypeProjectionModifierListContext::getRuleIndex() const {
  return myParser::RuleTypeProjectionModifierList;
}

void myParser::TypeProjectionModifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeProjectionModifierList(this);
}

void myParser::TypeProjectionModifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeProjectionModifierList(this);
}

myParser::TypeProjectionModifierListContext* myParser::typeProjectionModifierList() {
  TypeProjectionModifierListContext *_localctx = _tracker.createInstance<TypeProjectionModifierListContext>(_ctx, getState());
  enterRule(_localctx, 160, myParser::RuleTypeProjectionModifierList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1821); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1820);
              varianceAnnotation();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1823); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 269, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueArgumentContext ------------------------------------------------------------------

myParser::ValueArgumentContext::ValueArgumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionContext* myParser::ValueArgumentContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

myParser::SimpleIdentifierContext* myParser::ValueArgumentContext::simpleIdentifier() {
  return getRuleContext<myParser::SimpleIdentifierContext>(0);
}

tree::TerminalNode* myParser::ValueArgumentContext::ASSIGNMENT() {
  return getToken(myParser::ASSIGNMENT, 0);
}

tree::TerminalNode* myParser::ValueArgumentContext::MULT() {
  return getToken(myParser::MULT, 0);
}

std::vector<tree::TerminalNode *> myParser::ValueArgumentContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::ValueArgumentContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::ValueArgumentContext::getRuleIndex() const {
  return myParser::RuleValueArgument;
}

void myParser::ValueArgumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueArgument(this);
}

void myParser::ValueArgumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueArgument(this);
}

myParser::ValueArgumentContext* myParser::valueArgument() {
  ValueArgumentContext *_localctx = _tracker.createInstance<ValueArgumentContext>(_ctx, getState());
  enterRule(_localctx, 162, myParser::RuleValueArgument);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1839);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 272, _ctx)) {
    case 1: {
      setState(1825);
      simpleIdentifier();
      setState(1829);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(1826);
        match(myParser::NL);
        setState(1831);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1832);
      match(myParser::ASSIGNMENT);
      setState(1836);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 271, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1833);
          match(myParser::NL); 
        }
        setState(1838);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 271, _ctx);
      }
      break;
    }

    default:
      break;
    }
    setState(1842);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::MULT) {
      setState(1841);
      match(myParser::MULT);
    }
    setState(1847);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 274, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1844);
        match(myParser::NL); 
      }
      setState(1849);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 274, _ctx);
    }
    setState(1850);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralConstantContext ------------------------------------------------------------------

myParser::LiteralConstantContext::LiteralConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::LiteralConstantContext::BooleanLiteral() {
  return getToken(myParser::BooleanLiteral, 0);
}

tree::TerminalNode* myParser::LiteralConstantContext::IntegerLiteral() {
  return getToken(myParser::IntegerLiteral, 0);
}

myParser::StringLiteralContext* myParser::LiteralConstantContext::stringLiteral() {
  return getRuleContext<myParser::StringLiteralContext>(0);
}

tree::TerminalNode* myParser::LiteralConstantContext::HexLiteral() {
  return getToken(myParser::HexLiteral, 0);
}

tree::TerminalNode* myParser::LiteralConstantContext::BinLiteral() {
  return getToken(myParser::BinLiteral, 0);
}

tree::TerminalNode* myParser::LiteralConstantContext::CharacterLiteral() {
  return getToken(myParser::CharacterLiteral, 0);
}

tree::TerminalNode* myParser::LiteralConstantContext::RealLiteral() {
  return getToken(myParser::RealLiteral, 0);
}

tree::TerminalNode* myParser::LiteralConstantContext::NullLiteral() {
  return getToken(myParser::NullLiteral, 0);
}

tree::TerminalNode* myParser::LiteralConstantContext::LongLiteral() {
  return getToken(myParser::LongLiteral, 0);
}


size_t myParser::LiteralConstantContext::getRuleIndex() const {
  return myParser::RuleLiteralConstant;
}

void myParser::LiteralConstantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteralConstant(this);
}

void myParser::LiteralConstantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteralConstant(this);
}

myParser::LiteralConstantContext* myParser::literalConstant() {
  LiteralConstantContext *_localctx = _tracker.createInstance<LiteralConstantContext>(_ctx, getState());
  enterRule(_localctx, 164, myParser::RuleLiteralConstant);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1861);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::BooleanLiteral: {
        enterOuterAlt(_localctx, 1);
        setState(1852);
        match(myParser::BooleanLiteral);
        break;
      }

      case myParser::IntegerLiteral: {
        enterOuterAlt(_localctx, 2);
        setState(1853);
        match(myParser::IntegerLiteral);
        break;
      }

      case myParser::QUOTE_OPEN:
      case myParser::TRIPLE_QUOTE_OPEN: {
        enterOuterAlt(_localctx, 3);
        setState(1854);
        stringLiteral();
        break;
      }

      case myParser::HexLiteral: {
        enterOuterAlt(_localctx, 4);
        setState(1855);
        match(myParser::HexLiteral);
        break;
      }

      case myParser::BinLiteral: {
        enterOuterAlt(_localctx, 5);
        setState(1856);
        match(myParser::BinLiteral);
        break;
      }

      case myParser::CharacterLiteral: {
        enterOuterAlt(_localctx, 6);
        setState(1857);
        match(myParser::CharacterLiteral);
        break;
      }

      case myParser::RealLiteral: {
        enterOuterAlt(_localctx, 7);
        setState(1858);
        match(myParser::RealLiteral);
        break;
      }

      case myParser::NullLiteral: {
        enterOuterAlt(_localctx, 8);
        setState(1859);
        match(myParser::NullLiteral);
        break;
      }

      case myParser::LongLiteral: {
        enterOuterAlt(_localctx, 9);
        setState(1860);
        match(myParser::LongLiteral);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringLiteralContext ------------------------------------------------------------------

myParser::StringLiteralContext::StringLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::LineStringLiteralContext* myParser::StringLiteralContext::lineStringLiteral() {
  return getRuleContext<myParser::LineStringLiteralContext>(0);
}

myParser::MultiLineStringLiteralContext* myParser::StringLiteralContext::multiLineStringLiteral() {
  return getRuleContext<myParser::MultiLineStringLiteralContext>(0);
}


size_t myParser::StringLiteralContext::getRuleIndex() const {
  return myParser::RuleStringLiteral;
}

void myParser::StringLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringLiteral(this);
}

void myParser::StringLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringLiteral(this);
}

myParser::StringLiteralContext* myParser::stringLiteral() {
  StringLiteralContext *_localctx = _tracker.createInstance<StringLiteralContext>(_ctx, getState());
  enterRule(_localctx, 166, myParser::RuleStringLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1865);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::QUOTE_OPEN: {
        enterOuterAlt(_localctx, 1);
        setState(1863);
        lineStringLiteral();
        break;
      }

      case myParser::TRIPLE_QUOTE_OPEN: {
        enterOuterAlt(_localctx, 2);
        setState(1864);
        multiLineStringLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LineStringLiteralContext ------------------------------------------------------------------

myParser::LineStringLiteralContext::LineStringLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::LineStringLiteralContext::QUOTE_OPEN() {
  return getToken(myParser::QUOTE_OPEN, 0);
}

tree::TerminalNode* myParser::LineStringLiteralContext::QUOTE_CLOSE() {
  return getToken(myParser::QUOTE_CLOSE, 0);
}

std::vector<myParser::LineStringContentContext *> myParser::LineStringLiteralContext::lineStringContent() {
  return getRuleContexts<myParser::LineStringContentContext>();
}

myParser::LineStringContentContext* myParser::LineStringLiteralContext::lineStringContent(size_t i) {
  return getRuleContext<myParser::LineStringContentContext>(i);
}

std::vector<myParser::LineStringExpressionContext *> myParser::LineStringLiteralContext::lineStringExpression() {
  return getRuleContexts<myParser::LineStringExpressionContext>();
}

myParser::LineStringExpressionContext* myParser::LineStringLiteralContext::lineStringExpression(size_t i) {
  return getRuleContext<myParser::LineStringExpressionContext>(i);
}


size_t myParser::LineStringLiteralContext::getRuleIndex() const {
  return myParser::RuleLineStringLiteral;
}

void myParser::LineStringLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLineStringLiteral(this);
}

void myParser::LineStringLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLineStringLiteral(this);
}

myParser::LineStringLiteralContext* myParser::lineStringLiteral() {
  LineStringLiteralContext *_localctx = _tracker.createInstance<LineStringLiteralContext>(_ctx, getState());
  enterRule(_localctx, 168, myParser::RuleLineStringLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1867);
    match(myParser::QUOTE_OPEN);
    setState(1872);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la - 156) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 156)) & 15) != 0) {
      setState(1870);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case myParser::LineStrRef:
        case myParser::LineStrText:
        case myParser::LineStrEscapedChar: {
          setState(1868);
          lineStringContent();
          break;
        }

        case myParser::LineStrExprStart: {
          setState(1869);
          lineStringExpression();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1874);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1875);
    match(myParser::QUOTE_CLOSE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultiLineStringLiteralContext ------------------------------------------------------------------

myParser::MultiLineStringLiteralContext::MultiLineStringLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::MultiLineStringLiteralContext::TRIPLE_QUOTE_OPEN() {
  return getToken(myParser::TRIPLE_QUOTE_OPEN, 0);
}

tree::TerminalNode* myParser::MultiLineStringLiteralContext::TRIPLE_QUOTE_CLOSE() {
  return getToken(myParser::TRIPLE_QUOTE_CLOSE, 0);
}

std::vector<myParser::MultiLineStringContentContext *> myParser::MultiLineStringLiteralContext::multiLineStringContent() {
  return getRuleContexts<myParser::MultiLineStringContentContext>();
}

myParser::MultiLineStringContentContext* myParser::MultiLineStringLiteralContext::multiLineStringContent(size_t i) {
  return getRuleContext<myParser::MultiLineStringContentContext>(i);
}

std::vector<myParser::MultiLineStringExpressionContext *> myParser::MultiLineStringLiteralContext::multiLineStringExpression() {
  return getRuleContexts<myParser::MultiLineStringExpressionContext>();
}

myParser::MultiLineStringExpressionContext* myParser::MultiLineStringLiteralContext::multiLineStringExpression(size_t i) {
  return getRuleContext<myParser::MultiLineStringExpressionContext>(i);
}

std::vector<myParser::LineStringLiteralContext *> myParser::MultiLineStringLiteralContext::lineStringLiteral() {
  return getRuleContexts<myParser::LineStringLiteralContext>();
}

myParser::LineStringLiteralContext* myParser::MultiLineStringLiteralContext::lineStringLiteral(size_t i) {
  return getRuleContext<myParser::LineStringLiteralContext>(i);
}

std::vector<tree::TerminalNode *> myParser::MultiLineStringLiteralContext::MultiLineStringQuote() {
  return getTokens(myParser::MultiLineStringQuote);
}

tree::TerminalNode* myParser::MultiLineStringLiteralContext::MultiLineStringQuote(size_t i) {
  return getToken(myParser::MultiLineStringQuote, i);
}


size_t myParser::MultiLineStringLiteralContext::getRuleIndex() const {
  return myParser::RuleMultiLineStringLiteral;
}

void myParser::MultiLineStringLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiLineStringLiteral(this);
}

void myParser::MultiLineStringLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiLineStringLiteral(this);
}

myParser::MultiLineStringLiteralContext* myParser::multiLineStringLiteral() {
  MultiLineStringLiteralContext *_localctx = _tracker.createInstance<MultiLineStringLiteralContext>(_ctx, getState());
  enterRule(_localctx, 170, myParser::RuleMultiLineStringLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1877);
    match(myParser::TRIPLE_QUOTE_OPEN);
    setState(1884);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & 133143986177) != 0) {
      setState(1882);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case myParser::MultiLineStrRef:
        case myParser::MultiLineStrText:
        case myParser::MultiLineStrEscapedChar: {
          setState(1878);
          multiLineStringContent();
          break;
        }

        case myParser::MultiLineStrExprStart: {
          setState(1879);
          multiLineStringExpression();
          break;
        }

        case myParser::QUOTE_OPEN: {
          setState(1880);
          lineStringLiteral();
          break;
        }

        case myParser::MultiLineStringQuote: {
          setState(1881);
          match(myParser::MultiLineStringQuote);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1886);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1887);
    match(myParser::TRIPLE_QUOTE_CLOSE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LineStringContentContext ------------------------------------------------------------------

myParser::LineStringContentContext::LineStringContentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::LineStringContentContext::LineStrText() {
  return getToken(myParser::LineStrText, 0);
}

tree::TerminalNode* myParser::LineStringContentContext::LineStrEscapedChar() {
  return getToken(myParser::LineStrEscapedChar, 0);
}

tree::TerminalNode* myParser::LineStringContentContext::LineStrRef() {
  return getToken(myParser::LineStrRef, 0);
}


size_t myParser::LineStringContentContext::getRuleIndex() const {
  return myParser::RuleLineStringContent;
}

void myParser::LineStringContentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLineStringContent(this);
}

void myParser::LineStringContentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLineStringContent(this);
}

myParser::LineStringContentContext* myParser::lineStringContent() {
  LineStringContentContext *_localctx = _tracker.createInstance<LineStringContentContext>(_ctx, getState());
  enterRule(_localctx, 172, myParser::RuleLineStringContent);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1889);
    _la = _input->LA(1);
    if (!((((_la - 156) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 156)) & 7) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LineStringExpressionContext ------------------------------------------------------------------

myParser::LineStringExpressionContext::LineStringExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::LineStringExpressionContext::LineStrExprStart() {
  return getToken(myParser::LineStrExprStart, 0);
}

myParser::ExpressionContext* myParser::LineStringExpressionContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

tree::TerminalNode* myParser::LineStringExpressionContext::RCURL() {
  return getToken(myParser::RCURL, 0);
}


size_t myParser::LineStringExpressionContext::getRuleIndex() const {
  return myParser::RuleLineStringExpression;
}

void myParser::LineStringExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLineStringExpression(this);
}

void myParser::LineStringExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLineStringExpression(this);
}

myParser::LineStringExpressionContext* myParser::lineStringExpression() {
  LineStringExpressionContext *_localctx = _tracker.createInstance<LineStringExpressionContext>(_ctx, getState());
  enterRule(_localctx, 174, myParser::RuleLineStringExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1891);
    match(myParser::LineStrExprStart);
    setState(1892);
    expression();
    setState(1893);
    match(myParser::RCURL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultiLineStringContentContext ------------------------------------------------------------------

myParser::MultiLineStringContentContext::MultiLineStringContentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::MultiLineStringContentContext::MultiLineStrText() {
  return getToken(myParser::MultiLineStrText, 0);
}

tree::TerminalNode* myParser::MultiLineStringContentContext::MultiLineStrEscapedChar() {
  return getToken(myParser::MultiLineStrEscapedChar, 0);
}

tree::TerminalNode* myParser::MultiLineStringContentContext::MultiLineStrRef() {
  return getToken(myParser::MultiLineStrRef, 0);
}


size_t myParser::MultiLineStringContentContext::getRuleIndex() const {
  return myParser::RuleMultiLineStringContent;
}

void myParser::MultiLineStringContentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiLineStringContent(this);
}

void myParser::MultiLineStringContentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiLineStringContent(this);
}

myParser::MultiLineStringContentContext* myParser::multiLineStringContent() {
  MultiLineStringContentContext *_localctx = _tracker.createInstance<MultiLineStringContentContext>(_ctx, getState());
  enterRule(_localctx, 176, myParser::RuleMultiLineStringContent);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1895);
    _la = _input->LA(1);
    if (!((((_la - 162) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 162)) & 7) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultiLineStringExpressionContext ------------------------------------------------------------------

myParser::MultiLineStringExpressionContext::MultiLineStringExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::MultiLineStringExpressionContext::MultiLineStrExprStart() {
  return getToken(myParser::MultiLineStrExprStart, 0);
}

myParser::ExpressionContext* myParser::MultiLineStringExpressionContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

tree::TerminalNode* myParser::MultiLineStringExpressionContext::RCURL() {
  return getToken(myParser::RCURL, 0);
}


size_t myParser::MultiLineStringExpressionContext::getRuleIndex() const {
  return myParser::RuleMultiLineStringExpression;
}

void myParser::MultiLineStringExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiLineStringExpression(this);
}

void myParser::MultiLineStringExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiLineStringExpression(this);
}

myParser::MultiLineStringExpressionContext* myParser::multiLineStringExpression() {
  MultiLineStringExpressionContext *_localctx = _tracker.createInstance<MultiLineStringExpressionContext>(_ctx, getState());
  enterRule(_localctx, 178, myParser::RuleMultiLineStringExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1897);
    match(myParser::MultiLineStrExprStart);
    setState(1898);
    expression();
    setState(1899);
    match(myParser::RCURL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionLiteralContext ------------------------------------------------------------------

myParser::FunctionLiteralContext::FunctionLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::FunctionLiteralContext::LCURL() {
  return getToken(myParser::LCURL, 0);
}

myParser::StatementsContext* myParser::FunctionLiteralContext::statements() {
  return getRuleContext<myParser::StatementsContext>(0);
}

tree::TerminalNode* myParser::FunctionLiteralContext::RCURL() {
  return getToken(myParser::RCURL, 0);
}

myParser::LambdaParametersContext* myParser::FunctionLiteralContext::lambdaParameters() {
  return getRuleContext<myParser::LambdaParametersContext>(0);
}

tree::TerminalNode* myParser::FunctionLiteralContext::ARROW() {
  return getToken(myParser::ARROW, 0);
}

std::vector<myParser::AnnotationsContext *> myParser::FunctionLiteralContext::annotations() {
  return getRuleContexts<myParser::AnnotationsContext>();
}

myParser::AnnotationsContext* myParser::FunctionLiteralContext::annotations(size_t i) {
  return getRuleContext<myParser::AnnotationsContext>(i);
}

std::vector<tree::TerminalNode *> myParser::FunctionLiteralContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::FunctionLiteralContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::FunctionLiteralContext::getRuleIndex() const {
  return myParser::RuleFunctionLiteral;
}

void myParser::FunctionLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionLiteral(this);
}

void myParser::FunctionLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionLiteral(this);
}

myParser::FunctionLiteralContext* myParser::functionLiteral() {
  FunctionLiteralContext *_localctx = _tracker.createInstance<FunctionLiteralContext>(_ctx, getState());
  enterRule(_localctx, 180, myParser::RuleFunctionLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1904);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::AT

    || _la == myParser::FILE || (((_la - 93) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 93)) & 281474976711631) != 0) {
      setState(1901);
      annotations();
      setState(1906);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1953);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 288, _ctx)) {
    case 1: {
      setState(1907);
      match(myParser::LCURL);
      setState(1911);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 282, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1908);
          match(myParser::NL); 
        }
        setState(1913);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 282, _ctx);
      }
      setState(1914);
      statements();
      setState(1918);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(1915);
        match(myParser::NL);
        setState(1920);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1921);
      match(myParser::RCURL);
      break;
    }

    case 2: {
      setState(1923);
      match(myParser::LCURL);
      setState(1927);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 284, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1924);
          match(myParser::NL); 
        }
        setState(1929);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 284, _ctx);
      }
      setState(1930);
      lambdaParameters();
      setState(1934);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(1931);
        match(myParser::NL);
        setState(1936);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1937);
      match(myParser::ARROW);
      setState(1941);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 286, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1938);
          match(myParser::NL); 
        }
        setState(1943);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 286, _ctx);
      }
      setState(1944);
      statements();
      setState(1948);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(1945);
        match(myParser::NL);
        setState(1950);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1951);
      match(myParser::RCURL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LambdaParametersContext ------------------------------------------------------------------

myParser::LambdaParametersContext::LambdaParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::LambdaParameterContext *> myParser::LambdaParametersContext::lambdaParameter() {
  return getRuleContexts<myParser::LambdaParameterContext>();
}

myParser::LambdaParameterContext* myParser::LambdaParametersContext::lambdaParameter(size_t i) {
  return getRuleContext<myParser::LambdaParameterContext>(i);
}

std::vector<tree::TerminalNode *> myParser::LambdaParametersContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::LambdaParametersContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}

std::vector<tree::TerminalNode *> myParser::LambdaParametersContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::LambdaParametersContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::LambdaParametersContext::getRuleIndex() const {
  return myParser::RuleLambdaParameters;
}

void myParser::LambdaParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLambdaParameters(this);
}

void myParser::LambdaParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLambdaParameters(this);
}

myParser::LambdaParametersContext* myParser::lambdaParameters() {
  LambdaParametersContext *_localctx = _tracker.createInstance<LambdaParametersContext>(_ctx, getState());
  enterRule(_localctx, 182, myParser::RuleLambdaParameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1956);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LPAREN

    || _la == myParser::IMPORT || (((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 9223371905925394575) != 0 || _la == myParser::Identifier) {
      setState(1955);
      lambdaParameter();
    }
    setState(1974);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 292, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1961);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(1958);
          match(myParser::NL);
          setState(1963);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1964);
        match(myParser::COMMA);
        setState(1968);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(1965);
          match(myParser::NL);
          setState(1970);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1971);
        lambdaParameter(); 
      }
      setState(1976);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 292, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LambdaParameterContext ------------------------------------------------------------------

myParser::LambdaParameterContext::LambdaParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::VariableDeclarationContext* myParser::LambdaParameterContext::variableDeclaration() {
  return getRuleContext<myParser::VariableDeclarationContext>(0);
}

myParser::MultiVariableDeclarationContext* myParser::LambdaParameterContext::multiVariableDeclaration() {
  return getRuleContext<myParser::MultiVariableDeclarationContext>(0);
}

tree::TerminalNode* myParser::LambdaParameterContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::TypeContext* myParser::LambdaParameterContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

std::vector<tree::TerminalNode *> myParser::LambdaParameterContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::LambdaParameterContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::LambdaParameterContext::getRuleIndex() const {
  return myParser::RuleLambdaParameter;
}

void myParser::LambdaParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLambdaParameter(this);
}

void myParser::LambdaParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLambdaParameter(this);
}

myParser::LambdaParameterContext* myParser::lambdaParameter() {
  LambdaParameterContext *_localctx = _tracker.createInstance<LambdaParameterContext>(_ctx, getState());
  enterRule(_localctx, 184, myParser::RuleLambdaParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1995);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::IMPORT:
      case myParser::CONSTRUCTOR:
      case myParser::BY:
      case myParser::COMPANION:
      case myParser::INIT:
      case myParser::WHERE:
      case myParser::CATCH:
      case myParser::FINALLY:
      case myParser::OUT:
      case myParser::GETTER:
      case myParser::SETTER:
      case myParser::DYNAMIC:
      case myParser::PUBLIC:
      case myParser::PRIVATE:
      case myParser::PROTECTED:
      case myParser::INTERNAL:
      case myParser::ENUM:
      case myParser::SEALED:
      case myParser::ANNOTATION:
      case myParser::DATA:
      case myParser::INNER:
      case myParser::TAILREC:
      case myParser::OPERATOR:
      case myParser::INLINE:
      case myParser::INFIX:
      case myParser::EXTERNAL:
      case myParser::SUSPEND:
      case myParser::OVERRIDE:
      case myParser::ABSTRACT:
      case myParser::FINAL:
      case myParser::OPEN:
      case myParser::CONST:
      case myParser::LATEINIT:
      case myParser::VARARG:
      case myParser::NOINLINE:
      case myParser::CROSSINLINE:
      case myParser::REIFIED:
      case myParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(1977);
        variableDeclaration();
        break;
      }

      case myParser::LPAREN: {
        enterOuterAlt(_localctx, 2);
        setState(1978);
        multiVariableDeclaration();
        setState(1993);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 295, _ctx)) {
        case 1: {
          setState(1982);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == myParser::NL) {
            setState(1979);
            match(myParser::NL);
            setState(1984);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(1985);
          match(myParser::COLON);
          setState(1989);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == myParser::NL) {
            setState(1986);
            match(myParser::NL);
            setState(1991);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(1992);
          type();
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectLiteralContext ------------------------------------------------------------------

myParser::ObjectLiteralContext::ObjectLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ObjectLiteralContext::OBJECT() {
  return getToken(myParser::OBJECT, 0);
}

myParser::ClassBodyContext* myParser::ObjectLiteralContext::classBody() {
  return getRuleContext<myParser::ClassBodyContext>(0);
}

tree::TerminalNode* myParser::ObjectLiteralContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::DelegationSpecifiersContext* myParser::ObjectLiteralContext::delegationSpecifiers() {
  return getRuleContext<myParser::DelegationSpecifiersContext>(0);
}

std::vector<tree::TerminalNode *> myParser::ObjectLiteralContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::ObjectLiteralContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::ObjectLiteralContext::getRuleIndex() const {
  return myParser::RuleObjectLiteral;
}

void myParser::ObjectLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectLiteral(this);
}

void myParser::ObjectLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectLiteral(this);
}

myParser::ObjectLiteralContext* myParser::objectLiteral() {
  ObjectLiteralContext *_localctx = _tracker.createInstance<ObjectLiteralContext>(_ctx, getState());
  enterRule(_localctx, 186, myParser::RuleObjectLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1997);
    match(myParser::OBJECT);
    setState(2012);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 299, _ctx)) {
    case 1: {
      setState(2001);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(1998);
        match(myParser::NL);
        setState(2003);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2004);
      match(myParser::COLON);
      setState(2008);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(2005);
        match(myParser::NL);
        setState(2010);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2011);
      delegationSpecifiers();
      break;
    }

    default:
      break;
    }
    setState(2017);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(2014);
      match(myParser::NL);
      setState(2019);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2020);
    classBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CollectionLiteralContext ------------------------------------------------------------------

myParser::CollectionLiteralContext::CollectionLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::CollectionLiteralContext::LSQUARE() {
  return getToken(myParser::LSQUARE, 0);
}

tree::TerminalNode* myParser::CollectionLiteralContext::RSQUARE() {
  return getToken(myParser::RSQUARE, 0);
}

std::vector<myParser::ExpressionContext *> myParser::CollectionLiteralContext::expression() {
  return getRuleContexts<myParser::ExpressionContext>();
}

myParser::ExpressionContext* myParser::CollectionLiteralContext::expression(size_t i) {
  return getRuleContext<myParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> myParser::CollectionLiteralContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::CollectionLiteralContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::CollectionLiteralContext::getRuleIndex() const {
  return myParser::RuleCollectionLiteral;
}

void myParser::CollectionLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollectionLiteral(this);
}

void myParser::CollectionLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollectionLiteral(this);
}

myParser::CollectionLiteralContext* myParser::collectionLiteral() {
  CollectionLiteralContext *_localctx = _tracker.createInstance<CollectionLiteralContext>(_ctx, getState());
  enterRule(_localctx, 188, myParser::RuleCollectionLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2022);
    match(myParser::LSQUARE);
    setState(2024);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 5035025689090992672) != 0 || (((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & -65012289) != 0 || (((_la - 130) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 130)) & 24563) != 0) {
      setState(2023);
      expression();
    }
    setState(2030);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(2026);
      match(myParser::COMMA);
      setState(2027);
      expression();
      setState(2032);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2033);
    match(myParser::RSQUARE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThisExpressionContext ------------------------------------------------------------------

myParser::ThisExpressionContext::ThisExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ThisExpressionContext::THIS() {
  return getToken(myParser::THIS, 0);
}

tree::TerminalNode* myParser::ThisExpressionContext::LabelReference() {
  return getToken(myParser::LabelReference, 0);
}


size_t myParser::ThisExpressionContext::getRuleIndex() const {
  return myParser::RuleThisExpression;
}

void myParser::ThisExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThisExpression(this);
}

void myParser::ThisExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThisExpression(this);
}

myParser::ThisExpressionContext* myParser::thisExpression() {
  ThisExpressionContext *_localctx = _tracker.createInstance<ThisExpressionContext>(_ctx, getState());
  enterRule(_localctx, 190, myParser::RuleThisExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2035);
    match(myParser::THIS);
    setState(2037);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 303, _ctx)) {
    case 1: {
      setState(2036);
      match(myParser::LabelReference);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SuperExpressionContext ------------------------------------------------------------------

myParser::SuperExpressionContext::SuperExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::SuperExpressionContext::SUPER() {
  return getToken(myParser::SUPER, 0);
}

tree::TerminalNode* myParser::SuperExpressionContext::LANGLE() {
  return getToken(myParser::LANGLE, 0);
}

myParser::TypeContext* myParser::SuperExpressionContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

tree::TerminalNode* myParser::SuperExpressionContext::RANGLE() {
  return getToken(myParser::RANGLE, 0);
}

tree::TerminalNode* myParser::SuperExpressionContext::LabelReference() {
  return getToken(myParser::LabelReference, 0);
}

std::vector<tree::TerminalNode *> myParser::SuperExpressionContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::SuperExpressionContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::SuperExpressionContext::getRuleIndex() const {
  return myParser::RuleSuperExpression;
}

void myParser::SuperExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSuperExpression(this);
}

void myParser::SuperExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSuperExpression(this);
}

myParser::SuperExpressionContext* myParser::superExpression() {
  SuperExpressionContext *_localctx = _tracker.createInstance<SuperExpressionContext>(_ctx, getState());
  enterRule(_localctx, 192, myParser::RuleSuperExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2039);
    match(myParser::SUPER);
    setState(2056);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 306, _ctx)) {
    case 1: {
      setState(2040);
      match(myParser::LANGLE);
      setState(2044);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(2041);
        match(myParser::NL);
        setState(2046);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2047);
      type();
      setState(2051);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(2048);
        match(myParser::NL);
        setState(2053);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2054);
      match(myParser::RANGLE);
      break;
    }

    default:
      break;
    }
    setState(2059);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 307, _ctx)) {
    case 1: {
      setState(2058);
      match(myParser::LabelReference);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionalExpressionContext ------------------------------------------------------------------

myParser::ConditionalExpressionContext::ConditionalExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IfExpressionContext* myParser::ConditionalExpressionContext::ifExpression() {
  return getRuleContext<myParser::IfExpressionContext>(0);
}

myParser::WhenExpressionContext* myParser::ConditionalExpressionContext::whenExpression() {
  return getRuleContext<myParser::WhenExpressionContext>(0);
}


size_t myParser::ConditionalExpressionContext::getRuleIndex() const {
  return myParser::RuleConditionalExpression;
}

void myParser::ConditionalExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionalExpression(this);
}

void myParser::ConditionalExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionalExpression(this);
}

myParser::ConditionalExpressionContext* myParser::conditionalExpression() {
  ConditionalExpressionContext *_localctx = _tracker.createInstance<ConditionalExpressionContext>(_ctx, getState());
  enterRule(_localctx, 194, myParser::RuleConditionalExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2063);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::IF: {
        enterOuterAlt(_localctx, 1);
        setState(2061);
        ifExpression();
        break;
      }

      case myParser::WHEN: {
        enterOuterAlt(_localctx, 2);
        setState(2062);
        whenExpression();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfExpressionContext ------------------------------------------------------------------

myParser::IfExpressionContext::IfExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::IfExpressionContext::IF() {
  return getToken(myParser::IF, 0);
}

tree::TerminalNode* myParser::IfExpressionContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::ExpressionContext* myParser::IfExpressionContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

tree::TerminalNode* myParser::IfExpressionContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

std::vector<tree::TerminalNode *> myParser::IfExpressionContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::IfExpressionContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

std::vector<myParser::ControlStructureBodyContext *> myParser::IfExpressionContext::controlStructureBody() {
  return getRuleContexts<myParser::ControlStructureBodyContext>();
}

myParser::ControlStructureBodyContext* myParser::IfExpressionContext::controlStructureBody(size_t i) {
  return getRuleContext<myParser::ControlStructureBodyContext>(i);
}

tree::TerminalNode* myParser::IfExpressionContext::SEMICOLON() {
  return getToken(myParser::SEMICOLON, 0);
}

tree::TerminalNode* myParser::IfExpressionContext::ELSE() {
  return getToken(myParser::ELSE, 0);
}


size_t myParser::IfExpressionContext::getRuleIndex() const {
  return myParser::RuleIfExpression;
}

void myParser::IfExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfExpression(this);
}

void myParser::IfExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfExpression(this);
}

myParser::IfExpressionContext* myParser::ifExpression() {
  IfExpressionContext *_localctx = _tracker.createInstance<IfExpressionContext>(_ctx, getState());
  enterRule(_localctx, 196, myParser::RuleIfExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2065);
    match(myParser::IF);
    setState(2069);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(2066);
      match(myParser::NL);
      setState(2071);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2072);
    match(myParser::LPAREN);
    setState(2073);
    expression();
    setState(2074);
    match(myParser::RPAREN);
    setState(2078);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 310, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2075);
        match(myParser::NL); 
      }
      setState(2080);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 310, _ctx);
    }
    setState(2082);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 311, _ctx)) {
    case 1: {
      setState(2081);
      controlStructureBody();
      break;
    }

    default:
      break;
    }
    setState(2085);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 312, _ctx)) {
    case 1: {
      setState(2084);
      match(myParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
    setState(2103);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 316, _ctx)) {
    case 1: {
      setState(2090);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(2087);
        match(myParser::NL);
        setState(2092);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2093);
      match(myParser::ELSE);
      setState(2097);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 314, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2094);
          match(myParser::NL); 
        }
        setState(2099);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 314, _ctx);
      }
      setState(2101);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 315, _ctx)) {
      case 1: {
        setState(2100);
        controlStructureBody();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ControlStructureBodyContext ------------------------------------------------------------------

myParser::ControlStructureBodyContext::ControlStructureBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::BlockContext* myParser::ControlStructureBodyContext::block() {
  return getRuleContext<myParser::BlockContext>(0);
}

myParser::ExpressionContext* myParser::ControlStructureBodyContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}


size_t myParser::ControlStructureBodyContext::getRuleIndex() const {
  return myParser::RuleControlStructureBody;
}

void myParser::ControlStructureBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterControlStructureBody(this);
}

void myParser::ControlStructureBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitControlStructureBody(this);
}

myParser::ControlStructureBodyContext* myParser::controlStructureBody() {
  ControlStructureBodyContext *_localctx = _tracker.createInstance<ControlStructureBodyContext>(_ctx, getState());
  enterRule(_localctx, 198, myParser::RuleControlStructureBody);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2107);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 317, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2105);
      block();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2106);
      expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhenExpressionContext ------------------------------------------------------------------

myParser::WhenExpressionContext::WhenExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::WhenExpressionContext::WHEN() {
  return getToken(myParser::WHEN, 0);
}

tree::TerminalNode* myParser::WhenExpressionContext::LCURL() {
  return getToken(myParser::LCURL, 0);
}

tree::TerminalNode* myParser::WhenExpressionContext::RCURL() {
  return getToken(myParser::RCURL, 0);
}

std::vector<tree::TerminalNode *> myParser::WhenExpressionContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::WhenExpressionContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

tree::TerminalNode* myParser::WhenExpressionContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::ExpressionContext* myParser::WhenExpressionContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

tree::TerminalNode* myParser::WhenExpressionContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

std::vector<myParser::WhenEntryContext *> myParser::WhenExpressionContext::whenEntry() {
  return getRuleContexts<myParser::WhenEntryContext>();
}

myParser::WhenEntryContext* myParser::WhenExpressionContext::whenEntry(size_t i) {
  return getRuleContext<myParser::WhenEntryContext>(i);
}


size_t myParser::WhenExpressionContext::getRuleIndex() const {
  return myParser::RuleWhenExpression;
}

void myParser::WhenExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhenExpression(this);
}

void myParser::WhenExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhenExpression(this);
}

myParser::WhenExpressionContext* myParser::whenExpression() {
  WhenExpressionContext *_localctx = _tracker.createInstance<WhenExpressionContext>(_ctx, getState());
  enterRule(_localctx, 200, myParser::RuleWhenExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2109);
    match(myParser::WHEN);
    setState(2113);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 318, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2110);
        match(myParser::NL); 
      }
      setState(2115);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 318, _ctx);
    }
    setState(2120);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LPAREN) {
      setState(2116);
      match(myParser::LPAREN);
      setState(2117);
      expression();
      setState(2118);
      match(myParser::RPAREN);
    }
    setState(2125);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(2122);
      match(myParser::NL);
      setState(2127);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2128);
    match(myParser::LCURL);
    setState(2132);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 321, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2129);
        match(myParser::NL); 
      }
      setState(2134);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 321, _ctx);
    }
    setState(2144);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 323, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2135);
        whenEntry();
        setState(2139);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 322, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2136);
            match(myParser::NL); 
          }
          setState(2141);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 322, _ctx);
        } 
      }
      setState(2146);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 323, _ctx);
    }
    setState(2150);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(2147);
      match(myParser::NL);
      setState(2152);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2153);
    match(myParser::RCURL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhenEntryContext ------------------------------------------------------------------

myParser::WhenEntryContext::WhenEntryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::WhenConditionContext *> myParser::WhenEntryContext::whenCondition() {
  return getRuleContexts<myParser::WhenConditionContext>();
}

myParser::WhenConditionContext* myParser::WhenEntryContext::whenCondition(size_t i) {
  return getRuleContext<myParser::WhenConditionContext>(i);
}

tree::TerminalNode* myParser::WhenEntryContext::ARROW() {
  return getToken(myParser::ARROW, 0);
}

myParser::ControlStructureBodyContext* myParser::WhenEntryContext::controlStructureBody() {
  return getRuleContext<myParser::ControlStructureBodyContext>(0);
}

std::vector<tree::TerminalNode *> myParser::WhenEntryContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::WhenEntryContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}

std::vector<tree::TerminalNode *> myParser::WhenEntryContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::WhenEntryContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

myParser::SemiContext* myParser::WhenEntryContext::semi() {
  return getRuleContext<myParser::SemiContext>(0);
}

tree::TerminalNode* myParser::WhenEntryContext::ELSE() {
  return getToken(myParser::ELSE, 0);
}


size_t myParser::WhenEntryContext::getRuleIndex() const {
  return myParser::RuleWhenEntry;
}

void myParser::WhenEntryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhenEntry(this);
}

void myParser::WhenEntryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhenEntry(this);
}

myParser::WhenEntryContext* myParser::whenEntry() {
  WhenEntryContext *_localctx = _tracker.createInstance<WhenEntryContext>(_ctx, getState());
  enterRule(_localctx, 202, myParser::RuleWhenEntry);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(2207);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::NL:
      case myParser::LPAREN:
      case myParser::LSQUARE:
      case myParser::LCURL:
      case myParser::ADD:
      case myParser::SUB:
      case myParser::INCR:
      case myParser::DECR:
      case myParser::EXCL:
      case myParser::COLONCOLON:
      case myParser::Q_COLONCOLON:
      case myParser::AT:
      case myParser::RETURN_AT:
      case myParser::CONTINUE_AT:
      case myParser::BREAK_AT:
      case myParser::FILE:
      case myParser::IMPORT:
      case myParser::OBJECT:
      case myParser::CONSTRUCTOR:
      case myParser::BY:
      case myParser::COMPANION:
      case myParser::INIT:
      case myParser::THIS:
      case myParser::SUPER:
      case myParser::WHERE:
      case myParser::IF:
      case myParser::WHEN:
      case myParser::TRY:
      case myParser::CATCH:
      case myParser::FINALLY:
      case myParser::FOR:
      case myParser::DO:
      case myParser::WHILE:
      case myParser::THROW:
      case myParser::RETURN:
      case myParser::CONTINUE:
      case myParser::BREAK:
      case myParser::IS:
      case myParser::IN:
      case myParser::NOT_IS:
      case myParser::NOT_IN:
      case myParser::OUT:
      case myParser::FIELD:
      case myParser::PROPERTY:
      case myParser::GET:
      case myParser::SET:
      case myParser::GETTER:
      case myParser::SETTER:
      case myParser::RECEIVER:
      case myParser::PARAM:
      case myParser::SETPARAM:
      case myParser::DELEGATE:
      case myParser::DYNAMIC:
      case myParser::PUBLIC:
      case myParser::PRIVATE:
      case myParser::PROTECTED:
      case myParser::INTERNAL:
      case myParser::ENUM:
      case myParser::SEALED:
      case myParser::ANNOTATION:
      case myParser::DATA:
      case myParser::INNER:
      case myParser::TAILREC:
      case myParser::OPERATOR:
      case myParser::INLINE:
      case myParser::INFIX:
      case myParser::EXTERNAL:
      case myParser::SUSPEND:
      case myParser::OVERRIDE:
      case myParser::ABSTRACT:
      case myParser::FINAL:
      case myParser::OPEN:
      case myParser::CONST:
      case myParser::LATEINIT:
      case myParser::VARARG:
      case myParser::NOINLINE:
      case myParser::CROSSINLINE:
      case myParser::REIFIED:
      case myParser::QUOTE_OPEN:
      case myParser::TRIPLE_QUOTE_OPEN:
      case myParser::RealLiteral:
      case myParser::LongLiteral:
      case myParser::IntegerLiteral:
      case myParser::HexLiteral:
      case myParser::BinLiteral:
      case myParser::BooleanLiteral:
      case myParser::NullLiteral:
      case myParser::Identifier:
      case myParser::LabelReference:
      case myParser::LabelDefinition:
      case myParser::CharacterLiteral: {
        enterOuterAlt(_localctx, 1);
        setState(2155);
        whenCondition();
        setState(2172);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 327, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2159);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == myParser::NL) {
              setState(2156);
              match(myParser::NL);
              setState(2161);
              _errHandler->sync(this);
              _la = _input->LA(1);
            }
            setState(2162);
            match(myParser::COMMA);
            setState(2166);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 326, _ctx);
            while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
              if (alt == 1) {
                setState(2163);
                match(myParser::NL); 
              }
              setState(2168);
              _errHandler->sync(this);
              alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 326, _ctx);
            }
            setState(2169);
            whenCondition(); 
          }
          setState(2174);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 327, _ctx);
        }
        setState(2178);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(2175);
          match(myParser::NL);
          setState(2180);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2181);
        match(myParser::ARROW);
        setState(2185);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 329, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2182);
            match(myParser::NL); 
          }
          setState(2187);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 329, _ctx);
        }
        setState(2188);
        controlStructureBody();
        setState(2190);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 330, _ctx)) {
        case 1: {
          setState(2189);
          semi();
          break;
        }

        default:
          break;
        }
        break;
      }

      case myParser::ELSE: {
        enterOuterAlt(_localctx, 2);
        setState(2192);
        match(myParser::ELSE);
        setState(2196);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(2193);
          match(myParser::NL);
          setState(2198);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2199);
        match(myParser::ARROW);
        setState(2203);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 332, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2200);
            match(myParser::NL); 
          }
          setState(2205);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 332, _ctx);
        }
        setState(2206);
        controlStructureBody();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhenConditionContext ------------------------------------------------------------------

myParser::WhenConditionContext::WhenConditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionContext* myParser::WhenConditionContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

myParser::RangeTestContext* myParser::WhenConditionContext::rangeTest() {
  return getRuleContext<myParser::RangeTestContext>(0);
}

myParser::TypeTestContext* myParser::WhenConditionContext::typeTest() {
  return getRuleContext<myParser::TypeTestContext>(0);
}


size_t myParser::WhenConditionContext::getRuleIndex() const {
  return myParser::RuleWhenCondition;
}

void myParser::WhenConditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhenCondition(this);
}

void myParser::WhenConditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhenCondition(this);
}

myParser::WhenConditionContext* myParser::whenCondition() {
  WhenConditionContext *_localctx = _tracker.createInstance<WhenConditionContext>(_ctx, getState());
  enterRule(_localctx, 204, myParser::RuleWhenCondition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2212);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::NL:
      case myParser::LPAREN:
      case myParser::LSQUARE:
      case myParser::LCURL:
      case myParser::ADD:
      case myParser::SUB:
      case myParser::INCR:
      case myParser::DECR:
      case myParser::EXCL:
      case myParser::COLONCOLON:
      case myParser::Q_COLONCOLON:
      case myParser::AT:
      case myParser::RETURN_AT:
      case myParser::CONTINUE_AT:
      case myParser::BREAK_AT:
      case myParser::FILE:
      case myParser::IMPORT:
      case myParser::OBJECT:
      case myParser::CONSTRUCTOR:
      case myParser::BY:
      case myParser::COMPANION:
      case myParser::INIT:
      case myParser::THIS:
      case myParser::SUPER:
      case myParser::WHERE:
      case myParser::IF:
      case myParser::WHEN:
      case myParser::TRY:
      case myParser::CATCH:
      case myParser::FINALLY:
      case myParser::FOR:
      case myParser::DO:
      case myParser::WHILE:
      case myParser::THROW:
      case myParser::RETURN:
      case myParser::CONTINUE:
      case myParser::BREAK:
      case myParser::OUT:
      case myParser::FIELD:
      case myParser::PROPERTY:
      case myParser::GET:
      case myParser::SET:
      case myParser::GETTER:
      case myParser::SETTER:
      case myParser::RECEIVER:
      case myParser::PARAM:
      case myParser::SETPARAM:
      case myParser::DELEGATE:
      case myParser::DYNAMIC:
      case myParser::PUBLIC:
      case myParser::PRIVATE:
      case myParser::PROTECTED:
      case myParser::INTERNAL:
      case myParser::ENUM:
      case myParser::SEALED:
      case myParser::ANNOTATION:
      case myParser::DATA:
      case myParser::INNER:
      case myParser::TAILREC:
      case myParser::OPERATOR:
      case myParser::INLINE:
      case myParser::INFIX:
      case myParser::EXTERNAL:
      case myParser::SUSPEND:
      case myParser::OVERRIDE:
      case myParser::ABSTRACT:
      case myParser::FINAL:
      case myParser::OPEN:
      case myParser::CONST:
      case myParser::LATEINIT:
      case myParser::VARARG:
      case myParser::NOINLINE:
      case myParser::CROSSINLINE:
      case myParser::REIFIED:
      case myParser::QUOTE_OPEN:
      case myParser::TRIPLE_QUOTE_OPEN:
      case myParser::RealLiteral:
      case myParser::LongLiteral:
      case myParser::IntegerLiteral:
      case myParser::HexLiteral:
      case myParser::BinLiteral:
      case myParser::BooleanLiteral:
      case myParser::NullLiteral:
      case myParser::Identifier:
      case myParser::LabelReference:
      case myParser::LabelDefinition:
      case myParser::CharacterLiteral: {
        enterOuterAlt(_localctx, 1);
        setState(2209);
        expression();
        break;
      }

      case myParser::IN:
      case myParser::NOT_IN: {
        enterOuterAlt(_localctx, 2);
        setState(2210);
        rangeTest();
        break;
      }

      case myParser::IS:
      case myParser::NOT_IS: {
        enterOuterAlt(_localctx, 3);
        setState(2211);
        typeTest();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RangeTestContext ------------------------------------------------------------------

myParser::RangeTestContext::RangeTestContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::InOperatorContext* myParser::RangeTestContext::inOperator() {
  return getRuleContext<myParser::InOperatorContext>(0);
}

myParser::ExpressionContext* myParser::RangeTestContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

std::vector<tree::TerminalNode *> myParser::RangeTestContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::RangeTestContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::RangeTestContext::getRuleIndex() const {
  return myParser::RuleRangeTest;
}

void myParser::RangeTestContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRangeTest(this);
}

void myParser::RangeTestContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRangeTest(this);
}

myParser::RangeTestContext* myParser::rangeTest() {
  RangeTestContext *_localctx = _tracker.createInstance<RangeTestContext>(_ctx, getState());
  enterRule(_localctx, 206, myParser::RuleRangeTest);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2214);
    inOperator();
    setState(2218);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 335, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2215);
        match(myParser::NL); 
      }
      setState(2220);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 335, _ctx);
    }
    setState(2221);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeTestContext ------------------------------------------------------------------

myParser::TypeTestContext::TypeTestContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IsOperatorContext* myParser::TypeTestContext::isOperator() {
  return getRuleContext<myParser::IsOperatorContext>(0);
}

myParser::TypeContext* myParser::TypeTestContext::type() {
  return getRuleContext<myParser::TypeContext>(0);
}

std::vector<tree::TerminalNode *> myParser::TypeTestContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::TypeTestContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::TypeTestContext::getRuleIndex() const {
  return myParser::RuleTypeTest;
}

void myParser::TypeTestContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeTest(this);
}

void myParser::TypeTestContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeTest(this);
}

myParser::TypeTestContext* myParser::typeTest() {
  TypeTestContext *_localctx = _tracker.createInstance<TypeTestContext>(_ctx, getState());
  enterRule(_localctx, 208, myParser::RuleTypeTest);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2223);
    isOperator();
    setState(2227);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(2224);
      match(myParser::NL);
      setState(2229);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2230);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TryExpressionContext ------------------------------------------------------------------

myParser::TryExpressionContext::TryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TryExpressionContext::TRY() {
  return getToken(myParser::TRY, 0);
}

myParser::BlockContext* myParser::TryExpressionContext::block() {
  return getRuleContext<myParser::BlockContext>(0);
}

std::vector<tree::TerminalNode *> myParser::TryExpressionContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::TryExpressionContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

std::vector<myParser::CatchBlockContext *> myParser::TryExpressionContext::catchBlock() {
  return getRuleContexts<myParser::CatchBlockContext>();
}

myParser::CatchBlockContext* myParser::TryExpressionContext::catchBlock(size_t i) {
  return getRuleContext<myParser::CatchBlockContext>(i);
}

myParser::FinallyBlockContext* myParser::TryExpressionContext::finallyBlock() {
  return getRuleContext<myParser::FinallyBlockContext>(0);
}


size_t myParser::TryExpressionContext::getRuleIndex() const {
  return myParser::RuleTryExpression;
}

void myParser::TryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTryExpression(this);
}

void myParser::TryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTryExpression(this);
}

myParser::TryExpressionContext* myParser::tryExpression() {
  TryExpressionContext *_localctx = _tracker.createInstance<TryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 210, myParser::RuleTryExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2232);
    match(myParser::TRY);
    setState(2236);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(2233);
      match(myParser::NL);
      setState(2238);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2239);
    block();
    setState(2249);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 339, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2243);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(2240);
          match(myParser::NL);
          setState(2245);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2246);
        catchBlock(); 
      }
      setState(2251);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 339, _ctx);
    }
    setState(2259);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 341, _ctx)) {
    case 1: {
      setState(2255);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(2252);
        match(myParser::NL);
        setState(2257);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2258);
      finallyBlock();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CatchBlockContext ------------------------------------------------------------------

myParser::CatchBlockContext::CatchBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::CatchBlockContext::CATCH() {
  return getToken(myParser::CATCH, 0);
}

tree::TerminalNode* myParser::CatchBlockContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::SimpleIdentifierContext* myParser::CatchBlockContext::simpleIdentifier() {
  return getRuleContext<myParser::SimpleIdentifierContext>(0);
}

tree::TerminalNode* myParser::CatchBlockContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::UserTypeContext* myParser::CatchBlockContext::userType() {
  return getRuleContext<myParser::UserTypeContext>(0);
}

tree::TerminalNode* myParser::CatchBlockContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

myParser::BlockContext* myParser::CatchBlockContext::block() {
  return getRuleContext<myParser::BlockContext>(0);
}

std::vector<tree::TerminalNode *> myParser::CatchBlockContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::CatchBlockContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

std::vector<myParser::AnnotationsContext *> myParser::CatchBlockContext::annotations() {
  return getRuleContexts<myParser::AnnotationsContext>();
}

myParser::AnnotationsContext* myParser::CatchBlockContext::annotations(size_t i) {
  return getRuleContext<myParser::AnnotationsContext>(i);
}


size_t myParser::CatchBlockContext::getRuleIndex() const {
  return myParser::RuleCatchBlock;
}

void myParser::CatchBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCatchBlock(this);
}

void myParser::CatchBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCatchBlock(this);
}

myParser::CatchBlockContext* myParser::catchBlock() {
  CatchBlockContext *_localctx = _tracker.createInstance<CatchBlockContext>(_ctx, getState());
  enterRule(_localctx, 212, myParser::RuleCatchBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2261);
    match(myParser::CATCH);
    setState(2265);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(2262);
      match(myParser::NL);
      setState(2267);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2268);
    match(myParser::LPAREN);
    setState(2272);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::AT

    || _la == myParser::FILE || (((_la - 93) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 93)) & 281474976711631) != 0) {
      setState(2269);
      annotations();
      setState(2274);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2275);
    simpleIdentifier();
    setState(2276);
    match(myParser::COLON);
    setState(2277);
    userType();
    setState(2278);
    match(myParser::RPAREN);
    setState(2282);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(2279);
      match(myParser::NL);
      setState(2284);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2285);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FinallyBlockContext ------------------------------------------------------------------

myParser::FinallyBlockContext::FinallyBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::FinallyBlockContext::FINALLY() {
  return getToken(myParser::FINALLY, 0);
}

myParser::BlockContext* myParser::FinallyBlockContext::block() {
  return getRuleContext<myParser::BlockContext>(0);
}

std::vector<tree::TerminalNode *> myParser::FinallyBlockContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::FinallyBlockContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::FinallyBlockContext::getRuleIndex() const {
  return myParser::RuleFinallyBlock;
}

void myParser::FinallyBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFinallyBlock(this);
}

void myParser::FinallyBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFinallyBlock(this);
}

myParser::FinallyBlockContext* myParser::finallyBlock() {
  FinallyBlockContext *_localctx = _tracker.createInstance<FinallyBlockContext>(_ctx, getState());
  enterRule(_localctx, 214, myParser::RuleFinallyBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2287);
    match(myParser::FINALLY);
    setState(2291);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(2288);
      match(myParser::NL);
      setState(2293);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2294);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoopExpressionContext ------------------------------------------------------------------

myParser::LoopExpressionContext::LoopExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ForExpressionContext* myParser::LoopExpressionContext::forExpression() {
  return getRuleContext<myParser::ForExpressionContext>(0);
}

myParser::WhileExpressionContext* myParser::LoopExpressionContext::whileExpression() {
  return getRuleContext<myParser::WhileExpressionContext>(0);
}

myParser::DoWhileExpressionContext* myParser::LoopExpressionContext::doWhileExpression() {
  return getRuleContext<myParser::DoWhileExpressionContext>(0);
}


size_t myParser::LoopExpressionContext::getRuleIndex() const {
  return myParser::RuleLoopExpression;
}

void myParser::LoopExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoopExpression(this);
}

void myParser::LoopExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoopExpression(this);
}

myParser::LoopExpressionContext* myParser::loopExpression() {
  LoopExpressionContext *_localctx = _tracker.createInstance<LoopExpressionContext>(_ctx, getState());
  enterRule(_localctx, 216, myParser::RuleLoopExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2299);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::FOR: {
        enterOuterAlt(_localctx, 1);
        setState(2296);
        forExpression();
        break;
      }

      case myParser::WHILE: {
        enterOuterAlt(_localctx, 2);
        setState(2297);
        whileExpression();
        break;
      }

      case myParser::DO: {
        enterOuterAlt(_localctx, 3);
        setState(2298);
        doWhileExpression();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForExpressionContext ------------------------------------------------------------------

myParser::ForExpressionContext::ForExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ForExpressionContext::FOR() {
  return getToken(myParser::FOR, 0);
}

tree::TerminalNode* myParser::ForExpressionContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

tree::TerminalNode* myParser::ForExpressionContext::IN() {
  return getToken(myParser::IN, 0);
}

myParser::ExpressionContext* myParser::ForExpressionContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

tree::TerminalNode* myParser::ForExpressionContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

myParser::VariableDeclarationContext* myParser::ForExpressionContext::variableDeclaration() {
  return getRuleContext<myParser::VariableDeclarationContext>(0);
}

myParser::MultiVariableDeclarationContext* myParser::ForExpressionContext::multiVariableDeclaration() {
  return getRuleContext<myParser::MultiVariableDeclarationContext>(0);
}

std::vector<tree::TerminalNode *> myParser::ForExpressionContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::ForExpressionContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

std::vector<myParser::AnnotationsContext *> myParser::ForExpressionContext::annotations() {
  return getRuleContexts<myParser::AnnotationsContext>();
}

myParser::AnnotationsContext* myParser::ForExpressionContext::annotations(size_t i) {
  return getRuleContext<myParser::AnnotationsContext>(i);
}

myParser::ControlStructureBodyContext* myParser::ForExpressionContext::controlStructureBody() {
  return getRuleContext<myParser::ControlStructureBodyContext>(0);
}


size_t myParser::ForExpressionContext::getRuleIndex() const {
  return myParser::RuleForExpression;
}

void myParser::ForExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForExpression(this);
}

void myParser::ForExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForExpression(this);
}

myParser::ForExpressionContext* myParser::forExpression() {
  ForExpressionContext *_localctx = _tracker.createInstance<ForExpressionContext>(_ctx, getState());
  enterRule(_localctx, 218, myParser::RuleForExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2301);
    match(myParser::FOR);
    setState(2305);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(2302);
      match(myParser::NL);
      setState(2307);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2308);
    match(myParser::LPAREN);
    setState(2312);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::AT

    || _la == myParser::FILE || (((_la - 93) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 93)) & 281474976711631) != 0) {
      setState(2309);
      annotations();
      setState(2314);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2317);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::IMPORT:
      case myParser::CONSTRUCTOR:
      case myParser::BY:
      case myParser::COMPANION:
      case myParser::INIT:
      case myParser::WHERE:
      case myParser::CATCH:
      case myParser::FINALLY:
      case myParser::OUT:
      case myParser::GETTER:
      case myParser::SETTER:
      case myParser::DYNAMIC:
      case myParser::PUBLIC:
      case myParser::PRIVATE:
      case myParser::PROTECTED:
      case myParser::INTERNAL:
      case myParser::ENUM:
      case myParser::SEALED:
      case myParser::ANNOTATION:
      case myParser::DATA:
      case myParser::INNER:
      case myParser::TAILREC:
      case myParser::OPERATOR:
      case myParser::INLINE:
      case myParser::INFIX:
      case myParser::EXTERNAL:
      case myParser::SUSPEND:
      case myParser::OVERRIDE:
      case myParser::ABSTRACT:
      case myParser::FINAL:
      case myParser::OPEN:
      case myParser::CONST:
      case myParser::LATEINIT:
      case myParser::VARARG:
      case myParser::NOINLINE:
      case myParser::CROSSINLINE:
      case myParser::REIFIED:
      case myParser::Identifier: {
        setState(2315);
        variableDeclaration();
        break;
      }

      case myParser::LPAREN: {
        setState(2316);
        multiVariableDeclaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2319);
    match(myParser::IN);
    setState(2320);
    expression();
    setState(2321);
    match(myParser::RPAREN);
    setState(2325);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 350, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2322);
        match(myParser::NL); 
      }
      setState(2327);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 350, _ctx);
    }
    setState(2329);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 351, _ctx)) {
    case 1: {
      setState(2328);
      controlStructureBody();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhileExpressionContext ------------------------------------------------------------------

myParser::WhileExpressionContext::WhileExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::WhileExpressionContext::WHILE() {
  return getToken(myParser::WHILE, 0);
}

tree::TerminalNode* myParser::WhileExpressionContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::ExpressionContext* myParser::WhileExpressionContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

tree::TerminalNode* myParser::WhileExpressionContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

std::vector<tree::TerminalNode *> myParser::WhileExpressionContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::WhileExpressionContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

myParser::ControlStructureBodyContext* myParser::WhileExpressionContext::controlStructureBody() {
  return getRuleContext<myParser::ControlStructureBodyContext>(0);
}


size_t myParser::WhileExpressionContext::getRuleIndex() const {
  return myParser::RuleWhileExpression;
}

void myParser::WhileExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhileExpression(this);
}

void myParser::WhileExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhileExpression(this);
}

myParser::WhileExpressionContext* myParser::whileExpression() {
  WhileExpressionContext *_localctx = _tracker.createInstance<WhileExpressionContext>(_ctx, getState());
  enterRule(_localctx, 220, myParser::RuleWhileExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2331);
    match(myParser::WHILE);
    setState(2335);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(2332);
      match(myParser::NL);
      setState(2337);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2338);
    match(myParser::LPAREN);
    setState(2339);
    expression();
    setState(2340);
    match(myParser::RPAREN);
    setState(2344);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 353, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2341);
        match(myParser::NL); 
      }
      setState(2346);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 353, _ctx);
    }
    setState(2348);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 354, _ctx)) {
    case 1: {
      setState(2347);
      controlStructureBody();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DoWhileExpressionContext ------------------------------------------------------------------

myParser::DoWhileExpressionContext::DoWhileExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::DoWhileExpressionContext::DO() {
  return getToken(myParser::DO, 0);
}

tree::TerminalNode* myParser::DoWhileExpressionContext::WHILE() {
  return getToken(myParser::WHILE, 0);
}

tree::TerminalNode* myParser::DoWhileExpressionContext::LPAREN() {
  return getToken(myParser::LPAREN, 0);
}

myParser::ExpressionContext* myParser::DoWhileExpressionContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

tree::TerminalNode* myParser::DoWhileExpressionContext::RPAREN() {
  return getToken(myParser::RPAREN, 0);
}

std::vector<tree::TerminalNode *> myParser::DoWhileExpressionContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::DoWhileExpressionContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

myParser::ControlStructureBodyContext* myParser::DoWhileExpressionContext::controlStructureBody() {
  return getRuleContext<myParser::ControlStructureBodyContext>(0);
}


size_t myParser::DoWhileExpressionContext::getRuleIndex() const {
  return myParser::RuleDoWhileExpression;
}

void myParser::DoWhileExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoWhileExpression(this);
}

void myParser::DoWhileExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoWhileExpression(this);
}

myParser::DoWhileExpressionContext* myParser::doWhileExpression() {
  DoWhileExpressionContext *_localctx = _tracker.createInstance<DoWhileExpressionContext>(_ctx, getState());
  enterRule(_localctx, 222, myParser::RuleDoWhileExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2350);
    match(myParser::DO);
    setState(2354);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 355, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2351);
        match(myParser::NL); 
      }
      setState(2356);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 355, _ctx);
    }
    setState(2358);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 356, _ctx)) {
    case 1: {
      setState(2357);
      controlStructureBody();
      break;
    }

    default:
      break;
    }
    setState(2363);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(2360);
      match(myParser::NL);
      setState(2365);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2366);
    match(myParser::WHILE);
    setState(2370);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(2367);
      match(myParser::NL);
      setState(2372);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2373);
    match(myParser::LPAREN);
    setState(2374);
    expression();
    setState(2375);
    match(myParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JumpExpressionContext ------------------------------------------------------------------

myParser::JumpExpressionContext::JumpExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::JumpExpressionContext::THROW() {
  return getToken(myParser::THROW, 0);
}

myParser::ExpressionContext* myParser::JumpExpressionContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

std::vector<tree::TerminalNode *> myParser::JumpExpressionContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::JumpExpressionContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

tree::TerminalNode* myParser::JumpExpressionContext::RETURN() {
  return getToken(myParser::RETURN, 0);
}

tree::TerminalNode* myParser::JumpExpressionContext::RETURN_AT() {
  return getToken(myParser::RETURN_AT, 0);
}

tree::TerminalNode* myParser::JumpExpressionContext::CONTINUE() {
  return getToken(myParser::CONTINUE, 0);
}

tree::TerminalNode* myParser::JumpExpressionContext::CONTINUE_AT() {
  return getToken(myParser::CONTINUE_AT, 0);
}

tree::TerminalNode* myParser::JumpExpressionContext::BREAK() {
  return getToken(myParser::BREAK, 0);
}

tree::TerminalNode* myParser::JumpExpressionContext::BREAK_AT() {
  return getToken(myParser::BREAK_AT, 0);
}


size_t myParser::JumpExpressionContext::getRuleIndex() const {
  return myParser::RuleJumpExpression;
}

void myParser::JumpExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJumpExpression(this);
}

void myParser::JumpExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJumpExpression(this);
}

myParser::JumpExpressionContext* myParser::jumpExpression() {
  JumpExpressionContext *_localctx = _tracker.createInstance<JumpExpressionContext>(_ctx, getState());
  enterRule(_localctx, 224, myParser::RuleJumpExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(2393);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::THROW: {
        enterOuterAlt(_localctx, 1);
        setState(2377);
        match(myParser::THROW);
        setState(2381);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 359, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2378);
            match(myParser::NL); 
          }
          setState(2383);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 359, _ctx);
        }
        setState(2384);
        expression();
        break;
      }

      case myParser::RETURN_AT:
      case myParser::RETURN: {
        enterOuterAlt(_localctx, 2);
        setState(2385);
        _la = _input->LA(1);
        if (!(_la == myParser::RETURN_AT

        || _la == myParser::RETURN)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2387);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 360, _ctx)) {
        case 1: {
          setState(2386);
          expression();
          break;
        }

        default:
          break;
        }
        break;
      }

      case myParser::CONTINUE: {
        enterOuterAlt(_localctx, 3);
        setState(2389);
        match(myParser::CONTINUE);
        break;
      }

      case myParser::CONTINUE_AT: {
        enterOuterAlt(_localctx, 4);
        setState(2390);
        match(myParser::CONTINUE_AT);
        break;
      }

      case myParser::BREAK: {
        enterOuterAlt(_localctx, 5);
        setState(2391);
        match(myParser::BREAK);
        break;
      }

      case myParser::BREAK_AT: {
        enterOuterAlt(_localctx, 6);
        setState(2392);
        match(myParser::BREAK_AT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CallableReferenceContext ------------------------------------------------------------------

myParser::CallableReferenceContext::CallableReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::CallableReferenceContext::COLONCOLON() {
  return getToken(myParser::COLONCOLON, 0);
}

tree::TerminalNode* myParser::CallableReferenceContext::Q_COLONCOLON() {
  return getToken(myParser::Q_COLONCOLON, 0);
}

myParser::IdentifierContext* myParser::CallableReferenceContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

tree::TerminalNode* myParser::CallableReferenceContext::CLASS() {
  return getToken(myParser::CLASS, 0);
}

myParser::UserTypeContext* myParser::CallableReferenceContext::userType() {
  return getRuleContext<myParser::UserTypeContext>(0);
}

std::vector<tree::TerminalNode *> myParser::CallableReferenceContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::CallableReferenceContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

std::vector<tree::TerminalNode *> myParser::CallableReferenceContext::QUEST() {
  return getTokens(myParser::QUEST);
}

tree::TerminalNode* myParser::CallableReferenceContext::QUEST(size_t i) {
  return getToken(myParser::QUEST, i);
}


size_t myParser::CallableReferenceContext::getRuleIndex() const {
  return myParser::RuleCallableReference;
}

void myParser::CallableReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCallableReference(this);
}

void myParser::CallableReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCallableReference(this);
}

myParser::CallableReferenceContext* myParser::callableReference() {
  CallableReferenceContext *_localctx = _tracker.createInstance<CallableReferenceContext>(_ctx, getState());
  enterRule(_localctx, 226, myParser::RuleCallableReference);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2408);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la - 58) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 58)) & -33517921595647) != 0 || (((_la - 122) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 122)) & 262271) != 0) {
      setState(2395);
      userType();
      setState(2405);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::QUEST) {
        setState(2396);
        match(myParser::QUEST);
        setState(2400);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 362, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2397);
            match(myParser::NL); 
          }
          setState(2402);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 362, _ctx);
        }
        setState(2407);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(2413);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(2410);
      match(myParser::NL);
      setState(2415);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2416);
    _la = _input->LA(1);
    if (!(_la == myParser::COLONCOLON

    || _la == myParser::Q_COLONCOLON)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2420);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NL) {
      setState(2417);
      match(myParser::NL);
      setState(2422);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2425);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::IMPORT:
      case myParser::CONSTRUCTOR:
      case myParser::BY:
      case myParser::COMPANION:
      case myParser::INIT:
      case myParser::WHERE:
      case myParser::CATCH:
      case myParser::FINALLY:
      case myParser::OUT:
      case myParser::GETTER:
      case myParser::SETTER:
      case myParser::DYNAMIC:
      case myParser::PUBLIC:
      case myParser::PRIVATE:
      case myParser::PROTECTED:
      case myParser::INTERNAL:
      case myParser::ENUM:
      case myParser::SEALED:
      case myParser::ANNOTATION:
      case myParser::DATA:
      case myParser::INNER:
      case myParser::TAILREC:
      case myParser::OPERATOR:
      case myParser::INLINE:
      case myParser::INFIX:
      case myParser::EXTERNAL:
      case myParser::SUSPEND:
      case myParser::OVERRIDE:
      case myParser::ABSTRACT:
      case myParser::FINAL:
      case myParser::OPEN:
      case myParser::CONST:
      case myParser::LATEINIT:
      case myParser::VARARG:
      case myParser::NOINLINE:
      case myParser::CROSSINLINE:
      case myParser::REIFIED:
      case myParser::Identifier: {
        setState(2423);
        identifier();
        break;
      }

      case myParser::CLASS: {
        setState(2424);
        match(myParser::CLASS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentOperatorContext ------------------------------------------------------------------

myParser::AssignmentOperatorContext::AssignmentOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::AssignmentOperatorContext::ASSIGNMENT() {
  return getToken(myParser::ASSIGNMENT, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::ADD_ASSIGNMENT() {
  return getToken(myParser::ADD_ASSIGNMENT, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::SUB_ASSIGNMENT() {
  return getToken(myParser::SUB_ASSIGNMENT, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::MULT_ASSIGNMENT() {
  return getToken(myParser::MULT_ASSIGNMENT, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::DIV_ASSIGNMENT() {
  return getToken(myParser::DIV_ASSIGNMENT, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::MOD_ASSIGNMENT() {
  return getToken(myParser::MOD_ASSIGNMENT, 0);
}


size_t myParser::AssignmentOperatorContext::getRuleIndex() const {
  return myParser::RuleAssignmentOperator;
}

void myParser::AssignmentOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentOperator(this);
}

void myParser::AssignmentOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentOperator(this);
}

myParser::AssignmentOperatorContext* myParser::assignmentOperator() {
  AssignmentOperatorContext *_localctx = _tracker.createInstance<AssignmentOperatorContext>(_ctx, getState());
  enterRule(_localctx, 228, myParser::RuleAssignmentOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2427);
    _la = _input->LA(1);
    if (!(((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8455716864) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EqualityOperationContext ------------------------------------------------------------------

myParser::EqualityOperationContext::EqualityOperationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::EqualityOperationContext::EXCL_EQ() {
  return getToken(myParser::EXCL_EQ, 0);
}

tree::TerminalNode* myParser::EqualityOperationContext::EXCL_EQEQ() {
  return getToken(myParser::EXCL_EQEQ, 0);
}

tree::TerminalNode* myParser::EqualityOperationContext::EQEQ() {
  return getToken(myParser::EQEQ, 0);
}

tree::TerminalNode* myParser::EqualityOperationContext::EQEQEQ() {
  return getToken(myParser::EQEQEQ, 0);
}


size_t myParser::EqualityOperationContext::getRuleIndex() const {
  return myParser::RuleEqualityOperation;
}

void myParser::EqualityOperationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEqualityOperation(this);
}

void myParser::EqualityOperationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEqualityOperation(this);
}

myParser::EqualityOperationContext* myParser::equalityOperation() {
  EqualityOperationContext *_localctx = _tracker.createInstance<EqualityOperationContext>(_ctx, getState());
  enterRule(_localctx, 230, myParser::RuleEqualityOperation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2429);
    _la = _input->LA(1);
    if (!(((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 3799912185593856) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComparisonOperatorContext ------------------------------------------------------------------

myParser::ComparisonOperatorContext::ComparisonOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ComparisonOperatorContext::LANGLE() {
  return getToken(myParser::LANGLE, 0);
}

tree::TerminalNode* myParser::ComparisonOperatorContext::RANGLE() {
  return getToken(myParser::RANGLE, 0);
}

tree::TerminalNode* myParser::ComparisonOperatorContext::LE() {
  return getToken(myParser::LE, 0);
}

tree::TerminalNode* myParser::ComparisonOperatorContext::GE() {
  return getToken(myParser::GE, 0);
}


size_t myParser::ComparisonOperatorContext::getRuleIndex() const {
  return myParser::RuleComparisonOperator;
}

void myParser::ComparisonOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparisonOperator(this);
}

void myParser::ComparisonOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparisonOperator(this);
}

myParser::ComparisonOperatorContext* myParser::comparisonOperator() {
  ComparisonOperatorContext *_localctx = _tracker.createInstance<ComparisonOperatorContext>(_ctx, getState());
  enterRule(_localctx, 232, myParser::RuleComparisonOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2431);
    _la = _input->LA(1);
    if (!(((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 131941395333120) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InOperatorContext ------------------------------------------------------------------

myParser::InOperatorContext::InOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::InOperatorContext::IN() {
  return getToken(myParser::IN, 0);
}

tree::TerminalNode* myParser::InOperatorContext::NOT_IN() {
  return getToken(myParser::NOT_IN, 0);
}


size_t myParser::InOperatorContext::getRuleIndex() const {
  return myParser::RuleInOperator;
}

void myParser::InOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInOperator(this);
}

void myParser::InOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInOperator(this);
}

myParser::InOperatorContext* myParser::inOperator() {
  InOperatorContext *_localctx = _tracker.createInstance<InOperatorContext>(_ctx, getState());
  enterRule(_localctx, 234, myParser::RuleInOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2433);
    _la = _input->LA(1);
    if (!(_la == myParser::IN

    || _la == myParser::NOT_IN)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IsOperatorContext ------------------------------------------------------------------

myParser::IsOperatorContext::IsOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::IsOperatorContext::IS() {
  return getToken(myParser::IS, 0);
}

tree::TerminalNode* myParser::IsOperatorContext::NOT_IS() {
  return getToken(myParser::NOT_IS, 0);
}


size_t myParser::IsOperatorContext::getRuleIndex() const {
  return myParser::RuleIsOperator;
}

void myParser::IsOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIsOperator(this);
}

void myParser::IsOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIsOperator(this);
}

myParser::IsOperatorContext* myParser::isOperator() {
  IsOperatorContext *_localctx = _tracker.createInstance<IsOperatorContext>(_ctx, getState());
  enterRule(_localctx, 236, myParser::RuleIsOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2435);
    _la = _input->LA(1);
    if (!(_la == myParser::IS

    || _la == myParser::NOT_IS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AdditiveOperatorContext ------------------------------------------------------------------

myParser::AdditiveOperatorContext::AdditiveOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::AdditiveOperatorContext::ADD() {
  return getToken(myParser::ADD, 0);
}

tree::TerminalNode* myParser::AdditiveOperatorContext::SUB() {
  return getToken(myParser::SUB, 0);
}


size_t myParser::AdditiveOperatorContext::getRuleIndex() const {
  return myParser::RuleAdditiveOperator;
}

void myParser::AdditiveOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAdditiveOperator(this);
}

void myParser::AdditiveOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAdditiveOperator(this);
}

myParser::AdditiveOperatorContext* myParser::additiveOperator() {
  AdditiveOperatorContext *_localctx = _tracker.createInstance<AdditiveOperatorContext>(_ctx, getState());
  enterRule(_localctx, 238, myParser::RuleAdditiveOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2437);
    _la = _input->LA(1);
    if (!(_la == myParser::ADD

    || _la == myParser::SUB)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultiplicativeOperationContext ------------------------------------------------------------------

myParser::MultiplicativeOperationContext::MultiplicativeOperationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::MultiplicativeOperationContext::MULT() {
  return getToken(myParser::MULT, 0);
}

tree::TerminalNode* myParser::MultiplicativeOperationContext::DIV() {
  return getToken(myParser::DIV, 0);
}

tree::TerminalNode* myParser::MultiplicativeOperationContext::MOD() {
  return getToken(myParser::MOD, 0);
}


size_t myParser::MultiplicativeOperationContext::getRuleIndex() const {
  return myParser::RuleMultiplicativeOperation;
}

void myParser::MultiplicativeOperationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiplicativeOperation(this);
}

void myParser::MultiplicativeOperationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiplicativeOperation(this);
}

myParser::MultiplicativeOperationContext* myParser::multiplicativeOperation() {
  MultiplicativeOperationContext *_localctx = _tracker.createInstance<MultiplicativeOperationContext>(_ctx, getState());
  enterRule(_localctx, 240, myParser::RuleMultiplicativeOperation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2439);
    _la = _input->LA(1);
    if (!(((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 229376) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeOperationContext ------------------------------------------------------------------

myParser::TypeOperationContext::TypeOperationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TypeOperationContext::AS() {
  return getToken(myParser::AS, 0);
}

tree::TerminalNode* myParser::TypeOperationContext::AS_SAFE() {
  return getToken(myParser::AS_SAFE, 0);
}

tree::TerminalNode* myParser::TypeOperationContext::COLON() {
  return getToken(myParser::COLON, 0);
}


size_t myParser::TypeOperationContext::getRuleIndex() const {
  return myParser::RuleTypeOperation;
}

void myParser::TypeOperationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeOperation(this);
}

void myParser::TypeOperationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeOperation(this);
}

myParser::TypeOperationContext* myParser::typeOperation() {
  TypeOperationContext *_localctx = _tracker.createInstance<TypeOperationContext>(_ctx, getState());
  enterRule(_localctx, 242, myParser::RuleTypeOperation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2441);
    _la = _input->LA(1);
    if (!((((_la - 25) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 25)) & 4611686018444165121) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrefixUnaryOperationContext ------------------------------------------------------------------

myParser::PrefixUnaryOperationContext::PrefixUnaryOperationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::PrefixUnaryOperationContext::INCR() {
  return getToken(myParser::INCR, 0);
}

tree::TerminalNode* myParser::PrefixUnaryOperationContext::DECR() {
  return getToken(myParser::DECR, 0);
}

tree::TerminalNode* myParser::PrefixUnaryOperationContext::ADD() {
  return getToken(myParser::ADD, 0);
}

tree::TerminalNode* myParser::PrefixUnaryOperationContext::SUB() {
  return getToken(myParser::SUB, 0);
}

tree::TerminalNode* myParser::PrefixUnaryOperationContext::EXCL() {
  return getToken(myParser::EXCL, 0);
}

myParser::AnnotationsContext* myParser::PrefixUnaryOperationContext::annotations() {
  return getRuleContext<myParser::AnnotationsContext>(0);
}

myParser::LabelDefinitionContext* myParser::PrefixUnaryOperationContext::labelDefinition() {
  return getRuleContext<myParser::LabelDefinitionContext>(0);
}


size_t myParser::PrefixUnaryOperationContext::getRuleIndex() const {
  return myParser::RulePrefixUnaryOperation;
}

void myParser::PrefixUnaryOperationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrefixUnaryOperation(this);
}

void myParser::PrefixUnaryOperationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrefixUnaryOperation(this);
}

myParser::PrefixUnaryOperationContext* myParser::prefixUnaryOperation() {
  PrefixUnaryOperationContext *_localctx = _tracker.createInstance<PrefixUnaryOperationContext>(_ctx, getState());
  enterRule(_localctx, 244, myParser::RulePrefixUnaryOperation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2450);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::INCR: {
        enterOuterAlt(_localctx, 1);
        setState(2443);
        match(myParser::INCR);
        break;
      }

      case myParser::DECR: {
        enterOuterAlt(_localctx, 2);
        setState(2444);
        match(myParser::DECR);
        break;
      }

      case myParser::ADD: {
        enterOuterAlt(_localctx, 3);
        setState(2445);
        match(myParser::ADD);
        break;
      }

      case myParser::SUB: {
        enterOuterAlt(_localctx, 4);
        setState(2446);
        match(myParser::SUB);
        break;
      }

      case myParser::EXCL: {
        enterOuterAlt(_localctx, 5);
        setState(2447);
        match(myParser::EXCL);
        break;
      }

      case myParser::AT:
      case myParser::FILE:
      case myParser::FIELD:
      case myParser::PROPERTY:
      case myParser::GET:
      case myParser::SET:
      case myParser::RECEIVER:
      case myParser::PARAM:
      case myParser::SETPARAM:
      case myParser::DELEGATE:
      case myParser::LabelReference: {
        enterOuterAlt(_localctx, 6);
        setState(2448);
        annotations();
        break;
      }

      case myParser::LabelDefinition: {
        enterOuterAlt(_localctx, 7);
        setState(2449);
        labelDefinition();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PostfixUnaryOperationContext ------------------------------------------------------------------

myParser::PostfixUnaryOperationContext::PostfixUnaryOperationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::PostfixUnaryOperationContext::INCR() {
  return getToken(myParser::INCR, 0);
}

tree::TerminalNode* myParser::PostfixUnaryOperationContext::DECR() {
  return getToken(myParser::DECR, 0);
}

std::vector<tree::TerminalNode *> myParser::PostfixUnaryOperationContext::EXCL() {
  return getTokens(myParser::EXCL);
}

tree::TerminalNode* myParser::PostfixUnaryOperationContext::EXCL(size_t i) {
  return getToken(myParser::EXCL, i);
}

myParser::CallSuffixContext* myParser::PostfixUnaryOperationContext::callSuffix() {
  return getRuleContext<myParser::CallSuffixContext>(0);
}

myParser::ArrayAccessContext* myParser::PostfixUnaryOperationContext::arrayAccess() {
  return getRuleContext<myParser::ArrayAccessContext>(0);
}

myParser::MemberAccessOperatorContext* myParser::PostfixUnaryOperationContext::memberAccessOperator() {
  return getRuleContext<myParser::MemberAccessOperatorContext>(0);
}

myParser::PostfixUnaryExpressionContext* myParser::PostfixUnaryOperationContext::postfixUnaryExpression() {
  return getRuleContext<myParser::PostfixUnaryExpressionContext>(0);
}

std::vector<tree::TerminalNode *> myParser::PostfixUnaryOperationContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::PostfixUnaryOperationContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::PostfixUnaryOperationContext::getRuleIndex() const {
  return myParser::RulePostfixUnaryOperation;
}

void myParser::PostfixUnaryOperationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostfixUnaryOperation(this);
}

void myParser::PostfixUnaryOperationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostfixUnaryOperation(this);
}

myParser::PostfixUnaryOperationContext* myParser::postfixUnaryOperation() {
  PostfixUnaryOperationContext *_localctx = _tracker.createInstance<PostfixUnaryOperationContext>(_ctx, getState());
  enterRule(_localctx, 246, myParser::RulePostfixUnaryOperation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2467);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 370, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2452);
      match(myParser::INCR);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2453);
      match(myParser::DECR);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2454);
      match(myParser::EXCL);
      setState(2455);
      match(myParser::EXCL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2456);
      callSuffix();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2457);
      arrayAccess();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2461);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(2458);
        match(myParser::NL);
        setState(2463);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2464);
      memberAccessOperator();
      setState(2465);
      postfixUnaryExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MemberAccessOperatorContext ------------------------------------------------------------------

myParser::MemberAccessOperatorContext::MemberAccessOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::MemberAccessOperatorContext::DOT() {
  return getToken(myParser::DOT, 0);
}

tree::TerminalNode* myParser::MemberAccessOperatorContext::QUEST() {
  return getToken(myParser::QUEST, 0);
}


size_t myParser::MemberAccessOperatorContext::getRuleIndex() const {
  return myParser::RuleMemberAccessOperator;
}

void myParser::MemberAccessOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemberAccessOperator(this);
}

void myParser::MemberAccessOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemberAccessOperator(this);
}

myParser::MemberAccessOperatorContext* myParser::memberAccessOperator() {
  MemberAccessOperatorContext *_localctx = _tracker.createInstance<MemberAccessOperatorContext>(_ctx, getState());
  enterRule(_localctx, 248, myParser::RuleMemberAccessOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2472);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::DOT: {
        enterOuterAlt(_localctx, 1);
        setState(2469);
        match(myParser::DOT);
        break;
      }

      case myParser::QUEST: {
        enterOuterAlt(_localctx, 2);
        setState(2470);
        match(myParser::QUEST);
        setState(2471);
        match(myParser::DOT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModifierListContext ------------------------------------------------------------------

myParser::ModifierListContext::ModifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::AnnotationsContext *> myParser::ModifierListContext::annotations() {
  return getRuleContexts<myParser::AnnotationsContext>();
}

myParser::AnnotationsContext* myParser::ModifierListContext::annotations(size_t i) {
  return getRuleContext<myParser::AnnotationsContext>(i);
}

std::vector<myParser::ModifierContext *> myParser::ModifierListContext::modifier() {
  return getRuleContexts<myParser::ModifierContext>();
}

myParser::ModifierContext* myParser::ModifierListContext::modifier(size_t i) {
  return getRuleContext<myParser::ModifierContext>(i);
}


size_t myParser::ModifierListContext::getRuleIndex() const {
  return myParser::RuleModifierList;
}

void myParser::ModifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModifierList(this);
}

void myParser::ModifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModifierList(this);
}

myParser::ModifierListContext* myParser::modifierList() {
  ModifierListContext *_localctx = _tracker.createInstance<ModifierListContext>(_ctx, getState());
  enterRule(_localctx, 250, myParser::RuleModifierList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2476); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(2476);
              _errHandler->sync(this);
              switch (_input->LA(1)) {
                case myParser::AT:
                case myParser::FILE:
                case myParser::FIELD:
                case myParser::PROPERTY:
                case myParser::GET:
                case myParser::SET:
                case myParser::RECEIVER:
                case myParser::PARAM:
                case myParser::SETPARAM:
                case myParser::DELEGATE:
                case myParser::LabelReference: {
                  setState(2474);
                  annotations();
                  break;
                }

                case myParser::IN:
                case myParser::OUT:
                case myParser::PUBLIC:
                case myParser::PRIVATE:
                case myParser::PROTECTED:
                case myParser::INTERNAL:
                case myParser::ENUM:
                case myParser::SEALED:
                case myParser::ANNOTATION:
                case myParser::DATA:
                case myParser::INNER:
                case myParser::TAILREC:
                case myParser::OPERATOR:
                case myParser::INLINE:
                case myParser::INFIX:
                case myParser::EXTERNAL:
                case myParser::SUSPEND:
                case myParser::OVERRIDE:
                case myParser::ABSTRACT:
                case myParser::FINAL:
                case myParser::OPEN:
                case myParser::CONST:
                case myParser::LATEINIT:
                case myParser::VARARG:
                case myParser::NOINLINE:
                case myParser::CROSSINLINE:
                case myParser::REIFIED: {
                  setState(2475);
                  modifier();
                  break;
                }

              default:
                throw NoViableAltException(this);
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(2478); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 373, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModifierContext ------------------------------------------------------------------

myParser::ModifierContext::ModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ClassModifierContext* myParser::ModifierContext::classModifier() {
  return getRuleContext<myParser::ClassModifierContext>(0);
}

myParser::MemberModifierContext* myParser::ModifierContext::memberModifier() {
  return getRuleContext<myParser::MemberModifierContext>(0);
}

myParser::VisibilityModifierContext* myParser::ModifierContext::visibilityModifier() {
  return getRuleContext<myParser::VisibilityModifierContext>(0);
}

myParser::VarianceAnnotationContext* myParser::ModifierContext::varianceAnnotation() {
  return getRuleContext<myParser::VarianceAnnotationContext>(0);
}

myParser::FunctionModifierContext* myParser::ModifierContext::functionModifier() {
  return getRuleContext<myParser::FunctionModifierContext>(0);
}

myParser::PropertyModifierContext* myParser::ModifierContext::propertyModifier() {
  return getRuleContext<myParser::PropertyModifierContext>(0);
}

myParser::InheritanceModifierContext* myParser::ModifierContext::inheritanceModifier() {
  return getRuleContext<myParser::InheritanceModifierContext>(0);
}

myParser::ParameterModifierContext* myParser::ModifierContext::parameterModifier() {
  return getRuleContext<myParser::ParameterModifierContext>(0);
}

myParser::TypeParameterModifierContext* myParser::ModifierContext::typeParameterModifier() {
  return getRuleContext<myParser::TypeParameterModifierContext>(0);
}

std::vector<tree::TerminalNode *> myParser::ModifierContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::ModifierContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::ModifierContext::getRuleIndex() const {
  return myParser::RuleModifier;
}

void myParser::ModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModifier(this);
}

void myParser::ModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModifier(this);
}

myParser::ModifierContext* myParser::modifier() {
  ModifierContext *_localctx = _tracker.createInstance<ModifierContext>(_ctx, getState());
  enterRule(_localctx, 252, myParser::RuleModifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2489);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::ENUM:
      case myParser::SEALED:
      case myParser::ANNOTATION:
      case myParser::DATA:
      case myParser::INNER: {
        setState(2480);
        classModifier();
        break;
      }

      case myParser::OVERRIDE:
      case myParser::LATEINIT: {
        setState(2481);
        memberModifier();
        break;
      }

      case myParser::PUBLIC:
      case myParser::PRIVATE:
      case myParser::PROTECTED:
      case myParser::INTERNAL: {
        setState(2482);
        visibilityModifier();
        break;
      }

      case myParser::IN:
      case myParser::OUT: {
        setState(2483);
        varianceAnnotation();
        break;
      }

      case myParser::TAILREC:
      case myParser::OPERATOR:
      case myParser::INLINE:
      case myParser::INFIX:
      case myParser::EXTERNAL:
      case myParser::SUSPEND: {
        setState(2484);
        functionModifier();
        break;
      }

      case myParser::CONST: {
        setState(2485);
        propertyModifier();
        break;
      }

      case myParser::ABSTRACT:
      case myParser::FINAL:
      case myParser::OPEN: {
        setState(2486);
        inheritanceModifier();
        break;
      }

      case myParser::VARARG:
      case myParser::NOINLINE:
      case myParser::CROSSINLINE: {
        setState(2487);
        parameterModifier();
        break;
      }

      case myParser::REIFIED: {
        setState(2488);
        typeParameterModifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2494);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 375, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2491);
        match(myParser::NL); 
      }
      setState(2496);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 375, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassModifierContext ------------------------------------------------------------------

myParser::ClassModifierContext::ClassModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ClassModifierContext::ENUM() {
  return getToken(myParser::ENUM, 0);
}

tree::TerminalNode* myParser::ClassModifierContext::SEALED() {
  return getToken(myParser::SEALED, 0);
}

tree::TerminalNode* myParser::ClassModifierContext::ANNOTATION() {
  return getToken(myParser::ANNOTATION, 0);
}

tree::TerminalNode* myParser::ClassModifierContext::DATA() {
  return getToken(myParser::DATA, 0);
}

tree::TerminalNode* myParser::ClassModifierContext::INNER() {
  return getToken(myParser::INNER, 0);
}


size_t myParser::ClassModifierContext::getRuleIndex() const {
  return myParser::RuleClassModifier;
}

void myParser::ClassModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassModifier(this);
}

void myParser::ClassModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassModifier(this);
}

myParser::ClassModifierContext* myParser::classModifier() {
  ClassModifierContext *_localctx = _tracker.createInstance<ClassModifierContext>(_ctx, getState());
  enterRule(_localctx, 254, myParser::RuleClassModifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2497);
    _la = _input->LA(1);
    if (!((((_la - 108) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 108)) & 31) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MemberModifierContext ------------------------------------------------------------------

myParser::MemberModifierContext::MemberModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::MemberModifierContext::OVERRIDE() {
  return getToken(myParser::OVERRIDE, 0);
}

tree::TerminalNode* myParser::MemberModifierContext::LATEINIT() {
  return getToken(myParser::LATEINIT, 0);
}


size_t myParser::MemberModifierContext::getRuleIndex() const {
  return myParser::RuleMemberModifier;
}

void myParser::MemberModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemberModifier(this);
}

void myParser::MemberModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemberModifier(this);
}

myParser::MemberModifierContext* myParser::memberModifier() {
  MemberModifierContext *_localctx = _tracker.createInstance<MemberModifierContext>(_ctx, getState());
  enterRule(_localctx, 256, myParser::RuleMemberModifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2499);
    _la = _input->LA(1);
    if (!(_la == myParser::OVERRIDE

    || _la == myParser::LATEINIT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VisibilityModifierContext ------------------------------------------------------------------

myParser::VisibilityModifierContext::VisibilityModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::VisibilityModifierContext::PUBLIC() {
  return getToken(myParser::PUBLIC, 0);
}

tree::TerminalNode* myParser::VisibilityModifierContext::PRIVATE() {
  return getToken(myParser::PRIVATE, 0);
}

tree::TerminalNode* myParser::VisibilityModifierContext::INTERNAL() {
  return getToken(myParser::INTERNAL, 0);
}

tree::TerminalNode* myParser::VisibilityModifierContext::PROTECTED() {
  return getToken(myParser::PROTECTED, 0);
}


size_t myParser::VisibilityModifierContext::getRuleIndex() const {
  return myParser::RuleVisibilityModifier;
}

void myParser::VisibilityModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVisibilityModifier(this);
}

void myParser::VisibilityModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVisibilityModifier(this);
}

myParser::VisibilityModifierContext* myParser::visibilityModifier() {
  VisibilityModifierContext *_localctx = _tracker.createInstance<VisibilityModifierContext>(_ctx, getState());
  enterRule(_localctx, 258, myParser::RuleVisibilityModifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2501);
    _la = _input->LA(1);
    if (!((((_la - 104) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 104)) & 15) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarianceAnnotationContext ------------------------------------------------------------------

myParser::VarianceAnnotationContext::VarianceAnnotationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::VarianceAnnotationContext::IN() {
  return getToken(myParser::IN, 0);
}

tree::TerminalNode* myParser::VarianceAnnotationContext::OUT() {
  return getToken(myParser::OUT, 0);
}


size_t myParser::VarianceAnnotationContext::getRuleIndex() const {
  return myParser::RuleVarianceAnnotation;
}

void myParser::VarianceAnnotationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarianceAnnotation(this);
}

void myParser::VarianceAnnotationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarianceAnnotation(this);
}

myParser::VarianceAnnotationContext* myParser::varianceAnnotation() {
  VarianceAnnotationContext *_localctx = _tracker.createInstance<VarianceAnnotationContext>(_ctx, getState());
  enterRule(_localctx, 260, myParser::RuleVarianceAnnotation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2503);
    _la = _input->LA(1);
    if (!(_la == myParser::IN

    || _la == myParser::OUT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionModifierContext ------------------------------------------------------------------

myParser::FunctionModifierContext::FunctionModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::FunctionModifierContext::TAILREC() {
  return getToken(myParser::TAILREC, 0);
}

tree::TerminalNode* myParser::FunctionModifierContext::OPERATOR() {
  return getToken(myParser::OPERATOR, 0);
}

tree::TerminalNode* myParser::FunctionModifierContext::INFIX() {
  return getToken(myParser::INFIX, 0);
}

tree::TerminalNode* myParser::FunctionModifierContext::INLINE() {
  return getToken(myParser::INLINE, 0);
}

tree::TerminalNode* myParser::FunctionModifierContext::EXTERNAL() {
  return getToken(myParser::EXTERNAL, 0);
}

tree::TerminalNode* myParser::FunctionModifierContext::SUSPEND() {
  return getToken(myParser::SUSPEND, 0);
}


size_t myParser::FunctionModifierContext::getRuleIndex() const {
  return myParser::RuleFunctionModifier;
}

void myParser::FunctionModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionModifier(this);
}

void myParser::FunctionModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionModifier(this);
}

myParser::FunctionModifierContext* myParser::functionModifier() {
  FunctionModifierContext *_localctx = _tracker.createInstance<FunctionModifierContext>(_ctx, getState());
  enterRule(_localctx, 262, myParser::RuleFunctionModifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2505);
    _la = _input->LA(1);
    if (!((((_la - 113) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 113)) & 63) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyModifierContext ------------------------------------------------------------------

myParser::PropertyModifierContext::PropertyModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::PropertyModifierContext::CONST() {
  return getToken(myParser::CONST, 0);
}


size_t myParser::PropertyModifierContext::getRuleIndex() const {
  return myParser::RulePropertyModifier;
}

void myParser::PropertyModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyModifier(this);
}

void myParser::PropertyModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyModifier(this);
}

myParser::PropertyModifierContext* myParser::propertyModifier() {
  PropertyModifierContext *_localctx = _tracker.createInstance<PropertyModifierContext>(_ctx, getState());
  enterRule(_localctx, 264, myParser::RulePropertyModifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2507);
    match(myParser::CONST);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InheritanceModifierContext ------------------------------------------------------------------

myParser::InheritanceModifierContext::InheritanceModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::InheritanceModifierContext::ABSTRACT() {
  return getToken(myParser::ABSTRACT, 0);
}

tree::TerminalNode* myParser::InheritanceModifierContext::FINAL() {
  return getToken(myParser::FINAL, 0);
}

tree::TerminalNode* myParser::InheritanceModifierContext::OPEN() {
  return getToken(myParser::OPEN, 0);
}


size_t myParser::InheritanceModifierContext::getRuleIndex() const {
  return myParser::RuleInheritanceModifier;
}

void myParser::InheritanceModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInheritanceModifier(this);
}

void myParser::InheritanceModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInheritanceModifier(this);
}

myParser::InheritanceModifierContext* myParser::inheritanceModifier() {
  InheritanceModifierContext *_localctx = _tracker.createInstance<InheritanceModifierContext>(_ctx, getState());
  enterRule(_localctx, 266, myParser::RuleInheritanceModifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2509);
    _la = _input->LA(1);
    if (!((((_la - 120) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 120)) & 7) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterModifierContext ------------------------------------------------------------------

myParser::ParameterModifierContext::ParameterModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ParameterModifierContext::VARARG() {
  return getToken(myParser::VARARG, 0);
}

tree::TerminalNode* myParser::ParameterModifierContext::NOINLINE() {
  return getToken(myParser::NOINLINE, 0);
}

tree::TerminalNode* myParser::ParameterModifierContext::CROSSINLINE() {
  return getToken(myParser::CROSSINLINE, 0);
}


size_t myParser::ParameterModifierContext::getRuleIndex() const {
  return myParser::RuleParameterModifier;
}

void myParser::ParameterModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameterModifier(this);
}

void myParser::ParameterModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameterModifier(this);
}

myParser::ParameterModifierContext* myParser::parameterModifier() {
  ParameterModifierContext *_localctx = _tracker.createInstance<ParameterModifierContext>(_ctx, getState());
  enterRule(_localctx, 268, myParser::RuleParameterModifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2511);
    _la = _input->LA(1);
    if (!((((_la - 125) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 125)) & 7) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeParameterModifierContext ------------------------------------------------------------------

myParser::TypeParameterModifierContext::TypeParameterModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TypeParameterModifierContext::REIFIED() {
  return getToken(myParser::REIFIED, 0);
}


size_t myParser::TypeParameterModifierContext::getRuleIndex() const {
  return myParser::RuleTypeParameterModifier;
}

void myParser::TypeParameterModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeParameterModifier(this);
}

void myParser::TypeParameterModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeParameterModifier(this);
}

myParser::TypeParameterModifierContext* myParser::typeParameterModifier() {
  TypeParameterModifierContext *_localctx = _tracker.createInstance<TypeParameterModifierContext>(_ctx, getState());
  enterRule(_localctx, 270, myParser::RuleTypeParameterModifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2513);
    match(myParser::REIFIED);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelDefinitionContext ------------------------------------------------------------------

myParser::LabelDefinitionContext::LabelDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::LabelDefinitionContext::LabelDefinition() {
  return getToken(myParser::LabelDefinition, 0);
}

std::vector<tree::TerminalNode *> myParser::LabelDefinitionContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::LabelDefinitionContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::LabelDefinitionContext::getRuleIndex() const {
  return myParser::RuleLabelDefinition;
}

void myParser::LabelDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabelDefinition(this);
}

void myParser::LabelDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabelDefinition(this);
}

myParser::LabelDefinitionContext* myParser::labelDefinition() {
  LabelDefinitionContext *_localctx = _tracker.createInstance<LabelDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 272, myParser::RuleLabelDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2515);
    match(myParser::LabelDefinition);
    setState(2519);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 376, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2516);
        match(myParser::NL); 
      }
      setState(2521);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 376, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnnotationsContext ------------------------------------------------------------------

myParser::AnnotationsContext::AnnotationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::AnnotationContext* myParser::AnnotationsContext::annotation() {
  return getRuleContext<myParser::AnnotationContext>(0);
}

myParser::AnnotationListContext* myParser::AnnotationsContext::annotationList() {
  return getRuleContext<myParser::AnnotationListContext>(0);
}

std::vector<tree::TerminalNode *> myParser::AnnotationsContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::AnnotationsContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::AnnotationsContext::getRuleIndex() const {
  return myParser::RuleAnnotations;
}

void myParser::AnnotationsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnnotations(this);
}

void myParser::AnnotationsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnnotations(this);
}

myParser::AnnotationsContext* myParser::annotations() {
  AnnotationsContext *_localctx = _tracker.createInstance<AnnotationsContext>(_ctx, getState());
  enterRule(_localctx, 274, myParser::RuleAnnotations);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2524);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 377, _ctx)) {
    case 1: {
      setState(2522);
      annotation();
      break;
    }

    case 2: {
      setState(2523);
      annotationList();
      break;
    }

    default:
      break;
    }
    setState(2529);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 378, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2526);
        match(myParser::NL); 
      }
      setState(2531);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 378, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnnotationContext ------------------------------------------------------------------

myParser::AnnotationContext::AnnotationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::AnnotationUseSiteTargetContext* myParser::AnnotationContext::annotationUseSiteTarget() {
  return getRuleContext<myParser::AnnotationUseSiteTargetContext>(0);
}

tree::TerminalNode* myParser::AnnotationContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::UnescapedAnnotationContext* myParser::AnnotationContext::unescapedAnnotation() {
  return getRuleContext<myParser::UnescapedAnnotationContext>(0);
}

std::vector<tree::TerminalNode *> myParser::AnnotationContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::AnnotationContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

tree::TerminalNode* myParser::AnnotationContext::LabelReference() {
  return getToken(myParser::LabelReference, 0);
}

myParser::TypeArgumentsContext* myParser::AnnotationContext::typeArguments() {
  return getRuleContext<myParser::TypeArgumentsContext>(0);
}

myParser::ValueArgumentsContext* myParser::AnnotationContext::valueArguments() {
  return getRuleContext<myParser::ValueArgumentsContext>(0);
}


size_t myParser::AnnotationContext::getRuleIndex() const {
  return myParser::RuleAnnotation;
}

void myParser::AnnotationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnnotation(this);
}

void myParser::AnnotationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnnotation(this);
}

myParser::AnnotationContext* myParser::annotation() {
  AnnotationContext *_localctx = _tracker.createInstance<AnnotationContext>(_ctx, getState());
  enterRule(_localctx, 276, myParser::RuleAnnotation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2567);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::FILE:
      case myParser::FIELD:
      case myParser::PROPERTY:
      case myParser::GET:
      case myParser::SET:
      case myParser::RECEIVER:
      case myParser::PARAM:
      case myParser::SETPARAM:
      case myParser::DELEGATE: {
        enterOuterAlt(_localctx, 1);
        setState(2532);
        annotationUseSiteTarget();
        setState(2536);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(2533);
          match(myParser::NL);
          setState(2538);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2539);
        match(myParser::COLON);
        setState(2543);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(2540);
          match(myParser::NL);
          setState(2545);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2546);
        unescapedAnnotation();
        break;
      }

      case myParser::LabelReference: {
        enterOuterAlt(_localctx, 2);
        setState(2548);
        match(myParser::LabelReference);
        setState(2556);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 382, _ctx)) {
        case 1: {
          setState(2552);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == myParser::NL) {
            setState(2549);
            match(myParser::NL);
            setState(2554);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(2555);
          typeArguments();
          break;
        }

        default:
          break;
        }
        setState(2565);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 384, _ctx)) {
        case 1: {
          setState(2561);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == myParser::NL) {
            setState(2558);
            match(myParser::NL);
            setState(2563);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(2564);
          valueArguments();
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnnotationListContext ------------------------------------------------------------------

myParser::AnnotationListContext::AnnotationListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::AnnotationUseSiteTargetContext* myParser::AnnotationListContext::annotationUseSiteTarget() {
  return getRuleContext<myParser::AnnotationUseSiteTargetContext>(0);
}

tree::TerminalNode* myParser::AnnotationListContext::COLON() {
  return getToken(myParser::COLON, 0);
}

tree::TerminalNode* myParser::AnnotationListContext::LSQUARE() {
  return getToken(myParser::LSQUARE, 0);
}

tree::TerminalNode* myParser::AnnotationListContext::RSQUARE() {
  return getToken(myParser::RSQUARE, 0);
}

std::vector<myParser::UnescapedAnnotationContext *> myParser::AnnotationListContext::unescapedAnnotation() {
  return getRuleContexts<myParser::UnescapedAnnotationContext>();
}

myParser::UnescapedAnnotationContext* myParser::AnnotationListContext::unescapedAnnotation(size_t i) {
  return getRuleContext<myParser::UnescapedAnnotationContext>(i);
}

tree::TerminalNode* myParser::AnnotationListContext::AT() {
  return getToken(myParser::AT, 0);
}


size_t myParser::AnnotationListContext::getRuleIndex() const {
  return myParser::RuleAnnotationList;
}

void myParser::AnnotationListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnnotationList(this);
}

void myParser::AnnotationListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnnotationList(this);
}

myParser::AnnotationListContext* myParser::annotationList() {
  AnnotationListContext *_localctx = _tracker.createInstance<AnnotationListContext>(_ctx, getState());
  enterRule(_localctx, 278, myParser::RuleAnnotationList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2588);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::FILE:
      case myParser::FIELD:
      case myParser::PROPERTY:
      case myParser::GET:
      case myParser::SET:
      case myParser::RECEIVER:
      case myParser::PARAM:
      case myParser::SETPARAM:
      case myParser::DELEGATE: {
        enterOuterAlt(_localctx, 1);
        setState(2569);
        annotationUseSiteTarget();
        setState(2570);
        match(myParser::COLON);
        setState(2571);
        match(myParser::LSQUARE);
        setState(2573); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(2572);
          unescapedAnnotation();
          setState(2575); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la - 58) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 58)) & -33517921595647) != 0 || (((_la - 122) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 122)) & 262271) != 0);
        setState(2577);
        match(myParser::RSQUARE);
        break;
      }

      case myParser::AT: {
        enterOuterAlt(_localctx, 2);
        setState(2579);
        match(myParser::AT);
        setState(2580);
        match(myParser::LSQUARE);
        setState(2582); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(2581);
          unescapedAnnotation();
          setState(2584); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la - 58) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 58)) & -33517921595647) != 0 || (((_la - 122) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 122)) & 262271) != 0);
        setState(2586);
        match(myParser::RSQUARE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnnotationUseSiteTargetContext ------------------------------------------------------------------

myParser::AnnotationUseSiteTargetContext::AnnotationUseSiteTargetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::AnnotationUseSiteTargetContext::FIELD() {
  return getToken(myParser::FIELD, 0);
}

tree::TerminalNode* myParser::AnnotationUseSiteTargetContext::FILE() {
  return getToken(myParser::FILE, 0);
}

tree::TerminalNode* myParser::AnnotationUseSiteTargetContext::PROPERTY() {
  return getToken(myParser::PROPERTY, 0);
}

tree::TerminalNode* myParser::AnnotationUseSiteTargetContext::GET() {
  return getToken(myParser::GET, 0);
}

tree::TerminalNode* myParser::AnnotationUseSiteTargetContext::SET() {
  return getToken(myParser::SET, 0);
}

tree::TerminalNode* myParser::AnnotationUseSiteTargetContext::RECEIVER() {
  return getToken(myParser::RECEIVER, 0);
}

tree::TerminalNode* myParser::AnnotationUseSiteTargetContext::PARAM() {
  return getToken(myParser::PARAM, 0);
}

tree::TerminalNode* myParser::AnnotationUseSiteTargetContext::SETPARAM() {
  return getToken(myParser::SETPARAM, 0);
}

tree::TerminalNode* myParser::AnnotationUseSiteTargetContext::DELEGATE() {
  return getToken(myParser::DELEGATE, 0);
}


size_t myParser::AnnotationUseSiteTargetContext::getRuleIndex() const {
  return myParser::RuleAnnotationUseSiteTarget;
}

void myParser::AnnotationUseSiteTargetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnnotationUseSiteTarget(this);
}

void myParser::AnnotationUseSiteTargetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnnotationUseSiteTarget(this);
}

myParser::AnnotationUseSiteTargetContext* myParser::annotationUseSiteTarget() {
  AnnotationUseSiteTargetContext *_localctx = _tracker.createInstance<AnnotationUseSiteTargetContext>(_ctx, getState());
  enterRule(_localctx, 280, myParser::RuleAnnotationUseSiteTarget);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2590);
    _la = _input->LA(1);
    if (!((((_la - 56) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 56)) & 134002979635201) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnescapedAnnotationContext ------------------------------------------------------------------

myParser::UnescapedAnnotationContext::UnescapedAnnotationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierContext* myParser::UnescapedAnnotationContext::identifier() {
  return getRuleContext<myParser::IdentifierContext>(0);
}

myParser::TypeArgumentsContext* myParser::UnescapedAnnotationContext::typeArguments() {
  return getRuleContext<myParser::TypeArgumentsContext>(0);
}

myParser::ValueArgumentsContext* myParser::UnescapedAnnotationContext::valueArguments() {
  return getRuleContext<myParser::ValueArgumentsContext>(0);
}


size_t myParser::UnescapedAnnotationContext::getRuleIndex() const {
  return myParser::RuleUnescapedAnnotation;
}

void myParser::UnescapedAnnotationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnescapedAnnotation(this);
}

void myParser::UnescapedAnnotationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnescapedAnnotation(this);
}

myParser::UnescapedAnnotationContext* myParser::unescapedAnnotation() {
  UnescapedAnnotationContext *_localctx = _tracker.createInstance<UnescapedAnnotationContext>(_ctx, getState());
  enterRule(_localctx, 282, myParser::RuleUnescapedAnnotation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2592);
    identifier();
    setState(2594);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LANGLE) {
      setState(2593);
      typeArguments();
    }
    setState(2597);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 390, _ctx)) {
    case 1: {
      setState(2596);
      valueArguments();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

myParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::SimpleIdentifierContext *> myParser::IdentifierContext::simpleIdentifier() {
  return getRuleContexts<myParser::SimpleIdentifierContext>();
}

myParser::SimpleIdentifierContext* myParser::IdentifierContext::simpleIdentifier(size_t i) {
  return getRuleContext<myParser::SimpleIdentifierContext>(i);
}

std::vector<tree::TerminalNode *> myParser::IdentifierContext::DOT() {
  return getTokens(myParser::DOT);
}

tree::TerminalNode* myParser::IdentifierContext::DOT(size_t i) {
  return getToken(myParser::DOT, i);
}

std::vector<tree::TerminalNode *> myParser::IdentifierContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::IdentifierContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}


size_t myParser::IdentifierContext::getRuleIndex() const {
  return myParser::RuleIdentifier;
}

void myParser::IdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier(this);
}

void myParser::IdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier(this);
}

myParser::IdentifierContext* myParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 284, myParser::RuleIdentifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2599);
    simpleIdentifier();
    setState(2610);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 392, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2603);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::NL) {
          setState(2600);
          match(myParser::NL);
          setState(2605);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2606);
        match(myParser::DOT);
        setState(2607);
        simpleIdentifier(); 
      }
      setState(2612);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 392, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleIdentifierContext ------------------------------------------------------------------

myParser::SimpleIdentifierContext::SimpleIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::SimpleIdentifierContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::ABSTRACT() {
  return getToken(myParser::ABSTRACT, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::ANNOTATION() {
  return getToken(myParser::ANNOTATION, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::BY() {
  return getToken(myParser::BY, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::CATCH() {
  return getToken(myParser::CATCH, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::COMPANION() {
  return getToken(myParser::COMPANION, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::CONSTRUCTOR() {
  return getToken(myParser::CONSTRUCTOR, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::CROSSINLINE() {
  return getToken(myParser::CROSSINLINE, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::DATA() {
  return getToken(myParser::DATA, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::DYNAMIC() {
  return getToken(myParser::DYNAMIC, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::ENUM() {
  return getToken(myParser::ENUM, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::EXTERNAL() {
  return getToken(myParser::EXTERNAL, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::FINAL() {
  return getToken(myParser::FINAL, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::FINALLY() {
  return getToken(myParser::FINALLY, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::GETTER() {
  return getToken(myParser::GETTER, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::IMPORT() {
  return getToken(myParser::IMPORT, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::INFIX() {
  return getToken(myParser::INFIX, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::INIT() {
  return getToken(myParser::INIT, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::INLINE() {
  return getToken(myParser::INLINE, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::INNER() {
  return getToken(myParser::INNER, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::INTERNAL() {
  return getToken(myParser::INTERNAL, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::LATEINIT() {
  return getToken(myParser::LATEINIT, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::NOINLINE() {
  return getToken(myParser::NOINLINE, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::OPEN() {
  return getToken(myParser::OPEN, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::OPERATOR() {
  return getToken(myParser::OPERATOR, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::OUT() {
  return getToken(myParser::OUT, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::OVERRIDE() {
  return getToken(myParser::OVERRIDE, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::PRIVATE() {
  return getToken(myParser::PRIVATE, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::PROTECTED() {
  return getToken(myParser::PROTECTED, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::PUBLIC() {
  return getToken(myParser::PUBLIC, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::REIFIED() {
  return getToken(myParser::REIFIED, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::SEALED() {
  return getToken(myParser::SEALED, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::TAILREC() {
  return getToken(myParser::TAILREC, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::SETTER() {
  return getToken(myParser::SETTER, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::VARARG() {
  return getToken(myParser::VARARG, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::WHERE() {
  return getToken(myParser::WHERE, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::CONST() {
  return getToken(myParser::CONST, 0);
}

tree::TerminalNode* myParser::SimpleIdentifierContext::SUSPEND() {
  return getToken(myParser::SUSPEND, 0);
}


size_t myParser::SimpleIdentifierContext::getRuleIndex() const {
  return myParser::RuleSimpleIdentifier;
}

void myParser::SimpleIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleIdentifier(this);
}

void myParser::SimpleIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleIdentifier(this);
}

myParser::SimpleIdentifierContext* myParser::simpleIdentifier() {
  SimpleIdentifierContext *_localctx = _tracker.createInstance<SimpleIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 286, myParser::RuleSimpleIdentifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2613);
    _la = _input->LA(1);
    if (!((((_la - 58) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 58)) & -33517921595647) != 0 || (((_la - 122) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 122)) & 262271) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SemiContext ------------------------------------------------------------------

myParser::SemiContext::SemiContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> myParser::SemiContext::NL() {
  return getTokens(myParser::NL);
}

tree::TerminalNode* myParser::SemiContext::NL(size_t i) {
  return getToken(myParser::NL, i);
}

tree::TerminalNode* myParser::SemiContext::SEMICOLON() {
  return getToken(myParser::SEMICOLON, 0);
}


size_t myParser::SemiContext::getRuleIndex() const {
  return myParser::RuleSemi;
}

void myParser::SemiContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSemi(this);
}

void myParser::SemiContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSemi(this);
}

myParser::SemiContext* myParser::semi() {
  SemiContext *_localctx = _tracker.createInstance<SemiContext>(_ctx, getState());
  enterRule(_localctx, 288, myParser::RuleSemi);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(2633);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 396, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2616); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(2615);
                match(myParser::NL);
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(2618); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 393, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2623);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::NL) {
        setState(2620);
        match(myParser::NL);
        setState(2625);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2626);
      match(myParser::SEMICOLON);
      setState(2630);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 395, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2627);
          match(myParser::NL); 
        }
        setState(2632);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 395, _ctx);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnysemiContext ------------------------------------------------------------------

myParser::AnysemiContext::AnysemiContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::AnysemiContext::NL() {
  return getToken(myParser::NL, 0);
}

tree::TerminalNode* myParser::AnysemiContext::SEMICOLON() {
  return getToken(myParser::SEMICOLON, 0);
}


size_t myParser::AnysemiContext::getRuleIndex() const {
  return myParser::RuleAnysemi;
}

void myParser::AnysemiContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnysemi(this);
}

void myParser::AnysemiContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnysemi(this);
}

myParser::AnysemiContext* myParser::anysemi() {
  AnysemiContext *_localctx = _tracker.createInstance<AnysemiContext>(_ctx, getState());
  enterRule(_localctx, 290, myParser::RuleAnysemi);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2635);
    _la = _input->LA(1);
    if (!(_la == myParser::NL

    || _la == myParser::SEMICOLON)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

void myParser::initialize() {
  ::antlr4::internal::call_once(myparserParserOnceFlag, myparserParserInitialize);
}


// Generated from my.g4 by ANTLR 4.11.1


#include "myListener.h"

#include "myParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct MyParserStaticData final {
  MyParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  MyParserStaticData(const MyParserStaticData&) = delete;
  MyParserStaticData(MyParserStaticData&&) = delete;
  MyParserStaticData& operator=(const MyParserStaticData&) = delete;
  MyParserStaticData& operator=(MyParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag myParserOnceFlag;
MyParserStaticData *myParserStaticData = nullptr;

void myParserInitialize() {
  assert(myParserStaticData == nullptr);
  auto staticData = std::make_unique<MyParserStaticData>(
    std::vector<std::string>{
      "sourceFile", "packageClause", "importDecl", "importSpec", "importPath", 
      "topLevelDecl", "declaration", "constDecl", "constSpec", "identifierList", 
      "expressionList", "typeDecl", "typeSpec", "functionDecl", "function", 
      "methodDecl", "receiver", "varDecl", "varSpec", "block", "statementList", 
      "statement", "simpleStmt", "expressionStmt", "sendStmt", "incDecStmt", 
      "assignment", "assign_op", "shortVarDecl", "emptyStmt", "labeledStmt", 
      "returnStmt", "breakStmt", "continueStmt", "gotoStmt", "fallthroughStmt", 
      "deferStmt", "ifStmt", "switchStmt", "exprSwitchStmt", "exprCaseClause", 
      "exprSwitchCase", "typeSwitchStmt", "typeSwitchGuard", "typeCaseClause", 
      "typeSwitchCase", "typeList", "selectStmt", "commClause", "commCase", 
      "recvStmt", "forStmt", "forClause", "rangeClause", "goStmt", "goType", 
      "typeName", "typeLit", "arrayType", "arrayLength", "elementType", 
      "pointerType", "interfaceType", "sliceType", "mapType", "channelType", 
      "methodSpec", "functionType", "signature", "result", "parameters", 
      "parameterList", "parameterDecl", "operand", "literal", "basicLit", 
      "operandName", "qualifiedIdent", "compositeLit", "literalType", "literalValue", 
      "elementList", "keyedElement", "key", "element", "structType", "fieldDecl", 
      "anonymousField", "functionLit", "primaryExpr", "selector", "index", 
      "slice", "typeAssertion", "arguments", "methodExpr", "receiverType", 
      "expression", "unaryExpr", "conversion", "eos"
    },
    std::vector<std::string>{
      "", "'package'", "'import'", "'('", "')'", "'.'", "'const'", "'='", 
      "','", "'type'", "';'", "'func'", "'var'", "'{'", "'}'", "'<-'", "'++'", 
      "'--'", "'+'", "'-'", "'|'", "'^'", "'*'", "'/'", "'%'", "'<<'", "'>>'", 
      "'&'", "'&^'", "':='", "':'", "'return'", "'break'", "'continue'", 
      "'goto'", "'fallthrough'", "'defer'", "'if'", "'else'", "'switch'", 
      "'case'", "'default'", "'select'", "'for'", "'range'", "'go'", "'['", 
      "']'", "'interface'", "'map'", "'chan'", "'...'", "'struct'", "'||'", 
      "'&&'", "'=='", "'!='", "'<'", "'<='", "'>'", "'>='", "'!'"
    },
    std::vector<std::string>{
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "COMMENT", "LINE_COMMENT", 
      "IDENTIFIER", "KEYWORD", "BINARY_OP", "INT_LIT", "FLOAT_LIT", "IMAGINARY_LIT", 
      "RUNE_LIT", "LITTLE_U_VALUE", "BIG_U_VALUE", "STRING_LIT", "WS", "TERMINATOR"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,75,922,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
  	14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
  	21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
  	28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,
  	35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,
  	42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,
  	49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,
  	56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,
  	63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,
  	70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,
  	77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,
  	84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
  	91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,7,
  	98,2,99,7,99,2,100,7,100,1,0,1,0,4,0,205,8,0,11,0,12,0,206,1,0,5,0,210,
  	8,0,10,0,12,0,213,9,0,1,0,4,0,216,8,0,11,0,12,0,217,1,0,5,0,221,8,0,10,
  	0,12,0,224,9,0,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,5,2,236,8,2,10,
  	2,12,2,239,9,2,1,2,1,2,3,2,243,8,2,1,2,1,2,1,2,3,2,248,8,2,1,3,3,3,251,
  	8,3,1,3,3,3,254,8,3,1,3,1,3,1,4,1,4,1,5,1,5,1,5,3,5,263,8,5,1,6,1,6,1,
  	6,1,6,3,6,269,8,6,1,7,1,7,1,7,1,7,5,7,275,8,7,10,7,12,7,278,9,7,1,7,3,
  	7,281,8,7,1,8,1,8,3,8,285,8,8,1,8,1,8,3,8,289,8,8,1,9,1,9,1,9,5,9,294,
  	8,9,10,9,12,9,297,9,9,1,10,1,10,1,10,5,10,302,8,10,10,10,12,10,305,9,
  	10,1,11,1,11,1,11,1,11,1,11,1,11,5,11,313,8,11,10,11,12,11,316,9,11,1,
  	11,3,11,319,8,11,1,12,1,12,1,12,1,13,1,13,1,13,1,13,1,13,3,13,329,8,13,
  	1,13,1,13,1,14,1,14,1,14,1,15,1,15,1,15,1,15,1,15,3,15,341,8,15,1,16,
  	1,16,1,17,1,17,1,17,1,17,5,17,349,8,17,10,17,12,17,352,9,17,1,17,3,17,
  	355,8,17,1,18,1,18,1,18,1,18,3,18,361,8,18,1,18,1,18,3,18,365,8,18,1,
  	19,1,19,1,19,1,19,1,19,1,19,1,20,5,20,374,8,20,10,20,12,20,377,9,20,1,
  	21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,
  	21,1,21,3,21,395,8,21,1,22,1,22,1,22,1,22,1,22,1,22,3,22,403,8,22,1,23,
  	1,23,1,24,1,24,1,24,1,24,1,25,1,25,1,25,1,26,1,26,1,26,1,26,1,27,3,27,
  	419,8,27,1,27,1,27,1,28,1,28,1,28,1,28,1,29,1,29,1,30,1,30,1,30,1,30,
  	1,31,1,31,3,31,435,8,31,1,32,1,32,3,32,439,8,32,1,33,1,33,3,33,443,8,
  	33,1,34,1,34,1,34,1,35,1,35,1,36,1,36,1,36,1,37,1,37,1,37,1,37,3,37,457,
  	8,37,1,37,1,37,1,37,1,37,1,37,3,37,464,8,37,3,37,466,8,37,1,38,1,38,3,
  	38,470,8,38,1,39,1,39,1,39,1,39,3,39,476,8,39,1,39,3,39,479,8,39,1,39,
  	1,39,5,39,483,8,39,10,39,12,39,486,9,39,1,39,1,39,1,40,1,40,1,40,1,40,
  	1,41,1,41,1,41,3,41,497,8,41,1,42,1,42,1,42,1,42,3,42,503,8,42,1,42,1,
  	42,1,42,5,42,508,8,42,10,42,12,42,511,9,42,1,42,1,42,1,43,1,43,3,43,517,
  	8,43,1,43,1,43,1,43,1,43,1,43,1,43,1,44,1,44,1,44,1,44,1,45,1,45,1,45,
  	3,45,532,8,45,1,46,1,46,1,46,5,46,537,8,46,10,46,12,46,540,9,46,1,47,
  	1,47,1,47,5,47,545,8,47,10,47,12,47,548,9,47,1,47,1,47,1,48,1,48,1,48,
  	1,48,1,49,1,49,1,49,3,49,559,8,49,1,49,3,49,562,8,49,1,50,1,50,1,50,1,
  	50,1,50,1,50,3,50,570,8,50,1,50,1,50,1,51,1,51,1,51,1,51,3,51,578,8,51,
  	1,51,1,51,1,52,3,52,583,8,52,1,52,1,52,3,52,587,8,52,1,52,1,52,3,52,591,
  	8,52,1,53,1,53,1,53,1,53,1,53,1,53,3,53,599,8,53,1,53,1,53,1,53,1,54,
  	1,54,1,54,1,55,1,55,1,55,1,55,1,55,1,55,3,55,613,8,55,1,56,1,56,3,56,
  	617,8,56,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,3,57,627,8,57,1,58,1,
  	58,1,58,1,58,1,58,1,59,1,59,1,60,1,60,1,61,1,61,1,61,1,62,1,62,1,62,5,
  	62,644,8,62,10,62,12,62,647,9,62,1,62,1,62,1,63,1,63,1,63,1,63,1,64,1,
  	64,1,64,1,64,1,64,1,64,1,65,1,65,1,65,1,65,1,65,3,65,666,8,65,1,65,1,
  	65,1,66,1,66,1,66,3,66,673,8,66,1,67,1,67,1,67,1,68,1,68,3,68,680,8,68,
  	1,69,1,69,3,69,684,8,69,1,70,1,70,1,70,3,70,689,8,70,3,70,691,8,70,1,
  	70,1,70,1,71,1,71,1,71,5,71,698,8,71,10,71,12,71,701,9,71,1,72,3,72,704,
  	8,72,1,72,3,72,707,8,72,1,72,1,72,1,73,1,73,1,73,1,73,1,73,1,73,1,73,
  	3,73,718,8,73,1,74,1,74,1,74,3,74,723,8,74,1,75,1,75,1,76,1,76,3,76,729,
  	8,76,1,77,1,77,1,77,1,77,1,78,1,78,1,78,1,79,1,79,1,79,1,79,1,79,1,79,
  	1,79,1,79,1,79,3,79,747,8,79,1,80,1,80,1,80,3,80,752,8,80,3,80,754,8,
  	80,1,80,1,80,1,81,1,81,1,81,5,81,761,8,81,10,81,12,81,764,9,81,1,82,1,
  	82,1,82,3,82,769,8,82,1,82,1,82,1,83,1,83,1,83,3,83,776,8,83,1,84,1,84,
  	3,84,780,8,84,1,85,1,85,1,85,5,85,785,8,85,10,85,12,85,788,9,85,1,85,
  	1,85,1,86,1,86,1,86,1,86,3,86,796,8,86,1,86,3,86,799,8,86,1,87,3,87,802,
  	8,87,1,87,1,87,1,88,1,88,1,88,1,89,1,89,1,89,3,89,812,8,89,1,89,1,89,
  	1,89,1,89,1,89,1,89,1,89,1,89,1,89,1,89,5,89,824,8,89,10,89,12,89,827,
  	9,89,1,90,1,90,1,90,1,91,1,91,1,91,1,91,1,92,1,92,3,92,838,8,92,1,92,
  	1,92,3,92,842,8,92,1,92,3,92,845,8,92,1,92,1,92,1,92,1,92,1,92,3,92,852,
  	8,92,1,92,1,92,1,93,1,93,1,93,1,93,1,93,1,94,1,94,1,94,1,94,1,94,3,94,
  	866,8,94,3,94,868,8,94,1,94,3,94,871,8,94,1,94,3,94,874,8,94,3,94,876,
  	8,94,1,94,1,94,1,95,1,95,1,95,1,95,1,96,1,96,1,96,1,96,1,96,1,96,1,96,
  	1,96,1,96,1,96,3,96,894,8,96,1,97,1,97,1,97,1,97,1,97,1,97,5,97,902,8,
  	97,10,97,12,97,905,9,97,1,98,1,98,1,98,3,98,910,8,98,1,99,1,99,1,99,1,
  	99,3,99,916,8,99,1,99,1,99,1,100,1,100,1,100,0,2,178,194,101,0,2,4,6,
  	8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,
  	56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,
  	102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,
  	138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,
  	174,176,178,180,182,184,186,188,190,192,194,196,198,200,0,7,2,0,5,5,64,
  	64,1,0,16,17,1,0,18,28,2,0,67,70,73,73,2,0,18,28,53,60,5,0,15,15,18,19,
  	21,22,27,27,61,61,2,1,10,10,74,75,962,0,202,1,0,0,0,2,225,1,0,0,0,4,247,
  	1,0,0,0,6,250,1,0,0,0,8,257,1,0,0,0,10,262,1,0,0,0,12,268,1,0,0,0,14,
  	270,1,0,0,0,16,282,1,0,0,0,18,290,1,0,0,0,20,298,1,0,0,0,22,306,1,0,0,
  	0,24,320,1,0,0,0,26,323,1,0,0,0,28,332,1,0,0,0,30,335,1,0,0,0,32,342,
  	1,0,0,0,34,344,1,0,0,0,36,356,1,0,0,0,38,366,1,0,0,0,40,375,1,0,0,0,42,
  	394,1,0,0,0,44,402,1,0,0,0,46,404,1,0,0,0,48,406,1,0,0,0,50,410,1,0,0,
  	0,52,413,1,0,0,0,54,418,1,0,0,0,56,422,1,0,0,0,58,426,1,0,0,0,60,428,
  	1,0,0,0,62,432,1,0,0,0,64,436,1,0,0,0,66,440,1,0,0,0,68,444,1,0,0,0,70,
  	447,1,0,0,0,72,449,1,0,0,0,74,452,1,0,0,0,76,469,1,0,0,0,78,471,1,0,0,
  	0,80,489,1,0,0,0,82,496,1,0,0,0,84,498,1,0,0,0,86,516,1,0,0,0,88,524,
  	1,0,0,0,90,531,1,0,0,0,92,533,1,0,0,0,94,541,1,0,0,0,96,551,1,0,0,0,98,
  	561,1,0,0,0,100,569,1,0,0,0,102,573,1,0,0,0,104,582,1,0,0,0,106,598,1,
  	0,0,0,108,603,1,0,0,0,110,612,1,0,0,0,112,616,1,0,0,0,114,626,1,0,0,0,
  	116,628,1,0,0,0,118,633,1,0,0,0,120,635,1,0,0,0,122,637,1,0,0,0,124,640,
  	1,0,0,0,126,650,1,0,0,0,128,654,1,0,0,0,130,665,1,0,0,0,132,672,1,0,0,
  	0,134,674,1,0,0,0,136,677,1,0,0,0,138,683,1,0,0,0,140,685,1,0,0,0,142,
  	694,1,0,0,0,144,703,1,0,0,0,146,717,1,0,0,0,148,722,1,0,0,0,150,724,1,
  	0,0,0,152,728,1,0,0,0,154,730,1,0,0,0,156,734,1,0,0,0,158,746,1,0,0,0,
  	160,748,1,0,0,0,162,757,1,0,0,0,164,768,1,0,0,0,166,775,1,0,0,0,168,779,
  	1,0,0,0,170,781,1,0,0,0,172,795,1,0,0,0,174,801,1,0,0,0,176,805,1,0,0,
  	0,178,811,1,0,0,0,180,828,1,0,0,0,182,831,1,0,0,0,184,835,1,0,0,0,186,
  	855,1,0,0,0,188,860,1,0,0,0,190,879,1,0,0,0,192,893,1,0,0,0,194,895,1,
  	0,0,0,196,909,1,0,0,0,198,911,1,0,0,0,200,919,1,0,0,0,202,204,3,2,1,0,
  	203,205,5,75,0,0,204,203,1,0,0,0,205,206,1,0,0,0,206,204,1,0,0,0,206,
  	207,1,0,0,0,207,211,1,0,0,0,208,210,3,4,2,0,209,208,1,0,0,0,210,213,1,
  	0,0,0,211,209,1,0,0,0,211,212,1,0,0,0,212,215,1,0,0,0,213,211,1,0,0,0,
  	214,216,5,75,0,0,215,214,1,0,0,0,216,217,1,0,0,0,217,215,1,0,0,0,217,
  	218,1,0,0,0,218,222,1,0,0,0,219,221,3,10,5,0,220,219,1,0,0,0,221,224,
  	1,0,0,0,222,220,1,0,0,0,222,223,1,0,0,0,223,1,1,0,0,0,224,222,1,0,0,0,
  	225,226,5,1,0,0,226,227,5,74,0,0,227,228,5,64,0,0,228,3,1,0,0,0,229,230,
  	5,2,0,0,230,242,5,74,0,0,231,243,3,6,3,0,232,233,5,3,0,0,233,237,5,75,
  	0,0,234,236,3,6,3,0,235,234,1,0,0,0,236,239,1,0,0,0,237,235,1,0,0,0,237,
  	238,1,0,0,0,238,240,1,0,0,0,239,237,1,0,0,0,240,241,5,4,0,0,241,243,5,
  	75,0,0,242,231,1,0,0,0,242,232,1,0,0,0,243,248,1,0,0,0,244,245,5,2,0,
  	0,245,246,5,74,0,0,246,248,3,8,4,0,247,229,1,0,0,0,247,244,1,0,0,0,248,
  	5,1,0,0,0,249,251,5,74,0,0,250,249,1,0,0,0,250,251,1,0,0,0,251,253,1,
  	0,0,0,252,254,7,0,0,0,253,252,1,0,0,0,253,254,1,0,0,0,254,255,1,0,0,0,
  	255,256,3,8,4,0,256,7,1,0,0,0,257,258,5,73,0,0,258,9,1,0,0,0,259,263,
  	3,12,6,0,260,263,3,26,13,0,261,263,3,30,15,0,262,259,1,0,0,0,262,260,
  	1,0,0,0,262,261,1,0,0,0,263,11,1,0,0,0,264,269,3,14,7,0,265,269,3,22,
  	11,0,266,269,3,34,17,0,267,269,5,62,0,0,268,264,1,0,0,0,268,265,1,0,0,
  	0,268,266,1,0,0,0,268,267,1,0,0,0,269,13,1,0,0,0,270,280,5,6,0,0,271,
  	281,3,16,8,0,272,276,5,3,0,0,273,275,3,16,8,0,274,273,1,0,0,0,275,278,
  	1,0,0,0,276,274,1,0,0,0,276,277,1,0,0,0,277,279,1,0,0,0,278,276,1,0,0,
  	0,279,281,5,4,0,0,280,271,1,0,0,0,280,272,1,0,0,0,281,15,1,0,0,0,282,
  	288,3,18,9,0,283,285,3,110,55,0,284,283,1,0,0,0,284,285,1,0,0,0,285,286,
  	1,0,0,0,286,287,5,7,0,0,287,289,3,20,10,0,288,284,1,0,0,0,288,289,1,0,
  	0,0,289,17,1,0,0,0,290,295,5,64,0,0,291,292,5,8,0,0,292,294,5,64,0,0,
  	293,291,1,0,0,0,294,297,1,0,0,0,295,293,1,0,0,0,295,296,1,0,0,0,296,19,
  	1,0,0,0,297,295,1,0,0,0,298,303,3,194,97,0,299,300,5,8,0,0,300,302,3,
  	194,97,0,301,299,1,0,0,0,302,305,1,0,0,0,303,301,1,0,0,0,303,304,1,0,
  	0,0,304,21,1,0,0,0,305,303,1,0,0,0,306,318,5,9,0,0,307,319,3,24,12,0,
  	308,314,5,3,0,0,309,310,3,24,12,0,310,311,5,10,0,0,311,313,1,0,0,0,312,
  	309,1,0,0,0,313,316,1,0,0,0,314,312,1,0,0,0,314,315,1,0,0,0,315,317,1,
  	0,0,0,316,314,1,0,0,0,317,319,5,4,0,0,318,307,1,0,0,0,318,308,1,0,0,0,
  	319,23,1,0,0,0,320,321,5,64,0,0,321,322,3,110,55,0,322,25,1,0,0,0,323,
  	324,5,11,0,0,324,325,5,74,0,0,325,328,5,64,0,0,326,329,3,28,14,0,327,
  	329,3,136,68,0,328,326,1,0,0,0,328,327,1,0,0,0,329,330,1,0,0,0,330,331,
  	5,75,0,0,331,27,1,0,0,0,332,333,3,136,68,0,333,334,3,38,19,0,334,29,1,
  	0,0,0,335,336,5,11,0,0,336,337,3,32,16,0,337,340,5,64,0,0,338,341,3,28,
  	14,0,339,341,3,136,68,0,340,338,1,0,0,0,340,339,1,0,0,0,341,31,1,0,0,
  	0,342,343,3,140,70,0,343,33,1,0,0,0,344,354,5,12,0,0,345,355,3,36,18,
  	0,346,350,5,3,0,0,347,349,3,36,18,0,348,347,1,0,0,0,349,352,1,0,0,0,350,
  	348,1,0,0,0,350,351,1,0,0,0,351,353,1,0,0,0,352,350,1,0,0,0,353,355,5,
  	4,0,0,354,345,1,0,0,0,354,346,1,0,0,0,355,35,1,0,0,0,356,364,3,18,9,0,
  	357,360,3,110,55,0,358,359,5,7,0,0,359,361,3,20,10,0,360,358,1,0,0,0,
  	360,361,1,0,0,0,361,365,1,0,0,0,362,363,5,7,0,0,363,365,3,20,10,0,364,
  	357,1,0,0,0,364,362,1,0,0,0,365,37,1,0,0,0,366,367,5,13,0,0,367,368,5,
  	74,0,0,368,369,3,40,20,0,369,370,5,74,0,0,370,371,5,14,0,0,371,39,1,0,
  	0,0,372,374,3,42,21,0,373,372,1,0,0,0,374,377,1,0,0,0,375,373,1,0,0,0,
  	375,376,1,0,0,0,376,41,1,0,0,0,377,375,1,0,0,0,378,395,3,12,6,0,379,395,
  	3,60,30,0,380,395,3,44,22,0,381,395,3,108,54,0,382,395,3,62,31,0,383,
  	395,3,64,32,0,384,395,3,66,33,0,385,395,3,68,34,0,386,395,3,70,35,0,387,
  	395,3,38,19,0,388,395,3,74,37,0,389,395,3,76,38,0,390,395,3,94,47,0,391,
  	395,3,102,51,0,392,395,3,72,36,0,393,395,5,75,0,0,394,378,1,0,0,0,394,
  	379,1,0,0,0,394,380,1,0,0,0,394,381,1,0,0,0,394,382,1,0,0,0,394,383,1,
  	0,0,0,394,384,1,0,0,0,394,385,1,0,0,0,394,386,1,0,0,0,394,387,1,0,0,0,
  	394,388,1,0,0,0,394,389,1,0,0,0,394,390,1,0,0,0,394,391,1,0,0,0,394,392,
  	1,0,0,0,394,393,1,0,0,0,395,43,1,0,0,0,396,403,3,48,24,0,397,403,3,46,
  	23,0,398,403,3,50,25,0,399,403,3,52,26,0,400,403,3,56,28,0,401,403,3,
  	58,29,0,402,396,1,0,0,0,402,397,1,0,0,0,402,398,1,0,0,0,402,399,1,0,0,
  	0,402,400,1,0,0,0,402,401,1,0,0,0,403,45,1,0,0,0,404,405,3,194,97,0,405,
  	47,1,0,0,0,406,407,3,194,97,0,407,408,5,15,0,0,408,409,3,194,97,0,409,
  	49,1,0,0,0,410,411,3,194,97,0,411,412,7,1,0,0,412,51,1,0,0,0,413,414,
  	3,20,10,0,414,415,3,54,27,0,415,416,3,20,10,0,416,53,1,0,0,0,417,419,
  	7,2,0,0,418,417,1,0,0,0,418,419,1,0,0,0,419,420,1,0,0,0,420,421,5,7,0,
  	0,421,55,1,0,0,0,422,423,3,18,9,0,423,424,5,29,0,0,424,425,3,20,10,0,
  	425,57,1,0,0,0,426,427,5,10,0,0,427,59,1,0,0,0,428,429,5,64,0,0,429,430,
  	5,30,0,0,430,431,3,42,21,0,431,61,1,0,0,0,432,434,5,31,0,0,433,435,3,
  	20,10,0,434,433,1,0,0,0,434,435,1,0,0,0,435,63,1,0,0,0,436,438,5,32,0,
  	0,437,439,5,64,0,0,438,437,1,0,0,0,438,439,1,0,0,0,439,65,1,0,0,0,440,
  	442,5,33,0,0,441,443,5,64,0,0,442,441,1,0,0,0,442,443,1,0,0,0,443,67,
  	1,0,0,0,444,445,5,34,0,0,445,446,5,64,0,0,446,69,1,0,0,0,447,448,5,35,
  	0,0,448,71,1,0,0,0,449,450,5,36,0,0,450,451,3,194,97,0,451,73,1,0,0,0,
  	452,456,5,37,0,0,453,454,3,44,22,0,454,455,5,10,0,0,455,457,1,0,0,0,456,
  	453,1,0,0,0,456,457,1,0,0,0,457,458,1,0,0,0,458,459,3,194,97,0,459,465,
  	3,38,19,0,460,463,5,38,0,0,461,464,3,74,37,0,462,464,3,38,19,0,463,461,
  	1,0,0,0,463,462,1,0,0,0,464,466,1,0,0,0,465,460,1,0,0,0,465,466,1,0,0,
  	0,466,75,1,0,0,0,467,470,3,78,39,0,468,470,3,84,42,0,469,467,1,0,0,0,
  	469,468,1,0,0,0,470,77,1,0,0,0,471,475,5,39,0,0,472,473,3,44,22,0,473,
  	474,5,10,0,0,474,476,1,0,0,0,475,472,1,0,0,0,475,476,1,0,0,0,476,478,
  	1,0,0,0,477,479,3,194,97,0,478,477,1,0,0,0,478,479,1,0,0,0,479,480,1,
  	0,0,0,480,484,5,13,0,0,481,483,3,80,40,0,482,481,1,0,0,0,483,486,1,0,
  	0,0,484,482,1,0,0,0,484,485,1,0,0,0,485,487,1,0,0,0,486,484,1,0,0,0,487,
  	488,5,14,0,0,488,79,1,0,0,0,489,490,3,82,41,0,490,491,5,30,0,0,491,492,
  	3,40,20,0,492,81,1,0,0,0,493,494,5,40,0,0,494,497,3,20,10,0,495,497,5,
  	41,0,0,496,493,1,0,0,0,496,495,1,0,0,0,497,83,1,0,0,0,498,502,5,39,0,
  	0,499,500,3,44,22,0,500,501,5,10,0,0,501,503,1,0,0,0,502,499,1,0,0,0,
  	502,503,1,0,0,0,503,504,1,0,0,0,504,505,3,86,43,0,505,509,5,13,0,0,506,
  	508,3,88,44,0,507,506,1,0,0,0,508,511,1,0,0,0,509,507,1,0,0,0,509,510,
  	1,0,0,0,510,512,1,0,0,0,511,509,1,0,0,0,512,513,5,14,0,0,513,85,1,0,0,
  	0,514,515,5,64,0,0,515,517,5,29,0,0,516,514,1,0,0,0,516,517,1,0,0,0,517,
  	518,1,0,0,0,518,519,3,178,89,0,519,520,5,5,0,0,520,521,5,3,0,0,521,522,
  	5,9,0,0,522,523,5,4,0,0,523,87,1,0,0,0,524,525,3,90,45,0,525,526,5,30,
  	0,0,526,527,3,40,20,0,527,89,1,0,0,0,528,529,5,40,0,0,529,532,3,92,46,
  	0,530,532,5,41,0,0,531,528,1,0,0,0,531,530,1,0,0,0,532,91,1,0,0,0,533,
  	538,3,110,55,0,534,535,5,8,0,0,535,537,3,110,55,0,536,534,1,0,0,0,537,
  	540,1,0,0,0,538,536,1,0,0,0,538,539,1,0,0,0,539,93,1,0,0,0,540,538,1,
  	0,0,0,541,542,5,42,0,0,542,546,5,13,0,0,543,545,3,96,48,0,544,543,1,0,
  	0,0,545,548,1,0,0,0,546,544,1,0,0,0,546,547,1,0,0,0,547,549,1,0,0,0,548,
  	546,1,0,0,0,549,550,5,14,0,0,550,95,1,0,0,0,551,552,3,98,49,0,552,553,
  	5,30,0,0,553,554,3,40,20,0,554,97,1,0,0,0,555,558,5,40,0,0,556,559,3,
  	48,24,0,557,559,3,100,50,0,558,556,1,0,0,0,558,557,1,0,0,0,559,562,1,
  	0,0,0,560,562,5,41,0,0,561,555,1,0,0,0,561,560,1,0,0,0,562,99,1,0,0,0,
  	563,564,3,20,10,0,564,565,5,7,0,0,565,570,1,0,0,0,566,567,3,18,9,0,567,
  	568,5,29,0,0,568,570,1,0,0,0,569,563,1,0,0,0,569,566,1,0,0,0,569,570,
  	1,0,0,0,570,571,1,0,0,0,571,572,3,194,97,0,572,101,1,0,0,0,573,577,5,
  	43,0,0,574,578,3,194,97,0,575,578,3,104,52,0,576,578,3,106,53,0,577,574,
  	1,0,0,0,577,575,1,0,0,0,577,576,1,0,0,0,577,578,1,0,0,0,578,579,1,0,0,
  	0,579,580,3,38,19,0,580,103,1,0,0,0,581,583,3,44,22,0,582,581,1,0,0,0,
  	582,583,1,0,0,0,583,584,1,0,0,0,584,586,5,10,0,0,585,587,3,194,97,0,586,
  	585,1,0,0,0,586,587,1,0,0,0,587,588,1,0,0,0,588,590,5,10,0,0,589,591,
  	3,44,22,0,590,589,1,0,0,0,590,591,1,0,0,0,591,105,1,0,0,0,592,593,3,20,
  	10,0,593,594,5,7,0,0,594,599,1,0,0,0,595,596,3,18,9,0,596,597,5,29,0,
  	0,597,599,1,0,0,0,598,592,1,0,0,0,598,595,1,0,0,0,598,599,1,0,0,0,599,
  	600,1,0,0,0,600,601,5,44,0,0,601,602,3,194,97,0,602,107,1,0,0,0,603,604,
  	5,45,0,0,604,605,3,194,97,0,605,109,1,0,0,0,606,613,3,112,56,0,607,613,
  	3,114,57,0,608,609,5,3,0,0,609,610,3,110,55,0,610,611,5,4,0,0,611,613,
  	1,0,0,0,612,606,1,0,0,0,612,607,1,0,0,0,612,608,1,0,0,0,613,111,1,0,0,
  	0,614,617,5,64,0,0,615,617,3,154,77,0,616,614,1,0,0,0,616,615,1,0,0,0,
  	617,113,1,0,0,0,618,627,3,116,58,0,619,627,3,170,85,0,620,627,3,122,61,
  	0,621,627,3,134,67,0,622,627,3,124,62,0,623,627,3,126,63,0,624,627,3,
  	128,64,0,625,627,3,130,65,0,626,618,1,0,0,0,626,619,1,0,0,0,626,620,1,
  	0,0,0,626,621,1,0,0,0,626,622,1,0,0,0,626,623,1,0,0,0,626,624,1,0,0,0,
  	626,625,1,0,0,0,627,115,1,0,0,0,628,629,5,46,0,0,629,630,3,118,59,0,630,
  	631,5,47,0,0,631,632,3,120,60,0,632,117,1,0,0,0,633,634,3,194,97,0,634,
  	119,1,0,0,0,635,636,3,110,55,0,636,121,1,0,0,0,637,638,5,22,0,0,638,639,
  	3,110,55,0,639,123,1,0,0,0,640,641,5,48,0,0,641,645,5,13,0,0,642,644,
  	3,132,66,0,643,642,1,0,0,0,644,647,1,0,0,0,645,643,1,0,0,0,645,646,1,
  	0,0,0,646,648,1,0,0,0,647,645,1,0,0,0,648,649,5,14,0,0,649,125,1,0,0,
  	0,650,651,5,46,0,0,651,652,5,47,0,0,652,653,3,120,60,0,653,127,1,0,0,
  	0,654,655,5,49,0,0,655,656,5,46,0,0,656,657,3,110,55,0,657,658,5,47,0,
  	0,658,659,3,120,60,0,659,129,1,0,0,0,660,666,5,50,0,0,661,662,5,50,0,
  	0,662,666,5,15,0,0,663,664,5,15,0,0,664,666,5,50,0,0,665,660,1,0,0,0,
  	665,661,1,0,0,0,665,663,1,0,0,0,666,667,1,0,0,0,667,668,3,120,60,0,668,
  	131,1,0,0,0,669,670,5,64,0,0,670,673,3,136,68,0,671,673,3,112,56,0,672,
  	669,1,0,0,0,672,671,1,0,0,0,673,133,1,0,0,0,674,675,5,11,0,0,675,676,
  	3,136,68,0,676,135,1,0,0,0,677,679,3,140,70,0,678,680,3,138,69,0,679,
  	678,1,0,0,0,679,680,1,0,0,0,680,137,1,0,0,0,681,684,3,140,70,0,682,684,
  	3,110,55,0,683,681,1,0,0,0,683,682,1,0,0,0,684,139,1,0,0,0,685,690,5,
  	3,0,0,686,688,3,142,71,0,687,689,5,8,0,0,688,687,1,0,0,0,688,689,1,0,
  	0,0,689,691,1,0,0,0,690,686,1,0,0,0,690,691,1,0,0,0,691,692,1,0,0,0,692,
  	693,5,4,0,0,693,141,1,0,0,0,694,699,3,144,72,0,695,696,5,8,0,0,696,698,
  	3,144,72,0,697,695,1,0,0,0,698,701,1,0,0,0,699,697,1,0,0,0,699,700,1,
  	0,0,0,700,143,1,0,0,0,701,699,1,0,0,0,702,704,3,18,9,0,703,702,1,0,0,
  	0,703,704,1,0,0,0,704,706,1,0,0,0,705,707,5,51,0,0,706,705,1,0,0,0,706,
  	707,1,0,0,0,707,708,1,0,0,0,708,709,3,110,55,0,709,145,1,0,0,0,710,718,
  	3,148,74,0,711,718,3,152,76,0,712,718,3,190,95,0,713,714,5,3,0,0,714,
  	715,3,194,97,0,715,716,5,4,0,0,716,718,1,0,0,0,717,710,1,0,0,0,717,711,
  	1,0,0,0,717,712,1,0,0,0,717,713,1,0,0,0,718,147,1,0,0,0,719,723,3,150,
  	75,0,720,723,3,156,78,0,721,723,3,176,88,0,722,719,1,0,0,0,722,720,1,
  	0,0,0,722,721,1,0,0,0,723,149,1,0,0,0,724,725,7,3,0,0,725,151,1,0,0,0,
  	726,729,5,64,0,0,727,729,3,154,77,0,728,726,1,0,0,0,728,727,1,0,0,0,729,
  	153,1,0,0,0,730,731,5,64,0,0,731,732,5,5,0,0,732,733,5,64,0,0,733,155,
  	1,0,0,0,734,735,3,158,79,0,735,736,3,160,80,0,736,157,1,0,0,0,737,747,
  	3,170,85,0,738,747,3,116,58,0,739,740,5,46,0,0,740,741,5,51,0,0,741,742,
  	5,47,0,0,742,747,3,120,60,0,743,747,3,126,63,0,744,747,3,128,64,0,745,
  	747,3,112,56,0,746,737,1,0,0,0,746,738,1,0,0,0,746,739,1,0,0,0,746,743,
  	1,0,0,0,746,744,1,0,0,0,746,745,1,0,0,0,747,159,1,0,0,0,748,753,5,13,
  	0,0,749,751,3,162,81,0,750,752,5,8,0,0,751,750,1,0,0,0,751,752,1,0,0,
  	0,752,754,1,0,0,0,753,749,1,0,0,0,753,754,1,0,0,0,754,755,1,0,0,0,755,
  	756,5,14,0,0,756,161,1,0,0,0,757,762,3,164,82,0,758,759,5,8,0,0,759,761,
  	3,164,82,0,760,758,1,0,0,0,761,764,1,0,0,0,762,760,1,0,0,0,762,763,1,
  	0,0,0,763,163,1,0,0,0,764,762,1,0,0,0,765,766,3,166,83,0,766,767,5,30,
  	0,0,767,769,1,0,0,0,768,765,1,0,0,0,768,769,1,0,0,0,769,770,1,0,0,0,770,
  	771,3,168,84,0,771,165,1,0,0,0,772,776,5,64,0,0,773,776,3,194,97,0,774,
  	776,3,160,80,0,775,772,1,0,0,0,775,773,1,0,0,0,775,774,1,0,0,0,776,167,
  	1,0,0,0,777,780,3,194,97,0,778,780,3,160,80,0,779,777,1,0,0,0,779,778,
  	1,0,0,0,780,169,1,0,0,0,781,782,5,52,0,0,782,786,5,13,0,0,783,785,3,172,
  	86,0,784,783,1,0,0,0,785,788,1,0,0,0,786,784,1,0,0,0,786,787,1,0,0,0,
  	787,789,1,0,0,0,788,786,1,0,0,0,789,790,5,14,0,0,790,171,1,0,0,0,791,
  	792,3,18,9,0,792,793,3,110,55,0,793,796,1,0,0,0,794,796,3,174,87,0,795,
  	791,1,0,0,0,795,794,1,0,0,0,796,798,1,0,0,0,797,799,5,73,0,0,798,797,
  	1,0,0,0,798,799,1,0,0,0,799,173,1,0,0,0,800,802,5,22,0,0,801,800,1,0,
  	0,0,801,802,1,0,0,0,802,803,1,0,0,0,803,804,3,112,56,0,804,175,1,0,0,
  	0,805,806,5,11,0,0,806,807,3,28,14,0,807,177,1,0,0,0,808,809,6,89,-1,
  	0,809,812,3,146,73,0,810,812,3,198,99,0,811,808,1,0,0,0,811,810,1,0,0,
  	0,812,825,1,0,0,0,813,814,10,5,0,0,814,824,3,180,90,0,815,816,10,4,0,
  	0,816,824,3,182,91,0,817,818,10,3,0,0,818,824,3,184,92,0,819,820,10,2,
  	0,0,820,824,3,186,93,0,821,822,10,1,0,0,822,824,3,188,94,0,823,813,1,
  	0,0,0,823,815,1,0,0,0,823,817,1,0,0,0,823,819,1,0,0,0,823,821,1,0,0,0,
  	824,827,1,0,0,0,825,823,1,0,0,0,825,826,1,0,0,0,826,179,1,0,0,0,827,825,
  	1,0,0,0,828,829,5,5,0,0,829,830,5,64,0,0,830,181,1,0,0,0,831,832,5,46,
  	0,0,832,833,3,194,97,0,833,834,5,47,0,0,834,183,1,0,0,0,835,851,5,46,
  	0,0,836,838,3,194,97,0,837,836,1,0,0,0,837,838,1,0,0,0,838,839,1,0,0,
  	0,839,841,5,30,0,0,840,842,3,194,97,0,841,840,1,0,0,0,841,842,1,0,0,0,
  	842,852,1,0,0,0,843,845,3,194,97,0,844,843,1,0,0,0,844,845,1,0,0,0,845,
  	846,1,0,0,0,846,847,5,30,0,0,847,848,3,194,97,0,848,849,5,30,0,0,849,
  	850,3,194,97,0,850,852,1,0,0,0,851,837,1,0,0,0,851,844,1,0,0,0,852,853,
  	1,0,0,0,853,854,5,47,0,0,854,185,1,0,0,0,855,856,5,5,0,0,856,857,5,3,
  	0,0,857,858,3,110,55,0,858,859,5,4,0,0,859,187,1,0,0,0,860,875,5,3,0,
  	0,861,868,3,20,10,0,862,865,3,110,55,0,863,864,5,8,0,0,864,866,3,20,10,
  	0,865,863,1,0,0,0,865,866,1,0,0,0,866,868,1,0,0,0,867,861,1,0,0,0,867,
  	862,1,0,0,0,868,870,1,0,0,0,869,871,5,51,0,0,870,869,1,0,0,0,870,871,
  	1,0,0,0,871,873,1,0,0,0,872,874,5,8,0,0,873,872,1,0,0,0,873,874,1,0,0,
  	0,874,876,1,0,0,0,875,867,1,0,0,0,875,876,1,0,0,0,876,877,1,0,0,0,877,
  	878,5,4,0,0,878,189,1,0,0,0,879,880,3,192,96,0,880,881,5,5,0,0,881,882,
  	5,64,0,0,882,191,1,0,0,0,883,894,3,112,56,0,884,885,5,3,0,0,885,886,5,
  	22,0,0,886,887,3,112,56,0,887,888,5,4,0,0,888,894,1,0,0,0,889,890,5,3,
  	0,0,890,891,3,192,96,0,891,892,5,4,0,0,892,894,1,0,0,0,893,883,1,0,0,
  	0,893,884,1,0,0,0,893,889,1,0,0,0,894,193,1,0,0,0,895,896,6,97,-1,0,896,
  	897,3,196,98,0,897,903,1,0,0,0,898,899,10,1,0,0,899,900,7,4,0,0,900,902,
  	3,194,97,2,901,898,1,0,0,0,902,905,1,0,0,0,903,901,1,0,0,0,903,904,1,
  	0,0,0,904,195,1,0,0,0,905,903,1,0,0,0,906,910,3,178,89,0,907,908,7,5,
  	0,0,908,910,3,196,98,0,909,906,1,0,0,0,909,907,1,0,0,0,910,197,1,0,0,
  	0,911,912,3,110,55,0,912,913,5,3,0,0,913,915,3,194,97,0,914,916,5,8,0,
  	0,915,914,1,0,0,0,915,916,1,0,0,0,916,917,1,0,0,0,917,918,5,4,0,0,918,
  	199,1,0,0,0,919,920,7,6,0,0,920,201,1,0,0,0,97,206,211,217,222,237,242,
  	247,250,253,262,268,276,280,284,288,295,303,314,318,328,340,350,354,360,
  	364,375,394,402,418,434,438,442,456,463,465,469,475,478,484,496,502,509,
  	516,531,538,546,558,561,569,577,582,586,590,598,612,616,626,645,665,672,
  	679,683,688,690,699,703,706,717,722,728,746,751,753,762,768,775,779,786,
  	795,798,801,811,823,825,837,841,844,851,865,867,870,873,875,893,903,909,
  	915
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  myParserStaticData = staticData.release();
}

}

myParser::myParser(TokenStream *input) : myParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

myParser::myParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  myParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *myParserStaticData->atn, myParserStaticData->decisionToDFA, myParserStaticData->sharedContextCache, options);
}

myParser::~myParser() {
  delete _interpreter;
}

const atn::ATN& myParser::getATN() const {
  return *myParserStaticData->atn;
}

std::string myParser::getGrammarFileName() const {
  return "my.g4";
}

const std::vector<std::string>& myParser::getRuleNames() const {
  return myParserStaticData->ruleNames;
}

const dfa::Vocabulary& myParser::getVocabulary() const {
  return myParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView myParser::getSerializedATN() const {
  return myParserStaticData->serializedATN;
}


//----------------- SourceFileContext ------------------------------------------------------------------

myParser::SourceFileContext::SourceFileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::PackageClauseContext* myParser::SourceFileContext::packageClause() {
  return getRuleContext<myParser::PackageClauseContext>(0);
}

std::vector<tree::TerminalNode *> myParser::SourceFileContext::TERMINATOR() {
  return getTokens(myParser::TERMINATOR);
}

tree::TerminalNode* myParser::SourceFileContext::TERMINATOR(size_t i) {
  return getToken(myParser::TERMINATOR, i);
}

std::vector<myParser::ImportDeclContext *> myParser::SourceFileContext::importDecl() {
  return getRuleContexts<myParser::ImportDeclContext>();
}

myParser::ImportDeclContext* myParser::SourceFileContext::importDecl(size_t i) {
  return getRuleContext<myParser::ImportDeclContext>(i);
}

std::vector<myParser::TopLevelDeclContext *> myParser::SourceFileContext::topLevelDecl() {
  return getRuleContexts<myParser::TopLevelDeclContext>();
}

myParser::TopLevelDeclContext* myParser::SourceFileContext::topLevelDecl(size_t i) {
  return getRuleContext<myParser::TopLevelDeclContext>(i);
}


size_t myParser::SourceFileContext::getRuleIndex() const {
  return myParser::RuleSourceFile;
}

void myParser::SourceFileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSourceFile(this);
}

void myParser::SourceFileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSourceFile(this);
}

myParser::SourceFileContext* myParser::sourceFile() {
  SourceFileContext *_localctx = _tracker.createInstance<SourceFileContext>(_ctx, getState());
  enterRule(_localctx, 0, myParser::RuleSourceFile);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(202);
    packageClause();
    setState(204); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(203);
              match(myParser::TERMINATOR);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(206); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(211);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::T__1) {
      setState(208);
      importDecl();
      setState(213);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(215); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(214);
      match(myParser::TERMINATOR);
      setState(217); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == myParser::TERMINATOR);
    setState(222);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4611686018427394624) != 0) {
      setState(219);
      topLevelDecl();
      setState(224);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PackageClauseContext ------------------------------------------------------------------

myParser::PackageClauseContext::PackageClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::PackageClauseContext::WS() {
  return getToken(myParser::WS, 0);
}

tree::TerminalNode* myParser::PackageClauseContext::IDENTIFIER() {
  return getToken(myParser::IDENTIFIER, 0);
}


size_t myParser::PackageClauseContext::getRuleIndex() const {
  return myParser::RulePackageClause;
}

void myParser::PackageClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPackageClause(this);
}

void myParser::PackageClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPackageClause(this);
}

myParser::PackageClauseContext* myParser::packageClause() {
  PackageClauseContext *_localctx = _tracker.createInstance<PackageClauseContext>(_ctx, getState());
  enterRule(_localctx, 2, myParser::RulePackageClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(225);
    match(myParser::T__0);
    setState(226);
    match(myParser::WS);
    setState(227);
    match(myParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportDeclContext ------------------------------------------------------------------

myParser::ImportDeclContext::ImportDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ImportDeclContext::WS() {
  return getToken(myParser::WS, 0);
}

std::vector<myParser::ImportSpecContext *> myParser::ImportDeclContext::importSpec() {
  return getRuleContexts<myParser::ImportSpecContext>();
}

myParser::ImportSpecContext* myParser::ImportDeclContext::importSpec(size_t i) {
  return getRuleContext<myParser::ImportSpecContext>(i);
}

std::vector<tree::TerminalNode *> myParser::ImportDeclContext::TERMINATOR() {
  return getTokens(myParser::TERMINATOR);
}

tree::TerminalNode* myParser::ImportDeclContext::TERMINATOR(size_t i) {
  return getToken(myParser::TERMINATOR, i);
}

myParser::ImportPathContext* myParser::ImportDeclContext::importPath() {
  return getRuleContext<myParser::ImportPathContext>(0);
}


size_t myParser::ImportDeclContext::getRuleIndex() const {
  return myParser::RuleImportDecl;
}

void myParser::ImportDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportDecl(this);
}

void myParser::ImportDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportDecl(this);
}

myParser::ImportDeclContext* myParser::importDecl() {
  ImportDeclContext *_localctx = _tracker.createInstance<ImportDeclContext>(_ctx, getState());
  enterRule(_localctx, 4, myParser::RuleImportDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(247);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(229);
      match(myParser::T__1);
      setState(230);
      match(myParser::WS);
      setState(242);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case myParser::T__4:
        case myParser::IDENTIFIER:
        case myParser::STRING_LIT:
        case myParser::WS: {
          setState(231);
          importSpec();
          break;
        }

        case myParser::T__2: {
          setState(232);
          match(myParser::T__2);
          setState(233);
          match(myParser::TERMINATOR);
          setState(237);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == myParser::T__4 || (((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & 1537) != 0) {
            setState(234);
            importSpec();
            setState(239);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(240);
          match(myParser::T__3);
          setState(241);
          match(myParser::TERMINATOR);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(244);
      match(myParser::T__1);
      setState(245);
      match(myParser::WS);
      setState(246);
      importPath();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportSpecContext ------------------------------------------------------------------

myParser::ImportSpecContext::ImportSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ImportPathContext* myParser::ImportSpecContext::importPath() {
  return getRuleContext<myParser::ImportPathContext>(0);
}

tree::TerminalNode* myParser::ImportSpecContext::WS() {
  return getToken(myParser::WS, 0);
}

tree::TerminalNode* myParser::ImportSpecContext::IDENTIFIER() {
  return getToken(myParser::IDENTIFIER, 0);
}


size_t myParser::ImportSpecContext::getRuleIndex() const {
  return myParser::RuleImportSpec;
}

void myParser::ImportSpecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportSpec(this);
}

void myParser::ImportSpecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportSpec(this);
}

myParser::ImportSpecContext* myParser::importSpec() {
  ImportSpecContext *_localctx = _tracker.createInstance<ImportSpecContext>(_ctx, getState());
  enterRule(_localctx, 6, myParser::RuleImportSpec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(250);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::WS) {
      setState(249);
      match(myParser::WS);
    }
    setState(253);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::T__4

    || _la == myParser::IDENTIFIER) {
      setState(252);
      _la = _input->LA(1);
      if (!(_la == myParser::T__4

      || _la == myParser::IDENTIFIER)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(255);
    importPath();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportPathContext ------------------------------------------------------------------

myParser::ImportPathContext::ImportPathContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ImportPathContext::STRING_LIT() {
  return getToken(myParser::STRING_LIT, 0);
}


size_t myParser::ImportPathContext::getRuleIndex() const {
  return myParser::RuleImportPath;
}

void myParser::ImportPathContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportPath(this);
}

void myParser::ImportPathContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportPath(this);
}

myParser::ImportPathContext* myParser::importPath() {
  ImportPathContext *_localctx = _tracker.createInstance<ImportPathContext>(_ctx, getState());
  enterRule(_localctx, 8, myParser::RuleImportPath);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(257);
    match(myParser::STRING_LIT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TopLevelDeclContext ------------------------------------------------------------------

myParser::TopLevelDeclContext::TopLevelDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::DeclarationContext* myParser::TopLevelDeclContext::declaration() {
  return getRuleContext<myParser::DeclarationContext>(0);
}

myParser::FunctionDeclContext* myParser::TopLevelDeclContext::functionDecl() {
  return getRuleContext<myParser::FunctionDeclContext>(0);
}

myParser::MethodDeclContext* myParser::TopLevelDeclContext::methodDecl() {
  return getRuleContext<myParser::MethodDeclContext>(0);
}


size_t myParser::TopLevelDeclContext::getRuleIndex() const {
  return myParser::RuleTopLevelDecl;
}

void myParser::TopLevelDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTopLevelDecl(this);
}

void myParser::TopLevelDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTopLevelDecl(this);
}

myParser::TopLevelDeclContext* myParser::topLevelDecl() {
  TopLevelDeclContext *_localctx = _tracker.createInstance<TopLevelDeclContext>(_ctx, getState());
  enterRule(_localctx, 10, myParser::RuleTopLevelDecl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(262);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(259);
      declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(260);
      functionDecl();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(261);
      methodDecl();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclarationContext ------------------------------------------------------------------

myParser::DeclarationContext::DeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ConstDeclContext* myParser::DeclarationContext::constDecl() {
  return getRuleContext<myParser::ConstDeclContext>(0);
}

myParser::TypeDeclContext* myParser::DeclarationContext::typeDecl() {
  return getRuleContext<myParser::TypeDeclContext>(0);
}

myParser::VarDeclContext* myParser::DeclarationContext::varDecl() {
  return getRuleContext<myParser::VarDeclContext>(0);
}

tree::TerminalNode* myParser::DeclarationContext::COMMENT() {
  return getToken(myParser::COMMENT, 0);
}


size_t myParser::DeclarationContext::getRuleIndex() const {
  return myParser::RuleDeclaration;
}

void myParser::DeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclaration(this);
}

void myParser::DeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclaration(this);
}

myParser::DeclarationContext* myParser::declaration() {
  DeclarationContext *_localctx = _tracker.createInstance<DeclarationContext>(_ctx, getState());
  enterRule(_localctx, 12, myParser::RuleDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(268);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::T__5: {
        enterOuterAlt(_localctx, 1);
        setState(264);
        constDecl();
        break;
      }

      case myParser::T__8: {
        enterOuterAlt(_localctx, 2);
        setState(265);
        typeDecl();
        break;
      }

      case myParser::T__11: {
        enterOuterAlt(_localctx, 3);
        setState(266);
        varDecl();
        break;
      }

      case myParser::COMMENT: {
        enterOuterAlt(_localctx, 4);
        setState(267);
        match(myParser::COMMENT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstDeclContext ------------------------------------------------------------------

myParser::ConstDeclContext::ConstDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::ConstSpecContext *> myParser::ConstDeclContext::constSpec() {
  return getRuleContexts<myParser::ConstSpecContext>();
}

myParser::ConstSpecContext* myParser::ConstDeclContext::constSpec(size_t i) {
  return getRuleContext<myParser::ConstSpecContext>(i);
}


size_t myParser::ConstDeclContext::getRuleIndex() const {
  return myParser::RuleConstDecl;
}

void myParser::ConstDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstDecl(this);
}

void myParser::ConstDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstDecl(this);
}

myParser::ConstDeclContext* myParser::constDecl() {
  ConstDeclContext *_localctx = _tracker.createInstance<ConstDeclContext>(_ctx, getState());
  enterRule(_localctx, 14, myParser::RuleConstDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(270);
    match(myParser::T__5);
    setState(280);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::IDENTIFIER: {
        setState(271);
        constSpec();
        break;
      }

      case myParser::T__2: {
        setState(272);
        match(myParser::T__2);
        setState(276);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::IDENTIFIER) {
          setState(273);
          constSpec();
          setState(278);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(279);
        match(myParser::T__3);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstSpecContext ------------------------------------------------------------------

myParser::ConstSpecContext::ConstSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierListContext* myParser::ConstSpecContext::identifierList() {
  return getRuleContext<myParser::IdentifierListContext>(0);
}

myParser::ExpressionListContext* myParser::ConstSpecContext::expressionList() {
  return getRuleContext<myParser::ExpressionListContext>(0);
}

myParser::GoTypeContext* myParser::ConstSpecContext::goType() {
  return getRuleContext<myParser::GoTypeContext>(0);
}


size_t myParser::ConstSpecContext::getRuleIndex() const {
  return myParser::RuleConstSpec;
}

void myParser::ConstSpecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstSpec(this);
}

void myParser::ConstSpecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstSpec(this);
}

myParser::ConstSpecContext* myParser::constSpec() {
  ConstSpecContext *_localctx = _tracker.createInstance<ConstSpecContext>(_ctx, getState());
  enterRule(_localctx, 16, myParser::RuleConstSpec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(282);
    identifierList();
    setState(288);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {
    case 1: {
      setState(284);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la - 3) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 3)) & 2306661045865287937) != 0) {
        setState(283);
        goType();
      }
      setState(286);
      match(myParser::T__6);
      setState(287);
      expressionList();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierListContext ------------------------------------------------------------------

myParser::IdentifierListContext::IdentifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> myParser::IdentifierListContext::IDENTIFIER() {
  return getTokens(myParser::IDENTIFIER);
}

tree::TerminalNode* myParser::IdentifierListContext::IDENTIFIER(size_t i) {
  return getToken(myParser::IDENTIFIER, i);
}


size_t myParser::IdentifierListContext::getRuleIndex() const {
  return myParser::RuleIdentifierList;
}

void myParser::IdentifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierList(this);
}

void myParser::IdentifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierList(this);
}

myParser::IdentifierListContext* myParser::identifierList() {
  IdentifierListContext *_localctx = _tracker.createInstance<IdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 18, myParser::RuleIdentifierList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(290);
    match(myParser::IDENTIFIER);
    setState(295);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::T__7) {
      setState(291);
      match(myParser::T__7);
      setState(292);
      match(myParser::IDENTIFIER);
      setState(297);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionListContext ------------------------------------------------------------------

myParser::ExpressionListContext::ExpressionListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::ExpressionContext *> myParser::ExpressionListContext::expression() {
  return getRuleContexts<myParser::ExpressionContext>();
}

myParser::ExpressionContext* myParser::ExpressionListContext::expression(size_t i) {
  return getRuleContext<myParser::ExpressionContext>(i);
}


size_t myParser::ExpressionListContext::getRuleIndex() const {
  return myParser::RuleExpressionList;
}

void myParser::ExpressionListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionList(this);
}

void myParser::ExpressionListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionList(this);
}

myParser::ExpressionListContext* myParser::expressionList() {
  ExpressionListContext *_localctx = _tracker.createInstance<ExpressionListContext>(_ctx, getState());
  enterRule(_localctx, 20, myParser::RuleExpressionList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(298);
    expression(0);
    setState(303);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(299);
        match(myParser::T__7);
        setState(300);
        expression(0); 
      }
      setState(305);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeDeclContext ------------------------------------------------------------------

myParser::TypeDeclContext::TypeDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::TypeSpecContext *> myParser::TypeDeclContext::typeSpec() {
  return getRuleContexts<myParser::TypeSpecContext>();
}

myParser::TypeSpecContext* myParser::TypeDeclContext::typeSpec(size_t i) {
  return getRuleContext<myParser::TypeSpecContext>(i);
}


size_t myParser::TypeDeclContext::getRuleIndex() const {
  return myParser::RuleTypeDecl;
}

void myParser::TypeDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeDecl(this);
}

void myParser::TypeDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeDecl(this);
}

myParser::TypeDeclContext* myParser::typeDecl() {
  TypeDeclContext *_localctx = _tracker.createInstance<TypeDeclContext>(_ctx, getState());
  enterRule(_localctx, 22, myParser::RuleTypeDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(306);
    match(myParser::T__8);
    setState(318);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::IDENTIFIER: {
        setState(307);
        typeSpec();
        break;
      }

      case myParser::T__2: {
        setState(308);
        match(myParser::T__2);
        setState(314);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::IDENTIFIER) {
          setState(309);
          typeSpec();
          setState(310);
          match(myParser::T__9);
          setState(316);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(317);
        match(myParser::T__3);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeSpecContext ------------------------------------------------------------------

myParser::TypeSpecContext::TypeSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TypeSpecContext::IDENTIFIER() {
  return getToken(myParser::IDENTIFIER, 0);
}

myParser::GoTypeContext* myParser::TypeSpecContext::goType() {
  return getRuleContext<myParser::GoTypeContext>(0);
}


size_t myParser::TypeSpecContext::getRuleIndex() const {
  return myParser::RuleTypeSpec;
}

void myParser::TypeSpecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeSpec(this);
}

void myParser::TypeSpecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeSpec(this);
}

myParser::TypeSpecContext* myParser::typeSpec() {
  TypeSpecContext *_localctx = _tracker.createInstance<TypeSpecContext>(_ctx, getState());
  enterRule(_localctx, 24, myParser::RuleTypeSpec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(320);
    match(myParser::IDENTIFIER);
    setState(321);
    goType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDeclContext ------------------------------------------------------------------

myParser::FunctionDeclContext::FunctionDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::FunctionDeclContext::WS() {
  return getToken(myParser::WS, 0);
}

tree::TerminalNode* myParser::FunctionDeclContext::IDENTIFIER() {
  return getToken(myParser::IDENTIFIER, 0);
}

tree::TerminalNode* myParser::FunctionDeclContext::TERMINATOR() {
  return getToken(myParser::TERMINATOR, 0);
}

myParser::FunctionContext* myParser::FunctionDeclContext::function() {
  return getRuleContext<myParser::FunctionContext>(0);
}

myParser::SignatureContext* myParser::FunctionDeclContext::signature() {
  return getRuleContext<myParser::SignatureContext>(0);
}


size_t myParser::FunctionDeclContext::getRuleIndex() const {
  return myParser::RuleFunctionDecl;
}

void myParser::FunctionDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionDecl(this);
}

void myParser::FunctionDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionDecl(this);
}

myParser::FunctionDeclContext* myParser::functionDecl() {
  FunctionDeclContext *_localctx = _tracker.createInstance<FunctionDeclContext>(_ctx, getState());
  enterRule(_localctx, 26, myParser::RuleFunctionDecl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(323);
    match(myParser::T__10);
    setState(324);
    match(myParser::WS);
    setState(325);
    match(myParser::IDENTIFIER);
    setState(328);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
    case 1: {
      setState(326);
      function();
      break;
    }

    case 2: {
      setState(327);
      signature();
      break;
    }

    default:
      break;
    }
    setState(330);
    match(myParser::TERMINATOR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionContext ------------------------------------------------------------------

myParser::FunctionContext::FunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SignatureContext* myParser::FunctionContext::signature() {
  return getRuleContext<myParser::SignatureContext>(0);
}

myParser::BlockContext* myParser::FunctionContext::block() {
  return getRuleContext<myParser::BlockContext>(0);
}


size_t myParser::FunctionContext::getRuleIndex() const {
  return myParser::RuleFunction;
}

void myParser::FunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction(this);
}

void myParser::FunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction(this);
}

myParser::FunctionContext* myParser::function() {
  FunctionContext *_localctx = _tracker.createInstance<FunctionContext>(_ctx, getState());
  enterRule(_localctx, 28, myParser::RuleFunction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(332);
    signature();
    setState(333);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MethodDeclContext ------------------------------------------------------------------

myParser::MethodDeclContext::MethodDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ReceiverContext* myParser::MethodDeclContext::receiver() {
  return getRuleContext<myParser::ReceiverContext>(0);
}

tree::TerminalNode* myParser::MethodDeclContext::IDENTIFIER() {
  return getToken(myParser::IDENTIFIER, 0);
}

myParser::FunctionContext* myParser::MethodDeclContext::function() {
  return getRuleContext<myParser::FunctionContext>(0);
}

myParser::SignatureContext* myParser::MethodDeclContext::signature() {
  return getRuleContext<myParser::SignatureContext>(0);
}


size_t myParser::MethodDeclContext::getRuleIndex() const {
  return myParser::RuleMethodDecl;
}

void myParser::MethodDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMethodDecl(this);
}

void myParser::MethodDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMethodDecl(this);
}

myParser::MethodDeclContext* myParser::methodDecl() {
  MethodDeclContext *_localctx = _tracker.createInstance<MethodDeclContext>(_ctx, getState());
  enterRule(_localctx, 30, myParser::RuleMethodDecl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(335);
    match(myParser::T__10);
    setState(336);
    receiver();
    setState(337);
    match(myParser::IDENTIFIER);
    setState(340);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
    case 1: {
      setState(338);
      function();
      break;
    }

    case 2: {
      setState(339);
      signature();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReceiverContext ------------------------------------------------------------------

myParser::ReceiverContext::ReceiverContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ParametersContext* myParser::ReceiverContext::parameters() {
  return getRuleContext<myParser::ParametersContext>(0);
}


size_t myParser::ReceiverContext::getRuleIndex() const {
  return myParser::RuleReceiver;
}

void myParser::ReceiverContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReceiver(this);
}

void myParser::ReceiverContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReceiver(this);
}

myParser::ReceiverContext* myParser::receiver() {
  ReceiverContext *_localctx = _tracker.createInstance<ReceiverContext>(_ctx, getState());
  enterRule(_localctx, 32, myParser::RuleReceiver);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(342);
    parameters();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarDeclContext ------------------------------------------------------------------

myParser::VarDeclContext::VarDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::VarSpecContext *> myParser::VarDeclContext::varSpec() {
  return getRuleContexts<myParser::VarSpecContext>();
}

myParser::VarSpecContext* myParser::VarDeclContext::varSpec(size_t i) {
  return getRuleContext<myParser::VarSpecContext>(i);
}


size_t myParser::VarDeclContext::getRuleIndex() const {
  return myParser::RuleVarDecl;
}

void myParser::VarDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarDecl(this);
}

void myParser::VarDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarDecl(this);
}

myParser::VarDeclContext* myParser::varDecl() {
  VarDeclContext *_localctx = _tracker.createInstance<VarDeclContext>(_ctx, getState());
  enterRule(_localctx, 34, myParser::RuleVarDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(344);
    match(myParser::T__11);
    setState(354);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::IDENTIFIER: {
        setState(345);
        varSpec();
        break;
      }

      case myParser::T__2: {
        setState(346);
        match(myParser::T__2);
        setState(350);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::IDENTIFIER) {
          setState(347);
          varSpec();
          setState(352);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(353);
        match(myParser::T__3);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarSpecContext ------------------------------------------------------------------

myParser::VarSpecContext::VarSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierListContext* myParser::VarSpecContext::identifierList() {
  return getRuleContext<myParser::IdentifierListContext>(0);
}

myParser::GoTypeContext* myParser::VarSpecContext::goType() {
  return getRuleContext<myParser::GoTypeContext>(0);
}

myParser::ExpressionListContext* myParser::VarSpecContext::expressionList() {
  return getRuleContext<myParser::ExpressionListContext>(0);
}


size_t myParser::VarSpecContext::getRuleIndex() const {
  return myParser::RuleVarSpec;
}

void myParser::VarSpecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarSpec(this);
}

void myParser::VarSpecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarSpec(this);
}

myParser::VarSpecContext* myParser::varSpec() {
  VarSpecContext *_localctx = _tracker.createInstance<VarSpecContext>(_ctx, getState());
  enterRule(_localctx, 36, myParser::RuleVarSpec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(356);
    identifierList();
    setState(364);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::T__2:
      case myParser::T__10:
      case myParser::T__14:
      case myParser::T__21:
      case myParser::T__45:
      case myParser::T__47:
      case myParser::T__48:
      case myParser::T__49:
      case myParser::T__51:
      case myParser::IDENTIFIER: {
        setState(357);
        goType();
        setState(360);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::T__6) {
          setState(358);
          match(myParser::T__6);
          setState(359);
          expressionList();
        }
        break;
      }

      case myParser::T__6: {
        setState(362);
        match(myParser::T__6);
        setState(363);
        expressionList();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContext ------------------------------------------------------------------

myParser::BlockContext::BlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> myParser::BlockContext::WS() {
  return getTokens(myParser::WS);
}

tree::TerminalNode* myParser::BlockContext::WS(size_t i) {
  return getToken(myParser::WS, i);
}

myParser::StatementListContext* myParser::BlockContext::statementList() {
  return getRuleContext<myParser::StatementListContext>(0);
}


size_t myParser::BlockContext::getRuleIndex() const {
  return myParser::RuleBlock;
}

void myParser::BlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock(this);
}

void myParser::BlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock(this);
}

myParser::BlockContext* myParser::block() {
  BlockContext *_localctx = _tracker.createInstance<BlockContext>(_ctx, getState());
  enterRule(_localctx, 38, myParser::RuleBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(366);
    match(myParser::T__12);
    setState(367);
    match(myParser::WS);
    setState(368);
    statementList();
    setState(369);
    match(myParser::WS);
    setState(370);
    match(myParser::T__13);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementListContext ------------------------------------------------------------------

myParser::StatementListContext::StatementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::StatementContext *> myParser::StatementListContext::statement() {
  return getRuleContexts<myParser::StatementContext>();
}

myParser::StatementContext* myParser::StatementListContext::statement(size_t i) {
  return getRuleContext<myParser::StatementContext>(i);
}


size_t myParser::StatementListContext::getRuleIndex() const {
  return myParser::RuleStatementList;
}

void myParser::StatementListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatementList(this);
}

void myParser::StatementListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatementList(this);
}

myParser::StatementListContext* myParser::statementList() {
  StatementListContext *_localctx = _tracker.createInstance<StatementListContext>(_ctx, getState());
  enterRule(_localctx, 40, myParser::RuleStatementList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(375);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6924122521988808264) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 2681) != 0) {
      setState(372);
      statement();
      setState(377);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

myParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::DeclarationContext* myParser::StatementContext::declaration() {
  return getRuleContext<myParser::DeclarationContext>(0);
}

myParser::LabeledStmtContext* myParser::StatementContext::labeledStmt() {
  return getRuleContext<myParser::LabeledStmtContext>(0);
}

myParser::SimpleStmtContext* myParser::StatementContext::simpleStmt() {
  return getRuleContext<myParser::SimpleStmtContext>(0);
}

myParser::GoStmtContext* myParser::StatementContext::goStmt() {
  return getRuleContext<myParser::GoStmtContext>(0);
}

myParser::ReturnStmtContext* myParser::StatementContext::returnStmt() {
  return getRuleContext<myParser::ReturnStmtContext>(0);
}

myParser::BreakStmtContext* myParser::StatementContext::breakStmt() {
  return getRuleContext<myParser::BreakStmtContext>(0);
}

myParser::ContinueStmtContext* myParser::StatementContext::continueStmt() {
  return getRuleContext<myParser::ContinueStmtContext>(0);
}

myParser::GotoStmtContext* myParser::StatementContext::gotoStmt() {
  return getRuleContext<myParser::GotoStmtContext>(0);
}

myParser::FallthroughStmtContext* myParser::StatementContext::fallthroughStmt() {
  return getRuleContext<myParser::FallthroughStmtContext>(0);
}

myParser::BlockContext* myParser::StatementContext::block() {
  return getRuleContext<myParser::BlockContext>(0);
}

myParser::IfStmtContext* myParser::StatementContext::ifStmt() {
  return getRuleContext<myParser::IfStmtContext>(0);
}

myParser::SwitchStmtContext* myParser::StatementContext::switchStmt() {
  return getRuleContext<myParser::SwitchStmtContext>(0);
}

myParser::SelectStmtContext* myParser::StatementContext::selectStmt() {
  return getRuleContext<myParser::SelectStmtContext>(0);
}

myParser::ForStmtContext* myParser::StatementContext::forStmt() {
  return getRuleContext<myParser::ForStmtContext>(0);
}

myParser::DeferStmtContext* myParser::StatementContext::deferStmt() {
  return getRuleContext<myParser::DeferStmtContext>(0);
}

tree::TerminalNode* myParser::StatementContext::TERMINATOR() {
  return getToken(myParser::TERMINATOR, 0);
}


size_t myParser::StatementContext::getRuleIndex() const {
  return myParser::RuleStatement;
}

void myParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void myParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}

myParser::StatementContext* myParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 42, myParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(394);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(378);
      declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(379);
      labeledStmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(380);
      simpleStmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(381);
      goStmt();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(382);
      returnStmt();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(383);
      breakStmt();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(384);
      continueStmt();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(385);
      gotoStmt();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(386);
      fallthroughStmt();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(387);
      block();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(388);
      ifStmt();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(389);
      switchStmt();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(390);
      selectStmt();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(391);
      forStmt();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(392);
      deferStmt();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(393);
      match(myParser::TERMINATOR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleStmtContext ------------------------------------------------------------------

myParser::SimpleStmtContext::SimpleStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SendStmtContext* myParser::SimpleStmtContext::sendStmt() {
  return getRuleContext<myParser::SendStmtContext>(0);
}

myParser::ExpressionStmtContext* myParser::SimpleStmtContext::expressionStmt() {
  return getRuleContext<myParser::ExpressionStmtContext>(0);
}

myParser::IncDecStmtContext* myParser::SimpleStmtContext::incDecStmt() {
  return getRuleContext<myParser::IncDecStmtContext>(0);
}

myParser::AssignmentContext* myParser::SimpleStmtContext::assignment() {
  return getRuleContext<myParser::AssignmentContext>(0);
}

myParser::ShortVarDeclContext* myParser::SimpleStmtContext::shortVarDecl() {
  return getRuleContext<myParser::ShortVarDeclContext>(0);
}

myParser::EmptyStmtContext* myParser::SimpleStmtContext::emptyStmt() {
  return getRuleContext<myParser::EmptyStmtContext>(0);
}


size_t myParser::SimpleStmtContext::getRuleIndex() const {
  return myParser::RuleSimpleStmt;
}

void myParser::SimpleStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleStmt(this);
}

void myParser::SimpleStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleStmt(this);
}

myParser::SimpleStmtContext* myParser::simpleStmt() {
  SimpleStmtContext *_localctx = _tracker.createInstance<SimpleStmtContext>(_ctx, getState());
  enterRule(_localctx, 44, myParser::RuleSimpleStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(402);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(396);
      sendStmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(397);
      expressionStmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(398);
      incDecStmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(399);
      assignment();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(400);
      shortVarDecl();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(401);
      emptyStmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionStmtContext ------------------------------------------------------------------

myParser::ExpressionStmtContext::ExpressionStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionContext* myParser::ExpressionStmtContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}


size_t myParser::ExpressionStmtContext::getRuleIndex() const {
  return myParser::RuleExpressionStmt;
}

void myParser::ExpressionStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionStmt(this);
}

void myParser::ExpressionStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionStmt(this);
}

myParser::ExpressionStmtContext* myParser::expressionStmt() {
  ExpressionStmtContext *_localctx = _tracker.createInstance<ExpressionStmtContext>(_ctx, getState());
  enterRule(_localctx, 46, myParser::RuleExpressionStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(404);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SendStmtContext ------------------------------------------------------------------

myParser::SendStmtContext::SendStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::ExpressionContext *> myParser::SendStmtContext::expression() {
  return getRuleContexts<myParser::ExpressionContext>();
}

myParser::ExpressionContext* myParser::SendStmtContext::expression(size_t i) {
  return getRuleContext<myParser::ExpressionContext>(i);
}


size_t myParser::SendStmtContext::getRuleIndex() const {
  return myParser::RuleSendStmt;
}

void myParser::SendStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSendStmt(this);
}

void myParser::SendStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSendStmt(this);
}

myParser::SendStmtContext* myParser::sendStmt() {
  SendStmtContext *_localctx = _tracker.createInstance<SendStmtContext>(_ctx, getState());
  enterRule(_localctx, 48, myParser::RuleSendStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(406);
    expression(0);
    setState(407);
    match(myParser::T__14);
    setState(408);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IncDecStmtContext ------------------------------------------------------------------

myParser::IncDecStmtContext::IncDecStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionContext* myParser::IncDecStmtContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}


size_t myParser::IncDecStmtContext::getRuleIndex() const {
  return myParser::RuleIncDecStmt;
}

void myParser::IncDecStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIncDecStmt(this);
}

void myParser::IncDecStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIncDecStmt(this);
}

myParser::IncDecStmtContext* myParser::incDecStmt() {
  IncDecStmtContext *_localctx = _tracker.createInstance<IncDecStmtContext>(_ctx, getState());
  enterRule(_localctx, 50, myParser::RuleIncDecStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(410);
    expression(0);
    setState(411);
    _la = _input->LA(1);
    if (!(_la == myParser::T__15

    || _la == myParser::T__16)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentContext ------------------------------------------------------------------

myParser::AssignmentContext::AssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::ExpressionListContext *> myParser::AssignmentContext::expressionList() {
  return getRuleContexts<myParser::ExpressionListContext>();
}

myParser::ExpressionListContext* myParser::AssignmentContext::expressionList(size_t i) {
  return getRuleContext<myParser::ExpressionListContext>(i);
}

myParser::Assign_opContext* myParser::AssignmentContext::assign_op() {
  return getRuleContext<myParser::Assign_opContext>(0);
}


size_t myParser::AssignmentContext::getRuleIndex() const {
  return myParser::RuleAssignment;
}

void myParser::AssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment(this);
}

void myParser::AssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment(this);
}

myParser::AssignmentContext* myParser::assignment() {
  AssignmentContext *_localctx = _tracker.createInstance<AssignmentContext>(_ctx, getState());
  enterRule(_localctx, 52, myParser::RuleAssignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(413);
    expressionList();
    setState(414);
    assign_op();
    setState(415);
    expressionList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assign_opContext ------------------------------------------------------------------

myParser::Assign_opContext::Assign_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t myParser::Assign_opContext::getRuleIndex() const {
  return myParser::RuleAssign_op;
}

void myParser::Assign_opContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssign_op(this);
}

void myParser::Assign_opContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssign_op(this);
}

myParser::Assign_opContext* myParser::assign_op() {
  Assign_opContext *_localctx = _tracker.createInstance<Assign_opContext>(_ctx, getState());
  enterRule(_localctx, 54, myParser::RuleAssign_op);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(418);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 536608768) != 0) {
      setState(417);
      _la = _input->LA(1);
      if (!(((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 536608768) != 0)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(420);
    match(myParser::T__6);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShortVarDeclContext ------------------------------------------------------------------

myParser::ShortVarDeclContext::ShortVarDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierListContext* myParser::ShortVarDeclContext::identifierList() {
  return getRuleContext<myParser::IdentifierListContext>(0);
}

myParser::ExpressionListContext* myParser::ShortVarDeclContext::expressionList() {
  return getRuleContext<myParser::ExpressionListContext>(0);
}


size_t myParser::ShortVarDeclContext::getRuleIndex() const {
  return myParser::RuleShortVarDecl;
}

void myParser::ShortVarDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShortVarDecl(this);
}

void myParser::ShortVarDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShortVarDecl(this);
}

myParser::ShortVarDeclContext* myParser::shortVarDecl() {
  ShortVarDeclContext *_localctx = _tracker.createInstance<ShortVarDeclContext>(_ctx, getState());
  enterRule(_localctx, 56, myParser::RuleShortVarDecl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(422);
    identifierList();
    setState(423);
    match(myParser::T__28);
    setState(424);
    expressionList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmptyStmtContext ------------------------------------------------------------------

myParser::EmptyStmtContext::EmptyStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t myParser::EmptyStmtContext::getRuleIndex() const {
  return myParser::RuleEmptyStmt;
}

void myParser::EmptyStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmptyStmt(this);
}

void myParser::EmptyStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmptyStmt(this);
}

myParser::EmptyStmtContext* myParser::emptyStmt() {
  EmptyStmtContext *_localctx = _tracker.createInstance<EmptyStmtContext>(_ctx, getState());
  enterRule(_localctx, 58, myParser::RuleEmptyStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(426);
    match(myParser::T__9);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabeledStmtContext ------------------------------------------------------------------

myParser::LabeledStmtContext::LabeledStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::LabeledStmtContext::IDENTIFIER() {
  return getToken(myParser::IDENTIFIER, 0);
}

myParser::StatementContext* myParser::LabeledStmtContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}


size_t myParser::LabeledStmtContext::getRuleIndex() const {
  return myParser::RuleLabeledStmt;
}

void myParser::LabeledStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabeledStmt(this);
}

void myParser::LabeledStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabeledStmt(this);
}

myParser::LabeledStmtContext* myParser::labeledStmt() {
  LabeledStmtContext *_localctx = _tracker.createInstance<LabeledStmtContext>(_ctx, getState());
  enterRule(_localctx, 60, myParser::RuleLabeledStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(428);
    match(myParser::IDENTIFIER);
    setState(429);
    match(myParser::T__29);
    setState(430);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnStmtContext ------------------------------------------------------------------

myParser::ReturnStmtContext::ReturnStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionListContext* myParser::ReturnStmtContext::expressionList() {
  return getRuleContext<myParser::ExpressionListContext>(0);
}


size_t myParser::ReturnStmtContext::getRuleIndex() const {
  return myParser::RuleReturnStmt;
}

void myParser::ReturnStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnStmt(this);
}

void myParser::ReturnStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnStmt(this);
}

myParser::ReturnStmtContext* myParser::returnStmt() {
  ReturnStmtContext *_localctx = _tracker.createInstance<ReturnStmtContext>(_ctx, getState());
  enterRule(_localctx, 62, myParser::RuleReturnStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(432);
    match(myParser::T__30);
    setState(434);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
    case 1: {
      setState(433);
      expressionList();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BreakStmtContext ------------------------------------------------------------------

myParser::BreakStmtContext::BreakStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::BreakStmtContext::IDENTIFIER() {
  return getToken(myParser::IDENTIFIER, 0);
}


size_t myParser::BreakStmtContext::getRuleIndex() const {
  return myParser::RuleBreakStmt;
}

void myParser::BreakStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBreakStmt(this);
}

void myParser::BreakStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBreakStmt(this);
}

myParser::BreakStmtContext* myParser::breakStmt() {
  BreakStmtContext *_localctx = _tracker.createInstance<BreakStmtContext>(_ctx, getState());
  enterRule(_localctx, 64, myParser::RuleBreakStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(436);
    match(myParser::T__31);
    setState(438);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
    case 1: {
      setState(437);
      match(myParser::IDENTIFIER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ContinueStmtContext ------------------------------------------------------------------

myParser::ContinueStmtContext::ContinueStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ContinueStmtContext::IDENTIFIER() {
  return getToken(myParser::IDENTIFIER, 0);
}


size_t myParser::ContinueStmtContext::getRuleIndex() const {
  return myParser::RuleContinueStmt;
}

void myParser::ContinueStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContinueStmt(this);
}

void myParser::ContinueStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContinueStmt(this);
}

myParser::ContinueStmtContext* myParser::continueStmt() {
  ContinueStmtContext *_localctx = _tracker.createInstance<ContinueStmtContext>(_ctx, getState());
  enterRule(_localctx, 66, myParser::RuleContinueStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(440);
    match(myParser::T__32);
    setState(442);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
    case 1: {
      setState(441);
      match(myParser::IDENTIFIER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GotoStmtContext ------------------------------------------------------------------

myParser::GotoStmtContext::GotoStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::GotoStmtContext::IDENTIFIER() {
  return getToken(myParser::IDENTIFIER, 0);
}


size_t myParser::GotoStmtContext::getRuleIndex() const {
  return myParser::RuleGotoStmt;
}

void myParser::GotoStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGotoStmt(this);
}

void myParser::GotoStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGotoStmt(this);
}

myParser::GotoStmtContext* myParser::gotoStmt() {
  GotoStmtContext *_localctx = _tracker.createInstance<GotoStmtContext>(_ctx, getState());
  enterRule(_localctx, 68, myParser::RuleGotoStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(444);
    match(myParser::T__33);
    setState(445);
    match(myParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FallthroughStmtContext ------------------------------------------------------------------

myParser::FallthroughStmtContext::FallthroughStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t myParser::FallthroughStmtContext::getRuleIndex() const {
  return myParser::RuleFallthroughStmt;
}

void myParser::FallthroughStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFallthroughStmt(this);
}

void myParser::FallthroughStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFallthroughStmt(this);
}

myParser::FallthroughStmtContext* myParser::fallthroughStmt() {
  FallthroughStmtContext *_localctx = _tracker.createInstance<FallthroughStmtContext>(_ctx, getState());
  enterRule(_localctx, 70, myParser::RuleFallthroughStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(447);
    match(myParser::T__34);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeferStmtContext ------------------------------------------------------------------

myParser::DeferStmtContext::DeferStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionContext* myParser::DeferStmtContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}


size_t myParser::DeferStmtContext::getRuleIndex() const {
  return myParser::RuleDeferStmt;
}

void myParser::DeferStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeferStmt(this);
}

void myParser::DeferStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeferStmt(this);
}

myParser::DeferStmtContext* myParser::deferStmt() {
  DeferStmtContext *_localctx = _tracker.createInstance<DeferStmtContext>(_ctx, getState());
  enterRule(_localctx, 72, myParser::RuleDeferStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(449);
    match(myParser::T__35);
    setState(450);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStmtContext ------------------------------------------------------------------

myParser::IfStmtContext::IfStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionContext* myParser::IfStmtContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

std::vector<myParser::BlockContext *> myParser::IfStmtContext::block() {
  return getRuleContexts<myParser::BlockContext>();
}

myParser::BlockContext* myParser::IfStmtContext::block(size_t i) {
  return getRuleContext<myParser::BlockContext>(i);
}

myParser::SimpleStmtContext* myParser::IfStmtContext::simpleStmt() {
  return getRuleContext<myParser::SimpleStmtContext>(0);
}

myParser::IfStmtContext* myParser::IfStmtContext::ifStmt() {
  return getRuleContext<myParser::IfStmtContext>(0);
}


size_t myParser::IfStmtContext::getRuleIndex() const {
  return myParser::RuleIfStmt;
}

void myParser::IfStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfStmt(this);
}

void myParser::IfStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfStmt(this);
}

myParser::IfStmtContext* myParser::ifStmt() {
  IfStmtContext *_localctx = _tracker.createInstance<IfStmtContext>(_ctx, getState());
  enterRule(_localctx, 74, myParser::RuleIfStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(452);
    match(myParser::T__36);
    setState(456);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
    case 1: {
      setState(453);
      simpleStmt();
      setState(454);
      match(myParser::T__9);
      break;
    }

    default:
      break;
    }
    setState(458);
    expression(0);
    setState(459);
    block();
    setState(465);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::T__37) {
      setState(460);
      match(myParser::T__37);
      setState(463);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case myParser::T__36: {
          setState(461);
          ifStmt();
          break;
        }

        case myParser::T__12: {
          setState(462);
          block();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SwitchStmtContext ------------------------------------------------------------------

myParser::SwitchStmtContext::SwitchStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExprSwitchStmtContext* myParser::SwitchStmtContext::exprSwitchStmt() {
  return getRuleContext<myParser::ExprSwitchStmtContext>(0);
}

myParser::TypeSwitchStmtContext* myParser::SwitchStmtContext::typeSwitchStmt() {
  return getRuleContext<myParser::TypeSwitchStmtContext>(0);
}


size_t myParser::SwitchStmtContext::getRuleIndex() const {
  return myParser::RuleSwitchStmt;
}

void myParser::SwitchStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitchStmt(this);
}

void myParser::SwitchStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitchStmt(this);
}

myParser::SwitchStmtContext* myParser::switchStmt() {
  SwitchStmtContext *_localctx = _tracker.createInstance<SwitchStmtContext>(_ctx, getState());
  enterRule(_localctx, 76, myParser::RuleSwitchStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(469);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(467);
      exprSwitchStmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(468);
      typeSwitchStmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprSwitchStmtContext ------------------------------------------------------------------

myParser::ExprSwitchStmtContext::ExprSwitchStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SimpleStmtContext* myParser::ExprSwitchStmtContext::simpleStmt() {
  return getRuleContext<myParser::SimpleStmtContext>(0);
}

myParser::ExpressionContext* myParser::ExprSwitchStmtContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

std::vector<myParser::ExprCaseClauseContext *> myParser::ExprSwitchStmtContext::exprCaseClause() {
  return getRuleContexts<myParser::ExprCaseClauseContext>();
}

myParser::ExprCaseClauseContext* myParser::ExprSwitchStmtContext::exprCaseClause(size_t i) {
  return getRuleContext<myParser::ExprCaseClauseContext>(i);
}


size_t myParser::ExprSwitchStmtContext::getRuleIndex() const {
  return myParser::RuleExprSwitchStmt;
}

void myParser::ExprSwitchStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprSwitchStmt(this);
}

void myParser::ExprSwitchStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprSwitchStmt(this);
}

myParser::ExprSwitchStmtContext* myParser::exprSwitchStmt() {
  ExprSwitchStmtContext *_localctx = _tracker.createInstance<ExprSwitchStmtContext>(_ctx, getState());
  enterRule(_localctx, 78, myParser::RuleExprSwitchStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(471);
    match(myParser::T__38);
    setState(475);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx)) {
    case 1: {
      setState(472);
      simpleStmt();
      setState(473);
      match(myParser::T__9);
      break;
    }

    default:
      break;
    }
    setState(478);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2312387302563547144) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 633) != 0) {
      setState(477);
      expression(0);
    }
    setState(480);
    match(myParser::T__12);
    setState(484);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::T__39

    || _la == myParser::T__40) {
      setState(481);
      exprCaseClause();
      setState(486);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(487);
    match(myParser::T__13);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprCaseClauseContext ------------------------------------------------------------------

myParser::ExprCaseClauseContext::ExprCaseClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExprSwitchCaseContext* myParser::ExprCaseClauseContext::exprSwitchCase() {
  return getRuleContext<myParser::ExprSwitchCaseContext>(0);
}

myParser::StatementListContext* myParser::ExprCaseClauseContext::statementList() {
  return getRuleContext<myParser::StatementListContext>(0);
}


size_t myParser::ExprCaseClauseContext::getRuleIndex() const {
  return myParser::RuleExprCaseClause;
}

void myParser::ExprCaseClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprCaseClause(this);
}

void myParser::ExprCaseClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprCaseClause(this);
}

myParser::ExprCaseClauseContext* myParser::exprCaseClause() {
  ExprCaseClauseContext *_localctx = _tracker.createInstance<ExprCaseClauseContext>(_ctx, getState());
  enterRule(_localctx, 80, myParser::RuleExprCaseClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(489);
    exprSwitchCase();
    setState(490);
    match(myParser::T__29);
    setState(491);
    statementList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprSwitchCaseContext ------------------------------------------------------------------

myParser::ExprSwitchCaseContext::ExprSwitchCaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionListContext* myParser::ExprSwitchCaseContext::expressionList() {
  return getRuleContext<myParser::ExpressionListContext>(0);
}


size_t myParser::ExprSwitchCaseContext::getRuleIndex() const {
  return myParser::RuleExprSwitchCase;
}

void myParser::ExprSwitchCaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprSwitchCase(this);
}

void myParser::ExprSwitchCaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprSwitchCase(this);
}

myParser::ExprSwitchCaseContext* myParser::exprSwitchCase() {
  ExprSwitchCaseContext *_localctx = _tracker.createInstance<ExprSwitchCaseContext>(_ctx, getState());
  enterRule(_localctx, 82, myParser::RuleExprSwitchCase);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(496);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::T__39: {
        enterOuterAlt(_localctx, 1);
        setState(493);
        match(myParser::T__39);
        setState(494);
        expressionList();
        break;
      }

      case myParser::T__40: {
        enterOuterAlt(_localctx, 2);
        setState(495);
        match(myParser::T__40);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeSwitchStmtContext ------------------------------------------------------------------

myParser::TypeSwitchStmtContext::TypeSwitchStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::TypeSwitchGuardContext* myParser::TypeSwitchStmtContext::typeSwitchGuard() {
  return getRuleContext<myParser::TypeSwitchGuardContext>(0);
}

myParser::SimpleStmtContext* myParser::TypeSwitchStmtContext::simpleStmt() {
  return getRuleContext<myParser::SimpleStmtContext>(0);
}

std::vector<myParser::TypeCaseClauseContext *> myParser::TypeSwitchStmtContext::typeCaseClause() {
  return getRuleContexts<myParser::TypeCaseClauseContext>();
}

myParser::TypeCaseClauseContext* myParser::TypeSwitchStmtContext::typeCaseClause(size_t i) {
  return getRuleContext<myParser::TypeCaseClauseContext>(i);
}


size_t myParser::TypeSwitchStmtContext::getRuleIndex() const {
  return myParser::RuleTypeSwitchStmt;
}

void myParser::TypeSwitchStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeSwitchStmt(this);
}

void myParser::TypeSwitchStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeSwitchStmt(this);
}

myParser::TypeSwitchStmtContext* myParser::typeSwitchStmt() {
  TypeSwitchStmtContext *_localctx = _tracker.createInstance<TypeSwitchStmtContext>(_ctx, getState());
  enterRule(_localctx, 84, myParser::RuleTypeSwitchStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(498);
    match(myParser::T__38);
    setState(502);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
    case 1: {
      setState(499);
      simpleStmt();
      setState(500);
      match(myParser::T__9);
      break;
    }

    default:
      break;
    }
    setState(504);
    typeSwitchGuard();
    setState(505);
    match(myParser::T__12);
    setState(509);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::T__39

    || _la == myParser::T__40) {
      setState(506);
      typeCaseClause();
      setState(511);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(512);
    match(myParser::T__13);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeSwitchGuardContext ------------------------------------------------------------------

myParser::TypeSwitchGuardContext::TypeSwitchGuardContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::PrimaryExprContext* myParser::TypeSwitchGuardContext::primaryExpr() {
  return getRuleContext<myParser::PrimaryExprContext>(0);
}

tree::TerminalNode* myParser::TypeSwitchGuardContext::IDENTIFIER() {
  return getToken(myParser::IDENTIFIER, 0);
}


size_t myParser::TypeSwitchGuardContext::getRuleIndex() const {
  return myParser::RuleTypeSwitchGuard;
}

void myParser::TypeSwitchGuardContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeSwitchGuard(this);
}

void myParser::TypeSwitchGuardContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeSwitchGuard(this);
}

myParser::TypeSwitchGuardContext* myParser::typeSwitchGuard() {
  TypeSwitchGuardContext *_localctx = _tracker.createInstance<TypeSwitchGuardContext>(_ctx, getState());
  enterRule(_localctx, 86, myParser::RuleTypeSwitchGuard);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(516);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx)) {
    case 1: {
      setState(514);
      match(myParser::IDENTIFIER);
      setState(515);
      match(myParser::T__28);
      break;
    }

    default:
      break;
    }
    setState(518);
    primaryExpr(0);
    setState(519);
    match(myParser::T__4);
    setState(520);
    match(myParser::T__2);
    setState(521);
    match(myParser::T__8);
    setState(522);
    match(myParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeCaseClauseContext ------------------------------------------------------------------

myParser::TypeCaseClauseContext::TypeCaseClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::TypeSwitchCaseContext* myParser::TypeCaseClauseContext::typeSwitchCase() {
  return getRuleContext<myParser::TypeSwitchCaseContext>(0);
}

myParser::StatementListContext* myParser::TypeCaseClauseContext::statementList() {
  return getRuleContext<myParser::StatementListContext>(0);
}


size_t myParser::TypeCaseClauseContext::getRuleIndex() const {
  return myParser::RuleTypeCaseClause;
}

void myParser::TypeCaseClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeCaseClause(this);
}

void myParser::TypeCaseClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeCaseClause(this);
}

myParser::TypeCaseClauseContext* myParser::typeCaseClause() {
  TypeCaseClauseContext *_localctx = _tracker.createInstance<TypeCaseClauseContext>(_ctx, getState());
  enterRule(_localctx, 88, myParser::RuleTypeCaseClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(524);
    typeSwitchCase();
    setState(525);
    match(myParser::T__29);
    setState(526);
    statementList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeSwitchCaseContext ------------------------------------------------------------------

myParser::TypeSwitchCaseContext::TypeSwitchCaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::TypeListContext* myParser::TypeSwitchCaseContext::typeList() {
  return getRuleContext<myParser::TypeListContext>(0);
}


size_t myParser::TypeSwitchCaseContext::getRuleIndex() const {
  return myParser::RuleTypeSwitchCase;
}

void myParser::TypeSwitchCaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeSwitchCase(this);
}

void myParser::TypeSwitchCaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeSwitchCase(this);
}

myParser::TypeSwitchCaseContext* myParser::typeSwitchCase() {
  TypeSwitchCaseContext *_localctx = _tracker.createInstance<TypeSwitchCaseContext>(_ctx, getState());
  enterRule(_localctx, 90, myParser::RuleTypeSwitchCase);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(531);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::T__39: {
        enterOuterAlt(_localctx, 1);
        setState(528);
        match(myParser::T__39);
        setState(529);
        typeList();
        break;
      }

      case myParser::T__40: {
        enterOuterAlt(_localctx, 2);
        setState(530);
        match(myParser::T__40);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeListContext ------------------------------------------------------------------

myParser::TypeListContext::TypeListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::GoTypeContext *> myParser::TypeListContext::goType() {
  return getRuleContexts<myParser::GoTypeContext>();
}

myParser::GoTypeContext* myParser::TypeListContext::goType(size_t i) {
  return getRuleContext<myParser::GoTypeContext>(i);
}


size_t myParser::TypeListContext::getRuleIndex() const {
  return myParser::RuleTypeList;
}

void myParser::TypeListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeList(this);
}

void myParser::TypeListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeList(this);
}

myParser::TypeListContext* myParser::typeList() {
  TypeListContext *_localctx = _tracker.createInstance<TypeListContext>(_ctx, getState());
  enterRule(_localctx, 92, myParser::RuleTypeList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(533);
    goType();
    setState(538);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::T__7) {
      setState(534);
      match(myParser::T__7);
      setState(535);
      goType();
      setState(540);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectStmtContext ------------------------------------------------------------------

myParser::SelectStmtContext::SelectStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::CommClauseContext *> myParser::SelectStmtContext::commClause() {
  return getRuleContexts<myParser::CommClauseContext>();
}

myParser::CommClauseContext* myParser::SelectStmtContext::commClause(size_t i) {
  return getRuleContext<myParser::CommClauseContext>(i);
}


size_t myParser::SelectStmtContext::getRuleIndex() const {
  return myParser::RuleSelectStmt;
}

void myParser::SelectStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectStmt(this);
}

void myParser::SelectStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectStmt(this);
}

myParser::SelectStmtContext* myParser::selectStmt() {
  SelectStmtContext *_localctx = _tracker.createInstance<SelectStmtContext>(_ctx, getState());
  enterRule(_localctx, 94, myParser::RuleSelectStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(541);
    match(myParser::T__41);
    setState(542);
    match(myParser::T__12);
    setState(546);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::T__39

    || _la == myParser::T__40) {
      setState(543);
      commClause();
      setState(548);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(549);
    match(myParser::T__13);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommClauseContext ------------------------------------------------------------------

myParser::CommClauseContext::CommClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::CommCaseContext* myParser::CommClauseContext::commCase() {
  return getRuleContext<myParser::CommCaseContext>(0);
}

myParser::StatementListContext* myParser::CommClauseContext::statementList() {
  return getRuleContext<myParser::StatementListContext>(0);
}


size_t myParser::CommClauseContext::getRuleIndex() const {
  return myParser::RuleCommClause;
}

void myParser::CommClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommClause(this);
}

void myParser::CommClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommClause(this);
}

myParser::CommClauseContext* myParser::commClause() {
  CommClauseContext *_localctx = _tracker.createInstance<CommClauseContext>(_ctx, getState());
  enterRule(_localctx, 96, myParser::RuleCommClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(551);
    commCase();
    setState(552);
    match(myParser::T__29);
    setState(553);
    statementList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommCaseContext ------------------------------------------------------------------

myParser::CommCaseContext::CommCaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SendStmtContext* myParser::CommCaseContext::sendStmt() {
  return getRuleContext<myParser::SendStmtContext>(0);
}

myParser::RecvStmtContext* myParser::CommCaseContext::recvStmt() {
  return getRuleContext<myParser::RecvStmtContext>(0);
}


size_t myParser::CommCaseContext::getRuleIndex() const {
  return myParser::RuleCommCase;
}

void myParser::CommCaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommCase(this);
}

void myParser::CommCaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommCase(this);
}

myParser::CommCaseContext* myParser::commCase() {
  CommCaseContext *_localctx = _tracker.createInstance<CommCaseContext>(_ctx, getState());
  enterRule(_localctx, 98, myParser::RuleCommCase);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(561);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::T__39: {
        enterOuterAlt(_localctx, 1);
        setState(555);
        match(myParser::T__39);
        setState(558);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx)) {
        case 1: {
          setState(556);
          sendStmt();
          break;
        }

        case 2: {
          setState(557);
          recvStmt();
          break;
        }

        default:
          break;
        }
        break;
      }

      case myParser::T__40: {
        enterOuterAlt(_localctx, 2);
        setState(560);
        match(myParser::T__40);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RecvStmtContext ------------------------------------------------------------------

myParser::RecvStmtContext::RecvStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionContext* myParser::RecvStmtContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

myParser::ExpressionListContext* myParser::RecvStmtContext::expressionList() {
  return getRuleContext<myParser::ExpressionListContext>(0);
}

myParser::IdentifierListContext* myParser::RecvStmtContext::identifierList() {
  return getRuleContext<myParser::IdentifierListContext>(0);
}


size_t myParser::RecvStmtContext::getRuleIndex() const {
  return myParser::RuleRecvStmt;
}

void myParser::RecvStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRecvStmt(this);
}

void myParser::RecvStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRecvStmt(this);
}

myParser::RecvStmtContext* myParser::recvStmt() {
  RecvStmtContext *_localctx = _tracker.createInstance<RecvStmtContext>(_ctx, getState());
  enterRule(_localctx, 100, myParser::RuleRecvStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(569);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx)) {
    case 1: {
      setState(563);
      expressionList();
      setState(564);
      match(myParser::T__6);
      break;
    }

    case 2: {
      setState(566);
      identifierList();
      setState(567);
      match(myParser::T__28);
      break;
    }

    default:
      break;
    }
    setState(571);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForStmtContext ------------------------------------------------------------------

myParser::ForStmtContext::ForStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::BlockContext* myParser::ForStmtContext::block() {
  return getRuleContext<myParser::BlockContext>(0);
}

myParser::ExpressionContext* myParser::ForStmtContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

myParser::ForClauseContext* myParser::ForStmtContext::forClause() {
  return getRuleContext<myParser::ForClauseContext>(0);
}

myParser::RangeClauseContext* myParser::ForStmtContext::rangeClause() {
  return getRuleContext<myParser::RangeClauseContext>(0);
}


size_t myParser::ForStmtContext::getRuleIndex() const {
  return myParser::RuleForStmt;
}

void myParser::ForStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForStmt(this);
}

void myParser::ForStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForStmt(this);
}

myParser::ForStmtContext* myParser::forStmt() {
  ForStmtContext *_localctx = _tracker.createInstance<ForStmtContext>(_ctx, getState());
  enterRule(_localctx, 102, myParser::RuleForStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(573);
    match(myParser::T__42);
    setState(577);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
    case 1: {
      setState(574);
      expression(0);
      break;
    }

    case 2: {
      setState(575);
      forClause();
      break;
    }

    case 3: {
      setState(576);
      rangeClause();
      break;
    }

    default:
      break;
    }
    setState(579);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForClauseContext ------------------------------------------------------------------

myParser::ForClauseContext::ForClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::SimpleStmtContext *> myParser::ForClauseContext::simpleStmt() {
  return getRuleContexts<myParser::SimpleStmtContext>();
}

myParser::SimpleStmtContext* myParser::ForClauseContext::simpleStmt(size_t i) {
  return getRuleContext<myParser::SimpleStmtContext>(i);
}

myParser::ExpressionContext* myParser::ForClauseContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}


size_t myParser::ForClauseContext::getRuleIndex() const {
  return myParser::RuleForClause;
}

void myParser::ForClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForClause(this);
}

void myParser::ForClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForClause(this);
}

myParser::ForClauseContext* myParser::forClause() {
  ForClauseContext *_localctx = _tracker.createInstance<ForClauseContext>(_ctx, getState());
  enterRule(_localctx, 104, myParser::RuleForClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(582);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx)) {
    case 1: {
      setState(581);
      simpleStmt();
      break;
    }

    default:
      break;
    }
    setState(584);
    match(myParser::T__9);
    setState(586);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2312387302563547144) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 633) != 0) {
      setState(585);
      expression(0);
    }
    setState(588);
    match(myParser::T__9);
    setState(590);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2312387302563548168) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 633) != 0) {
      setState(589);
      simpleStmt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RangeClauseContext ------------------------------------------------------------------

myParser::RangeClauseContext::RangeClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionContext* myParser::RangeClauseContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

myParser::ExpressionListContext* myParser::RangeClauseContext::expressionList() {
  return getRuleContext<myParser::ExpressionListContext>(0);
}

myParser::IdentifierListContext* myParser::RangeClauseContext::identifierList() {
  return getRuleContext<myParser::IdentifierListContext>(0);
}


size_t myParser::RangeClauseContext::getRuleIndex() const {
  return myParser::RuleRangeClause;
}

void myParser::RangeClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRangeClause(this);
}

void myParser::RangeClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRangeClause(this);
}

myParser::RangeClauseContext* myParser::rangeClause() {
  RangeClauseContext *_localctx = _tracker.createInstance<RangeClauseContext>(_ctx, getState());
  enterRule(_localctx, 106, myParser::RuleRangeClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(598);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {
    case 1: {
      setState(592);
      expressionList();
      setState(593);
      match(myParser::T__6);
      break;
    }

    case 2: {
      setState(595);
      identifierList();
      setState(596);
      match(myParser::T__28);
      break;
    }

    default:
      break;
    }
    setState(600);
    match(myParser::T__43);
    setState(601);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GoStmtContext ------------------------------------------------------------------

myParser::GoStmtContext::GoStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionContext* myParser::GoStmtContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}


size_t myParser::GoStmtContext::getRuleIndex() const {
  return myParser::RuleGoStmt;
}

void myParser::GoStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGoStmt(this);
}

void myParser::GoStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGoStmt(this);
}

myParser::GoStmtContext* myParser::goStmt() {
  GoStmtContext *_localctx = _tracker.createInstance<GoStmtContext>(_ctx, getState());
  enterRule(_localctx, 108, myParser::RuleGoStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(603);
    match(myParser::T__44);
    setState(604);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GoTypeContext ------------------------------------------------------------------

myParser::GoTypeContext::GoTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::TypeNameContext* myParser::GoTypeContext::typeName() {
  return getRuleContext<myParser::TypeNameContext>(0);
}

myParser::TypeLitContext* myParser::GoTypeContext::typeLit() {
  return getRuleContext<myParser::TypeLitContext>(0);
}

myParser::GoTypeContext* myParser::GoTypeContext::goType() {
  return getRuleContext<myParser::GoTypeContext>(0);
}


size_t myParser::GoTypeContext::getRuleIndex() const {
  return myParser::RuleGoType;
}

void myParser::GoTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGoType(this);
}

void myParser::GoTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGoType(this);
}

myParser::GoTypeContext* myParser::goType() {
  GoTypeContext *_localctx = _tracker.createInstance<GoTypeContext>(_ctx, getState());
  enterRule(_localctx, 110, myParser::RuleGoType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(612);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(606);
        typeName();
        break;
      }

      case myParser::T__10:
      case myParser::T__14:
      case myParser::T__21:
      case myParser::T__45:
      case myParser::T__47:
      case myParser::T__48:
      case myParser::T__49:
      case myParser::T__51: {
        enterOuterAlt(_localctx, 2);
        setState(607);
        typeLit();
        break;
      }

      case myParser::T__2: {
        enterOuterAlt(_localctx, 3);
        setState(608);
        match(myParser::T__2);
        setState(609);
        goType();
        setState(610);
        match(myParser::T__3);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeNameContext ------------------------------------------------------------------

myParser::TypeNameContext::TypeNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TypeNameContext::IDENTIFIER() {
  return getToken(myParser::IDENTIFIER, 0);
}

myParser::QualifiedIdentContext* myParser::TypeNameContext::qualifiedIdent() {
  return getRuleContext<myParser::QualifiedIdentContext>(0);
}


size_t myParser::TypeNameContext::getRuleIndex() const {
  return myParser::RuleTypeName;
}

void myParser::TypeNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeName(this);
}

void myParser::TypeNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeName(this);
}

myParser::TypeNameContext* myParser::typeName() {
  TypeNameContext *_localctx = _tracker.createInstance<TypeNameContext>(_ctx, getState());
  enterRule(_localctx, 112, myParser::RuleTypeName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(616);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(614);
      match(myParser::IDENTIFIER);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(615);
      qualifiedIdent();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeLitContext ------------------------------------------------------------------

myParser::TypeLitContext::TypeLitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ArrayTypeContext* myParser::TypeLitContext::arrayType() {
  return getRuleContext<myParser::ArrayTypeContext>(0);
}

myParser::StructTypeContext* myParser::TypeLitContext::structType() {
  return getRuleContext<myParser::StructTypeContext>(0);
}

myParser::PointerTypeContext* myParser::TypeLitContext::pointerType() {
  return getRuleContext<myParser::PointerTypeContext>(0);
}

myParser::FunctionTypeContext* myParser::TypeLitContext::functionType() {
  return getRuleContext<myParser::FunctionTypeContext>(0);
}

myParser::InterfaceTypeContext* myParser::TypeLitContext::interfaceType() {
  return getRuleContext<myParser::InterfaceTypeContext>(0);
}

myParser::SliceTypeContext* myParser::TypeLitContext::sliceType() {
  return getRuleContext<myParser::SliceTypeContext>(0);
}

myParser::MapTypeContext* myParser::TypeLitContext::mapType() {
  return getRuleContext<myParser::MapTypeContext>(0);
}

myParser::ChannelTypeContext* myParser::TypeLitContext::channelType() {
  return getRuleContext<myParser::ChannelTypeContext>(0);
}


size_t myParser::TypeLitContext::getRuleIndex() const {
  return myParser::RuleTypeLit;
}

void myParser::TypeLitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeLit(this);
}

void myParser::TypeLitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeLit(this);
}

myParser::TypeLitContext* myParser::typeLit() {
  TypeLitContext *_localctx = _tracker.createInstance<TypeLitContext>(_ctx, getState());
  enterRule(_localctx, 114, myParser::RuleTypeLit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(626);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(618);
      arrayType();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(619);
      structType();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(620);
      pointerType();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(621);
      functionType();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(622);
      interfaceType();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(623);
      sliceType();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(624);
      mapType();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(625);
      channelType();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayTypeContext ------------------------------------------------------------------

myParser::ArrayTypeContext::ArrayTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ArrayLengthContext* myParser::ArrayTypeContext::arrayLength() {
  return getRuleContext<myParser::ArrayLengthContext>(0);
}

myParser::ElementTypeContext* myParser::ArrayTypeContext::elementType() {
  return getRuleContext<myParser::ElementTypeContext>(0);
}


size_t myParser::ArrayTypeContext::getRuleIndex() const {
  return myParser::RuleArrayType;
}

void myParser::ArrayTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayType(this);
}

void myParser::ArrayTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayType(this);
}

myParser::ArrayTypeContext* myParser::arrayType() {
  ArrayTypeContext *_localctx = _tracker.createInstance<ArrayTypeContext>(_ctx, getState());
  enterRule(_localctx, 116, myParser::RuleArrayType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(628);
    match(myParser::T__45);
    setState(629);
    arrayLength();
    setState(630);
    match(myParser::T__46);
    setState(631);
    elementType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayLengthContext ------------------------------------------------------------------

myParser::ArrayLengthContext::ArrayLengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionContext* myParser::ArrayLengthContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}


size_t myParser::ArrayLengthContext::getRuleIndex() const {
  return myParser::RuleArrayLength;
}

void myParser::ArrayLengthContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayLength(this);
}

void myParser::ArrayLengthContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayLength(this);
}

myParser::ArrayLengthContext* myParser::arrayLength() {
  ArrayLengthContext *_localctx = _tracker.createInstance<ArrayLengthContext>(_ctx, getState());
  enterRule(_localctx, 118, myParser::RuleArrayLength);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(633);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementTypeContext ------------------------------------------------------------------

myParser::ElementTypeContext::ElementTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::GoTypeContext* myParser::ElementTypeContext::goType() {
  return getRuleContext<myParser::GoTypeContext>(0);
}


size_t myParser::ElementTypeContext::getRuleIndex() const {
  return myParser::RuleElementType;
}

void myParser::ElementTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElementType(this);
}

void myParser::ElementTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElementType(this);
}

myParser::ElementTypeContext* myParser::elementType() {
  ElementTypeContext *_localctx = _tracker.createInstance<ElementTypeContext>(_ctx, getState());
  enterRule(_localctx, 120, myParser::RuleElementType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(635);
    goType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PointerTypeContext ------------------------------------------------------------------

myParser::PointerTypeContext::PointerTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::GoTypeContext* myParser::PointerTypeContext::goType() {
  return getRuleContext<myParser::GoTypeContext>(0);
}


size_t myParser::PointerTypeContext::getRuleIndex() const {
  return myParser::RulePointerType;
}

void myParser::PointerTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPointerType(this);
}

void myParser::PointerTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPointerType(this);
}

myParser::PointerTypeContext* myParser::pointerType() {
  PointerTypeContext *_localctx = _tracker.createInstance<PointerTypeContext>(_ctx, getState());
  enterRule(_localctx, 122, myParser::RulePointerType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(637);
    match(myParser::T__21);
    setState(638);
    goType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InterfaceTypeContext ------------------------------------------------------------------

myParser::InterfaceTypeContext::InterfaceTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::MethodSpecContext *> myParser::InterfaceTypeContext::methodSpec() {
  return getRuleContexts<myParser::MethodSpecContext>();
}

myParser::MethodSpecContext* myParser::InterfaceTypeContext::methodSpec(size_t i) {
  return getRuleContext<myParser::MethodSpecContext>(i);
}


size_t myParser::InterfaceTypeContext::getRuleIndex() const {
  return myParser::RuleInterfaceType;
}

void myParser::InterfaceTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterfaceType(this);
}

void myParser::InterfaceTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterfaceType(this);
}

myParser::InterfaceTypeContext* myParser::interfaceType() {
  InterfaceTypeContext *_localctx = _tracker.createInstance<InterfaceTypeContext>(_ctx, getState());
  enterRule(_localctx, 124, myParser::RuleInterfaceType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(640);
    match(myParser::T__47);
    setState(641);
    match(myParser::T__12);
    setState(645);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::IDENTIFIER) {
      setState(642);
      methodSpec();
      setState(647);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(648);
    match(myParser::T__13);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SliceTypeContext ------------------------------------------------------------------

myParser::SliceTypeContext::SliceTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ElementTypeContext* myParser::SliceTypeContext::elementType() {
  return getRuleContext<myParser::ElementTypeContext>(0);
}


size_t myParser::SliceTypeContext::getRuleIndex() const {
  return myParser::RuleSliceType;
}

void myParser::SliceTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSliceType(this);
}

void myParser::SliceTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSliceType(this);
}

myParser::SliceTypeContext* myParser::sliceType() {
  SliceTypeContext *_localctx = _tracker.createInstance<SliceTypeContext>(_ctx, getState());
  enterRule(_localctx, 126, myParser::RuleSliceType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(650);
    match(myParser::T__45);
    setState(651);
    match(myParser::T__46);
    setState(652);
    elementType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MapTypeContext ------------------------------------------------------------------

myParser::MapTypeContext::MapTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::GoTypeContext* myParser::MapTypeContext::goType() {
  return getRuleContext<myParser::GoTypeContext>(0);
}

myParser::ElementTypeContext* myParser::MapTypeContext::elementType() {
  return getRuleContext<myParser::ElementTypeContext>(0);
}


size_t myParser::MapTypeContext::getRuleIndex() const {
  return myParser::RuleMapType;
}

void myParser::MapTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMapType(this);
}

void myParser::MapTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMapType(this);
}

myParser::MapTypeContext* myParser::mapType() {
  MapTypeContext *_localctx = _tracker.createInstance<MapTypeContext>(_ctx, getState());
  enterRule(_localctx, 128, myParser::RuleMapType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(654);
    match(myParser::T__48);
    setState(655);
    match(myParser::T__45);
    setState(656);
    goType();
    setState(657);
    match(myParser::T__46);
    setState(658);
    elementType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChannelTypeContext ------------------------------------------------------------------

myParser::ChannelTypeContext::ChannelTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ElementTypeContext* myParser::ChannelTypeContext::elementType() {
  return getRuleContext<myParser::ElementTypeContext>(0);
}


size_t myParser::ChannelTypeContext::getRuleIndex() const {
  return myParser::RuleChannelType;
}

void myParser::ChannelTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChannelType(this);
}

void myParser::ChannelTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChannelType(this);
}

myParser::ChannelTypeContext* myParser::channelType() {
  ChannelTypeContext *_localctx = _tracker.createInstance<ChannelTypeContext>(_ctx, getState());
  enterRule(_localctx, 130, myParser::RuleChannelType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(665);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
    case 1: {
      setState(660);
      match(myParser::T__49);
      break;
    }

    case 2: {
      setState(661);
      match(myParser::T__49);
      setState(662);
      match(myParser::T__14);
      break;
    }

    case 3: {
      setState(663);
      match(myParser::T__14);
      setState(664);
      match(myParser::T__49);
      break;
    }

    default:
      break;
    }
    setState(667);
    elementType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MethodSpecContext ------------------------------------------------------------------

myParser::MethodSpecContext::MethodSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::MethodSpecContext::IDENTIFIER() {
  return getToken(myParser::IDENTIFIER, 0);
}

myParser::SignatureContext* myParser::MethodSpecContext::signature() {
  return getRuleContext<myParser::SignatureContext>(0);
}

myParser::TypeNameContext* myParser::MethodSpecContext::typeName() {
  return getRuleContext<myParser::TypeNameContext>(0);
}


size_t myParser::MethodSpecContext::getRuleIndex() const {
  return myParser::RuleMethodSpec;
}

void myParser::MethodSpecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMethodSpec(this);
}

void myParser::MethodSpecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMethodSpec(this);
}

myParser::MethodSpecContext* myParser::methodSpec() {
  MethodSpecContext *_localctx = _tracker.createInstance<MethodSpecContext>(_ctx, getState());
  enterRule(_localctx, 132, myParser::RuleMethodSpec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(672);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(669);
      match(myParser::IDENTIFIER);
      setState(670);
      signature();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(671);
      typeName();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionTypeContext ------------------------------------------------------------------

myParser::FunctionTypeContext::FunctionTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SignatureContext* myParser::FunctionTypeContext::signature() {
  return getRuleContext<myParser::SignatureContext>(0);
}


size_t myParser::FunctionTypeContext::getRuleIndex() const {
  return myParser::RuleFunctionType;
}

void myParser::FunctionTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionType(this);
}

void myParser::FunctionTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionType(this);
}

myParser::FunctionTypeContext* myParser::functionType() {
  FunctionTypeContext *_localctx = _tracker.createInstance<FunctionTypeContext>(_ctx, getState());
  enterRule(_localctx, 134, myParser::RuleFunctionType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(674);
    match(myParser::T__10);
    setState(675);
    signature();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignatureContext ------------------------------------------------------------------

myParser::SignatureContext::SignatureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ParametersContext* myParser::SignatureContext::parameters() {
  return getRuleContext<myParser::ParametersContext>(0);
}

myParser::ResultContext* myParser::SignatureContext::result() {
  return getRuleContext<myParser::ResultContext>(0);
}


size_t myParser::SignatureContext::getRuleIndex() const {
  return myParser::RuleSignature;
}

void myParser::SignatureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignature(this);
}

void myParser::SignatureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignature(this);
}

myParser::SignatureContext* myParser::signature() {
  SignatureContext *_localctx = _tracker.createInstance<SignatureContext>(_ctx, getState());
  enterRule(_localctx, 136, myParser::RuleSignature);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(677);
    parameters();
    setState(679);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {
    case 1: {
      setState(678);
      result();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResultContext ------------------------------------------------------------------

myParser::ResultContext::ResultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ParametersContext* myParser::ResultContext::parameters() {
  return getRuleContext<myParser::ParametersContext>(0);
}

myParser::GoTypeContext* myParser::ResultContext::goType() {
  return getRuleContext<myParser::GoTypeContext>(0);
}


size_t myParser::ResultContext::getRuleIndex() const {
  return myParser::RuleResult;
}

void myParser::ResultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResult(this);
}

void myParser::ResultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResult(this);
}

myParser::ResultContext* myParser::result() {
  ResultContext *_localctx = _tracker.createInstance<ResultContext>(_ctx, getState());
  enterRule(_localctx, 138, myParser::RuleResult);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(683);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(681);
      parameters();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(682);
      goType();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParametersContext ------------------------------------------------------------------

myParser::ParametersContext::ParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ParameterListContext* myParser::ParametersContext::parameterList() {
  return getRuleContext<myParser::ParameterListContext>(0);
}


size_t myParser::ParametersContext::getRuleIndex() const {
  return myParser::RuleParameters;
}

void myParser::ParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameters(this);
}

void myParser::ParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameters(this);
}

myParser::ParametersContext* myParser::parameters() {
  ParametersContext *_localctx = _tracker.createInstance<ParametersContext>(_ctx, getState());
  enterRule(_localctx, 140, myParser::RuleParameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(685);
    match(myParser::T__2);
    setState(690);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la - 3) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 3)) & 2306942520841998593) != 0) {
      setState(686);
      parameterList();
      setState(688);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::T__7) {
        setState(687);
        match(myParser::T__7);
      }
    }
    setState(692);
    match(myParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterListContext ------------------------------------------------------------------

myParser::ParameterListContext::ParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::ParameterDeclContext *> myParser::ParameterListContext::parameterDecl() {
  return getRuleContexts<myParser::ParameterDeclContext>();
}

myParser::ParameterDeclContext* myParser::ParameterListContext::parameterDecl(size_t i) {
  return getRuleContext<myParser::ParameterDeclContext>(i);
}


size_t myParser::ParameterListContext::getRuleIndex() const {
  return myParser::RuleParameterList;
}

void myParser::ParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameterList(this);
}

void myParser::ParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameterList(this);
}

myParser::ParameterListContext* myParser::parameterList() {
  ParameterListContext *_localctx = _tracker.createInstance<ParameterListContext>(_ctx, getState());
  enterRule(_localctx, 142, myParser::RuleParameterList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(694);
    parameterDecl();
    setState(699);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(695);
        match(myParser::T__7);
        setState(696);
        parameterDecl(); 
      }
      setState(701);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterDeclContext ------------------------------------------------------------------

myParser::ParameterDeclContext::ParameterDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::GoTypeContext* myParser::ParameterDeclContext::goType() {
  return getRuleContext<myParser::GoTypeContext>(0);
}

myParser::IdentifierListContext* myParser::ParameterDeclContext::identifierList() {
  return getRuleContext<myParser::IdentifierListContext>(0);
}


size_t myParser::ParameterDeclContext::getRuleIndex() const {
  return myParser::RuleParameterDecl;
}

void myParser::ParameterDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameterDecl(this);
}

void myParser::ParameterDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameterDecl(this);
}

myParser::ParameterDeclContext* myParser::parameterDecl() {
  ParameterDeclContext *_localctx = _tracker.createInstance<ParameterDeclContext>(_ctx, getState());
  enterRule(_localctx, 144, myParser::RuleParameterDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(703);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
    case 1: {
      setState(702);
      identifierList();
      break;
    }

    default:
      break;
    }
    setState(706);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::T__50) {
      setState(705);
      match(myParser::T__50);
    }
    setState(708);
    goType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OperandContext ------------------------------------------------------------------

myParser::OperandContext::OperandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::LiteralContext* myParser::OperandContext::literal() {
  return getRuleContext<myParser::LiteralContext>(0);
}

myParser::OperandNameContext* myParser::OperandContext::operandName() {
  return getRuleContext<myParser::OperandNameContext>(0);
}

myParser::MethodExprContext* myParser::OperandContext::methodExpr() {
  return getRuleContext<myParser::MethodExprContext>(0);
}

myParser::ExpressionContext* myParser::OperandContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}


size_t myParser::OperandContext::getRuleIndex() const {
  return myParser::RuleOperand;
}

void myParser::OperandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOperand(this);
}

void myParser::OperandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOperand(this);
}

myParser::OperandContext* myParser::operand() {
  OperandContext *_localctx = _tracker.createInstance<OperandContext>(_ctx, getState());
  enterRule(_localctx, 146, myParser::RuleOperand);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(717);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(710);
      literal();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(711);
      operandName();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(712);
      methodExpr();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(713);
      match(myParser::T__2);
      setState(714);
      expression(0);
      setState(715);
      match(myParser::T__3);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

myParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::BasicLitContext* myParser::LiteralContext::basicLit() {
  return getRuleContext<myParser::BasicLitContext>(0);
}

myParser::CompositeLitContext* myParser::LiteralContext::compositeLit() {
  return getRuleContext<myParser::CompositeLitContext>(0);
}

myParser::FunctionLitContext* myParser::LiteralContext::functionLit() {
  return getRuleContext<myParser::FunctionLitContext>(0);
}


size_t myParser::LiteralContext::getRuleIndex() const {
  return myParser::RuleLiteral;
}

void myParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void myParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}

myParser::LiteralContext* myParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 148, myParser::RuleLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(722);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::INT_LIT:
      case myParser::FLOAT_LIT:
      case myParser::IMAGINARY_LIT:
      case myParser::RUNE_LIT:
      case myParser::STRING_LIT: {
        enterOuterAlt(_localctx, 1);
        setState(719);
        basicLit();
        break;
      }

      case myParser::T__45:
      case myParser::T__48:
      case myParser::T__51:
      case myParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 2);
        setState(720);
        compositeLit();
        break;
      }

      case myParser::T__10: {
        enterOuterAlt(_localctx, 3);
        setState(721);
        functionLit();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BasicLitContext ------------------------------------------------------------------

myParser::BasicLitContext::BasicLitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::BasicLitContext::INT_LIT() {
  return getToken(myParser::INT_LIT, 0);
}

tree::TerminalNode* myParser::BasicLitContext::FLOAT_LIT() {
  return getToken(myParser::FLOAT_LIT, 0);
}

tree::TerminalNode* myParser::BasicLitContext::IMAGINARY_LIT() {
  return getToken(myParser::IMAGINARY_LIT, 0);
}

tree::TerminalNode* myParser::BasicLitContext::RUNE_LIT() {
  return getToken(myParser::RUNE_LIT, 0);
}

tree::TerminalNode* myParser::BasicLitContext::STRING_LIT() {
  return getToken(myParser::STRING_LIT, 0);
}


size_t myParser::BasicLitContext::getRuleIndex() const {
  return myParser::RuleBasicLit;
}

void myParser::BasicLitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBasicLit(this);
}

void myParser::BasicLitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBasicLit(this);
}

myParser::BasicLitContext* myParser::basicLit() {
  BasicLitContext *_localctx = _tracker.createInstance<BasicLitContext>(_ctx, getState());
  enterRule(_localctx, 150, myParser::RuleBasicLit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(724);
    _la = _input->LA(1);
    if (!((((_la - 67) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 67)) & 79) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OperandNameContext ------------------------------------------------------------------

myParser::OperandNameContext::OperandNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::OperandNameContext::IDENTIFIER() {
  return getToken(myParser::IDENTIFIER, 0);
}

myParser::QualifiedIdentContext* myParser::OperandNameContext::qualifiedIdent() {
  return getRuleContext<myParser::QualifiedIdentContext>(0);
}


size_t myParser::OperandNameContext::getRuleIndex() const {
  return myParser::RuleOperandName;
}

void myParser::OperandNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOperandName(this);
}

void myParser::OperandNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOperandName(this);
}

myParser::OperandNameContext* myParser::operandName() {
  OperandNameContext *_localctx = _tracker.createInstance<OperandNameContext>(_ctx, getState());
  enterRule(_localctx, 152, myParser::RuleOperandName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(728);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(726);
      match(myParser::IDENTIFIER);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(727);
      qualifiedIdent();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedIdentContext ------------------------------------------------------------------

myParser::QualifiedIdentContext::QualifiedIdentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> myParser::QualifiedIdentContext::IDENTIFIER() {
  return getTokens(myParser::IDENTIFIER);
}

tree::TerminalNode* myParser::QualifiedIdentContext::IDENTIFIER(size_t i) {
  return getToken(myParser::IDENTIFIER, i);
}


size_t myParser::QualifiedIdentContext::getRuleIndex() const {
  return myParser::RuleQualifiedIdent;
}

void myParser::QualifiedIdentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedIdent(this);
}

void myParser::QualifiedIdentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedIdent(this);
}

myParser::QualifiedIdentContext* myParser::qualifiedIdent() {
  QualifiedIdentContext *_localctx = _tracker.createInstance<QualifiedIdentContext>(_ctx, getState());
  enterRule(_localctx, 154, myParser::RuleQualifiedIdent);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(730);
    match(myParser::IDENTIFIER);
    setState(731);
    match(myParser::T__4);
    setState(732);
    match(myParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompositeLitContext ------------------------------------------------------------------

myParser::CompositeLitContext::CompositeLitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::LiteralTypeContext* myParser::CompositeLitContext::literalType() {
  return getRuleContext<myParser::LiteralTypeContext>(0);
}

myParser::LiteralValueContext* myParser::CompositeLitContext::literalValue() {
  return getRuleContext<myParser::LiteralValueContext>(0);
}


size_t myParser::CompositeLitContext::getRuleIndex() const {
  return myParser::RuleCompositeLit;
}

void myParser::CompositeLitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompositeLit(this);
}

void myParser::CompositeLitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompositeLit(this);
}

myParser::CompositeLitContext* myParser::compositeLit() {
  CompositeLitContext *_localctx = _tracker.createInstance<CompositeLitContext>(_ctx, getState());
  enterRule(_localctx, 156, myParser::RuleCompositeLit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(734);
    literalType();
    setState(735);
    literalValue();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralTypeContext ------------------------------------------------------------------

myParser::LiteralTypeContext::LiteralTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::StructTypeContext* myParser::LiteralTypeContext::structType() {
  return getRuleContext<myParser::StructTypeContext>(0);
}

myParser::ArrayTypeContext* myParser::LiteralTypeContext::arrayType() {
  return getRuleContext<myParser::ArrayTypeContext>(0);
}

myParser::ElementTypeContext* myParser::LiteralTypeContext::elementType() {
  return getRuleContext<myParser::ElementTypeContext>(0);
}

myParser::SliceTypeContext* myParser::LiteralTypeContext::sliceType() {
  return getRuleContext<myParser::SliceTypeContext>(0);
}

myParser::MapTypeContext* myParser::LiteralTypeContext::mapType() {
  return getRuleContext<myParser::MapTypeContext>(0);
}

myParser::TypeNameContext* myParser::LiteralTypeContext::typeName() {
  return getRuleContext<myParser::TypeNameContext>(0);
}


size_t myParser::LiteralTypeContext::getRuleIndex() const {
  return myParser::RuleLiteralType;
}

void myParser::LiteralTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteralType(this);
}

void myParser::LiteralTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteralType(this);
}

myParser::LiteralTypeContext* myParser::literalType() {
  LiteralTypeContext *_localctx = _tracker.createInstance<LiteralTypeContext>(_ctx, getState());
  enterRule(_localctx, 158, myParser::RuleLiteralType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(746);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(737);
      structType();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(738);
      arrayType();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(739);
      match(myParser::T__45);
      setState(740);
      match(myParser::T__50);
      setState(741);
      match(myParser::T__46);
      setState(742);
      elementType();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(743);
      sliceType();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(744);
      mapType();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(745);
      typeName();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralValueContext ------------------------------------------------------------------

myParser::LiteralValueContext::LiteralValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ElementListContext* myParser::LiteralValueContext::elementList() {
  return getRuleContext<myParser::ElementListContext>(0);
}


size_t myParser::LiteralValueContext::getRuleIndex() const {
  return myParser::RuleLiteralValue;
}

void myParser::LiteralValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteralValue(this);
}

void myParser::LiteralValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteralValue(this);
}

myParser::LiteralValueContext* myParser::literalValue() {
  LiteralValueContext *_localctx = _tracker.createInstance<LiteralValueContext>(_ctx, getState());
  enterRule(_localctx, 160, myParser::RuleLiteralValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(748);
    match(myParser::T__12);
    setState(753);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2312387302563555336) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 633) != 0) {
      setState(749);
      elementList();
      setState(751);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::T__7) {
        setState(750);
        match(myParser::T__7);
      }
    }
    setState(755);
    match(myParser::T__13);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementListContext ------------------------------------------------------------------

myParser::ElementListContext::ElementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::KeyedElementContext *> myParser::ElementListContext::keyedElement() {
  return getRuleContexts<myParser::KeyedElementContext>();
}

myParser::KeyedElementContext* myParser::ElementListContext::keyedElement(size_t i) {
  return getRuleContext<myParser::KeyedElementContext>(i);
}


size_t myParser::ElementListContext::getRuleIndex() const {
  return myParser::RuleElementList;
}

void myParser::ElementListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElementList(this);
}

void myParser::ElementListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElementList(this);
}

myParser::ElementListContext* myParser::elementList() {
  ElementListContext *_localctx = _tracker.createInstance<ElementListContext>(_ctx, getState());
  enterRule(_localctx, 162, myParser::RuleElementList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(757);
    keyedElement();
    setState(762);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(758);
        match(myParser::T__7);
        setState(759);
        keyedElement(); 
      }
      setState(764);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyedElementContext ------------------------------------------------------------------

myParser::KeyedElementContext::KeyedElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ElementContext* myParser::KeyedElementContext::element() {
  return getRuleContext<myParser::ElementContext>(0);
}

myParser::KeyContext* myParser::KeyedElementContext::key() {
  return getRuleContext<myParser::KeyContext>(0);
}


size_t myParser::KeyedElementContext::getRuleIndex() const {
  return myParser::RuleKeyedElement;
}

void myParser::KeyedElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyedElement(this);
}

void myParser::KeyedElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyedElement(this);
}

myParser::KeyedElementContext* myParser::keyedElement() {
  KeyedElementContext *_localctx = _tracker.createInstance<KeyedElementContext>(_ctx, getState());
  enterRule(_localctx, 164, myParser::RuleKeyedElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(768);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx)) {
    case 1: {
      setState(765);
      key();
      setState(766);
      match(myParser::T__29);
      break;
    }

    default:
      break;
    }
    setState(770);
    element();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyContext ------------------------------------------------------------------

myParser::KeyContext::KeyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::KeyContext::IDENTIFIER() {
  return getToken(myParser::IDENTIFIER, 0);
}

myParser::ExpressionContext* myParser::KeyContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

myParser::LiteralValueContext* myParser::KeyContext::literalValue() {
  return getRuleContext<myParser::LiteralValueContext>(0);
}


size_t myParser::KeyContext::getRuleIndex() const {
  return myParser::RuleKey;
}

void myParser::KeyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKey(this);
}

void myParser::KeyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKey(this);
}

myParser::KeyContext* myParser::key() {
  KeyContext *_localctx = _tracker.createInstance<KeyContext>(_ctx, getState());
  enterRule(_localctx, 166, myParser::RuleKey);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(775);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(772);
      match(myParser::IDENTIFIER);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(773);
      expression(0);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(774);
      literalValue();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementContext ------------------------------------------------------------------

myParser::ElementContext::ElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionContext* myParser::ElementContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}

myParser::LiteralValueContext* myParser::ElementContext::literalValue() {
  return getRuleContext<myParser::LiteralValueContext>(0);
}


size_t myParser::ElementContext::getRuleIndex() const {
  return myParser::RuleElement;
}

void myParser::ElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElement(this);
}

void myParser::ElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElement(this);
}

myParser::ElementContext* myParser::element() {
  ElementContext *_localctx = _tracker.createInstance<ElementContext>(_ctx, getState());
  enterRule(_localctx, 168, myParser::RuleElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(779);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::T__2:
      case myParser::T__10:
      case myParser::T__14:
      case myParser::T__17:
      case myParser::T__18:
      case myParser::T__20:
      case myParser::T__21:
      case myParser::T__26:
      case myParser::T__45:
      case myParser::T__47:
      case myParser::T__48:
      case myParser::T__49:
      case myParser::T__51:
      case myParser::T__60:
      case myParser::IDENTIFIER:
      case myParser::INT_LIT:
      case myParser::FLOAT_LIT:
      case myParser::IMAGINARY_LIT:
      case myParser::RUNE_LIT:
      case myParser::STRING_LIT: {
        enterOuterAlt(_localctx, 1);
        setState(777);
        expression(0);
        break;
      }

      case myParser::T__12: {
        enterOuterAlt(_localctx, 2);
        setState(778);
        literalValue();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StructTypeContext ------------------------------------------------------------------

myParser::StructTypeContext::StructTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::FieldDeclContext *> myParser::StructTypeContext::fieldDecl() {
  return getRuleContexts<myParser::FieldDeclContext>();
}

myParser::FieldDeclContext* myParser::StructTypeContext::fieldDecl(size_t i) {
  return getRuleContext<myParser::FieldDeclContext>(i);
}


size_t myParser::StructTypeContext::getRuleIndex() const {
  return myParser::RuleStructType;
}

void myParser::StructTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStructType(this);
}

void myParser::StructTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStructType(this);
}

myParser::StructTypeContext* myParser::structType() {
  StructTypeContext *_localctx = _tracker.createInstance<StructTypeContext>(_ctx, getState());
  enterRule(_localctx, 170, myParser::RuleStructType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(781);
    match(myParser::T__51);
    setState(782);
    match(myParser::T__12);
    setState(786);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::T__21

    || _la == myParser::IDENTIFIER) {
      setState(783);
      fieldDecl();
      setState(788);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(789);
    match(myParser::T__13);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldDeclContext ------------------------------------------------------------------

myParser::FieldDeclContext::FieldDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierListContext* myParser::FieldDeclContext::identifierList() {
  return getRuleContext<myParser::IdentifierListContext>(0);
}

myParser::GoTypeContext* myParser::FieldDeclContext::goType() {
  return getRuleContext<myParser::GoTypeContext>(0);
}

myParser::AnonymousFieldContext* myParser::FieldDeclContext::anonymousField() {
  return getRuleContext<myParser::AnonymousFieldContext>(0);
}

tree::TerminalNode* myParser::FieldDeclContext::STRING_LIT() {
  return getToken(myParser::STRING_LIT, 0);
}


size_t myParser::FieldDeclContext::getRuleIndex() const {
  return myParser::RuleFieldDecl;
}

void myParser::FieldDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldDecl(this);
}

void myParser::FieldDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldDecl(this);
}

myParser::FieldDeclContext* myParser::fieldDecl() {
  FieldDeclContext *_localctx = _tracker.createInstance<FieldDeclContext>(_ctx, getState());
  enterRule(_localctx, 172, myParser::RuleFieldDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(795);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx)) {
    case 1: {
      setState(791);
      identifierList();
      setState(792);
      goType();
      break;
    }

    case 2: {
      setState(794);
      anonymousField();
      break;
    }

    default:
      break;
    }
    setState(798);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::STRING_LIT) {
      setState(797);
      match(myParser::STRING_LIT);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnonymousFieldContext ------------------------------------------------------------------

myParser::AnonymousFieldContext::AnonymousFieldContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::TypeNameContext* myParser::AnonymousFieldContext::typeName() {
  return getRuleContext<myParser::TypeNameContext>(0);
}


size_t myParser::AnonymousFieldContext::getRuleIndex() const {
  return myParser::RuleAnonymousField;
}

void myParser::AnonymousFieldContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnonymousField(this);
}

void myParser::AnonymousFieldContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnonymousField(this);
}

myParser::AnonymousFieldContext* myParser::anonymousField() {
  AnonymousFieldContext *_localctx = _tracker.createInstance<AnonymousFieldContext>(_ctx, getState());
  enterRule(_localctx, 174, myParser::RuleAnonymousField);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(801);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::T__21) {
      setState(800);
      match(myParser::T__21);
    }
    setState(803);
    typeName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionLitContext ------------------------------------------------------------------

myParser::FunctionLitContext::FunctionLitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::FunctionContext* myParser::FunctionLitContext::function() {
  return getRuleContext<myParser::FunctionContext>(0);
}


size_t myParser::FunctionLitContext::getRuleIndex() const {
  return myParser::RuleFunctionLit;
}

void myParser::FunctionLitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionLit(this);
}

void myParser::FunctionLitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionLit(this);
}

myParser::FunctionLitContext* myParser::functionLit() {
  FunctionLitContext *_localctx = _tracker.createInstance<FunctionLitContext>(_ctx, getState());
  enterRule(_localctx, 176, myParser::RuleFunctionLit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(805);
    match(myParser::T__10);
    setState(806);
    function();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrimaryExprContext ------------------------------------------------------------------

myParser::PrimaryExprContext::PrimaryExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::OperandContext* myParser::PrimaryExprContext::operand() {
  return getRuleContext<myParser::OperandContext>(0);
}

myParser::ConversionContext* myParser::PrimaryExprContext::conversion() {
  return getRuleContext<myParser::ConversionContext>(0);
}

myParser::PrimaryExprContext* myParser::PrimaryExprContext::primaryExpr() {
  return getRuleContext<myParser::PrimaryExprContext>(0);
}

myParser::SelectorContext* myParser::PrimaryExprContext::selector() {
  return getRuleContext<myParser::SelectorContext>(0);
}

myParser::IndexContext* myParser::PrimaryExprContext::index() {
  return getRuleContext<myParser::IndexContext>(0);
}

myParser::SliceContext* myParser::PrimaryExprContext::slice() {
  return getRuleContext<myParser::SliceContext>(0);
}

myParser::TypeAssertionContext* myParser::PrimaryExprContext::typeAssertion() {
  return getRuleContext<myParser::TypeAssertionContext>(0);
}

myParser::ArgumentsContext* myParser::PrimaryExprContext::arguments() {
  return getRuleContext<myParser::ArgumentsContext>(0);
}


size_t myParser::PrimaryExprContext::getRuleIndex() const {
  return myParser::RulePrimaryExpr;
}

void myParser::PrimaryExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExpr(this);
}

void myParser::PrimaryExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExpr(this);
}


myParser::PrimaryExprContext* myParser::primaryExpr() {
   return primaryExpr(0);
}

myParser::PrimaryExprContext* myParser::primaryExpr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  myParser::PrimaryExprContext *_localctx = _tracker.createInstance<PrimaryExprContext>(_ctx, parentState);
  myParser::PrimaryExprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 178;
  enterRecursionRule(_localctx, 178, myParser::RulePrimaryExpr, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(811);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx)) {
    case 1: {
      setState(809);
      operand();
      break;
    }

    case 2: {
      setState(810);
      conversion();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(825);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(823);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<PrimaryExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePrimaryExpr);
          setState(813);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(814);
          selector();
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<PrimaryExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePrimaryExpr);
          setState(815);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(816);
          index();
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<PrimaryExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePrimaryExpr);
          setState(817);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(818);
          slice();
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<PrimaryExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePrimaryExpr);
          setState(819);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(820);
          typeAssertion();
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<PrimaryExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePrimaryExpr);
          setState(821);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(822);
          arguments();
          break;
        }

        default:
          break;
        } 
      }
      setState(827);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- SelectorContext ------------------------------------------------------------------

myParser::SelectorContext::SelectorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::SelectorContext::IDENTIFIER() {
  return getToken(myParser::IDENTIFIER, 0);
}


size_t myParser::SelectorContext::getRuleIndex() const {
  return myParser::RuleSelector;
}

void myParser::SelectorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelector(this);
}

void myParser::SelectorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelector(this);
}

myParser::SelectorContext* myParser::selector() {
  SelectorContext *_localctx = _tracker.createInstance<SelectorContext>(_ctx, getState());
  enterRule(_localctx, 180, myParser::RuleSelector);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(828);
    match(myParser::T__4);
    setState(829);
    match(myParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexContext ------------------------------------------------------------------

myParser::IndexContext::IndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionContext* myParser::IndexContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}


size_t myParser::IndexContext::getRuleIndex() const {
  return myParser::RuleIndex;
}

void myParser::IndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex(this);
}

void myParser::IndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex(this);
}

myParser::IndexContext* myParser::index() {
  IndexContext *_localctx = _tracker.createInstance<IndexContext>(_ctx, getState());
  enterRule(_localctx, 182, myParser::RuleIndex);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(831);
    match(myParser::T__45);
    setState(832);
    expression(0);
    setState(833);
    match(myParser::T__46);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SliceContext ------------------------------------------------------------------

myParser::SliceContext::SliceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::ExpressionContext *> myParser::SliceContext::expression() {
  return getRuleContexts<myParser::ExpressionContext>();
}

myParser::ExpressionContext* myParser::SliceContext::expression(size_t i) {
  return getRuleContext<myParser::ExpressionContext>(i);
}


size_t myParser::SliceContext::getRuleIndex() const {
  return myParser::RuleSlice;
}

void myParser::SliceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSlice(this);
}

void myParser::SliceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSlice(this);
}

myParser::SliceContext* myParser::slice() {
  SliceContext *_localctx = _tracker.createInstance<SliceContext>(_ctx, getState());
  enterRule(_localctx, 184, myParser::RuleSlice);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(835);
    match(myParser::T__45);
    setState(851);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx)) {
    case 1: {
      setState(837);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2312387302563547144) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 633) != 0) {
        setState(836);
        expression(0);
      }
      setState(839);
      match(myParser::T__29);
      setState(841);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2312387302563547144) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 633) != 0) {
        setState(840);
        expression(0);
      }
      break;
    }

    case 2: {
      setState(844);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2312387302563547144) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 633) != 0) {
        setState(843);
        expression(0);
      }
      setState(846);
      match(myParser::T__29);
      setState(847);
      expression(0);
      setState(848);
      match(myParser::T__29);
      setState(849);
      expression(0);
      break;
    }

    default:
      break;
    }
    setState(853);
    match(myParser::T__46);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeAssertionContext ------------------------------------------------------------------

myParser::TypeAssertionContext::TypeAssertionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::GoTypeContext* myParser::TypeAssertionContext::goType() {
  return getRuleContext<myParser::GoTypeContext>(0);
}


size_t myParser::TypeAssertionContext::getRuleIndex() const {
  return myParser::RuleTypeAssertion;
}

void myParser::TypeAssertionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeAssertion(this);
}

void myParser::TypeAssertionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeAssertion(this);
}

myParser::TypeAssertionContext* myParser::typeAssertion() {
  TypeAssertionContext *_localctx = _tracker.createInstance<TypeAssertionContext>(_ctx, getState());
  enterRule(_localctx, 186, myParser::RuleTypeAssertion);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(855);
    match(myParser::T__4);
    setState(856);
    match(myParser::T__2);
    setState(857);
    goType();
    setState(858);
    match(myParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentsContext ------------------------------------------------------------------

myParser::ArgumentsContext::ArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionListContext* myParser::ArgumentsContext::expressionList() {
  return getRuleContext<myParser::ExpressionListContext>(0);
}

myParser::GoTypeContext* myParser::ArgumentsContext::goType() {
  return getRuleContext<myParser::GoTypeContext>(0);
}


size_t myParser::ArgumentsContext::getRuleIndex() const {
  return myParser::RuleArguments;
}

void myParser::ArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArguments(this);
}

void myParser::ArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArguments(this);
}

myParser::ArgumentsContext* myParser::arguments() {
  ArgumentsContext *_localctx = _tracker.createInstance<ArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 188, myParser::RuleArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(860);
    match(myParser::T__2);
    setState(875);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2312387302563547144) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 633) != 0) {
      setState(867);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx)) {
      case 1: {
        setState(861);
        expressionList();
        break;
      }

      case 2: {
        setState(862);
        goType();
        setState(865);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx)) {
        case 1: {
          setState(863);
          match(myParser::T__7);
          setState(864);
          expressionList();
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
      setState(870);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::T__50) {
        setState(869);
        match(myParser::T__50);
      }
      setState(873);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::T__7) {
        setState(872);
        match(myParser::T__7);
      }
    }
    setState(877);
    match(myParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MethodExprContext ------------------------------------------------------------------

myParser::MethodExprContext::MethodExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ReceiverTypeContext* myParser::MethodExprContext::receiverType() {
  return getRuleContext<myParser::ReceiverTypeContext>(0);
}

tree::TerminalNode* myParser::MethodExprContext::IDENTIFIER() {
  return getToken(myParser::IDENTIFIER, 0);
}


size_t myParser::MethodExprContext::getRuleIndex() const {
  return myParser::RuleMethodExpr;
}

void myParser::MethodExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMethodExpr(this);
}

void myParser::MethodExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMethodExpr(this);
}

myParser::MethodExprContext* myParser::methodExpr() {
  MethodExprContext *_localctx = _tracker.createInstance<MethodExprContext>(_ctx, getState());
  enterRule(_localctx, 190, myParser::RuleMethodExpr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(879);
    receiverType();
    setState(880);
    match(myParser::T__4);
    setState(881);
    match(myParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReceiverTypeContext ------------------------------------------------------------------

myParser::ReceiverTypeContext::ReceiverTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::TypeNameContext* myParser::ReceiverTypeContext::typeName() {
  return getRuleContext<myParser::TypeNameContext>(0);
}

myParser::ReceiverTypeContext* myParser::ReceiverTypeContext::receiverType() {
  return getRuleContext<myParser::ReceiverTypeContext>(0);
}


size_t myParser::ReceiverTypeContext::getRuleIndex() const {
  return myParser::RuleReceiverType;
}

void myParser::ReceiverTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReceiverType(this);
}

void myParser::ReceiverTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReceiverType(this);
}

myParser::ReceiverTypeContext* myParser::receiverType() {
  ReceiverTypeContext *_localctx = _tracker.createInstance<ReceiverTypeContext>(_ctx, getState());
  enterRule(_localctx, 192, myParser::RuleReceiverType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(893);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(883);
      typeName();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(884);
      match(myParser::T__2);
      setState(885);
      match(myParser::T__21);
      setState(886);
      typeName();
      setState(887);
      match(myParser::T__3);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(889);
      match(myParser::T__2);
      setState(890);
      receiverType();
      setState(891);
      match(myParser::T__3);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

myParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::UnaryExprContext* myParser::ExpressionContext::unaryExpr() {
  return getRuleContext<myParser::UnaryExprContext>(0);
}

std::vector<myParser::ExpressionContext *> myParser::ExpressionContext::expression() {
  return getRuleContexts<myParser::ExpressionContext>();
}

myParser::ExpressionContext* myParser::ExpressionContext::expression(size_t i) {
  return getRuleContext<myParser::ExpressionContext>(i);
}


size_t myParser::ExpressionContext::getRuleIndex() const {
  return myParser::RuleExpression;
}

void myParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void myParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}


myParser::ExpressionContext* myParser::expression() {
   return expression(0);
}

myParser::ExpressionContext* myParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  myParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  myParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 194;
  enterRecursionRule(_localctx, 194, myParser::RuleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(896);
    unaryExpr();
    _ctx->stop = _input->LT(-1);
    setState(903);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleExpression);
        setState(898);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(899);
        _la = _input->LA(1);
        if (!(((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 2296835810495561728) != 0)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(900);
        expression(2); 
      }
      setState(905);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- UnaryExprContext ------------------------------------------------------------------

myParser::UnaryExprContext::UnaryExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::PrimaryExprContext* myParser::UnaryExprContext::primaryExpr() {
  return getRuleContext<myParser::PrimaryExprContext>(0);
}

myParser::UnaryExprContext* myParser::UnaryExprContext::unaryExpr() {
  return getRuleContext<myParser::UnaryExprContext>(0);
}


size_t myParser::UnaryExprContext::getRuleIndex() const {
  return myParser::RuleUnaryExpr;
}

void myParser::UnaryExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryExpr(this);
}

void myParser::UnaryExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryExpr(this);
}

myParser::UnaryExprContext* myParser::unaryExpr() {
  UnaryExprContext *_localctx = _tracker.createInstance<UnaryExprContext>(_ctx, getState());
  enterRule(_localctx, 196, myParser::RuleUnaryExpr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(909);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(906);
      primaryExpr(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(907);
      _la = _input->LA(1);
      if (!(((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2305843009355022336) != 0)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(908);
      unaryExpr();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConversionContext ------------------------------------------------------------------

myParser::ConversionContext::ConversionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::GoTypeContext* myParser::ConversionContext::goType() {
  return getRuleContext<myParser::GoTypeContext>(0);
}

myParser::ExpressionContext* myParser::ConversionContext::expression() {
  return getRuleContext<myParser::ExpressionContext>(0);
}


size_t myParser::ConversionContext::getRuleIndex() const {
  return myParser::RuleConversion;
}

void myParser::ConversionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConversion(this);
}

void myParser::ConversionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConversion(this);
}

myParser::ConversionContext* myParser::conversion() {
  ConversionContext *_localctx = _tracker.createInstance<ConversionContext>(_ctx, getState());
  enterRule(_localctx, 198, myParser::RuleConversion);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(911);
    goType();
    setState(912);
    match(myParser::T__2);
    setState(913);
    expression(0);
    setState(915);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::T__7) {
      setState(914);
      match(myParser::T__7);
    }
    setState(917);
    match(myParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EosContext ------------------------------------------------------------------

myParser::EosContext::EosContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::EosContext::WS() {
  return getToken(myParser::WS, 0);
}

tree::TerminalNode* myParser::EosContext::TERMINATOR() {
  return getToken(myParser::TERMINATOR, 0);
}

tree::TerminalNode* myParser::EosContext::EOF() {
  return getToken(myParser::EOF, 0);
}


size_t myParser::EosContext::getRuleIndex() const {
  return myParser::RuleEos;
}

void myParser::EosContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEos(this);
}

void myParser::EosContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEos(this);
}

myParser::EosContext* myParser::eos() {
  EosContext *_localctx = _tracker.createInstance<EosContext>(_ctx, getState());
  enterRule(_localctx, 200, myParser::RuleEos);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(919);
    _la = _input->LA(1);
    if (!(_la == myParser::EOF

    || _la == myParser::T__9 || _la == myParser::WS

    || _la == myParser::TERMINATOR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool myParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 89: return primaryExprSempred(antlrcpp::downCast<PrimaryExprContext *>(context), predicateIndex);
    case 97: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool myParser::primaryExprSempred(PrimaryExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 5);
    case 1: return precpred(_ctx, 4);
    case 2: return precpred(_ctx, 3);
    case 3: return precpred(_ctx, 2);
    case 4: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool myParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 5: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

void myParser::initialize() {
  ::antlr4::internal::call_once(myParserOnceFlag, myParserInitialize);
}


// Generated from PhpParser.g4 by ANTLR 4.13.0


#include "PhpParserListener.h"

#include "PhpParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct PhpParserStaticData final {
  PhpParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  PhpParserStaticData(const PhpParserStaticData&) = delete;
  PhpParserStaticData(PhpParserStaticData&&) = delete;
  PhpParserStaticData& operator=(const PhpParserStaticData&) = delete;
  PhpParserStaticData& operator=(PhpParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag phpparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
PhpParserStaticData *phpparserParserStaticData = nullptr;

void phpparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (phpparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(phpparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<PhpParserStaticData>(
    std::vector<std::string>{
      "htmlDocument", "inlineHtml", "htmlElement", "scriptText", "phpBlock", 
      "importStatement", "topStatement", "useDeclaration", "useDeclarationContentList", 
      "useDeclarationContent", "namespaceDeclaration", "namespaceStatement", 
      "functionDeclaration", "classDeclaration", "classEntryType", "interfaceList", 
      "typeParameterListInBrackets", "typeParameterList", "typeParameterWithDefaultsList", 
      "typeParameterDecl", "typeParameterWithDefaultDecl", "genericDynamicArgs", 
      "attributes", "attributeGroup", "attribute", "innerStatementList", 
      "innerStatement", "statement", "emptyStatement_", "blockStatement", 
      "ifStatement", "elseIfStatement", "elseIfColonStatement", "elseStatement", 
      "elseColonStatement", "whileStatement", "doWhileStatement", "forStatement", 
      "forInit", "forUpdate", "switchStatement", "switchBlock", "breakStatement", 
      "continueStatement", "returnStatement", "expressionStatement", "unsetStatement", 
      "foreachStatement", "tryCatchFinally", "catchClause", "finallyStatement", 
      "throwStatement", "gotoStatement", "declareStatement", "inlineHtmlStatement", 
      "declareList", "directive", "formalParameterList", "formalParameter", 
      "typeHint", "globalStatement", "globalVar", "echoStatement", "staticVariableStatement", 
      "classStatement", "traitAdaptations", "traitAdaptationStatement", 
      "traitPrecedence", "traitAlias", "traitMethodReference", "baseCtorCall", 
      "returnTypeDecl", "methodBody", "propertyModifiers", "memberModifiers", 
      "variableInitializer", "identifierInitializer", "globalConstantDeclaration", 
      "enumDeclaration", "enumItem", "expressionList", "parentheses", "expression", 
      "assignable", "arrayCreation", "arrayDestructuring", "indexedDestructItem", 
      "keyedDestructItem", "lambdaFunctionExpr", "matchExpr", "matchItem", 
      "newExpr", "assignmentOperator", "yieldExpression", "arrayItemList", 
      "arrayItem", "lambdaFunctionUseVars", "lambdaFunctionUseVar", "qualifiedStaticTypeRef", 
      "typeRef", "anonymousClass", "indirectTypeRef", "qualifiedNamespaceName", 
      "namespaceNameList", "namespaceNameTail", "qualifiedNamespaceNameList", 
      "arguments", "actualArgument", "argumentName", "constantInitializer", 
      "constant", "literalConstant", "numericConstant", "classConstant", 
      "stringConstant", "string", "interpolatedStringPart", "chainList", 
      "chain", "chainOrigin", "memberAccess", "functionCall", "functionCallName", 
      "actualArguments", "chainBase", "keyedFieldName", "keyedSimpleFieldName", 
      "keyedVariable", "squareCurlyExpression", "assignmentList", "assignmentListElement", 
      "modifier", "identifier", "memberModifier", "magicConstant", "magicMethod", 
      "primitiveType", "castOperation"
    },
    std::vector<std::string>{
      "", "", "", "'<\\u003Fxml'", "", "", "", "", "", "", "", "", "", "'\\u003F>'", 
      "", "", "'/>'", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "'#['", "'abstract'", 
      "'array'", "'as'", "'binary'", "", "", "'break'", "'callable'", "'case'", 
      "'catch'", "'class'", "'clone'", "'const'", "'continue'", "'declare'", 
      "'default'", "'do'", "'real'", "'double'", "'echo'", "'else'", "'elseif'", 
      "'empty'", "'enum'", "'enddeclare'", "'endfor'", "'endforeach'", "'endif'", 
      "'endswitch'", "'endwhile'", "'eval'", "'die'", "'extends'", "'final'", 
      "'finally'", "'float'", "'for'", "'foreach'", "'function'", "'global'", 
      "'goto'", "'if'", "'implements'", "'import'", "'include'", "'include_once'", 
      "'instanceof'", "'insteadof'", "'int8'", "'int16'", "'int64'", "", 
      "'interface'", "'isset'", "'list'", "'and'", "'or'", "'xor'", "'match'", 
      "'namespace'", "'new'", "'null'", "'object'", "'parent'", "'partial'", 
      "'print'", "'private'", "'protected'", "'public'", "'readonly'", "'require'", 
      "'require_once'", "'resource'", "'return'", "'static'", "'string'", 
      "'switch'", "'throw'", "'trait'", "'try'", "'clrtypeof'", "", "'unicode'", 
      "'unset'", "'use'", "'var'", "'while'", "'yield'", "'from'", "'fn'", 
      "'ticks'", "'encoding'", "'strict_types'", "'__get'", "'__set'", "'__call'", 
      "'__callstatic'", "'__construct'", "'__destruct'", "'__wakeup'", "'__sleep'", 
      "'__autoload'", "'__isset'", "'__unset'", "'__tostring'", "'__invoke'", 
      "'__set_state'", "'__clone'", "'__debuginfo'", "'__namespace__'", 
      "'__class__'", "'__trait__'", "'__function__'", "'__method__'", "'__line__'", 
      "'__file__'", "'__dir__'", "'<=>'", "'<:'", "':>'", "'=>'", "'++'", 
      "'--'", "'==='", "'!=='", "'=='", "", "'<='", "'>='", "'+='", "'-='", 
      "'*='", "'**'", "'**='", "'/='", "'.='", "'%='", "'<<='", "'>>='", 
      "'&='", "'|='", "'^='", "'||'", "'&&'", "'\\u003F\\u003F'", "'\\u003F\\u003F='", 
      "'<<'", "'>>'", "'::'", "'->'", "'\\'", "'...'", "", "", "'&'", "'|'", 
      "'!'", "'^'", "'+'", "'-'", "'*'", "'%'", "", "'~'", "'@'", "", "'.'", 
      "", "'('", "')'", "'['", "']'", "", "'}'", "','", "':'", "';'", "", 
      "'''", "'`'"
    },
    std::vector<std::string>{
      "", "SeaWhitespace", "HtmlText", "XmlStart", "PHPStart", "HtmlScriptOpen", 
      "HtmlStyleOpen", "HtmlComment", "HtmlDtd", "HtmlOpen", "Shebang", 
      "Error", "XmlText", "XmlClose", "PHPStartInside", "HtmlClose", "HtmlSlashClose", 
      "HtmlSlash", "HtmlEquals", "HtmlStartQuoteString", "HtmlStartDoubleQuoteString", 
      "HtmlHex", "HtmlDecimal", "HtmlSpace", "HtmlName", "ErrorInside", 
      "PHPStartInsideQuoteString", "HtmlEndQuoteString", "HtmlQuoteString", 
      "ErrorHtmlQuote", "PHPStartDoubleQuoteString", "HtmlEndDoubleQuoteString", 
      "HtmlDoubleQuoteString", "ErrorHtmlDoubleQuote", "ScriptText", "HtmlScriptClose", 
      "PHPStartInsideScript", "StyleBody", "PHPEnd", "Whitespace", "MultiLineComment", 
      "SingleLineComment", "ShellStyleComment", "AttributeStart", "Abstract", 
      "Array", "As", "BinaryCast", "BoolType", "BooleanConstant", "Break", 
      "Callable", "Case", "Catch", "Class", "Clone", "Const", "Continue", 
      "Declare", "Default", "Do", "DoubleCast", "DoubleType", "Echo", "Else", 
      "ElseIf", "Empty", "Enum_", "EndDeclare", "EndFor", "EndForeach", 
      "EndIf", "EndSwitch", "EndWhile", "Eval", "Exit", "Extends", "Final", 
      "Finally", "FloatCast", "For", "Foreach", "Function_", "Global", "Goto", 
      "If", "Implements", "Import", "Include", "IncludeOnce", "InstanceOf", 
      "InsteadOf", "Int8Cast", "Int16Cast", "Int64Type", "IntType", "Interface", 
      "IsSet", "List", "LogicalAnd", "LogicalOr", "LogicalXor", "Match_", 
      "Namespace", "New", "Null", "ObjectType", "Parent_", "Partial", "Print", 
      "Private", "Protected", "Public", "Readonly", "Require", "RequireOnce", 
      "Resource", "Return", "Static", "StringType", "Switch", "Throw", "Trait", 
      "Try", "Typeof", "UintCast", "UnicodeCast", "Unset", "Use", "Var", 
      "While", "Yield", "From", "LambdaFn", "Ticks", "Encoding", "StrictTypes", 
      "Get", "Set", "Call", "CallStatic", "Constructor", "Destruct", "Wakeup", 
      "Sleep", "Autoload", "IsSet__", "Unset__", "ToString__", "Invoke", 
      "SetState", "Clone__", "DebugInfo", "Namespace__", "Class__", "Traic__", 
      "Function__", "Method__", "Line__", "File__", "Dir__", "Spaceship", 
      "Lgeneric", "Rgeneric", "DoubleArrow", "Inc", "Dec", "IsIdentical", 
      "IsNoidentical", "IsEqual", "IsNotEq", "IsSmallerOrEqual", "IsGreaterOrEqual", 
      "PlusEqual", "MinusEqual", "MulEqual", "Pow", "PowEqual", "DivEqual", 
      "Concaequal", "ModEqual", "ShiftLeftEqual", "ShiftRightEqual", "AndEqual", 
      "OrEqual", "XorEqual", "BooleanOr", "BooleanAnd", "NullCoalescing", 
      "NullCoalescingEqual", "ShiftLeft", "ShiftRight", "DoubleColon", "ObjectOperator", 
      "NamespaceSeparator", "Ellipsis", "Less", "Greater", "Ampersand", 
      "Pipe", "Bang", "Caret", "Plus", "Minus", "Asterisk", "Percent", "Divide", 
      "Tilde", "SuppressWarnings", "Dollar", "Dot", "QuestionMark", "OpenRoundBracket", 
      "CloseRoundBracket", "OpenSquareBracket", "CloseSquareBracket", "OpenCurlyBracket", 
      "CloseCurlyBracket", "Comma", "Colon", "SemiColon", "Eq", "Quote", 
      "BackQuote", "VarName", "Label", "Octal", "Decimal", "Real", "Hex", 
      "Binary", "BackQuoteString", "SingleQuoteString", "DoubleQuote", "StartNowDoc", 
      "StartHereDoc", "ErrorPhp", "CurlyDollar", "UnicodeEscape", "StringPart", 
      "Comment", "PHPEndSingleLineComment", "CommentEnd", "HereDocText", 
      "XmlText2"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,244,1947,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,
  	7,134,2,135,7,135,2,136,7,136,2,137,7,137,1,0,3,0,278,8,0,1,0,1,0,5,0,
  	282,8,0,10,0,12,0,285,9,0,1,0,1,0,1,1,4,1,290,8,1,11,1,12,1,291,1,1,3,
  	1,295,8,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
  	1,2,1,2,1,2,1,2,1,2,1,2,1,2,5,2,319,8,2,10,2,12,2,322,9,2,1,2,3,2,325,
  	8,2,1,3,4,3,328,8,3,11,3,12,3,329,1,4,5,4,333,8,4,10,4,12,4,336,9,4,1,
  	4,4,4,339,8,4,11,4,12,4,340,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,
  	6,1,6,3,6,355,8,6,1,7,1,7,3,7,359,8,7,1,7,1,7,1,7,1,8,3,8,365,8,8,1,8,
  	1,8,1,8,3,8,370,8,8,1,8,5,8,373,8,8,10,8,12,8,376,9,8,1,9,1,9,1,10,1,
  	10,3,10,382,8,10,1,10,1,10,5,10,386,8,10,10,10,12,10,389,9,10,1,10,1,
  	10,1,10,1,10,3,10,395,8,10,1,11,1,11,1,11,1,11,1,11,3,11,402,8,11,1,12,
  	3,12,405,8,12,1,12,1,12,3,12,409,8,12,1,12,1,12,3,12,413,8,12,1,12,1,
  	12,1,12,1,12,1,12,3,12,420,8,12,1,12,3,12,423,8,12,1,12,1,12,1,13,3,13,
  	428,8,13,1,13,3,13,431,8,13,1,13,3,13,434,8,13,1,13,3,13,437,8,13,1,13,
  	1,13,1,13,3,13,442,8,13,1,13,1,13,3,13,446,8,13,1,13,1,13,3,13,450,8,
  	13,1,13,1,13,1,13,3,13,455,8,13,1,13,1,13,3,13,459,8,13,3,13,461,8,13,
  	1,13,1,13,5,13,465,8,13,10,13,12,13,468,9,13,1,13,1,13,1,14,1,14,1,15,
  	1,15,1,15,5,15,477,8,15,10,15,12,15,480,9,15,1,16,1,16,1,16,1,16,1,16,
  	1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,3,16,496,8,16,1,17,1,17,
  	1,17,5,17,501,8,17,10,17,12,17,504,9,17,1,18,1,18,1,18,5,18,509,8,18,
  	10,18,12,18,512,9,18,1,19,3,19,515,8,19,1,19,1,19,1,20,3,20,520,8,20,
  	1,20,1,20,1,20,1,20,3,20,526,8,20,1,21,1,21,1,21,1,21,5,21,532,8,21,10,
  	21,12,21,535,9,21,1,21,1,21,1,22,4,22,540,8,22,11,22,12,22,541,1,23,1,
  	23,1,23,1,23,3,23,548,8,23,1,23,1,23,1,23,5,23,553,8,23,10,23,12,23,556,
  	9,23,1,23,1,23,1,24,1,24,3,24,562,8,24,1,25,5,25,565,8,25,10,25,12,25,
  	568,9,25,1,26,1,26,1,26,3,26,573,8,26,1,27,1,27,1,27,1,27,1,27,1,27,1,
  	27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,
  	27,1,27,1,27,1,27,1,27,1,27,1,27,3,27,602,8,27,1,28,1,28,1,29,1,29,1,
  	29,1,29,1,30,1,30,1,30,1,30,5,30,614,8,30,10,30,12,30,617,9,30,1,30,3,
  	30,620,8,30,1,30,1,30,1,30,1,30,1,30,5,30,627,8,30,10,30,12,30,630,9,
  	30,1,30,3,30,633,8,30,1,30,1,30,1,30,3,30,638,8,30,1,31,1,31,1,31,1,31,
  	1,32,1,32,1,32,1,32,1,32,1,33,1,33,1,33,1,34,1,34,1,34,1,34,1,35,1,35,
  	1,35,1,35,1,35,1,35,1,35,1,35,3,35,664,8,35,1,36,1,36,1,36,1,36,1,36,
  	1,36,1,37,1,37,1,37,3,37,675,8,37,1,37,1,37,3,37,679,8,37,1,37,1,37,3,
  	37,683,8,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,3,37,692,8,37,1,38,1,38,
  	1,39,1,39,1,40,1,40,1,40,1,40,3,40,702,8,40,1,40,5,40,705,8,40,10,40,
  	12,40,708,9,40,1,40,1,40,1,40,3,40,713,8,40,1,40,5,40,716,8,40,10,40,
  	12,40,719,9,40,1,40,1,40,3,40,723,8,40,1,41,1,41,1,41,3,41,728,8,41,1,
  	41,4,41,731,8,41,11,41,12,41,732,1,41,1,41,1,42,1,42,3,42,739,8,42,1,
  	42,1,42,1,43,1,43,3,43,745,8,43,1,43,1,43,1,44,1,44,3,44,751,8,44,1,44,
  	1,44,1,45,1,45,1,45,1,46,1,46,1,46,1,46,1,46,1,46,1,47,1,47,1,47,1,47,
  	1,47,1,47,1,47,1,47,1,47,1,47,1,47,3,47,775,8,47,1,47,1,47,1,47,3,47,
  	780,8,47,1,47,3,47,783,8,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,3,
  	47,793,8,47,1,47,3,47,796,8,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,
  	1,47,1,47,1,47,3,47,809,8,47,1,47,1,47,1,47,1,47,1,47,1,47,3,47,817,8,
  	47,1,48,1,48,1,48,4,48,822,8,48,11,48,12,48,823,1,48,3,48,827,8,48,1,
  	48,5,48,830,8,48,10,48,12,48,833,9,48,1,48,3,48,836,8,48,1,49,1,49,1,
  	49,1,49,1,49,5,49,843,8,49,10,49,12,49,846,9,49,1,49,3,49,849,8,49,1,
  	49,1,49,1,49,1,50,1,50,1,50,1,51,1,51,1,51,1,51,1,52,1,52,1,52,1,52,1,
  	53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,3,53,875,8,53,1,54,4,
  	54,878,8,54,11,54,12,54,879,1,55,1,55,1,55,5,55,885,8,55,10,55,12,55,
  	888,9,55,1,56,1,56,1,56,1,56,3,56,894,8,56,1,56,1,56,1,56,1,56,1,56,1,
  	56,3,56,902,8,56,1,57,3,57,905,8,57,1,57,1,57,5,57,909,8,57,10,57,12,
  	57,912,9,57,1,57,3,57,915,8,57,1,58,3,58,918,8,58,1,58,5,58,921,8,58,
  	10,58,12,58,924,9,58,1,58,3,58,927,8,58,1,58,3,58,930,8,58,1,58,3,58,
  	933,8,58,1,58,3,58,936,8,58,1,58,1,58,1,59,1,59,1,59,1,59,3,59,944,8,
  	59,1,59,1,59,1,59,5,59,949,8,59,10,59,12,59,952,9,59,1,60,1,60,1,60,1,
  	60,5,60,958,8,60,10,60,12,60,961,9,60,1,60,1,60,1,61,1,61,1,61,1,61,1,
  	61,1,61,1,61,1,61,3,61,973,8,61,1,62,1,62,1,62,1,62,1,63,1,63,1,63,1,
  	63,5,63,983,8,63,10,63,12,63,986,9,63,1,63,1,63,1,64,3,64,991,8,64,1,
  	64,1,64,3,64,995,8,64,1,64,1,64,1,64,5,64,1000,8,64,10,64,12,64,1003,
  	9,64,1,64,1,64,1,64,3,64,1008,8,64,1,64,1,64,3,64,1012,8,64,1,64,1,64,
  	1,64,5,64,1017,8,64,10,64,12,64,1020,9,64,1,64,1,64,1,64,1,64,3,64,1026,
  	8,64,1,64,1,64,3,64,1030,8,64,1,64,1,64,1,64,1,64,1,64,3,64,1037,8,64,
  	1,64,1,64,3,64,1041,8,64,3,64,1043,8,64,1,64,1,64,1,64,1,64,3,64,1049,
  	8,64,1,65,1,65,1,65,5,65,1054,8,65,10,65,12,65,1057,9,65,1,65,3,65,1060,
  	8,65,1,66,1,66,3,66,1064,8,66,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,68,
  	1,68,1,68,1,68,3,68,1077,8,68,1,68,3,68,1080,8,68,1,68,1,68,1,69,1,69,
  	1,69,3,69,1087,8,69,1,69,1,69,1,70,1,70,1,70,3,70,1094,8,70,1,71,1,71,
  	3,71,1098,8,71,1,71,1,71,1,72,1,72,3,72,1104,8,72,1,73,1,73,3,73,1108,
  	8,73,1,74,4,74,1111,8,74,11,74,12,74,1112,1,75,1,75,1,75,3,75,1118,8,
  	75,1,76,1,76,1,76,1,76,1,77,3,77,1125,8,77,1,77,1,77,1,77,1,77,5,77,1131,
  	8,77,10,77,12,77,1134,9,77,1,77,1,77,1,78,1,78,1,78,1,78,3,78,1142,8,
  	78,1,78,1,78,3,78,1146,8,78,1,78,1,78,5,78,1150,8,78,10,78,12,78,1153,
  	9,78,1,78,1,78,1,79,1,79,1,79,1,79,3,79,1161,8,79,1,79,1,79,1,79,3,79,
  	1166,8,79,1,79,1,79,1,79,1,79,1,79,3,79,1173,8,79,1,80,1,80,1,80,5,80,
  	1178,8,80,10,80,12,80,1181,9,80,1,81,1,81,1,81,3,81,1186,8,81,1,81,1,
  	81,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,
  	82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,
  	82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,
  	82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,
  	82,1,82,1,82,1,82,3,82,1249,8,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,
  	82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,3,82,1266,8,82,1,82,1,82,1,82,1,
  	82,1,82,3,82,1273,8,82,1,82,1,82,1,82,3,82,1278,8,82,3,82,1280,8,82,1,
  	82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,
  	82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,
  	82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,3,82,1318,8,82,1,82,1,82,1,82,1,
  	82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,
  	82,1,82,1,82,5,82,1340,8,82,10,82,12,82,1343,9,82,1,83,1,83,3,83,1347,
  	8,83,1,84,1,84,1,84,3,84,1352,8,84,1,84,1,84,1,84,3,84,1357,8,84,1,84,
  	3,84,1360,8,84,1,84,1,84,1,84,1,84,3,84,1366,8,84,1,85,1,85,5,85,1370,
  	8,85,10,85,12,85,1373,9,85,1,85,1,85,4,85,1377,8,85,11,85,12,85,1378,
  	1,85,5,85,1382,8,85,10,85,12,85,1385,9,85,1,85,5,85,1388,8,85,10,85,12,
  	85,1391,9,85,1,85,1,85,1,85,1,85,1,85,4,85,1398,8,85,11,85,12,85,1399,
  	1,85,5,85,1403,8,85,10,85,12,85,1406,9,85,1,85,3,85,1409,8,85,1,85,1,
  	85,3,85,1413,8,85,1,86,3,86,1416,8,86,1,86,1,86,1,87,1,87,1,87,3,87,1423,
  	8,87,1,87,3,87,1426,8,87,1,87,1,87,1,88,3,88,1431,8,88,1,88,1,88,3,88,
  	1435,8,88,1,88,1,88,1,88,1,88,3,88,1441,8,88,1,88,1,88,3,88,1445,8,88,
  	1,88,1,88,1,88,1,88,1,88,1,88,1,88,1,88,1,88,3,88,1456,8,88,1,89,1,89,
  	1,89,1,89,1,89,1,89,1,89,1,89,5,89,1466,8,89,10,89,12,89,1469,9,89,1,
  	89,3,89,1472,8,89,1,89,1,89,1,90,1,90,1,90,5,90,1479,8,90,10,90,12,90,
  	1482,9,90,1,90,1,90,1,90,1,91,1,91,1,91,3,91,1490,8,91,1,92,1,92,1,93,
  	1,93,1,93,1,93,3,93,1498,8,93,1,93,1,93,3,93,1502,8,93,1,94,1,94,1,94,
  	5,94,1507,8,94,10,94,12,94,1510,9,94,1,94,3,94,1513,8,94,1,95,1,95,1,
  	95,3,95,1518,8,95,1,95,1,95,1,95,3,95,1523,8,95,1,95,1,95,3,95,1527,8,
  	95,1,96,1,96,1,96,1,96,1,96,5,96,1534,8,96,10,96,12,96,1537,9,96,1,96,
  	1,96,1,97,3,97,1542,8,97,1,97,1,97,1,98,1,98,3,98,1548,8,98,1,98,3,98,
  	1551,8,98,1,99,1,99,3,99,1555,8,99,1,99,3,99,1558,8,99,1,99,1,99,1,99,
  	3,99,1563,8,99,1,100,3,100,1566,8,100,1,100,3,100,1569,8,100,1,100,3,
  	100,1572,8,100,1,100,3,100,1575,8,100,1,100,1,100,3,100,1579,8,100,1,
  	100,1,100,3,100,1583,8,100,1,100,1,100,3,100,1587,8,100,1,100,1,100,1,
  	100,3,100,1592,8,100,1,100,1,100,3,100,1596,8,100,3,100,1598,8,100,1,
  	100,1,100,5,100,1602,8,100,10,100,12,100,1605,9,100,1,100,1,100,1,101,
  	1,101,1,101,5,101,1612,8,101,10,101,12,101,1615,9,101,1,102,3,102,1618,
  	8,102,1,102,3,102,1621,8,102,1,102,1,102,1,103,1,103,1,103,1,103,5,103,
  	1629,8,103,10,103,12,103,1632,9,103,1,103,1,103,3,103,1636,8,103,3,103,
  	1638,8,103,1,104,1,104,1,104,3,104,1643,8,104,1,104,1,104,1,104,1,104,
  	5,104,1649,8,104,10,104,12,104,1652,9,104,1,104,3,104,1655,8,104,1,104,
  	1,104,3,104,1659,8,104,1,105,1,105,1,105,5,105,1664,8,105,10,105,12,105,
  	1667,9,105,1,106,1,106,1,106,1,106,5,106,1673,8,106,10,106,12,106,1676,
  	9,106,1,106,3,106,1679,8,106,1,106,3,106,1682,8,106,1,106,1,106,1,107,
  	3,107,1687,8,107,1,107,3,107,1690,8,107,1,107,1,107,1,107,3,107,1695,
  	8,107,1,108,1,108,1,108,1,109,1,109,1,109,1,109,1,109,1,109,3,109,1706,
  	8,109,3,109,1708,8,109,1,109,1,109,1,109,1,109,3,109,1714,8,109,3,109,
  	1716,8,109,1,109,1,109,1,109,1,109,1,109,3,109,1723,8,109,1,109,1,109,
  	1,109,3,109,1728,8,109,5,109,1730,8,109,10,109,12,109,1733,9,109,3,109,
  	1735,8,109,1,110,1,110,1,110,1,110,1,110,3,110,1742,8,110,1,111,1,111,
  	1,111,1,111,3,111,1748,8,111,1,112,1,112,1,113,1,113,1,113,1,113,1,113,
  	1,113,3,113,1758,8,113,1,113,1,113,1,113,3,113,1763,8,113,1,113,1,113,
  	1,113,3,113,1768,8,113,3,113,1770,8,113,1,114,1,114,1,115,1,115,4,115,
  	1776,8,115,11,115,12,115,1777,1,115,1,115,4,115,1782,8,115,11,115,12,
  	115,1783,1,115,1,115,1,115,5,115,1789,8,115,10,115,12,115,1792,9,115,
  	1,115,3,115,1795,8,115,1,116,1,116,1,116,3,116,1800,8,116,1,117,1,117,
  	1,117,5,117,1805,8,117,10,117,12,117,1808,9,117,1,118,1,118,5,118,1812,
  	8,118,10,118,12,118,1815,9,118,1,119,1,119,1,119,1,119,1,119,1,119,3,
  	119,1823,8,119,1,120,1,120,1,120,3,120,1828,8,120,1,121,1,121,1,121,1,
  	122,1,122,1,122,1,122,3,122,1837,8,122,1,123,3,123,1840,8,123,1,123,4,
  	123,1843,8,123,11,123,12,123,1844,1,123,5,123,1848,8,123,10,123,12,123,
  	1851,9,123,1,124,1,124,1,124,3,124,1856,8,124,1,124,1,124,1,124,1,124,
  	3,124,1862,8,124,1,125,1,125,3,125,1866,8,125,1,126,1,126,1,126,1,126,
  	1,126,3,126,1873,8,126,1,126,5,126,1876,8,126,10,126,12,126,1879,9,126,
  	1,127,5,127,1882,8,127,10,127,12,127,1885,9,127,1,127,1,127,1,127,1,127,
  	1,127,1,127,3,127,1893,8,127,1,127,5,127,1896,8,127,10,127,12,127,1899,
  	9,127,1,128,1,128,3,128,1903,8,128,1,128,1,128,1,128,1,128,1,128,3,128,
  	1910,8,128,1,129,3,129,1913,8,129,1,129,1,129,3,129,1917,8,129,5,129,
  	1919,8,129,10,129,12,129,1922,9,129,1,130,1,130,1,130,1,130,1,130,1,130,
  	1,130,3,130,1931,8,130,1,131,1,131,1,132,1,132,1,133,1,133,1,134,1,134,
  	1,135,1,135,1,136,1,136,1,137,1,137,1,137,0,2,118,164,138,0,2,4,6,8,10,
  	12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,
  	58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,
  	104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,
  	140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,
  	176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,
  	212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,
  	248,250,252,254,256,258,260,262,264,266,268,270,272,274,0,25,2,0,56,56,
  	82,82,2,0,54,54,122,122,1,0,219,220,2,0,95,95,119,119,1,0,207,208,2,0,
  	200,200,202,203,1,0,165,166,1,0,88,89,1,0,114,115,1,0,204,206,2,0,202,
  	203,210,210,1,0,190,191,2,0,171,172,196,197,1,0,167,170,4,0,173,175,177,
  	185,189,189,221,221,1,0,202,203,2,0,226,227,229,230,2,0,54,54,107,107,
  	2,0,44,44,77,77,2,0,44,160,225,225,4,0,44,44,77,77,110,113,118,118,1,
  	0,153,160,1,0,137,152,7,0,45,45,48,48,62,62,94,95,106,106,116,116,119,
  	119,9,0,45,45,47,48,61,62,79,79,92,95,106,106,116,116,119,119,125,127,
  	2184,0,277,1,0,0,0,2,294,1,0,0,0,4,324,1,0,0,0,6,327,1,0,0,0,8,334,1,
  	0,0,0,10,342,1,0,0,0,12,354,1,0,0,0,14,356,1,0,0,0,16,364,1,0,0,0,18,
  	377,1,0,0,0,20,379,1,0,0,0,22,401,1,0,0,0,24,404,1,0,0,0,26,427,1,0,0,
  	0,28,471,1,0,0,0,30,473,1,0,0,0,32,495,1,0,0,0,34,497,1,0,0,0,36,505,
  	1,0,0,0,38,514,1,0,0,0,40,519,1,0,0,0,42,527,1,0,0,0,44,539,1,0,0,0,46,
  	543,1,0,0,0,48,559,1,0,0,0,50,566,1,0,0,0,52,572,1,0,0,0,54,601,1,0,0,
  	0,56,603,1,0,0,0,58,605,1,0,0,0,60,637,1,0,0,0,62,639,1,0,0,0,64,643,
  	1,0,0,0,66,648,1,0,0,0,68,651,1,0,0,0,70,655,1,0,0,0,72,665,1,0,0,0,74,
  	671,1,0,0,0,76,693,1,0,0,0,78,695,1,0,0,0,80,697,1,0,0,0,82,730,1,0,0,
  	0,84,736,1,0,0,0,86,742,1,0,0,0,88,748,1,0,0,0,90,754,1,0,0,0,92,757,
  	1,0,0,0,94,763,1,0,0,0,96,818,1,0,0,0,98,837,1,0,0,0,100,853,1,0,0,0,
  	102,856,1,0,0,0,104,860,1,0,0,0,106,864,1,0,0,0,108,877,1,0,0,0,110,881,
  	1,0,0,0,112,901,1,0,0,0,114,904,1,0,0,0,116,917,1,0,0,0,118,943,1,0,0,
  	0,120,953,1,0,0,0,122,972,1,0,0,0,124,974,1,0,0,0,126,978,1,0,0,0,128,
  	1048,1,0,0,0,130,1059,1,0,0,0,132,1063,1,0,0,0,134,1065,1,0,0,0,136,1072,
  	1,0,0,0,138,1086,1,0,0,0,140,1090,1,0,0,0,142,1095,1,0,0,0,144,1103,1,
  	0,0,0,146,1107,1,0,0,0,148,1110,1,0,0,0,150,1114,1,0,0,0,152,1119,1,0,
  	0,0,154,1124,1,0,0,0,156,1137,1,0,0,0,158,1172,1,0,0,0,160,1174,1,0,0,
  	0,162,1182,1,0,0,0,164,1279,1,0,0,0,166,1346,1,0,0,0,168,1359,1,0,0,0,
  	170,1412,1,0,0,0,172,1415,1,0,0,0,174,1422,1,0,0,0,176,1455,1,0,0,0,178,
  	1457,1,0,0,0,180,1475,1,0,0,0,182,1486,1,0,0,0,184,1491,1,0,0,0,186,1493,
  	1,0,0,0,188,1503,1,0,0,0,190,1526,1,0,0,0,192,1528,1,0,0,0,194,1541,1,
  	0,0,0,196,1550,1,0,0,0,198,1562,1,0,0,0,200,1565,1,0,0,0,202,1608,1,0,
  	0,0,204,1617,1,0,0,0,206,1637,1,0,0,0,208,1658,1,0,0,0,210,1660,1,0,0,
  	0,212,1668,1,0,0,0,214,1694,1,0,0,0,216,1696,1,0,0,0,218,1734,1,0,0,0,
  	220,1741,1,0,0,0,222,1747,1,0,0,0,224,1749,1,0,0,0,226,1769,1,0,0,0,228,
  	1771,1,0,0,0,230,1794,1,0,0,0,232,1799,1,0,0,0,234,1801,1,0,0,0,236,1809,
  	1,0,0,0,238,1822,1,0,0,0,240,1824,1,0,0,0,242,1829,1,0,0,0,244,1836,1,
  	0,0,0,246,1839,1,0,0,0,248,1861,1,0,0,0,250,1865,1,0,0,0,252,1872,1,0,
  	0,0,254,1883,1,0,0,0,256,1909,1,0,0,0,258,1912,1,0,0,0,260,1930,1,0,0,
  	0,262,1932,1,0,0,0,264,1934,1,0,0,0,266,1936,1,0,0,0,268,1938,1,0,0,0,
  	270,1940,1,0,0,0,272,1942,1,0,0,0,274,1944,1,0,0,0,276,278,5,10,0,0,277,
  	276,1,0,0,0,277,278,1,0,0,0,278,283,1,0,0,0,279,282,3,2,1,0,280,282,3,
  	8,4,0,281,279,1,0,0,0,281,280,1,0,0,0,282,285,1,0,0,0,283,281,1,0,0,0,
  	283,284,1,0,0,0,284,286,1,0,0,0,285,283,1,0,0,0,286,287,5,0,0,1,287,1,
  	1,0,0,0,288,290,3,4,2,0,289,288,1,0,0,0,290,291,1,0,0,0,291,289,1,0,0,
  	0,291,292,1,0,0,0,292,295,1,0,0,0,293,295,3,6,3,0,294,289,1,0,0,0,294,
  	293,1,0,0,0,295,3,1,0,0,0,296,325,5,8,0,0,297,325,5,15,0,0,298,325,5,
  	6,0,0,299,325,5,9,0,0,300,325,5,24,0,0,301,325,5,16,0,0,302,325,5,17,
  	0,0,303,325,5,2,0,0,304,325,5,18,0,0,305,325,5,19,0,0,306,325,5,27,0,
  	0,307,325,5,20,0,0,308,325,5,31,0,0,309,325,5,21,0,0,310,325,5,22,0,0,
  	311,325,5,28,0,0,312,325,5,32,0,0,313,325,5,37,0,0,314,325,5,5,0,0,315,
  	325,5,35,0,0,316,320,5,3,0,0,317,319,5,12,0,0,318,317,1,0,0,0,319,322,
  	1,0,0,0,320,318,1,0,0,0,320,321,1,0,0,0,321,323,1,0,0,0,322,320,1,0,0,
  	0,323,325,5,13,0,0,324,296,1,0,0,0,324,297,1,0,0,0,324,298,1,0,0,0,324,
  	299,1,0,0,0,324,300,1,0,0,0,324,301,1,0,0,0,324,302,1,0,0,0,324,303,1,
  	0,0,0,324,304,1,0,0,0,324,305,1,0,0,0,324,306,1,0,0,0,324,307,1,0,0,0,
  	324,308,1,0,0,0,324,309,1,0,0,0,324,310,1,0,0,0,324,311,1,0,0,0,324,312,
  	1,0,0,0,324,313,1,0,0,0,324,314,1,0,0,0,324,315,1,0,0,0,324,316,1,0,0,
  	0,325,5,1,0,0,0,326,328,5,34,0,0,327,326,1,0,0,0,328,329,1,0,0,0,329,
  	327,1,0,0,0,329,330,1,0,0,0,330,7,1,0,0,0,331,333,3,10,5,0,332,331,1,
  	0,0,0,333,336,1,0,0,0,334,332,1,0,0,0,334,335,1,0,0,0,335,338,1,0,0,0,
  	336,334,1,0,0,0,337,339,3,12,6,0,338,337,1,0,0,0,339,340,1,0,0,0,340,
  	338,1,0,0,0,340,341,1,0,0,0,341,9,1,0,0,0,342,343,5,87,0,0,343,344,5,
  	103,0,0,344,345,3,206,103,0,345,346,5,220,0,0,346,11,1,0,0,0,347,355,
  	3,54,27,0,348,355,3,14,7,0,349,355,3,20,10,0,350,355,3,24,12,0,351,355,
  	3,26,13,0,352,355,3,154,77,0,353,355,3,156,78,0,354,347,1,0,0,0,354,348,
  	1,0,0,0,354,349,1,0,0,0,354,350,1,0,0,0,354,351,1,0,0,0,354,352,1,0,0,
  	0,354,353,1,0,0,0,355,13,1,0,0,0,356,358,5,128,0,0,357,359,7,0,0,0,358,
  	357,1,0,0,0,358,359,1,0,0,0,359,360,1,0,0,0,360,361,3,16,8,0,361,362,
  	5,220,0,0,362,15,1,0,0,0,363,365,5,194,0,0,364,363,1,0,0,0,364,365,1,
  	0,0,0,365,366,1,0,0,0,366,374,3,18,9,0,367,369,5,218,0,0,368,370,5,194,
  	0,0,369,368,1,0,0,0,369,370,1,0,0,0,370,371,1,0,0,0,371,373,3,18,9,0,
  	372,367,1,0,0,0,373,376,1,0,0,0,374,372,1,0,0,0,374,375,1,0,0,0,375,17,
  	1,0,0,0,376,374,1,0,0,0,377,378,3,206,103,0,378,19,1,0,0,0,379,394,5,
  	103,0,0,380,382,3,206,103,0,381,380,1,0,0,0,381,382,1,0,0,0,382,383,1,
  	0,0,0,383,387,5,216,0,0,384,386,3,22,11,0,385,384,1,0,0,0,386,389,1,0,
  	0,0,387,385,1,0,0,0,387,388,1,0,0,0,388,390,1,0,0,0,389,387,1,0,0,0,390,
  	395,5,217,0,0,391,392,3,206,103,0,392,393,5,220,0,0,393,395,1,0,0,0,394,
  	381,1,0,0,0,394,391,1,0,0,0,395,21,1,0,0,0,396,402,3,54,27,0,397,402,
  	3,14,7,0,398,402,3,24,12,0,399,402,3,26,13,0,400,402,3,154,77,0,401,396,
  	1,0,0,0,401,397,1,0,0,0,401,398,1,0,0,0,401,399,1,0,0,0,401,400,1,0,0,
  	0,402,23,1,0,0,0,403,405,3,44,22,0,404,403,1,0,0,0,404,405,1,0,0,0,405,
  	406,1,0,0,0,406,408,5,82,0,0,407,409,5,198,0,0,408,407,1,0,0,0,408,409,
  	1,0,0,0,409,410,1,0,0,0,410,412,3,264,132,0,411,413,3,32,16,0,412,411,
  	1,0,0,0,412,413,1,0,0,0,413,414,1,0,0,0,414,415,5,212,0,0,415,416,3,114,
  	57,0,416,422,5,213,0,0,417,419,5,219,0,0,418,420,5,211,0,0,419,418,1,
  	0,0,0,419,420,1,0,0,0,420,421,1,0,0,0,421,423,3,118,59,0,422,417,1,0,
  	0,0,422,423,1,0,0,0,423,424,1,0,0,0,424,425,3,58,29,0,425,25,1,0,0,0,
  	426,428,3,44,22,0,427,426,1,0,0,0,427,428,1,0,0,0,428,430,1,0,0,0,429,
  	431,5,110,0,0,430,429,1,0,0,0,430,431,1,0,0,0,431,433,1,0,0,0,432,434,
  	3,262,131,0,433,432,1,0,0,0,433,434,1,0,0,0,434,436,1,0,0,0,435,437,5,
  	108,0,0,436,435,1,0,0,0,436,437,1,0,0,0,437,460,1,0,0,0,438,439,3,28,
  	14,0,439,441,3,264,132,0,440,442,3,32,16,0,441,440,1,0,0,0,441,442,1,
  	0,0,0,442,445,1,0,0,0,443,444,5,76,0,0,444,446,3,196,98,0,445,443,1,0,
  	0,0,445,446,1,0,0,0,446,449,1,0,0,0,447,448,5,86,0,0,448,450,3,30,15,
  	0,449,447,1,0,0,0,449,450,1,0,0,0,450,461,1,0,0,0,451,452,5,96,0,0,452,
  	454,3,264,132,0,453,455,3,32,16,0,454,453,1,0,0,0,454,455,1,0,0,0,455,
  	458,1,0,0,0,456,457,5,76,0,0,457,459,3,30,15,0,458,456,1,0,0,0,458,459,
  	1,0,0,0,459,461,1,0,0,0,460,438,1,0,0,0,460,451,1,0,0,0,461,462,1,0,0,
  	0,462,466,5,216,0,0,463,465,3,128,64,0,464,463,1,0,0,0,465,468,1,0,0,
  	0,466,464,1,0,0,0,466,467,1,0,0,0,467,469,1,0,0,0,468,466,1,0,0,0,469,
  	470,5,217,0,0,470,27,1,0,0,0,471,472,7,1,0,0,472,29,1,0,0,0,473,478,3,
  	196,98,0,474,475,5,218,0,0,475,477,3,196,98,0,476,474,1,0,0,0,477,480,
  	1,0,0,0,478,476,1,0,0,0,478,479,1,0,0,0,479,31,1,0,0,0,480,478,1,0,0,
  	0,481,482,5,162,0,0,482,483,3,34,17,0,483,484,5,163,0,0,484,496,1,0,0,
  	0,485,486,5,162,0,0,486,487,3,36,18,0,487,488,5,163,0,0,488,496,1,0,0,
  	0,489,490,5,162,0,0,490,491,3,34,17,0,491,492,5,218,0,0,492,493,3,36,
  	18,0,493,494,5,163,0,0,494,496,1,0,0,0,495,481,1,0,0,0,495,485,1,0,0,
  	0,495,489,1,0,0,0,496,33,1,0,0,0,497,502,3,38,19,0,498,499,5,218,0,0,
  	499,501,3,38,19,0,500,498,1,0,0,0,501,504,1,0,0,0,502,500,1,0,0,0,502,
  	503,1,0,0,0,503,35,1,0,0,0,504,502,1,0,0,0,505,510,3,40,20,0,506,507,
  	5,218,0,0,507,509,3,40,20,0,508,506,1,0,0,0,509,512,1,0,0,0,510,508,1,
  	0,0,0,510,511,1,0,0,0,511,37,1,0,0,0,512,510,1,0,0,0,513,515,3,44,22,
  	0,514,513,1,0,0,0,514,515,1,0,0,0,515,516,1,0,0,0,516,517,3,264,132,0,
  	517,39,1,0,0,0,518,520,3,44,22,0,519,518,1,0,0,0,519,520,1,0,0,0,520,
  	521,1,0,0,0,521,522,3,264,132,0,522,525,5,221,0,0,523,526,3,196,98,0,
  	524,526,3,272,136,0,525,523,1,0,0,0,525,524,1,0,0,0,526,41,1,0,0,0,527,
  	528,5,162,0,0,528,533,3,198,99,0,529,530,5,218,0,0,530,532,3,198,99,0,
  	531,529,1,0,0,0,532,535,1,0,0,0,533,531,1,0,0,0,533,534,1,0,0,0,534,536,
  	1,0,0,0,535,533,1,0,0,0,536,537,5,163,0,0,537,43,1,0,0,0,538,540,3,46,
  	23,0,539,538,1,0,0,0,540,541,1,0,0,0,541,539,1,0,0,0,541,542,1,0,0,0,
  	542,45,1,0,0,0,543,547,5,43,0,0,544,545,3,264,132,0,545,546,5,219,0,0,
  	546,548,1,0,0,0,547,544,1,0,0,0,547,548,1,0,0,0,548,549,1,0,0,0,549,554,
  	3,48,24,0,550,551,5,218,0,0,551,553,3,48,24,0,552,550,1,0,0,0,553,556,
  	1,0,0,0,554,552,1,0,0,0,554,555,1,0,0,0,555,557,1,0,0,0,556,554,1,0,0,
  	0,557,558,5,215,0,0,558,47,1,0,0,0,559,561,3,204,102,0,560,562,3,212,
  	106,0,561,560,1,0,0,0,561,562,1,0,0,0,562,49,1,0,0,0,563,565,3,52,26,
  	0,564,563,1,0,0,0,565,568,1,0,0,0,566,564,1,0,0,0,566,567,1,0,0,0,567,
  	51,1,0,0,0,568,566,1,0,0,0,569,573,3,54,27,0,570,573,3,24,12,0,571,573,
  	3,26,13,0,572,569,1,0,0,0,572,570,1,0,0,0,572,571,1,0,0,0,573,53,1,0,
  	0,0,574,575,3,264,132,0,575,576,5,219,0,0,576,602,1,0,0,0,577,602,3,58,
  	29,0,578,602,3,60,30,0,579,602,3,70,35,0,580,602,3,72,36,0,581,602,3,
  	74,37,0,582,602,3,80,40,0,583,602,3,84,42,0,584,602,3,86,43,0,585,602,
  	3,88,44,0,586,587,3,186,93,0,587,588,5,220,0,0,588,602,1,0,0,0,589,602,
  	3,120,60,0,590,602,3,126,63,0,591,602,3,124,62,0,592,602,3,90,45,0,593,
  	602,3,92,46,0,594,602,3,94,47,0,595,602,3,96,48,0,596,602,3,102,51,0,
  	597,602,3,104,52,0,598,602,3,106,53,0,599,602,3,56,28,0,600,602,3,108,
  	54,0,601,574,1,0,0,0,601,577,1,0,0,0,601,578,1,0,0,0,601,579,1,0,0,0,
  	601,580,1,0,0,0,601,581,1,0,0,0,601,582,1,0,0,0,601,583,1,0,0,0,601,584,
  	1,0,0,0,601,585,1,0,0,0,601,586,1,0,0,0,601,589,1,0,0,0,601,590,1,0,0,
  	0,601,591,1,0,0,0,601,592,1,0,0,0,601,593,1,0,0,0,601,594,1,0,0,0,601,
  	595,1,0,0,0,601,596,1,0,0,0,601,597,1,0,0,0,601,598,1,0,0,0,601,599,1,
  	0,0,0,601,600,1,0,0,0,602,55,1,0,0,0,603,604,5,220,0,0,604,57,1,0,0,0,
  	605,606,5,216,0,0,606,607,3,50,25,0,607,608,5,217,0,0,608,59,1,0,0,0,
  	609,610,5,85,0,0,610,611,3,162,81,0,611,615,3,54,27,0,612,614,3,62,31,
  	0,613,612,1,0,0,0,614,617,1,0,0,0,615,613,1,0,0,0,615,616,1,0,0,0,616,
  	619,1,0,0,0,617,615,1,0,0,0,618,620,3,66,33,0,619,618,1,0,0,0,619,620,
  	1,0,0,0,620,638,1,0,0,0,621,622,5,85,0,0,622,623,3,162,81,0,623,624,5,
  	219,0,0,624,628,3,50,25,0,625,627,3,64,32,0,626,625,1,0,0,0,627,630,1,
  	0,0,0,628,626,1,0,0,0,628,629,1,0,0,0,629,632,1,0,0,0,630,628,1,0,0,0,
  	631,633,3,68,34,0,632,631,1,0,0,0,632,633,1,0,0,0,633,634,1,0,0,0,634,
  	635,5,71,0,0,635,636,5,220,0,0,636,638,1,0,0,0,637,609,1,0,0,0,637,621,
  	1,0,0,0,638,61,1,0,0,0,639,640,5,65,0,0,640,641,3,162,81,0,641,642,3,
  	54,27,0,642,63,1,0,0,0,643,644,5,65,0,0,644,645,3,162,81,0,645,646,5,
  	219,0,0,646,647,3,50,25,0,647,65,1,0,0,0,648,649,5,64,0,0,649,650,3,54,
  	27,0,650,67,1,0,0,0,651,652,5,64,0,0,652,653,5,219,0,0,653,654,3,50,25,
  	0,654,69,1,0,0,0,655,656,5,130,0,0,656,663,3,162,81,0,657,664,3,54,27,
  	0,658,659,5,219,0,0,659,660,3,50,25,0,660,661,5,73,0,0,661,662,5,220,
  	0,0,662,664,1,0,0,0,663,657,1,0,0,0,663,658,1,0,0,0,664,71,1,0,0,0,665,
  	666,5,60,0,0,666,667,3,54,27,0,667,668,5,130,0,0,668,669,3,162,81,0,669,
  	670,5,220,0,0,670,73,1,0,0,0,671,672,5,80,0,0,672,674,5,212,0,0,673,675,
  	3,76,38,0,674,673,1,0,0,0,674,675,1,0,0,0,675,676,1,0,0,0,676,678,5,220,
  	0,0,677,679,3,160,80,0,678,677,1,0,0,0,678,679,1,0,0,0,679,680,1,0,0,
  	0,680,682,5,220,0,0,681,683,3,78,39,0,682,681,1,0,0,0,682,683,1,0,0,0,
  	683,684,1,0,0,0,684,691,5,213,0,0,685,692,3,54,27,0,686,687,5,219,0,0,
  	687,688,3,50,25,0,688,689,5,69,0,0,689,690,5,220,0,0,690,692,1,0,0,0,
  	691,685,1,0,0,0,691,686,1,0,0,0,692,75,1,0,0,0,693,694,3,160,80,0,694,
  	77,1,0,0,0,695,696,3,160,80,0,696,79,1,0,0,0,697,698,5,120,0,0,698,722,
  	3,162,81,0,699,701,5,216,0,0,700,702,5,220,0,0,701,700,1,0,0,0,701,702,
  	1,0,0,0,702,706,1,0,0,0,703,705,3,82,41,0,704,703,1,0,0,0,705,708,1,0,
  	0,0,706,704,1,0,0,0,706,707,1,0,0,0,707,709,1,0,0,0,708,706,1,0,0,0,709,
  	723,5,217,0,0,710,712,5,219,0,0,711,713,5,220,0,0,712,711,1,0,0,0,712,
  	713,1,0,0,0,713,717,1,0,0,0,714,716,3,82,41,0,715,714,1,0,0,0,716,719,
  	1,0,0,0,717,715,1,0,0,0,717,718,1,0,0,0,718,720,1,0,0,0,719,717,1,0,0,
  	0,720,721,5,72,0,0,721,723,5,220,0,0,722,699,1,0,0,0,722,710,1,0,0,0,
  	723,81,1,0,0,0,724,725,5,52,0,0,725,728,3,164,82,0,726,728,5,59,0,0,727,
  	724,1,0,0,0,727,726,1,0,0,0,728,729,1,0,0,0,729,731,7,2,0,0,730,727,1,
  	0,0,0,731,732,1,0,0,0,732,730,1,0,0,0,732,733,1,0,0,0,733,734,1,0,0,0,
  	734,735,3,50,25,0,735,83,1,0,0,0,736,738,5,50,0,0,737,739,3,164,82,0,
  	738,737,1,0,0,0,738,739,1,0,0,0,739,740,1,0,0,0,740,741,5,220,0,0,741,
  	85,1,0,0,0,742,744,5,57,0,0,743,745,3,164,82,0,744,743,1,0,0,0,744,745,
  	1,0,0,0,745,746,1,0,0,0,746,747,5,220,0,0,747,87,1,0,0,0,748,750,5,117,
  	0,0,749,751,3,164,82,0,750,749,1,0,0,0,750,751,1,0,0,0,751,752,1,0,0,
  	0,752,753,5,220,0,0,753,89,1,0,0,0,754,755,3,164,82,0,755,756,5,220,0,
  	0,756,91,1,0,0,0,757,758,5,127,0,0,758,759,5,212,0,0,759,760,3,234,117,
  	0,760,761,5,213,0,0,761,762,5,220,0,0,762,93,1,0,0,0,763,808,5,81,0,0,
  	764,765,5,212,0,0,765,766,3,164,82,0,766,767,5,46,0,0,767,768,3,170,85,
  	0,768,769,5,213,0,0,769,809,1,0,0,0,770,771,5,212,0,0,771,772,3,236,118,
  	0,772,774,5,46,0,0,773,775,5,198,0,0,774,773,1,0,0,0,774,775,1,0,0,0,
  	775,776,1,0,0,0,776,782,3,166,83,0,777,779,5,164,0,0,778,780,5,198,0,
  	0,779,778,1,0,0,0,779,780,1,0,0,0,780,781,1,0,0,0,781,783,3,236,118,0,
  	782,777,1,0,0,0,782,783,1,0,0,0,783,784,1,0,0,0,784,785,5,213,0,0,785,
  	809,1,0,0,0,786,787,5,212,0,0,787,788,3,164,82,0,788,789,5,46,0,0,789,
  	795,3,166,83,0,790,792,5,164,0,0,791,793,5,198,0,0,792,791,1,0,0,0,792,
  	793,1,0,0,0,793,794,1,0,0,0,794,796,3,236,118,0,795,790,1,0,0,0,795,796,
  	1,0,0,0,796,797,1,0,0,0,797,798,5,213,0,0,798,809,1,0,0,0,799,800,5,212,
  	0,0,800,801,3,236,118,0,801,802,5,46,0,0,802,803,5,98,0,0,803,804,5,212,
  	0,0,804,805,3,258,129,0,805,806,5,213,0,0,806,807,5,213,0,0,807,809,1,
  	0,0,0,808,764,1,0,0,0,808,770,1,0,0,0,808,786,1,0,0,0,808,799,1,0,0,0,
  	809,816,1,0,0,0,810,817,3,54,27,0,811,812,5,219,0,0,812,813,3,50,25,0,
  	813,814,5,70,0,0,814,815,5,220,0,0,815,817,1,0,0,0,816,810,1,0,0,0,816,
  	811,1,0,0,0,817,95,1,0,0,0,818,819,5,123,0,0,819,835,3,58,29,0,820,822,
  	3,98,49,0,821,820,1,0,0,0,822,823,1,0,0,0,823,821,1,0,0,0,823,824,1,0,
  	0,0,824,826,1,0,0,0,825,827,3,100,50,0,826,825,1,0,0,0,826,827,1,0,0,
  	0,827,836,1,0,0,0,828,830,3,98,49,0,829,828,1,0,0,0,830,833,1,0,0,0,831,
  	829,1,0,0,0,831,832,1,0,0,0,832,834,1,0,0,0,833,831,1,0,0,0,834,836,3,
  	100,50,0,835,821,1,0,0,0,835,831,1,0,0,0,836,97,1,0,0,0,837,838,5,53,
  	0,0,838,839,5,212,0,0,839,844,3,196,98,0,840,841,5,199,0,0,841,843,3,
  	196,98,0,842,840,1,0,0,0,843,846,1,0,0,0,844,842,1,0,0,0,844,845,1,0,
  	0,0,845,848,1,0,0,0,846,844,1,0,0,0,847,849,5,224,0,0,848,847,1,0,0,0,
  	848,849,1,0,0,0,849,850,1,0,0,0,850,851,5,213,0,0,851,852,3,58,29,0,852,
  	99,1,0,0,0,853,854,5,78,0,0,854,855,3,58,29,0,855,101,1,0,0,0,856,857,
  	5,121,0,0,857,858,3,164,82,0,858,859,5,220,0,0,859,103,1,0,0,0,860,861,
  	5,84,0,0,861,862,3,264,132,0,862,863,5,220,0,0,863,105,1,0,0,0,864,865,
  	5,58,0,0,865,866,5,212,0,0,866,867,3,110,55,0,867,874,5,213,0,0,868,875,
  	3,54,27,0,869,870,5,219,0,0,870,871,3,50,25,0,871,872,5,68,0,0,872,873,
  	5,220,0,0,873,875,1,0,0,0,874,868,1,0,0,0,874,869,1,0,0,0,875,107,1,0,
  	0,0,876,878,3,2,1,0,877,876,1,0,0,0,878,879,1,0,0,0,879,877,1,0,0,0,879,
  	880,1,0,0,0,880,109,1,0,0,0,881,886,3,112,56,0,882,883,5,218,0,0,883,
  	885,3,112,56,0,884,882,1,0,0,0,885,888,1,0,0,0,886,884,1,0,0,0,886,887,
  	1,0,0,0,887,111,1,0,0,0,888,886,1,0,0,0,889,890,5,134,0,0,890,893,5,221,
  	0,0,891,894,3,224,112,0,892,894,5,228,0,0,893,891,1,0,0,0,893,892,1,0,
  	0,0,894,902,1,0,0,0,895,896,5,135,0,0,896,897,5,221,0,0,897,902,5,232,
  	0,0,898,899,5,136,0,0,899,900,5,221,0,0,900,902,3,224,112,0,901,889,1,
  	0,0,0,901,895,1,0,0,0,901,898,1,0,0,0,902,113,1,0,0,0,903,905,3,116,58,
  	0,904,903,1,0,0,0,904,905,1,0,0,0,905,910,1,0,0,0,906,907,5,218,0,0,907,
  	909,3,116,58,0,908,906,1,0,0,0,909,912,1,0,0,0,910,908,1,0,0,0,910,911,
  	1,0,0,0,911,914,1,0,0,0,912,910,1,0,0,0,913,915,5,218,0,0,914,913,1,0,
  	0,0,914,915,1,0,0,0,915,115,1,0,0,0,916,918,3,44,22,0,917,916,1,0,0,0,
  	917,918,1,0,0,0,918,922,1,0,0,0,919,921,3,266,133,0,920,919,1,0,0,0,921,
  	924,1,0,0,0,922,920,1,0,0,0,922,923,1,0,0,0,923,926,1,0,0,0,924,922,1,
  	0,0,0,925,927,5,211,0,0,926,925,1,0,0,0,926,927,1,0,0,0,927,929,1,0,0,
  	0,928,930,3,118,59,0,929,928,1,0,0,0,929,930,1,0,0,0,930,932,1,0,0,0,
  	931,933,5,198,0,0,932,931,1,0,0,0,932,933,1,0,0,0,933,935,1,0,0,0,934,
  	936,5,195,0,0,935,934,1,0,0,0,935,936,1,0,0,0,936,937,1,0,0,0,937,938,
  	3,150,75,0,938,117,1,0,0,0,939,940,6,59,-1,0,940,944,3,196,98,0,941,944,
  	5,51,0,0,942,944,3,272,136,0,943,939,1,0,0,0,943,941,1,0,0,0,943,942,
  	1,0,0,0,944,950,1,0,0,0,945,946,10,1,0,0,946,947,5,199,0,0,947,949,3,
  	118,59,2,948,945,1,0,0,0,949,952,1,0,0,0,950,948,1,0,0,0,950,951,1,0,
  	0,0,951,119,1,0,0,0,952,950,1,0,0,0,953,954,5,83,0,0,954,959,3,122,61,
  	0,955,956,5,218,0,0,956,958,3,122,61,0,957,955,1,0,0,0,958,961,1,0,0,
  	0,959,957,1,0,0,0,959,960,1,0,0,0,960,962,1,0,0,0,961,959,1,0,0,0,962,
  	963,5,220,0,0,963,121,1,0,0,0,964,973,5,224,0,0,965,966,5,209,0,0,966,
  	973,3,236,118,0,967,968,5,209,0,0,968,969,5,216,0,0,969,970,3,164,82,
  	0,970,971,5,217,0,0,971,973,1,0,0,0,972,964,1,0,0,0,972,965,1,0,0,0,972,
  	967,1,0,0,0,973,123,1,0,0,0,974,975,5,63,0,0,975,976,3,160,80,0,976,977,
  	5,220,0,0,977,125,1,0,0,0,978,979,5,118,0,0,979,984,3,150,75,0,980,981,
  	5,218,0,0,981,983,3,150,75,0,982,980,1,0,0,0,983,986,1,0,0,0,984,982,
  	1,0,0,0,984,985,1,0,0,0,985,987,1,0,0,0,986,984,1,0,0,0,987,988,5,220,
  	0,0,988,127,1,0,0,0,989,991,3,44,22,0,990,989,1,0,0,0,990,991,1,0,0,0,
  	991,1042,1,0,0,0,992,994,3,146,73,0,993,995,3,118,59,0,994,993,1,0,0,
  	0,994,995,1,0,0,0,995,996,1,0,0,0,996,1001,3,150,75,0,997,998,5,218,0,
  	0,998,1000,3,150,75,0,999,997,1,0,0,0,1000,1003,1,0,0,0,1001,999,1,0,
  	0,0,1001,1002,1,0,0,0,1002,1004,1,0,0,0,1003,1001,1,0,0,0,1004,1005,5,
  	220,0,0,1005,1043,1,0,0,0,1006,1008,3,148,74,0,1007,1006,1,0,0,0,1007,
  	1008,1,0,0,0,1008,1040,1,0,0,0,1009,1011,5,56,0,0,1010,1012,3,118,59,
  	0,1011,1010,1,0,0,0,1011,1012,1,0,0,0,1012,1013,1,0,0,0,1013,1018,3,152,
  	76,0,1014,1015,5,218,0,0,1015,1017,3,152,76,0,1016,1014,1,0,0,0,1017,
  	1020,1,0,0,0,1018,1016,1,0,0,0,1018,1019,1,0,0,0,1019,1021,1,0,0,0,1020,
  	1018,1,0,0,0,1021,1022,5,220,0,0,1022,1041,1,0,0,0,1023,1025,5,82,0,0,
  	1024,1026,5,198,0,0,1025,1024,1,0,0,0,1025,1026,1,0,0,0,1026,1027,1,0,
  	0,0,1027,1029,3,264,132,0,1028,1030,3,32,16,0,1029,1028,1,0,0,0,1029,
  	1030,1,0,0,0,1030,1031,1,0,0,0,1031,1032,5,212,0,0,1032,1033,3,114,57,
  	0,1033,1036,5,213,0,0,1034,1037,3,140,70,0,1035,1037,3,142,71,0,1036,
  	1034,1,0,0,0,1036,1035,1,0,0,0,1036,1037,1,0,0,0,1037,1038,1,0,0,0,1038,
  	1039,3,144,72,0,1039,1041,1,0,0,0,1040,1009,1,0,0,0,1040,1023,1,0,0,0,
  	1041,1043,1,0,0,0,1042,992,1,0,0,0,1042,1007,1,0,0,0,1043,1049,1,0,0,
  	0,1044,1045,5,128,0,0,1045,1046,3,210,105,0,1046,1047,3,130,65,0,1047,
  	1049,1,0,0,0,1048,990,1,0,0,0,1048,1044,1,0,0,0,1049,129,1,0,0,0,1050,
  	1060,5,220,0,0,1051,1055,5,216,0,0,1052,1054,3,132,66,0,1053,1052,1,0,
  	0,0,1054,1057,1,0,0,0,1055,1053,1,0,0,0,1055,1056,1,0,0,0,1056,1058,1,
  	0,0,0,1057,1055,1,0,0,0,1058,1060,5,217,0,0,1059,1050,1,0,0,0,1059,1051,
  	1,0,0,0,1060,131,1,0,0,0,1061,1064,3,134,67,0,1062,1064,3,136,68,0,1063,
  	1061,1,0,0,0,1063,1062,1,0,0,0,1064,133,1,0,0,0,1065,1066,3,204,102,0,
  	1066,1067,5,192,0,0,1067,1068,3,264,132,0,1068,1069,5,91,0,0,1069,1070,
  	3,210,105,0,1070,1071,5,220,0,0,1071,135,1,0,0,0,1072,1073,3,138,69,0,
  	1073,1079,5,46,0,0,1074,1080,3,266,133,0,1075,1077,3,266,133,0,1076,1075,
  	1,0,0,0,1076,1077,1,0,0,0,1077,1078,1,0,0,0,1078,1080,3,264,132,0,1079,
  	1074,1,0,0,0,1079,1076,1,0,0,0,1080,1081,1,0,0,0,1081,1082,5,220,0,0,
  	1082,137,1,0,0,0,1083,1084,3,204,102,0,1084,1085,5,192,0,0,1085,1087,
  	1,0,0,0,1086,1083,1,0,0,0,1086,1087,1,0,0,0,1087,1088,1,0,0,0,1088,1089,
  	3,264,132,0,1089,139,1,0,0,0,1090,1091,5,219,0,0,1091,1093,3,264,132,
  	0,1092,1094,3,212,106,0,1093,1092,1,0,0,0,1093,1094,1,0,0,0,1094,141,
  	1,0,0,0,1095,1097,5,219,0,0,1096,1098,5,211,0,0,1097,1096,1,0,0,0,1097,
  	1098,1,0,0,0,1098,1099,1,0,0,0,1099,1100,3,118,59,0,1100,143,1,0,0,0,
  	1101,1104,5,220,0,0,1102,1104,3,58,29,0,1103,1101,1,0,0,0,1103,1102,1,
  	0,0,0,1104,145,1,0,0,0,1105,1108,3,148,74,0,1106,1108,5,129,0,0,1107,
  	1105,1,0,0,0,1107,1106,1,0,0,0,1108,147,1,0,0,0,1109,1111,3,266,133,0,
  	1110,1109,1,0,0,0,1111,1112,1,0,0,0,1112,1110,1,0,0,0,1112,1113,1,0,0,
  	0,1113,149,1,0,0,0,1114,1117,5,224,0,0,1115,1116,5,221,0,0,1116,1118,
  	3,218,109,0,1117,1115,1,0,0,0,1117,1118,1,0,0,0,1118,151,1,0,0,0,1119,
  	1120,3,264,132,0,1120,1121,5,221,0,0,1121,1122,3,218,109,0,1122,153,1,
  	0,0,0,1123,1125,3,44,22,0,1124,1123,1,0,0,0,1124,1125,1,0,0,0,1125,1126,
  	1,0,0,0,1126,1127,5,56,0,0,1127,1132,3,152,76,0,1128,1129,5,218,0,0,1129,
  	1131,3,152,76,0,1130,1128,1,0,0,0,1131,1134,1,0,0,0,1132,1130,1,0,0,0,
  	1132,1133,1,0,0,0,1133,1135,1,0,0,0,1134,1132,1,0,0,0,1135,1136,5,220,
  	0,0,1136,155,1,0,0,0,1137,1138,5,67,0,0,1138,1141,3,264,132,0,1139,1140,
  	5,219,0,0,1140,1142,7,3,0,0,1141,1139,1,0,0,0,1141,1142,1,0,0,0,1142,
  	1145,1,0,0,0,1143,1144,5,86,0,0,1144,1146,3,30,15,0,1145,1143,1,0,0,0,
  	1145,1146,1,0,0,0,1146,1147,1,0,0,0,1147,1151,5,216,0,0,1148,1150,3,158,
  	79,0,1149,1148,1,0,0,0,1150,1153,1,0,0,0,1151,1149,1,0,0,0,1151,1152,
  	1,0,0,0,1152,1154,1,0,0,0,1153,1151,1,0,0,0,1154,1155,5,217,0,0,1155,
  	157,1,0,0,0,1156,1157,5,52,0,0,1157,1160,3,264,132,0,1158,1159,5,221,
  	0,0,1159,1161,3,164,82,0,1160,1158,1,0,0,0,1160,1161,1,0,0,0,1161,1162,
  	1,0,0,0,1162,1163,5,220,0,0,1163,1173,1,0,0,0,1164,1166,3,148,74,0,1165,
  	1164,1,0,0,0,1165,1166,1,0,0,0,1166,1167,1,0,0,0,1167,1173,3,24,12,0,
  	1168,1169,5,128,0,0,1169,1170,3,210,105,0,1170,1171,3,130,65,0,1171,1173,
  	1,0,0,0,1172,1156,1,0,0,0,1172,1165,1,0,0,0,1172,1168,1,0,0,0,1173,159,
  	1,0,0,0,1174,1179,3,164,82,0,1175,1176,5,218,0,0,1176,1178,3,164,82,0,
  	1177,1175,1,0,0,0,1178,1181,1,0,0,0,1179,1177,1,0,0,0,1179,1180,1,0,0,
  	0,1180,161,1,0,0,0,1181,1179,1,0,0,0,1182,1185,5,212,0,0,1183,1186,3,
  	164,82,0,1184,1186,3,186,93,0,1185,1183,1,0,0,0,1185,1184,1,0,0,0,1186,
  	1187,1,0,0,0,1187,1188,5,213,0,0,1188,163,1,0,0,0,1189,1190,6,82,-1,0,
  	1190,1191,5,55,0,0,1191,1280,3,164,82,48,1192,1280,3,182,91,0,1193,1194,
  	3,228,114,0,1194,1195,5,214,0,0,1195,1196,3,164,82,0,1196,1197,5,215,
  	0,0,1197,1280,1,0,0,0,1198,1199,5,212,0,0,1199,1200,3,274,137,0,1200,
  	1201,5,213,0,0,1201,1202,3,164,82,45,1202,1280,1,0,0,0,1203,1204,7,4,
  	0,0,1204,1280,3,164,82,44,1205,1206,7,5,0,0,1206,1280,3,164,82,43,1207,
  	1208,7,6,0,0,1208,1280,3,236,118,0,1209,1210,3,236,118,0,1210,1211,7,
  	6,0,0,1211,1280,1,0,0,0,1212,1213,5,109,0,0,1213,1280,3,164,82,40,1214,
  	1280,3,168,84,0,1215,1280,3,236,118,0,1216,1280,3,220,110,0,1217,1280,
  	3,230,115,0,1218,1280,5,225,0,0,1219,1280,5,231,0,0,1220,1280,3,162,81,
  	0,1221,1280,5,131,0,0,1222,1223,5,98,0,0,1223,1224,5,212,0,0,1224,1225,
  	3,258,129,0,1225,1226,5,213,0,0,1226,1227,5,221,0,0,1227,1228,3,164,82,
  	31,1228,1280,1,0,0,0,1229,1230,5,97,0,0,1230,1231,5,212,0,0,1231,1232,
  	3,234,117,0,1232,1233,5,213,0,0,1233,1280,1,0,0,0,1234,1235,5,66,0,0,
  	1235,1236,5,212,0,0,1236,1237,3,236,118,0,1237,1238,5,213,0,0,1238,1280,
  	1,0,0,0,1239,1240,5,74,0,0,1240,1241,5,212,0,0,1241,1242,3,164,82,0,1242,
  	1243,5,213,0,0,1243,1280,1,0,0,0,1244,1248,5,75,0,0,1245,1246,5,212,0,
  	0,1246,1249,5,213,0,0,1247,1249,3,162,81,0,1248,1245,1,0,0,0,1248,1247,
  	1,0,0,0,1248,1249,1,0,0,0,1249,1280,1,0,0,0,1250,1251,7,7,0,0,1251,1280,
  	3,164,82,26,1252,1253,7,8,0,0,1253,1280,3,164,82,25,1254,1280,3,176,88,
  	0,1255,1280,3,178,89,0,1256,1257,5,121,0,0,1257,1280,3,164,82,7,1258,
  	1259,3,170,85,0,1259,1260,5,221,0,0,1260,1261,3,164,82,6,1261,1280,1,
  	0,0,0,1262,1263,3,166,83,0,1263,1265,3,184,92,0,1264,1266,3,44,22,0,1265,
  	1264,1,0,0,0,1265,1266,1,0,0,0,1266,1267,1,0,0,0,1267,1268,3,164,82,5,
  	1268,1280,1,0,0,0,1269,1270,3,166,83,0,1270,1272,5,221,0,0,1271,1273,
  	3,44,22,0,1272,1271,1,0,0,0,1272,1273,1,0,0,0,1273,1274,1,0,0,0,1274,
  	1277,5,198,0,0,1275,1278,3,236,118,0,1276,1278,3,182,91,0,1277,1275,1,
  	0,0,0,1277,1276,1,0,0,0,1278,1280,1,0,0,0,1279,1189,1,0,0,0,1279,1192,
  	1,0,0,0,1279,1193,1,0,0,0,1279,1198,1,0,0,0,1279,1203,1,0,0,0,1279,1205,
  	1,0,0,0,1279,1207,1,0,0,0,1279,1209,1,0,0,0,1279,1212,1,0,0,0,1279,1214,
  	1,0,0,0,1279,1215,1,0,0,0,1279,1216,1,0,0,0,1279,1217,1,0,0,0,1279,1218,
  	1,0,0,0,1279,1219,1,0,0,0,1279,1220,1,0,0,0,1279,1221,1,0,0,0,1279,1222,
  	1,0,0,0,1279,1229,1,0,0,0,1279,1234,1,0,0,0,1279,1239,1,0,0,0,1279,1244,
  	1,0,0,0,1279,1250,1,0,0,0,1279,1252,1,0,0,0,1279,1254,1,0,0,0,1279,1255,
  	1,0,0,0,1279,1256,1,0,0,0,1279,1258,1,0,0,0,1279,1262,1,0,0,0,1279,1269,
  	1,0,0,0,1280,1341,1,0,0,0,1281,1282,10,22,0,0,1282,1283,5,176,0,0,1283,
  	1340,3,164,82,22,1284,1285,10,20,0,0,1285,1286,7,9,0,0,1286,1340,3,164,
  	82,21,1287,1288,10,19,0,0,1288,1289,7,10,0,0,1289,1340,3,164,82,20,1290,
  	1291,10,18,0,0,1291,1292,7,11,0,0,1292,1340,3,164,82,19,1293,1294,10,
  	17,0,0,1294,1295,7,12,0,0,1295,1340,3,164,82,18,1296,1297,10,16,0,0,1297,
  	1298,7,13,0,0,1298,1340,3,164,82,17,1299,1300,10,15,0,0,1300,1301,5,198,
  	0,0,1301,1340,3,164,82,16,1302,1303,10,14,0,0,1303,1304,5,201,0,0,1304,
  	1340,3,164,82,15,1305,1306,10,13,0,0,1306,1307,5,199,0,0,1307,1340,3,
  	164,82,14,1308,1309,10,12,0,0,1309,1310,5,187,0,0,1310,1340,3,164,82,
  	13,1311,1312,10,11,0,0,1312,1313,5,186,0,0,1313,1340,3,164,82,12,1314,
  	1315,10,10,0,0,1315,1317,5,211,0,0,1316,1318,3,164,82,0,1317,1316,1,0,
  	0,0,1317,1318,1,0,0,0,1318,1319,1,0,0,0,1319,1320,5,219,0,0,1320,1340,
  	3,164,82,11,1321,1322,10,9,0,0,1322,1323,5,188,0,0,1323,1340,3,164,82,
  	10,1324,1325,10,8,0,0,1325,1326,5,161,0,0,1326,1340,3,164,82,9,1327,1328,
  	10,3,0,0,1328,1329,5,99,0,0,1329,1340,3,164,82,4,1330,1331,10,2,0,0,1331,
  	1332,5,101,0,0,1332,1340,3,164,82,3,1333,1334,10,1,0,0,1334,1335,5,100,
  	0,0,1335,1340,3,164,82,2,1336,1337,10,21,0,0,1337,1338,5,90,0,0,1338,
  	1340,3,198,99,0,1339,1281,1,0,0,0,1339,1284,1,0,0,0,1339,1287,1,0,0,0,
  	1339,1290,1,0,0,0,1339,1293,1,0,0,0,1339,1296,1,0,0,0,1339,1299,1,0,0,
  	0,1339,1302,1,0,0,0,1339,1305,1,0,0,0,1339,1308,1,0,0,0,1339,1311,1,0,
  	0,0,1339,1314,1,0,0,0,1339,1321,1,0,0,0,1339,1324,1,0,0,0,1339,1327,1,
  	0,0,0,1339,1330,1,0,0,0,1339,1333,1,0,0,0,1339,1336,1,0,0,0,1340,1343,
  	1,0,0,0,1341,1339,1,0,0,0,1341,1342,1,0,0,0,1342,165,1,0,0,0,1343,1341,
  	1,0,0,0,1344,1347,3,236,118,0,1345,1347,3,168,84,0,1346,1344,1,0,0,0,
  	1346,1345,1,0,0,0,1347,167,1,0,0,0,1348,1349,5,45,0,0,1349,1351,5,212,
  	0,0,1350,1352,3,188,94,0,1351,1350,1,0,0,0,1351,1352,1,0,0,0,1352,1353,
  	1,0,0,0,1353,1360,5,213,0,0,1354,1356,5,214,0,0,1355,1357,3,188,94,0,
  	1356,1355,1,0,0,0,1356,1357,1,0,0,0,1357,1358,1,0,0,0,1358,1360,5,215,
  	0,0,1359,1348,1,0,0,0,1359,1354,1,0,0,0,1360,1365,1,0,0,0,1361,1362,5,
  	214,0,0,1362,1363,3,164,82,0,1363,1364,5,215,0,0,1364,1366,1,0,0,0,1365,
  	1361,1,0,0,0,1365,1366,1,0,0,0,1366,169,1,0,0,0,1367,1371,5,214,0,0,1368,
  	1370,5,218,0,0,1369,1368,1,0,0,0,1370,1373,1,0,0,0,1371,1369,1,0,0,0,
  	1371,1372,1,0,0,0,1372,1374,1,0,0,0,1373,1371,1,0,0,0,1374,1383,3,172,
  	86,0,1375,1377,5,218,0,0,1376,1375,1,0,0,0,1377,1378,1,0,0,0,1378,1376,
  	1,0,0,0,1378,1379,1,0,0,0,1379,1380,1,0,0,0,1380,1382,3,172,86,0,1381,
  	1376,1,0,0,0,1382,1385,1,0,0,0,1383,1381,1,0,0,0,1383,1384,1,0,0,0,1384,
  	1389,1,0,0,0,1385,1383,1,0,0,0,1386,1388,5,218,0,0,1387,1386,1,0,0,0,
  	1388,1391,1,0,0,0,1389,1387,1,0,0,0,1389,1390,1,0,0,0,1390,1392,1,0,0,
  	0,1391,1389,1,0,0,0,1392,1393,5,215,0,0,1393,1413,1,0,0,0,1394,1395,5,
  	214,0,0,1395,1404,3,174,87,0,1396,1398,5,218,0,0,1397,1396,1,0,0,0,1398,
  	1399,1,0,0,0,1399,1397,1,0,0,0,1399,1400,1,0,0,0,1400,1401,1,0,0,0,1401,
  	1403,3,174,87,0,1402,1397,1,0,0,0,1403,1406,1,0,0,0,1404,1402,1,0,0,0,
  	1404,1405,1,0,0,0,1405,1408,1,0,0,0,1406,1404,1,0,0,0,1407,1409,5,218,
  	0,0,1408,1407,1,0,0,0,1408,1409,1,0,0,0,1409,1410,1,0,0,0,1410,1411,5,
  	215,0,0,1411,1413,1,0,0,0,1412,1367,1,0,0,0,1412,1394,1,0,0,0,1413,171,
  	1,0,0,0,1414,1416,5,198,0,0,1415,1414,1,0,0,0,1415,1416,1,0,0,0,1416,
  	1417,1,0,0,0,1417,1418,3,236,118,0,1418,173,1,0,0,0,1419,1420,3,164,82,
  	0,1420,1421,5,164,0,0,1421,1423,1,0,0,0,1422,1419,1,0,0,0,1422,1423,1,
  	0,0,0,1423,1425,1,0,0,0,1424,1426,5,198,0,0,1425,1424,1,0,0,0,1425,1426,
  	1,0,0,0,1426,1427,1,0,0,0,1427,1428,3,236,118,0,1428,175,1,0,0,0,1429,
  	1431,5,118,0,0,1430,1429,1,0,0,0,1430,1431,1,0,0,0,1431,1432,1,0,0,0,
  	1432,1434,5,82,0,0,1433,1435,5,198,0,0,1434,1433,1,0,0,0,1434,1435,1,
  	0,0,0,1435,1436,1,0,0,0,1436,1437,5,212,0,0,1437,1438,3,114,57,0,1438,
  	1440,5,213,0,0,1439,1441,3,192,96,0,1440,1439,1,0,0,0,1440,1441,1,0,0,
  	0,1441,1444,1,0,0,0,1442,1443,5,219,0,0,1443,1445,3,118,59,0,1444,1442,
  	1,0,0,0,1444,1445,1,0,0,0,1445,1446,1,0,0,0,1446,1447,3,58,29,0,1447,
  	1456,1,0,0,0,1448,1449,5,133,0,0,1449,1450,5,212,0,0,1450,1451,3,114,
  	57,0,1451,1452,5,213,0,0,1452,1453,5,164,0,0,1453,1454,3,164,82,0,1454,
  	1456,1,0,0,0,1455,1430,1,0,0,0,1455,1448,1,0,0,0,1456,177,1,0,0,0,1457,
  	1458,5,102,0,0,1458,1459,5,212,0,0,1459,1460,3,164,82,0,1460,1461,5,213,
  	0,0,1461,1462,5,216,0,0,1462,1467,3,180,90,0,1463,1464,5,218,0,0,1464,
  	1466,3,180,90,0,1465,1463,1,0,0,0,1466,1469,1,0,0,0,1467,1465,1,0,0,0,
  	1467,1468,1,0,0,0,1468,1471,1,0,0,0,1469,1467,1,0,0,0,1470,1472,5,218,
  	0,0,1471,1470,1,0,0,0,1471,1472,1,0,0,0,1472,1473,1,0,0,0,1473,1474,5,
  	217,0,0,1474,179,1,0,0,0,1475,1480,3,164,82,0,1476,1477,5,218,0,0,1477,
  	1479,3,164,82,0,1478,1476,1,0,0,0,1479,1482,1,0,0,0,1480,1478,1,0,0,0,
  	1480,1481,1,0,0,0,1481,1483,1,0,0,0,1482,1480,1,0,0,0,1483,1484,5,164,
  	0,0,1484,1485,3,164,82,0,1485,181,1,0,0,0,1486,1487,5,104,0,0,1487,1489,
  	3,198,99,0,1488,1490,3,212,106,0,1489,1488,1,0,0,0,1489,1490,1,0,0,0,
  	1490,183,1,0,0,0,1491,1492,7,14,0,0,1492,185,1,0,0,0,1493,1501,5,131,
  	0,0,1494,1497,3,164,82,0,1495,1496,5,164,0,0,1496,1498,3,164,82,0,1497,
  	1495,1,0,0,0,1497,1498,1,0,0,0,1498,1502,1,0,0,0,1499,1500,5,132,0,0,
  	1500,1502,3,164,82,0,1501,1494,1,0,0,0,1501,1499,1,0,0,0,1502,187,1,0,
  	0,0,1503,1508,3,190,95,0,1504,1505,5,218,0,0,1505,1507,3,190,95,0,1506,
  	1504,1,0,0,0,1507,1510,1,0,0,0,1508,1506,1,0,0,0,1508,1509,1,0,0,0,1509,
  	1512,1,0,0,0,1510,1508,1,0,0,0,1511,1513,5,218,0,0,1512,1511,1,0,0,0,
  	1512,1513,1,0,0,0,1513,189,1,0,0,0,1514,1517,3,164,82,0,1515,1516,5,164,
  	0,0,1516,1518,3,164,82,0,1517,1515,1,0,0,0,1517,1518,1,0,0,0,1518,1527,
  	1,0,0,0,1519,1520,3,164,82,0,1520,1521,5,164,0,0,1521,1523,1,0,0,0,1522,
  	1519,1,0,0,0,1522,1523,1,0,0,0,1523,1524,1,0,0,0,1524,1525,5,198,0,0,
  	1525,1527,3,236,118,0,1526,1514,1,0,0,0,1526,1522,1,0,0,0,1527,191,1,
  	0,0,0,1528,1529,5,128,0,0,1529,1530,5,212,0,0,1530,1535,3,194,97,0,1531,
  	1532,5,218,0,0,1532,1534,3,194,97,0,1533,1531,1,0,0,0,1534,1537,1,0,0,
  	0,1535,1533,1,0,0,0,1535,1536,1,0,0,0,1536,1538,1,0,0,0,1537,1535,1,0,
  	0,0,1538,1539,5,213,0,0,1539,193,1,0,0,0,1540,1542,5,198,0,0,1541,1540,
  	1,0,0,0,1541,1542,1,0,0,0,1542,1543,1,0,0,0,1543,1544,5,224,0,0,1544,
  	195,1,0,0,0,1545,1547,3,204,102,0,1546,1548,3,42,21,0,1547,1546,1,0,0,
  	0,1547,1548,1,0,0,0,1548,1551,1,0,0,0,1549,1551,5,118,0,0,1550,1545,1,
  	0,0,0,1550,1549,1,0,0,0,1551,197,1,0,0,0,1552,1555,3,204,102,0,1553,1555,
  	3,202,101,0,1554,1552,1,0,0,0,1554,1553,1,0,0,0,1555,1557,1,0,0,0,1556,
  	1558,3,42,21,0,1557,1556,1,0,0,0,1557,1558,1,0,0,0,1558,1563,1,0,0,0,
  	1559,1563,3,272,136,0,1560,1563,5,118,0,0,1561,1563,3,200,100,0,1562,
  	1554,1,0,0,0,1562,1559,1,0,0,0,1562,1560,1,0,0,0,1562,1561,1,0,0,0,1563,
  	199,1,0,0,0,1564,1566,3,44,22,0,1565,1564,1,0,0,0,1565,1566,1,0,0,0,1566,
  	1568,1,0,0,0,1567,1569,5,110,0,0,1568,1567,1,0,0,0,1568,1569,1,0,0,0,
  	1569,1571,1,0,0,0,1570,1572,3,262,131,0,1571,1570,1,0,0,0,1571,1572,1,
  	0,0,0,1572,1574,1,0,0,0,1573,1575,5,108,0,0,1574,1573,1,0,0,0,1574,1575,
  	1,0,0,0,1575,1597,1,0,0,0,1576,1578,3,28,14,0,1577,1579,3,32,16,0,1578,
  	1577,1,0,0,0,1578,1579,1,0,0,0,1579,1582,1,0,0,0,1580,1581,5,76,0,0,1581,
  	1583,3,196,98,0,1582,1580,1,0,0,0,1582,1583,1,0,0,0,1583,1586,1,0,0,0,
  	1584,1585,5,86,0,0,1585,1587,3,30,15,0,1586,1584,1,0,0,0,1586,1587,1,
  	0,0,0,1587,1598,1,0,0,0,1588,1589,5,96,0,0,1589,1591,3,264,132,0,1590,
  	1592,3,32,16,0,1591,1590,1,0,0,0,1591,1592,1,0,0,0,1592,1595,1,0,0,0,
  	1593,1594,5,76,0,0,1594,1596,3,30,15,0,1595,1593,1,0,0,0,1595,1596,1,
  	0,0,0,1596,1598,1,0,0,0,1597,1576,1,0,0,0,1597,1588,1,0,0,0,1598,1599,
  	1,0,0,0,1599,1603,5,216,0,0,1600,1602,3,128,64,0,1601,1600,1,0,0,0,1602,
  	1605,1,0,0,0,1603,1601,1,0,0,0,1603,1604,1,0,0,0,1604,1606,1,0,0,0,1605,
  	1603,1,0,0,0,1606,1607,5,217,0,0,1607,201,1,0,0,0,1608,1613,3,248,124,
  	0,1609,1610,5,193,0,0,1610,1612,3,250,125,0,1611,1609,1,0,0,0,1612,1615,
  	1,0,0,0,1613,1611,1,0,0,0,1613,1614,1,0,0,0,1614,203,1,0,0,0,1615,1613,
  	1,0,0,0,1616,1618,5,103,0,0,1617,1616,1,0,0,0,1617,1618,1,0,0,0,1618,
  	1620,1,0,0,0,1619,1621,5,194,0,0,1620,1619,1,0,0,0,1620,1621,1,0,0,0,
  	1621,1622,1,0,0,0,1622,1623,3,206,103,0,1623,205,1,0,0,0,1624,1638,3,
  	264,132,0,1625,1630,3,264,132,0,1626,1627,5,194,0,0,1627,1629,3,264,132,
  	0,1628,1626,1,0,0,0,1629,1632,1,0,0,0,1630,1628,1,0,0,0,1630,1631,1,0,
  	0,0,1631,1635,1,0,0,0,1632,1630,1,0,0,0,1633,1634,5,194,0,0,1634,1636,
  	3,208,104,0,1635,1633,1,0,0,0,1635,1636,1,0,0,0,1636,1638,1,0,0,0,1637,
  	1624,1,0,0,0,1637,1625,1,0,0,0,1638,207,1,0,0,0,1639,1642,3,264,132,0,
  	1640,1641,5,46,0,0,1641,1643,3,264,132,0,1642,1640,1,0,0,0,1642,1643,
  	1,0,0,0,1643,1659,1,0,0,0,1644,1645,5,216,0,0,1645,1650,3,208,104,0,1646,
  	1647,5,218,0,0,1647,1649,3,208,104,0,1648,1646,1,0,0,0,1649,1652,1,0,
  	0,0,1650,1648,1,0,0,0,1650,1651,1,0,0,0,1651,1654,1,0,0,0,1652,1650,1,
  	0,0,0,1653,1655,5,218,0,0,1654,1653,1,0,0,0,1654,1655,1,0,0,0,1655,1656,
  	1,0,0,0,1656,1657,5,217,0,0,1657,1659,1,0,0,0,1658,1639,1,0,0,0,1658,
  	1644,1,0,0,0,1659,209,1,0,0,0,1660,1665,3,204,102,0,1661,1662,5,218,0,
  	0,1662,1664,3,204,102,0,1663,1661,1,0,0,0,1664,1667,1,0,0,0,1665,1663,
  	1,0,0,0,1665,1666,1,0,0,0,1666,211,1,0,0,0,1667,1665,1,0,0,0,1668,1678,
  	5,212,0,0,1669,1674,3,214,107,0,1670,1671,5,218,0,0,1671,1673,3,214,107,
  	0,1672,1670,1,0,0,0,1673,1676,1,0,0,0,1674,1672,1,0,0,0,1674,1675,1,0,
  	0,0,1675,1679,1,0,0,0,1676,1674,1,0,0,0,1677,1679,3,186,93,0,1678,1669,
  	1,0,0,0,1678,1677,1,0,0,0,1678,1679,1,0,0,0,1679,1681,1,0,0,0,1680,1682,
  	5,218,0,0,1681,1680,1,0,0,0,1681,1682,1,0,0,0,1682,1683,1,0,0,0,1683,
  	1684,5,213,0,0,1684,213,1,0,0,0,1685,1687,3,216,108,0,1686,1685,1,0,0,
  	0,1686,1687,1,0,0,0,1687,1689,1,0,0,0,1688,1690,5,195,0,0,1689,1688,1,
  	0,0,0,1689,1690,1,0,0,0,1690,1691,1,0,0,0,1691,1695,3,164,82,0,1692,1693,
  	5,198,0,0,1693,1695,3,236,118,0,1694,1686,1,0,0,0,1694,1692,1,0,0,0,1695,
  	215,1,0,0,0,1696,1697,3,264,132,0,1697,1698,5,219,0,0,1698,217,1,0,0,
  	0,1699,1735,3,220,110,0,1700,1735,3,230,115,0,1701,1702,5,45,0,0,1702,
  	1707,5,212,0,0,1703,1705,3,188,94,0,1704,1706,5,218,0,0,1705,1704,1,0,
  	0,0,1705,1706,1,0,0,0,1706,1708,1,0,0,0,1707,1703,1,0,0,0,1707,1708,1,
  	0,0,0,1708,1709,1,0,0,0,1709,1735,5,213,0,0,1710,1715,5,214,0,0,1711,
  	1713,3,188,94,0,1712,1714,5,218,0,0,1713,1712,1,0,0,0,1713,1714,1,0,0,
  	0,1714,1716,1,0,0,0,1715,1711,1,0,0,0,1715,1716,1,0,0,0,1716,1717,1,0,
  	0,0,1717,1735,5,215,0,0,1718,1719,7,15,0,0,1719,1735,3,218,109,0,1720,
  	1723,3,230,115,0,1721,1723,3,220,110,0,1722,1720,1,0,0,0,1722,1721,1,
  	0,0,0,1723,1731,1,0,0,0,1724,1727,5,210,0,0,1725,1728,3,230,115,0,1726,
  	1728,3,220,110,0,1727,1725,1,0,0,0,1727,1726,1,0,0,0,1728,1730,1,0,0,
  	0,1729,1724,1,0,0,0,1730,1733,1,0,0,0,1731,1729,1,0,0,0,1731,1732,1,0,
  	0,0,1732,1735,1,0,0,0,1733,1731,1,0,0,0,1734,1699,1,0,0,0,1734,1700,1,
  	0,0,0,1734,1701,1,0,0,0,1734,1710,1,0,0,0,1734,1718,1,0,0,0,1734,1722,
  	1,0,0,0,1735,219,1,0,0,0,1736,1742,5,105,0,0,1737,1742,3,222,111,0,1738,
  	1742,3,268,134,0,1739,1742,3,226,113,0,1740,1742,3,204,102,0,1741,1736,
  	1,0,0,0,1741,1737,1,0,0,0,1741,1738,1,0,0,0,1741,1739,1,0,0,0,1741,1740,
  	1,0,0,0,1742,221,1,0,0,0,1743,1748,5,228,0,0,1744,1748,5,49,0,0,1745,
  	1748,3,224,112,0,1746,1748,3,228,114,0,1747,1743,1,0,0,0,1747,1744,1,
  	0,0,0,1747,1745,1,0,0,0,1747,1746,1,0,0,0,1748,223,1,0,0,0,1749,1750,
  	7,16,0,0,1750,225,1,0,0,0,1751,1752,7,17,0,0,1752,1757,5,192,0,0,1753,
  	1758,3,264,132,0,1754,1758,5,141,0,0,1755,1758,5,137,0,0,1756,1758,5,
  	138,0,0,1757,1753,1,0,0,0,1757,1754,1,0,0,0,1757,1755,1,0,0,0,1757,1756,
  	1,0,0,0,1758,1770,1,0,0,0,1759,1763,3,196,98,0,1760,1763,3,254,127,0,
  	1761,1763,3,230,115,0,1762,1759,1,0,0,0,1762,1760,1,0,0,0,1762,1761,1,
  	0,0,0,1763,1764,1,0,0,0,1764,1767,5,192,0,0,1765,1768,3,264,132,0,1766,
  	1768,3,254,127,0,1767,1765,1,0,0,0,1767,1766,1,0,0,0,1768,1770,1,0,0,
  	0,1769,1751,1,0,0,0,1769,1762,1,0,0,0,1770,227,1,0,0,0,1771,1772,5,225,
  	0,0,1772,229,1,0,0,0,1773,1775,5,235,0,0,1774,1776,5,243,0,0,1775,1774,
  	1,0,0,0,1776,1777,1,0,0,0,1777,1775,1,0,0,0,1777,1778,1,0,0,0,1778,1795,
  	1,0,0,0,1779,1781,5,234,0,0,1780,1782,5,243,0,0,1781,1780,1,0,0,0,1782,
  	1783,1,0,0,0,1783,1781,1,0,0,0,1783,1784,1,0,0,0,1784,1795,1,0,0,0,1785,
  	1795,5,232,0,0,1786,1790,5,233,0,0,1787,1789,3,232,116,0,1788,1787,1,
  	0,0,0,1789,1792,1,0,0,0,1790,1788,1,0,0,0,1790,1791,1,0,0,0,1791,1793,
  	1,0,0,0,1792,1790,1,0,0,0,1793,1795,5,233,0,0,1794,1773,1,0,0,0,1794,
  	1779,1,0,0,0,1794,1785,1,0,0,0,1794,1786,1,0,0,0,1795,231,1,0,0,0,1796,
  	1800,5,239,0,0,1797,1800,5,238,0,0,1798,1800,3,236,118,0,1799,1796,1,
  	0,0,0,1799,1797,1,0,0,0,1799,1798,1,0,0,0,1800,233,1,0,0,0,1801,1806,
  	3,236,118,0,1802,1803,5,218,0,0,1803,1805,3,236,118,0,1804,1802,1,0,0,
  	0,1805,1808,1,0,0,0,1806,1804,1,0,0,0,1806,1807,1,0,0,0,1807,235,1,0,
  	0,0,1808,1806,1,0,0,0,1809,1813,3,238,119,0,1810,1812,3,240,120,0,1811,
  	1810,1,0,0,0,1812,1815,1,0,0,0,1813,1811,1,0,0,0,1813,1814,1,0,0,0,1814,
  	237,1,0,0,0,1815,1813,1,0,0,0,1816,1823,3,248,124,0,1817,1823,3,242,121,
  	0,1818,1819,5,212,0,0,1819,1820,3,182,91,0,1820,1821,5,213,0,0,1821,1823,
  	1,0,0,0,1822,1816,1,0,0,0,1822,1817,1,0,0,0,1822,1818,1,0,0,0,1823,239,
  	1,0,0,0,1824,1825,5,193,0,0,1825,1827,3,250,125,0,1826,1828,3,246,123,
  	0,1827,1826,1,0,0,0,1827,1828,1,0,0,0,1828,241,1,0,0,0,1829,1830,3,244,
  	122,0,1830,1831,3,246,123,0,1831,243,1,0,0,0,1832,1837,3,204,102,0,1833,
  	1837,3,226,113,0,1834,1837,3,248,124,0,1835,1837,3,162,81,0,1836,1832,
  	1,0,0,0,1836,1833,1,0,0,0,1836,1834,1,0,0,0,1836,1835,1,0,0,0,1837,245,
  	1,0,0,0,1838,1840,3,42,21,0,1839,1838,1,0,0,0,1839,1840,1,0,0,0,1840,
  	1842,1,0,0,0,1841,1843,3,212,106,0,1842,1841,1,0,0,0,1843,1844,1,0,0,
  	0,1844,1842,1,0,0,0,1844,1845,1,0,0,0,1845,1849,1,0,0,0,1846,1848,3,256,
  	128,0,1847,1846,1,0,0,0,1848,1851,1,0,0,0,1849,1847,1,0,0,0,1849,1850,
  	1,0,0,0,1850,247,1,0,0,0,1851,1849,1,0,0,0,1852,1855,3,254,127,0,1853,
  	1854,5,192,0,0,1854,1856,3,254,127,0,1855,1853,1,0,0,0,1855,1856,1,0,
  	0,0,1856,1862,1,0,0,0,1857,1858,3,196,98,0,1858,1859,5,192,0,0,1859,1860,
  	3,254,127,0,1860,1862,1,0,0,0,1861,1852,1,0,0,0,1861,1857,1,0,0,0,1862,
  	249,1,0,0,0,1863,1866,3,252,126,0,1864,1866,3,254,127,0,1865,1863,1,0,
  	0,0,1865,1864,1,0,0,0,1866,251,1,0,0,0,1867,1873,3,264,132,0,1868,1869,
  	5,216,0,0,1869,1870,3,164,82,0,1870,1871,5,217,0,0,1871,1873,1,0,0,0,
  	1872,1867,1,0,0,0,1872,1868,1,0,0,0,1873,1877,1,0,0,0,1874,1876,3,256,
  	128,0,1875,1874,1,0,0,0,1876,1879,1,0,0,0,1877,1875,1,0,0,0,1877,1878,
  	1,0,0,0,1878,253,1,0,0,0,1879,1877,1,0,0,0,1880,1882,5,209,0,0,1881,1880,
  	1,0,0,0,1882,1885,1,0,0,0,1883,1881,1,0,0,0,1883,1884,1,0,0,0,1884,1892,
  	1,0,0,0,1885,1883,1,0,0,0,1886,1893,5,224,0,0,1887,1888,5,209,0,0,1888,
  	1889,5,216,0,0,1889,1890,3,164,82,0,1890,1891,5,217,0,0,1891,1893,1,0,
  	0,0,1892,1886,1,0,0,0,1892,1887,1,0,0,0,1893,1897,1,0,0,0,1894,1896,3,
  	256,128,0,1895,1894,1,0,0,0,1896,1899,1,0,0,0,1897,1895,1,0,0,0,1897,
  	1898,1,0,0,0,1898,255,1,0,0,0,1899,1897,1,0,0,0,1900,1902,5,214,0,0,1901,
  	1903,3,164,82,0,1902,1901,1,0,0,0,1902,1903,1,0,0,0,1903,1904,1,0,0,0,
  	1904,1910,5,215,0,0,1905,1906,5,216,0,0,1906,1907,3,164,82,0,1907,1908,
  	5,217,0,0,1908,1910,1,0,0,0,1909,1900,1,0,0,0,1909,1905,1,0,0,0,1910,
  	257,1,0,0,0,1911,1913,3,260,130,0,1912,1911,1,0,0,0,1912,1913,1,0,0,0,
  	1913,1920,1,0,0,0,1914,1916,5,218,0,0,1915,1917,3,260,130,0,1916,1915,
  	1,0,0,0,1916,1917,1,0,0,0,1917,1919,1,0,0,0,1918,1914,1,0,0,0,1919,1922,
  	1,0,0,0,1920,1918,1,0,0,0,1920,1921,1,0,0,0,1921,259,1,0,0,0,1922,1920,
  	1,0,0,0,1923,1931,3,236,118,0,1924,1925,5,98,0,0,1925,1926,5,212,0,0,
  	1926,1927,3,258,129,0,1927,1928,5,213,0,0,1928,1931,1,0,0,0,1929,1931,
  	3,190,95,0,1930,1923,1,0,0,0,1930,1924,1,0,0,0,1930,1929,1,0,0,0,1931,
  	261,1,0,0,0,1932,1933,7,18,0,0,1933,263,1,0,0,0,1934,1935,7,19,0,0,1935,
  	265,1,0,0,0,1936,1937,7,20,0,0,1937,267,1,0,0,0,1938,1939,7,21,0,0,1939,
  	269,1,0,0,0,1940,1941,7,22,0,0,1941,271,1,0,0,0,1942,1943,7,23,0,0,1943,
  	273,1,0,0,0,1944,1945,7,24,0,0,1945,275,1,0,0,0,252,277,281,283,291,294,
  	320,324,329,334,340,354,358,364,369,374,381,387,394,401,404,408,412,419,
  	422,427,430,433,436,441,445,449,454,458,460,466,478,495,502,510,514,519,
  	525,533,541,547,554,561,566,572,601,615,619,628,632,637,663,674,678,682,
  	691,701,706,712,717,722,727,732,738,744,750,774,779,782,792,795,808,816,
  	823,826,831,835,844,848,874,879,886,893,901,904,910,914,917,922,926,929,
  	932,935,943,950,959,972,984,990,994,1001,1007,1011,1018,1025,1029,1036,
  	1040,1042,1048,1055,1059,1063,1076,1079,1086,1093,1097,1103,1107,1112,
  	1117,1124,1132,1141,1145,1151,1160,1165,1172,1179,1185,1248,1265,1272,
  	1277,1279,1317,1339,1341,1346,1351,1356,1359,1365,1371,1378,1383,1389,
  	1399,1404,1408,1412,1415,1422,1425,1430,1434,1440,1444,1455,1467,1471,
  	1480,1489,1497,1501,1508,1512,1517,1522,1526,1535,1541,1547,1550,1554,
  	1557,1562,1565,1568,1571,1574,1578,1582,1586,1591,1595,1597,1603,1613,
  	1617,1620,1630,1635,1637,1642,1650,1654,1658,1665,1674,1678,1681,1686,
  	1689,1694,1705,1707,1713,1715,1722,1727,1731,1734,1741,1747,1757,1762,
  	1767,1769,1777,1783,1790,1794,1799,1806,1813,1822,1827,1836,1839,1844,
  	1849,1855,1861,1865,1872,1877,1883,1892,1897,1902,1909,1912,1916,1920,
  	1930
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  phpparserParserStaticData = staticData.release();
}

}

PhpParser::PhpParser(TokenStream *input) : PhpParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

PhpParser::PhpParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  PhpParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *phpparserParserStaticData->atn, phpparserParserStaticData->decisionToDFA, phpparserParserStaticData->sharedContextCache, options);
}

PhpParser::~PhpParser() {
  delete _interpreter;
}

const atn::ATN& PhpParser::getATN() const {
  return *phpparserParserStaticData->atn;
}

std::string PhpParser::getGrammarFileName() const {
  return "PhpParser.g4";
}

const std::vector<std::string>& PhpParser::getRuleNames() const {
  return phpparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& PhpParser::getVocabulary() const {
  return phpparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView PhpParser::getSerializedATN() const {
  return phpparserParserStaticData->serializedATN;
}


//----------------- HtmlDocumentContext ------------------------------------------------------------------

PhpParser::HtmlDocumentContext::HtmlDocumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::HtmlDocumentContext::EOF() {
  return getToken(PhpParser::EOF, 0);
}

tree::TerminalNode* PhpParser::HtmlDocumentContext::Shebang() {
  return getToken(PhpParser::Shebang, 0);
}

std::vector<PhpParser::InlineHtmlContext *> PhpParser::HtmlDocumentContext::inlineHtml() {
  return getRuleContexts<PhpParser::InlineHtmlContext>();
}

PhpParser::InlineHtmlContext* PhpParser::HtmlDocumentContext::inlineHtml(size_t i) {
  return getRuleContext<PhpParser::InlineHtmlContext>(i);
}

std::vector<PhpParser::PhpBlockContext *> PhpParser::HtmlDocumentContext::phpBlock() {
  return getRuleContexts<PhpParser::PhpBlockContext>();
}

PhpParser::PhpBlockContext* PhpParser::HtmlDocumentContext::phpBlock(size_t i) {
  return getRuleContext<PhpParser::PhpBlockContext>(i);
}


size_t PhpParser::HtmlDocumentContext::getRuleIndex() const {
  return PhpParser::RuleHtmlDocument;
}

void PhpParser::HtmlDocumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHtmlDocument(this);
}

void PhpParser::HtmlDocumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHtmlDocument(this);
}

PhpParser::HtmlDocumentContext* PhpParser::htmlDocument() {
  HtmlDocumentContext *_localctx = _tracker.createInstance<HtmlDocumentContext>(_ctx, getState());
  enterRule(_localctx, 0, PhpParser::RuleHtmlDocument);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(277);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Shebang) {
      setState(276);
      match(PhpParser::Shebang);
    }
    setState(283);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -8600244223124) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -1) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 420906795007) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 194)) & 4397045441345) != 0)) {
      setState(281);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx)) {
      case 1: {
        setState(279);
        inlineHtml();
        break;
      }

      case 2: {
        setState(280);
        phpBlock();
        break;
      }

      default:
        break;
      }
      setState(285);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(286);
    match(PhpParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InlineHtmlContext ------------------------------------------------------------------

PhpParser::InlineHtmlContext::InlineHtmlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::HtmlElementContext *> PhpParser::InlineHtmlContext::htmlElement() {
  return getRuleContexts<PhpParser::HtmlElementContext>();
}

PhpParser::HtmlElementContext* PhpParser::InlineHtmlContext::htmlElement(size_t i) {
  return getRuleContext<PhpParser::HtmlElementContext>(i);
}

PhpParser::ScriptTextContext* PhpParser::InlineHtmlContext::scriptText() {
  return getRuleContext<PhpParser::ScriptTextContext>(0);
}


size_t PhpParser::InlineHtmlContext::getRuleIndex() const {
  return PhpParser::RuleInlineHtml;
}

void PhpParser::InlineHtmlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInlineHtml(this);
}

void PhpParser::InlineHtmlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInlineHtml(this);
}

PhpParser::InlineHtmlContext* PhpParser::inlineHtml() {
  InlineHtmlContext *_localctx = _tracker.createInstance<InlineHtmlContext>(_ctx, getState());
  enterRule(_localctx, 2, PhpParser::RuleInlineHtml);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(294);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::HtmlText:
      case PhpParser::XmlStart:
      case PhpParser::HtmlScriptOpen:
      case PhpParser::HtmlStyleOpen:
      case PhpParser::HtmlDtd:
      case PhpParser::HtmlOpen:
      case PhpParser::HtmlClose:
      case PhpParser::HtmlSlashClose:
      case PhpParser::HtmlSlash:
      case PhpParser::HtmlEquals:
      case PhpParser::HtmlStartQuoteString:
      case PhpParser::HtmlStartDoubleQuoteString:
      case PhpParser::HtmlHex:
      case PhpParser::HtmlDecimal:
      case PhpParser::HtmlName:
      case PhpParser::HtmlEndQuoteString:
      case PhpParser::HtmlQuoteString:
      case PhpParser::HtmlEndDoubleQuoteString:
      case PhpParser::HtmlDoubleQuoteString:
      case PhpParser::HtmlScriptClose:
      case PhpParser::StyleBody: {
        enterOuterAlt(_localctx, 1);
        setState(289); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(288);
                  htmlElement();
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(291); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

      case PhpParser::ScriptText: {
        enterOuterAlt(_localctx, 2);
        setState(293);
        scriptText();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HtmlElementContext ------------------------------------------------------------------

PhpParser::HtmlElementContext::HtmlElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::HtmlElementContext::HtmlDtd() {
  return getToken(PhpParser::HtmlDtd, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::HtmlClose() {
  return getToken(PhpParser::HtmlClose, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::HtmlStyleOpen() {
  return getToken(PhpParser::HtmlStyleOpen, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::HtmlOpen() {
  return getToken(PhpParser::HtmlOpen, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::HtmlName() {
  return getToken(PhpParser::HtmlName, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::HtmlSlashClose() {
  return getToken(PhpParser::HtmlSlashClose, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::HtmlSlash() {
  return getToken(PhpParser::HtmlSlash, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::HtmlText() {
  return getToken(PhpParser::HtmlText, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::HtmlEquals() {
  return getToken(PhpParser::HtmlEquals, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::HtmlStartQuoteString() {
  return getToken(PhpParser::HtmlStartQuoteString, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::HtmlEndQuoteString() {
  return getToken(PhpParser::HtmlEndQuoteString, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::HtmlStartDoubleQuoteString() {
  return getToken(PhpParser::HtmlStartDoubleQuoteString, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::HtmlEndDoubleQuoteString() {
  return getToken(PhpParser::HtmlEndDoubleQuoteString, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::HtmlHex() {
  return getToken(PhpParser::HtmlHex, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::HtmlDecimal() {
  return getToken(PhpParser::HtmlDecimal, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::HtmlQuoteString() {
  return getToken(PhpParser::HtmlQuoteString, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::HtmlDoubleQuoteString() {
  return getToken(PhpParser::HtmlDoubleQuoteString, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::StyleBody() {
  return getToken(PhpParser::StyleBody, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::HtmlScriptOpen() {
  return getToken(PhpParser::HtmlScriptOpen, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::HtmlScriptClose() {
  return getToken(PhpParser::HtmlScriptClose, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::XmlStart() {
  return getToken(PhpParser::XmlStart, 0);
}

tree::TerminalNode* PhpParser::HtmlElementContext::XmlClose() {
  return getToken(PhpParser::XmlClose, 0);
}

std::vector<tree::TerminalNode *> PhpParser::HtmlElementContext::XmlText() {
  return getTokens(PhpParser::XmlText);
}

tree::TerminalNode* PhpParser::HtmlElementContext::XmlText(size_t i) {
  return getToken(PhpParser::XmlText, i);
}


size_t PhpParser::HtmlElementContext::getRuleIndex() const {
  return PhpParser::RuleHtmlElement;
}

void PhpParser::HtmlElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHtmlElement(this);
}

void PhpParser::HtmlElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHtmlElement(this);
}

PhpParser::HtmlElementContext* PhpParser::htmlElement() {
  HtmlElementContext *_localctx = _tracker.createInstance<HtmlElementContext>(_ctx, getState());
  enterRule(_localctx, 4, PhpParser::RuleHtmlElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(324);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::HtmlDtd: {
        enterOuterAlt(_localctx, 1);
        setState(296);
        match(PhpParser::HtmlDtd);
        break;
      }

      case PhpParser::HtmlClose: {
        enterOuterAlt(_localctx, 2);
        setState(297);
        match(PhpParser::HtmlClose);
        break;
      }

      case PhpParser::HtmlStyleOpen: {
        enterOuterAlt(_localctx, 3);
        setState(298);
        match(PhpParser::HtmlStyleOpen);
        break;
      }

      case PhpParser::HtmlOpen: {
        enterOuterAlt(_localctx, 4);
        setState(299);
        match(PhpParser::HtmlOpen);
        break;
      }

      case PhpParser::HtmlName: {
        enterOuterAlt(_localctx, 5);
        setState(300);
        match(PhpParser::HtmlName);
        break;
      }

      case PhpParser::HtmlSlashClose: {
        enterOuterAlt(_localctx, 6);
        setState(301);
        match(PhpParser::HtmlSlashClose);
        break;
      }

      case PhpParser::HtmlSlash: {
        enterOuterAlt(_localctx, 7);
        setState(302);
        match(PhpParser::HtmlSlash);
        break;
      }

      case PhpParser::HtmlText: {
        enterOuterAlt(_localctx, 8);
        setState(303);
        match(PhpParser::HtmlText);
        break;
      }

      case PhpParser::HtmlEquals: {
        enterOuterAlt(_localctx, 9);
        setState(304);
        match(PhpParser::HtmlEquals);
        break;
      }

      case PhpParser::HtmlStartQuoteString: {
        enterOuterAlt(_localctx, 10);
        setState(305);
        match(PhpParser::HtmlStartQuoteString);
        break;
      }

      case PhpParser::HtmlEndQuoteString: {
        enterOuterAlt(_localctx, 11);
        setState(306);
        match(PhpParser::HtmlEndQuoteString);
        break;
      }

      case PhpParser::HtmlStartDoubleQuoteString: {
        enterOuterAlt(_localctx, 12);
        setState(307);
        match(PhpParser::HtmlStartDoubleQuoteString);
        break;
      }

      case PhpParser::HtmlEndDoubleQuoteString: {
        enterOuterAlt(_localctx, 13);
        setState(308);
        match(PhpParser::HtmlEndDoubleQuoteString);
        break;
      }

      case PhpParser::HtmlHex: {
        enterOuterAlt(_localctx, 14);
        setState(309);
        match(PhpParser::HtmlHex);
        break;
      }

      case PhpParser::HtmlDecimal: {
        enterOuterAlt(_localctx, 15);
        setState(310);
        match(PhpParser::HtmlDecimal);
        break;
      }

      case PhpParser::HtmlQuoteString: {
        enterOuterAlt(_localctx, 16);
        setState(311);
        match(PhpParser::HtmlQuoteString);
        break;
      }

      case PhpParser::HtmlDoubleQuoteString: {
        enterOuterAlt(_localctx, 17);
        setState(312);
        match(PhpParser::HtmlDoubleQuoteString);
        break;
      }

      case PhpParser::StyleBody: {
        enterOuterAlt(_localctx, 18);
        setState(313);
        match(PhpParser::StyleBody);
        break;
      }

      case PhpParser::HtmlScriptOpen: {
        enterOuterAlt(_localctx, 19);
        setState(314);
        match(PhpParser::HtmlScriptOpen);
        break;
      }

      case PhpParser::HtmlScriptClose: {
        enterOuterAlt(_localctx, 20);
        setState(315);
        match(PhpParser::HtmlScriptClose);
        break;
      }

      case PhpParser::XmlStart: {
        enterOuterAlt(_localctx, 21);
        setState(316);
        match(PhpParser::XmlStart);
        setState(320);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == PhpParser::XmlText) {
          setState(317);
          match(PhpParser::XmlText);
          setState(322);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(323);
        match(PhpParser::XmlClose);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScriptTextContext ------------------------------------------------------------------

PhpParser::ScriptTextContext::ScriptTextContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> PhpParser::ScriptTextContext::ScriptText() {
  return getTokens(PhpParser::ScriptText);
}

tree::TerminalNode* PhpParser::ScriptTextContext::ScriptText(size_t i) {
  return getToken(PhpParser::ScriptText, i);
}


size_t PhpParser::ScriptTextContext::getRuleIndex() const {
  return PhpParser::RuleScriptText;
}

void PhpParser::ScriptTextContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScriptText(this);
}

void PhpParser::ScriptTextContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScriptText(this);
}

PhpParser::ScriptTextContext* PhpParser::scriptText() {
  ScriptTextContext *_localctx = _tracker.createInstance<ScriptTextContext>(_ctx, getState());
  enterRule(_localctx, 6, PhpParser::RuleScriptText);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(327); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(326);
              match(PhpParser::ScriptText);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(329); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PhpBlockContext ------------------------------------------------------------------

PhpParser::PhpBlockContext::PhpBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::ImportStatementContext *> PhpParser::PhpBlockContext::importStatement() {
  return getRuleContexts<PhpParser::ImportStatementContext>();
}

PhpParser::ImportStatementContext* PhpParser::PhpBlockContext::importStatement(size_t i) {
  return getRuleContext<PhpParser::ImportStatementContext>(i);
}

std::vector<PhpParser::TopStatementContext *> PhpParser::PhpBlockContext::topStatement() {
  return getRuleContexts<PhpParser::TopStatementContext>();
}

PhpParser::TopStatementContext* PhpParser::PhpBlockContext::topStatement(size_t i) {
  return getRuleContext<PhpParser::TopStatementContext>(i);
}


size_t PhpParser::PhpBlockContext::getRuleIndex() const {
  return PhpParser::RulePhpBlock;
}

void PhpParser::PhpBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPhpBlock(this);
}

void PhpParser::PhpBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPhpBlock(this);
}

PhpParser::PhpBlockContext* PhpParser::phpBlock() {
  PhpBlockContext *_localctx = _tracker.createInstance<PhpBlockContext>(_ctx, getState());
  enterRule(_localctx, 8, PhpParser::RulePhpBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(334);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(331);
        importStatement(); 
      }
      setState(336);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx);
    }
    setState(338); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(337);
              topStatement();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(340); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportStatementContext ------------------------------------------------------------------

PhpParser::ImportStatementContext::ImportStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::ImportStatementContext::Import() {
  return getToken(PhpParser::Import, 0);
}

tree::TerminalNode* PhpParser::ImportStatementContext::Namespace() {
  return getToken(PhpParser::Namespace, 0);
}

PhpParser::NamespaceNameListContext* PhpParser::ImportStatementContext::namespaceNameList() {
  return getRuleContext<PhpParser::NamespaceNameListContext>(0);
}

tree::TerminalNode* PhpParser::ImportStatementContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}


size_t PhpParser::ImportStatementContext::getRuleIndex() const {
  return PhpParser::RuleImportStatement;
}

void PhpParser::ImportStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportStatement(this);
}

void PhpParser::ImportStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportStatement(this);
}

PhpParser::ImportStatementContext* PhpParser::importStatement() {
  ImportStatementContext *_localctx = _tracker.createInstance<ImportStatementContext>(_ctx, getState());
  enterRule(_localctx, 10, PhpParser::RuleImportStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(342);
    match(PhpParser::Import);
    setState(343);
    match(PhpParser::Namespace);
    setState(344);
    namespaceNameList();
    setState(345);
    match(PhpParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TopStatementContext ------------------------------------------------------------------

PhpParser::TopStatementContext::TopStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::StatementContext* PhpParser::TopStatementContext::statement() {
  return getRuleContext<PhpParser::StatementContext>(0);
}

PhpParser::UseDeclarationContext* PhpParser::TopStatementContext::useDeclaration() {
  return getRuleContext<PhpParser::UseDeclarationContext>(0);
}

PhpParser::NamespaceDeclarationContext* PhpParser::TopStatementContext::namespaceDeclaration() {
  return getRuleContext<PhpParser::NamespaceDeclarationContext>(0);
}

PhpParser::FunctionDeclarationContext* PhpParser::TopStatementContext::functionDeclaration() {
  return getRuleContext<PhpParser::FunctionDeclarationContext>(0);
}

PhpParser::ClassDeclarationContext* PhpParser::TopStatementContext::classDeclaration() {
  return getRuleContext<PhpParser::ClassDeclarationContext>(0);
}

PhpParser::GlobalConstantDeclarationContext* PhpParser::TopStatementContext::globalConstantDeclaration() {
  return getRuleContext<PhpParser::GlobalConstantDeclarationContext>(0);
}

PhpParser::EnumDeclarationContext* PhpParser::TopStatementContext::enumDeclaration() {
  return getRuleContext<PhpParser::EnumDeclarationContext>(0);
}


size_t PhpParser::TopStatementContext::getRuleIndex() const {
  return PhpParser::RuleTopStatement;
}

void PhpParser::TopStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTopStatement(this);
}

void PhpParser::TopStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTopStatement(this);
}

PhpParser::TopStatementContext* PhpParser::topStatement() {
  TopStatementContext *_localctx = _tracker.createInstance<TopStatementContext>(_ctx, getState());
  enterRule(_localctx, 12, PhpParser::RuleTopStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(354);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(347);
      statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(348);
      useDeclaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(349);
      namespaceDeclaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(350);
      functionDeclaration();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(351);
      classDeclaration();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(352);
      globalConstantDeclaration();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(353);
      enumDeclaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UseDeclarationContext ------------------------------------------------------------------

PhpParser::UseDeclarationContext::UseDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::UseDeclarationContext::Use() {
  return getToken(PhpParser::Use, 0);
}

PhpParser::UseDeclarationContentListContext* PhpParser::UseDeclarationContext::useDeclarationContentList() {
  return getRuleContext<PhpParser::UseDeclarationContentListContext>(0);
}

tree::TerminalNode* PhpParser::UseDeclarationContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}

tree::TerminalNode* PhpParser::UseDeclarationContext::Function_() {
  return getToken(PhpParser::Function_, 0);
}

tree::TerminalNode* PhpParser::UseDeclarationContext::Const() {
  return getToken(PhpParser::Const, 0);
}


size_t PhpParser::UseDeclarationContext::getRuleIndex() const {
  return PhpParser::RuleUseDeclaration;
}

void PhpParser::UseDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUseDeclaration(this);
}

void PhpParser::UseDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUseDeclaration(this);
}

PhpParser::UseDeclarationContext* PhpParser::useDeclaration() {
  UseDeclarationContext *_localctx = _tracker.createInstance<UseDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 14, PhpParser::RuleUseDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(356);
    match(PhpParser::Use);
    setState(358);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx)) {
    case 1: {
      setState(357);
      _la = _input->LA(1);
      if (!(_la == PhpParser::Const

      || _la == PhpParser::Function_)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(360);
    useDeclarationContentList();
    setState(361);
    match(PhpParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UseDeclarationContentListContext ------------------------------------------------------------------

PhpParser::UseDeclarationContentListContext::UseDeclarationContentListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::UseDeclarationContentContext *> PhpParser::UseDeclarationContentListContext::useDeclarationContent() {
  return getRuleContexts<PhpParser::UseDeclarationContentContext>();
}

PhpParser::UseDeclarationContentContext* PhpParser::UseDeclarationContentListContext::useDeclarationContent(size_t i) {
  return getRuleContext<PhpParser::UseDeclarationContentContext>(i);
}

std::vector<tree::TerminalNode *> PhpParser::UseDeclarationContentListContext::NamespaceSeparator() {
  return getTokens(PhpParser::NamespaceSeparator);
}

tree::TerminalNode* PhpParser::UseDeclarationContentListContext::NamespaceSeparator(size_t i) {
  return getToken(PhpParser::NamespaceSeparator, i);
}

std::vector<tree::TerminalNode *> PhpParser::UseDeclarationContentListContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::UseDeclarationContentListContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::UseDeclarationContentListContext::getRuleIndex() const {
  return PhpParser::RuleUseDeclarationContentList;
}

void PhpParser::UseDeclarationContentListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUseDeclarationContentList(this);
}

void PhpParser::UseDeclarationContentListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUseDeclarationContentList(this);
}

PhpParser::UseDeclarationContentListContext* PhpParser::useDeclarationContentList() {
  UseDeclarationContentListContext *_localctx = _tracker.createInstance<UseDeclarationContentListContext>(_ctx, getState());
  enterRule(_localctx, 16, PhpParser::RuleUseDeclarationContentList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(364);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::NamespaceSeparator) {
      setState(363);
      match(PhpParser::NamespaceSeparator);
    }
    setState(366);
    useDeclarationContent();
    setState(374);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PhpParser::Comma) {
      setState(367);
      match(PhpParser::Comma);
      setState(369);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PhpParser::NamespaceSeparator) {
        setState(368);
        match(PhpParser::NamespaceSeparator);
      }
      setState(371);
      useDeclarationContent();
      setState(376);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UseDeclarationContentContext ------------------------------------------------------------------

PhpParser::UseDeclarationContentContext::UseDeclarationContentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::NamespaceNameListContext* PhpParser::UseDeclarationContentContext::namespaceNameList() {
  return getRuleContext<PhpParser::NamespaceNameListContext>(0);
}


size_t PhpParser::UseDeclarationContentContext::getRuleIndex() const {
  return PhpParser::RuleUseDeclarationContent;
}

void PhpParser::UseDeclarationContentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUseDeclarationContent(this);
}

void PhpParser::UseDeclarationContentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUseDeclarationContent(this);
}

PhpParser::UseDeclarationContentContext* PhpParser::useDeclarationContent() {
  UseDeclarationContentContext *_localctx = _tracker.createInstance<UseDeclarationContentContext>(_ctx, getState());
  enterRule(_localctx, 18, PhpParser::RuleUseDeclarationContent);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(377);
    namespaceNameList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamespaceDeclarationContext ------------------------------------------------------------------

PhpParser::NamespaceDeclarationContext::NamespaceDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::NamespaceDeclarationContext::Namespace() {
  return getToken(PhpParser::Namespace, 0);
}

tree::TerminalNode* PhpParser::NamespaceDeclarationContext::OpenCurlyBracket() {
  return getToken(PhpParser::OpenCurlyBracket, 0);
}

tree::TerminalNode* PhpParser::NamespaceDeclarationContext::CloseCurlyBracket() {
  return getToken(PhpParser::CloseCurlyBracket, 0);
}

PhpParser::NamespaceNameListContext* PhpParser::NamespaceDeclarationContext::namespaceNameList() {
  return getRuleContext<PhpParser::NamespaceNameListContext>(0);
}

tree::TerminalNode* PhpParser::NamespaceDeclarationContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}

std::vector<PhpParser::NamespaceStatementContext *> PhpParser::NamespaceDeclarationContext::namespaceStatement() {
  return getRuleContexts<PhpParser::NamespaceStatementContext>();
}

PhpParser::NamespaceStatementContext* PhpParser::NamespaceDeclarationContext::namespaceStatement(size_t i) {
  return getRuleContext<PhpParser::NamespaceStatementContext>(i);
}


size_t PhpParser::NamespaceDeclarationContext::getRuleIndex() const {
  return PhpParser::RuleNamespaceDeclaration;
}

void PhpParser::NamespaceDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamespaceDeclaration(this);
}

void PhpParser::NamespaceDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamespaceDeclaration(this);
}

PhpParser::NamespaceDeclarationContext* PhpParser::namespaceDeclaration() {
  NamespaceDeclarationContext *_localctx = _tracker.createInstance<NamespaceDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 20, PhpParser::RuleNamespaceDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(379);
    match(PhpParser::Namespace);
    setState(394);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx)) {
    case 1: {
      setState(381);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 44) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 44)) & -1) != 0) || ((((_la - 108) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 108)) & 9007199254740991) != 0) || _la == PhpParser::Label) {
        setState(380);
        namespaceNameList();
      }
      setState(383);
      match(PhpParser::OpenCurlyBracket);
      setState(387);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -8600244223124) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & -1) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & 420906795007) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 194)) & 4397045441345) != 0)) {
        setState(384);
        namespaceStatement();
        setState(389);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(390);
      match(PhpParser::CloseCurlyBracket);
      break;
    }

    case 2: {
      setState(391);
      namespaceNameList();
      setState(392);
      match(PhpParser::SemiColon);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamespaceStatementContext ------------------------------------------------------------------

PhpParser::NamespaceStatementContext::NamespaceStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::StatementContext* PhpParser::NamespaceStatementContext::statement() {
  return getRuleContext<PhpParser::StatementContext>(0);
}

PhpParser::UseDeclarationContext* PhpParser::NamespaceStatementContext::useDeclaration() {
  return getRuleContext<PhpParser::UseDeclarationContext>(0);
}

PhpParser::FunctionDeclarationContext* PhpParser::NamespaceStatementContext::functionDeclaration() {
  return getRuleContext<PhpParser::FunctionDeclarationContext>(0);
}

PhpParser::ClassDeclarationContext* PhpParser::NamespaceStatementContext::classDeclaration() {
  return getRuleContext<PhpParser::ClassDeclarationContext>(0);
}

PhpParser::GlobalConstantDeclarationContext* PhpParser::NamespaceStatementContext::globalConstantDeclaration() {
  return getRuleContext<PhpParser::GlobalConstantDeclarationContext>(0);
}


size_t PhpParser::NamespaceStatementContext::getRuleIndex() const {
  return PhpParser::RuleNamespaceStatement;
}

void PhpParser::NamespaceStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamespaceStatement(this);
}

void PhpParser::NamespaceStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamespaceStatement(this);
}

PhpParser::NamespaceStatementContext* PhpParser::namespaceStatement() {
  NamespaceStatementContext *_localctx = _tracker.createInstance<NamespaceStatementContext>(_ctx, getState());
  enterRule(_localctx, 22, PhpParser::RuleNamespaceStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(401);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(396);
      statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(397);
      useDeclaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(398);
      functionDeclaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(399);
      classDeclaration();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(400);
      globalConstantDeclaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDeclarationContext ------------------------------------------------------------------

PhpParser::FunctionDeclarationContext::FunctionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::FunctionDeclarationContext::Function_() {
  return getToken(PhpParser::Function_, 0);
}

PhpParser::IdentifierContext* PhpParser::FunctionDeclarationContext::identifier() {
  return getRuleContext<PhpParser::IdentifierContext>(0);
}

tree::TerminalNode* PhpParser::FunctionDeclarationContext::OpenRoundBracket() {
  return getToken(PhpParser::OpenRoundBracket, 0);
}

PhpParser::FormalParameterListContext* PhpParser::FunctionDeclarationContext::formalParameterList() {
  return getRuleContext<PhpParser::FormalParameterListContext>(0);
}

tree::TerminalNode* PhpParser::FunctionDeclarationContext::CloseRoundBracket() {
  return getToken(PhpParser::CloseRoundBracket, 0);
}

PhpParser::BlockStatementContext* PhpParser::FunctionDeclarationContext::blockStatement() {
  return getRuleContext<PhpParser::BlockStatementContext>(0);
}

PhpParser::AttributesContext* PhpParser::FunctionDeclarationContext::attributes() {
  return getRuleContext<PhpParser::AttributesContext>(0);
}

tree::TerminalNode* PhpParser::FunctionDeclarationContext::Ampersand() {
  return getToken(PhpParser::Ampersand, 0);
}

PhpParser::TypeParameterListInBracketsContext* PhpParser::FunctionDeclarationContext::typeParameterListInBrackets() {
  return getRuleContext<PhpParser::TypeParameterListInBracketsContext>(0);
}

tree::TerminalNode* PhpParser::FunctionDeclarationContext::Colon() {
  return getToken(PhpParser::Colon, 0);
}

PhpParser::TypeHintContext* PhpParser::FunctionDeclarationContext::typeHint() {
  return getRuleContext<PhpParser::TypeHintContext>(0);
}

tree::TerminalNode* PhpParser::FunctionDeclarationContext::QuestionMark() {
  return getToken(PhpParser::QuestionMark, 0);
}


size_t PhpParser::FunctionDeclarationContext::getRuleIndex() const {
  return PhpParser::RuleFunctionDeclaration;
}

void PhpParser::FunctionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionDeclaration(this);
}

void PhpParser::FunctionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionDeclaration(this);
}

PhpParser::FunctionDeclarationContext* PhpParser::functionDeclaration() {
  FunctionDeclarationContext *_localctx = _tracker.createInstance<FunctionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 24, PhpParser::RuleFunctionDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(404);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::AttributeStart) {
      setState(403);
      attributes();
    }
    setState(406);
    match(PhpParser::Function_);
    setState(408);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Ampersand) {
      setState(407);
      match(PhpParser::Ampersand);
    }
    setState(410);
    identifier();
    setState(412);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Lgeneric) {
      setState(411);
      typeParameterListInBrackets();
    }
    setState(414);
    match(PhpParser::OpenRoundBracket);
    setState(415);
    formalParameterList();
    setState(416);
    match(PhpParser::CloseRoundBracket);
    setState(422);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Colon) {
      setState(417);
      match(PhpParser::Colon);
      setState(419);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PhpParser::QuestionMark) {
        setState(418);
        match(PhpParser::QuestionMark);
      }
      setState(421);
      typeHint(0);
    }
    setState(424);
    blockStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassDeclarationContext ------------------------------------------------------------------

PhpParser::ClassDeclarationContext::ClassDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::ClassDeclarationContext::OpenCurlyBracket() {
  return getToken(PhpParser::OpenCurlyBracket, 0);
}

tree::TerminalNode* PhpParser::ClassDeclarationContext::CloseCurlyBracket() {
  return getToken(PhpParser::CloseCurlyBracket, 0);
}

PhpParser::ClassEntryTypeContext* PhpParser::ClassDeclarationContext::classEntryType() {
  return getRuleContext<PhpParser::ClassEntryTypeContext>(0);
}

PhpParser::IdentifierContext* PhpParser::ClassDeclarationContext::identifier() {
  return getRuleContext<PhpParser::IdentifierContext>(0);
}

tree::TerminalNode* PhpParser::ClassDeclarationContext::Interface() {
  return getToken(PhpParser::Interface, 0);
}

PhpParser::AttributesContext* PhpParser::ClassDeclarationContext::attributes() {
  return getRuleContext<PhpParser::AttributesContext>(0);
}

tree::TerminalNode* PhpParser::ClassDeclarationContext::Private() {
  return getToken(PhpParser::Private, 0);
}

PhpParser::ModifierContext* PhpParser::ClassDeclarationContext::modifier() {
  return getRuleContext<PhpParser::ModifierContext>(0);
}

tree::TerminalNode* PhpParser::ClassDeclarationContext::Partial() {
  return getToken(PhpParser::Partial, 0);
}

std::vector<PhpParser::ClassStatementContext *> PhpParser::ClassDeclarationContext::classStatement() {
  return getRuleContexts<PhpParser::ClassStatementContext>();
}

PhpParser::ClassStatementContext* PhpParser::ClassDeclarationContext::classStatement(size_t i) {
  return getRuleContext<PhpParser::ClassStatementContext>(i);
}

PhpParser::TypeParameterListInBracketsContext* PhpParser::ClassDeclarationContext::typeParameterListInBrackets() {
  return getRuleContext<PhpParser::TypeParameterListInBracketsContext>(0);
}

tree::TerminalNode* PhpParser::ClassDeclarationContext::Extends() {
  return getToken(PhpParser::Extends, 0);
}

PhpParser::QualifiedStaticTypeRefContext* PhpParser::ClassDeclarationContext::qualifiedStaticTypeRef() {
  return getRuleContext<PhpParser::QualifiedStaticTypeRefContext>(0);
}

tree::TerminalNode* PhpParser::ClassDeclarationContext::Implements() {
  return getToken(PhpParser::Implements, 0);
}

PhpParser::InterfaceListContext* PhpParser::ClassDeclarationContext::interfaceList() {
  return getRuleContext<PhpParser::InterfaceListContext>(0);
}


size_t PhpParser::ClassDeclarationContext::getRuleIndex() const {
  return PhpParser::RuleClassDeclaration;
}

void PhpParser::ClassDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassDeclaration(this);
}

void PhpParser::ClassDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassDeclaration(this);
}

PhpParser::ClassDeclarationContext* PhpParser::classDeclaration() {
  ClassDeclarationContext *_localctx = _tracker.createInstance<ClassDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 26, PhpParser::RuleClassDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(427);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::AttributeStart) {
      setState(426);
      attributes();
    }
    setState(430);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Private) {
      setState(429);
      match(PhpParser::Private);
    }
    setState(433);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Abstract

    || _la == PhpParser::Final) {
      setState(432);
      modifier();
    }
    setState(436);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Partial) {
      setState(435);
      match(PhpParser::Partial);
    }
    setState(460);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::Class:
      case PhpParser::Trait: {
        setState(438);
        classEntryType();
        setState(439);
        identifier();
        setState(441);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Lgeneric) {
          setState(440);
          typeParameterListInBrackets();
        }
        setState(445);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Extends) {
          setState(443);
          match(PhpParser::Extends);
          setState(444);
          qualifiedStaticTypeRef();
        }
        setState(449);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Implements) {
          setState(447);
          match(PhpParser::Implements);
          setState(448);
          interfaceList();
        }
        break;
      }

      case PhpParser::Interface: {
        setState(451);
        match(PhpParser::Interface);
        setState(452);
        identifier();
        setState(454);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Lgeneric) {
          setState(453);
          typeParameterListInBrackets();
        }
        setState(458);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Extends) {
          setState(456);
          match(PhpParser::Extends);
          setState(457);
          interfaceList();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(462);
    match(PhpParser::OpenCurlyBracket);
    setState(466);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 72083982316994560) != 0) || ((((_la - 77) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 77)) & 6757727313330209) != 0)) {
      setState(463);
      classStatement();
      setState(468);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(469);
    match(PhpParser::CloseCurlyBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassEntryTypeContext ------------------------------------------------------------------

PhpParser::ClassEntryTypeContext::ClassEntryTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::ClassEntryTypeContext::Class() {
  return getToken(PhpParser::Class, 0);
}

tree::TerminalNode* PhpParser::ClassEntryTypeContext::Trait() {
  return getToken(PhpParser::Trait, 0);
}


size_t PhpParser::ClassEntryTypeContext::getRuleIndex() const {
  return PhpParser::RuleClassEntryType;
}

void PhpParser::ClassEntryTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassEntryType(this);
}

void PhpParser::ClassEntryTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassEntryType(this);
}

PhpParser::ClassEntryTypeContext* PhpParser::classEntryType() {
  ClassEntryTypeContext *_localctx = _tracker.createInstance<ClassEntryTypeContext>(_ctx, getState());
  enterRule(_localctx, 28, PhpParser::RuleClassEntryType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(471);
    _la = _input->LA(1);
    if (!(_la == PhpParser::Class || _la == PhpParser::Trait)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InterfaceListContext ------------------------------------------------------------------

PhpParser::InterfaceListContext::InterfaceListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::QualifiedStaticTypeRefContext *> PhpParser::InterfaceListContext::qualifiedStaticTypeRef() {
  return getRuleContexts<PhpParser::QualifiedStaticTypeRefContext>();
}

PhpParser::QualifiedStaticTypeRefContext* PhpParser::InterfaceListContext::qualifiedStaticTypeRef(size_t i) {
  return getRuleContext<PhpParser::QualifiedStaticTypeRefContext>(i);
}

std::vector<tree::TerminalNode *> PhpParser::InterfaceListContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::InterfaceListContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::InterfaceListContext::getRuleIndex() const {
  return PhpParser::RuleInterfaceList;
}

void PhpParser::InterfaceListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterfaceList(this);
}

void PhpParser::InterfaceListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterfaceList(this);
}

PhpParser::InterfaceListContext* PhpParser::interfaceList() {
  InterfaceListContext *_localctx = _tracker.createInstance<InterfaceListContext>(_ctx, getState());
  enterRule(_localctx, 30, PhpParser::RuleInterfaceList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(473);
    qualifiedStaticTypeRef();
    setState(478);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PhpParser::Comma) {
      setState(474);
      match(PhpParser::Comma);
      setState(475);
      qualifiedStaticTypeRef();
      setState(480);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeParameterListInBracketsContext ------------------------------------------------------------------

PhpParser::TypeParameterListInBracketsContext::TypeParameterListInBracketsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::TypeParameterListInBracketsContext::Lgeneric() {
  return getToken(PhpParser::Lgeneric, 0);
}

PhpParser::TypeParameterListContext* PhpParser::TypeParameterListInBracketsContext::typeParameterList() {
  return getRuleContext<PhpParser::TypeParameterListContext>(0);
}

tree::TerminalNode* PhpParser::TypeParameterListInBracketsContext::Rgeneric() {
  return getToken(PhpParser::Rgeneric, 0);
}

PhpParser::TypeParameterWithDefaultsListContext* PhpParser::TypeParameterListInBracketsContext::typeParameterWithDefaultsList() {
  return getRuleContext<PhpParser::TypeParameterWithDefaultsListContext>(0);
}

tree::TerminalNode* PhpParser::TypeParameterListInBracketsContext::Comma() {
  return getToken(PhpParser::Comma, 0);
}


size_t PhpParser::TypeParameterListInBracketsContext::getRuleIndex() const {
  return PhpParser::RuleTypeParameterListInBrackets;
}

void PhpParser::TypeParameterListInBracketsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeParameterListInBrackets(this);
}

void PhpParser::TypeParameterListInBracketsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeParameterListInBrackets(this);
}

PhpParser::TypeParameterListInBracketsContext* PhpParser::typeParameterListInBrackets() {
  TypeParameterListInBracketsContext *_localctx = _tracker.createInstance<TypeParameterListInBracketsContext>(_ctx, getState());
  enterRule(_localctx, 32, PhpParser::RuleTypeParameterListInBrackets);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(495);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(481);
      match(PhpParser::Lgeneric);
      setState(482);
      typeParameterList();
      setState(483);
      match(PhpParser::Rgeneric);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(485);
      match(PhpParser::Lgeneric);
      setState(486);
      typeParameterWithDefaultsList();
      setState(487);
      match(PhpParser::Rgeneric);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(489);
      match(PhpParser::Lgeneric);
      setState(490);
      typeParameterList();
      setState(491);
      match(PhpParser::Comma);
      setState(492);
      typeParameterWithDefaultsList();
      setState(493);
      match(PhpParser::Rgeneric);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeParameterListContext ------------------------------------------------------------------

PhpParser::TypeParameterListContext::TypeParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::TypeParameterDeclContext *> PhpParser::TypeParameterListContext::typeParameterDecl() {
  return getRuleContexts<PhpParser::TypeParameterDeclContext>();
}

PhpParser::TypeParameterDeclContext* PhpParser::TypeParameterListContext::typeParameterDecl(size_t i) {
  return getRuleContext<PhpParser::TypeParameterDeclContext>(i);
}

std::vector<tree::TerminalNode *> PhpParser::TypeParameterListContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::TypeParameterListContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::TypeParameterListContext::getRuleIndex() const {
  return PhpParser::RuleTypeParameterList;
}

void PhpParser::TypeParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeParameterList(this);
}

void PhpParser::TypeParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeParameterList(this);
}

PhpParser::TypeParameterListContext* PhpParser::typeParameterList() {
  TypeParameterListContext *_localctx = _tracker.createInstance<TypeParameterListContext>(_ctx, getState());
  enterRule(_localctx, 34, PhpParser::RuleTypeParameterList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(497);
    typeParameterDecl();
    setState(502);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(498);
        match(PhpParser::Comma);
        setState(499);
        typeParameterDecl(); 
      }
      setState(504);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeParameterWithDefaultsListContext ------------------------------------------------------------------

PhpParser::TypeParameterWithDefaultsListContext::TypeParameterWithDefaultsListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::TypeParameterWithDefaultDeclContext *> PhpParser::TypeParameterWithDefaultsListContext::typeParameterWithDefaultDecl() {
  return getRuleContexts<PhpParser::TypeParameterWithDefaultDeclContext>();
}

PhpParser::TypeParameterWithDefaultDeclContext* PhpParser::TypeParameterWithDefaultsListContext::typeParameterWithDefaultDecl(size_t i) {
  return getRuleContext<PhpParser::TypeParameterWithDefaultDeclContext>(i);
}

std::vector<tree::TerminalNode *> PhpParser::TypeParameterWithDefaultsListContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::TypeParameterWithDefaultsListContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::TypeParameterWithDefaultsListContext::getRuleIndex() const {
  return PhpParser::RuleTypeParameterWithDefaultsList;
}

void PhpParser::TypeParameterWithDefaultsListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeParameterWithDefaultsList(this);
}

void PhpParser::TypeParameterWithDefaultsListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeParameterWithDefaultsList(this);
}

PhpParser::TypeParameterWithDefaultsListContext* PhpParser::typeParameterWithDefaultsList() {
  TypeParameterWithDefaultsListContext *_localctx = _tracker.createInstance<TypeParameterWithDefaultsListContext>(_ctx, getState());
  enterRule(_localctx, 36, PhpParser::RuleTypeParameterWithDefaultsList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(505);
    typeParameterWithDefaultDecl();
    setState(510);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PhpParser::Comma) {
      setState(506);
      match(PhpParser::Comma);
      setState(507);
      typeParameterWithDefaultDecl();
      setState(512);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeParameterDeclContext ------------------------------------------------------------------

PhpParser::TypeParameterDeclContext::TypeParameterDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::IdentifierContext* PhpParser::TypeParameterDeclContext::identifier() {
  return getRuleContext<PhpParser::IdentifierContext>(0);
}

PhpParser::AttributesContext* PhpParser::TypeParameterDeclContext::attributes() {
  return getRuleContext<PhpParser::AttributesContext>(0);
}


size_t PhpParser::TypeParameterDeclContext::getRuleIndex() const {
  return PhpParser::RuleTypeParameterDecl;
}

void PhpParser::TypeParameterDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeParameterDecl(this);
}

void PhpParser::TypeParameterDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeParameterDecl(this);
}

PhpParser::TypeParameterDeclContext* PhpParser::typeParameterDecl() {
  TypeParameterDeclContext *_localctx = _tracker.createInstance<TypeParameterDeclContext>(_ctx, getState());
  enterRule(_localctx, 38, PhpParser::RuleTypeParameterDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(514);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::AttributeStart) {
      setState(513);
      attributes();
    }
    setState(516);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeParameterWithDefaultDeclContext ------------------------------------------------------------------

PhpParser::TypeParameterWithDefaultDeclContext::TypeParameterWithDefaultDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::IdentifierContext* PhpParser::TypeParameterWithDefaultDeclContext::identifier() {
  return getRuleContext<PhpParser::IdentifierContext>(0);
}

tree::TerminalNode* PhpParser::TypeParameterWithDefaultDeclContext::Eq() {
  return getToken(PhpParser::Eq, 0);
}

PhpParser::QualifiedStaticTypeRefContext* PhpParser::TypeParameterWithDefaultDeclContext::qualifiedStaticTypeRef() {
  return getRuleContext<PhpParser::QualifiedStaticTypeRefContext>(0);
}

PhpParser::PrimitiveTypeContext* PhpParser::TypeParameterWithDefaultDeclContext::primitiveType() {
  return getRuleContext<PhpParser::PrimitiveTypeContext>(0);
}

PhpParser::AttributesContext* PhpParser::TypeParameterWithDefaultDeclContext::attributes() {
  return getRuleContext<PhpParser::AttributesContext>(0);
}


size_t PhpParser::TypeParameterWithDefaultDeclContext::getRuleIndex() const {
  return PhpParser::RuleTypeParameterWithDefaultDecl;
}

void PhpParser::TypeParameterWithDefaultDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeParameterWithDefaultDecl(this);
}

void PhpParser::TypeParameterWithDefaultDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeParameterWithDefaultDecl(this);
}

PhpParser::TypeParameterWithDefaultDeclContext* PhpParser::typeParameterWithDefaultDecl() {
  TypeParameterWithDefaultDeclContext *_localctx = _tracker.createInstance<TypeParameterWithDefaultDeclContext>(_ctx, getState());
  enterRule(_localctx, 40, PhpParser::RuleTypeParameterWithDefaultDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(519);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::AttributeStart) {
      setState(518);
      attributes();
    }
    setState(521);
    identifier();
    setState(522);
    match(PhpParser::Eq);
    setState(525);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx)) {
    case 1: {
      setState(523);
      qualifiedStaticTypeRef();
      break;
    }

    case 2: {
      setState(524);
      primitiveType();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericDynamicArgsContext ------------------------------------------------------------------

PhpParser::GenericDynamicArgsContext::GenericDynamicArgsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::GenericDynamicArgsContext::Lgeneric() {
  return getToken(PhpParser::Lgeneric, 0);
}

std::vector<PhpParser::TypeRefContext *> PhpParser::GenericDynamicArgsContext::typeRef() {
  return getRuleContexts<PhpParser::TypeRefContext>();
}

PhpParser::TypeRefContext* PhpParser::GenericDynamicArgsContext::typeRef(size_t i) {
  return getRuleContext<PhpParser::TypeRefContext>(i);
}

tree::TerminalNode* PhpParser::GenericDynamicArgsContext::Rgeneric() {
  return getToken(PhpParser::Rgeneric, 0);
}

std::vector<tree::TerminalNode *> PhpParser::GenericDynamicArgsContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::GenericDynamicArgsContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::GenericDynamicArgsContext::getRuleIndex() const {
  return PhpParser::RuleGenericDynamicArgs;
}

void PhpParser::GenericDynamicArgsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericDynamicArgs(this);
}

void PhpParser::GenericDynamicArgsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericDynamicArgs(this);
}

PhpParser::GenericDynamicArgsContext* PhpParser::genericDynamicArgs() {
  GenericDynamicArgsContext *_localctx = _tracker.createInstance<GenericDynamicArgsContext>(_ctx, getState());
  enterRule(_localctx, 42, PhpParser::RuleGenericDynamicArgs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(527);
    match(PhpParser::Lgeneric);
    setState(528);
    typeRef();
    setState(533);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PhpParser::Comma) {
      setState(529);
      match(PhpParser::Comma);
      setState(530);
      typeRef();
      setState(535);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(536);
    match(PhpParser::Rgeneric);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributesContext ------------------------------------------------------------------

PhpParser::AttributesContext::AttributesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::AttributeGroupContext *> PhpParser::AttributesContext::attributeGroup() {
  return getRuleContexts<PhpParser::AttributeGroupContext>();
}

PhpParser::AttributeGroupContext* PhpParser::AttributesContext::attributeGroup(size_t i) {
  return getRuleContext<PhpParser::AttributeGroupContext>(i);
}


size_t PhpParser::AttributesContext::getRuleIndex() const {
  return PhpParser::RuleAttributes;
}

void PhpParser::AttributesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributes(this);
}

void PhpParser::AttributesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributes(this);
}

PhpParser::AttributesContext* PhpParser::attributes() {
  AttributesContext *_localctx = _tracker.createInstance<AttributesContext>(_ctx, getState());
  enterRule(_localctx, 44, PhpParser::RuleAttributes);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(539); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(538);
      attributeGroup();
      setState(541); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == PhpParser::AttributeStart);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeGroupContext ------------------------------------------------------------------

PhpParser::AttributeGroupContext::AttributeGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::AttributeGroupContext::AttributeStart() {
  return getToken(PhpParser::AttributeStart, 0);
}

std::vector<PhpParser::AttributeContext *> PhpParser::AttributeGroupContext::attribute() {
  return getRuleContexts<PhpParser::AttributeContext>();
}

PhpParser::AttributeContext* PhpParser::AttributeGroupContext::attribute(size_t i) {
  return getRuleContext<PhpParser::AttributeContext>(i);
}

tree::TerminalNode* PhpParser::AttributeGroupContext::CloseSquareBracket() {
  return getToken(PhpParser::CloseSquareBracket, 0);
}

PhpParser::IdentifierContext* PhpParser::AttributeGroupContext::identifier() {
  return getRuleContext<PhpParser::IdentifierContext>(0);
}

tree::TerminalNode* PhpParser::AttributeGroupContext::Colon() {
  return getToken(PhpParser::Colon, 0);
}

std::vector<tree::TerminalNode *> PhpParser::AttributeGroupContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::AttributeGroupContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::AttributeGroupContext::getRuleIndex() const {
  return PhpParser::RuleAttributeGroup;
}

void PhpParser::AttributeGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeGroup(this);
}

void PhpParser::AttributeGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeGroup(this);
}

PhpParser::AttributeGroupContext* PhpParser::attributeGroup() {
  AttributeGroupContext *_localctx = _tracker.createInstance<AttributeGroupContext>(_ctx, getState());
  enterRule(_localctx, 46, PhpParser::RuleAttributeGroup);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(543);
    match(PhpParser::AttributeStart);
    setState(547);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
    case 1: {
      setState(544);
      identifier();
      setState(545);
      match(PhpParser::Colon);
      break;
    }

    default:
      break;
    }
    setState(549);
    attribute();
    setState(554);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PhpParser::Comma) {
      setState(550);
      match(PhpParser::Comma);
      setState(551);
      attribute();
      setState(556);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(557);
    match(PhpParser::CloseSquareBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeContext ------------------------------------------------------------------

PhpParser::AttributeContext::AttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::QualifiedNamespaceNameContext* PhpParser::AttributeContext::qualifiedNamespaceName() {
  return getRuleContext<PhpParser::QualifiedNamespaceNameContext>(0);
}

PhpParser::ArgumentsContext* PhpParser::AttributeContext::arguments() {
  return getRuleContext<PhpParser::ArgumentsContext>(0);
}


size_t PhpParser::AttributeContext::getRuleIndex() const {
  return PhpParser::RuleAttribute;
}

void PhpParser::AttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttribute(this);
}

void PhpParser::AttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttribute(this);
}

PhpParser::AttributeContext* PhpParser::attribute() {
  AttributeContext *_localctx = _tracker.createInstance<AttributeContext>(_ctx, getState());
  enterRule(_localctx, 48, PhpParser::RuleAttribute);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(559);
    qualifiedNamespaceName();
    setState(561);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::OpenRoundBracket) {
      setState(560);
      arguments();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InnerStatementListContext ------------------------------------------------------------------

PhpParser::InnerStatementListContext::InnerStatementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::InnerStatementContext *> PhpParser::InnerStatementListContext::innerStatement() {
  return getRuleContexts<PhpParser::InnerStatementContext>();
}

PhpParser::InnerStatementContext* PhpParser::InnerStatementListContext::innerStatement(size_t i) {
  return getRuleContext<PhpParser::InnerStatementContext>(i);
}


size_t PhpParser::InnerStatementListContext::getRuleIndex() const {
  return PhpParser::RuleInnerStatementList;
}

void PhpParser::InnerStatementListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInnerStatementList(this);
}

void PhpParser::InnerStatementListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInnerStatementList(this);
}

PhpParser::InnerStatementListContext* PhpParser::innerStatementList() {
  InnerStatementListContext *_localctx = _tracker.createInstance<InnerStatementListContext>(_ctx, getState());
  enterRule(_localctx, 50, PhpParser::RuleInnerStatementList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(566);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(563);
        innerStatement(); 
      }
      setState(568);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InnerStatementContext ------------------------------------------------------------------

PhpParser::InnerStatementContext::InnerStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::StatementContext* PhpParser::InnerStatementContext::statement() {
  return getRuleContext<PhpParser::StatementContext>(0);
}

PhpParser::FunctionDeclarationContext* PhpParser::InnerStatementContext::functionDeclaration() {
  return getRuleContext<PhpParser::FunctionDeclarationContext>(0);
}

PhpParser::ClassDeclarationContext* PhpParser::InnerStatementContext::classDeclaration() {
  return getRuleContext<PhpParser::ClassDeclarationContext>(0);
}


size_t PhpParser::InnerStatementContext::getRuleIndex() const {
  return PhpParser::RuleInnerStatement;
}

void PhpParser::InnerStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInnerStatement(this);
}

void PhpParser::InnerStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInnerStatement(this);
}

PhpParser::InnerStatementContext* PhpParser::innerStatement() {
  InnerStatementContext *_localctx = _tracker.createInstance<InnerStatementContext>(_ctx, getState());
  enterRule(_localctx, 52, PhpParser::RuleInnerStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(572);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(569);
      statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(570);
      functionDeclaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(571);
      classDeclaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

PhpParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::IdentifierContext* PhpParser::StatementContext::identifier() {
  return getRuleContext<PhpParser::IdentifierContext>(0);
}

tree::TerminalNode* PhpParser::StatementContext::Colon() {
  return getToken(PhpParser::Colon, 0);
}

PhpParser::BlockStatementContext* PhpParser::StatementContext::blockStatement() {
  return getRuleContext<PhpParser::BlockStatementContext>(0);
}

PhpParser::IfStatementContext* PhpParser::StatementContext::ifStatement() {
  return getRuleContext<PhpParser::IfStatementContext>(0);
}

PhpParser::WhileStatementContext* PhpParser::StatementContext::whileStatement() {
  return getRuleContext<PhpParser::WhileStatementContext>(0);
}

PhpParser::DoWhileStatementContext* PhpParser::StatementContext::doWhileStatement() {
  return getRuleContext<PhpParser::DoWhileStatementContext>(0);
}

PhpParser::ForStatementContext* PhpParser::StatementContext::forStatement() {
  return getRuleContext<PhpParser::ForStatementContext>(0);
}

PhpParser::SwitchStatementContext* PhpParser::StatementContext::switchStatement() {
  return getRuleContext<PhpParser::SwitchStatementContext>(0);
}

PhpParser::BreakStatementContext* PhpParser::StatementContext::breakStatement() {
  return getRuleContext<PhpParser::BreakStatementContext>(0);
}

PhpParser::ContinueStatementContext* PhpParser::StatementContext::continueStatement() {
  return getRuleContext<PhpParser::ContinueStatementContext>(0);
}

PhpParser::ReturnStatementContext* PhpParser::StatementContext::returnStatement() {
  return getRuleContext<PhpParser::ReturnStatementContext>(0);
}

PhpParser::YieldExpressionContext* PhpParser::StatementContext::yieldExpression() {
  return getRuleContext<PhpParser::YieldExpressionContext>(0);
}

tree::TerminalNode* PhpParser::StatementContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}

PhpParser::GlobalStatementContext* PhpParser::StatementContext::globalStatement() {
  return getRuleContext<PhpParser::GlobalStatementContext>(0);
}

PhpParser::StaticVariableStatementContext* PhpParser::StatementContext::staticVariableStatement() {
  return getRuleContext<PhpParser::StaticVariableStatementContext>(0);
}

PhpParser::EchoStatementContext* PhpParser::StatementContext::echoStatement() {
  return getRuleContext<PhpParser::EchoStatementContext>(0);
}

PhpParser::ExpressionStatementContext* PhpParser::StatementContext::expressionStatement() {
  return getRuleContext<PhpParser::ExpressionStatementContext>(0);
}

PhpParser::UnsetStatementContext* PhpParser::StatementContext::unsetStatement() {
  return getRuleContext<PhpParser::UnsetStatementContext>(0);
}

PhpParser::ForeachStatementContext* PhpParser::StatementContext::foreachStatement() {
  return getRuleContext<PhpParser::ForeachStatementContext>(0);
}

PhpParser::TryCatchFinallyContext* PhpParser::StatementContext::tryCatchFinally() {
  return getRuleContext<PhpParser::TryCatchFinallyContext>(0);
}

PhpParser::ThrowStatementContext* PhpParser::StatementContext::throwStatement() {
  return getRuleContext<PhpParser::ThrowStatementContext>(0);
}

PhpParser::GotoStatementContext* PhpParser::StatementContext::gotoStatement() {
  return getRuleContext<PhpParser::GotoStatementContext>(0);
}

PhpParser::DeclareStatementContext* PhpParser::StatementContext::declareStatement() {
  return getRuleContext<PhpParser::DeclareStatementContext>(0);
}

PhpParser::EmptyStatement_Context* PhpParser::StatementContext::emptyStatement_() {
  return getRuleContext<PhpParser::EmptyStatement_Context>(0);
}

PhpParser::InlineHtmlStatementContext* PhpParser::StatementContext::inlineHtmlStatement() {
  return getRuleContext<PhpParser::InlineHtmlStatementContext>(0);
}


size_t PhpParser::StatementContext::getRuleIndex() const {
  return PhpParser::RuleStatement;
}

void PhpParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void PhpParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}

PhpParser::StatementContext* PhpParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 54, PhpParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(601);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(574);
      identifier();
      setState(575);
      match(PhpParser::Colon);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(577);
      blockStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(578);
      ifStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(579);
      whileStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(580);
      doWhileStatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(581);
      forStatement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(582);
      switchStatement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(583);
      breakStatement();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(584);
      continueStatement();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(585);
      returnStatement();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(586);
      yieldExpression();
      setState(587);
      match(PhpParser::SemiColon);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(589);
      globalStatement();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(590);
      staticVariableStatement();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(591);
      echoStatement();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(592);
      expressionStatement();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(593);
      unsetStatement();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(594);
      foreachStatement();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(595);
      tryCatchFinally();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(596);
      throwStatement();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(597);
      gotoStatement();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(598);
      declareStatement();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(599);
      emptyStatement_();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(600);
      inlineHtmlStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmptyStatement_Context ------------------------------------------------------------------

PhpParser::EmptyStatement_Context::EmptyStatement_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::EmptyStatement_Context::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}


size_t PhpParser::EmptyStatement_Context::getRuleIndex() const {
  return PhpParser::RuleEmptyStatement_;
}

void PhpParser::EmptyStatement_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmptyStatement_(this);
}

void PhpParser::EmptyStatement_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmptyStatement_(this);
}

PhpParser::EmptyStatement_Context* PhpParser::emptyStatement_() {
  EmptyStatement_Context *_localctx = _tracker.createInstance<EmptyStatement_Context>(_ctx, getState());
  enterRule(_localctx, 56, PhpParser::RuleEmptyStatement_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(603);
    match(PhpParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockStatementContext ------------------------------------------------------------------

PhpParser::BlockStatementContext::BlockStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::BlockStatementContext::OpenCurlyBracket() {
  return getToken(PhpParser::OpenCurlyBracket, 0);
}

PhpParser::InnerStatementListContext* PhpParser::BlockStatementContext::innerStatementList() {
  return getRuleContext<PhpParser::InnerStatementListContext>(0);
}

tree::TerminalNode* PhpParser::BlockStatementContext::CloseCurlyBracket() {
  return getToken(PhpParser::CloseCurlyBracket, 0);
}


size_t PhpParser::BlockStatementContext::getRuleIndex() const {
  return PhpParser::RuleBlockStatement;
}

void PhpParser::BlockStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlockStatement(this);
}

void PhpParser::BlockStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlockStatement(this);
}

PhpParser::BlockStatementContext* PhpParser::blockStatement() {
  BlockStatementContext *_localctx = _tracker.createInstance<BlockStatementContext>(_ctx, getState());
  enterRule(_localctx, 58, PhpParser::RuleBlockStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(605);
    match(PhpParser::OpenCurlyBracket);
    setState(606);
    innerStatementList();
    setState(607);
    match(PhpParser::CloseCurlyBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStatementContext ------------------------------------------------------------------

PhpParser::IfStatementContext::IfStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::IfStatementContext::If() {
  return getToken(PhpParser::If, 0);
}

PhpParser::ParenthesesContext* PhpParser::IfStatementContext::parentheses() {
  return getRuleContext<PhpParser::ParenthesesContext>(0);
}

PhpParser::StatementContext* PhpParser::IfStatementContext::statement() {
  return getRuleContext<PhpParser::StatementContext>(0);
}

std::vector<PhpParser::ElseIfStatementContext *> PhpParser::IfStatementContext::elseIfStatement() {
  return getRuleContexts<PhpParser::ElseIfStatementContext>();
}

PhpParser::ElseIfStatementContext* PhpParser::IfStatementContext::elseIfStatement(size_t i) {
  return getRuleContext<PhpParser::ElseIfStatementContext>(i);
}

PhpParser::ElseStatementContext* PhpParser::IfStatementContext::elseStatement() {
  return getRuleContext<PhpParser::ElseStatementContext>(0);
}

tree::TerminalNode* PhpParser::IfStatementContext::Colon() {
  return getToken(PhpParser::Colon, 0);
}

PhpParser::InnerStatementListContext* PhpParser::IfStatementContext::innerStatementList() {
  return getRuleContext<PhpParser::InnerStatementListContext>(0);
}

tree::TerminalNode* PhpParser::IfStatementContext::EndIf() {
  return getToken(PhpParser::EndIf, 0);
}

tree::TerminalNode* PhpParser::IfStatementContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}

std::vector<PhpParser::ElseIfColonStatementContext *> PhpParser::IfStatementContext::elseIfColonStatement() {
  return getRuleContexts<PhpParser::ElseIfColonStatementContext>();
}

PhpParser::ElseIfColonStatementContext* PhpParser::IfStatementContext::elseIfColonStatement(size_t i) {
  return getRuleContext<PhpParser::ElseIfColonStatementContext>(i);
}

PhpParser::ElseColonStatementContext* PhpParser::IfStatementContext::elseColonStatement() {
  return getRuleContext<PhpParser::ElseColonStatementContext>(0);
}


size_t PhpParser::IfStatementContext::getRuleIndex() const {
  return PhpParser::RuleIfStatement;
}

void PhpParser::IfStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfStatement(this);
}

void PhpParser::IfStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfStatement(this);
}

PhpParser::IfStatementContext* PhpParser::ifStatement() {
  IfStatementContext *_localctx = _tracker.createInstance<IfStatementContext>(_ctx, getState());
  enterRule(_localctx, 60, PhpParser::RuleIfStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(637);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(609);
      match(PhpParser::If);
      setState(610);
      parentheses();
      setState(611);
      statement();
      setState(615);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(612);
          elseIfStatement(); 
        }
        setState(617);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx);
      }
      setState(619);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
      case 1: {
        setState(618);
        elseStatement();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(621);
      match(PhpParser::If);
      setState(622);
      parentheses();
      setState(623);
      match(PhpParser::Colon);
      setState(624);
      innerStatementList();
      setState(628);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == PhpParser::ElseIf) {
        setState(625);
        elseIfColonStatement();
        setState(630);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(632);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PhpParser::Else) {
        setState(631);
        elseColonStatement();
      }
      setState(634);
      match(PhpParser::EndIf);
      setState(635);
      match(PhpParser::SemiColon);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseIfStatementContext ------------------------------------------------------------------

PhpParser::ElseIfStatementContext::ElseIfStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::ElseIfStatementContext::ElseIf() {
  return getToken(PhpParser::ElseIf, 0);
}

PhpParser::ParenthesesContext* PhpParser::ElseIfStatementContext::parentheses() {
  return getRuleContext<PhpParser::ParenthesesContext>(0);
}

PhpParser::StatementContext* PhpParser::ElseIfStatementContext::statement() {
  return getRuleContext<PhpParser::StatementContext>(0);
}


size_t PhpParser::ElseIfStatementContext::getRuleIndex() const {
  return PhpParser::RuleElseIfStatement;
}

void PhpParser::ElseIfStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElseIfStatement(this);
}

void PhpParser::ElseIfStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElseIfStatement(this);
}

PhpParser::ElseIfStatementContext* PhpParser::elseIfStatement() {
  ElseIfStatementContext *_localctx = _tracker.createInstance<ElseIfStatementContext>(_ctx, getState());
  enterRule(_localctx, 62, PhpParser::RuleElseIfStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(639);
    match(PhpParser::ElseIf);
    setState(640);
    parentheses();
    setState(641);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseIfColonStatementContext ------------------------------------------------------------------

PhpParser::ElseIfColonStatementContext::ElseIfColonStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::ElseIfColonStatementContext::ElseIf() {
  return getToken(PhpParser::ElseIf, 0);
}

PhpParser::ParenthesesContext* PhpParser::ElseIfColonStatementContext::parentheses() {
  return getRuleContext<PhpParser::ParenthesesContext>(0);
}

tree::TerminalNode* PhpParser::ElseIfColonStatementContext::Colon() {
  return getToken(PhpParser::Colon, 0);
}

PhpParser::InnerStatementListContext* PhpParser::ElseIfColonStatementContext::innerStatementList() {
  return getRuleContext<PhpParser::InnerStatementListContext>(0);
}


size_t PhpParser::ElseIfColonStatementContext::getRuleIndex() const {
  return PhpParser::RuleElseIfColonStatement;
}

void PhpParser::ElseIfColonStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElseIfColonStatement(this);
}

void PhpParser::ElseIfColonStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElseIfColonStatement(this);
}

PhpParser::ElseIfColonStatementContext* PhpParser::elseIfColonStatement() {
  ElseIfColonStatementContext *_localctx = _tracker.createInstance<ElseIfColonStatementContext>(_ctx, getState());
  enterRule(_localctx, 64, PhpParser::RuleElseIfColonStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(643);
    match(PhpParser::ElseIf);
    setState(644);
    parentheses();
    setState(645);
    match(PhpParser::Colon);
    setState(646);
    innerStatementList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseStatementContext ------------------------------------------------------------------

PhpParser::ElseStatementContext::ElseStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::ElseStatementContext::Else() {
  return getToken(PhpParser::Else, 0);
}

PhpParser::StatementContext* PhpParser::ElseStatementContext::statement() {
  return getRuleContext<PhpParser::StatementContext>(0);
}


size_t PhpParser::ElseStatementContext::getRuleIndex() const {
  return PhpParser::RuleElseStatement;
}

void PhpParser::ElseStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElseStatement(this);
}

void PhpParser::ElseStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElseStatement(this);
}

PhpParser::ElseStatementContext* PhpParser::elseStatement() {
  ElseStatementContext *_localctx = _tracker.createInstance<ElseStatementContext>(_ctx, getState());
  enterRule(_localctx, 66, PhpParser::RuleElseStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(648);
    match(PhpParser::Else);
    setState(649);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseColonStatementContext ------------------------------------------------------------------

PhpParser::ElseColonStatementContext::ElseColonStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::ElseColonStatementContext::Else() {
  return getToken(PhpParser::Else, 0);
}

tree::TerminalNode* PhpParser::ElseColonStatementContext::Colon() {
  return getToken(PhpParser::Colon, 0);
}

PhpParser::InnerStatementListContext* PhpParser::ElseColonStatementContext::innerStatementList() {
  return getRuleContext<PhpParser::InnerStatementListContext>(0);
}


size_t PhpParser::ElseColonStatementContext::getRuleIndex() const {
  return PhpParser::RuleElseColonStatement;
}

void PhpParser::ElseColonStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElseColonStatement(this);
}

void PhpParser::ElseColonStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElseColonStatement(this);
}

PhpParser::ElseColonStatementContext* PhpParser::elseColonStatement() {
  ElseColonStatementContext *_localctx = _tracker.createInstance<ElseColonStatementContext>(_ctx, getState());
  enterRule(_localctx, 68, PhpParser::RuleElseColonStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(651);
    match(PhpParser::Else);
    setState(652);
    match(PhpParser::Colon);
    setState(653);
    innerStatementList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhileStatementContext ------------------------------------------------------------------

PhpParser::WhileStatementContext::WhileStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::WhileStatementContext::While() {
  return getToken(PhpParser::While, 0);
}

PhpParser::ParenthesesContext* PhpParser::WhileStatementContext::parentheses() {
  return getRuleContext<PhpParser::ParenthesesContext>(0);
}

PhpParser::StatementContext* PhpParser::WhileStatementContext::statement() {
  return getRuleContext<PhpParser::StatementContext>(0);
}

tree::TerminalNode* PhpParser::WhileStatementContext::Colon() {
  return getToken(PhpParser::Colon, 0);
}

PhpParser::InnerStatementListContext* PhpParser::WhileStatementContext::innerStatementList() {
  return getRuleContext<PhpParser::InnerStatementListContext>(0);
}

tree::TerminalNode* PhpParser::WhileStatementContext::EndWhile() {
  return getToken(PhpParser::EndWhile, 0);
}

tree::TerminalNode* PhpParser::WhileStatementContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}


size_t PhpParser::WhileStatementContext::getRuleIndex() const {
  return PhpParser::RuleWhileStatement;
}

void PhpParser::WhileStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhileStatement(this);
}

void PhpParser::WhileStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhileStatement(this);
}

PhpParser::WhileStatementContext* PhpParser::whileStatement() {
  WhileStatementContext *_localctx = _tracker.createInstance<WhileStatementContext>(_ctx, getState());
  enterRule(_localctx, 70, PhpParser::RuleWhileStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(655);
    match(PhpParser::While);
    setState(656);
    parentheses();
    setState(663);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::HtmlText:
      case PhpParser::XmlStart:
      case PhpParser::HtmlScriptOpen:
      case PhpParser::HtmlStyleOpen:
      case PhpParser::HtmlDtd:
      case PhpParser::HtmlOpen:
      case PhpParser::HtmlClose:
      case PhpParser::HtmlSlashClose:
      case PhpParser::HtmlSlash:
      case PhpParser::HtmlEquals:
      case PhpParser::HtmlStartQuoteString:
      case PhpParser::HtmlStartDoubleQuoteString:
      case PhpParser::HtmlHex:
      case PhpParser::HtmlDecimal:
      case PhpParser::HtmlName:
      case PhpParser::HtmlEndQuoteString:
      case PhpParser::HtmlQuoteString:
      case PhpParser::HtmlEndDoubleQuoteString:
      case PhpParser::HtmlDoubleQuoteString:
      case PhpParser::ScriptText:
      case PhpParser::HtmlScriptClose:
      case PhpParser::StyleBody:
      case PhpParser::Abstract:
      case PhpParser::Array:
      case PhpParser::As:
      case PhpParser::BinaryCast:
      case PhpParser::BoolType:
      case PhpParser::BooleanConstant:
      case PhpParser::Break:
      case PhpParser::Callable:
      case PhpParser::Case:
      case PhpParser::Catch:
      case PhpParser::Class:
      case PhpParser::Clone:
      case PhpParser::Const:
      case PhpParser::Continue:
      case PhpParser::Declare:
      case PhpParser::Default:
      case PhpParser::Do:
      case PhpParser::DoubleCast:
      case PhpParser::DoubleType:
      case PhpParser::Echo:
      case PhpParser::Else:
      case PhpParser::ElseIf:
      case PhpParser::Empty:
      case PhpParser::Enum_:
      case PhpParser::EndDeclare:
      case PhpParser::EndFor:
      case PhpParser::EndForeach:
      case PhpParser::EndIf:
      case PhpParser::EndSwitch:
      case PhpParser::EndWhile:
      case PhpParser::Eval:
      case PhpParser::Exit:
      case PhpParser::Extends:
      case PhpParser::Final:
      case PhpParser::Finally:
      case PhpParser::FloatCast:
      case PhpParser::For:
      case PhpParser::Foreach:
      case PhpParser::Function_:
      case PhpParser::Global:
      case PhpParser::Goto:
      case PhpParser::If:
      case PhpParser::Implements:
      case PhpParser::Import:
      case PhpParser::Include:
      case PhpParser::IncludeOnce:
      case PhpParser::InstanceOf:
      case PhpParser::InsteadOf:
      case PhpParser::Int8Cast:
      case PhpParser::Int16Cast:
      case PhpParser::Int64Type:
      case PhpParser::IntType:
      case PhpParser::Interface:
      case PhpParser::IsSet:
      case PhpParser::List:
      case PhpParser::LogicalAnd:
      case PhpParser::LogicalOr:
      case PhpParser::LogicalXor:
      case PhpParser::Match_:
      case PhpParser::Namespace:
      case PhpParser::New:
      case PhpParser::Null:
      case PhpParser::ObjectType:
      case PhpParser::Parent_:
      case PhpParser::Partial:
      case PhpParser::Print:
      case PhpParser::Private:
      case PhpParser::Protected:
      case PhpParser::Public:
      case PhpParser::Readonly:
      case PhpParser::Require:
      case PhpParser::RequireOnce:
      case PhpParser::Resource:
      case PhpParser::Return:
      case PhpParser::Static:
      case PhpParser::StringType:
      case PhpParser::Switch:
      case PhpParser::Throw:
      case PhpParser::Trait:
      case PhpParser::Try:
      case PhpParser::Typeof:
      case PhpParser::UintCast:
      case PhpParser::UnicodeCast:
      case PhpParser::Unset:
      case PhpParser::Use:
      case PhpParser::Var:
      case PhpParser::While:
      case PhpParser::Yield:
      case PhpParser::From:
      case PhpParser::LambdaFn:
      case PhpParser::Ticks:
      case PhpParser::Encoding:
      case PhpParser::StrictTypes:
      case PhpParser::Get:
      case PhpParser::Set:
      case PhpParser::Call:
      case PhpParser::CallStatic:
      case PhpParser::Constructor:
      case PhpParser::Destruct:
      case PhpParser::Wakeup:
      case PhpParser::Sleep:
      case PhpParser::Autoload:
      case PhpParser::IsSet__:
      case PhpParser::Unset__:
      case PhpParser::ToString__:
      case PhpParser::Invoke:
      case PhpParser::SetState:
      case PhpParser::Clone__:
      case PhpParser::DebugInfo:
      case PhpParser::Namespace__:
      case PhpParser::Class__:
      case PhpParser::Traic__:
      case PhpParser::Function__:
      case PhpParser::Method__:
      case PhpParser::Line__:
      case PhpParser::File__:
      case PhpParser::Dir__:
      case PhpParser::Inc:
      case PhpParser::Dec:
      case PhpParser::NamespaceSeparator:
      case PhpParser::Bang:
      case PhpParser::Plus:
      case PhpParser::Minus:
      case PhpParser::Tilde:
      case PhpParser::SuppressWarnings:
      case PhpParser::Dollar:
      case PhpParser::OpenRoundBracket:
      case PhpParser::OpenSquareBracket:
      case PhpParser::OpenCurlyBracket:
      case PhpParser::SemiColon:
      case PhpParser::VarName:
      case PhpParser::Label:
      case PhpParser::Octal:
      case PhpParser::Decimal:
      case PhpParser::Real:
      case PhpParser::Hex:
      case PhpParser::Binary:
      case PhpParser::BackQuoteString:
      case PhpParser::SingleQuoteString:
      case PhpParser::DoubleQuote:
      case PhpParser::StartNowDoc:
      case PhpParser::StartHereDoc: {
        setState(657);
        statement();
        break;
      }

      case PhpParser::Colon: {
        setState(658);
        match(PhpParser::Colon);
        setState(659);
        innerStatementList();
        setState(660);
        match(PhpParser::EndWhile);
        setState(661);
        match(PhpParser::SemiColon);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DoWhileStatementContext ------------------------------------------------------------------

PhpParser::DoWhileStatementContext::DoWhileStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::DoWhileStatementContext::Do() {
  return getToken(PhpParser::Do, 0);
}

PhpParser::StatementContext* PhpParser::DoWhileStatementContext::statement() {
  return getRuleContext<PhpParser::StatementContext>(0);
}

tree::TerminalNode* PhpParser::DoWhileStatementContext::While() {
  return getToken(PhpParser::While, 0);
}

PhpParser::ParenthesesContext* PhpParser::DoWhileStatementContext::parentheses() {
  return getRuleContext<PhpParser::ParenthesesContext>(0);
}

tree::TerminalNode* PhpParser::DoWhileStatementContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}


size_t PhpParser::DoWhileStatementContext::getRuleIndex() const {
  return PhpParser::RuleDoWhileStatement;
}

void PhpParser::DoWhileStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoWhileStatement(this);
}

void PhpParser::DoWhileStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoWhileStatement(this);
}

PhpParser::DoWhileStatementContext* PhpParser::doWhileStatement() {
  DoWhileStatementContext *_localctx = _tracker.createInstance<DoWhileStatementContext>(_ctx, getState());
  enterRule(_localctx, 72, PhpParser::RuleDoWhileStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(665);
    match(PhpParser::Do);
    setState(666);
    statement();
    setState(667);
    match(PhpParser::While);
    setState(668);
    parentheses();
    setState(669);
    match(PhpParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForStatementContext ------------------------------------------------------------------

PhpParser::ForStatementContext::ForStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::ForStatementContext::For() {
  return getToken(PhpParser::For, 0);
}

tree::TerminalNode* PhpParser::ForStatementContext::OpenRoundBracket() {
  return getToken(PhpParser::OpenRoundBracket, 0);
}

std::vector<tree::TerminalNode *> PhpParser::ForStatementContext::SemiColon() {
  return getTokens(PhpParser::SemiColon);
}

tree::TerminalNode* PhpParser::ForStatementContext::SemiColon(size_t i) {
  return getToken(PhpParser::SemiColon, i);
}

tree::TerminalNode* PhpParser::ForStatementContext::CloseRoundBracket() {
  return getToken(PhpParser::CloseRoundBracket, 0);
}

PhpParser::StatementContext* PhpParser::ForStatementContext::statement() {
  return getRuleContext<PhpParser::StatementContext>(0);
}

tree::TerminalNode* PhpParser::ForStatementContext::Colon() {
  return getToken(PhpParser::Colon, 0);
}

PhpParser::InnerStatementListContext* PhpParser::ForStatementContext::innerStatementList() {
  return getRuleContext<PhpParser::InnerStatementListContext>(0);
}

tree::TerminalNode* PhpParser::ForStatementContext::EndFor() {
  return getToken(PhpParser::EndFor, 0);
}

PhpParser::ForInitContext* PhpParser::ForStatementContext::forInit() {
  return getRuleContext<PhpParser::ForInitContext>(0);
}

PhpParser::ExpressionListContext* PhpParser::ForStatementContext::expressionList() {
  return getRuleContext<PhpParser::ExpressionListContext>(0);
}

PhpParser::ForUpdateContext* PhpParser::ForStatementContext::forUpdate() {
  return getRuleContext<PhpParser::ForUpdateContext>(0);
}


size_t PhpParser::ForStatementContext::getRuleIndex() const {
  return PhpParser::RuleForStatement;
}

void PhpParser::ForStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForStatement(this);
}

void PhpParser::ForStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForStatement(this);
}

PhpParser::ForStatementContext* PhpParser::forStatement() {
  ForStatementContext *_localctx = _tracker.createInstance<ForStatementContext>(_ctx, getState());
  enterRule(_localctx, 74, PhpParser::RuleForStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(671);
    match(PhpParser::For);
    setState(672);
    match(PhpParser::OpenRoundBracket);
    setState(674);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 44) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 44)) & -1) != 0) || ((((_la - 108) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 108)) & 441352763482308607) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 194)) & 4396974138177) != 0)) {
      setState(673);
      forInit();
    }
    setState(676);
    match(PhpParser::SemiColon);
    setState(678);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 44) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 44)) & -1) != 0) || ((((_la - 108) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 108)) & 441352763482308607) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 194)) & 4396974138177) != 0)) {
      setState(677);
      expressionList();
    }
    setState(680);
    match(PhpParser::SemiColon);
    setState(682);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 44) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 44)) & -1) != 0) || ((((_la - 108) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 108)) & 441352763482308607) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 194)) & 4396974138177) != 0)) {
      setState(681);
      forUpdate();
    }
    setState(684);
    match(PhpParser::CloseRoundBracket);
    setState(691);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::HtmlText:
      case PhpParser::XmlStart:
      case PhpParser::HtmlScriptOpen:
      case PhpParser::HtmlStyleOpen:
      case PhpParser::HtmlDtd:
      case PhpParser::HtmlOpen:
      case PhpParser::HtmlClose:
      case PhpParser::HtmlSlashClose:
      case PhpParser::HtmlSlash:
      case PhpParser::HtmlEquals:
      case PhpParser::HtmlStartQuoteString:
      case PhpParser::HtmlStartDoubleQuoteString:
      case PhpParser::HtmlHex:
      case PhpParser::HtmlDecimal:
      case PhpParser::HtmlName:
      case PhpParser::HtmlEndQuoteString:
      case PhpParser::HtmlQuoteString:
      case PhpParser::HtmlEndDoubleQuoteString:
      case PhpParser::HtmlDoubleQuoteString:
      case PhpParser::ScriptText:
      case PhpParser::HtmlScriptClose:
      case PhpParser::StyleBody:
      case PhpParser::Abstract:
      case PhpParser::Array:
      case PhpParser::As:
      case PhpParser::BinaryCast:
      case PhpParser::BoolType:
      case PhpParser::BooleanConstant:
      case PhpParser::Break:
      case PhpParser::Callable:
      case PhpParser::Case:
      case PhpParser::Catch:
      case PhpParser::Class:
      case PhpParser::Clone:
      case PhpParser::Const:
      case PhpParser::Continue:
      case PhpParser::Declare:
      case PhpParser::Default:
      case PhpParser::Do:
      case PhpParser::DoubleCast:
      case PhpParser::DoubleType:
      case PhpParser::Echo:
      case PhpParser::Else:
      case PhpParser::ElseIf:
      case PhpParser::Empty:
      case PhpParser::Enum_:
      case PhpParser::EndDeclare:
      case PhpParser::EndFor:
      case PhpParser::EndForeach:
      case PhpParser::EndIf:
      case PhpParser::EndSwitch:
      case PhpParser::EndWhile:
      case PhpParser::Eval:
      case PhpParser::Exit:
      case PhpParser::Extends:
      case PhpParser::Final:
      case PhpParser::Finally:
      case PhpParser::FloatCast:
      case PhpParser::For:
      case PhpParser::Foreach:
      case PhpParser::Function_:
      case PhpParser::Global:
      case PhpParser::Goto:
      case PhpParser::If:
      case PhpParser::Implements:
      case PhpParser::Import:
      case PhpParser::Include:
      case PhpParser::IncludeOnce:
      case PhpParser::InstanceOf:
      case PhpParser::InsteadOf:
      case PhpParser::Int8Cast:
      case PhpParser::Int16Cast:
      case PhpParser::Int64Type:
      case PhpParser::IntType:
      case PhpParser::Interface:
      case PhpParser::IsSet:
      case PhpParser::List:
      case PhpParser::LogicalAnd:
      case PhpParser::LogicalOr:
      case PhpParser::LogicalXor:
      case PhpParser::Match_:
      case PhpParser::Namespace:
      case PhpParser::New:
      case PhpParser::Null:
      case PhpParser::ObjectType:
      case PhpParser::Parent_:
      case PhpParser::Partial:
      case PhpParser::Print:
      case PhpParser::Private:
      case PhpParser::Protected:
      case PhpParser::Public:
      case PhpParser::Readonly:
      case PhpParser::Require:
      case PhpParser::RequireOnce:
      case PhpParser::Resource:
      case PhpParser::Return:
      case PhpParser::Static:
      case PhpParser::StringType:
      case PhpParser::Switch:
      case PhpParser::Throw:
      case PhpParser::Trait:
      case PhpParser::Try:
      case PhpParser::Typeof:
      case PhpParser::UintCast:
      case PhpParser::UnicodeCast:
      case PhpParser::Unset:
      case PhpParser::Use:
      case PhpParser::Var:
      case PhpParser::While:
      case PhpParser::Yield:
      case PhpParser::From:
      case PhpParser::LambdaFn:
      case PhpParser::Ticks:
      case PhpParser::Encoding:
      case PhpParser::StrictTypes:
      case PhpParser::Get:
      case PhpParser::Set:
      case PhpParser::Call:
      case PhpParser::CallStatic:
      case PhpParser::Constructor:
      case PhpParser::Destruct:
      case PhpParser::Wakeup:
      case PhpParser::Sleep:
      case PhpParser::Autoload:
      case PhpParser::IsSet__:
      case PhpParser::Unset__:
      case PhpParser::ToString__:
      case PhpParser::Invoke:
      case PhpParser::SetState:
      case PhpParser::Clone__:
      case PhpParser::DebugInfo:
      case PhpParser::Namespace__:
      case PhpParser::Class__:
      case PhpParser::Traic__:
      case PhpParser::Function__:
      case PhpParser::Method__:
      case PhpParser::Line__:
      case PhpParser::File__:
      case PhpParser::Dir__:
      case PhpParser::Inc:
      case PhpParser::Dec:
      case PhpParser::NamespaceSeparator:
      case PhpParser::Bang:
      case PhpParser::Plus:
      case PhpParser::Minus:
      case PhpParser::Tilde:
      case PhpParser::SuppressWarnings:
      case PhpParser::Dollar:
      case PhpParser::OpenRoundBracket:
      case PhpParser::OpenSquareBracket:
      case PhpParser::OpenCurlyBracket:
      case PhpParser::SemiColon:
      case PhpParser::VarName:
      case PhpParser::Label:
      case PhpParser::Octal:
      case PhpParser::Decimal:
      case PhpParser::Real:
      case PhpParser::Hex:
      case PhpParser::Binary:
      case PhpParser::BackQuoteString:
      case PhpParser::SingleQuoteString:
      case PhpParser::DoubleQuote:
      case PhpParser::StartNowDoc:
      case PhpParser::StartHereDoc: {
        setState(685);
        statement();
        break;
      }

      case PhpParser::Colon: {
        setState(686);
        match(PhpParser::Colon);
        setState(687);
        innerStatementList();
        setState(688);
        match(PhpParser::EndFor);
        setState(689);
        match(PhpParser::SemiColon);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForInitContext ------------------------------------------------------------------

PhpParser::ForInitContext::ForInitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::ExpressionListContext* PhpParser::ForInitContext::expressionList() {
  return getRuleContext<PhpParser::ExpressionListContext>(0);
}


size_t PhpParser::ForInitContext::getRuleIndex() const {
  return PhpParser::RuleForInit;
}

void PhpParser::ForInitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForInit(this);
}

void PhpParser::ForInitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForInit(this);
}

PhpParser::ForInitContext* PhpParser::forInit() {
  ForInitContext *_localctx = _tracker.createInstance<ForInitContext>(_ctx, getState());
  enterRule(_localctx, 76, PhpParser::RuleForInit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(693);
    expressionList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForUpdateContext ------------------------------------------------------------------

PhpParser::ForUpdateContext::ForUpdateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::ExpressionListContext* PhpParser::ForUpdateContext::expressionList() {
  return getRuleContext<PhpParser::ExpressionListContext>(0);
}


size_t PhpParser::ForUpdateContext::getRuleIndex() const {
  return PhpParser::RuleForUpdate;
}

void PhpParser::ForUpdateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForUpdate(this);
}

void PhpParser::ForUpdateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForUpdate(this);
}

PhpParser::ForUpdateContext* PhpParser::forUpdate() {
  ForUpdateContext *_localctx = _tracker.createInstance<ForUpdateContext>(_ctx, getState());
  enterRule(_localctx, 78, PhpParser::RuleForUpdate);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(695);
    expressionList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SwitchStatementContext ------------------------------------------------------------------

PhpParser::SwitchStatementContext::SwitchStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::SwitchStatementContext::Switch() {
  return getToken(PhpParser::Switch, 0);
}

PhpParser::ParenthesesContext* PhpParser::SwitchStatementContext::parentheses() {
  return getRuleContext<PhpParser::ParenthesesContext>(0);
}

tree::TerminalNode* PhpParser::SwitchStatementContext::OpenCurlyBracket() {
  return getToken(PhpParser::OpenCurlyBracket, 0);
}

tree::TerminalNode* PhpParser::SwitchStatementContext::CloseCurlyBracket() {
  return getToken(PhpParser::CloseCurlyBracket, 0);
}

tree::TerminalNode* PhpParser::SwitchStatementContext::Colon() {
  return getToken(PhpParser::Colon, 0);
}

tree::TerminalNode* PhpParser::SwitchStatementContext::EndSwitch() {
  return getToken(PhpParser::EndSwitch, 0);
}

std::vector<tree::TerminalNode *> PhpParser::SwitchStatementContext::SemiColon() {
  return getTokens(PhpParser::SemiColon);
}

tree::TerminalNode* PhpParser::SwitchStatementContext::SemiColon(size_t i) {
  return getToken(PhpParser::SemiColon, i);
}

std::vector<PhpParser::SwitchBlockContext *> PhpParser::SwitchStatementContext::switchBlock() {
  return getRuleContexts<PhpParser::SwitchBlockContext>();
}

PhpParser::SwitchBlockContext* PhpParser::SwitchStatementContext::switchBlock(size_t i) {
  return getRuleContext<PhpParser::SwitchBlockContext>(i);
}


size_t PhpParser::SwitchStatementContext::getRuleIndex() const {
  return PhpParser::RuleSwitchStatement;
}

void PhpParser::SwitchStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitchStatement(this);
}

void PhpParser::SwitchStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitchStatement(this);
}

PhpParser::SwitchStatementContext* PhpParser::switchStatement() {
  SwitchStatementContext *_localctx = _tracker.createInstance<SwitchStatementContext>(_ctx, getState());
  enterRule(_localctx, 80, PhpParser::RuleSwitchStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(697);
    match(PhpParser::Switch);
    setState(698);
    parentheses();
    setState(722);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::OpenCurlyBracket: {
        setState(699);
        match(PhpParser::OpenCurlyBracket);
        setState(701);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::SemiColon) {
          setState(700);
          match(PhpParser::SemiColon);
        }
        setState(706);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == PhpParser::Case

        || _la == PhpParser::Default) {
          setState(703);
          switchBlock();
          setState(708);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(709);
        match(PhpParser::CloseCurlyBracket);
        break;
      }

      case PhpParser::Colon: {
        setState(710);
        match(PhpParser::Colon);
        setState(712);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::SemiColon) {
          setState(711);
          match(PhpParser::SemiColon);
        }
        setState(717);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == PhpParser::Case

        || _la == PhpParser::Default) {
          setState(714);
          switchBlock();
          setState(719);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(720);
        match(PhpParser::EndSwitch);
        setState(721);
        match(PhpParser::SemiColon);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SwitchBlockContext ------------------------------------------------------------------

PhpParser::SwitchBlockContext::SwitchBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::InnerStatementListContext* PhpParser::SwitchBlockContext::innerStatementList() {
  return getRuleContext<PhpParser::InnerStatementListContext>(0);
}

std::vector<tree::TerminalNode *> PhpParser::SwitchBlockContext::Colon() {
  return getTokens(PhpParser::Colon);
}

tree::TerminalNode* PhpParser::SwitchBlockContext::Colon(size_t i) {
  return getToken(PhpParser::Colon, i);
}

std::vector<tree::TerminalNode *> PhpParser::SwitchBlockContext::SemiColon() {
  return getTokens(PhpParser::SemiColon);
}

tree::TerminalNode* PhpParser::SwitchBlockContext::SemiColon(size_t i) {
  return getToken(PhpParser::SemiColon, i);
}

std::vector<tree::TerminalNode *> PhpParser::SwitchBlockContext::Case() {
  return getTokens(PhpParser::Case);
}

tree::TerminalNode* PhpParser::SwitchBlockContext::Case(size_t i) {
  return getToken(PhpParser::Case, i);
}

std::vector<PhpParser::ExpressionContext *> PhpParser::SwitchBlockContext::expression() {
  return getRuleContexts<PhpParser::ExpressionContext>();
}

PhpParser::ExpressionContext* PhpParser::SwitchBlockContext::expression(size_t i) {
  return getRuleContext<PhpParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> PhpParser::SwitchBlockContext::Default() {
  return getTokens(PhpParser::Default);
}

tree::TerminalNode* PhpParser::SwitchBlockContext::Default(size_t i) {
  return getToken(PhpParser::Default, i);
}


size_t PhpParser::SwitchBlockContext::getRuleIndex() const {
  return PhpParser::RuleSwitchBlock;
}

void PhpParser::SwitchBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitchBlock(this);
}

void PhpParser::SwitchBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitchBlock(this);
}

PhpParser::SwitchBlockContext* PhpParser::switchBlock() {
  SwitchBlockContext *_localctx = _tracker.createInstance<SwitchBlockContext>(_ctx, getState());
  enterRule(_localctx, 82, PhpParser::RuleSwitchBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(730); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(727);
              _errHandler->sync(this);
              switch (_input->LA(1)) {
                case PhpParser::Case: {
                  setState(724);
                  match(PhpParser::Case);
                  setState(725);
                  expression(0);
                  break;
                }

                case PhpParser::Default: {
                  setState(726);
                  match(PhpParser::Default);
                  break;
                }

              default:
                throw NoViableAltException(this);
              }
              setState(729);
              _la = _input->LA(1);
              if (!(_la == PhpParser::Colon

              || _la == PhpParser::SemiColon)) {
              _errHandler->recoverInline(this);
              }
              else {
                _errHandler->reportMatch(this);
                consume();
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(732); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(734);
    innerStatementList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BreakStatementContext ------------------------------------------------------------------

PhpParser::BreakStatementContext::BreakStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::BreakStatementContext::Break() {
  return getToken(PhpParser::Break, 0);
}

tree::TerminalNode* PhpParser::BreakStatementContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}

PhpParser::ExpressionContext* PhpParser::BreakStatementContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}


size_t PhpParser::BreakStatementContext::getRuleIndex() const {
  return PhpParser::RuleBreakStatement;
}

void PhpParser::BreakStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBreakStatement(this);
}

void PhpParser::BreakStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBreakStatement(this);
}

PhpParser::BreakStatementContext* PhpParser::breakStatement() {
  BreakStatementContext *_localctx = _tracker.createInstance<BreakStatementContext>(_ctx, getState());
  enterRule(_localctx, 84, PhpParser::RuleBreakStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(736);
    match(PhpParser::Break);
    setState(738);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 44) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 44)) & -1) != 0) || ((((_la - 108) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 108)) & 441352763482308607) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 194)) & 4396974138177) != 0)) {
      setState(737);
      expression(0);
    }
    setState(740);
    match(PhpParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ContinueStatementContext ------------------------------------------------------------------

PhpParser::ContinueStatementContext::ContinueStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::ContinueStatementContext::Continue() {
  return getToken(PhpParser::Continue, 0);
}

tree::TerminalNode* PhpParser::ContinueStatementContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}

PhpParser::ExpressionContext* PhpParser::ContinueStatementContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}


size_t PhpParser::ContinueStatementContext::getRuleIndex() const {
  return PhpParser::RuleContinueStatement;
}

void PhpParser::ContinueStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContinueStatement(this);
}

void PhpParser::ContinueStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContinueStatement(this);
}

PhpParser::ContinueStatementContext* PhpParser::continueStatement() {
  ContinueStatementContext *_localctx = _tracker.createInstance<ContinueStatementContext>(_ctx, getState());
  enterRule(_localctx, 86, PhpParser::RuleContinueStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(742);
    match(PhpParser::Continue);
    setState(744);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 44) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 44)) & -1) != 0) || ((((_la - 108) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 108)) & 441352763482308607) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 194)) & 4396974138177) != 0)) {
      setState(743);
      expression(0);
    }
    setState(746);
    match(PhpParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnStatementContext ------------------------------------------------------------------

PhpParser::ReturnStatementContext::ReturnStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::ReturnStatementContext::Return() {
  return getToken(PhpParser::Return, 0);
}

tree::TerminalNode* PhpParser::ReturnStatementContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}

PhpParser::ExpressionContext* PhpParser::ReturnStatementContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}


size_t PhpParser::ReturnStatementContext::getRuleIndex() const {
  return PhpParser::RuleReturnStatement;
}

void PhpParser::ReturnStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnStatement(this);
}

void PhpParser::ReturnStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnStatement(this);
}

PhpParser::ReturnStatementContext* PhpParser::returnStatement() {
  ReturnStatementContext *_localctx = _tracker.createInstance<ReturnStatementContext>(_ctx, getState());
  enterRule(_localctx, 88, PhpParser::RuleReturnStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(748);
    match(PhpParser::Return);
    setState(750);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 44) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 44)) & -1) != 0) || ((((_la - 108) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 108)) & 441352763482308607) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 194)) & 4396974138177) != 0)) {
      setState(749);
      expression(0);
    }
    setState(752);
    match(PhpParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionStatementContext ------------------------------------------------------------------

PhpParser::ExpressionStatementContext::ExpressionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::ExpressionContext* PhpParser::ExpressionStatementContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

tree::TerminalNode* PhpParser::ExpressionStatementContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}


size_t PhpParser::ExpressionStatementContext::getRuleIndex() const {
  return PhpParser::RuleExpressionStatement;
}

void PhpParser::ExpressionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionStatement(this);
}

void PhpParser::ExpressionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionStatement(this);
}

PhpParser::ExpressionStatementContext* PhpParser::expressionStatement() {
  ExpressionStatementContext *_localctx = _tracker.createInstance<ExpressionStatementContext>(_ctx, getState());
  enterRule(_localctx, 90, PhpParser::RuleExpressionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(754);
    expression(0);
    setState(755);
    match(PhpParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnsetStatementContext ------------------------------------------------------------------

PhpParser::UnsetStatementContext::UnsetStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::UnsetStatementContext::Unset() {
  return getToken(PhpParser::Unset, 0);
}

tree::TerminalNode* PhpParser::UnsetStatementContext::OpenRoundBracket() {
  return getToken(PhpParser::OpenRoundBracket, 0);
}

PhpParser::ChainListContext* PhpParser::UnsetStatementContext::chainList() {
  return getRuleContext<PhpParser::ChainListContext>(0);
}

tree::TerminalNode* PhpParser::UnsetStatementContext::CloseRoundBracket() {
  return getToken(PhpParser::CloseRoundBracket, 0);
}

tree::TerminalNode* PhpParser::UnsetStatementContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}


size_t PhpParser::UnsetStatementContext::getRuleIndex() const {
  return PhpParser::RuleUnsetStatement;
}

void PhpParser::UnsetStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnsetStatement(this);
}

void PhpParser::UnsetStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnsetStatement(this);
}

PhpParser::UnsetStatementContext* PhpParser::unsetStatement() {
  UnsetStatementContext *_localctx = _tracker.createInstance<UnsetStatementContext>(_ctx, getState());
  enterRule(_localctx, 92, PhpParser::RuleUnsetStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(757);
    match(PhpParser::Unset);
    setState(758);
    match(PhpParser::OpenRoundBracket);
    setState(759);
    chainList();
    setState(760);
    match(PhpParser::CloseRoundBracket);
    setState(761);
    match(PhpParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForeachStatementContext ------------------------------------------------------------------

PhpParser::ForeachStatementContext::ForeachStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::ForeachStatementContext::Foreach() {
  return getToken(PhpParser::Foreach, 0);
}

std::vector<tree::TerminalNode *> PhpParser::ForeachStatementContext::OpenRoundBracket() {
  return getTokens(PhpParser::OpenRoundBracket);
}

tree::TerminalNode* PhpParser::ForeachStatementContext::OpenRoundBracket(size_t i) {
  return getToken(PhpParser::OpenRoundBracket, i);
}

PhpParser::ExpressionContext* PhpParser::ForeachStatementContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

tree::TerminalNode* PhpParser::ForeachStatementContext::As() {
  return getToken(PhpParser::As, 0);
}

PhpParser::ArrayDestructuringContext* PhpParser::ForeachStatementContext::arrayDestructuring() {
  return getRuleContext<PhpParser::ArrayDestructuringContext>(0);
}

std::vector<tree::TerminalNode *> PhpParser::ForeachStatementContext::CloseRoundBracket() {
  return getTokens(PhpParser::CloseRoundBracket);
}

tree::TerminalNode* PhpParser::ForeachStatementContext::CloseRoundBracket(size_t i) {
  return getToken(PhpParser::CloseRoundBracket, i);
}

std::vector<PhpParser::ChainContext *> PhpParser::ForeachStatementContext::chain() {
  return getRuleContexts<PhpParser::ChainContext>();
}

PhpParser::ChainContext* PhpParser::ForeachStatementContext::chain(size_t i) {
  return getRuleContext<PhpParser::ChainContext>(i);
}

PhpParser::AssignableContext* PhpParser::ForeachStatementContext::assignable() {
  return getRuleContext<PhpParser::AssignableContext>(0);
}

tree::TerminalNode* PhpParser::ForeachStatementContext::List() {
  return getToken(PhpParser::List, 0);
}

PhpParser::AssignmentListContext* PhpParser::ForeachStatementContext::assignmentList() {
  return getRuleContext<PhpParser::AssignmentListContext>(0);
}

PhpParser::StatementContext* PhpParser::ForeachStatementContext::statement() {
  return getRuleContext<PhpParser::StatementContext>(0);
}

tree::TerminalNode* PhpParser::ForeachStatementContext::Colon() {
  return getToken(PhpParser::Colon, 0);
}

PhpParser::InnerStatementListContext* PhpParser::ForeachStatementContext::innerStatementList() {
  return getRuleContext<PhpParser::InnerStatementListContext>(0);
}

tree::TerminalNode* PhpParser::ForeachStatementContext::EndForeach() {
  return getToken(PhpParser::EndForeach, 0);
}

tree::TerminalNode* PhpParser::ForeachStatementContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}

std::vector<tree::TerminalNode *> PhpParser::ForeachStatementContext::Ampersand() {
  return getTokens(PhpParser::Ampersand);
}

tree::TerminalNode* PhpParser::ForeachStatementContext::Ampersand(size_t i) {
  return getToken(PhpParser::Ampersand, i);
}

tree::TerminalNode* PhpParser::ForeachStatementContext::DoubleArrow() {
  return getToken(PhpParser::DoubleArrow, 0);
}


size_t PhpParser::ForeachStatementContext::getRuleIndex() const {
  return PhpParser::RuleForeachStatement;
}

void PhpParser::ForeachStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForeachStatement(this);
}

void PhpParser::ForeachStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForeachStatement(this);
}

PhpParser::ForeachStatementContext* PhpParser::foreachStatement() {
  ForeachStatementContext *_localctx = _tracker.createInstance<ForeachStatementContext>(_ctx, getState());
  enterRule(_localctx, 94, PhpParser::RuleForeachStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(763);
    match(PhpParser::Foreach);
    setState(808);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
    case 1: {
      setState(764);
      match(PhpParser::OpenRoundBracket);
      setState(765);
      expression(0);
      setState(766);
      match(PhpParser::As);
      setState(767);
      arrayDestructuring();
      setState(768);
      match(PhpParser::CloseRoundBracket);
      break;
    }

    case 2: {
      setState(770);
      match(PhpParser::OpenRoundBracket);
      setState(771);
      chain();
      setState(772);
      match(PhpParser::As);
      setState(774);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PhpParser::Ampersand) {
        setState(773);
        match(PhpParser::Ampersand);
      }
      setState(776);
      assignable();
      setState(782);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PhpParser::DoubleArrow) {
        setState(777);
        match(PhpParser::DoubleArrow);
        setState(779);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Ampersand) {
          setState(778);
          match(PhpParser::Ampersand);
        }
        setState(781);
        chain();
      }
      setState(784);
      match(PhpParser::CloseRoundBracket);
      break;
    }

    case 3: {
      setState(786);
      match(PhpParser::OpenRoundBracket);
      setState(787);
      expression(0);
      setState(788);
      match(PhpParser::As);
      setState(789);
      assignable();
      setState(795);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PhpParser::DoubleArrow) {
        setState(790);
        match(PhpParser::DoubleArrow);
        setState(792);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Ampersand) {
          setState(791);
          match(PhpParser::Ampersand);
        }
        setState(794);
        chain();
      }
      setState(797);
      match(PhpParser::CloseRoundBracket);
      break;
    }

    case 4: {
      setState(799);
      match(PhpParser::OpenRoundBracket);
      setState(800);
      chain();
      setState(801);
      match(PhpParser::As);
      setState(802);
      match(PhpParser::List);
      setState(803);
      match(PhpParser::OpenRoundBracket);
      setState(804);
      assignmentList();
      setState(805);
      match(PhpParser::CloseRoundBracket);
      setState(806);
      match(PhpParser::CloseRoundBracket);
      break;
    }

    default:
      break;
    }
    setState(816);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::HtmlText:
      case PhpParser::XmlStart:
      case PhpParser::HtmlScriptOpen:
      case PhpParser::HtmlStyleOpen:
      case PhpParser::HtmlDtd:
      case PhpParser::HtmlOpen:
      case PhpParser::HtmlClose:
      case PhpParser::HtmlSlashClose:
      case PhpParser::HtmlSlash:
      case PhpParser::HtmlEquals:
      case PhpParser::HtmlStartQuoteString:
      case PhpParser::HtmlStartDoubleQuoteString:
      case PhpParser::HtmlHex:
      case PhpParser::HtmlDecimal:
      case PhpParser::HtmlName:
      case PhpParser::HtmlEndQuoteString:
      case PhpParser::HtmlQuoteString:
      case PhpParser::HtmlEndDoubleQuoteString:
      case PhpParser::HtmlDoubleQuoteString:
      case PhpParser::ScriptText:
      case PhpParser::HtmlScriptClose:
      case PhpParser::StyleBody:
      case PhpParser::Abstract:
      case PhpParser::Array:
      case PhpParser::As:
      case PhpParser::BinaryCast:
      case PhpParser::BoolType:
      case PhpParser::BooleanConstant:
      case PhpParser::Break:
      case PhpParser::Callable:
      case PhpParser::Case:
      case PhpParser::Catch:
      case PhpParser::Class:
      case PhpParser::Clone:
      case PhpParser::Const:
      case PhpParser::Continue:
      case PhpParser::Declare:
      case PhpParser::Default:
      case PhpParser::Do:
      case PhpParser::DoubleCast:
      case PhpParser::DoubleType:
      case PhpParser::Echo:
      case PhpParser::Else:
      case PhpParser::ElseIf:
      case PhpParser::Empty:
      case PhpParser::Enum_:
      case PhpParser::EndDeclare:
      case PhpParser::EndFor:
      case PhpParser::EndForeach:
      case PhpParser::EndIf:
      case PhpParser::EndSwitch:
      case PhpParser::EndWhile:
      case PhpParser::Eval:
      case PhpParser::Exit:
      case PhpParser::Extends:
      case PhpParser::Final:
      case PhpParser::Finally:
      case PhpParser::FloatCast:
      case PhpParser::For:
      case PhpParser::Foreach:
      case PhpParser::Function_:
      case PhpParser::Global:
      case PhpParser::Goto:
      case PhpParser::If:
      case PhpParser::Implements:
      case PhpParser::Import:
      case PhpParser::Include:
      case PhpParser::IncludeOnce:
      case PhpParser::InstanceOf:
      case PhpParser::InsteadOf:
      case PhpParser::Int8Cast:
      case PhpParser::Int16Cast:
      case PhpParser::Int64Type:
      case PhpParser::IntType:
      case PhpParser::Interface:
      case PhpParser::IsSet:
      case PhpParser::List:
      case PhpParser::LogicalAnd:
      case PhpParser::LogicalOr:
      case PhpParser::LogicalXor:
      case PhpParser::Match_:
      case PhpParser::Namespace:
      case PhpParser::New:
      case PhpParser::Null:
      case PhpParser::ObjectType:
      case PhpParser::Parent_:
      case PhpParser::Partial:
      case PhpParser::Print:
      case PhpParser::Private:
      case PhpParser::Protected:
      case PhpParser::Public:
      case PhpParser::Readonly:
      case PhpParser::Require:
      case PhpParser::RequireOnce:
      case PhpParser::Resource:
      case PhpParser::Return:
      case PhpParser::Static:
      case PhpParser::StringType:
      case PhpParser::Switch:
      case PhpParser::Throw:
      case PhpParser::Trait:
      case PhpParser::Try:
      case PhpParser::Typeof:
      case PhpParser::UintCast:
      case PhpParser::UnicodeCast:
      case PhpParser::Unset:
      case PhpParser::Use:
      case PhpParser::Var:
      case PhpParser::While:
      case PhpParser::Yield:
      case PhpParser::From:
      case PhpParser::LambdaFn:
      case PhpParser::Ticks:
      case PhpParser::Encoding:
      case PhpParser::StrictTypes:
      case PhpParser::Get:
      case PhpParser::Set:
      case PhpParser::Call:
      case PhpParser::CallStatic:
      case PhpParser::Constructor:
      case PhpParser::Destruct:
      case PhpParser::Wakeup:
      case PhpParser::Sleep:
      case PhpParser::Autoload:
      case PhpParser::IsSet__:
      case PhpParser::Unset__:
      case PhpParser::ToString__:
      case PhpParser::Invoke:
      case PhpParser::SetState:
      case PhpParser::Clone__:
      case PhpParser::DebugInfo:
      case PhpParser::Namespace__:
      case PhpParser::Class__:
      case PhpParser::Traic__:
      case PhpParser::Function__:
      case PhpParser::Method__:
      case PhpParser::Line__:
      case PhpParser::File__:
      case PhpParser::Dir__:
      case PhpParser::Inc:
      case PhpParser::Dec:
      case PhpParser::NamespaceSeparator:
      case PhpParser::Bang:
      case PhpParser::Plus:
      case PhpParser::Minus:
      case PhpParser::Tilde:
      case PhpParser::SuppressWarnings:
      case PhpParser::Dollar:
      case PhpParser::OpenRoundBracket:
      case PhpParser::OpenSquareBracket:
      case PhpParser::OpenCurlyBracket:
      case PhpParser::SemiColon:
      case PhpParser::VarName:
      case PhpParser::Label:
      case PhpParser::Octal:
      case PhpParser::Decimal:
      case PhpParser::Real:
      case PhpParser::Hex:
      case PhpParser::Binary:
      case PhpParser::BackQuoteString:
      case PhpParser::SingleQuoteString:
      case PhpParser::DoubleQuote:
      case PhpParser::StartNowDoc:
      case PhpParser::StartHereDoc: {
        setState(810);
        statement();
        break;
      }

      case PhpParser::Colon: {
        setState(811);
        match(PhpParser::Colon);
        setState(812);
        innerStatementList();
        setState(813);
        match(PhpParser::EndForeach);
        setState(814);
        match(PhpParser::SemiColon);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TryCatchFinallyContext ------------------------------------------------------------------

PhpParser::TryCatchFinallyContext::TryCatchFinallyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::TryCatchFinallyContext::Try() {
  return getToken(PhpParser::Try, 0);
}

PhpParser::BlockStatementContext* PhpParser::TryCatchFinallyContext::blockStatement() {
  return getRuleContext<PhpParser::BlockStatementContext>(0);
}

PhpParser::FinallyStatementContext* PhpParser::TryCatchFinallyContext::finallyStatement() {
  return getRuleContext<PhpParser::FinallyStatementContext>(0);
}

std::vector<PhpParser::CatchClauseContext *> PhpParser::TryCatchFinallyContext::catchClause() {
  return getRuleContexts<PhpParser::CatchClauseContext>();
}

PhpParser::CatchClauseContext* PhpParser::TryCatchFinallyContext::catchClause(size_t i) {
  return getRuleContext<PhpParser::CatchClauseContext>(i);
}


size_t PhpParser::TryCatchFinallyContext::getRuleIndex() const {
  return PhpParser::RuleTryCatchFinally;
}

void PhpParser::TryCatchFinallyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTryCatchFinally(this);
}

void PhpParser::TryCatchFinallyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTryCatchFinally(this);
}

PhpParser::TryCatchFinallyContext* PhpParser::tryCatchFinally() {
  TryCatchFinallyContext *_localctx = _tracker.createInstance<TryCatchFinallyContext>(_ctx, getState());
  enterRule(_localctx, 96, PhpParser::RuleTryCatchFinally);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(818);
    match(PhpParser::Try);
    setState(819);
    blockStatement();
    setState(835);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx)) {
    case 1: {
      setState(821); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(820);
                catchClause();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(823); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(826);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx)) {
      case 1: {
        setState(825);
        finallyStatement();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      setState(831);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == PhpParser::Catch) {
        setState(828);
        catchClause();
        setState(833);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(834);
      finallyStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CatchClauseContext ------------------------------------------------------------------

PhpParser::CatchClauseContext::CatchClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::CatchClauseContext::Catch() {
  return getToken(PhpParser::Catch, 0);
}

tree::TerminalNode* PhpParser::CatchClauseContext::OpenRoundBracket() {
  return getToken(PhpParser::OpenRoundBracket, 0);
}

std::vector<PhpParser::QualifiedStaticTypeRefContext *> PhpParser::CatchClauseContext::qualifiedStaticTypeRef() {
  return getRuleContexts<PhpParser::QualifiedStaticTypeRefContext>();
}

PhpParser::QualifiedStaticTypeRefContext* PhpParser::CatchClauseContext::qualifiedStaticTypeRef(size_t i) {
  return getRuleContext<PhpParser::QualifiedStaticTypeRefContext>(i);
}

tree::TerminalNode* PhpParser::CatchClauseContext::CloseRoundBracket() {
  return getToken(PhpParser::CloseRoundBracket, 0);
}

PhpParser::BlockStatementContext* PhpParser::CatchClauseContext::blockStatement() {
  return getRuleContext<PhpParser::BlockStatementContext>(0);
}

std::vector<tree::TerminalNode *> PhpParser::CatchClauseContext::Pipe() {
  return getTokens(PhpParser::Pipe);
}

tree::TerminalNode* PhpParser::CatchClauseContext::Pipe(size_t i) {
  return getToken(PhpParser::Pipe, i);
}

tree::TerminalNode* PhpParser::CatchClauseContext::VarName() {
  return getToken(PhpParser::VarName, 0);
}


size_t PhpParser::CatchClauseContext::getRuleIndex() const {
  return PhpParser::RuleCatchClause;
}

void PhpParser::CatchClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCatchClause(this);
}

void PhpParser::CatchClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCatchClause(this);
}

PhpParser::CatchClauseContext* PhpParser::catchClause() {
  CatchClauseContext *_localctx = _tracker.createInstance<CatchClauseContext>(_ctx, getState());
  enterRule(_localctx, 98, PhpParser::RuleCatchClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(837);
    match(PhpParser::Catch);
    setState(838);
    match(PhpParser::OpenRoundBracket);
    setState(839);
    qualifiedStaticTypeRef();
    setState(844);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PhpParser::Pipe) {
      setState(840);
      match(PhpParser::Pipe);
      setState(841);
      qualifiedStaticTypeRef();
      setState(846);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(848);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::VarName) {
      setState(847);
      match(PhpParser::VarName);
    }
    setState(850);
    match(PhpParser::CloseRoundBracket);
    setState(851);
    blockStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FinallyStatementContext ------------------------------------------------------------------

PhpParser::FinallyStatementContext::FinallyStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::FinallyStatementContext::Finally() {
  return getToken(PhpParser::Finally, 0);
}

PhpParser::BlockStatementContext* PhpParser::FinallyStatementContext::blockStatement() {
  return getRuleContext<PhpParser::BlockStatementContext>(0);
}


size_t PhpParser::FinallyStatementContext::getRuleIndex() const {
  return PhpParser::RuleFinallyStatement;
}

void PhpParser::FinallyStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFinallyStatement(this);
}

void PhpParser::FinallyStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFinallyStatement(this);
}

PhpParser::FinallyStatementContext* PhpParser::finallyStatement() {
  FinallyStatementContext *_localctx = _tracker.createInstance<FinallyStatementContext>(_ctx, getState());
  enterRule(_localctx, 100, PhpParser::RuleFinallyStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(853);
    match(PhpParser::Finally);
    setState(854);
    blockStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThrowStatementContext ------------------------------------------------------------------

PhpParser::ThrowStatementContext::ThrowStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::ThrowStatementContext::Throw() {
  return getToken(PhpParser::Throw, 0);
}

PhpParser::ExpressionContext* PhpParser::ThrowStatementContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

tree::TerminalNode* PhpParser::ThrowStatementContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}


size_t PhpParser::ThrowStatementContext::getRuleIndex() const {
  return PhpParser::RuleThrowStatement;
}

void PhpParser::ThrowStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrowStatement(this);
}

void PhpParser::ThrowStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrowStatement(this);
}

PhpParser::ThrowStatementContext* PhpParser::throwStatement() {
  ThrowStatementContext *_localctx = _tracker.createInstance<ThrowStatementContext>(_ctx, getState());
  enterRule(_localctx, 102, PhpParser::RuleThrowStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(856);
    match(PhpParser::Throw);
    setState(857);
    expression(0);
    setState(858);
    match(PhpParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GotoStatementContext ------------------------------------------------------------------

PhpParser::GotoStatementContext::GotoStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::GotoStatementContext::Goto() {
  return getToken(PhpParser::Goto, 0);
}

PhpParser::IdentifierContext* PhpParser::GotoStatementContext::identifier() {
  return getRuleContext<PhpParser::IdentifierContext>(0);
}

tree::TerminalNode* PhpParser::GotoStatementContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}


size_t PhpParser::GotoStatementContext::getRuleIndex() const {
  return PhpParser::RuleGotoStatement;
}

void PhpParser::GotoStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGotoStatement(this);
}

void PhpParser::GotoStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGotoStatement(this);
}

PhpParser::GotoStatementContext* PhpParser::gotoStatement() {
  GotoStatementContext *_localctx = _tracker.createInstance<GotoStatementContext>(_ctx, getState());
  enterRule(_localctx, 104, PhpParser::RuleGotoStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(860);
    match(PhpParser::Goto);
    setState(861);
    identifier();
    setState(862);
    match(PhpParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclareStatementContext ------------------------------------------------------------------

PhpParser::DeclareStatementContext::DeclareStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::DeclareStatementContext::Declare() {
  return getToken(PhpParser::Declare, 0);
}

tree::TerminalNode* PhpParser::DeclareStatementContext::OpenRoundBracket() {
  return getToken(PhpParser::OpenRoundBracket, 0);
}

PhpParser::DeclareListContext* PhpParser::DeclareStatementContext::declareList() {
  return getRuleContext<PhpParser::DeclareListContext>(0);
}

tree::TerminalNode* PhpParser::DeclareStatementContext::CloseRoundBracket() {
  return getToken(PhpParser::CloseRoundBracket, 0);
}

PhpParser::StatementContext* PhpParser::DeclareStatementContext::statement() {
  return getRuleContext<PhpParser::StatementContext>(0);
}

tree::TerminalNode* PhpParser::DeclareStatementContext::Colon() {
  return getToken(PhpParser::Colon, 0);
}

PhpParser::InnerStatementListContext* PhpParser::DeclareStatementContext::innerStatementList() {
  return getRuleContext<PhpParser::InnerStatementListContext>(0);
}

tree::TerminalNode* PhpParser::DeclareStatementContext::EndDeclare() {
  return getToken(PhpParser::EndDeclare, 0);
}

tree::TerminalNode* PhpParser::DeclareStatementContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}


size_t PhpParser::DeclareStatementContext::getRuleIndex() const {
  return PhpParser::RuleDeclareStatement;
}

void PhpParser::DeclareStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclareStatement(this);
}

void PhpParser::DeclareStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclareStatement(this);
}

PhpParser::DeclareStatementContext* PhpParser::declareStatement() {
  DeclareStatementContext *_localctx = _tracker.createInstance<DeclareStatementContext>(_ctx, getState());
  enterRule(_localctx, 106, PhpParser::RuleDeclareStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(864);
    match(PhpParser::Declare);
    setState(865);
    match(PhpParser::OpenRoundBracket);
    setState(866);
    declareList();
    setState(867);
    match(PhpParser::CloseRoundBracket);
    setState(874);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::HtmlText:
      case PhpParser::XmlStart:
      case PhpParser::HtmlScriptOpen:
      case PhpParser::HtmlStyleOpen:
      case PhpParser::HtmlDtd:
      case PhpParser::HtmlOpen:
      case PhpParser::HtmlClose:
      case PhpParser::HtmlSlashClose:
      case PhpParser::HtmlSlash:
      case PhpParser::HtmlEquals:
      case PhpParser::HtmlStartQuoteString:
      case PhpParser::HtmlStartDoubleQuoteString:
      case PhpParser::HtmlHex:
      case PhpParser::HtmlDecimal:
      case PhpParser::HtmlName:
      case PhpParser::HtmlEndQuoteString:
      case PhpParser::HtmlQuoteString:
      case PhpParser::HtmlEndDoubleQuoteString:
      case PhpParser::HtmlDoubleQuoteString:
      case PhpParser::ScriptText:
      case PhpParser::HtmlScriptClose:
      case PhpParser::StyleBody:
      case PhpParser::Abstract:
      case PhpParser::Array:
      case PhpParser::As:
      case PhpParser::BinaryCast:
      case PhpParser::BoolType:
      case PhpParser::BooleanConstant:
      case PhpParser::Break:
      case PhpParser::Callable:
      case PhpParser::Case:
      case PhpParser::Catch:
      case PhpParser::Class:
      case PhpParser::Clone:
      case PhpParser::Const:
      case PhpParser::Continue:
      case PhpParser::Declare:
      case PhpParser::Default:
      case PhpParser::Do:
      case PhpParser::DoubleCast:
      case PhpParser::DoubleType:
      case PhpParser::Echo:
      case PhpParser::Else:
      case PhpParser::ElseIf:
      case PhpParser::Empty:
      case PhpParser::Enum_:
      case PhpParser::EndDeclare:
      case PhpParser::EndFor:
      case PhpParser::EndForeach:
      case PhpParser::EndIf:
      case PhpParser::EndSwitch:
      case PhpParser::EndWhile:
      case PhpParser::Eval:
      case PhpParser::Exit:
      case PhpParser::Extends:
      case PhpParser::Final:
      case PhpParser::Finally:
      case PhpParser::FloatCast:
      case PhpParser::For:
      case PhpParser::Foreach:
      case PhpParser::Function_:
      case PhpParser::Global:
      case PhpParser::Goto:
      case PhpParser::If:
      case PhpParser::Implements:
      case PhpParser::Import:
      case PhpParser::Include:
      case PhpParser::IncludeOnce:
      case PhpParser::InstanceOf:
      case PhpParser::InsteadOf:
      case PhpParser::Int8Cast:
      case PhpParser::Int16Cast:
      case PhpParser::Int64Type:
      case PhpParser::IntType:
      case PhpParser::Interface:
      case PhpParser::IsSet:
      case PhpParser::List:
      case PhpParser::LogicalAnd:
      case PhpParser::LogicalOr:
      case PhpParser::LogicalXor:
      case PhpParser::Match_:
      case PhpParser::Namespace:
      case PhpParser::New:
      case PhpParser::Null:
      case PhpParser::ObjectType:
      case PhpParser::Parent_:
      case PhpParser::Partial:
      case PhpParser::Print:
      case PhpParser::Private:
      case PhpParser::Protected:
      case PhpParser::Public:
      case PhpParser::Readonly:
      case PhpParser::Require:
      case PhpParser::RequireOnce:
      case PhpParser::Resource:
      case PhpParser::Return:
      case PhpParser::Static:
      case PhpParser::StringType:
      case PhpParser::Switch:
      case PhpParser::Throw:
      case PhpParser::Trait:
      case PhpParser::Try:
      case PhpParser::Typeof:
      case PhpParser::UintCast:
      case PhpParser::UnicodeCast:
      case PhpParser::Unset:
      case PhpParser::Use:
      case PhpParser::Var:
      case PhpParser::While:
      case PhpParser::Yield:
      case PhpParser::From:
      case PhpParser::LambdaFn:
      case PhpParser::Ticks:
      case PhpParser::Encoding:
      case PhpParser::StrictTypes:
      case PhpParser::Get:
      case PhpParser::Set:
      case PhpParser::Call:
      case PhpParser::CallStatic:
      case PhpParser::Constructor:
      case PhpParser::Destruct:
      case PhpParser::Wakeup:
      case PhpParser::Sleep:
      case PhpParser::Autoload:
      case PhpParser::IsSet__:
      case PhpParser::Unset__:
      case PhpParser::ToString__:
      case PhpParser::Invoke:
      case PhpParser::SetState:
      case PhpParser::Clone__:
      case PhpParser::DebugInfo:
      case PhpParser::Namespace__:
      case PhpParser::Class__:
      case PhpParser::Traic__:
      case PhpParser::Function__:
      case PhpParser::Method__:
      case PhpParser::Line__:
      case PhpParser::File__:
      case PhpParser::Dir__:
      case PhpParser::Inc:
      case PhpParser::Dec:
      case PhpParser::NamespaceSeparator:
      case PhpParser::Bang:
      case PhpParser::Plus:
      case PhpParser::Minus:
      case PhpParser::Tilde:
      case PhpParser::SuppressWarnings:
      case PhpParser::Dollar:
      case PhpParser::OpenRoundBracket:
      case PhpParser::OpenSquareBracket:
      case PhpParser::OpenCurlyBracket:
      case PhpParser::SemiColon:
      case PhpParser::VarName:
      case PhpParser::Label:
      case PhpParser::Octal:
      case PhpParser::Decimal:
      case PhpParser::Real:
      case PhpParser::Hex:
      case PhpParser::Binary:
      case PhpParser::BackQuoteString:
      case PhpParser::SingleQuoteString:
      case PhpParser::DoubleQuote:
      case PhpParser::StartNowDoc:
      case PhpParser::StartHereDoc: {
        setState(868);
        statement();
        break;
      }

      case PhpParser::Colon: {
        setState(869);
        match(PhpParser::Colon);
        setState(870);
        innerStatementList();
        setState(871);
        match(PhpParser::EndDeclare);
        setState(872);
        match(PhpParser::SemiColon);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InlineHtmlStatementContext ------------------------------------------------------------------

PhpParser::InlineHtmlStatementContext::InlineHtmlStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::InlineHtmlContext *> PhpParser::InlineHtmlStatementContext::inlineHtml() {
  return getRuleContexts<PhpParser::InlineHtmlContext>();
}

PhpParser::InlineHtmlContext* PhpParser::InlineHtmlStatementContext::inlineHtml(size_t i) {
  return getRuleContext<PhpParser::InlineHtmlContext>(i);
}


size_t PhpParser::InlineHtmlStatementContext::getRuleIndex() const {
  return PhpParser::RuleInlineHtmlStatement;
}

void PhpParser::InlineHtmlStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInlineHtmlStatement(this);
}

void PhpParser::InlineHtmlStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInlineHtmlStatement(this);
}

PhpParser::InlineHtmlStatementContext* PhpParser::inlineHtmlStatement() {
  InlineHtmlStatementContext *_localctx = _tracker.createInstance<InlineHtmlStatementContext>(_ctx, getState());
  enterRule(_localctx, 108, PhpParser::RuleInlineHtmlStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(877); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(876);
              inlineHtml();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(879); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclareListContext ------------------------------------------------------------------

PhpParser::DeclareListContext::DeclareListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::DirectiveContext *> PhpParser::DeclareListContext::directive() {
  return getRuleContexts<PhpParser::DirectiveContext>();
}

PhpParser::DirectiveContext* PhpParser::DeclareListContext::directive(size_t i) {
  return getRuleContext<PhpParser::DirectiveContext>(i);
}

std::vector<tree::TerminalNode *> PhpParser::DeclareListContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::DeclareListContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::DeclareListContext::getRuleIndex() const {
  return PhpParser::RuleDeclareList;
}

void PhpParser::DeclareListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclareList(this);
}

void PhpParser::DeclareListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclareList(this);
}

PhpParser::DeclareListContext* PhpParser::declareList() {
  DeclareListContext *_localctx = _tracker.createInstance<DeclareListContext>(_ctx, getState());
  enterRule(_localctx, 110, PhpParser::RuleDeclareList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(881);
    directive();
    setState(886);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PhpParser::Comma) {
      setState(882);
      match(PhpParser::Comma);
      setState(883);
      directive();
      setState(888);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DirectiveContext ------------------------------------------------------------------

PhpParser::DirectiveContext::DirectiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::DirectiveContext::Ticks() {
  return getToken(PhpParser::Ticks, 0);
}

tree::TerminalNode* PhpParser::DirectiveContext::Eq() {
  return getToken(PhpParser::Eq, 0);
}

PhpParser::NumericConstantContext* PhpParser::DirectiveContext::numericConstant() {
  return getRuleContext<PhpParser::NumericConstantContext>(0);
}

tree::TerminalNode* PhpParser::DirectiveContext::Real() {
  return getToken(PhpParser::Real, 0);
}

tree::TerminalNode* PhpParser::DirectiveContext::Encoding() {
  return getToken(PhpParser::Encoding, 0);
}

tree::TerminalNode* PhpParser::DirectiveContext::SingleQuoteString() {
  return getToken(PhpParser::SingleQuoteString, 0);
}

tree::TerminalNode* PhpParser::DirectiveContext::StrictTypes() {
  return getToken(PhpParser::StrictTypes, 0);
}


size_t PhpParser::DirectiveContext::getRuleIndex() const {
  return PhpParser::RuleDirective;
}

void PhpParser::DirectiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDirective(this);
}

void PhpParser::DirectiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDirective(this);
}

PhpParser::DirectiveContext* PhpParser::directive() {
  DirectiveContext *_localctx = _tracker.createInstance<DirectiveContext>(_ctx, getState());
  enterRule(_localctx, 112, PhpParser::RuleDirective);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(901);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::Ticks: {
        enterOuterAlt(_localctx, 1);
        setState(889);
        match(PhpParser::Ticks);
        setState(890);
        match(PhpParser::Eq);
        setState(893);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case PhpParser::Octal:
          case PhpParser::Decimal:
          case PhpParser::Hex:
          case PhpParser::Binary: {
            setState(891);
            numericConstant();
            break;
          }

          case PhpParser::Real: {
            setState(892);
            match(PhpParser::Real);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case PhpParser::Encoding: {
        enterOuterAlt(_localctx, 2);
        setState(895);
        match(PhpParser::Encoding);
        setState(896);
        match(PhpParser::Eq);
        setState(897);
        match(PhpParser::SingleQuoteString);
        break;
      }

      case PhpParser::StrictTypes: {
        enterOuterAlt(_localctx, 3);
        setState(898);
        match(PhpParser::StrictTypes);
        setState(899);
        match(PhpParser::Eq);
        setState(900);
        numericConstant();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FormalParameterListContext ------------------------------------------------------------------

PhpParser::FormalParameterListContext::FormalParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::FormalParameterContext *> PhpParser::FormalParameterListContext::formalParameter() {
  return getRuleContexts<PhpParser::FormalParameterContext>();
}

PhpParser::FormalParameterContext* PhpParser::FormalParameterListContext::formalParameter(size_t i) {
  return getRuleContext<PhpParser::FormalParameterContext>(i);
}

std::vector<tree::TerminalNode *> PhpParser::FormalParameterListContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::FormalParameterListContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::FormalParameterListContext::getRuleIndex() const {
  return PhpParser::RuleFormalParameterList;
}

void PhpParser::FormalParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFormalParameterList(this);
}

void PhpParser::FormalParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFormalParameterList(this);
}

PhpParser::FormalParameterListContext* PhpParser::formalParameterList() {
  FormalParameterListContext *_localctx = _tracker.createInstance<FormalParameterListContext>(_ctx, getState());
  enterRule(_localctx, 114, PhpParser::RuleFormalParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(904);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 43) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 43)) & -1) != 0) || ((((_la - 107) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 107)) & 18014398509481983) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 194)) & 3221356563) != 0)) {
      setState(903);
      formalParameter();
    }
    setState(910);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(906);
        match(PhpParser::Comma);
        setState(907);
        formalParameter(); 
      }
      setState(912);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx);
    }
    setState(914);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Comma) {
      setState(913);
      match(PhpParser::Comma);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FormalParameterContext ------------------------------------------------------------------

PhpParser::FormalParameterContext::FormalParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::VariableInitializerContext* PhpParser::FormalParameterContext::variableInitializer() {
  return getRuleContext<PhpParser::VariableInitializerContext>(0);
}

PhpParser::AttributesContext* PhpParser::FormalParameterContext::attributes() {
  return getRuleContext<PhpParser::AttributesContext>(0);
}

std::vector<PhpParser::MemberModifierContext *> PhpParser::FormalParameterContext::memberModifier() {
  return getRuleContexts<PhpParser::MemberModifierContext>();
}

PhpParser::MemberModifierContext* PhpParser::FormalParameterContext::memberModifier(size_t i) {
  return getRuleContext<PhpParser::MemberModifierContext>(i);
}

tree::TerminalNode* PhpParser::FormalParameterContext::QuestionMark() {
  return getToken(PhpParser::QuestionMark, 0);
}

PhpParser::TypeHintContext* PhpParser::FormalParameterContext::typeHint() {
  return getRuleContext<PhpParser::TypeHintContext>(0);
}

tree::TerminalNode* PhpParser::FormalParameterContext::Ampersand() {
  return getToken(PhpParser::Ampersand, 0);
}

tree::TerminalNode* PhpParser::FormalParameterContext::Ellipsis() {
  return getToken(PhpParser::Ellipsis, 0);
}


size_t PhpParser::FormalParameterContext::getRuleIndex() const {
  return PhpParser::RuleFormalParameter;
}

void PhpParser::FormalParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFormalParameter(this);
}

void PhpParser::FormalParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFormalParameter(this);
}

PhpParser::FormalParameterContext* PhpParser::formalParameter() {
  FormalParameterContext *_localctx = _tracker.createInstance<FormalParameterContext>(_ctx, getState());
  enterRule(_localctx, 116, PhpParser::RuleFormalParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(917);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::AttributeStart) {
      setState(916);
      attributes();
    }
    setState(922);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 92, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(919);
        memberModifier(); 
      }
      setState(924);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 92, _ctx);
    }
    setState(926);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::QuestionMark) {
      setState(925);
      match(PhpParser::QuestionMark);
    }
    setState(929);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 44) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 44)) & -1) != 0) || ((((_la - 108) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 108)) & 9007199254740991) != 0) || _la == PhpParser::NamespaceSeparator

    || _la == PhpParser::Label) {
      setState(928);
      typeHint(0);
    }
    setState(932);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Ampersand) {
      setState(931);
      match(PhpParser::Ampersand);
    }
    setState(935);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Ellipsis) {
      setState(934);
      match(PhpParser::Ellipsis);
    }
    setState(937);
    variableInitializer();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeHintContext ------------------------------------------------------------------

PhpParser::TypeHintContext::TypeHintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::QualifiedStaticTypeRefContext* PhpParser::TypeHintContext::qualifiedStaticTypeRef() {
  return getRuleContext<PhpParser::QualifiedStaticTypeRefContext>(0);
}

tree::TerminalNode* PhpParser::TypeHintContext::Callable() {
  return getToken(PhpParser::Callable, 0);
}

PhpParser::PrimitiveTypeContext* PhpParser::TypeHintContext::primitiveType() {
  return getRuleContext<PhpParser::PrimitiveTypeContext>(0);
}

std::vector<PhpParser::TypeHintContext *> PhpParser::TypeHintContext::typeHint() {
  return getRuleContexts<PhpParser::TypeHintContext>();
}

PhpParser::TypeHintContext* PhpParser::TypeHintContext::typeHint(size_t i) {
  return getRuleContext<PhpParser::TypeHintContext>(i);
}

tree::TerminalNode* PhpParser::TypeHintContext::Pipe() {
  return getToken(PhpParser::Pipe, 0);
}


size_t PhpParser::TypeHintContext::getRuleIndex() const {
  return PhpParser::RuleTypeHint;
}

void PhpParser::TypeHintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeHint(this);
}

void PhpParser::TypeHintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeHint(this);
}


PhpParser::TypeHintContext* PhpParser::typeHint() {
   return typeHint(0);
}

PhpParser::TypeHintContext* PhpParser::typeHint(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  PhpParser::TypeHintContext *_localctx = _tracker.createInstance<TypeHintContext>(_ctx, parentState);
  PhpParser::TypeHintContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 118;
  enterRecursionRule(_localctx, 118, PhpParser::RuleTypeHint, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(943);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx)) {
    case 1: {
      setState(940);
      qualifiedStaticTypeRef();
      break;
    }

    case 2: {
      setState(941);
      match(PhpParser::Callable);
      break;
    }

    case 3: {
      setState(942);
      primitiveType();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(950);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<TypeHintContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleTypeHint);
        setState(945);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(946);
        match(PhpParser::Pipe);
        setState(947);
        typeHint(2); 
      }
      setState(952);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- GlobalStatementContext ------------------------------------------------------------------

PhpParser::GlobalStatementContext::GlobalStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::GlobalStatementContext::Global() {
  return getToken(PhpParser::Global, 0);
}

std::vector<PhpParser::GlobalVarContext *> PhpParser::GlobalStatementContext::globalVar() {
  return getRuleContexts<PhpParser::GlobalVarContext>();
}

PhpParser::GlobalVarContext* PhpParser::GlobalStatementContext::globalVar(size_t i) {
  return getRuleContext<PhpParser::GlobalVarContext>(i);
}

tree::TerminalNode* PhpParser::GlobalStatementContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}

std::vector<tree::TerminalNode *> PhpParser::GlobalStatementContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::GlobalStatementContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::GlobalStatementContext::getRuleIndex() const {
  return PhpParser::RuleGlobalStatement;
}

void PhpParser::GlobalStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGlobalStatement(this);
}

void PhpParser::GlobalStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGlobalStatement(this);
}

PhpParser::GlobalStatementContext* PhpParser::globalStatement() {
  GlobalStatementContext *_localctx = _tracker.createInstance<GlobalStatementContext>(_ctx, getState());
  enterRule(_localctx, 120, PhpParser::RuleGlobalStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(953);
    match(PhpParser::Global);
    setState(954);
    globalVar();
    setState(959);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PhpParser::Comma) {
      setState(955);
      match(PhpParser::Comma);
      setState(956);
      globalVar();
      setState(961);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(962);
    match(PhpParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GlobalVarContext ------------------------------------------------------------------

PhpParser::GlobalVarContext::GlobalVarContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::GlobalVarContext::VarName() {
  return getToken(PhpParser::VarName, 0);
}

tree::TerminalNode* PhpParser::GlobalVarContext::Dollar() {
  return getToken(PhpParser::Dollar, 0);
}

PhpParser::ChainContext* PhpParser::GlobalVarContext::chain() {
  return getRuleContext<PhpParser::ChainContext>(0);
}

tree::TerminalNode* PhpParser::GlobalVarContext::OpenCurlyBracket() {
  return getToken(PhpParser::OpenCurlyBracket, 0);
}

PhpParser::ExpressionContext* PhpParser::GlobalVarContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

tree::TerminalNode* PhpParser::GlobalVarContext::CloseCurlyBracket() {
  return getToken(PhpParser::CloseCurlyBracket, 0);
}


size_t PhpParser::GlobalVarContext::getRuleIndex() const {
  return PhpParser::RuleGlobalVar;
}

void PhpParser::GlobalVarContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGlobalVar(this);
}

void PhpParser::GlobalVarContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGlobalVar(this);
}

PhpParser::GlobalVarContext* PhpParser::globalVar() {
  GlobalVarContext *_localctx = _tracker.createInstance<GlobalVarContext>(_ctx, getState());
  enterRule(_localctx, 122, PhpParser::RuleGlobalVar);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(972);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(964);
      match(PhpParser::VarName);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(965);
      match(PhpParser::Dollar);
      setState(966);
      chain();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(967);
      match(PhpParser::Dollar);
      setState(968);
      match(PhpParser::OpenCurlyBracket);
      setState(969);
      expression(0);
      setState(970);
      match(PhpParser::CloseCurlyBracket);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EchoStatementContext ------------------------------------------------------------------

PhpParser::EchoStatementContext::EchoStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::EchoStatementContext::Echo() {
  return getToken(PhpParser::Echo, 0);
}

PhpParser::ExpressionListContext* PhpParser::EchoStatementContext::expressionList() {
  return getRuleContext<PhpParser::ExpressionListContext>(0);
}

tree::TerminalNode* PhpParser::EchoStatementContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}


size_t PhpParser::EchoStatementContext::getRuleIndex() const {
  return PhpParser::RuleEchoStatement;
}

void PhpParser::EchoStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEchoStatement(this);
}

void PhpParser::EchoStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEchoStatement(this);
}

PhpParser::EchoStatementContext* PhpParser::echoStatement() {
  EchoStatementContext *_localctx = _tracker.createInstance<EchoStatementContext>(_ctx, getState());
  enterRule(_localctx, 124, PhpParser::RuleEchoStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(974);
    match(PhpParser::Echo);
    setState(975);
    expressionList();
    setState(976);
    match(PhpParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StaticVariableStatementContext ------------------------------------------------------------------

PhpParser::StaticVariableStatementContext::StaticVariableStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::StaticVariableStatementContext::Static() {
  return getToken(PhpParser::Static, 0);
}

std::vector<PhpParser::VariableInitializerContext *> PhpParser::StaticVariableStatementContext::variableInitializer() {
  return getRuleContexts<PhpParser::VariableInitializerContext>();
}

PhpParser::VariableInitializerContext* PhpParser::StaticVariableStatementContext::variableInitializer(size_t i) {
  return getRuleContext<PhpParser::VariableInitializerContext>(i);
}

tree::TerminalNode* PhpParser::StaticVariableStatementContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}

std::vector<tree::TerminalNode *> PhpParser::StaticVariableStatementContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::StaticVariableStatementContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::StaticVariableStatementContext::getRuleIndex() const {
  return PhpParser::RuleStaticVariableStatement;
}

void PhpParser::StaticVariableStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStaticVariableStatement(this);
}

void PhpParser::StaticVariableStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStaticVariableStatement(this);
}

PhpParser::StaticVariableStatementContext* PhpParser::staticVariableStatement() {
  StaticVariableStatementContext *_localctx = _tracker.createInstance<StaticVariableStatementContext>(_ctx, getState());
  enterRule(_localctx, 126, PhpParser::RuleStaticVariableStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(978);
    match(PhpParser::Static);
    setState(979);
    variableInitializer();
    setState(984);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PhpParser::Comma) {
      setState(980);
      match(PhpParser::Comma);
      setState(981);
      variableInitializer();
      setState(986);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(987);
    match(PhpParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassStatementContext ------------------------------------------------------------------

PhpParser::ClassStatementContext::ClassStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::PropertyModifiersContext* PhpParser::ClassStatementContext::propertyModifiers() {
  return getRuleContext<PhpParser::PropertyModifiersContext>(0);
}

std::vector<PhpParser::VariableInitializerContext *> PhpParser::ClassStatementContext::variableInitializer() {
  return getRuleContexts<PhpParser::VariableInitializerContext>();
}

PhpParser::VariableInitializerContext* PhpParser::ClassStatementContext::variableInitializer(size_t i) {
  return getRuleContext<PhpParser::VariableInitializerContext>(i);
}

tree::TerminalNode* PhpParser::ClassStatementContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}

PhpParser::AttributesContext* PhpParser::ClassStatementContext::attributes() {
  return getRuleContext<PhpParser::AttributesContext>(0);
}

tree::TerminalNode* PhpParser::ClassStatementContext::Const() {
  return getToken(PhpParser::Const, 0);
}

std::vector<PhpParser::IdentifierInitializerContext *> PhpParser::ClassStatementContext::identifierInitializer() {
  return getRuleContexts<PhpParser::IdentifierInitializerContext>();
}

PhpParser::IdentifierInitializerContext* PhpParser::ClassStatementContext::identifierInitializer(size_t i) {
  return getRuleContext<PhpParser::IdentifierInitializerContext>(i);
}

tree::TerminalNode* PhpParser::ClassStatementContext::Function_() {
  return getToken(PhpParser::Function_, 0);
}

PhpParser::IdentifierContext* PhpParser::ClassStatementContext::identifier() {
  return getRuleContext<PhpParser::IdentifierContext>(0);
}

tree::TerminalNode* PhpParser::ClassStatementContext::OpenRoundBracket() {
  return getToken(PhpParser::OpenRoundBracket, 0);
}

PhpParser::FormalParameterListContext* PhpParser::ClassStatementContext::formalParameterList() {
  return getRuleContext<PhpParser::FormalParameterListContext>(0);
}

tree::TerminalNode* PhpParser::ClassStatementContext::CloseRoundBracket() {
  return getToken(PhpParser::CloseRoundBracket, 0);
}

PhpParser::MethodBodyContext* PhpParser::ClassStatementContext::methodBody() {
  return getRuleContext<PhpParser::MethodBodyContext>(0);
}

PhpParser::TypeHintContext* PhpParser::ClassStatementContext::typeHint() {
  return getRuleContext<PhpParser::TypeHintContext>(0);
}

std::vector<tree::TerminalNode *> PhpParser::ClassStatementContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::ClassStatementContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}

PhpParser::MemberModifiersContext* PhpParser::ClassStatementContext::memberModifiers() {
  return getRuleContext<PhpParser::MemberModifiersContext>(0);
}

tree::TerminalNode* PhpParser::ClassStatementContext::Ampersand() {
  return getToken(PhpParser::Ampersand, 0);
}

PhpParser::TypeParameterListInBracketsContext* PhpParser::ClassStatementContext::typeParameterListInBrackets() {
  return getRuleContext<PhpParser::TypeParameterListInBracketsContext>(0);
}

PhpParser::BaseCtorCallContext* PhpParser::ClassStatementContext::baseCtorCall() {
  return getRuleContext<PhpParser::BaseCtorCallContext>(0);
}

PhpParser::ReturnTypeDeclContext* PhpParser::ClassStatementContext::returnTypeDecl() {
  return getRuleContext<PhpParser::ReturnTypeDeclContext>(0);
}

tree::TerminalNode* PhpParser::ClassStatementContext::Use() {
  return getToken(PhpParser::Use, 0);
}

PhpParser::QualifiedNamespaceNameListContext* PhpParser::ClassStatementContext::qualifiedNamespaceNameList() {
  return getRuleContext<PhpParser::QualifiedNamespaceNameListContext>(0);
}

PhpParser::TraitAdaptationsContext* PhpParser::ClassStatementContext::traitAdaptations() {
  return getRuleContext<PhpParser::TraitAdaptationsContext>(0);
}


size_t PhpParser::ClassStatementContext::getRuleIndex() const {
  return PhpParser::RuleClassStatement;
}

void PhpParser::ClassStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassStatement(this);
}

void PhpParser::ClassStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassStatement(this);
}

PhpParser::ClassStatementContext* PhpParser::classStatement() {
  ClassStatementContext *_localctx = _tracker.createInstance<ClassStatementContext>(_ctx, getState());
  enterRule(_localctx, 128, PhpParser::RuleClassStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1048);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::AttributeStart:
      case PhpParser::Abstract:
      case PhpParser::Const:
      case PhpParser::Final:
      case PhpParser::Function_:
      case PhpParser::Private:
      case PhpParser::Protected:
      case PhpParser::Public:
      case PhpParser::Readonly:
      case PhpParser::Static:
      case PhpParser::Var: {
        enterOuterAlt(_localctx, 1);
        setState(990);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::AttributeStart) {
          setState(989);
          attributes();
        }
        setState(1042);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 112, _ctx)) {
        case 1: {
          setState(992);
          propertyModifiers();
          setState(994);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (((((_la - 44) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 44)) & -1) != 0) || ((((_la - 108) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 108)) & 9007199254740991) != 0) || _la == PhpParser::NamespaceSeparator

          || _la == PhpParser::Label) {
            setState(993);
            typeHint(0);
          }
          setState(996);
          variableInitializer();
          setState(1001);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == PhpParser::Comma) {
            setState(997);
            match(PhpParser::Comma);
            setState(998);
            variableInitializer();
            setState(1003);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(1004);
          match(PhpParser::SemiColon);
          break;
        }

        case 2: {
          setState(1007);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == PhpParser::Abstract || ((((_la - 77) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 77)) & 2327872274433) != 0)) {
            setState(1006);
            memberModifiers();
          }
          setState(1040);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case PhpParser::Const: {
              setState(1009);
              match(PhpParser::Const);
              setState(1011);
              _errHandler->sync(this);

              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx)) {
              case 1: {
                setState(1010);
                typeHint(0);
                break;
              }

              default:
                break;
              }
              setState(1013);
              identifierInitializer();
              setState(1018);
              _errHandler->sync(this);
              _la = _input->LA(1);
              while (_la == PhpParser::Comma) {
                setState(1014);
                match(PhpParser::Comma);
                setState(1015);
                identifierInitializer();
                setState(1020);
                _errHandler->sync(this);
                _la = _input->LA(1);
              }
              setState(1021);
              match(PhpParser::SemiColon);
              break;
            }

            case PhpParser::Function_: {
              setState(1023);
              match(PhpParser::Function_);
              setState(1025);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == PhpParser::Ampersand) {
                setState(1024);
                match(PhpParser::Ampersand);
              }
              setState(1027);
              identifier();
              setState(1029);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == PhpParser::Lgeneric) {
                setState(1028);
                typeParameterListInBrackets();
              }
              setState(1031);
              match(PhpParser::OpenRoundBracket);
              setState(1032);
              formalParameterList();
              setState(1033);
              match(PhpParser::CloseRoundBracket);
              setState(1036);
              _errHandler->sync(this);

              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 110, _ctx)) {
              case 1: {
                setState(1034);
                baseCtorCall();
                break;
              }

              case 2: {
                setState(1035);
                returnTypeDecl();
                break;
              }

              default:
                break;
              }
              setState(1038);
              methodBody();
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      case PhpParser::Use: {
        enterOuterAlt(_localctx, 2);
        setState(1044);
        match(PhpParser::Use);
        setState(1045);
        qualifiedNamespaceNameList();
        setState(1046);
        traitAdaptations();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TraitAdaptationsContext ------------------------------------------------------------------

PhpParser::TraitAdaptationsContext::TraitAdaptationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::TraitAdaptationsContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}

tree::TerminalNode* PhpParser::TraitAdaptationsContext::OpenCurlyBracket() {
  return getToken(PhpParser::OpenCurlyBracket, 0);
}

tree::TerminalNode* PhpParser::TraitAdaptationsContext::CloseCurlyBracket() {
  return getToken(PhpParser::CloseCurlyBracket, 0);
}

std::vector<PhpParser::TraitAdaptationStatementContext *> PhpParser::TraitAdaptationsContext::traitAdaptationStatement() {
  return getRuleContexts<PhpParser::TraitAdaptationStatementContext>();
}

PhpParser::TraitAdaptationStatementContext* PhpParser::TraitAdaptationsContext::traitAdaptationStatement(size_t i) {
  return getRuleContext<PhpParser::TraitAdaptationStatementContext>(i);
}


size_t PhpParser::TraitAdaptationsContext::getRuleIndex() const {
  return PhpParser::RuleTraitAdaptations;
}

void PhpParser::TraitAdaptationsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTraitAdaptations(this);
}

void PhpParser::TraitAdaptationsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTraitAdaptations(this);
}

PhpParser::TraitAdaptationsContext* PhpParser::traitAdaptations() {
  TraitAdaptationsContext *_localctx = _tracker.createInstance<TraitAdaptationsContext>(_ctx, getState());
  enterRule(_localctx, 130, PhpParser::RuleTraitAdaptations);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1059);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::SemiColon: {
        enterOuterAlt(_localctx, 1);
        setState(1050);
        match(PhpParser::SemiColon);
        break;
      }

      case PhpParser::OpenCurlyBracket: {
        enterOuterAlt(_localctx, 2);
        setState(1051);
        match(PhpParser::OpenCurlyBracket);
        setState(1055);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (((((_la - 44) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 44)) & -1) != 0) || ((((_la - 108) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 108)) & 9007199254740991) != 0) || _la == PhpParser::NamespaceSeparator

        || _la == PhpParser::Label) {
          setState(1052);
          traitAdaptationStatement();
          setState(1057);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1058);
        match(PhpParser::CloseCurlyBracket);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TraitAdaptationStatementContext ------------------------------------------------------------------

PhpParser::TraitAdaptationStatementContext::TraitAdaptationStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::TraitPrecedenceContext* PhpParser::TraitAdaptationStatementContext::traitPrecedence() {
  return getRuleContext<PhpParser::TraitPrecedenceContext>(0);
}

PhpParser::TraitAliasContext* PhpParser::TraitAdaptationStatementContext::traitAlias() {
  return getRuleContext<PhpParser::TraitAliasContext>(0);
}


size_t PhpParser::TraitAdaptationStatementContext::getRuleIndex() const {
  return PhpParser::RuleTraitAdaptationStatement;
}

void PhpParser::TraitAdaptationStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTraitAdaptationStatement(this);
}

void PhpParser::TraitAdaptationStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTraitAdaptationStatement(this);
}

PhpParser::TraitAdaptationStatementContext* PhpParser::traitAdaptationStatement() {
  TraitAdaptationStatementContext *_localctx = _tracker.createInstance<TraitAdaptationStatementContext>(_ctx, getState());
  enterRule(_localctx, 132, PhpParser::RuleTraitAdaptationStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1063);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1061);
      traitPrecedence();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1062);
      traitAlias();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TraitPrecedenceContext ------------------------------------------------------------------

PhpParser::TraitPrecedenceContext::TraitPrecedenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::QualifiedNamespaceNameContext* PhpParser::TraitPrecedenceContext::qualifiedNamespaceName() {
  return getRuleContext<PhpParser::QualifiedNamespaceNameContext>(0);
}

tree::TerminalNode* PhpParser::TraitPrecedenceContext::DoubleColon() {
  return getToken(PhpParser::DoubleColon, 0);
}

PhpParser::IdentifierContext* PhpParser::TraitPrecedenceContext::identifier() {
  return getRuleContext<PhpParser::IdentifierContext>(0);
}

tree::TerminalNode* PhpParser::TraitPrecedenceContext::InsteadOf() {
  return getToken(PhpParser::InsteadOf, 0);
}

PhpParser::QualifiedNamespaceNameListContext* PhpParser::TraitPrecedenceContext::qualifiedNamespaceNameList() {
  return getRuleContext<PhpParser::QualifiedNamespaceNameListContext>(0);
}

tree::TerminalNode* PhpParser::TraitPrecedenceContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}


size_t PhpParser::TraitPrecedenceContext::getRuleIndex() const {
  return PhpParser::RuleTraitPrecedence;
}

void PhpParser::TraitPrecedenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTraitPrecedence(this);
}

void PhpParser::TraitPrecedenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTraitPrecedence(this);
}

PhpParser::TraitPrecedenceContext* PhpParser::traitPrecedence() {
  TraitPrecedenceContext *_localctx = _tracker.createInstance<TraitPrecedenceContext>(_ctx, getState());
  enterRule(_localctx, 134, PhpParser::RuleTraitPrecedence);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1065);
    qualifiedNamespaceName();
    setState(1066);
    match(PhpParser::DoubleColon);
    setState(1067);
    identifier();
    setState(1068);
    match(PhpParser::InsteadOf);
    setState(1069);
    qualifiedNamespaceNameList();
    setState(1070);
    match(PhpParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TraitAliasContext ------------------------------------------------------------------

PhpParser::TraitAliasContext::TraitAliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::TraitMethodReferenceContext* PhpParser::TraitAliasContext::traitMethodReference() {
  return getRuleContext<PhpParser::TraitMethodReferenceContext>(0);
}

tree::TerminalNode* PhpParser::TraitAliasContext::As() {
  return getToken(PhpParser::As, 0);
}

tree::TerminalNode* PhpParser::TraitAliasContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}

PhpParser::MemberModifierContext* PhpParser::TraitAliasContext::memberModifier() {
  return getRuleContext<PhpParser::MemberModifierContext>(0);
}

PhpParser::IdentifierContext* PhpParser::TraitAliasContext::identifier() {
  return getRuleContext<PhpParser::IdentifierContext>(0);
}


size_t PhpParser::TraitAliasContext::getRuleIndex() const {
  return PhpParser::RuleTraitAlias;
}

void PhpParser::TraitAliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTraitAlias(this);
}

void PhpParser::TraitAliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTraitAlias(this);
}

PhpParser::TraitAliasContext* PhpParser::traitAlias() {
  TraitAliasContext *_localctx = _tracker.createInstance<TraitAliasContext>(_ctx, getState());
  enterRule(_localctx, 136, PhpParser::RuleTraitAlias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1072);
    traitMethodReference();
    setState(1073);
    match(PhpParser::As);
    setState(1079);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx)) {
    case 1: {
      setState(1074);
      memberModifier();
      break;
    }

    case 2: {
      setState(1076);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx)) {
      case 1: {
        setState(1075);
        memberModifier();
        break;
      }

      default:
        break;
      }
      setState(1078);
      identifier();
      break;
    }

    default:
      break;
    }
    setState(1081);
    match(PhpParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TraitMethodReferenceContext ------------------------------------------------------------------

PhpParser::TraitMethodReferenceContext::TraitMethodReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::IdentifierContext* PhpParser::TraitMethodReferenceContext::identifier() {
  return getRuleContext<PhpParser::IdentifierContext>(0);
}

PhpParser::QualifiedNamespaceNameContext* PhpParser::TraitMethodReferenceContext::qualifiedNamespaceName() {
  return getRuleContext<PhpParser::QualifiedNamespaceNameContext>(0);
}

tree::TerminalNode* PhpParser::TraitMethodReferenceContext::DoubleColon() {
  return getToken(PhpParser::DoubleColon, 0);
}


size_t PhpParser::TraitMethodReferenceContext::getRuleIndex() const {
  return PhpParser::RuleTraitMethodReference;
}

void PhpParser::TraitMethodReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTraitMethodReference(this);
}

void PhpParser::TraitMethodReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTraitMethodReference(this);
}

PhpParser::TraitMethodReferenceContext* PhpParser::traitMethodReference() {
  TraitMethodReferenceContext *_localctx = _tracker.createInstance<TraitMethodReferenceContext>(_ctx, getState());
  enterRule(_localctx, 138, PhpParser::RuleTraitMethodReference);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1086);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 119, _ctx)) {
    case 1: {
      setState(1083);
      qualifiedNamespaceName();
      setState(1084);
      match(PhpParser::DoubleColon);
      break;
    }

    default:
      break;
    }
    setState(1088);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BaseCtorCallContext ------------------------------------------------------------------

PhpParser::BaseCtorCallContext::BaseCtorCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::BaseCtorCallContext::Colon() {
  return getToken(PhpParser::Colon, 0);
}

PhpParser::IdentifierContext* PhpParser::BaseCtorCallContext::identifier() {
  return getRuleContext<PhpParser::IdentifierContext>(0);
}

PhpParser::ArgumentsContext* PhpParser::BaseCtorCallContext::arguments() {
  return getRuleContext<PhpParser::ArgumentsContext>(0);
}


size_t PhpParser::BaseCtorCallContext::getRuleIndex() const {
  return PhpParser::RuleBaseCtorCall;
}

void PhpParser::BaseCtorCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBaseCtorCall(this);
}

void PhpParser::BaseCtorCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBaseCtorCall(this);
}

PhpParser::BaseCtorCallContext* PhpParser::baseCtorCall() {
  BaseCtorCallContext *_localctx = _tracker.createInstance<BaseCtorCallContext>(_ctx, getState());
  enterRule(_localctx, 140, PhpParser::RuleBaseCtorCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1090);
    match(PhpParser::Colon);
    setState(1091);
    identifier();
    setState(1093);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::OpenRoundBracket) {
      setState(1092);
      arguments();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnTypeDeclContext ------------------------------------------------------------------

PhpParser::ReturnTypeDeclContext::ReturnTypeDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::ReturnTypeDeclContext::Colon() {
  return getToken(PhpParser::Colon, 0);
}

PhpParser::TypeHintContext* PhpParser::ReturnTypeDeclContext::typeHint() {
  return getRuleContext<PhpParser::TypeHintContext>(0);
}

tree::TerminalNode* PhpParser::ReturnTypeDeclContext::QuestionMark() {
  return getToken(PhpParser::QuestionMark, 0);
}


size_t PhpParser::ReturnTypeDeclContext::getRuleIndex() const {
  return PhpParser::RuleReturnTypeDecl;
}

void PhpParser::ReturnTypeDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnTypeDecl(this);
}

void PhpParser::ReturnTypeDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnTypeDecl(this);
}

PhpParser::ReturnTypeDeclContext* PhpParser::returnTypeDecl() {
  ReturnTypeDeclContext *_localctx = _tracker.createInstance<ReturnTypeDeclContext>(_ctx, getState());
  enterRule(_localctx, 142, PhpParser::RuleReturnTypeDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1095);
    match(PhpParser::Colon);
    setState(1097);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::QuestionMark) {
      setState(1096);
      match(PhpParser::QuestionMark);
    }
    setState(1099);
    typeHint(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MethodBodyContext ------------------------------------------------------------------

PhpParser::MethodBodyContext::MethodBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::MethodBodyContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}

PhpParser::BlockStatementContext* PhpParser::MethodBodyContext::blockStatement() {
  return getRuleContext<PhpParser::BlockStatementContext>(0);
}


size_t PhpParser::MethodBodyContext::getRuleIndex() const {
  return PhpParser::RuleMethodBody;
}

void PhpParser::MethodBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMethodBody(this);
}

void PhpParser::MethodBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMethodBody(this);
}

PhpParser::MethodBodyContext* PhpParser::methodBody() {
  MethodBodyContext *_localctx = _tracker.createInstance<MethodBodyContext>(_ctx, getState());
  enterRule(_localctx, 144, PhpParser::RuleMethodBody);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1103);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::SemiColon: {
        enterOuterAlt(_localctx, 1);
        setState(1101);
        match(PhpParser::SemiColon);
        break;
      }

      case PhpParser::OpenCurlyBracket: {
        enterOuterAlt(_localctx, 2);
        setState(1102);
        blockStatement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyModifiersContext ------------------------------------------------------------------

PhpParser::PropertyModifiersContext::PropertyModifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::MemberModifiersContext* PhpParser::PropertyModifiersContext::memberModifiers() {
  return getRuleContext<PhpParser::MemberModifiersContext>(0);
}

tree::TerminalNode* PhpParser::PropertyModifiersContext::Var() {
  return getToken(PhpParser::Var, 0);
}


size_t PhpParser::PropertyModifiersContext::getRuleIndex() const {
  return PhpParser::RulePropertyModifiers;
}

void PhpParser::PropertyModifiersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyModifiers(this);
}

void PhpParser::PropertyModifiersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyModifiers(this);
}

PhpParser::PropertyModifiersContext* PhpParser::propertyModifiers() {
  PropertyModifiersContext *_localctx = _tracker.createInstance<PropertyModifiersContext>(_ctx, getState());
  enterRule(_localctx, 146, PhpParser::RulePropertyModifiers);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1107);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::Abstract:
      case PhpParser::Final:
      case PhpParser::Private:
      case PhpParser::Protected:
      case PhpParser::Public:
      case PhpParser::Readonly:
      case PhpParser::Static: {
        enterOuterAlt(_localctx, 1);
        setState(1105);
        memberModifiers();
        break;
      }

      case PhpParser::Var: {
        enterOuterAlt(_localctx, 2);
        setState(1106);
        match(PhpParser::Var);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MemberModifiersContext ------------------------------------------------------------------

PhpParser::MemberModifiersContext::MemberModifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::MemberModifierContext *> PhpParser::MemberModifiersContext::memberModifier() {
  return getRuleContexts<PhpParser::MemberModifierContext>();
}

PhpParser::MemberModifierContext* PhpParser::MemberModifiersContext::memberModifier(size_t i) {
  return getRuleContext<PhpParser::MemberModifierContext>(i);
}


size_t PhpParser::MemberModifiersContext::getRuleIndex() const {
  return PhpParser::RuleMemberModifiers;
}

void PhpParser::MemberModifiersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemberModifiers(this);
}

void PhpParser::MemberModifiersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemberModifiers(this);
}

PhpParser::MemberModifiersContext* PhpParser::memberModifiers() {
  MemberModifiersContext *_localctx = _tracker.createInstance<MemberModifiersContext>(_ctx, getState());
  enterRule(_localctx, 148, PhpParser::RuleMemberModifiers);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1110); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1109);
              memberModifier();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1112); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 124, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableInitializerContext ------------------------------------------------------------------

PhpParser::VariableInitializerContext::VariableInitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::VariableInitializerContext::VarName() {
  return getToken(PhpParser::VarName, 0);
}

tree::TerminalNode* PhpParser::VariableInitializerContext::Eq() {
  return getToken(PhpParser::Eq, 0);
}

PhpParser::ConstantInitializerContext* PhpParser::VariableInitializerContext::constantInitializer() {
  return getRuleContext<PhpParser::ConstantInitializerContext>(0);
}


size_t PhpParser::VariableInitializerContext::getRuleIndex() const {
  return PhpParser::RuleVariableInitializer;
}

void PhpParser::VariableInitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableInitializer(this);
}

void PhpParser::VariableInitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableInitializer(this);
}

PhpParser::VariableInitializerContext* PhpParser::variableInitializer() {
  VariableInitializerContext *_localctx = _tracker.createInstance<VariableInitializerContext>(_ctx, getState());
  enterRule(_localctx, 150, PhpParser::RuleVariableInitializer);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1114);
    match(PhpParser::VarName);
    setState(1117);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Eq) {
      setState(1115);
      match(PhpParser::Eq);
      setState(1116);
      constantInitializer();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierInitializerContext ------------------------------------------------------------------

PhpParser::IdentifierInitializerContext::IdentifierInitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::IdentifierContext* PhpParser::IdentifierInitializerContext::identifier() {
  return getRuleContext<PhpParser::IdentifierContext>(0);
}

tree::TerminalNode* PhpParser::IdentifierInitializerContext::Eq() {
  return getToken(PhpParser::Eq, 0);
}

PhpParser::ConstantInitializerContext* PhpParser::IdentifierInitializerContext::constantInitializer() {
  return getRuleContext<PhpParser::ConstantInitializerContext>(0);
}


size_t PhpParser::IdentifierInitializerContext::getRuleIndex() const {
  return PhpParser::RuleIdentifierInitializer;
}

void PhpParser::IdentifierInitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierInitializer(this);
}

void PhpParser::IdentifierInitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierInitializer(this);
}

PhpParser::IdentifierInitializerContext* PhpParser::identifierInitializer() {
  IdentifierInitializerContext *_localctx = _tracker.createInstance<IdentifierInitializerContext>(_ctx, getState());
  enterRule(_localctx, 152, PhpParser::RuleIdentifierInitializer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1119);
    identifier();
    setState(1120);
    match(PhpParser::Eq);
    setState(1121);
    constantInitializer();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GlobalConstantDeclarationContext ------------------------------------------------------------------

PhpParser::GlobalConstantDeclarationContext::GlobalConstantDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::GlobalConstantDeclarationContext::Const() {
  return getToken(PhpParser::Const, 0);
}

std::vector<PhpParser::IdentifierInitializerContext *> PhpParser::GlobalConstantDeclarationContext::identifierInitializer() {
  return getRuleContexts<PhpParser::IdentifierInitializerContext>();
}

PhpParser::IdentifierInitializerContext* PhpParser::GlobalConstantDeclarationContext::identifierInitializer(size_t i) {
  return getRuleContext<PhpParser::IdentifierInitializerContext>(i);
}

tree::TerminalNode* PhpParser::GlobalConstantDeclarationContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}

PhpParser::AttributesContext* PhpParser::GlobalConstantDeclarationContext::attributes() {
  return getRuleContext<PhpParser::AttributesContext>(0);
}

std::vector<tree::TerminalNode *> PhpParser::GlobalConstantDeclarationContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::GlobalConstantDeclarationContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::GlobalConstantDeclarationContext::getRuleIndex() const {
  return PhpParser::RuleGlobalConstantDeclaration;
}

void PhpParser::GlobalConstantDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGlobalConstantDeclaration(this);
}

void PhpParser::GlobalConstantDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGlobalConstantDeclaration(this);
}

PhpParser::GlobalConstantDeclarationContext* PhpParser::globalConstantDeclaration() {
  GlobalConstantDeclarationContext *_localctx = _tracker.createInstance<GlobalConstantDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 154, PhpParser::RuleGlobalConstantDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1124);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::AttributeStart) {
      setState(1123);
      attributes();
    }
    setState(1126);
    match(PhpParser::Const);
    setState(1127);
    identifierInitializer();
    setState(1132);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PhpParser::Comma) {
      setState(1128);
      match(PhpParser::Comma);
      setState(1129);
      identifierInitializer();
      setState(1134);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1135);
    match(PhpParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumDeclarationContext ------------------------------------------------------------------

PhpParser::EnumDeclarationContext::EnumDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::EnumDeclarationContext::Enum_() {
  return getToken(PhpParser::Enum_, 0);
}

PhpParser::IdentifierContext* PhpParser::EnumDeclarationContext::identifier() {
  return getRuleContext<PhpParser::IdentifierContext>(0);
}

tree::TerminalNode* PhpParser::EnumDeclarationContext::OpenCurlyBracket() {
  return getToken(PhpParser::OpenCurlyBracket, 0);
}

tree::TerminalNode* PhpParser::EnumDeclarationContext::CloseCurlyBracket() {
  return getToken(PhpParser::CloseCurlyBracket, 0);
}

tree::TerminalNode* PhpParser::EnumDeclarationContext::Colon() {
  return getToken(PhpParser::Colon, 0);
}

tree::TerminalNode* PhpParser::EnumDeclarationContext::Implements() {
  return getToken(PhpParser::Implements, 0);
}

PhpParser::InterfaceListContext* PhpParser::EnumDeclarationContext::interfaceList() {
  return getRuleContext<PhpParser::InterfaceListContext>(0);
}

std::vector<PhpParser::EnumItemContext *> PhpParser::EnumDeclarationContext::enumItem() {
  return getRuleContexts<PhpParser::EnumItemContext>();
}

PhpParser::EnumItemContext* PhpParser::EnumDeclarationContext::enumItem(size_t i) {
  return getRuleContext<PhpParser::EnumItemContext>(i);
}

tree::TerminalNode* PhpParser::EnumDeclarationContext::IntType() {
  return getToken(PhpParser::IntType, 0);
}

tree::TerminalNode* PhpParser::EnumDeclarationContext::StringType() {
  return getToken(PhpParser::StringType, 0);
}


size_t PhpParser::EnumDeclarationContext::getRuleIndex() const {
  return PhpParser::RuleEnumDeclaration;
}

void PhpParser::EnumDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumDeclaration(this);
}

void PhpParser::EnumDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumDeclaration(this);
}

PhpParser::EnumDeclarationContext* PhpParser::enumDeclaration() {
  EnumDeclarationContext *_localctx = _tracker.createInstance<EnumDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 156, PhpParser::RuleEnumDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1137);
    match(PhpParser::Enum_);
    setState(1138);
    identifier();
    setState(1141);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Colon) {
      setState(1139);
      match(PhpParser::Colon);
      setState(1140);
      _la = _input->LA(1);
      if (!(_la == PhpParser::IntType

      || _la == PhpParser::StringType)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1145);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Implements) {
      setState(1143);
      match(PhpParser::Implements);
      setState(1144);
      interfaceList();
    }
    setState(1147);
    match(PhpParser::OpenCurlyBracket);
    setState(1151);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4529987906437120) != 0) || ((((_la - 77) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 77)) & 2254127685959713) != 0)) {
      setState(1148);
      enumItem();
      setState(1153);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1154);
    match(PhpParser::CloseCurlyBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumItemContext ------------------------------------------------------------------

PhpParser::EnumItemContext::EnumItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::EnumItemContext::Case() {
  return getToken(PhpParser::Case, 0);
}

PhpParser::IdentifierContext* PhpParser::EnumItemContext::identifier() {
  return getRuleContext<PhpParser::IdentifierContext>(0);
}

tree::TerminalNode* PhpParser::EnumItemContext::SemiColon() {
  return getToken(PhpParser::SemiColon, 0);
}

tree::TerminalNode* PhpParser::EnumItemContext::Eq() {
  return getToken(PhpParser::Eq, 0);
}

PhpParser::ExpressionContext* PhpParser::EnumItemContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

PhpParser::FunctionDeclarationContext* PhpParser::EnumItemContext::functionDeclaration() {
  return getRuleContext<PhpParser::FunctionDeclarationContext>(0);
}

PhpParser::MemberModifiersContext* PhpParser::EnumItemContext::memberModifiers() {
  return getRuleContext<PhpParser::MemberModifiersContext>(0);
}

tree::TerminalNode* PhpParser::EnumItemContext::Use() {
  return getToken(PhpParser::Use, 0);
}

PhpParser::QualifiedNamespaceNameListContext* PhpParser::EnumItemContext::qualifiedNamespaceNameList() {
  return getRuleContext<PhpParser::QualifiedNamespaceNameListContext>(0);
}

PhpParser::TraitAdaptationsContext* PhpParser::EnumItemContext::traitAdaptations() {
  return getRuleContext<PhpParser::TraitAdaptationsContext>(0);
}


size_t PhpParser::EnumItemContext::getRuleIndex() const {
  return PhpParser::RuleEnumItem;
}

void PhpParser::EnumItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumItem(this);
}

void PhpParser::EnumItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumItem(this);
}

PhpParser::EnumItemContext* PhpParser::enumItem() {
  EnumItemContext *_localctx = _tracker.createInstance<EnumItemContext>(_ctx, getState());
  enterRule(_localctx, 158, PhpParser::RuleEnumItem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1172);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::Case: {
        enterOuterAlt(_localctx, 1);
        setState(1156);
        match(PhpParser::Case);
        setState(1157);
        identifier();
        setState(1160);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Eq) {
          setState(1158);
          match(PhpParser::Eq);
          setState(1159);
          expression(0);
        }
        setState(1162);
        match(PhpParser::SemiColon);
        break;
      }

      case PhpParser::AttributeStart:
      case PhpParser::Abstract:
      case PhpParser::Final:
      case PhpParser::Function_:
      case PhpParser::Private:
      case PhpParser::Protected:
      case PhpParser::Public:
      case PhpParser::Readonly:
      case PhpParser::Static: {
        enterOuterAlt(_localctx, 2);
        setState(1165);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Abstract || ((((_la - 77) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 77)) & 2327872274433) != 0)) {
          setState(1164);
          memberModifiers();
        }
        setState(1167);
        functionDeclaration();
        break;
      }

      case PhpParser::Use: {
        enterOuterAlt(_localctx, 3);
        setState(1168);
        match(PhpParser::Use);
        setState(1169);
        qualifiedNamespaceNameList();
        setState(1170);
        traitAdaptations();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionListContext ------------------------------------------------------------------

PhpParser::ExpressionListContext::ExpressionListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::ExpressionContext *> PhpParser::ExpressionListContext::expression() {
  return getRuleContexts<PhpParser::ExpressionContext>();
}

PhpParser::ExpressionContext* PhpParser::ExpressionListContext::expression(size_t i) {
  return getRuleContext<PhpParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> PhpParser::ExpressionListContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::ExpressionListContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::ExpressionListContext::getRuleIndex() const {
  return PhpParser::RuleExpressionList;
}

void PhpParser::ExpressionListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionList(this);
}

void PhpParser::ExpressionListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionList(this);
}

PhpParser::ExpressionListContext* PhpParser::expressionList() {
  ExpressionListContext *_localctx = _tracker.createInstance<ExpressionListContext>(_ctx, getState());
  enterRule(_localctx, 160, PhpParser::RuleExpressionList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1174);
    expression(0);
    setState(1179);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PhpParser::Comma) {
      setState(1175);
      match(PhpParser::Comma);
      setState(1176);
      expression(0);
      setState(1181);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParenthesesContext ------------------------------------------------------------------

PhpParser::ParenthesesContext::ParenthesesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::ParenthesesContext::OpenRoundBracket() {
  return getToken(PhpParser::OpenRoundBracket, 0);
}

tree::TerminalNode* PhpParser::ParenthesesContext::CloseRoundBracket() {
  return getToken(PhpParser::CloseRoundBracket, 0);
}

PhpParser::ExpressionContext* PhpParser::ParenthesesContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

PhpParser::YieldExpressionContext* PhpParser::ParenthesesContext::yieldExpression() {
  return getRuleContext<PhpParser::YieldExpressionContext>(0);
}


size_t PhpParser::ParenthesesContext::getRuleIndex() const {
  return PhpParser::RuleParentheses;
}

void PhpParser::ParenthesesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParentheses(this);
}

void PhpParser::ParenthesesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParentheses(this);
}

PhpParser::ParenthesesContext* PhpParser::parentheses() {
  ParenthesesContext *_localctx = _tracker.createInstance<ParenthesesContext>(_ctx, getState());
  enterRule(_localctx, 162, PhpParser::RuleParentheses);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1182);
    match(PhpParser::OpenRoundBracket);
    setState(1185);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 135, _ctx)) {
    case 1: {
      setState(1183);
      expression(0);
      break;
    }

    case 2: {
      setState(1184);
      yieldExpression();
      break;
    }

    default:
      break;
    }
    setState(1187);
    match(PhpParser::CloseRoundBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

PhpParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t PhpParser::ExpressionContext::getRuleIndex() const {
  return PhpParser::RuleExpression;
}

void PhpParser::ExpressionContext::copyFrom(ExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ChainExpressionContext ------------------------------------------------------------------

PhpParser::ChainContext* PhpParser::ChainExpressionContext::chain() {
  return getRuleContext<PhpParser::ChainContext>(0);
}

PhpParser::ChainExpressionContext::ChainExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::ChainExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChainExpression(this);
}
void PhpParser::ChainExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChainExpression(this);
}
//----------------- SpecialWordExpressionContext ------------------------------------------------------------------

tree::TerminalNode* PhpParser::SpecialWordExpressionContext::Yield() {
  return getToken(PhpParser::Yield, 0);
}

tree::TerminalNode* PhpParser::SpecialWordExpressionContext::List() {
  return getToken(PhpParser::List, 0);
}

tree::TerminalNode* PhpParser::SpecialWordExpressionContext::OpenRoundBracket() {
  return getToken(PhpParser::OpenRoundBracket, 0);
}

PhpParser::AssignmentListContext* PhpParser::SpecialWordExpressionContext::assignmentList() {
  return getRuleContext<PhpParser::AssignmentListContext>(0);
}

tree::TerminalNode* PhpParser::SpecialWordExpressionContext::CloseRoundBracket() {
  return getToken(PhpParser::CloseRoundBracket, 0);
}

tree::TerminalNode* PhpParser::SpecialWordExpressionContext::Eq() {
  return getToken(PhpParser::Eq, 0);
}

PhpParser::ExpressionContext* PhpParser::SpecialWordExpressionContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

tree::TerminalNode* PhpParser::SpecialWordExpressionContext::IsSet() {
  return getToken(PhpParser::IsSet, 0);
}

PhpParser::ChainListContext* PhpParser::SpecialWordExpressionContext::chainList() {
  return getRuleContext<PhpParser::ChainListContext>(0);
}

tree::TerminalNode* PhpParser::SpecialWordExpressionContext::Empty() {
  return getToken(PhpParser::Empty, 0);
}

PhpParser::ChainContext* PhpParser::SpecialWordExpressionContext::chain() {
  return getRuleContext<PhpParser::ChainContext>(0);
}

tree::TerminalNode* PhpParser::SpecialWordExpressionContext::Eval() {
  return getToken(PhpParser::Eval, 0);
}

tree::TerminalNode* PhpParser::SpecialWordExpressionContext::Exit() {
  return getToken(PhpParser::Exit, 0);
}

PhpParser::ParenthesesContext* PhpParser::SpecialWordExpressionContext::parentheses() {
  return getRuleContext<PhpParser::ParenthesesContext>(0);
}

tree::TerminalNode* PhpParser::SpecialWordExpressionContext::Include() {
  return getToken(PhpParser::Include, 0);
}

tree::TerminalNode* PhpParser::SpecialWordExpressionContext::IncludeOnce() {
  return getToken(PhpParser::IncludeOnce, 0);
}

tree::TerminalNode* PhpParser::SpecialWordExpressionContext::Require() {
  return getToken(PhpParser::Require, 0);
}

tree::TerminalNode* PhpParser::SpecialWordExpressionContext::RequireOnce() {
  return getToken(PhpParser::RequireOnce, 0);
}

tree::TerminalNode* PhpParser::SpecialWordExpressionContext::Throw() {
  return getToken(PhpParser::Throw, 0);
}

PhpParser::SpecialWordExpressionContext::SpecialWordExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::SpecialWordExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpecialWordExpression(this);
}
void PhpParser::SpecialWordExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpecialWordExpression(this);
}
//----------------- ArrayCreationExpressionContext ------------------------------------------------------------------

PhpParser::ArrayCreationContext* PhpParser::ArrayCreationExpressionContext::arrayCreation() {
  return getRuleContext<PhpParser::ArrayCreationContext>(0);
}

PhpParser::ArrayCreationExpressionContext::ArrayCreationExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::ArrayCreationExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayCreationExpression(this);
}
void PhpParser::ArrayCreationExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayCreationExpression(this);
}
//----------------- BackQuoteStringExpressionContext ------------------------------------------------------------------

tree::TerminalNode* PhpParser::BackQuoteStringExpressionContext::BackQuoteString() {
  return getToken(PhpParser::BackQuoteString, 0);
}

PhpParser::BackQuoteStringExpressionContext::BackQuoteStringExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::BackQuoteStringExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBackQuoteStringExpression(this);
}
void PhpParser::BackQuoteStringExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBackQuoteStringExpression(this);
}
//----------------- MatchExpressionContext ------------------------------------------------------------------

PhpParser::MatchExprContext* PhpParser::MatchExpressionContext::matchExpr() {
  return getRuleContext<PhpParser::MatchExprContext>(0);
}

PhpParser::MatchExpressionContext::MatchExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::MatchExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMatchExpression(this);
}
void PhpParser::MatchExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMatchExpression(this);
}
//----------------- LogicalExpressionContext ------------------------------------------------------------------

std::vector<PhpParser::ExpressionContext *> PhpParser::LogicalExpressionContext::expression() {
  return getRuleContexts<PhpParser::ExpressionContext>();
}

PhpParser::ExpressionContext* PhpParser::LogicalExpressionContext::expression(size_t i) {
  return getRuleContext<PhpParser::ExpressionContext>(i);
}

tree::TerminalNode* PhpParser::LogicalExpressionContext::LogicalAnd() {
  return getToken(PhpParser::LogicalAnd, 0);
}

tree::TerminalNode* PhpParser::LogicalExpressionContext::LogicalXor() {
  return getToken(PhpParser::LogicalXor, 0);
}

tree::TerminalNode* PhpParser::LogicalExpressionContext::LogicalOr() {
  return getToken(PhpParser::LogicalOr, 0);
}

PhpParser::LogicalExpressionContext::LogicalExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::LogicalExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalExpression(this);
}
void PhpParser::LogicalExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalExpression(this);
}
//----------------- PrintExpressionContext ------------------------------------------------------------------

tree::TerminalNode* PhpParser::PrintExpressionContext::Print() {
  return getToken(PhpParser::Print, 0);
}

PhpParser::ExpressionContext* PhpParser::PrintExpressionContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

PhpParser::PrintExpressionContext::PrintExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::PrintExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrintExpression(this);
}
void PhpParser::PrintExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrintExpression(this);
}
//----------------- AssignmentExpressionContext ------------------------------------------------------------------

PhpParser::AssignableContext* PhpParser::AssignmentExpressionContext::assignable() {
  return getRuleContext<PhpParser::AssignableContext>(0);
}

PhpParser::AssignmentOperatorContext* PhpParser::AssignmentExpressionContext::assignmentOperator() {
  return getRuleContext<PhpParser::AssignmentOperatorContext>(0);
}

PhpParser::ExpressionContext* PhpParser::AssignmentExpressionContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

PhpParser::AttributesContext* PhpParser::AssignmentExpressionContext::attributes() {
  return getRuleContext<PhpParser::AttributesContext>(0);
}

tree::TerminalNode* PhpParser::AssignmentExpressionContext::Eq() {
  return getToken(PhpParser::Eq, 0);
}

tree::TerminalNode* PhpParser::AssignmentExpressionContext::Ampersand() {
  return getToken(PhpParser::Ampersand, 0);
}

PhpParser::ChainContext* PhpParser::AssignmentExpressionContext::chain() {
  return getRuleContext<PhpParser::ChainContext>(0);
}

PhpParser::NewExprContext* PhpParser::AssignmentExpressionContext::newExpr() {
  return getRuleContext<PhpParser::NewExprContext>(0);
}

PhpParser::AssignmentExpressionContext::AssignmentExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::AssignmentExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentExpression(this);
}
void PhpParser::AssignmentExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentExpression(this);
}
//----------------- PostfixIncDecExpressionContext ------------------------------------------------------------------

PhpParser::ChainContext* PhpParser::PostfixIncDecExpressionContext::chain() {
  return getRuleContext<PhpParser::ChainContext>(0);
}

tree::TerminalNode* PhpParser::PostfixIncDecExpressionContext::Inc() {
  return getToken(PhpParser::Inc, 0);
}

tree::TerminalNode* PhpParser::PostfixIncDecExpressionContext::Dec() {
  return getToken(PhpParser::Dec, 0);
}

PhpParser::PostfixIncDecExpressionContext::PostfixIncDecExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::PostfixIncDecExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostfixIncDecExpression(this);
}
void PhpParser::PostfixIncDecExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostfixIncDecExpression(this);
}
//----------------- CloneExpressionContext ------------------------------------------------------------------

tree::TerminalNode* PhpParser::CloneExpressionContext::Clone() {
  return getToken(PhpParser::Clone, 0);
}

PhpParser::ExpressionContext* PhpParser::CloneExpressionContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

PhpParser::CloneExpressionContext::CloneExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::CloneExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCloneExpression(this);
}
void PhpParser::CloneExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCloneExpression(this);
}
//----------------- UnaryOperatorExpressionContext ------------------------------------------------------------------

PhpParser::ExpressionContext* PhpParser::UnaryOperatorExpressionContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

tree::TerminalNode* PhpParser::UnaryOperatorExpressionContext::Tilde() {
  return getToken(PhpParser::Tilde, 0);
}

tree::TerminalNode* PhpParser::UnaryOperatorExpressionContext::SuppressWarnings() {
  return getToken(PhpParser::SuppressWarnings, 0);
}

tree::TerminalNode* PhpParser::UnaryOperatorExpressionContext::Bang() {
  return getToken(PhpParser::Bang, 0);
}

tree::TerminalNode* PhpParser::UnaryOperatorExpressionContext::Plus() {
  return getToken(PhpParser::Plus, 0);
}

tree::TerminalNode* PhpParser::UnaryOperatorExpressionContext::Minus() {
  return getToken(PhpParser::Minus, 0);
}

PhpParser::UnaryOperatorExpressionContext::UnaryOperatorExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::UnaryOperatorExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryOperatorExpression(this);
}
void PhpParser::UnaryOperatorExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryOperatorExpression(this);
}
//----------------- NewExpressionContext ------------------------------------------------------------------

PhpParser::NewExprContext* PhpParser::NewExpressionContext::newExpr() {
  return getRuleContext<PhpParser::NewExprContext>(0);
}

PhpParser::NewExpressionContext::NewExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::NewExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNewExpression(this);
}
void PhpParser::NewExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNewExpression(this);
}
//----------------- ParenthesisExpressionContext ------------------------------------------------------------------

PhpParser::ParenthesesContext* PhpParser::ParenthesisExpressionContext::parentheses() {
  return getRuleContext<PhpParser::ParenthesesContext>(0);
}

PhpParser::ParenthesisExpressionContext::ParenthesisExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::ParenthesisExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParenthesisExpression(this);
}
void PhpParser::ParenthesisExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParenthesisExpression(this);
}
//----------------- SpaceshipExpressionContext ------------------------------------------------------------------

std::vector<PhpParser::ExpressionContext *> PhpParser::SpaceshipExpressionContext::expression() {
  return getRuleContexts<PhpParser::ExpressionContext>();
}

PhpParser::ExpressionContext* PhpParser::SpaceshipExpressionContext::expression(size_t i) {
  return getRuleContext<PhpParser::ExpressionContext>(i);
}

tree::TerminalNode* PhpParser::SpaceshipExpressionContext::Spaceship() {
  return getToken(PhpParser::Spaceship, 0);
}

PhpParser::SpaceshipExpressionContext::SpaceshipExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::SpaceshipExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpaceshipExpression(this);
}
void PhpParser::SpaceshipExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpaceshipExpression(this);
}
//----------------- ConditionalExpressionContext ------------------------------------------------------------------

std::vector<PhpParser::ExpressionContext *> PhpParser::ConditionalExpressionContext::expression() {
  return getRuleContexts<PhpParser::ExpressionContext>();
}

PhpParser::ExpressionContext* PhpParser::ConditionalExpressionContext::expression(size_t i) {
  return getRuleContext<PhpParser::ExpressionContext>(i);
}

tree::TerminalNode* PhpParser::ConditionalExpressionContext::Colon() {
  return getToken(PhpParser::Colon, 0);
}

tree::TerminalNode* PhpParser::ConditionalExpressionContext::QuestionMark() {
  return getToken(PhpParser::QuestionMark, 0);
}

PhpParser::ConditionalExpressionContext::ConditionalExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::ConditionalExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionalExpression(this);
}
void PhpParser::ConditionalExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionalExpression(this);
}
//----------------- NullCoalescingExpressionContext ------------------------------------------------------------------

std::vector<PhpParser::ExpressionContext *> PhpParser::NullCoalescingExpressionContext::expression() {
  return getRuleContexts<PhpParser::ExpressionContext>();
}

PhpParser::ExpressionContext* PhpParser::NullCoalescingExpressionContext::expression(size_t i) {
  return getRuleContext<PhpParser::ExpressionContext>(i);
}

tree::TerminalNode* PhpParser::NullCoalescingExpressionContext::NullCoalescing() {
  return getToken(PhpParser::NullCoalescing, 0);
}

PhpParser::NullCoalescingExpressionContext::NullCoalescingExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::NullCoalescingExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullCoalescingExpression(this);
}
void PhpParser::NullCoalescingExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullCoalescingExpression(this);
}
//----------------- ArithmeticExpressionContext ------------------------------------------------------------------

std::vector<PhpParser::ExpressionContext *> PhpParser::ArithmeticExpressionContext::expression() {
  return getRuleContexts<PhpParser::ExpressionContext>();
}

PhpParser::ExpressionContext* PhpParser::ArithmeticExpressionContext::expression(size_t i) {
  return getRuleContext<PhpParser::ExpressionContext>(i);
}

tree::TerminalNode* PhpParser::ArithmeticExpressionContext::Pow() {
  return getToken(PhpParser::Pow, 0);
}

tree::TerminalNode* PhpParser::ArithmeticExpressionContext::Asterisk() {
  return getToken(PhpParser::Asterisk, 0);
}

tree::TerminalNode* PhpParser::ArithmeticExpressionContext::Divide() {
  return getToken(PhpParser::Divide, 0);
}

tree::TerminalNode* PhpParser::ArithmeticExpressionContext::Percent() {
  return getToken(PhpParser::Percent, 0);
}

tree::TerminalNode* PhpParser::ArithmeticExpressionContext::Plus() {
  return getToken(PhpParser::Plus, 0);
}

tree::TerminalNode* PhpParser::ArithmeticExpressionContext::Minus() {
  return getToken(PhpParser::Minus, 0);
}

tree::TerminalNode* PhpParser::ArithmeticExpressionContext::Dot() {
  return getToken(PhpParser::Dot, 0);
}

PhpParser::ArithmeticExpressionContext::ArithmeticExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::ArithmeticExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArithmeticExpression(this);
}
void PhpParser::ArithmeticExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArithmeticExpression(this);
}
//----------------- IndexerExpressionContext ------------------------------------------------------------------

PhpParser::StringConstantContext* PhpParser::IndexerExpressionContext::stringConstant() {
  return getRuleContext<PhpParser::StringConstantContext>(0);
}

tree::TerminalNode* PhpParser::IndexerExpressionContext::OpenSquareBracket() {
  return getToken(PhpParser::OpenSquareBracket, 0);
}

PhpParser::ExpressionContext* PhpParser::IndexerExpressionContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

tree::TerminalNode* PhpParser::IndexerExpressionContext::CloseSquareBracket() {
  return getToken(PhpParser::CloseSquareBracket, 0);
}

PhpParser::IndexerExpressionContext::IndexerExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::IndexerExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexerExpression(this);
}
void PhpParser::IndexerExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexerExpression(this);
}
//----------------- ScalarExpressionContext ------------------------------------------------------------------

PhpParser::ConstantContext* PhpParser::ScalarExpressionContext::constant() {
  return getRuleContext<PhpParser::ConstantContext>(0);
}

PhpParser::StringContext* PhpParser::ScalarExpressionContext::string() {
  return getRuleContext<PhpParser::StringContext>(0);
}

tree::TerminalNode* PhpParser::ScalarExpressionContext::Label() {
  return getToken(PhpParser::Label, 0);
}

PhpParser::ScalarExpressionContext::ScalarExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::ScalarExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalarExpression(this);
}
void PhpParser::ScalarExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalarExpression(this);
}
//----------------- PrefixIncDecExpressionContext ------------------------------------------------------------------

PhpParser::ChainContext* PhpParser::PrefixIncDecExpressionContext::chain() {
  return getRuleContext<PhpParser::ChainContext>(0);
}

tree::TerminalNode* PhpParser::PrefixIncDecExpressionContext::Inc() {
  return getToken(PhpParser::Inc, 0);
}

tree::TerminalNode* PhpParser::PrefixIncDecExpressionContext::Dec() {
  return getToken(PhpParser::Dec, 0);
}

PhpParser::PrefixIncDecExpressionContext::PrefixIncDecExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::PrefixIncDecExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrefixIncDecExpression(this);
}
void PhpParser::PrefixIncDecExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrefixIncDecExpression(this);
}
//----------------- ComparisonExpressionContext ------------------------------------------------------------------

std::vector<PhpParser::ExpressionContext *> PhpParser::ComparisonExpressionContext::expression() {
  return getRuleContexts<PhpParser::ExpressionContext>();
}

PhpParser::ExpressionContext* PhpParser::ComparisonExpressionContext::expression(size_t i) {
  return getRuleContext<PhpParser::ExpressionContext>(i);
}

tree::TerminalNode* PhpParser::ComparisonExpressionContext::ShiftLeft() {
  return getToken(PhpParser::ShiftLeft, 0);
}

tree::TerminalNode* PhpParser::ComparisonExpressionContext::ShiftRight() {
  return getToken(PhpParser::ShiftRight, 0);
}

tree::TerminalNode* PhpParser::ComparisonExpressionContext::Less() {
  return getToken(PhpParser::Less, 0);
}

tree::TerminalNode* PhpParser::ComparisonExpressionContext::IsSmallerOrEqual() {
  return getToken(PhpParser::IsSmallerOrEqual, 0);
}

tree::TerminalNode* PhpParser::ComparisonExpressionContext::Greater() {
  return getToken(PhpParser::Greater, 0);
}

tree::TerminalNode* PhpParser::ComparisonExpressionContext::IsGreaterOrEqual() {
  return getToken(PhpParser::IsGreaterOrEqual, 0);
}

tree::TerminalNode* PhpParser::ComparisonExpressionContext::IsIdentical() {
  return getToken(PhpParser::IsIdentical, 0);
}

tree::TerminalNode* PhpParser::ComparisonExpressionContext::IsNoidentical() {
  return getToken(PhpParser::IsNoidentical, 0);
}

tree::TerminalNode* PhpParser::ComparisonExpressionContext::IsEqual() {
  return getToken(PhpParser::IsEqual, 0);
}

tree::TerminalNode* PhpParser::ComparisonExpressionContext::IsNotEq() {
  return getToken(PhpParser::IsNotEq, 0);
}

PhpParser::ComparisonExpressionContext::ComparisonExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::ComparisonExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparisonExpression(this);
}
void PhpParser::ComparisonExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparisonExpression(this);
}
//----------------- CastExpressionContext ------------------------------------------------------------------

tree::TerminalNode* PhpParser::CastExpressionContext::OpenRoundBracket() {
  return getToken(PhpParser::OpenRoundBracket, 0);
}

PhpParser::CastOperationContext* PhpParser::CastExpressionContext::castOperation() {
  return getRuleContext<PhpParser::CastOperationContext>(0);
}

tree::TerminalNode* PhpParser::CastExpressionContext::CloseRoundBracket() {
  return getToken(PhpParser::CloseRoundBracket, 0);
}

PhpParser::ExpressionContext* PhpParser::CastExpressionContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

PhpParser::CastExpressionContext::CastExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::CastExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCastExpression(this);
}
void PhpParser::CastExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCastExpression(this);
}
//----------------- InstanceOfExpressionContext ------------------------------------------------------------------

PhpParser::ExpressionContext* PhpParser::InstanceOfExpressionContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

tree::TerminalNode* PhpParser::InstanceOfExpressionContext::InstanceOf() {
  return getToken(PhpParser::InstanceOf, 0);
}

PhpParser::TypeRefContext* PhpParser::InstanceOfExpressionContext::typeRef() {
  return getRuleContext<PhpParser::TypeRefContext>(0);
}

PhpParser::InstanceOfExpressionContext::InstanceOfExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::InstanceOfExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInstanceOfExpression(this);
}
void PhpParser::InstanceOfExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInstanceOfExpression(this);
}
//----------------- ArrayDestructExpressionContext ------------------------------------------------------------------

PhpParser::ArrayDestructuringContext* PhpParser::ArrayDestructExpressionContext::arrayDestructuring() {
  return getRuleContext<PhpParser::ArrayDestructuringContext>(0);
}

tree::TerminalNode* PhpParser::ArrayDestructExpressionContext::Eq() {
  return getToken(PhpParser::Eq, 0);
}

PhpParser::ExpressionContext* PhpParser::ArrayDestructExpressionContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

PhpParser::ArrayDestructExpressionContext::ArrayDestructExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::ArrayDestructExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayDestructExpression(this);
}
void PhpParser::ArrayDestructExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayDestructExpression(this);
}
//----------------- LambdaFunctionExpressionContext ------------------------------------------------------------------

PhpParser::LambdaFunctionExprContext* PhpParser::LambdaFunctionExpressionContext::lambdaFunctionExpr() {
  return getRuleContext<PhpParser::LambdaFunctionExprContext>(0);
}

PhpParser::LambdaFunctionExpressionContext::LambdaFunctionExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::LambdaFunctionExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLambdaFunctionExpression(this);
}
void PhpParser::LambdaFunctionExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLambdaFunctionExpression(this);
}
//----------------- BitwiseExpressionContext ------------------------------------------------------------------

std::vector<PhpParser::ExpressionContext *> PhpParser::BitwiseExpressionContext::expression() {
  return getRuleContexts<PhpParser::ExpressionContext>();
}

PhpParser::ExpressionContext* PhpParser::BitwiseExpressionContext::expression(size_t i) {
  return getRuleContext<PhpParser::ExpressionContext>(i);
}

tree::TerminalNode* PhpParser::BitwiseExpressionContext::Ampersand() {
  return getToken(PhpParser::Ampersand, 0);
}

tree::TerminalNode* PhpParser::BitwiseExpressionContext::Caret() {
  return getToken(PhpParser::Caret, 0);
}

tree::TerminalNode* PhpParser::BitwiseExpressionContext::Pipe() {
  return getToken(PhpParser::Pipe, 0);
}

tree::TerminalNode* PhpParser::BitwiseExpressionContext::BooleanAnd() {
  return getToken(PhpParser::BooleanAnd, 0);
}

tree::TerminalNode* PhpParser::BitwiseExpressionContext::BooleanOr() {
  return getToken(PhpParser::BooleanOr, 0);
}

PhpParser::BitwiseExpressionContext::BitwiseExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void PhpParser::BitwiseExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitwiseExpression(this);
}
void PhpParser::BitwiseExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitwiseExpression(this);
}

PhpParser::ExpressionContext* PhpParser::expression() {
   return expression(0);
}

PhpParser::ExpressionContext* PhpParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  PhpParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  PhpParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 164;
  enterRecursionRule(_localctx, 164, PhpParser::RuleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1279);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 140, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<CloneExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(1190);
      match(PhpParser::Clone);
      setState(1191);
      expression(48);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<NewExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1192);
      newExpr();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<IndexerExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1193);
      stringConstant();
      setState(1194);
      match(PhpParser::OpenSquareBracket);
      setState(1195);
      expression(0);
      setState(1196);
      match(PhpParser::CloseSquareBracket);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<CastExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1198);
      match(PhpParser::OpenRoundBracket);
      setState(1199);
      castOperation();
      setState(1200);
      match(PhpParser::CloseRoundBracket);
      setState(1201);
      expression(45);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<UnaryOperatorExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1203);
      _la = _input->LA(1);
      if (!(_la == PhpParser::Tilde

      || _la == PhpParser::SuppressWarnings)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1204);
      expression(44);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<UnaryOperatorExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1205);
      _la = _input->LA(1);
      if (!(((((_la - 200) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 200)) & 13) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1206);
      expression(43);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<PrefixIncDecExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1207);
      _la = _input->LA(1);
      if (!(_la == PhpParser::Inc

      || _la == PhpParser::Dec)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1208);
      chain();
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<PostfixIncDecExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1209);
      chain();
      setState(1210);
      _la = _input->LA(1);
      if (!(_la == PhpParser::Inc

      || _la == PhpParser::Dec)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<PrintExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1212);
      match(PhpParser::Print);
      setState(1213);
      expression(40);
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<ArrayCreationExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1214);
      arrayCreation();
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<ChainExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1215);
      chain();
      break;
    }

    case 12: {
      _localctx = _tracker.createInstance<ScalarExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1216);
      constant();
      break;
    }

    case 13: {
      _localctx = _tracker.createInstance<ScalarExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1217);
      string();
      break;
    }

    case 14: {
      _localctx = _tracker.createInstance<ScalarExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1218);
      match(PhpParser::Label);
      break;
    }

    case 15: {
      _localctx = _tracker.createInstance<BackQuoteStringExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1219);
      match(PhpParser::BackQuoteString);
      break;
    }

    case 16: {
      _localctx = _tracker.createInstance<ParenthesisExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1220);
      parentheses();
      break;
    }

    case 17: {
      _localctx = _tracker.createInstance<SpecialWordExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1221);
      match(PhpParser::Yield);
      break;
    }

    case 18: {
      _localctx = _tracker.createInstance<SpecialWordExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1222);
      match(PhpParser::List);
      setState(1223);
      match(PhpParser::OpenRoundBracket);
      setState(1224);
      assignmentList();
      setState(1225);
      match(PhpParser::CloseRoundBracket);
      setState(1226);
      match(PhpParser::Eq);
      setState(1227);
      expression(31);
      break;
    }

    case 19: {
      _localctx = _tracker.createInstance<SpecialWordExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1229);
      match(PhpParser::IsSet);
      setState(1230);
      match(PhpParser::OpenRoundBracket);
      setState(1231);
      chainList();
      setState(1232);
      match(PhpParser::CloseRoundBracket);
      break;
    }

    case 20: {
      _localctx = _tracker.createInstance<SpecialWordExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1234);
      match(PhpParser::Empty);
      setState(1235);
      match(PhpParser::OpenRoundBracket);
      setState(1236);
      chain();
      setState(1237);
      match(PhpParser::CloseRoundBracket);
      break;
    }

    case 21: {
      _localctx = _tracker.createInstance<SpecialWordExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1239);
      match(PhpParser::Eval);
      setState(1240);
      match(PhpParser::OpenRoundBracket);
      setState(1241);
      expression(0);
      setState(1242);
      match(PhpParser::CloseRoundBracket);
      break;
    }

    case 22: {
      _localctx = _tracker.createInstance<SpecialWordExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1244);
      match(PhpParser::Exit);
      setState(1248);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx)) {
      case 1: {
        setState(1245);
        match(PhpParser::OpenRoundBracket);
        setState(1246);
        match(PhpParser::CloseRoundBracket);
        break;
      }

      case 2: {
        setState(1247);
        parentheses();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 23: {
      _localctx = _tracker.createInstance<SpecialWordExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1250);
      _la = _input->LA(1);
      if (!(_la == PhpParser::Include

      || _la == PhpParser::IncludeOnce)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1251);
      expression(26);
      break;
    }

    case 24: {
      _localctx = _tracker.createInstance<SpecialWordExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1252);
      _la = _input->LA(1);
      if (!(_la == PhpParser::Require

      || _la == PhpParser::RequireOnce)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1253);
      expression(25);
      break;
    }

    case 25: {
      _localctx = _tracker.createInstance<LambdaFunctionExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1254);
      lambdaFunctionExpr();
      break;
    }

    case 26: {
      _localctx = _tracker.createInstance<MatchExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1255);
      matchExpr();
      break;
    }

    case 27: {
      _localctx = _tracker.createInstance<SpecialWordExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1256);
      match(PhpParser::Throw);
      setState(1257);
      expression(7);
      break;
    }

    case 28: {
      _localctx = _tracker.createInstance<ArrayDestructExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1258);
      arrayDestructuring();
      setState(1259);
      match(PhpParser::Eq);
      setState(1260);
      expression(6);
      break;
    }

    case 29: {
      _localctx = _tracker.createInstance<AssignmentExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1262);
      assignable();
      setState(1263);
      assignmentOperator();
      setState(1265);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PhpParser::AttributeStart) {
        setState(1264);
        attributes();
      }
      setState(1267);
      expression(5);
      break;
    }

    case 30: {
      _localctx = _tracker.createInstance<AssignmentExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1269);
      assignable();
      setState(1270);
      match(PhpParser::Eq);
      setState(1272);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PhpParser::AttributeStart) {
        setState(1271);
        attributes();
      }
      setState(1274);
      match(PhpParser::Ampersand);
      setState(1277);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 139, _ctx)) {
      case 1: {
        setState(1275);
        chain();
        break;
      }

      case 2: {
        setState(1276);
        newExpr();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(1341);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(1339);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<ArithmeticExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(1281);

          if (!(precpred(_ctx, 22))) throw FailedPredicateException(this, "precpred(_ctx, 22)");
          setState(1282);
          antlrcpp::downCast<ArithmeticExpressionContext *>(_localctx)->op = match(PhpParser::Pow);
          setState(1283);
          expression(22);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<ArithmeticExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(1284);

          if (!(precpred(_ctx, 20))) throw FailedPredicateException(this, "precpred(_ctx, 20)");
          setState(1285);
          antlrcpp::downCast<ArithmeticExpressionContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(((((_la - 204) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 204)) & 7) != 0))) {
            antlrcpp::downCast<ArithmeticExpressionContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1286);
          expression(21);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<ArithmeticExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(1287);

          if (!(precpred(_ctx, 19))) throw FailedPredicateException(this, "precpred(_ctx, 19)");
          setState(1288);
          antlrcpp::downCast<ArithmeticExpressionContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(((((_la - 202) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 202)) & 259) != 0))) {
            antlrcpp::downCast<ArithmeticExpressionContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1289);
          expression(20);
          break;
        }

        case 4: {
          auto newContext = _tracker.createInstance<ComparisonExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(1290);

          if (!(precpred(_ctx, 18))) throw FailedPredicateException(this, "precpred(_ctx, 18)");
          setState(1291);
          antlrcpp::downCast<ComparisonExpressionContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == PhpParser::ShiftLeft

          || _la == PhpParser::ShiftRight)) {
            antlrcpp::downCast<ComparisonExpressionContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1292);
          expression(19);
          break;
        }

        case 5: {
          auto newContext = _tracker.createInstance<ComparisonExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(1293);

          if (!(precpred(_ctx, 17))) throw FailedPredicateException(this, "precpred(_ctx, 17)");
          setState(1294);
          antlrcpp::downCast<ComparisonExpressionContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(((((_la - 171) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 171)) & 100663299) != 0))) {
            antlrcpp::downCast<ComparisonExpressionContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1295);
          expression(18);
          break;
        }

        case 6: {
          auto newContext = _tracker.createInstance<ComparisonExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(1296);

          if (!(precpred(_ctx, 16))) throw FailedPredicateException(this, "precpred(_ctx, 16)");
          setState(1297);
          antlrcpp::downCast<ComparisonExpressionContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(((((_la - 167) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 167)) & 15) != 0))) {
            antlrcpp::downCast<ComparisonExpressionContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1298);
          expression(17);
          break;
        }

        case 7: {
          auto newContext = _tracker.createInstance<BitwiseExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(1299);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(1300);
          antlrcpp::downCast<BitwiseExpressionContext *>(_localctx)->op = match(PhpParser::Ampersand);
          setState(1301);
          expression(16);
          break;
        }

        case 8: {
          auto newContext = _tracker.createInstance<BitwiseExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(1302);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(1303);
          antlrcpp::downCast<BitwiseExpressionContext *>(_localctx)->op = match(PhpParser::Caret);
          setState(1304);
          expression(15);
          break;
        }

        case 9: {
          auto newContext = _tracker.createInstance<BitwiseExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(1305);

          if (!(precpred(_ctx, 13))) throw FailedPredicateException(this, "precpred(_ctx, 13)");
          setState(1306);
          antlrcpp::downCast<BitwiseExpressionContext *>(_localctx)->op = match(PhpParser::Pipe);
          setState(1307);
          expression(14);
          break;
        }

        case 10: {
          auto newContext = _tracker.createInstance<BitwiseExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(1308);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(1309);
          antlrcpp::downCast<BitwiseExpressionContext *>(_localctx)->op = match(PhpParser::BooleanAnd);
          setState(1310);
          expression(13);
          break;
        }

        case 11: {
          auto newContext = _tracker.createInstance<BitwiseExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(1311);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(1312);
          antlrcpp::downCast<BitwiseExpressionContext *>(_localctx)->op = match(PhpParser::BooleanOr);
          setState(1313);
          expression(12);
          break;
        }

        case 12: {
          auto newContext = _tracker.createInstance<ConditionalExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(1314);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(1315);
          antlrcpp::downCast<ConditionalExpressionContext *>(_localctx)->op = match(PhpParser::QuestionMark);
          setState(1317);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (((((_la - 44) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 44)) & -1) != 0) || ((((_la - 108) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 108)) & 441352763482308607) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 194)) & 4396974138177) != 0)) {
            setState(1316);
            expression(0);
          }
          setState(1319);
          match(PhpParser::Colon);
          setState(1320);
          expression(11);
          break;
        }

        case 13: {
          auto newContext = _tracker.createInstance<NullCoalescingExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(1321);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(1322);
          antlrcpp::downCast<NullCoalescingExpressionContext *>(_localctx)->op = match(PhpParser::NullCoalescing);
          setState(1323);
          expression(10);
          break;
        }

        case 14: {
          auto newContext = _tracker.createInstance<SpaceshipExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(1324);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(1325);
          antlrcpp::downCast<SpaceshipExpressionContext *>(_localctx)->op = match(PhpParser::Spaceship);
          setState(1326);
          expression(9);
          break;
        }

        case 15: {
          auto newContext = _tracker.createInstance<LogicalExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(1327);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(1328);
          antlrcpp::downCast<LogicalExpressionContext *>(_localctx)->op = match(PhpParser::LogicalAnd);
          setState(1329);
          expression(4);
          break;
        }

        case 16: {
          auto newContext = _tracker.createInstance<LogicalExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(1330);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(1331);
          antlrcpp::downCast<LogicalExpressionContext *>(_localctx)->op = match(PhpParser::LogicalXor);
          setState(1332);
          expression(3);
          break;
        }

        case 17: {
          auto newContext = _tracker.createInstance<LogicalExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(1333);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(1334);
          antlrcpp::downCast<LogicalExpressionContext *>(_localctx)->op = match(PhpParser::LogicalOr);
          setState(1335);
          expression(2);
          break;
        }

        case 18: {
          auto newContext = _tracker.createInstance<InstanceOfExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(1336);

          if (!(precpred(_ctx, 21))) throw FailedPredicateException(this, "precpred(_ctx, 21)");
          setState(1337);
          match(PhpParser::InstanceOf);
          setState(1338);
          typeRef();
          break;
        }

        default:
          break;
        } 
      }
      setState(1343);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- AssignableContext ------------------------------------------------------------------

PhpParser::AssignableContext::AssignableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::ChainContext* PhpParser::AssignableContext::chain() {
  return getRuleContext<PhpParser::ChainContext>(0);
}

PhpParser::ArrayCreationContext* PhpParser::AssignableContext::arrayCreation() {
  return getRuleContext<PhpParser::ArrayCreationContext>(0);
}


size_t PhpParser::AssignableContext::getRuleIndex() const {
  return PhpParser::RuleAssignable;
}

void PhpParser::AssignableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignable(this);
}

void PhpParser::AssignableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignable(this);
}

PhpParser::AssignableContext* PhpParser::assignable() {
  AssignableContext *_localctx = _tracker.createInstance<AssignableContext>(_ctx, getState());
  enterRule(_localctx, 166, PhpParser::RuleAssignable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1346);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1344);
      chain();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1345);
      arrayCreation();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayCreationContext ------------------------------------------------------------------

PhpParser::ArrayCreationContext::ArrayCreationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::ArrayCreationContext::Array() {
  return getToken(PhpParser::Array, 0);
}

tree::TerminalNode* PhpParser::ArrayCreationContext::OpenRoundBracket() {
  return getToken(PhpParser::OpenRoundBracket, 0);
}

tree::TerminalNode* PhpParser::ArrayCreationContext::CloseRoundBracket() {
  return getToken(PhpParser::CloseRoundBracket, 0);
}

std::vector<tree::TerminalNode *> PhpParser::ArrayCreationContext::OpenSquareBracket() {
  return getTokens(PhpParser::OpenSquareBracket);
}

tree::TerminalNode* PhpParser::ArrayCreationContext::OpenSquareBracket(size_t i) {
  return getToken(PhpParser::OpenSquareBracket, i);
}

std::vector<tree::TerminalNode *> PhpParser::ArrayCreationContext::CloseSquareBracket() {
  return getTokens(PhpParser::CloseSquareBracket);
}

tree::TerminalNode* PhpParser::ArrayCreationContext::CloseSquareBracket(size_t i) {
  return getToken(PhpParser::CloseSquareBracket, i);
}

PhpParser::ExpressionContext* PhpParser::ArrayCreationContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

PhpParser::ArrayItemListContext* PhpParser::ArrayCreationContext::arrayItemList() {
  return getRuleContext<PhpParser::ArrayItemListContext>(0);
}


size_t PhpParser::ArrayCreationContext::getRuleIndex() const {
  return PhpParser::RuleArrayCreation;
}

void PhpParser::ArrayCreationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayCreation(this);
}

void PhpParser::ArrayCreationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayCreation(this);
}

PhpParser::ArrayCreationContext* PhpParser::arrayCreation() {
  ArrayCreationContext *_localctx = _tracker.createInstance<ArrayCreationContext>(_ctx, getState());
  enterRule(_localctx, 168, PhpParser::RuleArrayCreation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1359);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::Array: {
        setState(1348);
        match(PhpParser::Array);
        setState(1349);
        match(PhpParser::OpenRoundBracket);
        setState(1351);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 44) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 44)) & -1) != 0) || ((((_la - 108) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 108)) & 441352763482308607) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 194)) & 4396974138193) != 0)) {
          setState(1350);
          arrayItemList();
        }
        setState(1353);
        match(PhpParser::CloseRoundBracket);
        break;
      }

      case PhpParser::OpenSquareBracket: {
        setState(1354);
        match(PhpParser::OpenSquareBracket);
        setState(1356);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 44) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 44)) & -1) != 0) || ((((_la - 108) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 108)) & 441352763482308607) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 194)) & 4396974138193) != 0)) {
          setState(1355);
          arrayItemList();
        }
        setState(1358);
        match(PhpParser::CloseSquareBracket);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1365);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 148, _ctx)) {
    case 1: {
      setState(1361);
      match(PhpParser::OpenSquareBracket);
      setState(1362);
      expression(0);
      setState(1363);
      match(PhpParser::CloseSquareBracket);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayDestructuringContext ------------------------------------------------------------------

PhpParser::ArrayDestructuringContext::ArrayDestructuringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::ArrayDestructuringContext::OpenSquareBracket() {
  return getToken(PhpParser::OpenSquareBracket, 0);
}

std::vector<PhpParser::IndexedDestructItemContext *> PhpParser::ArrayDestructuringContext::indexedDestructItem() {
  return getRuleContexts<PhpParser::IndexedDestructItemContext>();
}

PhpParser::IndexedDestructItemContext* PhpParser::ArrayDestructuringContext::indexedDestructItem(size_t i) {
  return getRuleContext<PhpParser::IndexedDestructItemContext>(i);
}

tree::TerminalNode* PhpParser::ArrayDestructuringContext::CloseSquareBracket() {
  return getToken(PhpParser::CloseSquareBracket, 0);
}

std::vector<tree::TerminalNode *> PhpParser::ArrayDestructuringContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::ArrayDestructuringContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}

std::vector<PhpParser::KeyedDestructItemContext *> PhpParser::ArrayDestructuringContext::keyedDestructItem() {
  return getRuleContexts<PhpParser::KeyedDestructItemContext>();
}

PhpParser::KeyedDestructItemContext* PhpParser::ArrayDestructuringContext::keyedDestructItem(size_t i) {
  return getRuleContext<PhpParser::KeyedDestructItemContext>(i);
}


size_t PhpParser::ArrayDestructuringContext::getRuleIndex() const {
  return PhpParser::RuleArrayDestructuring;
}

void PhpParser::ArrayDestructuringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayDestructuring(this);
}

void PhpParser::ArrayDestructuringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayDestructuring(this);
}

PhpParser::ArrayDestructuringContext* PhpParser::arrayDestructuring() {
  ArrayDestructuringContext *_localctx = _tracker.createInstance<ArrayDestructuringContext>(_ctx, getState());
  enterRule(_localctx, 170, PhpParser::RuleArrayDestructuring);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1412);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1367);
      match(PhpParser::OpenSquareBracket);
      setState(1371);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == PhpParser::Comma) {
        setState(1368);
        match(PhpParser::Comma);
        setState(1373);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1374);
      indexedDestructItem();
      setState(1383);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 151, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1376); 
          _errHandler->sync(this);
          _la = _input->LA(1);
          do {
            setState(1375);
            match(PhpParser::Comma);
            setState(1378); 
            _errHandler->sync(this);
            _la = _input->LA(1);
          } while (_la == PhpParser::Comma);
          setState(1380);
          indexedDestructItem(); 
        }
        setState(1385);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 151, _ctx);
      }
      setState(1389);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == PhpParser::Comma) {
        setState(1386);
        match(PhpParser::Comma);
        setState(1391);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1392);
      match(PhpParser::CloseSquareBracket);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1394);
      match(PhpParser::OpenSquareBracket);
      setState(1395);
      keyedDestructItem();
      setState(1404);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1397); 
          _errHandler->sync(this);
          _la = _input->LA(1);
          do {
            setState(1396);
            match(PhpParser::Comma);
            setState(1399); 
            _errHandler->sync(this);
            _la = _input->LA(1);
          } while (_la == PhpParser::Comma);
          setState(1401);
          keyedDestructItem(); 
        }
        setState(1406);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx);
      }
      setState(1408);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PhpParser::Comma) {
        setState(1407);
        match(PhpParser::Comma);
      }
      setState(1410);
      match(PhpParser::CloseSquareBracket);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexedDestructItemContext ------------------------------------------------------------------

PhpParser::IndexedDestructItemContext::IndexedDestructItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::ChainContext* PhpParser::IndexedDestructItemContext::chain() {
  return getRuleContext<PhpParser::ChainContext>(0);
}

tree::TerminalNode* PhpParser::IndexedDestructItemContext::Ampersand() {
  return getToken(PhpParser::Ampersand, 0);
}


size_t PhpParser::IndexedDestructItemContext::getRuleIndex() const {
  return PhpParser::RuleIndexedDestructItem;
}

void PhpParser::IndexedDestructItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexedDestructItem(this);
}

void PhpParser::IndexedDestructItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexedDestructItem(this);
}

PhpParser::IndexedDestructItemContext* PhpParser::indexedDestructItem() {
  IndexedDestructItemContext *_localctx = _tracker.createInstance<IndexedDestructItemContext>(_ctx, getState());
  enterRule(_localctx, 172, PhpParser::RuleIndexedDestructItem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1415);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Ampersand) {
      setState(1414);
      match(PhpParser::Ampersand);
    }
    setState(1417);
    chain();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyedDestructItemContext ------------------------------------------------------------------

PhpParser::KeyedDestructItemContext::KeyedDestructItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::ChainContext* PhpParser::KeyedDestructItemContext::chain() {
  return getRuleContext<PhpParser::ChainContext>(0);
}

PhpParser::ExpressionContext* PhpParser::KeyedDestructItemContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

tree::TerminalNode* PhpParser::KeyedDestructItemContext::DoubleArrow() {
  return getToken(PhpParser::DoubleArrow, 0);
}

tree::TerminalNode* PhpParser::KeyedDestructItemContext::Ampersand() {
  return getToken(PhpParser::Ampersand, 0);
}


size_t PhpParser::KeyedDestructItemContext::getRuleIndex() const {
  return PhpParser::RuleKeyedDestructItem;
}

void PhpParser::KeyedDestructItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyedDestructItem(this);
}

void PhpParser::KeyedDestructItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyedDestructItem(this);
}

PhpParser::KeyedDestructItemContext* PhpParser::keyedDestructItem() {
  KeyedDestructItemContext *_localctx = _tracker.createInstance<KeyedDestructItemContext>(_ctx, getState());
  enterRule(_localctx, 174, PhpParser::RuleKeyedDestructItem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1422);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 158, _ctx)) {
    case 1: {
      setState(1419);
      expression(0);
      setState(1420);
      match(PhpParser::DoubleArrow);
      break;
    }

    default:
      break;
    }
    setState(1425);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Ampersand) {
      setState(1424);
      match(PhpParser::Ampersand);
    }
    setState(1427);
    chain();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LambdaFunctionExprContext ------------------------------------------------------------------

PhpParser::LambdaFunctionExprContext::LambdaFunctionExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::LambdaFunctionExprContext::Function_() {
  return getToken(PhpParser::Function_, 0);
}

tree::TerminalNode* PhpParser::LambdaFunctionExprContext::OpenRoundBracket() {
  return getToken(PhpParser::OpenRoundBracket, 0);
}

PhpParser::FormalParameterListContext* PhpParser::LambdaFunctionExprContext::formalParameterList() {
  return getRuleContext<PhpParser::FormalParameterListContext>(0);
}

tree::TerminalNode* PhpParser::LambdaFunctionExprContext::CloseRoundBracket() {
  return getToken(PhpParser::CloseRoundBracket, 0);
}

PhpParser::BlockStatementContext* PhpParser::LambdaFunctionExprContext::blockStatement() {
  return getRuleContext<PhpParser::BlockStatementContext>(0);
}

tree::TerminalNode* PhpParser::LambdaFunctionExprContext::Static() {
  return getToken(PhpParser::Static, 0);
}

tree::TerminalNode* PhpParser::LambdaFunctionExprContext::Ampersand() {
  return getToken(PhpParser::Ampersand, 0);
}

PhpParser::LambdaFunctionUseVarsContext* PhpParser::LambdaFunctionExprContext::lambdaFunctionUseVars() {
  return getRuleContext<PhpParser::LambdaFunctionUseVarsContext>(0);
}

tree::TerminalNode* PhpParser::LambdaFunctionExprContext::Colon() {
  return getToken(PhpParser::Colon, 0);
}

PhpParser::TypeHintContext* PhpParser::LambdaFunctionExprContext::typeHint() {
  return getRuleContext<PhpParser::TypeHintContext>(0);
}

tree::TerminalNode* PhpParser::LambdaFunctionExprContext::LambdaFn() {
  return getToken(PhpParser::LambdaFn, 0);
}

tree::TerminalNode* PhpParser::LambdaFunctionExprContext::DoubleArrow() {
  return getToken(PhpParser::DoubleArrow, 0);
}

PhpParser::ExpressionContext* PhpParser::LambdaFunctionExprContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}


size_t PhpParser::LambdaFunctionExprContext::getRuleIndex() const {
  return PhpParser::RuleLambdaFunctionExpr;
}

void PhpParser::LambdaFunctionExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLambdaFunctionExpr(this);
}

void PhpParser::LambdaFunctionExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLambdaFunctionExpr(this);
}

PhpParser::LambdaFunctionExprContext* PhpParser::lambdaFunctionExpr() {
  LambdaFunctionExprContext *_localctx = _tracker.createInstance<LambdaFunctionExprContext>(_ctx, getState());
  enterRule(_localctx, 176, PhpParser::RuleLambdaFunctionExpr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1455);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::Function_:
      case PhpParser::Static: {
        enterOuterAlt(_localctx, 1);
        setState(1430);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Static) {
          setState(1429);
          match(PhpParser::Static);
        }
        setState(1432);
        match(PhpParser::Function_);
        setState(1434);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Ampersand) {
          setState(1433);
          match(PhpParser::Ampersand);
        }
        setState(1436);
        match(PhpParser::OpenRoundBracket);
        setState(1437);
        formalParameterList();
        setState(1438);
        match(PhpParser::CloseRoundBracket);
        setState(1440);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Use) {
          setState(1439);
          lambdaFunctionUseVars();
        }
        setState(1444);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Colon) {
          setState(1442);
          match(PhpParser::Colon);
          setState(1443);
          typeHint(0);
        }
        setState(1446);
        blockStatement();
        break;
      }

      case PhpParser::LambdaFn: {
        enterOuterAlt(_localctx, 2);
        setState(1448);
        match(PhpParser::LambdaFn);
        setState(1449);
        match(PhpParser::OpenRoundBracket);
        setState(1450);
        formalParameterList();
        setState(1451);
        match(PhpParser::CloseRoundBracket);
        setState(1452);
        match(PhpParser::DoubleArrow);
        setState(1453);
        expression(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MatchExprContext ------------------------------------------------------------------

PhpParser::MatchExprContext::MatchExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::MatchExprContext::Match_() {
  return getToken(PhpParser::Match_, 0);
}

tree::TerminalNode* PhpParser::MatchExprContext::OpenRoundBracket() {
  return getToken(PhpParser::OpenRoundBracket, 0);
}

PhpParser::ExpressionContext* PhpParser::MatchExprContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

tree::TerminalNode* PhpParser::MatchExprContext::CloseRoundBracket() {
  return getToken(PhpParser::CloseRoundBracket, 0);
}

tree::TerminalNode* PhpParser::MatchExprContext::OpenCurlyBracket() {
  return getToken(PhpParser::OpenCurlyBracket, 0);
}

std::vector<PhpParser::MatchItemContext *> PhpParser::MatchExprContext::matchItem() {
  return getRuleContexts<PhpParser::MatchItemContext>();
}

PhpParser::MatchItemContext* PhpParser::MatchExprContext::matchItem(size_t i) {
  return getRuleContext<PhpParser::MatchItemContext>(i);
}

tree::TerminalNode* PhpParser::MatchExprContext::CloseCurlyBracket() {
  return getToken(PhpParser::CloseCurlyBracket, 0);
}

std::vector<tree::TerminalNode *> PhpParser::MatchExprContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::MatchExprContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::MatchExprContext::getRuleIndex() const {
  return PhpParser::RuleMatchExpr;
}

void PhpParser::MatchExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMatchExpr(this);
}

void PhpParser::MatchExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMatchExpr(this);
}

PhpParser::MatchExprContext* PhpParser::matchExpr() {
  MatchExprContext *_localctx = _tracker.createInstance<MatchExprContext>(_ctx, getState());
  enterRule(_localctx, 178, PhpParser::RuleMatchExpr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1457);
    match(PhpParser::Match_);
    setState(1458);
    match(PhpParser::OpenRoundBracket);
    setState(1459);
    expression(0);
    setState(1460);
    match(PhpParser::CloseRoundBracket);
    setState(1461);
    match(PhpParser::OpenCurlyBracket);
    setState(1462);
    matchItem();
    setState(1467);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1463);
        match(PhpParser::Comma);
        setState(1464);
        matchItem(); 
      }
      setState(1469);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx);
    }
    setState(1471);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Comma) {
      setState(1470);
      match(PhpParser::Comma);
    }
    setState(1473);
    match(PhpParser::CloseCurlyBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MatchItemContext ------------------------------------------------------------------

PhpParser::MatchItemContext::MatchItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::ExpressionContext *> PhpParser::MatchItemContext::expression() {
  return getRuleContexts<PhpParser::ExpressionContext>();
}

PhpParser::ExpressionContext* PhpParser::MatchItemContext::expression(size_t i) {
  return getRuleContext<PhpParser::ExpressionContext>(i);
}

tree::TerminalNode* PhpParser::MatchItemContext::DoubleArrow() {
  return getToken(PhpParser::DoubleArrow, 0);
}

std::vector<tree::TerminalNode *> PhpParser::MatchItemContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::MatchItemContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::MatchItemContext::getRuleIndex() const {
  return PhpParser::RuleMatchItem;
}

void PhpParser::MatchItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMatchItem(this);
}

void PhpParser::MatchItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMatchItem(this);
}

PhpParser::MatchItemContext* PhpParser::matchItem() {
  MatchItemContext *_localctx = _tracker.createInstance<MatchItemContext>(_ctx, getState());
  enterRule(_localctx, 180, PhpParser::RuleMatchItem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1475);
    expression(0);
    setState(1480);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PhpParser::Comma) {
      setState(1476);
      match(PhpParser::Comma);
      setState(1477);
      expression(0);
      setState(1482);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1483);
    match(PhpParser::DoubleArrow);
    setState(1484);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NewExprContext ------------------------------------------------------------------

PhpParser::NewExprContext::NewExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::NewExprContext::New() {
  return getToken(PhpParser::New, 0);
}

PhpParser::TypeRefContext* PhpParser::NewExprContext::typeRef() {
  return getRuleContext<PhpParser::TypeRefContext>(0);
}

PhpParser::ArgumentsContext* PhpParser::NewExprContext::arguments() {
  return getRuleContext<PhpParser::ArgumentsContext>(0);
}


size_t PhpParser::NewExprContext::getRuleIndex() const {
  return PhpParser::RuleNewExpr;
}

void PhpParser::NewExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNewExpr(this);
}

void PhpParser::NewExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNewExpr(this);
}

PhpParser::NewExprContext* PhpParser::newExpr() {
  NewExprContext *_localctx = _tracker.createInstance<NewExprContext>(_ctx, getState());
  enterRule(_localctx, 182, PhpParser::RuleNewExpr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1486);
    match(PhpParser::New);
    setState(1487);
    typeRef();
    setState(1489);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 168, _ctx)) {
    case 1: {
      setState(1488);
      arguments();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentOperatorContext ------------------------------------------------------------------

PhpParser::AssignmentOperatorContext::AssignmentOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::AssignmentOperatorContext::Eq() {
  return getToken(PhpParser::Eq, 0);
}

tree::TerminalNode* PhpParser::AssignmentOperatorContext::PlusEqual() {
  return getToken(PhpParser::PlusEqual, 0);
}

tree::TerminalNode* PhpParser::AssignmentOperatorContext::MinusEqual() {
  return getToken(PhpParser::MinusEqual, 0);
}

tree::TerminalNode* PhpParser::AssignmentOperatorContext::MulEqual() {
  return getToken(PhpParser::MulEqual, 0);
}

tree::TerminalNode* PhpParser::AssignmentOperatorContext::PowEqual() {
  return getToken(PhpParser::PowEqual, 0);
}

tree::TerminalNode* PhpParser::AssignmentOperatorContext::DivEqual() {
  return getToken(PhpParser::DivEqual, 0);
}

tree::TerminalNode* PhpParser::AssignmentOperatorContext::Concaequal() {
  return getToken(PhpParser::Concaequal, 0);
}

tree::TerminalNode* PhpParser::AssignmentOperatorContext::ModEqual() {
  return getToken(PhpParser::ModEqual, 0);
}

tree::TerminalNode* PhpParser::AssignmentOperatorContext::AndEqual() {
  return getToken(PhpParser::AndEqual, 0);
}

tree::TerminalNode* PhpParser::AssignmentOperatorContext::OrEqual() {
  return getToken(PhpParser::OrEqual, 0);
}

tree::TerminalNode* PhpParser::AssignmentOperatorContext::XorEqual() {
  return getToken(PhpParser::XorEqual, 0);
}

tree::TerminalNode* PhpParser::AssignmentOperatorContext::ShiftLeftEqual() {
  return getToken(PhpParser::ShiftLeftEqual, 0);
}

tree::TerminalNode* PhpParser::AssignmentOperatorContext::ShiftRightEqual() {
  return getToken(PhpParser::ShiftRightEqual, 0);
}

tree::TerminalNode* PhpParser::AssignmentOperatorContext::NullCoalescingEqual() {
  return getToken(PhpParser::NullCoalescingEqual, 0);
}


size_t PhpParser::AssignmentOperatorContext::getRuleIndex() const {
  return PhpParser::RuleAssignmentOperator;
}

void PhpParser::AssignmentOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentOperator(this);
}

void PhpParser::AssignmentOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentOperator(this);
}

PhpParser::AssignmentOperatorContext* PhpParser::assignmentOperator() {
  AssignmentOperatorContext *_localctx = _tracker.createInstance<AssignmentOperatorContext>(_ctx, getState());
  enterRule(_localctx, 184, PhpParser::RuleAssignmentOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1491);
    _la = _input->LA(1);
    if (!(((((_la - 173) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 173)) & 281474976784375) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- YieldExpressionContext ------------------------------------------------------------------

PhpParser::YieldExpressionContext::YieldExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::YieldExpressionContext::Yield() {
  return getToken(PhpParser::Yield, 0);
}

std::vector<PhpParser::ExpressionContext *> PhpParser::YieldExpressionContext::expression() {
  return getRuleContexts<PhpParser::ExpressionContext>();
}

PhpParser::ExpressionContext* PhpParser::YieldExpressionContext::expression(size_t i) {
  return getRuleContext<PhpParser::ExpressionContext>(i);
}

tree::TerminalNode* PhpParser::YieldExpressionContext::From() {
  return getToken(PhpParser::From, 0);
}

tree::TerminalNode* PhpParser::YieldExpressionContext::DoubleArrow() {
  return getToken(PhpParser::DoubleArrow, 0);
}


size_t PhpParser::YieldExpressionContext::getRuleIndex() const {
  return PhpParser::RuleYieldExpression;
}

void PhpParser::YieldExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterYieldExpression(this);
}

void PhpParser::YieldExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitYieldExpression(this);
}

PhpParser::YieldExpressionContext* PhpParser::yieldExpression() {
  YieldExpressionContext *_localctx = _tracker.createInstance<YieldExpressionContext>(_ctx, getState());
  enterRule(_localctx, 186, PhpParser::RuleYieldExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1493);
    match(PhpParser::Yield);
    setState(1501);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 170, _ctx)) {
    case 1: {
      setState(1494);
      expression(0);
      setState(1497);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PhpParser::DoubleArrow) {
        setState(1495);
        match(PhpParser::DoubleArrow);
        setState(1496);
        expression(0);
      }
      break;
    }

    case 2: {
      setState(1499);
      match(PhpParser::From);
      setState(1500);
      expression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayItemListContext ------------------------------------------------------------------

PhpParser::ArrayItemListContext::ArrayItemListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::ArrayItemContext *> PhpParser::ArrayItemListContext::arrayItem() {
  return getRuleContexts<PhpParser::ArrayItemContext>();
}

PhpParser::ArrayItemContext* PhpParser::ArrayItemListContext::arrayItem(size_t i) {
  return getRuleContext<PhpParser::ArrayItemContext>(i);
}

std::vector<tree::TerminalNode *> PhpParser::ArrayItemListContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::ArrayItemListContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::ArrayItemListContext::getRuleIndex() const {
  return PhpParser::RuleArrayItemList;
}

void PhpParser::ArrayItemListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayItemList(this);
}

void PhpParser::ArrayItemListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayItemList(this);
}

PhpParser::ArrayItemListContext* PhpParser::arrayItemList() {
  ArrayItemListContext *_localctx = _tracker.createInstance<ArrayItemListContext>(_ctx, getState());
  enterRule(_localctx, 188, PhpParser::RuleArrayItemList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1503);
    arrayItem();
    setState(1508);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 171, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1504);
        match(PhpParser::Comma);
        setState(1505);
        arrayItem(); 
      }
      setState(1510);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 171, _ctx);
    }
    setState(1512);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, _ctx)) {
    case 1: {
      setState(1511);
      match(PhpParser::Comma);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayItemContext ------------------------------------------------------------------

PhpParser::ArrayItemContext::ArrayItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::ExpressionContext *> PhpParser::ArrayItemContext::expression() {
  return getRuleContexts<PhpParser::ExpressionContext>();
}

PhpParser::ExpressionContext* PhpParser::ArrayItemContext::expression(size_t i) {
  return getRuleContext<PhpParser::ExpressionContext>(i);
}

tree::TerminalNode* PhpParser::ArrayItemContext::DoubleArrow() {
  return getToken(PhpParser::DoubleArrow, 0);
}

tree::TerminalNode* PhpParser::ArrayItemContext::Ampersand() {
  return getToken(PhpParser::Ampersand, 0);
}

PhpParser::ChainContext* PhpParser::ArrayItemContext::chain() {
  return getRuleContext<PhpParser::ChainContext>(0);
}


size_t PhpParser::ArrayItemContext::getRuleIndex() const {
  return PhpParser::RuleArrayItem;
}

void PhpParser::ArrayItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayItem(this);
}

void PhpParser::ArrayItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayItem(this);
}

PhpParser::ArrayItemContext* PhpParser::arrayItem() {
  ArrayItemContext *_localctx = _tracker.createInstance<ArrayItemContext>(_ctx, getState());
  enterRule(_localctx, 190, PhpParser::RuleArrayItem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1526);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 175, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1514);
      expression(0);
      setState(1517);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PhpParser::DoubleArrow) {
        setState(1515);
        match(PhpParser::DoubleArrow);
        setState(1516);
        expression(0);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1522);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 44) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 44)) & -1) != 0) || ((((_la - 108) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 108)) & 441352763482308607) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 194)) & 4396974138177) != 0)) {
        setState(1519);
        expression(0);
        setState(1520);
        match(PhpParser::DoubleArrow);
      }
      setState(1524);
      match(PhpParser::Ampersand);
      setState(1525);
      chain();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LambdaFunctionUseVarsContext ------------------------------------------------------------------

PhpParser::LambdaFunctionUseVarsContext::LambdaFunctionUseVarsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::LambdaFunctionUseVarsContext::Use() {
  return getToken(PhpParser::Use, 0);
}

tree::TerminalNode* PhpParser::LambdaFunctionUseVarsContext::OpenRoundBracket() {
  return getToken(PhpParser::OpenRoundBracket, 0);
}

std::vector<PhpParser::LambdaFunctionUseVarContext *> PhpParser::LambdaFunctionUseVarsContext::lambdaFunctionUseVar() {
  return getRuleContexts<PhpParser::LambdaFunctionUseVarContext>();
}

PhpParser::LambdaFunctionUseVarContext* PhpParser::LambdaFunctionUseVarsContext::lambdaFunctionUseVar(size_t i) {
  return getRuleContext<PhpParser::LambdaFunctionUseVarContext>(i);
}

tree::TerminalNode* PhpParser::LambdaFunctionUseVarsContext::CloseRoundBracket() {
  return getToken(PhpParser::CloseRoundBracket, 0);
}

std::vector<tree::TerminalNode *> PhpParser::LambdaFunctionUseVarsContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::LambdaFunctionUseVarsContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::LambdaFunctionUseVarsContext::getRuleIndex() const {
  return PhpParser::RuleLambdaFunctionUseVars;
}

void PhpParser::LambdaFunctionUseVarsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLambdaFunctionUseVars(this);
}

void PhpParser::LambdaFunctionUseVarsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLambdaFunctionUseVars(this);
}

PhpParser::LambdaFunctionUseVarsContext* PhpParser::lambdaFunctionUseVars() {
  LambdaFunctionUseVarsContext *_localctx = _tracker.createInstance<LambdaFunctionUseVarsContext>(_ctx, getState());
  enterRule(_localctx, 192, PhpParser::RuleLambdaFunctionUseVars);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1528);
    match(PhpParser::Use);
    setState(1529);
    match(PhpParser::OpenRoundBracket);
    setState(1530);
    lambdaFunctionUseVar();
    setState(1535);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PhpParser::Comma) {
      setState(1531);
      match(PhpParser::Comma);
      setState(1532);
      lambdaFunctionUseVar();
      setState(1537);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1538);
    match(PhpParser::CloseRoundBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LambdaFunctionUseVarContext ------------------------------------------------------------------

PhpParser::LambdaFunctionUseVarContext::LambdaFunctionUseVarContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::LambdaFunctionUseVarContext::VarName() {
  return getToken(PhpParser::VarName, 0);
}

tree::TerminalNode* PhpParser::LambdaFunctionUseVarContext::Ampersand() {
  return getToken(PhpParser::Ampersand, 0);
}


size_t PhpParser::LambdaFunctionUseVarContext::getRuleIndex() const {
  return PhpParser::RuleLambdaFunctionUseVar;
}

void PhpParser::LambdaFunctionUseVarContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLambdaFunctionUseVar(this);
}

void PhpParser::LambdaFunctionUseVarContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLambdaFunctionUseVar(this);
}

PhpParser::LambdaFunctionUseVarContext* PhpParser::lambdaFunctionUseVar() {
  LambdaFunctionUseVarContext *_localctx = _tracker.createInstance<LambdaFunctionUseVarContext>(_ctx, getState());
  enterRule(_localctx, 194, PhpParser::RuleLambdaFunctionUseVar);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1541);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Ampersand) {
      setState(1540);
      match(PhpParser::Ampersand);
    }
    setState(1543);
    match(PhpParser::VarName);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedStaticTypeRefContext ------------------------------------------------------------------

PhpParser::QualifiedStaticTypeRefContext::QualifiedStaticTypeRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::QualifiedNamespaceNameContext* PhpParser::QualifiedStaticTypeRefContext::qualifiedNamespaceName() {
  return getRuleContext<PhpParser::QualifiedNamespaceNameContext>(0);
}

PhpParser::GenericDynamicArgsContext* PhpParser::QualifiedStaticTypeRefContext::genericDynamicArgs() {
  return getRuleContext<PhpParser::GenericDynamicArgsContext>(0);
}

tree::TerminalNode* PhpParser::QualifiedStaticTypeRefContext::Static() {
  return getToken(PhpParser::Static, 0);
}


size_t PhpParser::QualifiedStaticTypeRefContext::getRuleIndex() const {
  return PhpParser::RuleQualifiedStaticTypeRef;
}

void PhpParser::QualifiedStaticTypeRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedStaticTypeRef(this);
}

void PhpParser::QualifiedStaticTypeRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedStaticTypeRef(this);
}

PhpParser::QualifiedStaticTypeRefContext* PhpParser::qualifiedStaticTypeRef() {
  QualifiedStaticTypeRefContext *_localctx = _tracker.createInstance<QualifiedStaticTypeRefContext>(_ctx, getState());
  enterRule(_localctx, 196, PhpParser::RuleQualifiedStaticTypeRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1550);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 179, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1545);
      qualifiedNamespaceName();
      setState(1547);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 178, _ctx)) {
      case 1: {
        setState(1546);
        genericDynamicArgs();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1549);
      match(PhpParser::Static);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeRefContext ------------------------------------------------------------------

PhpParser::TypeRefContext::TypeRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::QualifiedNamespaceNameContext* PhpParser::TypeRefContext::qualifiedNamespaceName() {
  return getRuleContext<PhpParser::QualifiedNamespaceNameContext>(0);
}

PhpParser::IndirectTypeRefContext* PhpParser::TypeRefContext::indirectTypeRef() {
  return getRuleContext<PhpParser::IndirectTypeRefContext>(0);
}

PhpParser::GenericDynamicArgsContext* PhpParser::TypeRefContext::genericDynamicArgs() {
  return getRuleContext<PhpParser::GenericDynamicArgsContext>(0);
}

PhpParser::PrimitiveTypeContext* PhpParser::TypeRefContext::primitiveType() {
  return getRuleContext<PhpParser::PrimitiveTypeContext>(0);
}

tree::TerminalNode* PhpParser::TypeRefContext::Static() {
  return getToken(PhpParser::Static, 0);
}

PhpParser::AnonymousClassContext* PhpParser::TypeRefContext::anonymousClass() {
  return getRuleContext<PhpParser::AnonymousClassContext>(0);
}


size_t PhpParser::TypeRefContext::getRuleIndex() const {
  return PhpParser::RuleTypeRef;
}

void PhpParser::TypeRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeRef(this);
}

void PhpParser::TypeRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeRef(this);
}

PhpParser::TypeRefContext* PhpParser::typeRef() {
  TypeRefContext *_localctx = _tracker.createInstance<TypeRefContext>(_ctx, getState());
  enterRule(_localctx, 198, PhpParser::RuleTypeRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1562);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 182, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1554);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 180, _ctx)) {
      case 1: {
        setState(1552);
        qualifiedNamespaceName();
        break;
      }

      case 2: {
        setState(1553);
        indirectTypeRef();
        break;
      }

      default:
        break;
      }
      setState(1557);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 181, _ctx)) {
      case 1: {
        setState(1556);
        genericDynamicArgs();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1559);
      primitiveType();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1560);
      match(PhpParser::Static);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1561);
      anonymousClass();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnonymousClassContext ------------------------------------------------------------------

PhpParser::AnonymousClassContext::AnonymousClassContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::AnonymousClassContext::OpenCurlyBracket() {
  return getToken(PhpParser::OpenCurlyBracket, 0);
}

tree::TerminalNode* PhpParser::AnonymousClassContext::CloseCurlyBracket() {
  return getToken(PhpParser::CloseCurlyBracket, 0);
}

PhpParser::ClassEntryTypeContext* PhpParser::AnonymousClassContext::classEntryType() {
  return getRuleContext<PhpParser::ClassEntryTypeContext>(0);
}

tree::TerminalNode* PhpParser::AnonymousClassContext::Interface() {
  return getToken(PhpParser::Interface, 0);
}

PhpParser::IdentifierContext* PhpParser::AnonymousClassContext::identifier() {
  return getRuleContext<PhpParser::IdentifierContext>(0);
}

PhpParser::AttributesContext* PhpParser::AnonymousClassContext::attributes() {
  return getRuleContext<PhpParser::AttributesContext>(0);
}

tree::TerminalNode* PhpParser::AnonymousClassContext::Private() {
  return getToken(PhpParser::Private, 0);
}

PhpParser::ModifierContext* PhpParser::AnonymousClassContext::modifier() {
  return getRuleContext<PhpParser::ModifierContext>(0);
}

tree::TerminalNode* PhpParser::AnonymousClassContext::Partial() {
  return getToken(PhpParser::Partial, 0);
}

std::vector<PhpParser::ClassStatementContext *> PhpParser::AnonymousClassContext::classStatement() {
  return getRuleContexts<PhpParser::ClassStatementContext>();
}

PhpParser::ClassStatementContext* PhpParser::AnonymousClassContext::classStatement(size_t i) {
  return getRuleContext<PhpParser::ClassStatementContext>(i);
}

PhpParser::TypeParameterListInBracketsContext* PhpParser::AnonymousClassContext::typeParameterListInBrackets() {
  return getRuleContext<PhpParser::TypeParameterListInBracketsContext>(0);
}

tree::TerminalNode* PhpParser::AnonymousClassContext::Extends() {
  return getToken(PhpParser::Extends, 0);
}

PhpParser::QualifiedStaticTypeRefContext* PhpParser::AnonymousClassContext::qualifiedStaticTypeRef() {
  return getRuleContext<PhpParser::QualifiedStaticTypeRefContext>(0);
}

tree::TerminalNode* PhpParser::AnonymousClassContext::Implements() {
  return getToken(PhpParser::Implements, 0);
}

PhpParser::InterfaceListContext* PhpParser::AnonymousClassContext::interfaceList() {
  return getRuleContext<PhpParser::InterfaceListContext>(0);
}


size_t PhpParser::AnonymousClassContext::getRuleIndex() const {
  return PhpParser::RuleAnonymousClass;
}

void PhpParser::AnonymousClassContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnonymousClass(this);
}

void PhpParser::AnonymousClassContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnonymousClass(this);
}

PhpParser::AnonymousClassContext* PhpParser::anonymousClass() {
  AnonymousClassContext *_localctx = _tracker.createInstance<AnonymousClassContext>(_ctx, getState());
  enterRule(_localctx, 200, PhpParser::RuleAnonymousClass);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1565);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::AttributeStart) {
      setState(1564);
      attributes();
    }
    setState(1568);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Private) {
      setState(1567);
      match(PhpParser::Private);
    }
    setState(1571);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Abstract

    || _la == PhpParser::Final) {
      setState(1570);
      modifier();
    }
    setState(1574);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Partial) {
      setState(1573);
      match(PhpParser::Partial);
    }
    setState(1597);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::Class:
      case PhpParser::Trait: {
        setState(1576);
        classEntryType();
        setState(1578);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Lgeneric) {
          setState(1577);
          typeParameterListInBrackets();
        }
        setState(1582);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Extends) {
          setState(1580);
          match(PhpParser::Extends);
          setState(1581);
          qualifiedStaticTypeRef();
        }
        setState(1586);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Implements) {
          setState(1584);
          match(PhpParser::Implements);
          setState(1585);
          interfaceList();
        }
        break;
      }

      case PhpParser::Interface: {
        setState(1588);
        match(PhpParser::Interface);
        setState(1589);
        identifier();
        setState(1591);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Lgeneric) {
          setState(1590);
          typeParameterListInBrackets();
        }
        setState(1595);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Extends) {
          setState(1593);
          match(PhpParser::Extends);
          setState(1594);
          interfaceList();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1599);
    match(PhpParser::OpenCurlyBracket);
    setState(1603);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 72083982316994560) != 0) || ((((_la - 77) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 77)) & 6757727313330209) != 0)) {
      setState(1600);
      classStatement();
      setState(1605);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1606);
    match(PhpParser::CloseCurlyBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndirectTypeRefContext ------------------------------------------------------------------

PhpParser::IndirectTypeRefContext::IndirectTypeRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::ChainBaseContext* PhpParser::IndirectTypeRefContext::chainBase() {
  return getRuleContext<PhpParser::ChainBaseContext>(0);
}

std::vector<tree::TerminalNode *> PhpParser::IndirectTypeRefContext::ObjectOperator() {
  return getTokens(PhpParser::ObjectOperator);
}

tree::TerminalNode* PhpParser::IndirectTypeRefContext::ObjectOperator(size_t i) {
  return getToken(PhpParser::ObjectOperator, i);
}

std::vector<PhpParser::KeyedFieldNameContext *> PhpParser::IndirectTypeRefContext::keyedFieldName() {
  return getRuleContexts<PhpParser::KeyedFieldNameContext>();
}

PhpParser::KeyedFieldNameContext* PhpParser::IndirectTypeRefContext::keyedFieldName(size_t i) {
  return getRuleContext<PhpParser::KeyedFieldNameContext>(i);
}


size_t PhpParser::IndirectTypeRefContext::getRuleIndex() const {
  return PhpParser::RuleIndirectTypeRef;
}

void PhpParser::IndirectTypeRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndirectTypeRef(this);
}

void PhpParser::IndirectTypeRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndirectTypeRef(this);
}

PhpParser::IndirectTypeRefContext* PhpParser::indirectTypeRef() {
  IndirectTypeRefContext *_localctx = _tracker.createInstance<IndirectTypeRefContext>(_ctx, getState());
  enterRule(_localctx, 202, PhpParser::RuleIndirectTypeRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1608);
    chainBase();
    setState(1613);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 194, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1609);
        match(PhpParser::ObjectOperator);
        setState(1610);
        keyedFieldName(); 
      }
      setState(1615);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 194, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedNamespaceNameContext ------------------------------------------------------------------

PhpParser::QualifiedNamespaceNameContext::QualifiedNamespaceNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::NamespaceNameListContext* PhpParser::QualifiedNamespaceNameContext::namespaceNameList() {
  return getRuleContext<PhpParser::NamespaceNameListContext>(0);
}

tree::TerminalNode* PhpParser::QualifiedNamespaceNameContext::Namespace() {
  return getToken(PhpParser::Namespace, 0);
}

tree::TerminalNode* PhpParser::QualifiedNamespaceNameContext::NamespaceSeparator() {
  return getToken(PhpParser::NamespaceSeparator, 0);
}


size_t PhpParser::QualifiedNamespaceNameContext::getRuleIndex() const {
  return PhpParser::RuleQualifiedNamespaceName;
}

void PhpParser::QualifiedNamespaceNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedNamespaceName(this);
}

void PhpParser::QualifiedNamespaceNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedNamespaceName(this);
}

PhpParser::QualifiedNamespaceNameContext* PhpParser::qualifiedNamespaceName() {
  QualifiedNamespaceNameContext *_localctx = _tracker.createInstance<QualifiedNamespaceNameContext>(_ctx, getState());
  enterRule(_localctx, 204, PhpParser::RuleQualifiedNamespaceName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1617);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 195, _ctx)) {
    case 1: {
      setState(1616);
      match(PhpParser::Namespace);
      break;
    }

    default:
      break;
    }
    setState(1620);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::NamespaceSeparator) {
      setState(1619);
      match(PhpParser::NamespaceSeparator);
    }
    setState(1622);
    namespaceNameList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamespaceNameListContext ------------------------------------------------------------------

PhpParser::NamespaceNameListContext::NamespaceNameListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::IdentifierContext *> PhpParser::NamespaceNameListContext::identifier() {
  return getRuleContexts<PhpParser::IdentifierContext>();
}

PhpParser::IdentifierContext* PhpParser::NamespaceNameListContext::identifier(size_t i) {
  return getRuleContext<PhpParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> PhpParser::NamespaceNameListContext::NamespaceSeparator() {
  return getTokens(PhpParser::NamespaceSeparator);
}

tree::TerminalNode* PhpParser::NamespaceNameListContext::NamespaceSeparator(size_t i) {
  return getToken(PhpParser::NamespaceSeparator, i);
}

PhpParser::NamespaceNameTailContext* PhpParser::NamespaceNameListContext::namespaceNameTail() {
  return getRuleContext<PhpParser::NamespaceNameTailContext>(0);
}


size_t PhpParser::NamespaceNameListContext::getRuleIndex() const {
  return PhpParser::RuleNamespaceNameList;
}

void PhpParser::NamespaceNameListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamespaceNameList(this);
}

void PhpParser::NamespaceNameListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamespaceNameList(this);
}

PhpParser::NamespaceNameListContext* PhpParser::namespaceNameList() {
  NamespaceNameListContext *_localctx = _tracker.createInstance<NamespaceNameListContext>(_ctx, getState());
  enterRule(_localctx, 206, PhpParser::RuleNamespaceNameList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1637);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 199, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1624);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1625);
      identifier();
      setState(1630);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 197, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1626);
          match(PhpParser::NamespaceSeparator);
          setState(1627);
          identifier(); 
        }
        setState(1632);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 197, _ctx);
      }
      setState(1635);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 198, _ctx)) {
      case 1: {
        setState(1633);
        match(PhpParser::NamespaceSeparator);
        setState(1634);
        namespaceNameTail();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamespaceNameTailContext ------------------------------------------------------------------

PhpParser::NamespaceNameTailContext::NamespaceNameTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::IdentifierContext *> PhpParser::NamespaceNameTailContext::identifier() {
  return getRuleContexts<PhpParser::IdentifierContext>();
}

PhpParser::IdentifierContext* PhpParser::NamespaceNameTailContext::identifier(size_t i) {
  return getRuleContext<PhpParser::IdentifierContext>(i);
}

tree::TerminalNode* PhpParser::NamespaceNameTailContext::As() {
  return getToken(PhpParser::As, 0);
}

tree::TerminalNode* PhpParser::NamespaceNameTailContext::OpenCurlyBracket() {
  return getToken(PhpParser::OpenCurlyBracket, 0);
}

std::vector<PhpParser::NamespaceNameTailContext *> PhpParser::NamespaceNameTailContext::namespaceNameTail() {
  return getRuleContexts<PhpParser::NamespaceNameTailContext>();
}

PhpParser::NamespaceNameTailContext* PhpParser::NamespaceNameTailContext::namespaceNameTail(size_t i) {
  return getRuleContext<PhpParser::NamespaceNameTailContext>(i);
}

tree::TerminalNode* PhpParser::NamespaceNameTailContext::CloseCurlyBracket() {
  return getToken(PhpParser::CloseCurlyBracket, 0);
}

std::vector<tree::TerminalNode *> PhpParser::NamespaceNameTailContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::NamespaceNameTailContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::NamespaceNameTailContext::getRuleIndex() const {
  return PhpParser::RuleNamespaceNameTail;
}

void PhpParser::NamespaceNameTailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamespaceNameTail(this);
}

void PhpParser::NamespaceNameTailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamespaceNameTail(this);
}

PhpParser::NamespaceNameTailContext* PhpParser::namespaceNameTail() {
  NamespaceNameTailContext *_localctx = _tracker.createInstance<NamespaceNameTailContext>(_ctx, getState());
  enterRule(_localctx, 208, PhpParser::RuleNamespaceNameTail);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1658);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::Abstract:
      case PhpParser::Array:
      case PhpParser::As:
      case PhpParser::BinaryCast:
      case PhpParser::BoolType:
      case PhpParser::BooleanConstant:
      case PhpParser::Break:
      case PhpParser::Callable:
      case PhpParser::Case:
      case PhpParser::Catch:
      case PhpParser::Class:
      case PhpParser::Clone:
      case PhpParser::Const:
      case PhpParser::Continue:
      case PhpParser::Declare:
      case PhpParser::Default:
      case PhpParser::Do:
      case PhpParser::DoubleCast:
      case PhpParser::DoubleType:
      case PhpParser::Echo:
      case PhpParser::Else:
      case PhpParser::ElseIf:
      case PhpParser::Empty:
      case PhpParser::Enum_:
      case PhpParser::EndDeclare:
      case PhpParser::EndFor:
      case PhpParser::EndForeach:
      case PhpParser::EndIf:
      case PhpParser::EndSwitch:
      case PhpParser::EndWhile:
      case PhpParser::Eval:
      case PhpParser::Exit:
      case PhpParser::Extends:
      case PhpParser::Final:
      case PhpParser::Finally:
      case PhpParser::FloatCast:
      case PhpParser::For:
      case PhpParser::Foreach:
      case PhpParser::Function_:
      case PhpParser::Global:
      case PhpParser::Goto:
      case PhpParser::If:
      case PhpParser::Implements:
      case PhpParser::Import:
      case PhpParser::Include:
      case PhpParser::IncludeOnce:
      case PhpParser::InstanceOf:
      case PhpParser::InsteadOf:
      case PhpParser::Int8Cast:
      case PhpParser::Int16Cast:
      case PhpParser::Int64Type:
      case PhpParser::IntType:
      case PhpParser::Interface:
      case PhpParser::IsSet:
      case PhpParser::List:
      case PhpParser::LogicalAnd:
      case PhpParser::LogicalOr:
      case PhpParser::LogicalXor:
      case PhpParser::Match_:
      case PhpParser::Namespace:
      case PhpParser::New:
      case PhpParser::Null:
      case PhpParser::ObjectType:
      case PhpParser::Parent_:
      case PhpParser::Partial:
      case PhpParser::Print:
      case PhpParser::Private:
      case PhpParser::Protected:
      case PhpParser::Public:
      case PhpParser::Readonly:
      case PhpParser::Require:
      case PhpParser::RequireOnce:
      case PhpParser::Resource:
      case PhpParser::Return:
      case PhpParser::Static:
      case PhpParser::StringType:
      case PhpParser::Switch:
      case PhpParser::Throw:
      case PhpParser::Trait:
      case PhpParser::Try:
      case PhpParser::Typeof:
      case PhpParser::UintCast:
      case PhpParser::UnicodeCast:
      case PhpParser::Unset:
      case PhpParser::Use:
      case PhpParser::Var:
      case PhpParser::While:
      case PhpParser::Yield:
      case PhpParser::From:
      case PhpParser::LambdaFn:
      case PhpParser::Ticks:
      case PhpParser::Encoding:
      case PhpParser::StrictTypes:
      case PhpParser::Get:
      case PhpParser::Set:
      case PhpParser::Call:
      case PhpParser::CallStatic:
      case PhpParser::Constructor:
      case PhpParser::Destruct:
      case PhpParser::Wakeup:
      case PhpParser::Sleep:
      case PhpParser::Autoload:
      case PhpParser::IsSet__:
      case PhpParser::Unset__:
      case PhpParser::ToString__:
      case PhpParser::Invoke:
      case PhpParser::SetState:
      case PhpParser::Clone__:
      case PhpParser::DebugInfo:
      case PhpParser::Namespace__:
      case PhpParser::Class__:
      case PhpParser::Traic__:
      case PhpParser::Function__:
      case PhpParser::Method__:
      case PhpParser::Line__:
      case PhpParser::File__:
      case PhpParser::Dir__:
      case PhpParser::Label: {
        enterOuterAlt(_localctx, 1);
        setState(1639);
        identifier();
        setState(1642);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx)) {
        case 1: {
          setState(1640);
          match(PhpParser::As);
          setState(1641);
          identifier();
          break;
        }

        default:
          break;
        }
        break;
      }

      case PhpParser::OpenCurlyBracket: {
        enterOuterAlt(_localctx, 2);
        setState(1644);
        match(PhpParser::OpenCurlyBracket);
        setState(1645);
        namespaceNameTail();
        setState(1650);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 201, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1646);
            match(PhpParser::Comma);
            setState(1647);
            namespaceNameTail(); 
          }
          setState(1652);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 201, _ctx);
        }
        setState(1654);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Comma) {
          setState(1653);
          match(PhpParser::Comma);
        }
        setState(1656);
        match(PhpParser::CloseCurlyBracket);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedNamespaceNameListContext ------------------------------------------------------------------

PhpParser::QualifiedNamespaceNameListContext::QualifiedNamespaceNameListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::QualifiedNamespaceNameContext *> PhpParser::QualifiedNamespaceNameListContext::qualifiedNamespaceName() {
  return getRuleContexts<PhpParser::QualifiedNamespaceNameContext>();
}

PhpParser::QualifiedNamespaceNameContext* PhpParser::QualifiedNamespaceNameListContext::qualifiedNamespaceName(size_t i) {
  return getRuleContext<PhpParser::QualifiedNamespaceNameContext>(i);
}

std::vector<tree::TerminalNode *> PhpParser::QualifiedNamespaceNameListContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::QualifiedNamespaceNameListContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::QualifiedNamespaceNameListContext::getRuleIndex() const {
  return PhpParser::RuleQualifiedNamespaceNameList;
}

void PhpParser::QualifiedNamespaceNameListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedNamespaceNameList(this);
}

void PhpParser::QualifiedNamespaceNameListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedNamespaceNameList(this);
}

PhpParser::QualifiedNamespaceNameListContext* PhpParser::qualifiedNamespaceNameList() {
  QualifiedNamespaceNameListContext *_localctx = _tracker.createInstance<QualifiedNamespaceNameListContext>(_ctx, getState());
  enterRule(_localctx, 210, PhpParser::RuleQualifiedNamespaceNameList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1660);
    qualifiedNamespaceName();
    setState(1665);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PhpParser::Comma) {
      setState(1661);
      match(PhpParser::Comma);
      setState(1662);
      qualifiedNamespaceName();
      setState(1667);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentsContext ------------------------------------------------------------------

PhpParser::ArgumentsContext::ArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::ArgumentsContext::OpenRoundBracket() {
  return getToken(PhpParser::OpenRoundBracket, 0);
}

tree::TerminalNode* PhpParser::ArgumentsContext::CloseRoundBracket() {
  return getToken(PhpParser::CloseRoundBracket, 0);
}

std::vector<PhpParser::ActualArgumentContext *> PhpParser::ArgumentsContext::actualArgument() {
  return getRuleContexts<PhpParser::ActualArgumentContext>();
}

PhpParser::ActualArgumentContext* PhpParser::ArgumentsContext::actualArgument(size_t i) {
  return getRuleContext<PhpParser::ActualArgumentContext>(i);
}

PhpParser::YieldExpressionContext* PhpParser::ArgumentsContext::yieldExpression() {
  return getRuleContext<PhpParser::YieldExpressionContext>(0);
}

std::vector<tree::TerminalNode *> PhpParser::ArgumentsContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::ArgumentsContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::ArgumentsContext::getRuleIndex() const {
  return PhpParser::RuleArguments;
}

void PhpParser::ArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArguments(this);
}

void PhpParser::ArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArguments(this);
}

PhpParser::ArgumentsContext* PhpParser::arguments() {
  ArgumentsContext *_localctx = _tracker.createInstance<ArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 212, PhpParser::RuleArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1668);
    match(PhpParser::OpenRoundBracket);
    setState(1678);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 206, _ctx)) {
    case 1: {
      setState(1669);
      actualArgument();
      setState(1674);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 205, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1670);
          match(PhpParser::Comma);
          setState(1671);
          actualArgument(); 
        }
        setState(1676);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 205, _ctx);
      }
      break;
    }

    case 2: {
      setState(1677);
      yieldExpression();
      break;
    }

    default:
      break;
    }
    setState(1681);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Comma) {
      setState(1680);
      match(PhpParser::Comma);
    }
    setState(1683);
    match(PhpParser::CloseRoundBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ActualArgumentContext ------------------------------------------------------------------

PhpParser::ActualArgumentContext::ActualArgumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::ExpressionContext* PhpParser::ActualArgumentContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

PhpParser::ArgumentNameContext* PhpParser::ActualArgumentContext::argumentName() {
  return getRuleContext<PhpParser::ArgumentNameContext>(0);
}

tree::TerminalNode* PhpParser::ActualArgumentContext::Ellipsis() {
  return getToken(PhpParser::Ellipsis, 0);
}

tree::TerminalNode* PhpParser::ActualArgumentContext::Ampersand() {
  return getToken(PhpParser::Ampersand, 0);
}

PhpParser::ChainContext* PhpParser::ActualArgumentContext::chain() {
  return getRuleContext<PhpParser::ChainContext>(0);
}


size_t PhpParser::ActualArgumentContext::getRuleIndex() const {
  return PhpParser::RuleActualArgument;
}

void PhpParser::ActualArgumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterActualArgument(this);
}

void PhpParser::ActualArgumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitActualArgument(this);
}

PhpParser::ActualArgumentContext* PhpParser::actualArgument() {
  ActualArgumentContext *_localctx = _tracker.createInstance<ActualArgumentContext>(_ctx, getState());
  enterRule(_localctx, 214, PhpParser::RuleActualArgument);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1694);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::Abstract:
      case PhpParser::Array:
      case PhpParser::As:
      case PhpParser::BinaryCast:
      case PhpParser::BoolType:
      case PhpParser::BooleanConstant:
      case PhpParser::Break:
      case PhpParser::Callable:
      case PhpParser::Case:
      case PhpParser::Catch:
      case PhpParser::Class:
      case PhpParser::Clone:
      case PhpParser::Const:
      case PhpParser::Continue:
      case PhpParser::Declare:
      case PhpParser::Default:
      case PhpParser::Do:
      case PhpParser::DoubleCast:
      case PhpParser::DoubleType:
      case PhpParser::Echo:
      case PhpParser::Else:
      case PhpParser::ElseIf:
      case PhpParser::Empty:
      case PhpParser::Enum_:
      case PhpParser::EndDeclare:
      case PhpParser::EndFor:
      case PhpParser::EndForeach:
      case PhpParser::EndIf:
      case PhpParser::EndSwitch:
      case PhpParser::EndWhile:
      case PhpParser::Eval:
      case PhpParser::Exit:
      case PhpParser::Extends:
      case PhpParser::Final:
      case PhpParser::Finally:
      case PhpParser::FloatCast:
      case PhpParser::For:
      case PhpParser::Foreach:
      case PhpParser::Function_:
      case PhpParser::Global:
      case PhpParser::Goto:
      case PhpParser::If:
      case PhpParser::Implements:
      case PhpParser::Import:
      case PhpParser::Include:
      case PhpParser::IncludeOnce:
      case PhpParser::InstanceOf:
      case PhpParser::InsteadOf:
      case PhpParser::Int8Cast:
      case PhpParser::Int16Cast:
      case PhpParser::Int64Type:
      case PhpParser::IntType:
      case PhpParser::Interface:
      case PhpParser::IsSet:
      case PhpParser::List:
      case PhpParser::LogicalAnd:
      case PhpParser::LogicalOr:
      case PhpParser::LogicalXor:
      case PhpParser::Match_:
      case PhpParser::Namespace:
      case PhpParser::New:
      case PhpParser::Null:
      case PhpParser::ObjectType:
      case PhpParser::Parent_:
      case PhpParser::Partial:
      case PhpParser::Print:
      case PhpParser::Private:
      case PhpParser::Protected:
      case PhpParser::Public:
      case PhpParser::Readonly:
      case PhpParser::Require:
      case PhpParser::RequireOnce:
      case PhpParser::Resource:
      case PhpParser::Return:
      case PhpParser::Static:
      case PhpParser::StringType:
      case PhpParser::Switch:
      case PhpParser::Throw:
      case PhpParser::Trait:
      case PhpParser::Try:
      case PhpParser::Typeof:
      case PhpParser::UintCast:
      case PhpParser::UnicodeCast:
      case PhpParser::Unset:
      case PhpParser::Use:
      case PhpParser::Var:
      case PhpParser::While:
      case PhpParser::Yield:
      case PhpParser::From:
      case PhpParser::LambdaFn:
      case PhpParser::Ticks:
      case PhpParser::Encoding:
      case PhpParser::StrictTypes:
      case PhpParser::Get:
      case PhpParser::Set:
      case PhpParser::Call:
      case PhpParser::CallStatic:
      case PhpParser::Constructor:
      case PhpParser::Destruct:
      case PhpParser::Wakeup:
      case PhpParser::Sleep:
      case PhpParser::Autoload:
      case PhpParser::IsSet__:
      case PhpParser::Unset__:
      case PhpParser::ToString__:
      case PhpParser::Invoke:
      case PhpParser::SetState:
      case PhpParser::Clone__:
      case PhpParser::DebugInfo:
      case PhpParser::Namespace__:
      case PhpParser::Class__:
      case PhpParser::Traic__:
      case PhpParser::Function__:
      case PhpParser::Method__:
      case PhpParser::Line__:
      case PhpParser::File__:
      case PhpParser::Dir__:
      case PhpParser::Inc:
      case PhpParser::Dec:
      case PhpParser::NamespaceSeparator:
      case PhpParser::Ellipsis:
      case PhpParser::Bang:
      case PhpParser::Plus:
      case PhpParser::Minus:
      case PhpParser::Tilde:
      case PhpParser::SuppressWarnings:
      case PhpParser::Dollar:
      case PhpParser::OpenRoundBracket:
      case PhpParser::OpenSquareBracket:
      case PhpParser::VarName:
      case PhpParser::Label:
      case PhpParser::Octal:
      case PhpParser::Decimal:
      case PhpParser::Real:
      case PhpParser::Hex:
      case PhpParser::Binary:
      case PhpParser::BackQuoteString:
      case PhpParser::SingleQuoteString:
      case PhpParser::DoubleQuote:
      case PhpParser::StartNowDoc:
      case PhpParser::StartHereDoc: {
        enterOuterAlt(_localctx, 1);
        setState(1686);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 208, _ctx)) {
        case 1: {
          setState(1685);
          argumentName();
          break;
        }

        default:
          break;
        }
        setState(1689);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Ellipsis) {
          setState(1688);
          match(PhpParser::Ellipsis);
        }
        setState(1691);
        expression(0);
        break;
      }

      case PhpParser::Ampersand: {
        enterOuterAlt(_localctx, 2);
        setState(1692);
        match(PhpParser::Ampersand);
        setState(1693);
        chain();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentNameContext ------------------------------------------------------------------

PhpParser::ArgumentNameContext::ArgumentNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::IdentifierContext* PhpParser::ArgumentNameContext::identifier() {
  return getRuleContext<PhpParser::IdentifierContext>(0);
}

tree::TerminalNode* PhpParser::ArgumentNameContext::Colon() {
  return getToken(PhpParser::Colon, 0);
}


size_t PhpParser::ArgumentNameContext::getRuleIndex() const {
  return PhpParser::RuleArgumentName;
}

void PhpParser::ArgumentNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgumentName(this);
}

void PhpParser::ArgumentNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgumentName(this);
}

PhpParser::ArgumentNameContext* PhpParser::argumentName() {
  ArgumentNameContext *_localctx = _tracker.createInstance<ArgumentNameContext>(_ctx, getState());
  enterRule(_localctx, 216, PhpParser::RuleArgumentName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1696);
    identifier();
    setState(1697);
    match(PhpParser::Colon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantInitializerContext ------------------------------------------------------------------

PhpParser::ConstantInitializerContext::ConstantInitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::ConstantContext *> PhpParser::ConstantInitializerContext::constant() {
  return getRuleContexts<PhpParser::ConstantContext>();
}

PhpParser::ConstantContext* PhpParser::ConstantInitializerContext::constant(size_t i) {
  return getRuleContext<PhpParser::ConstantContext>(i);
}

std::vector<PhpParser::StringContext *> PhpParser::ConstantInitializerContext::string() {
  return getRuleContexts<PhpParser::StringContext>();
}

PhpParser::StringContext* PhpParser::ConstantInitializerContext::string(size_t i) {
  return getRuleContext<PhpParser::StringContext>(i);
}

tree::TerminalNode* PhpParser::ConstantInitializerContext::Array() {
  return getToken(PhpParser::Array, 0);
}

tree::TerminalNode* PhpParser::ConstantInitializerContext::OpenRoundBracket() {
  return getToken(PhpParser::OpenRoundBracket, 0);
}

tree::TerminalNode* PhpParser::ConstantInitializerContext::CloseRoundBracket() {
  return getToken(PhpParser::CloseRoundBracket, 0);
}

PhpParser::ArrayItemListContext* PhpParser::ConstantInitializerContext::arrayItemList() {
  return getRuleContext<PhpParser::ArrayItemListContext>(0);
}

tree::TerminalNode* PhpParser::ConstantInitializerContext::Comma() {
  return getToken(PhpParser::Comma, 0);
}

tree::TerminalNode* PhpParser::ConstantInitializerContext::OpenSquareBracket() {
  return getToken(PhpParser::OpenSquareBracket, 0);
}

tree::TerminalNode* PhpParser::ConstantInitializerContext::CloseSquareBracket() {
  return getToken(PhpParser::CloseSquareBracket, 0);
}

PhpParser::ConstantInitializerContext* PhpParser::ConstantInitializerContext::constantInitializer() {
  return getRuleContext<PhpParser::ConstantInitializerContext>(0);
}

tree::TerminalNode* PhpParser::ConstantInitializerContext::Plus() {
  return getToken(PhpParser::Plus, 0);
}

tree::TerminalNode* PhpParser::ConstantInitializerContext::Minus() {
  return getToken(PhpParser::Minus, 0);
}

std::vector<tree::TerminalNode *> PhpParser::ConstantInitializerContext::Dot() {
  return getTokens(PhpParser::Dot);
}

tree::TerminalNode* PhpParser::ConstantInitializerContext::Dot(size_t i) {
  return getToken(PhpParser::Dot, i);
}


size_t PhpParser::ConstantInitializerContext::getRuleIndex() const {
  return PhpParser::RuleConstantInitializer;
}

void PhpParser::ConstantInitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstantInitializer(this);
}

void PhpParser::ConstantInitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstantInitializer(this);
}

PhpParser::ConstantInitializerContext* PhpParser::constantInitializer() {
  ConstantInitializerContext *_localctx = _tracker.createInstance<ConstantInitializerContext>(_ctx, getState());
  enterRule(_localctx, 218, PhpParser::RuleConstantInitializer);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1734);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 218, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1699);
      constant();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1700);
      string();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1701);
      match(PhpParser::Array);
      setState(1702);
      match(PhpParser::OpenRoundBracket);
      setState(1707);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 44) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 44)) & -1) != 0) || ((((_la - 108) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 108)) & 441352763482308607) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 194)) & 4396974138193) != 0)) {
        setState(1703);
        arrayItemList();
        setState(1705);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Comma) {
          setState(1704);
          match(PhpParser::Comma);
        }
      }
      setState(1709);
      match(PhpParser::CloseRoundBracket);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1710);
      match(PhpParser::OpenSquareBracket);
      setState(1715);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 44) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 44)) & -1) != 0) || ((((_la - 108) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 108)) & 441352763482308607) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 194)) & 4396974138193) != 0)) {
        setState(1711);
        arrayItemList();
        setState(1713);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PhpParser::Comma) {
          setState(1712);
          match(PhpParser::Comma);
        }
      }
      setState(1717);
      match(PhpParser::CloseSquareBracket);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1718);
      _la = _input->LA(1);
      if (!(_la == PhpParser::Plus

      || _la == PhpParser::Minus)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1719);
      constantInitializer();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1722);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 215, _ctx)) {
      case 1: {
        setState(1720);
        string();
        break;
      }

      case 2: {
        setState(1721);
        constant();
        break;
      }

      default:
        break;
      }
      setState(1731);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == PhpParser::Dot) {
        setState(1724);
        match(PhpParser::Dot);
        setState(1727);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 216, _ctx)) {
        case 1: {
          setState(1725);
          string();
          break;
        }

        case 2: {
          setState(1726);
          constant();
          break;
        }

        default:
          break;
        }
        setState(1733);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantContext ------------------------------------------------------------------

PhpParser::ConstantContext::ConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::ConstantContext::Null() {
  return getToken(PhpParser::Null, 0);
}

PhpParser::LiteralConstantContext* PhpParser::ConstantContext::literalConstant() {
  return getRuleContext<PhpParser::LiteralConstantContext>(0);
}

PhpParser::MagicConstantContext* PhpParser::ConstantContext::magicConstant() {
  return getRuleContext<PhpParser::MagicConstantContext>(0);
}

PhpParser::ClassConstantContext* PhpParser::ConstantContext::classConstant() {
  return getRuleContext<PhpParser::ClassConstantContext>(0);
}

PhpParser::QualifiedNamespaceNameContext* PhpParser::ConstantContext::qualifiedNamespaceName() {
  return getRuleContext<PhpParser::QualifiedNamespaceNameContext>(0);
}


size_t PhpParser::ConstantContext::getRuleIndex() const {
  return PhpParser::RuleConstant;
}

void PhpParser::ConstantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant(this);
}

void PhpParser::ConstantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant(this);
}

PhpParser::ConstantContext* PhpParser::constant() {
  ConstantContext *_localctx = _tracker.createInstance<ConstantContext>(_ctx, getState());
  enterRule(_localctx, 220, PhpParser::RuleConstant);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1741);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 219, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1736);
      match(PhpParser::Null);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1737);
      literalConstant();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1738);
      magicConstant();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1739);
      classConstant();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1740);
      qualifiedNamespaceName();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralConstantContext ------------------------------------------------------------------

PhpParser::LiteralConstantContext::LiteralConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::LiteralConstantContext::Real() {
  return getToken(PhpParser::Real, 0);
}

tree::TerminalNode* PhpParser::LiteralConstantContext::BooleanConstant() {
  return getToken(PhpParser::BooleanConstant, 0);
}

PhpParser::NumericConstantContext* PhpParser::LiteralConstantContext::numericConstant() {
  return getRuleContext<PhpParser::NumericConstantContext>(0);
}

PhpParser::StringConstantContext* PhpParser::LiteralConstantContext::stringConstant() {
  return getRuleContext<PhpParser::StringConstantContext>(0);
}


size_t PhpParser::LiteralConstantContext::getRuleIndex() const {
  return PhpParser::RuleLiteralConstant;
}

void PhpParser::LiteralConstantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteralConstant(this);
}

void PhpParser::LiteralConstantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteralConstant(this);
}

PhpParser::LiteralConstantContext* PhpParser::literalConstant() {
  LiteralConstantContext *_localctx = _tracker.createInstance<LiteralConstantContext>(_ctx, getState());
  enterRule(_localctx, 222, PhpParser::RuleLiteralConstant);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1747);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::Real: {
        enterOuterAlt(_localctx, 1);
        setState(1743);
        match(PhpParser::Real);
        break;
      }

      case PhpParser::BooleanConstant: {
        enterOuterAlt(_localctx, 2);
        setState(1744);
        match(PhpParser::BooleanConstant);
        break;
      }

      case PhpParser::Octal:
      case PhpParser::Decimal:
      case PhpParser::Hex:
      case PhpParser::Binary: {
        enterOuterAlt(_localctx, 3);
        setState(1745);
        numericConstant();
        break;
      }

      case PhpParser::Label: {
        enterOuterAlt(_localctx, 4);
        setState(1746);
        stringConstant();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericConstantContext ------------------------------------------------------------------

PhpParser::NumericConstantContext::NumericConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::NumericConstantContext::Octal() {
  return getToken(PhpParser::Octal, 0);
}

tree::TerminalNode* PhpParser::NumericConstantContext::Decimal() {
  return getToken(PhpParser::Decimal, 0);
}

tree::TerminalNode* PhpParser::NumericConstantContext::Hex() {
  return getToken(PhpParser::Hex, 0);
}

tree::TerminalNode* PhpParser::NumericConstantContext::Binary() {
  return getToken(PhpParser::Binary, 0);
}


size_t PhpParser::NumericConstantContext::getRuleIndex() const {
  return PhpParser::RuleNumericConstant;
}

void PhpParser::NumericConstantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericConstant(this);
}

void PhpParser::NumericConstantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericConstant(this);
}

PhpParser::NumericConstantContext* PhpParser::numericConstant() {
  NumericConstantContext *_localctx = _tracker.createInstance<NumericConstantContext>(_ctx, getState());
  enterRule(_localctx, 224, PhpParser::RuleNumericConstant);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1749);
    _la = _input->LA(1);
    if (!(((((_la - 226) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 226)) & 27) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassConstantContext ------------------------------------------------------------------

PhpParser::ClassConstantContext::ClassConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::ClassConstantContext::DoubleColon() {
  return getToken(PhpParser::DoubleColon, 0);
}

tree::TerminalNode* PhpParser::ClassConstantContext::Class() {
  return getToken(PhpParser::Class, 0);
}

tree::TerminalNode* PhpParser::ClassConstantContext::Parent_() {
  return getToken(PhpParser::Parent_, 0);
}

PhpParser::IdentifierContext* PhpParser::ClassConstantContext::identifier() {
  return getRuleContext<PhpParser::IdentifierContext>(0);
}

tree::TerminalNode* PhpParser::ClassConstantContext::Constructor() {
  return getToken(PhpParser::Constructor, 0);
}

tree::TerminalNode* PhpParser::ClassConstantContext::Get() {
  return getToken(PhpParser::Get, 0);
}

tree::TerminalNode* PhpParser::ClassConstantContext::Set() {
  return getToken(PhpParser::Set, 0);
}

PhpParser::QualifiedStaticTypeRefContext* PhpParser::ClassConstantContext::qualifiedStaticTypeRef() {
  return getRuleContext<PhpParser::QualifiedStaticTypeRefContext>(0);
}

std::vector<PhpParser::KeyedVariableContext *> PhpParser::ClassConstantContext::keyedVariable() {
  return getRuleContexts<PhpParser::KeyedVariableContext>();
}

PhpParser::KeyedVariableContext* PhpParser::ClassConstantContext::keyedVariable(size_t i) {
  return getRuleContext<PhpParser::KeyedVariableContext>(i);
}

PhpParser::StringContext* PhpParser::ClassConstantContext::string() {
  return getRuleContext<PhpParser::StringContext>(0);
}


size_t PhpParser::ClassConstantContext::getRuleIndex() const {
  return PhpParser::RuleClassConstant;
}

void PhpParser::ClassConstantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassConstant(this);
}

void PhpParser::ClassConstantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassConstant(this);
}

PhpParser::ClassConstantContext* PhpParser::classConstant() {
  ClassConstantContext *_localctx = _tracker.createInstance<ClassConstantContext>(_ctx, getState());
  enterRule(_localctx, 226, PhpParser::RuleClassConstant);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1769);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 224, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1751);
      _la = _input->LA(1);
      if (!(_la == PhpParser::Class

      || _la == PhpParser::Parent_)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1752);
      match(PhpParser::DoubleColon);
      setState(1757);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx)) {
      case 1: {
        setState(1753);
        identifier();
        break;
      }

      case 2: {
        setState(1754);
        match(PhpParser::Constructor);
        break;
      }

      case 3: {
        setState(1755);
        match(PhpParser::Get);
        break;
      }

      case 4: {
        setState(1756);
        match(PhpParser::Set);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1762);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case PhpParser::Abstract:
        case PhpParser::Array:
        case PhpParser::As:
        case PhpParser::BinaryCast:
        case PhpParser::BoolType:
        case PhpParser::BooleanConstant:
        case PhpParser::Break:
        case PhpParser::Callable:
        case PhpParser::Case:
        case PhpParser::Catch:
        case PhpParser::Class:
        case PhpParser::Clone:
        case PhpParser::Const:
        case PhpParser::Continue:
        case PhpParser::Declare:
        case PhpParser::Default:
        case PhpParser::Do:
        case PhpParser::DoubleCast:
        case PhpParser::DoubleType:
        case PhpParser::Echo:
        case PhpParser::Else:
        case PhpParser::ElseIf:
        case PhpParser::Empty:
        case PhpParser::Enum_:
        case PhpParser::EndDeclare:
        case PhpParser::EndFor:
        case PhpParser::EndForeach:
        case PhpParser::EndIf:
        case PhpParser::EndSwitch:
        case PhpParser::EndWhile:
        case PhpParser::Eval:
        case PhpParser::Exit:
        case PhpParser::Extends:
        case PhpParser::Final:
        case PhpParser::Finally:
        case PhpParser::FloatCast:
        case PhpParser::For:
        case PhpParser::Foreach:
        case PhpParser::Function_:
        case PhpParser::Global:
        case PhpParser::Goto:
        case PhpParser::If:
        case PhpParser::Implements:
        case PhpParser::Import:
        case PhpParser::Include:
        case PhpParser::IncludeOnce:
        case PhpParser::InstanceOf:
        case PhpParser::InsteadOf:
        case PhpParser::Int8Cast:
        case PhpParser::Int16Cast:
        case PhpParser::Int64Type:
        case PhpParser::IntType:
        case PhpParser::Interface:
        case PhpParser::IsSet:
        case PhpParser::List:
        case PhpParser::LogicalAnd:
        case PhpParser::LogicalOr:
        case PhpParser::LogicalXor:
        case PhpParser::Match_:
        case PhpParser::Namespace:
        case PhpParser::New:
        case PhpParser::Null:
        case PhpParser::ObjectType:
        case PhpParser::Parent_:
        case PhpParser::Partial:
        case PhpParser::Print:
        case PhpParser::Private:
        case PhpParser::Protected:
        case PhpParser::Public:
        case PhpParser::Readonly:
        case PhpParser::Require:
        case PhpParser::RequireOnce:
        case PhpParser::Resource:
        case PhpParser::Return:
        case PhpParser::Static:
        case PhpParser::StringType:
        case PhpParser::Switch:
        case PhpParser::Throw:
        case PhpParser::Trait:
        case PhpParser::Try:
        case PhpParser::Typeof:
        case PhpParser::UintCast:
        case PhpParser::UnicodeCast:
        case PhpParser::Unset:
        case PhpParser::Use:
        case PhpParser::Var:
        case PhpParser::While:
        case PhpParser::Yield:
        case PhpParser::From:
        case PhpParser::LambdaFn:
        case PhpParser::Ticks:
        case PhpParser::Encoding:
        case PhpParser::StrictTypes:
        case PhpParser::Get:
        case PhpParser::Set:
        case PhpParser::Call:
        case PhpParser::CallStatic:
        case PhpParser::Constructor:
        case PhpParser::Destruct:
        case PhpParser::Wakeup:
        case PhpParser::Sleep:
        case PhpParser::Autoload:
        case PhpParser::IsSet__:
        case PhpParser::Unset__:
        case PhpParser::ToString__:
        case PhpParser::Invoke:
        case PhpParser::SetState:
        case PhpParser::Clone__:
        case PhpParser::DebugInfo:
        case PhpParser::Namespace__:
        case PhpParser::Class__:
        case PhpParser::Traic__:
        case PhpParser::Function__:
        case PhpParser::Method__:
        case PhpParser::Line__:
        case PhpParser::File__:
        case PhpParser::Dir__:
        case PhpParser::NamespaceSeparator:
        case PhpParser::Label: {
          setState(1759);
          qualifiedStaticTypeRef();
          break;
        }

        case PhpParser::Dollar:
        case PhpParser::VarName: {
          setState(1760);
          keyedVariable();
          break;
        }

        case PhpParser::SingleQuoteString:
        case PhpParser::DoubleQuote:
        case PhpParser::StartNowDoc:
        case PhpParser::StartHereDoc: {
          setState(1761);
          string();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1764);
      match(PhpParser::DoubleColon);
      setState(1767);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case PhpParser::Abstract:
        case PhpParser::Array:
        case PhpParser::As:
        case PhpParser::BinaryCast:
        case PhpParser::BoolType:
        case PhpParser::BooleanConstant:
        case PhpParser::Break:
        case PhpParser::Callable:
        case PhpParser::Case:
        case PhpParser::Catch:
        case PhpParser::Class:
        case PhpParser::Clone:
        case PhpParser::Const:
        case PhpParser::Continue:
        case PhpParser::Declare:
        case PhpParser::Default:
        case PhpParser::Do:
        case PhpParser::DoubleCast:
        case PhpParser::DoubleType:
        case PhpParser::Echo:
        case PhpParser::Else:
        case PhpParser::ElseIf:
        case PhpParser::Empty:
        case PhpParser::Enum_:
        case PhpParser::EndDeclare:
        case PhpParser::EndFor:
        case PhpParser::EndForeach:
        case PhpParser::EndIf:
        case PhpParser::EndSwitch:
        case PhpParser::EndWhile:
        case PhpParser::Eval:
        case PhpParser::Exit:
        case PhpParser::Extends:
        case PhpParser::Final:
        case PhpParser::Finally:
        case PhpParser::FloatCast:
        case PhpParser::For:
        case PhpParser::Foreach:
        case PhpParser::Function_:
        case PhpParser::Global:
        case PhpParser::Goto:
        case PhpParser::If:
        case PhpParser::Implements:
        case PhpParser::Import:
        case PhpParser::Include:
        case PhpParser::IncludeOnce:
        case PhpParser::InstanceOf:
        case PhpParser::InsteadOf:
        case PhpParser::Int8Cast:
        case PhpParser::Int16Cast:
        case PhpParser::Int64Type:
        case PhpParser::IntType:
        case PhpParser::Interface:
        case PhpParser::IsSet:
        case PhpParser::List:
        case PhpParser::LogicalAnd:
        case PhpParser::LogicalOr:
        case PhpParser::LogicalXor:
        case PhpParser::Match_:
        case PhpParser::Namespace:
        case PhpParser::New:
        case PhpParser::Null:
        case PhpParser::ObjectType:
        case PhpParser::Parent_:
        case PhpParser::Partial:
        case PhpParser::Print:
        case PhpParser::Private:
        case PhpParser::Protected:
        case PhpParser::Public:
        case PhpParser::Readonly:
        case PhpParser::Require:
        case PhpParser::RequireOnce:
        case PhpParser::Resource:
        case PhpParser::Return:
        case PhpParser::Static:
        case PhpParser::StringType:
        case PhpParser::Switch:
        case PhpParser::Throw:
        case PhpParser::Trait:
        case PhpParser::Try:
        case PhpParser::Typeof:
        case PhpParser::UintCast:
        case PhpParser::UnicodeCast:
        case PhpParser::Unset:
        case PhpParser::Use:
        case PhpParser::Var:
        case PhpParser::While:
        case PhpParser::Yield:
        case PhpParser::From:
        case PhpParser::LambdaFn:
        case PhpParser::Ticks:
        case PhpParser::Encoding:
        case PhpParser::StrictTypes:
        case PhpParser::Get:
        case PhpParser::Set:
        case PhpParser::Call:
        case PhpParser::CallStatic:
        case PhpParser::Constructor:
        case PhpParser::Destruct:
        case PhpParser::Wakeup:
        case PhpParser::Sleep:
        case PhpParser::Autoload:
        case PhpParser::IsSet__:
        case PhpParser::Unset__:
        case PhpParser::ToString__:
        case PhpParser::Invoke:
        case PhpParser::SetState:
        case PhpParser::Clone__:
        case PhpParser::DebugInfo:
        case PhpParser::Namespace__:
        case PhpParser::Class__:
        case PhpParser::Traic__:
        case PhpParser::Function__:
        case PhpParser::Method__:
        case PhpParser::Line__:
        case PhpParser::File__:
        case PhpParser::Dir__:
        case PhpParser::Label: {
          setState(1765);
          identifier();
          break;
        }

        case PhpParser::Dollar:
        case PhpParser::VarName: {
          setState(1766);
          keyedVariable();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringConstantContext ------------------------------------------------------------------

PhpParser::StringConstantContext::StringConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::StringConstantContext::Label() {
  return getToken(PhpParser::Label, 0);
}


size_t PhpParser::StringConstantContext::getRuleIndex() const {
  return PhpParser::RuleStringConstant;
}

void PhpParser::StringConstantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringConstant(this);
}

void PhpParser::StringConstantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringConstant(this);
}

PhpParser::StringConstantContext* PhpParser::stringConstant() {
  StringConstantContext *_localctx = _tracker.createInstance<StringConstantContext>(_ctx, getState());
  enterRule(_localctx, 228, PhpParser::RuleStringConstant);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1771);
    match(PhpParser::Label);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringContext ------------------------------------------------------------------

PhpParser::StringContext::StringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::StringContext::StartHereDoc() {
  return getToken(PhpParser::StartHereDoc, 0);
}

std::vector<tree::TerminalNode *> PhpParser::StringContext::HereDocText() {
  return getTokens(PhpParser::HereDocText);
}

tree::TerminalNode* PhpParser::StringContext::HereDocText(size_t i) {
  return getToken(PhpParser::HereDocText, i);
}

tree::TerminalNode* PhpParser::StringContext::StartNowDoc() {
  return getToken(PhpParser::StartNowDoc, 0);
}

tree::TerminalNode* PhpParser::StringContext::SingleQuoteString() {
  return getToken(PhpParser::SingleQuoteString, 0);
}

std::vector<tree::TerminalNode *> PhpParser::StringContext::DoubleQuote() {
  return getTokens(PhpParser::DoubleQuote);
}

tree::TerminalNode* PhpParser::StringContext::DoubleQuote(size_t i) {
  return getToken(PhpParser::DoubleQuote, i);
}

std::vector<PhpParser::InterpolatedStringPartContext *> PhpParser::StringContext::interpolatedStringPart() {
  return getRuleContexts<PhpParser::InterpolatedStringPartContext>();
}

PhpParser::InterpolatedStringPartContext* PhpParser::StringContext::interpolatedStringPart(size_t i) {
  return getRuleContext<PhpParser::InterpolatedStringPartContext>(i);
}


size_t PhpParser::StringContext::getRuleIndex() const {
  return PhpParser::RuleString;
}

void PhpParser::StringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterString(this);
}

void PhpParser::StringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitString(this);
}

PhpParser::StringContext* PhpParser::string() {
  StringContext *_localctx = _tracker.createInstance<StringContext>(_ctx, getState());
  enterRule(_localctx, 230, PhpParser::RuleString);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1794);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::StartHereDoc: {
        enterOuterAlt(_localctx, 1);
        setState(1773);
        match(PhpParser::StartHereDoc);
        setState(1775); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(1774);
                  match(PhpParser::HereDocText);
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(1777); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 225, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

      case PhpParser::StartNowDoc: {
        enterOuterAlt(_localctx, 2);
        setState(1779);
        match(PhpParser::StartNowDoc);
        setState(1781); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(1780);
                  match(PhpParser::HereDocText);
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(1783); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 226, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

      case PhpParser::SingleQuoteString: {
        enterOuterAlt(_localctx, 3);
        setState(1785);
        match(PhpParser::SingleQuoteString);
        break;
      }

      case PhpParser::DoubleQuote: {
        enterOuterAlt(_localctx, 4);
        setState(1786);
        match(PhpParser::DoubleQuote);
        setState(1790);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 227, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1787);
            interpolatedStringPart(); 
          }
          setState(1792);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 227, _ctx);
        }
        setState(1793);
        match(PhpParser::DoubleQuote);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InterpolatedStringPartContext ------------------------------------------------------------------

PhpParser::InterpolatedStringPartContext::InterpolatedStringPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::InterpolatedStringPartContext::StringPart() {
  return getToken(PhpParser::StringPart, 0);
}

tree::TerminalNode* PhpParser::InterpolatedStringPartContext::UnicodeEscape() {
  return getToken(PhpParser::UnicodeEscape, 0);
}

PhpParser::ChainContext* PhpParser::InterpolatedStringPartContext::chain() {
  return getRuleContext<PhpParser::ChainContext>(0);
}


size_t PhpParser::InterpolatedStringPartContext::getRuleIndex() const {
  return PhpParser::RuleInterpolatedStringPart;
}

void PhpParser::InterpolatedStringPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterpolatedStringPart(this);
}

void PhpParser::InterpolatedStringPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterpolatedStringPart(this);
}

PhpParser::InterpolatedStringPartContext* PhpParser::interpolatedStringPart() {
  InterpolatedStringPartContext *_localctx = _tracker.createInstance<InterpolatedStringPartContext>(_ctx, getState());
  enterRule(_localctx, 232, PhpParser::RuleInterpolatedStringPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1799);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::StringPart: {
        enterOuterAlt(_localctx, 1);
        setState(1796);
        match(PhpParser::StringPart);
        break;
      }

      case PhpParser::UnicodeEscape: {
        enterOuterAlt(_localctx, 2);
        setState(1797);
        match(PhpParser::UnicodeEscape);
        break;
      }

      case PhpParser::Abstract:
      case PhpParser::Array:
      case PhpParser::As:
      case PhpParser::BinaryCast:
      case PhpParser::BoolType:
      case PhpParser::BooleanConstant:
      case PhpParser::Break:
      case PhpParser::Callable:
      case PhpParser::Case:
      case PhpParser::Catch:
      case PhpParser::Class:
      case PhpParser::Clone:
      case PhpParser::Const:
      case PhpParser::Continue:
      case PhpParser::Declare:
      case PhpParser::Default:
      case PhpParser::Do:
      case PhpParser::DoubleCast:
      case PhpParser::DoubleType:
      case PhpParser::Echo:
      case PhpParser::Else:
      case PhpParser::ElseIf:
      case PhpParser::Empty:
      case PhpParser::Enum_:
      case PhpParser::EndDeclare:
      case PhpParser::EndFor:
      case PhpParser::EndForeach:
      case PhpParser::EndIf:
      case PhpParser::EndSwitch:
      case PhpParser::EndWhile:
      case PhpParser::Eval:
      case PhpParser::Exit:
      case PhpParser::Extends:
      case PhpParser::Final:
      case PhpParser::Finally:
      case PhpParser::FloatCast:
      case PhpParser::For:
      case PhpParser::Foreach:
      case PhpParser::Function_:
      case PhpParser::Global:
      case PhpParser::Goto:
      case PhpParser::If:
      case PhpParser::Implements:
      case PhpParser::Import:
      case PhpParser::Include:
      case PhpParser::IncludeOnce:
      case PhpParser::InstanceOf:
      case PhpParser::InsteadOf:
      case PhpParser::Int8Cast:
      case PhpParser::Int16Cast:
      case PhpParser::Int64Type:
      case PhpParser::IntType:
      case PhpParser::Interface:
      case PhpParser::IsSet:
      case PhpParser::List:
      case PhpParser::LogicalAnd:
      case PhpParser::LogicalOr:
      case PhpParser::LogicalXor:
      case PhpParser::Match_:
      case PhpParser::Namespace:
      case PhpParser::New:
      case PhpParser::Null:
      case PhpParser::ObjectType:
      case PhpParser::Parent_:
      case PhpParser::Partial:
      case PhpParser::Print:
      case PhpParser::Private:
      case PhpParser::Protected:
      case PhpParser::Public:
      case PhpParser::Readonly:
      case PhpParser::Require:
      case PhpParser::RequireOnce:
      case PhpParser::Resource:
      case PhpParser::Return:
      case PhpParser::Static:
      case PhpParser::StringType:
      case PhpParser::Switch:
      case PhpParser::Throw:
      case PhpParser::Trait:
      case PhpParser::Try:
      case PhpParser::Typeof:
      case PhpParser::UintCast:
      case PhpParser::UnicodeCast:
      case PhpParser::Unset:
      case PhpParser::Use:
      case PhpParser::Var:
      case PhpParser::While:
      case PhpParser::Yield:
      case PhpParser::From:
      case PhpParser::LambdaFn:
      case PhpParser::Ticks:
      case PhpParser::Encoding:
      case PhpParser::StrictTypes:
      case PhpParser::Get:
      case PhpParser::Set:
      case PhpParser::Call:
      case PhpParser::CallStatic:
      case PhpParser::Constructor:
      case PhpParser::Destruct:
      case PhpParser::Wakeup:
      case PhpParser::Sleep:
      case PhpParser::Autoload:
      case PhpParser::IsSet__:
      case PhpParser::Unset__:
      case PhpParser::ToString__:
      case PhpParser::Invoke:
      case PhpParser::SetState:
      case PhpParser::Clone__:
      case PhpParser::DebugInfo:
      case PhpParser::Namespace__:
      case PhpParser::Class__:
      case PhpParser::Traic__:
      case PhpParser::Function__:
      case PhpParser::Method__:
      case PhpParser::Line__:
      case PhpParser::File__:
      case PhpParser::Dir__:
      case PhpParser::NamespaceSeparator:
      case PhpParser::Dollar:
      case PhpParser::OpenRoundBracket:
      case PhpParser::VarName:
      case PhpParser::Label:
      case PhpParser::SingleQuoteString:
      case PhpParser::DoubleQuote:
      case PhpParser::StartNowDoc:
      case PhpParser::StartHereDoc: {
        enterOuterAlt(_localctx, 3);
        setState(1798);
        chain();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChainListContext ------------------------------------------------------------------

PhpParser::ChainListContext::ChainListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::ChainContext *> PhpParser::ChainListContext::chain() {
  return getRuleContexts<PhpParser::ChainContext>();
}

PhpParser::ChainContext* PhpParser::ChainListContext::chain(size_t i) {
  return getRuleContext<PhpParser::ChainContext>(i);
}

std::vector<tree::TerminalNode *> PhpParser::ChainListContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::ChainListContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::ChainListContext::getRuleIndex() const {
  return PhpParser::RuleChainList;
}

void PhpParser::ChainListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChainList(this);
}

void PhpParser::ChainListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChainList(this);
}

PhpParser::ChainListContext* PhpParser::chainList() {
  ChainListContext *_localctx = _tracker.createInstance<ChainListContext>(_ctx, getState());
  enterRule(_localctx, 234, PhpParser::RuleChainList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1801);
    chain();
    setState(1806);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PhpParser::Comma) {
      setState(1802);
      match(PhpParser::Comma);
      setState(1803);
      chain();
      setState(1808);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChainContext ------------------------------------------------------------------

PhpParser::ChainContext::ChainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::ChainOriginContext* PhpParser::ChainContext::chainOrigin() {
  return getRuleContext<PhpParser::ChainOriginContext>(0);
}

std::vector<PhpParser::MemberAccessContext *> PhpParser::ChainContext::memberAccess() {
  return getRuleContexts<PhpParser::MemberAccessContext>();
}

PhpParser::MemberAccessContext* PhpParser::ChainContext::memberAccess(size_t i) {
  return getRuleContext<PhpParser::MemberAccessContext>(i);
}


size_t PhpParser::ChainContext::getRuleIndex() const {
  return PhpParser::RuleChain;
}

void PhpParser::ChainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChain(this);
}

void PhpParser::ChainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChain(this);
}

PhpParser::ChainContext* PhpParser::chain() {
  ChainContext *_localctx = _tracker.createInstance<ChainContext>(_ctx, getState());
  enterRule(_localctx, 236, PhpParser::RuleChain);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1809);
    chainOrigin();
    setState(1813);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 231, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1810);
        memberAccess(); 
      }
      setState(1815);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 231, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChainOriginContext ------------------------------------------------------------------

PhpParser::ChainOriginContext::ChainOriginContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::ChainBaseContext* PhpParser::ChainOriginContext::chainBase() {
  return getRuleContext<PhpParser::ChainBaseContext>(0);
}

PhpParser::FunctionCallContext* PhpParser::ChainOriginContext::functionCall() {
  return getRuleContext<PhpParser::FunctionCallContext>(0);
}

tree::TerminalNode* PhpParser::ChainOriginContext::OpenRoundBracket() {
  return getToken(PhpParser::OpenRoundBracket, 0);
}

PhpParser::NewExprContext* PhpParser::ChainOriginContext::newExpr() {
  return getRuleContext<PhpParser::NewExprContext>(0);
}

tree::TerminalNode* PhpParser::ChainOriginContext::CloseRoundBracket() {
  return getToken(PhpParser::CloseRoundBracket, 0);
}


size_t PhpParser::ChainOriginContext::getRuleIndex() const {
  return PhpParser::RuleChainOrigin;
}

void PhpParser::ChainOriginContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChainOrigin(this);
}

void PhpParser::ChainOriginContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChainOrigin(this);
}

PhpParser::ChainOriginContext* PhpParser::chainOrigin() {
  ChainOriginContext *_localctx = _tracker.createInstance<ChainOriginContext>(_ctx, getState());
  enterRule(_localctx, 238, PhpParser::RuleChainOrigin);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1822);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 232, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1816);
      chainBase();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1817);
      functionCall();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1818);
      match(PhpParser::OpenRoundBracket);
      setState(1819);
      newExpr();
      setState(1820);
      match(PhpParser::CloseRoundBracket);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MemberAccessContext ------------------------------------------------------------------

PhpParser::MemberAccessContext::MemberAccessContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::MemberAccessContext::ObjectOperator() {
  return getToken(PhpParser::ObjectOperator, 0);
}

PhpParser::KeyedFieldNameContext* PhpParser::MemberAccessContext::keyedFieldName() {
  return getRuleContext<PhpParser::KeyedFieldNameContext>(0);
}

PhpParser::ActualArgumentsContext* PhpParser::MemberAccessContext::actualArguments() {
  return getRuleContext<PhpParser::ActualArgumentsContext>(0);
}


size_t PhpParser::MemberAccessContext::getRuleIndex() const {
  return PhpParser::RuleMemberAccess;
}

void PhpParser::MemberAccessContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemberAccess(this);
}

void PhpParser::MemberAccessContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemberAccess(this);
}

PhpParser::MemberAccessContext* PhpParser::memberAccess() {
  MemberAccessContext *_localctx = _tracker.createInstance<MemberAccessContext>(_ctx, getState());
  enterRule(_localctx, 240, PhpParser::RuleMemberAccess);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1824);
    match(PhpParser::ObjectOperator);
    setState(1825);
    keyedFieldName();
    setState(1827);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 233, _ctx)) {
    case 1: {
      setState(1826);
      actualArguments();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionCallContext ------------------------------------------------------------------

PhpParser::FunctionCallContext::FunctionCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::FunctionCallNameContext* PhpParser::FunctionCallContext::functionCallName() {
  return getRuleContext<PhpParser::FunctionCallNameContext>(0);
}

PhpParser::ActualArgumentsContext* PhpParser::FunctionCallContext::actualArguments() {
  return getRuleContext<PhpParser::ActualArgumentsContext>(0);
}


size_t PhpParser::FunctionCallContext::getRuleIndex() const {
  return PhpParser::RuleFunctionCall;
}

void PhpParser::FunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionCall(this);
}

void PhpParser::FunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionCall(this);
}

PhpParser::FunctionCallContext* PhpParser::functionCall() {
  FunctionCallContext *_localctx = _tracker.createInstance<FunctionCallContext>(_ctx, getState());
  enterRule(_localctx, 242, PhpParser::RuleFunctionCall);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1829);
    functionCallName();
    setState(1830);
    actualArguments();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionCallNameContext ------------------------------------------------------------------

PhpParser::FunctionCallNameContext::FunctionCallNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::QualifiedNamespaceNameContext* PhpParser::FunctionCallNameContext::qualifiedNamespaceName() {
  return getRuleContext<PhpParser::QualifiedNamespaceNameContext>(0);
}

PhpParser::ClassConstantContext* PhpParser::FunctionCallNameContext::classConstant() {
  return getRuleContext<PhpParser::ClassConstantContext>(0);
}

PhpParser::ChainBaseContext* PhpParser::FunctionCallNameContext::chainBase() {
  return getRuleContext<PhpParser::ChainBaseContext>(0);
}

PhpParser::ParenthesesContext* PhpParser::FunctionCallNameContext::parentheses() {
  return getRuleContext<PhpParser::ParenthesesContext>(0);
}


size_t PhpParser::FunctionCallNameContext::getRuleIndex() const {
  return PhpParser::RuleFunctionCallName;
}

void PhpParser::FunctionCallNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionCallName(this);
}

void PhpParser::FunctionCallNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionCallName(this);
}

PhpParser::FunctionCallNameContext* PhpParser::functionCallName() {
  FunctionCallNameContext *_localctx = _tracker.createInstance<FunctionCallNameContext>(_ctx, getState());
  enterRule(_localctx, 244, PhpParser::RuleFunctionCallName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1836);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 234, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1832);
      qualifiedNamespaceName();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1833);
      classConstant();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1834);
      chainBase();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1835);
      parentheses();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ActualArgumentsContext ------------------------------------------------------------------

PhpParser::ActualArgumentsContext::ActualArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::GenericDynamicArgsContext* PhpParser::ActualArgumentsContext::genericDynamicArgs() {
  return getRuleContext<PhpParser::GenericDynamicArgsContext>(0);
}

std::vector<PhpParser::ArgumentsContext *> PhpParser::ActualArgumentsContext::arguments() {
  return getRuleContexts<PhpParser::ArgumentsContext>();
}

PhpParser::ArgumentsContext* PhpParser::ActualArgumentsContext::arguments(size_t i) {
  return getRuleContext<PhpParser::ArgumentsContext>(i);
}

std::vector<PhpParser::SquareCurlyExpressionContext *> PhpParser::ActualArgumentsContext::squareCurlyExpression() {
  return getRuleContexts<PhpParser::SquareCurlyExpressionContext>();
}

PhpParser::SquareCurlyExpressionContext* PhpParser::ActualArgumentsContext::squareCurlyExpression(size_t i) {
  return getRuleContext<PhpParser::SquareCurlyExpressionContext>(i);
}


size_t PhpParser::ActualArgumentsContext::getRuleIndex() const {
  return PhpParser::RuleActualArguments;
}

void PhpParser::ActualArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterActualArguments(this);
}

void PhpParser::ActualArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitActualArguments(this);
}

PhpParser::ActualArgumentsContext* PhpParser::actualArguments() {
  ActualArgumentsContext *_localctx = _tracker.createInstance<ActualArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 246, PhpParser::RuleActualArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1839);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PhpParser::Lgeneric) {
      setState(1838);
      genericDynamicArgs();
    }
    setState(1842); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1841);
              arguments();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1844); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 236, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(1849);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1846);
        squareCurlyExpression(); 
      }
      setState(1851);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChainBaseContext ------------------------------------------------------------------

PhpParser::ChainBaseContext::ChainBaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::KeyedVariableContext *> PhpParser::ChainBaseContext::keyedVariable() {
  return getRuleContexts<PhpParser::KeyedVariableContext>();
}

PhpParser::KeyedVariableContext* PhpParser::ChainBaseContext::keyedVariable(size_t i) {
  return getRuleContext<PhpParser::KeyedVariableContext>(i);
}

tree::TerminalNode* PhpParser::ChainBaseContext::DoubleColon() {
  return getToken(PhpParser::DoubleColon, 0);
}

PhpParser::QualifiedStaticTypeRefContext* PhpParser::ChainBaseContext::qualifiedStaticTypeRef() {
  return getRuleContext<PhpParser::QualifiedStaticTypeRefContext>(0);
}


size_t PhpParser::ChainBaseContext::getRuleIndex() const {
  return PhpParser::RuleChainBase;
}

void PhpParser::ChainBaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChainBase(this);
}

void PhpParser::ChainBaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChainBase(this);
}

PhpParser::ChainBaseContext* PhpParser::chainBase() {
  ChainBaseContext *_localctx = _tracker.createInstance<ChainBaseContext>(_ctx, getState());
  enterRule(_localctx, 248, PhpParser::RuleChainBase);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1861);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::Dollar:
      case PhpParser::VarName: {
        enterOuterAlt(_localctx, 1);
        setState(1852);
        keyedVariable();
        setState(1855);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 238, _ctx)) {
        case 1: {
          setState(1853);
          match(PhpParser::DoubleColon);
          setState(1854);
          keyedVariable();
          break;
        }

        default:
          break;
        }
        break;
      }

      case PhpParser::Abstract:
      case PhpParser::Array:
      case PhpParser::As:
      case PhpParser::BinaryCast:
      case PhpParser::BoolType:
      case PhpParser::BooleanConstant:
      case PhpParser::Break:
      case PhpParser::Callable:
      case PhpParser::Case:
      case PhpParser::Catch:
      case PhpParser::Class:
      case PhpParser::Clone:
      case PhpParser::Const:
      case PhpParser::Continue:
      case PhpParser::Declare:
      case PhpParser::Default:
      case PhpParser::Do:
      case PhpParser::DoubleCast:
      case PhpParser::DoubleType:
      case PhpParser::Echo:
      case PhpParser::Else:
      case PhpParser::ElseIf:
      case PhpParser::Empty:
      case PhpParser::Enum_:
      case PhpParser::EndDeclare:
      case PhpParser::EndFor:
      case PhpParser::EndForeach:
      case PhpParser::EndIf:
      case PhpParser::EndSwitch:
      case PhpParser::EndWhile:
      case PhpParser::Eval:
      case PhpParser::Exit:
      case PhpParser::Extends:
      case PhpParser::Final:
      case PhpParser::Finally:
      case PhpParser::FloatCast:
      case PhpParser::For:
      case PhpParser::Foreach:
      case PhpParser::Function_:
      case PhpParser::Global:
      case PhpParser::Goto:
      case PhpParser::If:
      case PhpParser::Implements:
      case PhpParser::Import:
      case PhpParser::Include:
      case PhpParser::IncludeOnce:
      case PhpParser::InstanceOf:
      case PhpParser::InsteadOf:
      case PhpParser::Int8Cast:
      case PhpParser::Int16Cast:
      case PhpParser::Int64Type:
      case PhpParser::IntType:
      case PhpParser::Interface:
      case PhpParser::IsSet:
      case PhpParser::List:
      case PhpParser::LogicalAnd:
      case PhpParser::LogicalOr:
      case PhpParser::LogicalXor:
      case PhpParser::Match_:
      case PhpParser::Namespace:
      case PhpParser::New:
      case PhpParser::Null:
      case PhpParser::ObjectType:
      case PhpParser::Parent_:
      case PhpParser::Partial:
      case PhpParser::Print:
      case PhpParser::Private:
      case PhpParser::Protected:
      case PhpParser::Public:
      case PhpParser::Readonly:
      case PhpParser::Require:
      case PhpParser::RequireOnce:
      case PhpParser::Resource:
      case PhpParser::Return:
      case PhpParser::Static:
      case PhpParser::StringType:
      case PhpParser::Switch:
      case PhpParser::Throw:
      case PhpParser::Trait:
      case PhpParser::Try:
      case PhpParser::Typeof:
      case PhpParser::UintCast:
      case PhpParser::UnicodeCast:
      case PhpParser::Unset:
      case PhpParser::Use:
      case PhpParser::Var:
      case PhpParser::While:
      case PhpParser::Yield:
      case PhpParser::From:
      case PhpParser::LambdaFn:
      case PhpParser::Ticks:
      case PhpParser::Encoding:
      case PhpParser::StrictTypes:
      case PhpParser::Get:
      case PhpParser::Set:
      case PhpParser::Call:
      case PhpParser::CallStatic:
      case PhpParser::Constructor:
      case PhpParser::Destruct:
      case PhpParser::Wakeup:
      case PhpParser::Sleep:
      case PhpParser::Autoload:
      case PhpParser::IsSet__:
      case PhpParser::Unset__:
      case PhpParser::ToString__:
      case PhpParser::Invoke:
      case PhpParser::SetState:
      case PhpParser::Clone__:
      case PhpParser::DebugInfo:
      case PhpParser::Namespace__:
      case PhpParser::Class__:
      case PhpParser::Traic__:
      case PhpParser::Function__:
      case PhpParser::Method__:
      case PhpParser::Line__:
      case PhpParser::File__:
      case PhpParser::Dir__:
      case PhpParser::NamespaceSeparator:
      case PhpParser::Label: {
        enterOuterAlt(_localctx, 2);
        setState(1857);
        qualifiedStaticTypeRef();
        setState(1858);
        match(PhpParser::DoubleColon);
        setState(1859);
        keyedVariable();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyedFieldNameContext ------------------------------------------------------------------

PhpParser::KeyedFieldNameContext::KeyedFieldNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::KeyedSimpleFieldNameContext* PhpParser::KeyedFieldNameContext::keyedSimpleFieldName() {
  return getRuleContext<PhpParser::KeyedSimpleFieldNameContext>(0);
}

PhpParser::KeyedVariableContext* PhpParser::KeyedFieldNameContext::keyedVariable() {
  return getRuleContext<PhpParser::KeyedVariableContext>(0);
}


size_t PhpParser::KeyedFieldNameContext::getRuleIndex() const {
  return PhpParser::RuleKeyedFieldName;
}

void PhpParser::KeyedFieldNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyedFieldName(this);
}

void PhpParser::KeyedFieldNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyedFieldName(this);
}

PhpParser::KeyedFieldNameContext* PhpParser::keyedFieldName() {
  KeyedFieldNameContext *_localctx = _tracker.createInstance<KeyedFieldNameContext>(_ctx, getState());
  enterRule(_localctx, 250, PhpParser::RuleKeyedFieldName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1865);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::Abstract:
      case PhpParser::Array:
      case PhpParser::As:
      case PhpParser::BinaryCast:
      case PhpParser::BoolType:
      case PhpParser::BooleanConstant:
      case PhpParser::Break:
      case PhpParser::Callable:
      case PhpParser::Case:
      case PhpParser::Catch:
      case PhpParser::Class:
      case PhpParser::Clone:
      case PhpParser::Const:
      case PhpParser::Continue:
      case PhpParser::Declare:
      case PhpParser::Default:
      case PhpParser::Do:
      case PhpParser::DoubleCast:
      case PhpParser::DoubleType:
      case PhpParser::Echo:
      case PhpParser::Else:
      case PhpParser::ElseIf:
      case PhpParser::Empty:
      case PhpParser::Enum_:
      case PhpParser::EndDeclare:
      case PhpParser::EndFor:
      case PhpParser::EndForeach:
      case PhpParser::EndIf:
      case PhpParser::EndSwitch:
      case PhpParser::EndWhile:
      case PhpParser::Eval:
      case PhpParser::Exit:
      case PhpParser::Extends:
      case PhpParser::Final:
      case PhpParser::Finally:
      case PhpParser::FloatCast:
      case PhpParser::For:
      case PhpParser::Foreach:
      case PhpParser::Function_:
      case PhpParser::Global:
      case PhpParser::Goto:
      case PhpParser::If:
      case PhpParser::Implements:
      case PhpParser::Import:
      case PhpParser::Include:
      case PhpParser::IncludeOnce:
      case PhpParser::InstanceOf:
      case PhpParser::InsteadOf:
      case PhpParser::Int8Cast:
      case PhpParser::Int16Cast:
      case PhpParser::Int64Type:
      case PhpParser::IntType:
      case PhpParser::Interface:
      case PhpParser::IsSet:
      case PhpParser::List:
      case PhpParser::LogicalAnd:
      case PhpParser::LogicalOr:
      case PhpParser::LogicalXor:
      case PhpParser::Match_:
      case PhpParser::Namespace:
      case PhpParser::New:
      case PhpParser::Null:
      case PhpParser::ObjectType:
      case PhpParser::Parent_:
      case PhpParser::Partial:
      case PhpParser::Print:
      case PhpParser::Private:
      case PhpParser::Protected:
      case PhpParser::Public:
      case PhpParser::Readonly:
      case PhpParser::Require:
      case PhpParser::RequireOnce:
      case PhpParser::Resource:
      case PhpParser::Return:
      case PhpParser::Static:
      case PhpParser::StringType:
      case PhpParser::Switch:
      case PhpParser::Throw:
      case PhpParser::Trait:
      case PhpParser::Try:
      case PhpParser::Typeof:
      case PhpParser::UintCast:
      case PhpParser::UnicodeCast:
      case PhpParser::Unset:
      case PhpParser::Use:
      case PhpParser::Var:
      case PhpParser::While:
      case PhpParser::Yield:
      case PhpParser::From:
      case PhpParser::LambdaFn:
      case PhpParser::Ticks:
      case PhpParser::Encoding:
      case PhpParser::StrictTypes:
      case PhpParser::Get:
      case PhpParser::Set:
      case PhpParser::Call:
      case PhpParser::CallStatic:
      case PhpParser::Constructor:
      case PhpParser::Destruct:
      case PhpParser::Wakeup:
      case PhpParser::Sleep:
      case PhpParser::Autoload:
      case PhpParser::IsSet__:
      case PhpParser::Unset__:
      case PhpParser::ToString__:
      case PhpParser::Invoke:
      case PhpParser::SetState:
      case PhpParser::Clone__:
      case PhpParser::DebugInfo:
      case PhpParser::Namespace__:
      case PhpParser::Class__:
      case PhpParser::Traic__:
      case PhpParser::Function__:
      case PhpParser::Method__:
      case PhpParser::Line__:
      case PhpParser::File__:
      case PhpParser::Dir__:
      case PhpParser::OpenCurlyBracket:
      case PhpParser::Label: {
        enterOuterAlt(_localctx, 1);
        setState(1863);
        keyedSimpleFieldName();
        break;
      }

      case PhpParser::Dollar:
      case PhpParser::VarName: {
        enterOuterAlt(_localctx, 2);
        setState(1864);
        keyedVariable();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyedSimpleFieldNameContext ------------------------------------------------------------------

PhpParser::KeyedSimpleFieldNameContext::KeyedSimpleFieldNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::IdentifierContext* PhpParser::KeyedSimpleFieldNameContext::identifier() {
  return getRuleContext<PhpParser::IdentifierContext>(0);
}

tree::TerminalNode* PhpParser::KeyedSimpleFieldNameContext::OpenCurlyBracket() {
  return getToken(PhpParser::OpenCurlyBracket, 0);
}

PhpParser::ExpressionContext* PhpParser::KeyedSimpleFieldNameContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

tree::TerminalNode* PhpParser::KeyedSimpleFieldNameContext::CloseCurlyBracket() {
  return getToken(PhpParser::CloseCurlyBracket, 0);
}

std::vector<PhpParser::SquareCurlyExpressionContext *> PhpParser::KeyedSimpleFieldNameContext::squareCurlyExpression() {
  return getRuleContexts<PhpParser::SquareCurlyExpressionContext>();
}

PhpParser::SquareCurlyExpressionContext* PhpParser::KeyedSimpleFieldNameContext::squareCurlyExpression(size_t i) {
  return getRuleContext<PhpParser::SquareCurlyExpressionContext>(i);
}


size_t PhpParser::KeyedSimpleFieldNameContext::getRuleIndex() const {
  return PhpParser::RuleKeyedSimpleFieldName;
}

void PhpParser::KeyedSimpleFieldNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyedSimpleFieldName(this);
}

void PhpParser::KeyedSimpleFieldNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyedSimpleFieldName(this);
}

PhpParser::KeyedSimpleFieldNameContext* PhpParser::keyedSimpleFieldName() {
  KeyedSimpleFieldNameContext *_localctx = _tracker.createInstance<KeyedSimpleFieldNameContext>(_ctx, getState());
  enterRule(_localctx, 252, PhpParser::RuleKeyedSimpleFieldName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1872);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::Abstract:
      case PhpParser::Array:
      case PhpParser::As:
      case PhpParser::BinaryCast:
      case PhpParser::BoolType:
      case PhpParser::BooleanConstant:
      case PhpParser::Break:
      case PhpParser::Callable:
      case PhpParser::Case:
      case PhpParser::Catch:
      case PhpParser::Class:
      case PhpParser::Clone:
      case PhpParser::Const:
      case PhpParser::Continue:
      case PhpParser::Declare:
      case PhpParser::Default:
      case PhpParser::Do:
      case PhpParser::DoubleCast:
      case PhpParser::DoubleType:
      case PhpParser::Echo:
      case PhpParser::Else:
      case PhpParser::ElseIf:
      case PhpParser::Empty:
      case PhpParser::Enum_:
      case PhpParser::EndDeclare:
      case PhpParser::EndFor:
      case PhpParser::EndForeach:
      case PhpParser::EndIf:
      case PhpParser::EndSwitch:
      case PhpParser::EndWhile:
      case PhpParser::Eval:
      case PhpParser::Exit:
      case PhpParser::Extends:
      case PhpParser::Final:
      case PhpParser::Finally:
      case PhpParser::FloatCast:
      case PhpParser::For:
      case PhpParser::Foreach:
      case PhpParser::Function_:
      case PhpParser::Global:
      case PhpParser::Goto:
      case PhpParser::If:
      case PhpParser::Implements:
      case PhpParser::Import:
      case PhpParser::Include:
      case PhpParser::IncludeOnce:
      case PhpParser::InstanceOf:
      case PhpParser::InsteadOf:
      case PhpParser::Int8Cast:
      case PhpParser::Int16Cast:
      case PhpParser::Int64Type:
      case PhpParser::IntType:
      case PhpParser::Interface:
      case PhpParser::IsSet:
      case PhpParser::List:
      case PhpParser::LogicalAnd:
      case PhpParser::LogicalOr:
      case PhpParser::LogicalXor:
      case PhpParser::Match_:
      case PhpParser::Namespace:
      case PhpParser::New:
      case PhpParser::Null:
      case PhpParser::ObjectType:
      case PhpParser::Parent_:
      case PhpParser::Partial:
      case PhpParser::Print:
      case PhpParser::Private:
      case PhpParser::Protected:
      case PhpParser::Public:
      case PhpParser::Readonly:
      case PhpParser::Require:
      case PhpParser::RequireOnce:
      case PhpParser::Resource:
      case PhpParser::Return:
      case PhpParser::Static:
      case PhpParser::StringType:
      case PhpParser::Switch:
      case PhpParser::Throw:
      case PhpParser::Trait:
      case PhpParser::Try:
      case PhpParser::Typeof:
      case PhpParser::UintCast:
      case PhpParser::UnicodeCast:
      case PhpParser::Unset:
      case PhpParser::Use:
      case PhpParser::Var:
      case PhpParser::While:
      case PhpParser::Yield:
      case PhpParser::From:
      case PhpParser::LambdaFn:
      case PhpParser::Ticks:
      case PhpParser::Encoding:
      case PhpParser::StrictTypes:
      case PhpParser::Get:
      case PhpParser::Set:
      case PhpParser::Call:
      case PhpParser::CallStatic:
      case PhpParser::Constructor:
      case PhpParser::Destruct:
      case PhpParser::Wakeup:
      case PhpParser::Sleep:
      case PhpParser::Autoload:
      case PhpParser::IsSet__:
      case PhpParser::Unset__:
      case PhpParser::ToString__:
      case PhpParser::Invoke:
      case PhpParser::SetState:
      case PhpParser::Clone__:
      case PhpParser::DebugInfo:
      case PhpParser::Namespace__:
      case PhpParser::Class__:
      case PhpParser::Traic__:
      case PhpParser::Function__:
      case PhpParser::Method__:
      case PhpParser::Line__:
      case PhpParser::File__:
      case PhpParser::Dir__:
      case PhpParser::Label: {
        setState(1867);
        identifier();
        break;
      }

      case PhpParser::OpenCurlyBracket: {
        setState(1868);
        match(PhpParser::OpenCurlyBracket);
        setState(1869);
        expression(0);
        setState(1870);
        match(PhpParser::CloseCurlyBracket);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1877);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1874);
        squareCurlyExpression(); 
      }
      setState(1879);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyedVariableContext ------------------------------------------------------------------

PhpParser::KeyedVariableContext::KeyedVariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::KeyedVariableContext::VarName() {
  return getToken(PhpParser::VarName, 0);
}

std::vector<tree::TerminalNode *> PhpParser::KeyedVariableContext::Dollar() {
  return getTokens(PhpParser::Dollar);
}

tree::TerminalNode* PhpParser::KeyedVariableContext::Dollar(size_t i) {
  return getToken(PhpParser::Dollar, i);
}

tree::TerminalNode* PhpParser::KeyedVariableContext::OpenCurlyBracket() {
  return getToken(PhpParser::OpenCurlyBracket, 0);
}

PhpParser::ExpressionContext* PhpParser::KeyedVariableContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

tree::TerminalNode* PhpParser::KeyedVariableContext::CloseCurlyBracket() {
  return getToken(PhpParser::CloseCurlyBracket, 0);
}

std::vector<PhpParser::SquareCurlyExpressionContext *> PhpParser::KeyedVariableContext::squareCurlyExpression() {
  return getRuleContexts<PhpParser::SquareCurlyExpressionContext>();
}

PhpParser::SquareCurlyExpressionContext* PhpParser::KeyedVariableContext::squareCurlyExpression(size_t i) {
  return getRuleContext<PhpParser::SquareCurlyExpressionContext>(i);
}


size_t PhpParser::KeyedVariableContext::getRuleIndex() const {
  return PhpParser::RuleKeyedVariable;
}

void PhpParser::KeyedVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyedVariable(this);
}

void PhpParser::KeyedVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyedVariable(this);
}

PhpParser::KeyedVariableContext* PhpParser::keyedVariable() {
  KeyedVariableContext *_localctx = _tracker.createInstance<KeyedVariableContext>(_ctx, getState());
  enterRule(_localctx, 254, PhpParser::RuleKeyedVariable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1883);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 243, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1880);
        match(PhpParser::Dollar); 
      }
      setState(1885);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 243, _ctx);
    }
    setState(1892);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::VarName: {
        setState(1886);
        match(PhpParser::VarName);
        break;
      }

      case PhpParser::Dollar: {
        setState(1887);
        match(PhpParser::Dollar);
        setState(1888);
        match(PhpParser::OpenCurlyBracket);
        setState(1889);
        expression(0);
        setState(1890);
        match(PhpParser::CloseCurlyBracket);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1897);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 245, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1894);
        squareCurlyExpression(); 
      }
      setState(1899);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 245, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SquareCurlyExpressionContext ------------------------------------------------------------------

PhpParser::SquareCurlyExpressionContext::SquareCurlyExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::SquareCurlyExpressionContext::OpenSquareBracket() {
  return getToken(PhpParser::OpenSquareBracket, 0);
}

tree::TerminalNode* PhpParser::SquareCurlyExpressionContext::CloseSquareBracket() {
  return getToken(PhpParser::CloseSquareBracket, 0);
}

PhpParser::ExpressionContext* PhpParser::SquareCurlyExpressionContext::expression() {
  return getRuleContext<PhpParser::ExpressionContext>(0);
}

tree::TerminalNode* PhpParser::SquareCurlyExpressionContext::OpenCurlyBracket() {
  return getToken(PhpParser::OpenCurlyBracket, 0);
}

tree::TerminalNode* PhpParser::SquareCurlyExpressionContext::CloseCurlyBracket() {
  return getToken(PhpParser::CloseCurlyBracket, 0);
}


size_t PhpParser::SquareCurlyExpressionContext::getRuleIndex() const {
  return PhpParser::RuleSquareCurlyExpression;
}

void PhpParser::SquareCurlyExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSquareCurlyExpression(this);
}

void PhpParser::SquareCurlyExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSquareCurlyExpression(this);
}

PhpParser::SquareCurlyExpressionContext* PhpParser::squareCurlyExpression() {
  SquareCurlyExpressionContext *_localctx = _tracker.createInstance<SquareCurlyExpressionContext>(_ctx, getState());
  enterRule(_localctx, 256, PhpParser::RuleSquareCurlyExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1909);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PhpParser::OpenSquareBracket: {
        enterOuterAlt(_localctx, 1);
        setState(1900);
        match(PhpParser::OpenSquareBracket);
        setState(1902);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 44) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 44)) & -1) != 0) || ((((_la - 108) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 108)) & 441352763482308607) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 194)) & 4396974138177) != 0)) {
          setState(1901);
          expression(0);
        }
        setState(1904);
        match(PhpParser::CloseSquareBracket);
        break;
      }

      case PhpParser::OpenCurlyBracket: {
        enterOuterAlt(_localctx, 2);
        setState(1905);
        match(PhpParser::OpenCurlyBracket);
        setState(1906);
        expression(0);
        setState(1907);
        match(PhpParser::CloseCurlyBracket);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentListContext ------------------------------------------------------------------

PhpParser::AssignmentListContext::AssignmentListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PhpParser::AssignmentListElementContext *> PhpParser::AssignmentListContext::assignmentListElement() {
  return getRuleContexts<PhpParser::AssignmentListElementContext>();
}

PhpParser::AssignmentListElementContext* PhpParser::AssignmentListContext::assignmentListElement(size_t i) {
  return getRuleContext<PhpParser::AssignmentListElementContext>(i);
}

std::vector<tree::TerminalNode *> PhpParser::AssignmentListContext::Comma() {
  return getTokens(PhpParser::Comma);
}

tree::TerminalNode* PhpParser::AssignmentListContext::Comma(size_t i) {
  return getToken(PhpParser::Comma, i);
}


size_t PhpParser::AssignmentListContext::getRuleIndex() const {
  return PhpParser::RuleAssignmentList;
}

void PhpParser::AssignmentListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentList(this);
}

void PhpParser::AssignmentListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentList(this);
}

PhpParser::AssignmentListContext* PhpParser::assignmentList() {
  AssignmentListContext *_localctx = _tracker.createInstance<AssignmentListContext>(_ctx, getState());
  enterRule(_localctx, 258, PhpParser::RuleAssignmentList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1912);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 44) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 44)) & -1) != 0) || ((((_la - 108) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 108)) & 441352763482308607) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 194)) & 4396974138193) != 0)) {
      setState(1911);
      assignmentListElement();
    }
    setState(1920);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PhpParser::Comma) {
      setState(1914);
      match(PhpParser::Comma);
      setState(1916);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 44) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 44)) & -1) != 0) || ((((_la - 108) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 108)) & 441352763482308607) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 194)) & 4396974138193) != 0)) {
        setState(1915);
        assignmentListElement();
      }
      setState(1922);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentListElementContext ------------------------------------------------------------------

PhpParser::AssignmentListElementContext::AssignmentListElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PhpParser::ChainContext* PhpParser::AssignmentListElementContext::chain() {
  return getRuleContext<PhpParser::ChainContext>(0);
}

tree::TerminalNode* PhpParser::AssignmentListElementContext::List() {
  return getToken(PhpParser::List, 0);
}

tree::TerminalNode* PhpParser::AssignmentListElementContext::OpenRoundBracket() {
  return getToken(PhpParser::OpenRoundBracket, 0);
}

PhpParser::AssignmentListContext* PhpParser::AssignmentListElementContext::assignmentList() {
  return getRuleContext<PhpParser::AssignmentListContext>(0);
}

tree::TerminalNode* PhpParser::AssignmentListElementContext::CloseRoundBracket() {
  return getToken(PhpParser::CloseRoundBracket, 0);
}

PhpParser::ArrayItemContext* PhpParser::AssignmentListElementContext::arrayItem() {
  return getRuleContext<PhpParser::ArrayItemContext>(0);
}


size_t PhpParser::AssignmentListElementContext::getRuleIndex() const {
  return PhpParser::RuleAssignmentListElement;
}

void PhpParser::AssignmentListElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentListElement(this);
}

void PhpParser::AssignmentListElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentListElement(this);
}

PhpParser::AssignmentListElementContext* PhpParser::assignmentListElement() {
  AssignmentListElementContext *_localctx = _tracker.createInstance<AssignmentListElementContext>(_ctx, getState());
  enterRule(_localctx, 260, PhpParser::RuleAssignmentListElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1930);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 251, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1923);
      chain();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1924);
      match(PhpParser::List);
      setState(1925);
      match(PhpParser::OpenRoundBracket);
      setState(1926);
      assignmentList();
      setState(1927);
      match(PhpParser::CloseRoundBracket);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1929);
      arrayItem();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModifierContext ------------------------------------------------------------------

PhpParser::ModifierContext::ModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::ModifierContext::Abstract() {
  return getToken(PhpParser::Abstract, 0);
}

tree::TerminalNode* PhpParser::ModifierContext::Final() {
  return getToken(PhpParser::Final, 0);
}


size_t PhpParser::ModifierContext::getRuleIndex() const {
  return PhpParser::RuleModifier;
}

void PhpParser::ModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModifier(this);
}

void PhpParser::ModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModifier(this);
}

PhpParser::ModifierContext* PhpParser::modifier() {
  ModifierContext *_localctx = _tracker.createInstance<ModifierContext>(_ctx, getState());
  enterRule(_localctx, 262, PhpParser::RuleModifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1932);
    _la = _input->LA(1);
    if (!(_la == PhpParser::Abstract

    || _la == PhpParser::Final)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

PhpParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::IdentifierContext::Label() {
  return getToken(PhpParser::Label, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Abstract() {
  return getToken(PhpParser::Abstract, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Array() {
  return getToken(PhpParser::Array, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::As() {
  return getToken(PhpParser::As, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::BinaryCast() {
  return getToken(PhpParser::BinaryCast, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::BoolType() {
  return getToken(PhpParser::BoolType, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::BooleanConstant() {
  return getToken(PhpParser::BooleanConstant, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Break() {
  return getToken(PhpParser::Break, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Callable() {
  return getToken(PhpParser::Callable, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Case() {
  return getToken(PhpParser::Case, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Catch() {
  return getToken(PhpParser::Catch, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Class() {
  return getToken(PhpParser::Class, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Clone() {
  return getToken(PhpParser::Clone, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Const() {
  return getToken(PhpParser::Const, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Continue() {
  return getToken(PhpParser::Continue, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Declare() {
  return getToken(PhpParser::Declare, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Default() {
  return getToken(PhpParser::Default, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Do() {
  return getToken(PhpParser::Do, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::DoubleCast() {
  return getToken(PhpParser::DoubleCast, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::DoubleType() {
  return getToken(PhpParser::DoubleType, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Echo() {
  return getToken(PhpParser::Echo, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Else() {
  return getToken(PhpParser::Else, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::ElseIf() {
  return getToken(PhpParser::ElseIf, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Empty() {
  return getToken(PhpParser::Empty, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::EndDeclare() {
  return getToken(PhpParser::EndDeclare, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::EndFor() {
  return getToken(PhpParser::EndFor, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::EndForeach() {
  return getToken(PhpParser::EndForeach, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::EndIf() {
  return getToken(PhpParser::EndIf, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::EndSwitch() {
  return getToken(PhpParser::EndSwitch, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::EndWhile() {
  return getToken(PhpParser::EndWhile, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Eval() {
  return getToken(PhpParser::Eval, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Exit() {
  return getToken(PhpParser::Exit, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Extends() {
  return getToken(PhpParser::Extends, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Final() {
  return getToken(PhpParser::Final, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Finally() {
  return getToken(PhpParser::Finally, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::FloatCast() {
  return getToken(PhpParser::FloatCast, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::For() {
  return getToken(PhpParser::For, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Foreach() {
  return getToken(PhpParser::Foreach, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Function_() {
  return getToken(PhpParser::Function_, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Global() {
  return getToken(PhpParser::Global, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Goto() {
  return getToken(PhpParser::Goto, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::If() {
  return getToken(PhpParser::If, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Implements() {
  return getToken(PhpParser::Implements, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Import() {
  return getToken(PhpParser::Import, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Include() {
  return getToken(PhpParser::Include, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::IncludeOnce() {
  return getToken(PhpParser::IncludeOnce, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::InstanceOf() {
  return getToken(PhpParser::InstanceOf, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::InsteadOf() {
  return getToken(PhpParser::InsteadOf, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Int16Cast() {
  return getToken(PhpParser::Int16Cast, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Int64Type() {
  return getToken(PhpParser::Int64Type, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Int8Cast() {
  return getToken(PhpParser::Int8Cast, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Interface() {
  return getToken(PhpParser::Interface, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::IntType() {
  return getToken(PhpParser::IntType, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::IsSet() {
  return getToken(PhpParser::IsSet, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::LambdaFn() {
  return getToken(PhpParser::LambdaFn, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::List() {
  return getToken(PhpParser::List, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::LogicalAnd() {
  return getToken(PhpParser::LogicalAnd, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::LogicalOr() {
  return getToken(PhpParser::LogicalOr, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::LogicalXor() {
  return getToken(PhpParser::LogicalXor, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Namespace() {
  return getToken(PhpParser::Namespace, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::New() {
  return getToken(PhpParser::New, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Null() {
  return getToken(PhpParser::Null, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::ObjectType() {
  return getToken(PhpParser::ObjectType, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Parent_() {
  return getToken(PhpParser::Parent_, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Partial() {
  return getToken(PhpParser::Partial, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Print() {
  return getToken(PhpParser::Print, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Private() {
  return getToken(PhpParser::Private, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Protected() {
  return getToken(PhpParser::Protected, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Public() {
  return getToken(PhpParser::Public, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Readonly() {
  return getToken(PhpParser::Readonly, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Require() {
  return getToken(PhpParser::Require, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::RequireOnce() {
  return getToken(PhpParser::RequireOnce, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Resource() {
  return getToken(PhpParser::Resource, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Return() {
  return getToken(PhpParser::Return, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Static() {
  return getToken(PhpParser::Static, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::StringType() {
  return getToken(PhpParser::StringType, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Switch() {
  return getToken(PhpParser::Switch, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Throw() {
  return getToken(PhpParser::Throw, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Trait() {
  return getToken(PhpParser::Trait, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Try() {
  return getToken(PhpParser::Try, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Typeof() {
  return getToken(PhpParser::Typeof, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::UintCast() {
  return getToken(PhpParser::UintCast, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::UnicodeCast() {
  return getToken(PhpParser::UnicodeCast, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Unset() {
  return getToken(PhpParser::Unset, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Use() {
  return getToken(PhpParser::Use, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Var() {
  return getToken(PhpParser::Var, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::While() {
  return getToken(PhpParser::While, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Yield() {
  return getToken(PhpParser::Yield, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::From() {
  return getToken(PhpParser::From, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Enum_() {
  return getToken(PhpParser::Enum_, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Match_() {
  return getToken(PhpParser::Match_, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Ticks() {
  return getToken(PhpParser::Ticks, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Encoding() {
  return getToken(PhpParser::Encoding, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::StrictTypes() {
  return getToken(PhpParser::StrictTypes, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Get() {
  return getToken(PhpParser::Get, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Set() {
  return getToken(PhpParser::Set, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Call() {
  return getToken(PhpParser::Call, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::CallStatic() {
  return getToken(PhpParser::CallStatic, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Constructor() {
  return getToken(PhpParser::Constructor, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Destruct() {
  return getToken(PhpParser::Destruct, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Wakeup() {
  return getToken(PhpParser::Wakeup, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Sleep() {
  return getToken(PhpParser::Sleep, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Autoload() {
  return getToken(PhpParser::Autoload, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::IsSet__() {
  return getToken(PhpParser::IsSet__, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Unset__() {
  return getToken(PhpParser::Unset__, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::ToString__() {
  return getToken(PhpParser::ToString__, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Invoke() {
  return getToken(PhpParser::Invoke, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::SetState() {
  return getToken(PhpParser::SetState, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Clone__() {
  return getToken(PhpParser::Clone__, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::DebugInfo() {
  return getToken(PhpParser::DebugInfo, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Namespace__() {
  return getToken(PhpParser::Namespace__, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Class__() {
  return getToken(PhpParser::Class__, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Traic__() {
  return getToken(PhpParser::Traic__, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Function__() {
  return getToken(PhpParser::Function__, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Method__() {
  return getToken(PhpParser::Method__, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Line__() {
  return getToken(PhpParser::Line__, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::File__() {
  return getToken(PhpParser::File__, 0);
}

tree::TerminalNode* PhpParser::IdentifierContext::Dir__() {
  return getToken(PhpParser::Dir__, 0);
}


size_t PhpParser::IdentifierContext::getRuleIndex() const {
  return PhpParser::RuleIdentifier;
}

void PhpParser::IdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier(this);
}

void PhpParser::IdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier(this);
}

PhpParser::IdentifierContext* PhpParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 264, PhpParser::RuleIdentifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1934);
    _la = _input->LA(1);
    if (!(((((_la - 44) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 44)) & -1) != 0) || ((((_la - 108) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 108)) & 9007199254740991) != 0) || _la == PhpParser::Label)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MemberModifierContext ------------------------------------------------------------------

PhpParser::MemberModifierContext::MemberModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::MemberModifierContext::Public() {
  return getToken(PhpParser::Public, 0);
}

tree::TerminalNode* PhpParser::MemberModifierContext::Protected() {
  return getToken(PhpParser::Protected, 0);
}

tree::TerminalNode* PhpParser::MemberModifierContext::Private() {
  return getToken(PhpParser::Private, 0);
}

tree::TerminalNode* PhpParser::MemberModifierContext::Static() {
  return getToken(PhpParser::Static, 0);
}

tree::TerminalNode* PhpParser::MemberModifierContext::Abstract() {
  return getToken(PhpParser::Abstract, 0);
}

tree::TerminalNode* PhpParser::MemberModifierContext::Final() {
  return getToken(PhpParser::Final, 0);
}

tree::TerminalNode* PhpParser::MemberModifierContext::Readonly() {
  return getToken(PhpParser::Readonly, 0);
}


size_t PhpParser::MemberModifierContext::getRuleIndex() const {
  return PhpParser::RuleMemberModifier;
}

void PhpParser::MemberModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemberModifier(this);
}

void PhpParser::MemberModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemberModifier(this);
}

PhpParser::MemberModifierContext* PhpParser::memberModifier() {
  MemberModifierContext *_localctx = _tracker.createInstance<MemberModifierContext>(_ctx, getState());
  enterRule(_localctx, 266, PhpParser::RuleMemberModifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1936);
    _la = _input->LA(1);
    if (!(_la == PhpParser::Abstract || ((((_la - 77) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 77)) & 2327872274433) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MagicConstantContext ------------------------------------------------------------------

PhpParser::MagicConstantContext::MagicConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::MagicConstantContext::Namespace__() {
  return getToken(PhpParser::Namespace__, 0);
}

tree::TerminalNode* PhpParser::MagicConstantContext::Class__() {
  return getToken(PhpParser::Class__, 0);
}

tree::TerminalNode* PhpParser::MagicConstantContext::Traic__() {
  return getToken(PhpParser::Traic__, 0);
}

tree::TerminalNode* PhpParser::MagicConstantContext::Function__() {
  return getToken(PhpParser::Function__, 0);
}

tree::TerminalNode* PhpParser::MagicConstantContext::Method__() {
  return getToken(PhpParser::Method__, 0);
}

tree::TerminalNode* PhpParser::MagicConstantContext::Line__() {
  return getToken(PhpParser::Line__, 0);
}

tree::TerminalNode* PhpParser::MagicConstantContext::File__() {
  return getToken(PhpParser::File__, 0);
}

tree::TerminalNode* PhpParser::MagicConstantContext::Dir__() {
  return getToken(PhpParser::Dir__, 0);
}


size_t PhpParser::MagicConstantContext::getRuleIndex() const {
  return PhpParser::RuleMagicConstant;
}

void PhpParser::MagicConstantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMagicConstant(this);
}

void PhpParser::MagicConstantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMagicConstant(this);
}

PhpParser::MagicConstantContext* PhpParser::magicConstant() {
  MagicConstantContext *_localctx = _tracker.createInstance<MagicConstantContext>(_ctx, getState());
  enterRule(_localctx, 268, PhpParser::RuleMagicConstant);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1938);
    _la = _input->LA(1);
    if (!(((((_la - 153) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 153)) & 255) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MagicMethodContext ------------------------------------------------------------------

PhpParser::MagicMethodContext::MagicMethodContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::MagicMethodContext::Get() {
  return getToken(PhpParser::Get, 0);
}

tree::TerminalNode* PhpParser::MagicMethodContext::Set() {
  return getToken(PhpParser::Set, 0);
}

tree::TerminalNode* PhpParser::MagicMethodContext::Call() {
  return getToken(PhpParser::Call, 0);
}

tree::TerminalNode* PhpParser::MagicMethodContext::CallStatic() {
  return getToken(PhpParser::CallStatic, 0);
}

tree::TerminalNode* PhpParser::MagicMethodContext::Constructor() {
  return getToken(PhpParser::Constructor, 0);
}

tree::TerminalNode* PhpParser::MagicMethodContext::Destruct() {
  return getToken(PhpParser::Destruct, 0);
}

tree::TerminalNode* PhpParser::MagicMethodContext::Wakeup() {
  return getToken(PhpParser::Wakeup, 0);
}

tree::TerminalNode* PhpParser::MagicMethodContext::Sleep() {
  return getToken(PhpParser::Sleep, 0);
}

tree::TerminalNode* PhpParser::MagicMethodContext::Autoload() {
  return getToken(PhpParser::Autoload, 0);
}

tree::TerminalNode* PhpParser::MagicMethodContext::IsSet__() {
  return getToken(PhpParser::IsSet__, 0);
}

tree::TerminalNode* PhpParser::MagicMethodContext::Unset__() {
  return getToken(PhpParser::Unset__, 0);
}

tree::TerminalNode* PhpParser::MagicMethodContext::ToString__() {
  return getToken(PhpParser::ToString__, 0);
}

tree::TerminalNode* PhpParser::MagicMethodContext::Invoke() {
  return getToken(PhpParser::Invoke, 0);
}

tree::TerminalNode* PhpParser::MagicMethodContext::SetState() {
  return getToken(PhpParser::SetState, 0);
}

tree::TerminalNode* PhpParser::MagicMethodContext::Clone__() {
  return getToken(PhpParser::Clone__, 0);
}

tree::TerminalNode* PhpParser::MagicMethodContext::DebugInfo() {
  return getToken(PhpParser::DebugInfo, 0);
}


size_t PhpParser::MagicMethodContext::getRuleIndex() const {
  return PhpParser::RuleMagicMethod;
}

void PhpParser::MagicMethodContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMagicMethod(this);
}

void PhpParser::MagicMethodContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMagicMethod(this);
}

PhpParser::MagicMethodContext* PhpParser::magicMethod() {
  MagicMethodContext *_localctx = _tracker.createInstance<MagicMethodContext>(_ctx, getState());
  enterRule(_localctx, 270, PhpParser::RuleMagicMethod);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1940);
    _la = _input->LA(1);
    if (!(((((_la - 137) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 137)) & 65535) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrimitiveTypeContext ------------------------------------------------------------------

PhpParser::PrimitiveTypeContext::PrimitiveTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::PrimitiveTypeContext::BoolType() {
  return getToken(PhpParser::BoolType, 0);
}

tree::TerminalNode* PhpParser::PrimitiveTypeContext::IntType() {
  return getToken(PhpParser::IntType, 0);
}

tree::TerminalNode* PhpParser::PrimitiveTypeContext::Int64Type() {
  return getToken(PhpParser::Int64Type, 0);
}

tree::TerminalNode* PhpParser::PrimitiveTypeContext::DoubleType() {
  return getToken(PhpParser::DoubleType, 0);
}

tree::TerminalNode* PhpParser::PrimitiveTypeContext::StringType() {
  return getToken(PhpParser::StringType, 0);
}

tree::TerminalNode* PhpParser::PrimitiveTypeContext::Resource() {
  return getToken(PhpParser::Resource, 0);
}

tree::TerminalNode* PhpParser::PrimitiveTypeContext::ObjectType() {
  return getToken(PhpParser::ObjectType, 0);
}

tree::TerminalNode* PhpParser::PrimitiveTypeContext::Array() {
  return getToken(PhpParser::Array, 0);
}


size_t PhpParser::PrimitiveTypeContext::getRuleIndex() const {
  return PhpParser::RulePrimitiveType;
}

void PhpParser::PrimitiveTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimitiveType(this);
}

void PhpParser::PrimitiveTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimitiveType(this);
}

PhpParser::PrimitiveTypeContext* PhpParser::primitiveType() {
  PrimitiveTypeContext *_localctx = _tracker.createInstance<PrimitiveTypeContext>(_ctx, getState());
  enterRule(_localctx, 272, PhpParser::RulePrimitiveType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1942);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4612002677776187392) != 0) || ((((_la - 94) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 94)) & 37752835) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CastOperationContext ------------------------------------------------------------------

PhpParser::CastOperationContext::CastOperationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PhpParser::CastOperationContext::BoolType() {
  return getToken(PhpParser::BoolType, 0);
}

tree::TerminalNode* PhpParser::CastOperationContext::Int8Cast() {
  return getToken(PhpParser::Int8Cast, 0);
}

tree::TerminalNode* PhpParser::CastOperationContext::Int16Cast() {
  return getToken(PhpParser::Int16Cast, 0);
}

tree::TerminalNode* PhpParser::CastOperationContext::IntType() {
  return getToken(PhpParser::IntType, 0);
}

tree::TerminalNode* PhpParser::CastOperationContext::Int64Type() {
  return getToken(PhpParser::Int64Type, 0);
}

tree::TerminalNode* PhpParser::CastOperationContext::UintCast() {
  return getToken(PhpParser::UintCast, 0);
}

tree::TerminalNode* PhpParser::CastOperationContext::DoubleCast() {
  return getToken(PhpParser::DoubleCast, 0);
}

tree::TerminalNode* PhpParser::CastOperationContext::DoubleType() {
  return getToken(PhpParser::DoubleType, 0);
}

tree::TerminalNode* PhpParser::CastOperationContext::FloatCast() {
  return getToken(PhpParser::FloatCast, 0);
}

tree::TerminalNode* PhpParser::CastOperationContext::StringType() {
  return getToken(PhpParser::StringType, 0);
}

tree::TerminalNode* PhpParser::CastOperationContext::BinaryCast() {
  return getToken(PhpParser::BinaryCast, 0);
}

tree::TerminalNode* PhpParser::CastOperationContext::UnicodeCast() {
  return getToken(PhpParser::UnicodeCast, 0);
}

tree::TerminalNode* PhpParser::CastOperationContext::Array() {
  return getToken(PhpParser::Array, 0);
}

tree::TerminalNode* PhpParser::CastOperationContext::ObjectType() {
  return getToken(PhpParser::ObjectType, 0);
}

tree::TerminalNode* PhpParser::CastOperationContext::Resource() {
  return getToken(PhpParser::Resource, 0);
}

tree::TerminalNode* PhpParser::CastOperationContext::Unset() {
  return getToken(PhpParser::Unset, 0);
}


size_t PhpParser::CastOperationContext::getRuleIndex() const {
  return PhpParser::RuleCastOperation;
}

void PhpParser::CastOperationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCastOperation(this);
}

void PhpParser::CastOperationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<PhpParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCastOperation(this);
}

PhpParser::CastOperationContext* PhpParser::castOperation() {
  CastOperationContext *_localctx = _tracker.createInstance<CastOperationContext>(_ctx, getState());
  enterRule(_localctx, 274, PhpParser::RuleCastOperation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1944);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917986424478236672) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 79)) & 493818294165505) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool PhpParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 59: return typeHintSempred(antlrcpp::downCast<TypeHintContext *>(context), predicateIndex);
    case 82: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool PhpParser::typeHintSempred(TypeHintContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool PhpParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return precpred(_ctx, 22);
    case 2: return precpred(_ctx, 20);
    case 3: return precpred(_ctx, 19);
    case 4: return precpred(_ctx, 18);
    case 5: return precpred(_ctx, 17);
    case 6: return precpred(_ctx, 16);
    case 7: return precpred(_ctx, 15);
    case 8: return precpred(_ctx, 14);
    case 9: return precpred(_ctx, 13);
    case 10: return precpred(_ctx, 12);
    case 11: return precpred(_ctx, 11);
    case 12: return precpred(_ctx, 10);
    case 13: return precpred(_ctx, 9);
    case 14: return precpred(_ctx, 8);
    case 15: return precpred(_ctx, 3);
    case 16: return precpred(_ctx, 2);
    case 17: return precpred(_ctx, 1);
    case 18: return precpred(_ctx, 21);

  default:
    break;
  }
  return true;
}

void PhpParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  phpparserParserInitialize();
#else
  ::antlr4::internal::call_once(phpparserParserOnceFlag, phpparserParserInitialize);
#endif
}

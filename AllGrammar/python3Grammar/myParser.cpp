
// Generated from my.g4 by ANTLR 4.11.1


#include "myListener.h"

#include "myParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct MyParserStaticData final {
  MyParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  MyParserStaticData(const MyParserStaticData&) = delete;
  MyParserStaticData(MyParserStaticData&&) = delete;
  MyParserStaticData& operator=(const MyParserStaticData&) = delete;
  MyParserStaticData& operator=(MyParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag myParserOnceFlag;
MyParserStaticData *myParserStaticData = nullptr;

void myParserInitialize() {
  assert(myParserStaticData == nullptr);
  auto staticData = std::make_unique<MyParserStaticData>(
    std::vector<std::string>{
      "single_input", "file_input", "eval_input", "decorator", "decorators", 
      "decorated", "async_funcdef", "funcdef", "parameters", "typedargslist", 
      "tfpdef", "varargslist", "vfpdef", "stmt", "simple_stmt", "small_stmt", 
      "expr_stmt", "annassign", "testlist_star_expr", "augassign", "del_stmt", 
      "pass_stmt", "flow_stmt", "break_stmt", "continue_stmt", "return_stmt", 
      "yield_stmt", "raise_stmt", "import_stmt", "import_name", "import_from", 
      "import_as_name", "dotted_as_name", "import_as_names", "dotted_as_names", 
      "dotted_name", "global_stmt", "nonlocal_stmt", "assert_stmt", "compound_stmt", 
      "async_stmt", "if_stmt", "while_stmt", "for_stmt", "try_stmt", "with_stmt", 
      "with_item", "except_clause", "suite", "test", "test_nocond", "lambdef", 
      "lambdef_nocond", "or_test", "and_test", "not_test", "comparison", 
      "comp_op", "star_expr", "expr", "xor_expr", "and_expr", "shift_expr", 
      "arith_expr", "term", "factor", "power", "atom_expr", "atom", "testlist_comp", 
      "trailer", "subscriptlist", "subscript", "sliceop", "exprlist", "testlist", 
      "dictorsetmaker", "classdef", "arglist", "argument", "comp_iter", 
      "comp_for", "comp_if", "encoding_decl", "yield_expr", "yield_arg"
    },
    std::vector<std::string>{
      "", "", "", "", "'def'", "'return'", "'raise'", "'from'", "'import'", 
      "'as'", "'global'", "'nonlocal'", "'assert'", "'if'", "'elif'", "'else'", 
      "'while'", "'for'", "'in'", "'try'", "'finally'", "'with'", "'except'", 
      "'lambda'", "'or'", "'and'", "'not'", "'is'", "'None'", "'True'", 
      "'False'", "'class'", "'yield'", "'del'", "'pass'", "'continue'", 
      "'break'", "'async'", "'await'", "", "", "", "", "", "", "", "", "", 
      "", "'.'", "'...'", "'*'", "'('", "')'", "','", "':'", "';'", "'**'", 
      "'='", "'['", "']'", "'|'", "'^'", "'&'", "'<<'", "'>>'", "'+'", "'-'", 
      "'/'", "'%'", "'//'", "'~'", "'{'", "'}'", "'<'", "'>'", "'=='", "'>='", 
      "'<='", "'<>'", "'!='", "'@'", "'->'", "'+='", "'-='", "'*='", "'@='", 
      "'/='", "'%='", "'&='", "'|='", "'^='", "'<<='", "'>>='", "'**='", 
      "'//='"
    },
    std::vector<std::string>{
      "", "STRING", "NUMBER", "INTEGER", "DEF", "RETURN", "RAISE", "FROM", 
      "IMPORT", "AS", "GLOBAL", "NONLOCAL", "ASSERT", "IF", "ELIF", "ELSE", 
      "WHILE", "FOR", "IN", "TRY", "FINALLY", "WITH", "EXCEPT", "LAMBDA", 
      "OR", "AND", "NOT", "IS", "NONE", "TRUE", "FALSE", "CLASS", "YIELD", 
      "DEL", "PASS", "CONTINUE", "BREAK", "ASYNC", "AWAIT", "NEWLINE", "NAME", 
      "STRING_LITERAL", "BYTES_LITERAL", "DECIMAL_INTEGER", "OCT_INTEGER", 
      "HEX_INTEGER", "BIN_INTEGER", "FLOAT_NUMBER", "IMAG_NUMBER", "DOT", 
      "ELLIPSIS", "STAR", "OPEN_PAREN", "CLOSE_PAREN", "COMMA", "COLON", 
      "SEMI_COLON", "POWER", "ASSIGN", "OPEN_BRACK", "CLOSE_BRACK", "OR_OP", 
      "XOR", "AND_OP", "LEFT_SHIFT", "RIGHT_SHIFT", "ADD", "MINUS", "DIV", 
      "MOD", "IDIV", "NOT_OP", "OPEN_BRACE", "CLOSE_BRACE", "LESS_THAN", 
      "GREATER_THAN", "EQUALS", "GT_EQ", "LT_EQ", "NOT_EQ_1", "NOT_EQ_2", 
      "AT", "ARROW", "ADD_ASSIGN", "SUB_ASSIGN", "MULT_ASSIGN", "AT_ASSIGN", 
      "DIV_ASSIGN", "MOD_ASSIGN", "AND_ASSIGN", "OR_ASSIGN", "XOR_ASSIGN", 
      "LEFT_SHIFT_ASSIGN", "RIGHT_SHIFT_ASSIGN", "POWER_ASSIGN", "IDIV_ASSIGN", 
      "SKIP_", "UNKNOWN_CHAR", "INDENT", "DEDENT"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,99,1104,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
  	14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
  	21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
  	28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,
  	35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,
  	42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,
  	49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,
  	56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,
  	63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,
  	70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,
  	77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,
  	84,2,85,7,85,1,0,1,0,1,0,1,0,1,0,3,0,178,8,0,1,1,1,1,5,1,182,8,1,10,1,
  	12,1,185,9,1,1,1,1,1,1,2,1,2,5,2,191,8,2,10,2,12,2,194,9,2,1,2,1,2,1,
  	3,1,3,1,3,1,3,3,3,202,8,3,1,3,3,3,205,8,3,1,3,1,3,1,4,4,4,210,8,4,11,
  	4,12,4,211,1,5,1,5,1,5,1,5,3,5,218,8,5,1,6,1,6,1,6,1,7,1,7,1,7,1,7,1,
  	7,3,7,228,8,7,1,7,1,7,1,7,1,8,1,8,3,8,235,8,8,1,8,1,8,1,9,1,9,1,9,3,9,
  	242,8,9,1,9,1,9,1,9,1,9,3,9,248,8,9,5,9,250,8,9,10,9,12,9,253,9,9,1,9,
  	1,9,1,9,3,9,258,8,9,1,9,1,9,1,9,1,9,3,9,264,8,9,5,9,266,8,9,10,9,12,9,
  	269,9,9,1,9,1,9,1,9,1,9,3,9,275,8,9,3,9,277,8,9,3,9,279,8,9,1,9,1,9,1,
  	9,3,9,284,8,9,3,9,286,8,9,3,9,288,8,9,1,9,1,9,3,9,292,8,9,1,9,1,9,1,9,
  	1,9,3,9,298,8,9,5,9,300,8,9,10,9,12,9,303,9,9,1,9,1,9,1,9,1,9,3,9,309,
  	8,9,3,9,311,8,9,3,9,313,8,9,1,9,1,9,1,9,3,9,318,8,9,3,9,320,8,9,1,10,
  	1,10,1,10,3,10,325,8,10,1,11,1,11,1,11,3,11,330,8,11,1,11,1,11,1,11,1,
  	11,3,11,336,8,11,5,11,338,8,11,10,11,12,11,341,9,11,1,11,1,11,1,11,3,
  	11,346,8,11,1,11,1,11,1,11,1,11,3,11,352,8,11,5,11,354,8,11,10,11,12,
  	11,357,9,11,1,11,1,11,1,11,1,11,3,11,363,8,11,3,11,365,8,11,3,11,367,
  	8,11,1,11,1,11,1,11,3,11,372,8,11,3,11,374,8,11,3,11,376,8,11,1,11,1,
  	11,3,11,380,8,11,1,11,1,11,1,11,1,11,3,11,386,8,11,5,11,388,8,11,10,11,
  	12,11,391,9,11,1,11,1,11,1,11,1,11,3,11,397,8,11,3,11,399,8,11,3,11,401,
  	8,11,1,11,1,11,1,11,3,11,406,8,11,3,11,408,8,11,1,12,1,12,1,13,1,13,3,
  	13,414,8,13,1,14,1,14,1,14,5,14,419,8,14,10,14,12,14,422,9,14,1,14,3,
  	14,425,8,14,1,14,1,14,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,3,15,437,
  	8,15,1,16,1,16,1,16,1,16,1,16,3,16,444,8,16,1,16,1,16,1,16,3,16,449,8,
  	16,5,16,451,8,16,10,16,12,16,454,9,16,3,16,456,8,16,1,17,1,17,1,17,1,
  	17,3,17,462,8,17,1,18,1,18,3,18,466,8,18,1,18,1,18,1,18,3,18,471,8,18,
  	5,18,473,8,18,10,18,12,18,476,9,18,1,18,3,18,479,8,18,1,19,1,19,1,20,
  	1,20,1,20,1,21,1,21,1,22,1,22,1,22,1,22,1,22,3,22,493,8,22,1,23,1,23,
  	1,24,1,24,1,25,1,25,3,25,501,8,25,1,26,1,26,1,27,1,27,1,27,1,27,3,27,
  	509,8,27,3,27,511,8,27,1,28,1,28,3,28,515,8,28,1,29,1,29,1,29,1,30,1,
  	30,5,30,522,8,30,10,30,12,30,525,9,30,1,30,1,30,4,30,529,8,30,11,30,12,
  	30,530,3,30,533,8,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,3,30,542,8,30,
  	1,31,1,31,1,31,3,31,547,8,31,1,32,1,32,1,32,3,32,552,8,32,1,33,1,33,1,
  	33,5,33,557,8,33,10,33,12,33,560,9,33,1,33,3,33,563,8,33,1,34,1,34,1,
  	34,5,34,568,8,34,10,34,12,34,571,9,34,1,35,1,35,1,35,5,35,576,8,35,10,
  	35,12,35,579,9,35,1,36,1,36,1,36,1,36,5,36,585,8,36,10,36,12,36,588,9,
  	36,1,37,1,37,1,37,1,37,5,37,594,8,37,10,37,12,37,597,9,37,1,38,1,38,1,
  	38,1,38,3,38,603,8,38,1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,3,
  	39,614,8,39,1,40,1,40,1,40,1,40,3,40,620,8,40,1,41,1,41,1,41,1,41,1,41,
  	1,41,1,41,1,41,1,41,5,41,631,8,41,10,41,12,41,634,9,41,1,41,1,41,1,41,
  	3,41,639,8,41,1,42,1,42,1,42,1,42,1,42,1,42,1,42,3,42,648,8,42,1,43,1,
  	43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,3,43,659,8,43,1,44,1,44,1,44,1,
  	44,1,44,1,44,1,44,4,44,668,8,44,11,44,12,44,669,1,44,1,44,1,44,3,44,675,
  	8,44,1,44,1,44,1,44,3,44,680,8,44,1,44,1,44,1,44,3,44,685,8,44,1,45,1,
  	45,1,45,1,45,5,45,691,8,45,10,45,12,45,694,9,45,1,45,1,45,1,45,1,46,1,
  	46,1,46,3,46,702,8,46,1,47,1,47,1,47,1,47,3,47,708,8,47,3,47,710,8,47,
  	1,48,1,48,1,48,1,48,4,48,716,8,48,11,48,12,48,717,1,48,1,48,3,48,722,
  	8,48,1,49,1,49,1,49,1,49,1,49,1,49,3,49,730,8,49,1,49,3,49,733,8,49,1,
  	50,1,50,3,50,737,8,50,1,51,1,51,3,51,741,8,51,1,51,1,51,1,51,1,52,1,52,
  	3,52,748,8,52,1,52,1,52,1,52,1,53,1,53,1,53,5,53,756,8,53,10,53,12,53,
  	759,9,53,1,54,1,54,1,54,5,54,764,8,54,10,54,12,54,767,9,54,1,55,1,55,
  	1,55,3,55,772,8,55,1,56,1,56,1,56,1,56,5,56,778,8,56,10,56,12,56,781,
  	9,56,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,
  	3,57,796,8,57,1,58,1,58,1,58,1,59,1,59,1,59,5,59,804,8,59,10,59,12,59,
  	807,9,59,1,60,1,60,1,60,5,60,812,8,60,10,60,12,60,815,9,60,1,61,1,61,
  	1,61,5,61,820,8,61,10,61,12,61,823,9,61,1,62,1,62,1,62,5,62,828,8,62,
  	10,62,12,62,831,9,62,1,63,1,63,1,63,5,63,836,8,63,10,63,12,63,839,9,63,
  	1,64,1,64,1,64,5,64,844,8,64,10,64,12,64,847,9,64,1,65,1,65,1,65,3,65,
  	852,8,65,1,66,1,66,1,66,3,66,857,8,66,1,67,3,67,860,8,67,1,67,1,67,5,
  	67,864,8,67,10,67,12,67,867,9,67,1,68,1,68,1,68,3,68,872,8,68,1,68,1,
  	68,1,68,3,68,877,8,68,1,68,1,68,1,68,3,68,882,8,68,1,68,1,68,1,68,1,68,
  	4,68,888,8,68,11,68,12,68,889,1,68,1,68,1,68,1,68,3,68,896,8,68,1,69,
  	1,69,3,69,900,8,69,1,69,1,69,1,69,1,69,3,69,906,8,69,5,69,908,8,69,10,
  	69,12,69,911,9,69,1,69,3,69,914,8,69,3,69,916,8,69,1,70,1,70,3,70,920,
  	8,70,1,70,1,70,1,70,1,70,1,70,1,70,1,70,3,70,929,8,70,1,71,1,71,1,71,
  	5,71,934,8,71,10,71,12,71,937,9,71,1,71,3,71,940,8,71,1,72,1,72,3,72,
  	944,8,72,1,72,1,72,3,72,948,8,72,1,72,3,72,951,8,72,3,72,953,8,72,1,73,
  	1,73,3,73,957,8,73,1,74,1,74,3,74,961,8,74,1,74,1,74,1,74,3,74,966,8,
  	74,5,74,968,8,74,10,74,12,74,971,9,74,1,74,3,74,974,8,74,1,75,1,75,1,
  	75,5,75,979,8,75,10,75,12,75,982,9,75,1,75,3,75,985,8,75,1,76,1,76,1,
  	76,1,76,1,76,1,76,3,76,993,8,76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,1,
  	76,3,76,1003,8,76,5,76,1005,8,76,10,76,12,76,1008,9,76,1,76,3,76,1011,
  	8,76,3,76,1013,8,76,1,76,1,76,3,76,1017,8,76,1,76,1,76,1,76,1,76,3,76,
  	1023,8,76,5,76,1025,8,76,10,76,12,76,1028,9,76,1,76,3,76,1031,8,76,3,
  	76,1033,8,76,3,76,1035,8,76,1,77,1,77,1,77,1,77,3,77,1041,8,77,1,77,3,
  	77,1044,8,77,1,77,1,77,1,77,1,78,1,78,1,78,5,78,1052,8,78,10,78,12,78,
  	1055,9,78,1,78,3,78,1058,8,78,1,79,1,79,3,79,1062,8,79,1,79,1,79,1,79,
  	1,79,1,79,1,79,1,79,1,79,3,79,1072,8,79,1,80,1,80,3,80,1076,8,80,1,81,
  	3,81,1079,8,81,1,81,1,81,1,81,1,81,1,81,3,81,1086,8,81,1,82,1,82,1,82,
  	3,82,1091,8,82,1,83,1,83,1,84,1,84,3,84,1097,8,84,1,85,1,85,1,85,3,85,
  	1102,8,85,1,85,0,0,86,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,
  	36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,
  	82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,
  	122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,
  	158,160,162,164,166,168,170,0,6,1,0,83,95,1,0,49,50,1,0,64,65,1,0,66,
  	67,3,0,51,51,68,70,81,81,2,0,66,67,71,71,1229,0,177,1,0,0,0,2,183,1,0,
  	0,0,4,188,1,0,0,0,6,197,1,0,0,0,8,209,1,0,0,0,10,213,1,0,0,0,12,219,1,
  	0,0,0,14,222,1,0,0,0,16,232,1,0,0,0,18,319,1,0,0,0,20,321,1,0,0,0,22,
  	407,1,0,0,0,24,409,1,0,0,0,26,413,1,0,0,0,28,415,1,0,0,0,30,436,1,0,0,
  	0,32,438,1,0,0,0,34,457,1,0,0,0,36,465,1,0,0,0,38,480,1,0,0,0,40,482,
  	1,0,0,0,42,485,1,0,0,0,44,492,1,0,0,0,46,494,1,0,0,0,48,496,1,0,0,0,50,
  	498,1,0,0,0,52,502,1,0,0,0,54,504,1,0,0,0,56,514,1,0,0,0,58,516,1,0,0,
  	0,60,519,1,0,0,0,62,543,1,0,0,0,64,548,1,0,0,0,66,553,1,0,0,0,68,564,
  	1,0,0,0,70,572,1,0,0,0,72,580,1,0,0,0,74,589,1,0,0,0,76,598,1,0,0,0,78,
  	613,1,0,0,0,80,615,1,0,0,0,82,621,1,0,0,0,84,640,1,0,0,0,86,649,1,0,0,
  	0,88,660,1,0,0,0,90,686,1,0,0,0,92,698,1,0,0,0,94,703,1,0,0,0,96,721,
  	1,0,0,0,98,732,1,0,0,0,100,736,1,0,0,0,102,738,1,0,0,0,104,745,1,0,0,
  	0,106,752,1,0,0,0,108,760,1,0,0,0,110,771,1,0,0,0,112,773,1,0,0,0,114,
  	795,1,0,0,0,116,797,1,0,0,0,118,800,1,0,0,0,120,808,1,0,0,0,122,816,1,
  	0,0,0,124,824,1,0,0,0,126,832,1,0,0,0,128,840,1,0,0,0,130,851,1,0,0,0,
  	132,853,1,0,0,0,134,859,1,0,0,0,136,895,1,0,0,0,138,899,1,0,0,0,140,928,
  	1,0,0,0,142,930,1,0,0,0,144,952,1,0,0,0,146,954,1,0,0,0,148,960,1,0,0,
  	0,150,975,1,0,0,0,152,1034,1,0,0,0,154,1036,1,0,0,0,156,1048,1,0,0,0,
  	158,1071,1,0,0,0,160,1075,1,0,0,0,162,1078,1,0,0,0,164,1087,1,0,0,0,166,
  	1092,1,0,0,0,168,1094,1,0,0,0,170,1101,1,0,0,0,172,178,5,39,0,0,173,178,
  	3,28,14,0,174,175,3,78,39,0,175,176,5,39,0,0,176,178,1,0,0,0,177,172,
  	1,0,0,0,177,173,1,0,0,0,177,174,1,0,0,0,178,1,1,0,0,0,179,182,5,39,0,
  	0,180,182,3,26,13,0,181,179,1,0,0,0,181,180,1,0,0,0,182,185,1,0,0,0,183,
  	181,1,0,0,0,183,184,1,0,0,0,184,186,1,0,0,0,185,183,1,0,0,0,186,187,5,
  	0,0,1,187,3,1,0,0,0,188,192,3,150,75,0,189,191,5,39,0,0,190,189,1,0,0,
  	0,191,194,1,0,0,0,192,190,1,0,0,0,192,193,1,0,0,0,193,195,1,0,0,0,194,
  	192,1,0,0,0,195,196,5,0,0,1,196,5,1,0,0,0,197,198,5,81,0,0,198,204,3,
  	70,35,0,199,201,5,52,0,0,200,202,3,156,78,0,201,200,1,0,0,0,201,202,1,
  	0,0,0,202,203,1,0,0,0,203,205,5,53,0,0,204,199,1,0,0,0,204,205,1,0,0,
  	0,205,206,1,0,0,0,206,207,5,39,0,0,207,7,1,0,0,0,208,210,3,6,3,0,209,
  	208,1,0,0,0,210,211,1,0,0,0,211,209,1,0,0,0,211,212,1,0,0,0,212,9,1,0,
  	0,0,213,217,3,8,4,0,214,218,3,154,77,0,215,218,3,14,7,0,216,218,3,12,
  	6,0,217,214,1,0,0,0,217,215,1,0,0,0,217,216,1,0,0,0,218,11,1,0,0,0,219,
  	220,5,37,0,0,220,221,3,14,7,0,221,13,1,0,0,0,222,223,5,4,0,0,223,224,
  	5,40,0,0,224,227,3,16,8,0,225,226,5,82,0,0,226,228,3,98,49,0,227,225,
  	1,0,0,0,227,228,1,0,0,0,228,229,1,0,0,0,229,230,5,55,0,0,230,231,3,96,
  	48,0,231,15,1,0,0,0,232,234,5,52,0,0,233,235,3,18,9,0,234,233,1,0,0,0,
  	234,235,1,0,0,0,235,236,1,0,0,0,236,237,5,53,0,0,237,17,1,0,0,0,238,241,
  	3,20,10,0,239,240,5,58,0,0,240,242,3,98,49,0,241,239,1,0,0,0,241,242,
  	1,0,0,0,242,251,1,0,0,0,243,244,5,54,0,0,244,247,3,20,10,0,245,246,5,
  	58,0,0,246,248,3,98,49,0,247,245,1,0,0,0,247,248,1,0,0,0,248,250,1,0,
  	0,0,249,243,1,0,0,0,250,253,1,0,0,0,251,249,1,0,0,0,251,252,1,0,0,0,252,
  	287,1,0,0,0,253,251,1,0,0,0,254,285,5,54,0,0,255,257,5,51,0,0,256,258,
  	3,20,10,0,257,256,1,0,0,0,257,258,1,0,0,0,258,267,1,0,0,0,259,260,5,54,
  	0,0,260,263,3,20,10,0,261,262,5,58,0,0,262,264,3,98,49,0,263,261,1,0,
  	0,0,263,264,1,0,0,0,264,266,1,0,0,0,265,259,1,0,0,0,266,269,1,0,0,0,267,
  	265,1,0,0,0,267,268,1,0,0,0,268,278,1,0,0,0,269,267,1,0,0,0,270,276,5,
  	54,0,0,271,272,5,57,0,0,272,274,3,20,10,0,273,275,5,54,0,0,274,273,1,
  	0,0,0,274,275,1,0,0,0,275,277,1,0,0,0,276,271,1,0,0,0,276,277,1,0,0,0,
  	277,279,1,0,0,0,278,270,1,0,0,0,278,279,1,0,0,0,279,286,1,0,0,0,280,281,
  	5,57,0,0,281,283,3,20,10,0,282,284,5,54,0,0,283,282,1,0,0,0,283,284,1,
  	0,0,0,284,286,1,0,0,0,285,255,1,0,0,0,285,280,1,0,0,0,285,286,1,0,0,0,
  	286,288,1,0,0,0,287,254,1,0,0,0,287,288,1,0,0,0,288,320,1,0,0,0,289,291,
  	5,51,0,0,290,292,3,20,10,0,291,290,1,0,0,0,291,292,1,0,0,0,292,301,1,
  	0,0,0,293,294,5,54,0,0,294,297,3,20,10,0,295,296,5,58,0,0,296,298,3,98,
  	49,0,297,295,1,0,0,0,297,298,1,0,0,0,298,300,1,0,0,0,299,293,1,0,0,0,
  	300,303,1,0,0,0,301,299,1,0,0,0,301,302,1,0,0,0,302,312,1,0,0,0,303,301,
  	1,0,0,0,304,310,5,54,0,0,305,306,5,57,0,0,306,308,3,20,10,0,307,309,5,
  	54,0,0,308,307,1,0,0,0,308,309,1,0,0,0,309,311,1,0,0,0,310,305,1,0,0,
  	0,310,311,1,0,0,0,311,313,1,0,0,0,312,304,1,0,0,0,312,313,1,0,0,0,313,
  	320,1,0,0,0,314,315,5,57,0,0,315,317,3,20,10,0,316,318,5,54,0,0,317,316,
  	1,0,0,0,317,318,1,0,0,0,318,320,1,0,0,0,319,238,1,0,0,0,319,289,1,0,0,
  	0,319,314,1,0,0,0,320,19,1,0,0,0,321,324,5,40,0,0,322,323,5,55,0,0,323,
  	325,3,98,49,0,324,322,1,0,0,0,324,325,1,0,0,0,325,21,1,0,0,0,326,329,
  	3,24,12,0,327,328,5,58,0,0,328,330,3,98,49,0,329,327,1,0,0,0,329,330,
  	1,0,0,0,330,339,1,0,0,0,331,332,5,54,0,0,332,335,3,24,12,0,333,334,5,
  	58,0,0,334,336,3,98,49,0,335,333,1,0,0,0,335,336,1,0,0,0,336,338,1,0,
  	0,0,337,331,1,0,0,0,338,341,1,0,0,0,339,337,1,0,0,0,339,340,1,0,0,0,340,
  	375,1,0,0,0,341,339,1,0,0,0,342,373,5,54,0,0,343,345,5,51,0,0,344,346,
  	3,24,12,0,345,344,1,0,0,0,345,346,1,0,0,0,346,355,1,0,0,0,347,348,5,54,
  	0,0,348,351,3,24,12,0,349,350,5,58,0,0,350,352,3,98,49,0,351,349,1,0,
  	0,0,351,352,1,0,0,0,352,354,1,0,0,0,353,347,1,0,0,0,354,357,1,0,0,0,355,
  	353,1,0,0,0,355,356,1,0,0,0,356,366,1,0,0,0,357,355,1,0,0,0,358,364,5,
  	54,0,0,359,360,5,57,0,0,360,362,3,24,12,0,361,363,5,54,0,0,362,361,1,
  	0,0,0,362,363,1,0,0,0,363,365,1,0,0,0,364,359,1,0,0,0,364,365,1,0,0,0,
  	365,367,1,0,0,0,366,358,1,0,0,0,366,367,1,0,0,0,367,374,1,0,0,0,368,369,
  	5,57,0,0,369,371,3,24,12,0,370,372,5,54,0,0,371,370,1,0,0,0,371,372,1,
  	0,0,0,372,374,1,0,0,0,373,343,1,0,0,0,373,368,1,0,0,0,373,374,1,0,0,0,
  	374,376,1,0,0,0,375,342,1,0,0,0,375,376,1,0,0,0,376,408,1,0,0,0,377,379,
  	5,51,0,0,378,380,3,24,12,0,379,378,1,0,0,0,379,380,1,0,0,0,380,389,1,
  	0,0,0,381,382,5,54,0,0,382,385,3,24,12,0,383,384,5,58,0,0,384,386,3,98,
  	49,0,385,383,1,0,0,0,385,386,1,0,0,0,386,388,1,0,0,0,387,381,1,0,0,0,
  	388,391,1,0,0,0,389,387,1,0,0,0,389,390,1,0,0,0,390,400,1,0,0,0,391,389,
  	1,0,0,0,392,398,5,54,0,0,393,394,5,57,0,0,394,396,3,24,12,0,395,397,5,
  	54,0,0,396,395,1,0,0,0,396,397,1,0,0,0,397,399,1,0,0,0,398,393,1,0,0,
  	0,398,399,1,0,0,0,399,401,1,0,0,0,400,392,1,0,0,0,400,401,1,0,0,0,401,
  	408,1,0,0,0,402,403,5,57,0,0,403,405,3,24,12,0,404,406,5,54,0,0,405,404,
  	1,0,0,0,405,406,1,0,0,0,406,408,1,0,0,0,407,326,1,0,0,0,407,377,1,0,0,
  	0,407,402,1,0,0,0,408,23,1,0,0,0,409,410,5,40,0,0,410,25,1,0,0,0,411,
  	414,3,28,14,0,412,414,3,78,39,0,413,411,1,0,0,0,413,412,1,0,0,0,414,27,
  	1,0,0,0,415,420,3,30,15,0,416,417,5,56,0,0,417,419,3,30,15,0,418,416,
  	1,0,0,0,419,422,1,0,0,0,420,418,1,0,0,0,420,421,1,0,0,0,421,424,1,0,0,
  	0,422,420,1,0,0,0,423,425,5,56,0,0,424,423,1,0,0,0,424,425,1,0,0,0,425,
  	426,1,0,0,0,426,427,5,39,0,0,427,29,1,0,0,0,428,437,3,32,16,0,429,437,
  	3,40,20,0,430,437,3,42,21,0,431,437,3,44,22,0,432,437,3,56,28,0,433,437,
  	3,72,36,0,434,437,3,74,37,0,435,437,3,76,38,0,436,428,1,0,0,0,436,429,
  	1,0,0,0,436,430,1,0,0,0,436,431,1,0,0,0,436,432,1,0,0,0,436,433,1,0,0,
  	0,436,434,1,0,0,0,436,435,1,0,0,0,437,31,1,0,0,0,438,455,3,36,18,0,439,
  	456,3,34,17,0,440,443,3,38,19,0,441,444,3,168,84,0,442,444,3,150,75,0,
  	443,441,1,0,0,0,443,442,1,0,0,0,444,456,1,0,0,0,445,448,5,58,0,0,446,
  	449,3,168,84,0,447,449,3,36,18,0,448,446,1,0,0,0,448,447,1,0,0,0,449,
  	451,1,0,0,0,450,445,1,0,0,0,451,454,1,0,0,0,452,450,1,0,0,0,452,453,1,
  	0,0,0,453,456,1,0,0,0,454,452,1,0,0,0,455,439,1,0,0,0,455,440,1,0,0,0,
  	455,452,1,0,0,0,456,33,1,0,0,0,457,458,5,55,0,0,458,461,3,98,49,0,459,
  	460,5,58,0,0,460,462,3,98,49,0,461,459,1,0,0,0,461,462,1,0,0,0,462,35,
  	1,0,0,0,463,466,3,98,49,0,464,466,3,116,58,0,465,463,1,0,0,0,465,464,
  	1,0,0,0,466,474,1,0,0,0,467,470,5,54,0,0,468,471,3,98,49,0,469,471,3,
  	116,58,0,470,468,1,0,0,0,470,469,1,0,0,0,471,473,1,0,0,0,472,467,1,0,
  	0,0,473,476,1,0,0,0,474,472,1,0,0,0,474,475,1,0,0,0,475,478,1,0,0,0,476,
  	474,1,0,0,0,477,479,5,54,0,0,478,477,1,0,0,0,478,479,1,0,0,0,479,37,1,
  	0,0,0,480,481,7,0,0,0,481,39,1,0,0,0,482,483,5,33,0,0,483,484,3,148,74,
  	0,484,41,1,0,0,0,485,486,5,34,0,0,486,43,1,0,0,0,487,493,3,46,23,0,488,
  	493,3,48,24,0,489,493,3,50,25,0,490,493,3,54,27,0,491,493,3,52,26,0,492,
  	487,1,0,0,0,492,488,1,0,0,0,492,489,1,0,0,0,492,490,1,0,0,0,492,491,1,
  	0,0,0,493,45,1,0,0,0,494,495,5,36,0,0,495,47,1,0,0,0,496,497,5,35,0,0,
  	497,49,1,0,0,0,498,500,5,5,0,0,499,501,3,150,75,0,500,499,1,0,0,0,500,
  	501,1,0,0,0,501,51,1,0,0,0,502,503,3,168,84,0,503,53,1,0,0,0,504,510,
  	5,6,0,0,505,508,3,98,49,0,506,507,5,7,0,0,507,509,3,98,49,0,508,506,1,
  	0,0,0,508,509,1,0,0,0,509,511,1,0,0,0,510,505,1,0,0,0,510,511,1,0,0,0,
  	511,55,1,0,0,0,512,515,3,58,29,0,513,515,3,60,30,0,514,512,1,0,0,0,514,
  	513,1,0,0,0,515,57,1,0,0,0,516,517,5,8,0,0,517,518,3,68,34,0,518,59,1,
  	0,0,0,519,532,5,7,0,0,520,522,7,1,0,0,521,520,1,0,0,0,522,525,1,0,0,0,
  	523,521,1,0,0,0,523,524,1,0,0,0,524,526,1,0,0,0,525,523,1,0,0,0,526,533,
  	3,70,35,0,527,529,7,1,0,0,528,527,1,0,0,0,529,530,1,0,0,0,530,528,1,0,
  	0,0,530,531,1,0,0,0,531,533,1,0,0,0,532,523,1,0,0,0,532,528,1,0,0,0,533,
  	534,1,0,0,0,534,541,5,8,0,0,535,542,5,51,0,0,536,537,5,52,0,0,537,538,
  	3,66,33,0,538,539,5,53,0,0,539,542,1,0,0,0,540,542,3,66,33,0,541,535,
  	1,0,0,0,541,536,1,0,0,0,541,540,1,0,0,0,542,61,1,0,0,0,543,546,5,40,0,
  	0,544,545,5,9,0,0,545,547,5,40,0,0,546,544,1,0,0,0,546,547,1,0,0,0,547,
  	63,1,0,0,0,548,551,3,70,35,0,549,550,5,9,0,0,550,552,5,40,0,0,551,549,
  	1,0,0,0,551,552,1,0,0,0,552,65,1,0,0,0,553,558,3,62,31,0,554,555,5,54,
  	0,0,555,557,3,62,31,0,556,554,1,0,0,0,557,560,1,0,0,0,558,556,1,0,0,0,
  	558,559,1,0,0,0,559,562,1,0,0,0,560,558,1,0,0,0,561,563,5,54,0,0,562,
  	561,1,0,0,0,562,563,1,0,0,0,563,67,1,0,0,0,564,569,3,64,32,0,565,566,
  	5,54,0,0,566,568,3,64,32,0,567,565,1,0,0,0,568,571,1,0,0,0,569,567,1,
  	0,0,0,569,570,1,0,0,0,570,69,1,0,0,0,571,569,1,0,0,0,572,577,5,40,0,0,
  	573,574,5,49,0,0,574,576,5,40,0,0,575,573,1,0,0,0,576,579,1,0,0,0,577,
  	575,1,0,0,0,577,578,1,0,0,0,578,71,1,0,0,0,579,577,1,0,0,0,580,581,5,
  	10,0,0,581,586,5,40,0,0,582,583,5,54,0,0,583,585,5,40,0,0,584,582,1,0,
  	0,0,585,588,1,0,0,0,586,584,1,0,0,0,586,587,1,0,0,0,587,73,1,0,0,0,588,
  	586,1,0,0,0,589,590,5,11,0,0,590,595,5,40,0,0,591,592,5,54,0,0,592,594,
  	5,40,0,0,593,591,1,0,0,0,594,597,1,0,0,0,595,593,1,0,0,0,595,596,1,0,
  	0,0,596,75,1,0,0,0,597,595,1,0,0,0,598,599,5,12,0,0,599,602,3,98,49,0,
  	600,601,5,54,0,0,601,603,3,98,49,0,602,600,1,0,0,0,602,603,1,0,0,0,603,
  	77,1,0,0,0,604,614,3,82,41,0,605,614,3,84,42,0,606,614,3,86,43,0,607,
  	614,3,88,44,0,608,614,3,90,45,0,609,614,3,14,7,0,610,614,3,154,77,0,611,
  	614,3,10,5,0,612,614,3,80,40,0,613,604,1,0,0,0,613,605,1,0,0,0,613,606,
  	1,0,0,0,613,607,1,0,0,0,613,608,1,0,0,0,613,609,1,0,0,0,613,610,1,0,0,
  	0,613,611,1,0,0,0,613,612,1,0,0,0,614,79,1,0,0,0,615,619,5,37,0,0,616,
  	620,3,14,7,0,617,620,3,90,45,0,618,620,3,86,43,0,619,616,1,0,0,0,619,
  	617,1,0,0,0,619,618,1,0,0,0,620,81,1,0,0,0,621,622,5,13,0,0,622,623,3,
  	98,49,0,623,624,5,55,0,0,624,632,3,96,48,0,625,626,5,14,0,0,626,627,3,
  	98,49,0,627,628,5,55,0,0,628,629,3,96,48,0,629,631,1,0,0,0,630,625,1,
  	0,0,0,631,634,1,0,0,0,632,630,1,0,0,0,632,633,1,0,0,0,633,638,1,0,0,0,
  	634,632,1,0,0,0,635,636,5,15,0,0,636,637,5,55,0,0,637,639,3,96,48,0,638,
  	635,1,0,0,0,638,639,1,0,0,0,639,83,1,0,0,0,640,641,5,16,0,0,641,642,3,
  	98,49,0,642,643,5,55,0,0,643,647,3,96,48,0,644,645,5,15,0,0,645,646,5,
  	55,0,0,646,648,3,96,48,0,647,644,1,0,0,0,647,648,1,0,0,0,648,85,1,0,0,
  	0,649,650,5,17,0,0,650,651,3,148,74,0,651,652,5,18,0,0,652,653,3,150,
  	75,0,653,654,5,55,0,0,654,658,3,96,48,0,655,656,5,15,0,0,656,657,5,55,
  	0,0,657,659,3,96,48,0,658,655,1,0,0,0,658,659,1,0,0,0,659,87,1,0,0,0,
  	660,661,5,19,0,0,661,662,5,55,0,0,662,684,3,96,48,0,663,664,3,94,47,0,
  	664,665,5,55,0,0,665,666,3,96,48,0,666,668,1,0,0,0,667,663,1,0,0,0,668,
  	669,1,0,0,0,669,667,1,0,0,0,669,670,1,0,0,0,670,674,1,0,0,0,671,672,5,
  	15,0,0,672,673,5,55,0,0,673,675,3,96,48,0,674,671,1,0,0,0,674,675,1,0,
  	0,0,675,679,1,0,0,0,676,677,5,20,0,0,677,678,5,55,0,0,678,680,3,96,48,
  	0,679,676,1,0,0,0,679,680,1,0,0,0,680,685,1,0,0,0,681,682,5,20,0,0,682,
  	683,5,55,0,0,683,685,3,96,48,0,684,667,1,0,0,0,684,681,1,0,0,0,685,89,
  	1,0,0,0,686,687,5,21,0,0,687,692,3,92,46,0,688,689,5,54,0,0,689,691,3,
  	92,46,0,690,688,1,0,0,0,691,694,1,0,0,0,692,690,1,0,0,0,692,693,1,0,0,
  	0,693,695,1,0,0,0,694,692,1,0,0,0,695,696,5,55,0,0,696,697,3,96,48,0,
  	697,91,1,0,0,0,698,701,3,98,49,0,699,700,5,9,0,0,700,702,3,118,59,0,701,
  	699,1,0,0,0,701,702,1,0,0,0,702,93,1,0,0,0,703,709,5,22,0,0,704,707,3,
  	98,49,0,705,706,5,9,0,0,706,708,5,40,0,0,707,705,1,0,0,0,707,708,1,0,
  	0,0,708,710,1,0,0,0,709,704,1,0,0,0,709,710,1,0,0,0,710,95,1,0,0,0,711,
  	722,3,28,14,0,712,713,5,39,0,0,713,715,5,98,0,0,714,716,3,26,13,0,715,
  	714,1,0,0,0,716,717,1,0,0,0,717,715,1,0,0,0,717,718,1,0,0,0,718,719,1,
  	0,0,0,719,720,5,99,0,0,720,722,1,0,0,0,721,711,1,0,0,0,721,712,1,0,0,
  	0,722,97,1,0,0,0,723,729,3,106,53,0,724,725,5,13,0,0,725,726,3,106,53,
  	0,726,727,5,15,0,0,727,728,3,98,49,0,728,730,1,0,0,0,729,724,1,0,0,0,
  	729,730,1,0,0,0,730,733,1,0,0,0,731,733,3,102,51,0,732,723,1,0,0,0,732,
  	731,1,0,0,0,733,99,1,0,0,0,734,737,3,106,53,0,735,737,3,104,52,0,736,
  	734,1,0,0,0,736,735,1,0,0,0,737,101,1,0,0,0,738,740,5,23,0,0,739,741,
  	3,22,11,0,740,739,1,0,0,0,740,741,1,0,0,0,741,742,1,0,0,0,742,743,5,55,
  	0,0,743,744,3,98,49,0,744,103,1,0,0,0,745,747,5,23,0,0,746,748,3,22,11,
  	0,747,746,1,0,0,0,747,748,1,0,0,0,748,749,1,0,0,0,749,750,5,55,0,0,750,
  	751,3,100,50,0,751,105,1,0,0,0,752,757,3,108,54,0,753,754,5,24,0,0,754,
  	756,3,108,54,0,755,753,1,0,0,0,756,759,1,0,0,0,757,755,1,0,0,0,757,758,
  	1,0,0,0,758,107,1,0,0,0,759,757,1,0,0,0,760,765,3,110,55,0,761,762,5,
  	25,0,0,762,764,3,110,55,0,763,761,1,0,0,0,764,767,1,0,0,0,765,763,1,0,
  	0,0,765,766,1,0,0,0,766,109,1,0,0,0,767,765,1,0,0,0,768,769,5,26,0,0,
  	769,772,3,110,55,0,770,772,3,112,56,0,771,768,1,0,0,0,771,770,1,0,0,0,
  	772,111,1,0,0,0,773,779,3,118,59,0,774,775,3,114,57,0,775,776,3,118,59,
  	0,776,778,1,0,0,0,777,774,1,0,0,0,778,781,1,0,0,0,779,777,1,0,0,0,779,
  	780,1,0,0,0,780,113,1,0,0,0,781,779,1,0,0,0,782,796,5,74,0,0,783,796,
  	5,75,0,0,784,796,5,76,0,0,785,796,5,77,0,0,786,796,5,78,0,0,787,796,5,
  	79,0,0,788,796,5,80,0,0,789,796,5,18,0,0,790,791,5,26,0,0,791,796,5,18,
  	0,0,792,796,5,27,0,0,793,794,5,27,0,0,794,796,5,26,0,0,795,782,1,0,0,
  	0,795,783,1,0,0,0,795,784,1,0,0,0,795,785,1,0,0,0,795,786,1,0,0,0,795,
  	787,1,0,0,0,795,788,1,0,0,0,795,789,1,0,0,0,795,790,1,0,0,0,795,792,1,
  	0,0,0,795,793,1,0,0,0,796,115,1,0,0,0,797,798,5,51,0,0,798,799,3,118,
  	59,0,799,117,1,0,0,0,800,805,3,120,60,0,801,802,5,61,0,0,802,804,3,120,
  	60,0,803,801,1,0,0,0,804,807,1,0,0,0,805,803,1,0,0,0,805,806,1,0,0,0,
  	806,119,1,0,0,0,807,805,1,0,0,0,808,813,3,122,61,0,809,810,5,62,0,0,810,
  	812,3,122,61,0,811,809,1,0,0,0,812,815,1,0,0,0,813,811,1,0,0,0,813,814,
  	1,0,0,0,814,121,1,0,0,0,815,813,1,0,0,0,816,821,3,124,62,0,817,818,5,
  	63,0,0,818,820,3,124,62,0,819,817,1,0,0,0,820,823,1,0,0,0,821,819,1,0,
  	0,0,821,822,1,0,0,0,822,123,1,0,0,0,823,821,1,0,0,0,824,829,3,126,63,
  	0,825,826,7,2,0,0,826,828,3,126,63,0,827,825,1,0,0,0,828,831,1,0,0,0,
  	829,827,1,0,0,0,829,830,1,0,0,0,830,125,1,0,0,0,831,829,1,0,0,0,832,837,
  	3,128,64,0,833,834,7,3,0,0,834,836,3,128,64,0,835,833,1,0,0,0,836,839,
  	1,0,0,0,837,835,1,0,0,0,837,838,1,0,0,0,838,127,1,0,0,0,839,837,1,0,0,
  	0,840,845,3,130,65,0,841,842,7,4,0,0,842,844,3,130,65,0,843,841,1,0,0,
  	0,844,847,1,0,0,0,845,843,1,0,0,0,845,846,1,0,0,0,846,129,1,0,0,0,847,
  	845,1,0,0,0,848,849,7,5,0,0,849,852,3,130,65,0,850,852,3,132,66,0,851,
  	848,1,0,0,0,851,850,1,0,0,0,852,131,1,0,0,0,853,856,3,134,67,0,854,855,
  	5,57,0,0,855,857,3,130,65,0,856,854,1,0,0,0,856,857,1,0,0,0,857,133,1,
  	0,0,0,858,860,5,38,0,0,859,858,1,0,0,0,859,860,1,0,0,0,860,861,1,0,0,
  	0,861,865,3,136,68,0,862,864,3,140,70,0,863,862,1,0,0,0,864,867,1,0,0,
  	0,865,863,1,0,0,0,865,866,1,0,0,0,866,135,1,0,0,0,867,865,1,0,0,0,868,
  	871,5,52,0,0,869,872,3,168,84,0,870,872,3,138,69,0,871,869,1,0,0,0,871,
  	870,1,0,0,0,871,872,1,0,0,0,872,873,1,0,0,0,873,896,5,53,0,0,874,876,
  	5,59,0,0,875,877,3,138,69,0,876,875,1,0,0,0,876,877,1,0,0,0,877,878,1,
  	0,0,0,878,896,5,60,0,0,879,881,5,72,0,0,880,882,3,152,76,0,881,880,1,
  	0,0,0,881,882,1,0,0,0,882,883,1,0,0,0,883,896,5,73,0,0,884,896,5,40,0,
  	0,885,896,5,2,0,0,886,888,5,1,0,0,887,886,1,0,0,0,888,889,1,0,0,0,889,
  	887,1,0,0,0,889,890,1,0,0,0,890,896,1,0,0,0,891,896,5,50,0,0,892,896,
  	5,28,0,0,893,896,5,29,0,0,894,896,5,30,0,0,895,868,1,0,0,0,895,874,1,
  	0,0,0,895,879,1,0,0,0,895,884,1,0,0,0,895,885,1,0,0,0,895,887,1,0,0,0,
  	895,891,1,0,0,0,895,892,1,0,0,0,895,893,1,0,0,0,895,894,1,0,0,0,896,137,
  	1,0,0,0,897,900,3,98,49,0,898,900,3,116,58,0,899,897,1,0,0,0,899,898,
  	1,0,0,0,900,915,1,0,0,0,901,916,3,162,81,0,902,905,5,54,0,0,903,906,3,
  	98,49,0,904,906,3,116,58,0,905,903,1,0,0,0,905,904,1,0,0,0,906,908,1,
  	0,0,0,907,902,1,0,0,0,908,911,1,0,0,0,909,907,1,0,0,0,909,910,1,0,0,0,
  	910,913,1,0,0,0,911,909,1,0,0,0,912,914,5,54,0,0,913,912,1,0,0,0,913,
  	914,1,0,0,0,914,916,1,0,0,0,915,901,1,0,0,0,915,909,1,0,0,0,916,139,1,
  	0,0,0,917,919,5,52,0,0,918,920,3,156,78,0,919,918,1,0,0,0,919,920,1,0,
  	0,0,920,921,1,0,0,0,921,929,5,53,0,0,922,923,5,59,0,0,923,924,3,142,71,
  	0,924,925,5,60,0,0,925,929,1,0,0,0,926,927,5,49,0,0,927,929,5,40,0,0,
  	928,917,1,0,0,0,928,922,1,0,0,0,928,926,1,0,0,0,929,141,1,0,0,0,930,935,
  	3,144,72,0,931,932,5,54,0,0,932,934,3,144,72,0,933,931,1,0,0,0,934,937,
  	1,0,0,0,935,933,1,0,0,0,935,936,1,0,0,0,936,939,1,0,0,0,937,935,1,0,0,
  	0,938,940,5,54,0,0,939,938,1,0,0,0,939,940,1,0,0,0,940,143,1,0,0,0,941,
  	953,3,98,49,0,942,944,3,98,49,0,943,942,1,0,0,0,943,944,1,0,0,0,944,945,
  	1,0,0,0,945,947,5,55,0,0,946,948,3,98,49,0,947,946,1,0,0,0,947,948,1,
  	0,0,0,948,950,1,0,0,0,949,951,3,146,73,0,950,949,1,0,0,0,950,951,1,0,
  	0,0,951,953,1,0,0,0,952,941,1,0,0,0,952,943,1,0,0,0,953,145,1,0,0,0,954,
  	956,5,55,0,0,955,957,3,98,49,0,956,955,1,0,0,0,956,957,1,0,0,0,957,147,
  	1,0,0,0,958,961,3,118,59,0,959,961,3,116,58,0,960,958,1,0,0,0,960,959,
  	1,0,0,0,961,969,1,0,0,0,962,965,5,54,0,0,963,966,3,118,59,0,964,966,3,
  	116,58,0,965,963,1,0,0,0,965,964,1,0,0,0,966,968,1,0,0,0,967,962,1,0,
  	0,0,968,971,1,0,0,0,969,967,1,0,0,0,969,970,1,0,0,0,970,973,1,0,0,0,971,
  	969,1,0,0,0,972,974,5,54,0,0,973,972,1,0,0,0,973,974,1,0,0,0,974,149,
  	1,0,0,0,975,980,3,98,49,0,976,977,5,54,0,0,977,979,3,98,49,0,978,976,
  	1,0,0,0,979,982,1,0,0,0,980,978,1,0,0,0,980,981,1,0,0,0,981,984,1,0,0,
  	0,982,980,1,0,0,0,983,985,5,54,0,0,984,983,1,0,0,0,984,985,1,0,0,0,985,
  	151,1,0,0,0,986,987,3,98,49,0,987,988,5,55,0,0,988,989,3,98,49,0,989,
  	993,1,0,0,0,990,991,5,57,0,0,991,993,3,118,59,0,992,986,1,0,0,0,992,990,
  	1,0,0,0,993,1012,1,0,0,0,994,1013,3,162,81,0,995,1002,5,54,0,0,996,997,
  	3,98,49,0,997,998,5,55,0,0,998,999,3,98,49,0,999,1003,1,0,0,0,1000,1001,
  	5,57,0,0,1001,1003,3,118,59,0,1002,996,1,0,0,0,1002,1000,1,0,0,0,1003,
  	1005,1,0,0,0,1004,995,1,0,0,0,1005,1008,1,0,0,0,1006,1004,1,0,0,0,1006,
  	1007,1,0,0,0,1007,1010,1,0,0,0,1008,1006,1,0,0,0,1009,1011,5,54,0,0,1010,
  	1009,1,0,0,0,1010,1011,1,0,0,0,1011,1013,1,0,0,0,1012,994,1,0,0,0,1012,
  	1006,1,0,0,0,1013,1035,1,0,0,0,1014,1017,3,98,49,0,1015,1017,3,116,58,
  	0,1016,1014,1,0,0,0,1016,1015,1,0,0,0,1017,1032,1,0,0,0,1018,1033,3,162,
  	81,0,1019,1022,5,54,0,0,1020,1023,3,98,49,0,1021,1023,3,116,58,0,1022,
  	1020,1,0,0,0,1022,1021,1,0,0,0,1023,1025,1,0,0,0,1024,1019,1,0,0,0,1025,
  	1028,1,0,0,0,1026,1024,1,0,0,0,1026,1027,1,0,0,0,1027,1030,1,0,0,0,1028,
  	1026,1,0,0,0,1029,1031,5,54,0,0,1030,1029,1,0,0,0,1030,1031,1,0,0,0,1031,
  	1033,1,0,0,0,1032,1018,1,0,0,0,1032,1026,1,0,0,0,1033,1035,1,0,0,0,1034,
  	992,1,0,0,0,1034,1016,1,0,0,0,1035,153,1,0,0,0,1036,1037,5,31,0,0,1037,
  	1043,5,40,0,0,1038,1040,5,52,0,0,1039,1041,3,156,78,0,1040,1039,1,0,0,
  	0,1040,1041,1,0,0,0,1041,1042,1,0,0,0,1042,1044,5,53,0,0,1043,1038,1,
  	0,0,0,1043,1044,1,0,0,0,1044,1045,1,0,0,0,1045,1046,5,55,0,0,1046,1047,
  	3,96,48,0,1047,155,1,0,0,0,1048,1053,3,158,79,0,1049,1050,5,54,0,0,1050,
  	1052,3,158,79,0,1051,1049,1,0,0,0,1052,1055,1,0,0,0,1053,1051,1,0,0,0,
  	1053,1054,1,0,0,0,1054,1057,1,0,0,0,1055,1053,1,0,0,0,1056,1058,5,54,
  	0,0,1057,1056,1,0,0,0,1057,1058,1,0,0,0,1058,157,1,0,0,0,1059,1061,3,
  	98,49,0,1060,1062,3,162,81,0,1061,1060,1,0,0,0,1061,1062,1,0,0,0,1062,
  	1072,1,0,0,0,1063,1064,3,98,49,0,1064,1065,5,58,0,0,1065,1066,3,98,49,
  	0,1066,1072,1,0,0,0,1067,1068,5,57,0,0,1068,1072,3,98,49,0,1069,1070,
  	5,51,0,0,1070,1072,3,98,49,0,1071,1059,1,0,0,0,1071,1063,1,0,0,0,1071,
  	1067,1,0,0,0,1071,1069,1,0,0,0,1072,159,1,0,0,0,1073,1076,3,162,81,0,
  	1074,1076,3,164,82,0,1075,1073,1,0,0,0,1075,1074,1,0,0,0,1076,161,1,0,
  	0,0,1077,1079,5,37,0,0,1078,1077,1,0,0,0,1078,1079,1,0,0,0,1079,1080,
  	1,0,0,0,1080,1081,5,17,0,0,1081,1082,3,148,74,0,1082,1083,5,18,0,0,1083,
  	1085,3,106,53,0,1084,1086,3,160,80,0,1085,1084,1,0,0,0,1085,1086,1,0,
  	0,0,1086,163,1,0,0,0,1087,1088,5,13,0,0,1088,1090,3,100,50,0,1089,1091,
  	3,160,80,0,1090,1089,1,0,0,0,1090,1091,1,0,0,0,1091,165,1,0,0,0,1092,
  	1093,5,40,0,0,1093,167,1,0,0,0,1094,1096,5,32,0,0,1095,1097,3,170,85,
  	0,1096,1095,1,0,0,0,1096,1097,1,0,0,0,1097,169,1,0,0,0,1098,1099,5,7,
  	0,0,1099,1102,3,98,49,0,1100,1102,3,150,75,0,1101,1098,1,0,0,0,1101,1100,
  	1,0,0,0,1102,171,1,0,0,0,166,177,181,183,192,201,204,211,217,227,234,
  	241,247,251,257,263,267,274,276,278,283,285,287,291,297,301,308,310,312,
  	317,319,324,329,335,339,345,351,355,362,364,366,371,373,375,379,385,389,
  	396,398,400,405,407,413,420,424,436,443,448,452,455,461,465,470,474,478,
  	492,500,508,510,514,523,530,532,541,546,551,558,562,569,577,586,595,602,
  	613,619,632,638,647,658,669,674,679,684,692,701,707,709,717,721,729,732,
  	736,740,747,757,765,771,779,795,805,813,821,829,837,845,851,856,859,865,
  	871,876,881,889,895,899,905,909,913,915,919,928,935,939,943,947,950,952,
  	956,960,965,969,973,980,984,992,1002,1006,1010,1012,1016,1022,1026,1030,
  	1032,1034,1040,1043,1053,1057,1061,1071,1075,1078,1085,1090,1096,1101
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  myParserStaticData = staticData.release();
}

}

myParser::myParser(TokenStream *input) : myParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

myParser::myParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  myParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *myParserStaticData->atn, myParserStaticData->decisionToDFA, myParserStaticData->sharedContextCache, options);
}

myParser::~myParser() {
  delete _interpreter;
}

const atn::ATN& myParser::getATN() const {
  return *myParserStaticData->atn;
}

std::string myParser::getGrammarFileName() const {
  return "my.g4";
}

const std::vector<std::string>& myParser::getRuleNames() const {
  return myParserStaticData->ruleNames;
}

const dfa::Vocabulary& myParser::getVocabulary() const {
  return myParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView myParser::getSerializedATN() const {
  return myParserStaticData->serializedATN;
}


//----------------- Single_inputContext ------------------------------------------------------------------

myParser::Single_inputContext::Single_inputContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Single_inputContext::NEWLINE() {
  return getToken(myParser::NEWLINE, 0);
}

myParser::Simple_stmtContext* myParser::Single_inputContext::simple_stmt() {
  return getRuleContext<myParser::Simple_stmtContext>(0);
}

myParser::Compound_stmtContext* myParser::Single_inputContext::compound_stmt() {
  return getRuleContext<myParser::Compound_stmtContext>(0);
}


size_t myParser::Single_inputContext::getRuleIndex() const {
  return myParser::RuleSingle_input;
}

void myParser::Single_inputContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingle_input(this);
}

void myParser::Single_inputContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingle_input(this);
}

myParser::Single_inputContext* myParser::single_input() {
  Single_inputContext *_localctx = _tracker.createInstance<Single_inputContext>(_ctx, getState());
  enterRule(_localctx, 0, myParser::RuleSingle_input);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(177);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::NEWLINE: {
        enterOuterAlt(_localctx, 1);
        setState(172);
        match(myParser::NEWLINE);
        break;
      }

      case myParser::STRING:
      case myParser::NUMBER:
      case myParser::RETURN:
      case myParser::RAISE:
      case myParser::FROM:
      case myParser::IMPORT:
      case myParser::GLOBAL:
      case myParser::NONLOCAL:
      case myParser::ASSERT:
      case myParser::LAMBDA:
      case myParser::NOT:
      case myParser::NONE:
      case myParser::TRUE:
      case myParser::FALSE:
      case myParser::YIELD:
      case myParser::DEL:
      case myParser::PASS:
      case myParser::CONTINUE:
      case myParser::BREAK:
      case myParser::AWAIT:
      case myParser::NAME:
      case myParser::ELLIPSIS:
      case myParser::STAR:
      case myParser::OPEN_PAREN:
      case myParser::OPEN_BRACK:
      case myParser::ADD:
      case myParser::MINUS:
      case myParser::NOT_OP:
      case myParser::OPEN_BRACE: {
        enterOuterAlt(_localctx, 2);
        setState(173);
        simple_stmt();
        break;
      }

      case myParser::DEF:
      case myParser::IF:
      case myParser::WHILE:
      case myParser::FOR:
      case myParser::TRY:
      case myParser::WITH:
      case myParser::CLASS:
      case myParser::ASYNC:
      case myParser::AT: {
        enterOuterAlt(_localctx, 3);
        setState(174);
        compound_stmt();
        setState(175);
        match(myParser::NEWLINE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_inputContext ------------------------------------------------------------------

myParser::File_inputContext::File_inputContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::File_inputContext::EOF() {
  return getToken(myParser::EOF, 0);
}

std::vector<tree::TerminalNode *> myParser::File_inputContext::NEWLINE() {
  return getTokens(myParser::NEWLINE);
}

tree::TerminalNode* myParser::File_inputContext::NEWLINE(size_t i) {
  return getToken(myParser::NEWLINE, i);
}

std::vector<myParser::StmtContext *> myParser::File_inputContext::stmt() {
  return getRuleContexts<myParser::StmtContext>();
}

myParser::StmtContext* myParser::File_inputContext::stmt(size_t i) {
  return getRuleContext<myParser::StmtContext>(i);
}


size_t myParser::File_inputContext::getRuleIndex() const {
  return myParser::RuleFile_input;
}

void myParser::File_inputContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFile_input(this);
}

void myParser::File_inputContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFile_input(this);
}

myParser::File_inputContext* myParser::file_input() {
  File_inputContext *_localctx = _tracker.createInstance<File_inputContext>(_ctx, getState());
  enterRule(_localctx, 2, myParser::RuleFile_input);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(183);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 584344250484473334) != 0 || (((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 32867) != 0) {
      setState(181);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case myParser::NEWLINE: {
          setState(179);
          match(myParser::NEWLINE);
          break;
        }

        case myParser::STRING:
        case myParser::NUMBER:
        case myParser::DEF:
        case myParser::RETURN:
        case myParser::RAISE:
        case myParser::FROM:
        case myParser::IMPORT:
        case myParser::GLOBAL:
        case myParser::NONLOCAL:
        case myParser::ASSERT:
        case myParser::IF:
        case myParser::WHILE:
        case myParser::FOR:
        case myParser::TRY:
        case myParser::WITH:
        case myParser::LAMBDA:
        case myParser::NOT:
        case myParser::NONE:
        case myParser::TRUE:
        case myParser::FALSE:
        case myParser::CLASS:
        case myParser::YIELD:
        case myParser::DEL:
        case myParser::PASS:
        case myParser::CONTINUE:
        case myParser::BREAK:
        case myParser::ASYNC:
        case myParser::AWAIT:
        case myParser::NAME:
        case myParser::ELLIPSIS:
        case myParser::STAR:
        case myParser::OPEN_PAREN:
        case myParser::OPEN_BRACK:
        case myParser::ADD:
        case myParser::MINUS:
        case myParser::NOT_OP:
        case myParser::OPEN_BRACE:
        case myParser::AT: {
          setState(180);
          stmt();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(185);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(186);
    match(myParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Eval_inputContext ------------------------------------------------------------------

myParser::Eval_inputContext::Eval_inputContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::TestlistContext* myParser::Eval_inputContext::testlist() {
  return getRuleContext<myParser::TestlistContext>(0);
}

tree::TerminalNode* myParser::Eval_inputContext::EOF() {
  return getToken(myParser::EOF, 0);
}

std::vector<tree::TerminalNode *> myParser::Eval_inputContext::NEWLINE() {
  return getTokens(myParser::NEWLINE);
}

tree::TerminalNode* myParser::Eval_inputContext::NEWLINE(size_t i) {
  return getToken(myParser::NEWLINE, i);
}


size_t myParser::Eval_inputContext::getRuleIndex() const {
  return myParser::RuleEval_input;
}

void myParser::Eval_inputContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEval_input(this);
}

void myParser::Eval_inputContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEval_input(this);
}

myParser::Eval_inputContext* myParser::eval_input() {
  Eval_inputContext *_localctx = _tracker.createInstance<Eval_inputContext>(_ctx, getState());
  enterRule(_localctx, 4, myParser::RuleEval_input);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(188);
    testlist();
    setState(192);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::NEWLINE) {
      setState(189);
      match(myParser::NEWLINE);
      setState(194);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(195);
    match(myParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DecoratorContext ------------------------------------------------------------------

myParser::DecoratorContext::DecoratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::DecoratorContext::AT() {
  return getToken(myParser::AT, 0);
}

myParser::Dotted_nameContext* myParser::DecoratorContext::dotted_name() {
  return getRuleContext<myParser::Dotted_nameContext>(0);
}

tree::TerminalNode* myParser::DecoratorContext::NEWLINE() {
  return getToken(myParser::NEWLINE, 0);
}

tree::TerminalNode* myParser::DecoratorContext::OPEN_PAREN() {
  return getToken(myParser::OPEN_PAREN, 0);
}

tree::TerminalNode* myParser::DecoratorContext::CLOSE_PAREN() {
  return getToken(myParser::CLOSE_PAREN, 0);
}

myParser::ArglistContext* myParser::DecoratorContext::arglist() {
  return getRuleContext<myParser::ArglistContext>(0);
}


size_t myParser::DecoratorContext::getRuleIndex() const {
  return myParser::RuleDecorator;
}

void myParser::DecoratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecorator(this);
}

void myParser::DecoratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecorator(this);
}

myParser::DecoratorContext* myParser::decorator() {
  DecoratorContext *_localctx = _tracker.createInstance<DecoratorContext>(_ctx, getState());
  enterRule(_localctx, 6, myParser::RuleDecorator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(197);
    match(myParser::AT);
    setState(198);
    dotted_name();
    setState(204);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::OPEN_PAREN) {
      setState(199);
      match(myParser::OPEN_PAREN);
      setState(201);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 728458616071258118) != 0 || (((_la - 66) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 66)) & 99) != 0) {
        setState(200);
        arglist();
      }
      setState(203);
      match(myParser::CLOSE_PAREN);
    }
    setState(206);
    match(myParser::NEWLINE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DecoratorsContext ------------------------------------------------------------------

myParser::DecoratorsContext::DecoratorsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::DecoratorContext *> myParser::DecoratorsContext::decorator() {
  return getRuleContexts<myParser::DecoratorContext>();
}

myParser::DecoratorContext* myParser::DecoratorsContext::decorator(size_t i) {
  return getRuleContext<myParser::DecoratorContext>(i);
}


size_t myParser::DecoratorsContext::getRuleIndex() const {
  return myParser::RuleDecorators;
}

void myParser::DecoratorsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecorators(this);
}

void myParser::DecoratorsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecorators(this);
}

myParser::DecoratorsContext* myParser::decorators() {
  DecoratorsContext *_localctx = _tracker.createInstance<DecoratorsContext>(_ctx, getState());
  enterRule(_localctx, 8, myParser::RuleDecorators);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(209); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(208);
      decorator();
      setState(211); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == myParser::AT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DecoratedContext ------------------------------------------------------------------

myParser::DecoratedContext::DecoratedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::DecoratorsContext* myParser::DecoratedContext::decorators() {
  return getRuleContext<myParser::DecoratorsContext>(0);
}

myParser::ClassdefContext* myParser::DecoratedContext::classdef() {
  return getRuleContext<myParser::ClassdefContext>(0);
}

myParser::FuncdefContext* myParser::DecoratedContext::funcdef() {
  return getRuleContext<myParser::FuncdefContext>(0);
}

myParser::Async_funcdefContext* myParser::DecoratedContext::async_funcdef() {
  return getRuleContext<myParser::Async_funcdefContext>(0);
}


size_t myParser::DecoratedContext::getRuleIndex() const {
  return myParser::RuleDecorated;
}

void myParser::DecoratedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecorated(this);
}

void myParser::DecoratedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecorated(this);
}

myParser::DecoratedContext* myParser::decorated() {
  DecoratedContext *_localctx = _tracker.createInstance<DecoratedContext>(_ctx, getState());
  enterRule(_localctx, 10, myParser::RuleDecorated);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(213);
    decorators();
    setState(217);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::CLASS: {
        setState(214);
        classdef();
        break;
      }

      case myParser::DEF: {
        setState(215);
        funcdef();
        break;
      }

      case myParser::ASYNC: {
        setState(216);
        async_funcdef();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Async_funcdefContext ------------------------------------------------------------------

myParser::Async_funcdefContext::Async_funcdefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Async_funcdefContext::ASYNC() {
  return getToken(myParser::ASYNC, 0);
}

myParser::FuncdefContext* myParser::Async_funcdefContext::funcdef() {
  return getRuleContext<myParser::FuncdefContext>(0);
}


size_t myParser::Async_funcdefContext::getRuleIndex() const {
  return myParser::RuleAsync_funcdef;
}

void myParser::Async_funcdefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAsync_funcdef(this);
}

void myParser::Async_funcdefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAsync_funcdef(this);
}

myParser::Async_funcdefContext* myParser::async_funcdef() {
  Async_funcdefContext *_localctx = _tracker.createInstance<Async_funcdefContext>(_ctx, getState());
  enterRule(_localctx, 12, myParser::RuleAsync_funcdef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(219);
    match(myParser::ASYNC);
    setState(220);
    funcdef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FuncdefContext ------------------------------------------------------------------

myParser::FuncdefContext::FuncdefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::FuncdefContext::DEF() {
  return getToken(myParser::DEF, 0);
}

tree::TerminalNode* myParser::FuncdefContext::NAME() {
  return getToken(myParser::NAME, 0);
}

myParser::ParametersContext* myParser::FuncdefContext::parameters() {
  return getRuleContext<myParser::ParametersContext>(0);
}

tree::TerminalNode* myParser::FuncdefContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::SuiteContext* myParser::FuncdefContext::suite() {
  return getRuleContext<myParser::SuiteContext>(0);
}

tree::TerminalNode* myParser::FuncdefContext::ARROW() {
  return getToken(myParser::ARROW, 0);
}

myParser::TestContext* myParser::FuncdefContext::test() {
  return getRuleContext<myParser::TestContext>(0);
}


size_t myParser::FuncdefContext::getRuleIndex() const {
  return myParser::RuleFuncdef;
}

void myParser::FuncdefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFuncdef(this);
}

void myParser::FuncdefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFuncdef(this);
}

myParser::FuncdefContext* myParser::funcdef() {
  FuncdefContext *_localctx = _tracker.createInstance<FuncdefContext>(_ctx, getState());
  enterRule(_localctx, 14, myParser::RuleFuncdef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(222);
    match(myParser::DEF);
    setState(223);
    match(myParser::NAME);
    setState(224);
    parameters();
    setState(227);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::ARROW) {
      setState(225);
      match(myParser::ARROW);
      setState(226);
      test();
    }
    setState(229);
    match(myParser::COLON);
    setState(230);
    suite();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParametersContext ------------------------------------------------------------------

myParser::ParametersContext::ParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ParametersContext::OPEN_PAREN() {
  return getToken(myParser::OPEN_PAREN, 0);
}

tree::TerminalNode* myParser::ParametersContext::CLOSE_PAREN() {
  return getToken(myParser::CLOSE_PAREN, 0);
}

myParser::TypedargslistContext* myParser::ParametersContext::typedargslist() {
  return getRuleContext<myParser::TypedargslistContext>(0);
}


size_t myParser::ParametersContext::getRuleIndex() const {
  return myParser::RuleParameters;
}

void myParser::ParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameters(this);
}

void myParser::ParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameters(this);
}

myParser::ParametersContext* myParser::parameters() {
  ParametersContext *_localctx = _tracker.createInstance<ParametersContext>(_ctx, getState());
  enterRule(_localctx, 16, myParser::RuleParameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(232);
    match(myParser::OPEN_PAREN);
    setState(234);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 146368087401168896) != 0) {
      setState(233);
      typedargslist();
    }
    setState(236);
    match(myParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypedargslistContext ------------------------------------------------------------------

myParser::TypedargslistContext::TypedargslistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::TfpdefContext *> myParser::TypedargslistContext::tfpdef() {
  return getRuleContexts<myParser::TfpdefContext>();
}

myParser::TfpdefContext* myParser::TypedargslistContext::tfpdef(size_t i) {
  return getRuleContext<myParser::TfpdefContext>(i);
}

tree::TerminalNode* myParser::TypedargslistContext::STAR() {
  return getToken(myParser::STAR, 0);
}

tree::TerminalNode* myParser::TypedargslistContext::POWER() {
  return getToken(myParser::POWER, 0);
}

std::vector<tree::TerminalNode *> myParser::TypedargslistContext::ASSIGN() {
  return getTokens(myParser::ASSIGN);
}

tree::TerminalNode* myParser::TypedargslistContext::ASSIGN(size_t i) {
  return getToken(myParser::ASSIGN, i);
}

std::vector<myParser::TestContext *> myParser::TypedargslistContext::test() {
  return getRuleContexts<myParser::TestContext>();
}

myParser::TestContext* myParser::TypedargslistContext::test(size_t i) {
  return getRuleContext<myParser::TestContext>(i);
}

std::vector<tree::TerminalNode *> myParser::TypedargslistContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::TypedargslistContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::TypedargslistContext::getRuleIndex() const {
  return myParser::RuleTypedargslist;
}

void myParser::TypedargslistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypedargslist(this);
}

void myParser::TypedargslistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypedargslist(this);
}

myParser::TypedargslistContext* myParser::typedargslist() {
  TypedargslistContext *_localctx = _tracker.createInstance<TypedargslistContext>(_ctx, getState());
  enterRule(_localctx, 18, myParser::RuleTypedargslist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(319);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::NAME: {
        setState(238);
        tfpdef();
        setState(241);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::ASSIGN) {
          setState(239);
          match(myParser::ASSIGN);
          setState(240);
          test();
        }
        setState(251);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(243);
            match(myParser::COMMA);
            setState(244);
            tfpdef();
            setState(247);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == myParser::ASSIGN) {
              setState(245);
              match(myParser::ASSIGN);
              setState(246);
              test();
            } 
          }
          setState(253);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx);
        }
        setState(287);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::COMMA) {
          setState(254);
          match(myParser::COMMA);
          setState(285);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case myParser::STAR: {
              setState(255);
              match(myParser::STAR);
              setState(257);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == myParser::NAME) {
                setState(256);
                tfpdef();
              }
              setState(267);
              _errHandler->sync(this);
              alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx);
              while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
                if (alt == 1) {
                  setState(259);
                  match(myParser::COMMA);
                  setState(260);
                  tfpdef();
                  setState(263);
                  _errHandler->sync(this);

                  _la = _input->LA(1);
                  if (_la == myParser::ASSIGN) {
                    setState(261);
                    match(myParser::ASSIGN);
                    setState(262);
                    test();
                  } 
                }
                setState(269);
                _errHandler->sync(this);
                alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx);
              }
              setState(278);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == myParser::COMMA) {
                setState(270);
                match(myParser::COMMA);
                setState(276);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == myParser::POWER) {
                  setState(271);
                  match(myParser::POWER);
                  setState(272);
                  tfpdef();
                  setState(274);
                  _errHandler->sync(this);

                  _la = _input->LA(1);
                  if (_la == myParser::COMMA) {
                    setState(273);
                    match(myParser::COMMA);
                  }
                }
              }
              break;
            }

            case myParser::POWER: {
              setState(280);
              match(myParser::POWER);
              setState(281);
              tfpdef();
              setState(283);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == myParser::COMMA) {
                setState(282);
                match(myParser::COMMA);
              }
              break;
            }

            case myParser::CLOSE_PAREN: {
              break;
            }

          default:
            break;
          }
        }
        break;
      }

      case myParser::STAR: {
        setState(289);
        match(myParser::STAR);
        setState(291);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::NAME) {
          setState(290);
          tfpdef();
        }
        setState(301);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(293);
            match(myParser::COMMA);
            setState(294);
            tfpdef();
            setState(297);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == myParser::ASSIGN) {
              setState(295);
              match(myParser::ASSIGN);
              setState(296);
              test();
            } 
          }
          setState(303);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx);
        }
        setState(312);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::COMMA) {
          setState(304);
          match(myParser::COMMA);
          setState(310);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == myParser::POWER) {
            setState(305);
            match(myParser::POWER);
            setState(306);
            tfpdef();
            setState(308);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == myParser::COMMA) {
              setState(307);
              match(myParser::COMMA);
            }
          }
        }
        break;
      }

      case myParser::POWER: {
        setState(314);
        match(myParser::POWER);
        setState(315);
        tfpdef();
        setState(317);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::COMMA) {
          setState(316);
          match(myParser::COMMA);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TfpdefContext ------------------------------------------------------------------

myParser::TfpdefContext::TfpdefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TfpdefContext::NAME() {
  return getToken(myParser::NAME, 0);
}

tree::TerminalNode* myParser::TfpdefContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::TestContext* myParser::TfpdefContext::test() {
  return getRuleContext<myParser::TestContext>(0);
}


size_t myParser::TfpdefContext::getRuleIndex() const {
  return myParser::RuleTfpdef;
}

void myParser::TfpdefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTfpdef(this);
}

void myParser::TfpdefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTfpdef(this);
}

myParser::TfpdefContext* myParser::tfpdef() {
  TfpdefContext *_localctx = _tracker.createInstance<TfpdefContext>(_ctx, getState());
  enterRule(_localctx, 20, myParser::RuleTfpdef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(321);
    match(myParser::NAME);
    setState(324);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::COLON) {
      setState(322);
      match(myParser::COLON);
      setState(323);
      test();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarargslistContext ------------------------------------------------------------------

myParser::VarargslistContext::VarargslistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::VfpdefContext *> myParser::VarargslistContext::vfpdef() {
  return getRuleContexts<myParser::VfpdefContext>();
}

myParser::VfpdefContext* myParser::VarargslistContext::vfpdef(size_t i) {
  return getRuleContext<myParser::VfpdefContext>(i);
}

tree::TerminalNode* myParser::VarargslistContext::STAR() {
  return getToken(myParser::STAR, 0);
}

tree::TerminalNode* myParser::VarargslistContext::POWER() {
  return getToken(myParser::POWER, 0);
}

std::vector<tree::TerminalNode *> myParser::VarargslistContext::ASSIGN() {
  return getTokens(myParser::ASSIGN);
}

tree::TerminalNode* myParser::VarargslistContext::ASSIGN(size_t i) {
  return getToken(myParser::ASSIGN, i);
}

std::vector<myParser::TestContext *> myParser::VarargslistContext::test() {
  return getRuleContexts<myParser::TestContext>();
}

myParser::TestContext* myParser::VarargslistContext::test(size_t i) {
  return getRuleContext<myParser::TestContext>(i);
}

std::vector<tree::TerminalNode *> myParser::VarargslistContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::VarargslistContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::VarargslistContext::getRuleIndex() const {
  return myParser::RuleVarargslist;
}

void myParser::VarargslistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarargslist(this);
}

void myParser::VarargslistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarargslist(this);
}

myParser::VarargslistContext* myParser::varargslist() {
  VarargslistContext *_localctx = _tracker.createInstance<VarargslistContext>(_ctx, getState());
  enterRule(_localctx, 22, myParser::RuleVarargslist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(407);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::NAME: {
        setState(326);
        vfpdef();
        setState(329);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::ASSIGN) {
          setState(327);
          match(myParser::ASSIGN);
          setState(328);
          test();
        }
        setState(339);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(331);
            match(myParser::COMMA);
            setState(332);
            vfpdef();
            setState(335);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == myParser::ASSIGN) {
              setState(333);
              match(myParser::ASSIGN);
              setState(334);
              test();
            } 
          }
          setState(341);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx);
        }
        setState(375);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::COMMA) {
          setState(342);
          match(myParser::COMMA);
          setState(373);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case myParser::STAR: {
              setState(343);
              match(myParser::STAR);
              setState(345);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == myParser::NAME) {
                setState(344);
                vfpdef();
              }
              setState(355);
              _errHandler->sync(this);
              alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
              while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
                if (alt == 1) {
                  setState(347);
                  match(myParser::COMMA);
                  setState(348);
                  vfpdef();
                  setState(351);
                  _errHandler->sync(this);

                  _la = _input->LA(1);
                  if (_la == myParser::ASSIGN) {
                    setState(349);
                    match(myParser::ASSIGN);
                    setState(350);
                    test();
                  } 
                }
                setState(357);
                _errHandler->sync(this);
                alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
              }
              setState(366);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == myParser::COMMA) {
                setState(358);
                match(myParser::COMMA);
                setState(364);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == myParser::POWER) {
                  setState(359);
                  match(myParser::POWER);
                  setState(360);
                  vfpdef();
                  setState(362);
                  _errHandler->sync(this);

                  _la = _input->LA(1);
                  if (_la == myParser::COMMA) {
                    setState(361);
                    match(myParser::COMMA);
                  }
                }
              }
              break;
            }

            case myParser::POWER: {
              setState(368);
              match(myParser::POWER);
              setState(369);
              vfpdef();
              setState(371);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == myParser::COMMA) {
                setState(370);
                match(myParser::COMMA);
              }
              break;
            }

            case myParser::COLON: {
              break;
            }

          default:
            break;
          }
        }
        break;
      }

      case myParser::STAR: {
        setState(377);
        match(myParser::STAR);
        setState(379);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::NAME) {
          setState(378);
          vfpdef();
        }
        setState(389);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(381);
            match(myParser::COMMA);
            setState(382);
            vfpdef();
            setState(385);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == myParser::ASSIGN) {
              setState(383);
              match(myParser::ASSIGN);
              setState(384);
              test();
            } 
          }
          setState(391);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx);
        }
        setState(400);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::COMMA) {
          setState(392);
          match(myParser::COMMA);
          setState(398);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == myParser::POWER) {
            setState(393);
            match(myParser::POWER);
            setState(394);
            vfpdef();
            setState(396);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == myParser::COMMA) {
              setState(395);
              match(myParser::COMMA);
            }
          }
        }
        break;
      }

      case myParser::POWER: {
        setState(402);
        match(myParser::POWER);
        setState(403);
        vfpdef();
        setState(405);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::COMMA) {
          setState(404);
          match(myParser::COMMA);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VfpdefContext ------------------------------------------------------------------

myParser::VfpdefContext::VfpdefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::VfpdefContext::NAME() {
  return getToken(myParser::NAME, 0);
}


size_t myParser::VfpdefContext::getRuleIndex() const {
  return myParser::RuleVfpdef;
}

void myParser::VfpdefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVfpdef(this);
}

void myParser::VfpdefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVfpdef(this);
}

myParser::VfpdefContext* myParser::vfpdef() {
  VfpdefContext *_localctx = _tracker.createInstance<VfpdefContext>(_ctx, getState());
  enterRule(_localctx, 24, myParser::RuleVfpdef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(409);
    match(myParser::NAME);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StmtContext ------------------------------------------------------------------

myParser::StmtContext::StmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Simple_stmtContext* myParser::StmtContext::simple_stmt() {
  return getRuleContext<myParser::Simple_stmtContext>(0);
}

myParser::Compound_stmtContext* myParser::StmtContext::compound_stmt() {
  return getRuleContext<myParser::Compound_stmtContext>(0);
}


size_t myParser::StmtContext::getRuleIndex() const {
  return myParser::RuleStmt;
}

void myParser::StmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStmt(this);
}

void myParser::StmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStmt(this);
}

myParser::StmtContext* myParser::stmt() {
  StmtContext *_localctx = _tracker.createInstance<StmtContext>(_ctx, getState());
  enterRule(_localctx, 26, myParser::RuleStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(413);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::STRING:
      case myParser::NUMBER:
      case myParser::RETURN:
      case myParser::RAISE:
      case myParser::FROM:
      case myParser::IMPORT:
      case myParser::GLOBAL:
      case myParser::NONLOCAL:
      case myParser::ASSERT:
      case myParser::LAMBDA:
      case myParser::NOT:
      case myParser::NONE:
      case myParser::TRUE:
      case myParser::FALSE:
      case myParser::YIELD:
      case myParser::DEL:
      case myParser::PASS:
      case myParser::CONTINUE:
      case myParser::BREAK:
      case myParser::AWAIT:
      case myParser::NAME:
      case myParser::ELLIPSIS:
      case myParser::STAR:
      case myParser::OPEN_PAREN:
      case myParser::OPEN_BRACK:
      case myParser::ADD:
      case myParser::MINUS:
      case myParser::NOT_OP:
      case myParser::OPEN_BRACE: {
        enterOuterAlt(_localctx, 1);
        setState(411);
        simple_stmt();
        break;
      }

      case myParser::DEF:
      case myParser::IF:
      case myParser::WHILE:
      case myParser::FOR:
      case myParser::TRY:
      case myParser::WITH:
      case myParser::CLASS:
      case myParser::ASYNC:
      case myParser::AT: {
        enterOuterAlt(_localctx, 2);
        setState(412);
        compound_stmt();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_stmtContext ------------------------------------------------------------------

myParser::Simple_stmtContext::Simple_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Small_stmtContext *> myParser::Simple_stmtContext::small_stmt() {
  return getRuleContexts<myParser::Small_stmtContext>();
}

myParser::Small_stmtContext* myParser::Simple_stmtContext::small_stmt(size_t i) {
  return getRuleContext<myParser::Small_stmtContext>(i);
}

tree::TerminalNode* myParser::Simple_stmtContext::NEWLINE() {
  return getToken(myParser::NEWLINE, 0);
}

std::vector<tree::TerminalNode *> myParser::Simple_stmtContext::SEMI_COLON() {
  return getTokens(myParser::SEMI_COLON);
}

tree::TerminalNode* myParser::Simple_stmtContext::SEMI_COLON(size_t i) {
  return getToken(myParser::SEMI_COLON, i);
}


size_t myParser::Simple_stmtContext::getRuleIndex() const {
  return myParser::RuleSimple_stmt;
}

void myParser::Simple_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_stmt(this);
}

void myParser::Simple_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_stmt(this);
}

myParser::Simple_stmtContext* myParser::simple_stmt() {
  Simple_stmtContext *_localctx = _tracker.createInstance<Simple_stmtContext>(_ctx, getState());
  enterRule(_localctx, 28, myParser::RuleSimple_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(415);
    small_stmt();
    setState(420);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(416);
        match(myParser::SEMI_COLON);
        setState(417);
        small_stmt(); 
      }
      setState(422);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx);
    }
    setState(424);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::SEMI_COLON) {
      setState(423);
      match(myParser::SEMI_COLON);
    }
    setState(426);
    match(myParser::NEWLINE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Small_stmtContext ------------------------------------------------------------------

myParser::Small_stmtContext::Small_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Expr_stmtContext* myParser::Small_stmtContext::expr_stmt() {
  return getRuleContext<myParser::Expr_stmtContext>(0);
}

myParser::Del_stmtContext* myParser::Small_stmtContext::del_stmt() {
  return getRuleContext<myParser::Del_stmtContext>(0);
}

myParser::Pass_stmtContext* myParser::Small_stmtContext::pass_stmt() {
  return getRuleContext<myParser::Pass_stmtContext>(0);
}

myParser::Flow_stmtContext* myParser::Small_stmtContext::flow_stmt() {
  return getRuleContext<myParser::Flow_stmtContext>(0);
}

myParser::Import_stmtContext* myParser::Small_stmtContext::import_stmt() {
  return getRuleContext<myParser::Import_stmtContext>(0);
}

myParser::Global_stmtContext* myParser::Small_stmtContext::global_stmt() {
  return getRuleContext<myParser::Global_stmtContext>(0);
}

myParser::Nonlocal_stmtContext* myParser::Small_stmtContext::nonlocal_stmt() {
  return getRuleContext<myParser::Nonlocal_stmtContext>(0);
}

myParser::Assert_stmtContext* myParser::Small_stmtContext::assert_stmt() {
  return getRuleContext<myParser::Assert_stmtContext>(0);
}


size_t myParser::Small_stmtContext::getRuleIndex() const {
  return myParser::RuleSmall_stmt;
}

void myParser::Small_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSmall_stmt(this);
}

void myParser::Small_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSmall_stmt(this);
}

myParser::Small_stmtContext* myParser::small_stmt() {
  Small_stmtContext *_localctx = _tracker.createInstance<Small_stmtContext>(_ctx, getState());
  enterRule(_localctx, 30, myParser::RuleSmall_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(436);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::STRING:
      case myParser::NUMBER:
      case myParser::LAMBDA:
      case myParser::NOT:
      case myParser::NONE:
      case myParser::TRUE:
      case myParser::FALSE:
      case myParser::AWAIT:
      case myParser::NAME:
      case myParser::ELLIPSIS:
      case myParser::STAR:
      case myParser::OPEN_PAREN:
      case myParser::OPEN_BRACK:
      case myParser::ADD:
      case myParser::MINUS:
      case myParser::NOT_OP:
      case myParser::OPEN_BRACE: {
        setState(428);
        expr_stmt();
        break;
      }

      case myParser::DEL: {
        setState(429);
        del_stmt();
        break;
      }

      case myParser::PASS: {
        setState(430);
        pass_stmt();
        break;
      }

      case myParser::RETURN:
      case myParser::RAISE:
      case myParser::YIELD:
      case myParser::CONTINUE:
      case myParser::BREAK: {
        setState(431);
        flow_stmt();
        break;
      }

      case myParser::FROM:
      case myParser::IMPORT: {
        setState(432);
        import_stmt();
        break;
      }

      case myParser::GLOBAL: {
        setState(433);
        global_stmt();
        break;
      }

      case myParser::NONLOCAL: {
        setState(434);
        nonlocal_stmt();
        break;
      }

      case myParser::ASSERT: {
        setState(435);
        assert_stmt();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_stmtContext ------------------------------------------------------------------

myParser::Expr_stmtContext::Expr_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Testlist_star_exprContext *> myParser::Expr_stmtContext::testlist_star_expr() {
  return getRuleContexts<myParser::Testlist_star_exprContext>();
}

myParser::Testlist_star_exprContext* myParser::Expr_stmtContext::testlist_star_expr(size_t i) {
  return getRuleContext<myParser::Testlist_star_exprContext>(i);
}

myParser::AnnassignContext* myParser::Expr_stmtContext::annassign() {
  return getRuleContext<myParser::AnnassignContext>(0);
}

myParser::AugassignContext* myParser::Expr_stmtContext::augassign() {
  return getRuleContext<myParser::AugassignContext>(0);
}

std::vector<myParser::Yield_exprContext *> myParser::Expr_stmtContext::yield_expr() {
  return getRuleContexts<myParser::Yield_exprContext>();
}

myParser::Yield_exprContext* myParser::Expr_stmtContext::yield_expr(size_t i) {
  return getRuleContext<myParser::Yield_exprContext>(i);
}

myParser::TestlistContext* myParser::Expr_stmtContext::testlist() {
  return getRuleContext<myParser::TestlistContext>(0);
}

std::vector<tree::TerminalNode *> myParser::Expr_stmtContext::ASSIGN() {
  return getTokens(myParser::ASSIGN);
}

tree::TerminalNode* myParser::Expr_stmtContext::ASSIGN(size_t i) {
  return getToken(myParser::ASSIGN, i);
}


size_t myParser::Expr_stmtContext::getRuleIndex() const {
  return myParser::RuleExpr_stmt;
}

void myParser::Expr_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_stmt(this);
}

void myParser::Expr_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_stmt(this);
}

myParser::Expr_stmtContext* myParser::expr_stmt() {
  Expr_stmtContext *_localctx = _tracker.createInstance<Expr_stmtContext>(_ctx, getState());
  enterRule(_localctx, 32, myParser::RuleExpr_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(438);
    testlist_star_expr();
    setState(455);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::COLON: {
        setState(439);
        annassign();
        break;
      }

      case myParser::ADD_ASSIGN:
      case myParser::SUB_ASSIGN:
      case myParser::MULT_ASSIGN:
      case myParser::AT_ASSIGN:
      case myParser::DIV_ASSIGN:
      case myParser::MOD_ASSIGN:
      case myParser::AND_ASSIGN:
      case myParser::OR_ASSIGN:
      case myParser::XOR_ASSIGN:
      case myParser::LEFT_SHIFT_ASSIGN:
      case myParser::RIGHT_SHIFT_ASSIGN:
      case myParser::POWER_ASSIGN:
      case myParser::IDIV_ASSIGN: {
        setState(440);
        augassign();
        setState(443);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case myParser::YIELD: {
            setState(441);
            yield_expr();
            break;
          }

          case myParser::STRING:
          case myParser::NUMBER:
          case myParser::LAMBDA:
          case myParser::NOT:
          case myParser::NONE:
          case myParser::TRUE:
          case myParser::FALSE:
          case myParser::AWAIT:
          case myParser::NAME:
          case myParser::ELLIPSIS:
          case myParser::OPEN_PAREN:
          case myParser::OPEN_BRACK:
          case myParser::ADD:
          case myParser::MINUS:
          case myParser::NOT_OP:
          case myParser::OPEN_BRACE: {
            setState(442);
            testlist();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case myParser::NEWLINE:
      case myParser::SEMI_COLON:
      case myParser::ASSIGN: {
        setState(452);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == myParser::ASSIGN) {
          setState(445);
          match(myParser::ASSIGN);
          setState(448);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case myParser::YIELD: {
              setState(446);
              yield_expr();
              break;
            }

            case myParser::STRING:
            case myParser::NUMBER:
            case myParser::LAMBDA:
            case myParser::NOT:
            case myParser::NONE:
            case myParser::TRUE:
            case myParser::FALSE:
            case myParser::AWAIT:
            case myParser::NAME:
            case myParser::ELLIPSIS:
            case myParser::STAR:
            case myParser::OPEN_PAREN:
            case myParser::OPEN_BRACK:
            case myParser::ADD:
            case myParser::MINUS:
            case myParser::NOT_OP:
            case myParser::OPEN_BRACE: {
              setState(447);
              testlist_star_expr();
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          setState(454);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnnassignContext ------------------------------------------------------------------

myParser::AnnassignContext::AnnassignContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::AnnassignContext::COLON() {
  return getToken(myParser::COLON, 0);
}

std::vector<myParser::TestContext *> myParser::AnnassignContext::test() {
  return getRuleContexts<myParser::TestContext>();
}

myParser::TestContext* myParser::AnnassignContext::test(size_t i) {
  return getRuleContext<myParser::TestContext>(i);
}

tree::TerminalNode* myParser::AnnassignContext::ASSIGN() {
  return getToken(myParser::ASSIGN, 0);
}


size_t myParser::AnnassignContext::getRuleIndex() const {
  return myParser::RuleAnnassign;
}

void myParser::AnnassignContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnnassign(this);
}

void myParser::AnnassignContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnnassign(this);
}

myParser::AnnassignContext* myParser::annassign() {
  AnnassignContext *_localctx = _tracker.createInstance<AnnassignContext>(_ctx, getState());
  enterRule(_localctx, 34, myParser::RuleAnnassign);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(457);
    match(myParser::COLON);
    setState(458);
    test();
    setState(461);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::ASSIGN) {
      setState(459);
      match(myParser::ASSIGN);
      setState(460);
      test();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Testlist_star_exprContext ------------------------------------------------------------------

myParser::Testlist_star_exprContext::Testlist_star_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::TestContext *> myParser::Testlist_star_exprContext::test() {
  return getRuleContexts<myParser::TestContext>();
}

myParser::TestContext* myParser::Testlist_star_exprContext::test(size_t i) {
  return getRuleContext<myParser::TestContext>(i);
}

std::vector<myParser::Star_exprContext *> myParser::Testlist_star_exprContext::star_expr() {
  return getRuleContexts<myParser::Star_exprContext>();
}

myParser::Star_exprContext* myParser::Testlist_star_exprContext::star_expr(size_t i) {
  return getRuleContext<myParser::Star_exprContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Testlist_star_exprContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Testlist_star_exprContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Testlist_star_exprContext::getRuleIndex() const {
  return myParser::RuleTestlist_star_expr;
}

void myParser::Testlist_star_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTestlist_star_expr(this);
}

void myParser::Testlist_star_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTestlist_star_expr(this);
}

myParser::Testlist_star_exprContext* myParser::testlist_star_expr() {
  Testlist_star_exprContext *_localctx = _tracker.createInstance<Testlist_star_exprContext>(_ctx, getState());
  enterRule(_localctx, 36, myParser::RuleTestlist_star_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(465);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::STRING:
      case myParser::NUMBER:
      case myParser::LAMBDA:
      case myParser::NOT:
      case myParser::NONE:
      case myParser::TRUE:
      case myParser::FALSE:
      case myParser::AWAIT:
      case myParser::NAME:
      case myParser::ELLIPSIS:
      case myParser::OPEN_PAREN:
      case myParser::OPEN_BRACK:
      case myParser::ADD:
      case myParser::MINUS:
      case myParser::NOT_OP:
      case myParser::OPEN_BRACE: {
        setState(463);
        test();
        break;
      }

      case myParser::STAR: {
        setState(464);
        star_expr();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(474);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(467);
        match(myParser::COMMA);
        setState(470);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case myParser::STRING:
          case myParser::NUMBER:
          case myParser::LAMBDA:
          case myParser::NOT:
          case myParser::NONE:
          case myParser::TRUE:
          case myParser::FALSE:
          case myParser::AWAIT:
          case myParser::NAME:
          case myParser::ELLIPSIS:
          case myParser::OPEN_PAREN:
          case myParser::OPEN_BRACK:
          case myParser::ADD:
          case myParser::MINUS:
          case myParser::NOT_OP:
          case myParser::OPEN_BRACE: {
            setState(468);
            test();
            break;
          }

          case myParser::STAR: {
            setState(469);
            star_expr();
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(476);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx);
    }
    setState(478);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::COMMA) {
      setState(477);
      match(myParser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AugassignContext ------------------------------------------------------------------

myParser::AugassignContext::AugassignContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::AugassignContext::ADD_ASSIGN() {
  return getToken(myParser::ADD_ASSIGN, 0);
}

tree::TerminalNode* myParser::AugassignContext::SUB_ASSIGN() {
  return getToken(myParser::SUB_ASSIGN, 0);
}

tree::TerminalNode* myParser::AugassignContext::MULT_ASSIGN() {
  return getToken(myParser::MULT_ASSIGN, 0);
}

tree::TerminalNode* myParser::AugassignContext::AT_ASSIGN() {
  return getToken(myParser::AT_ASSIGN, 0);
}

tree::TerminalNode* myParser::AugassignContext::DIV_ASSIGN() {
  return getToken(myParser::DIV_ASSIGN, 0);
}

tree::TerminalNode* myParser::AugassignContext::MOD_ASSIGN() {
  return getToken(myParser::MOD_ASSIGN, 0);
}

tree::TerminalNode* myParser::AugassignContext::AND_ASSIGN() {
  return getToken(myParser::AND_ASSIGN, 0);
}

tree::TerminalNode* myParser::AugassignContext::OR_ASSIGN() {
  return getToken(myParser::OR_ASSIGN, 0);
}

tree::TerminalNode* myParser::AugassignContext::XOR_ASSIGN() {
  return getToken(myParser::XOR_ASSIGN, 0);
}

tree::TerminalNode* myParser::AugassignContext::LEFT_SHIFT_ASSIGN() {
  return getToken(myParser::LEFT_SHIFT_ASSIGN, 0);
}

tree::TerminalNode* myParser::AugassignContext::RIGHT_SHIFT_ASSIGN() {
  return getToken(myParser::RIGHT_SHIFT_ASSIGN, 0);
}

tree::TerminalNode* myParser::AugassignContext::POWER_ASSIGN() {
  return getToken(myParser::POWER_ASSIGN, 0);
}

tree::TerminalNode* myParser::AugassignContext::IDIV_ASSIGN() {
  return getToken(myParser::IDIV_ASSIGN, 0);
}


size_t myParser::AugassignContext::getRuleIndex() const {
  return myParser::RuleAugassign;
}

void myParser::AugassignContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAugassign(this);
}

void myParser::AugassignContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAugassign(this);
}

myParser::AugassignContext* myParser::augassign() {
  AugassignContext *_localctx = _tracker.createInstance<AugassignContext>(_ctx, getState());
  enterRule(_localctx, 38, myParser::RuleAugassign);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(480);
    _la = _input->LA(1);
    if (!((((_la - 83) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 83)) & 8191) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Del_stmtContext ------------------------------------------------------------------

myParser::Del_stmtContext::Del_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Del_stmtContext::DEL() {
  return getToken(myParser::DEL, 0);
}

myParser::ExprlistContext* myParser::Del_stmtContext::exprlist() {
  return getRuleContext<myParser::ExprlistContext>(0);
}


size_t myParser::Del_stmtContext::getRuleIndex() const {
  return myParser::RuleDel_stmt;
}

void myParser::Del_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDel_stmt(this);
}

void myParser::Del_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDel_stmt(this);
}

myParser::Del_stmtContext* myParser::del_stmt() {
  Del_stmtContext *_localctx = _tracker.createInstance<Del_stmtContext>(_ctx, getState());
  enterRule(_localctx, 40, myParser::RuleDel_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(482);
    match(myParser::DEL);
    setState(483);
    exprlist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pass_stmtContext ------------------------------------------------------------------

myParser::Pass_stmtContext::Pass_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Pass_stmtContext::PASS() {
  return getToken(myParser::PASS, 0);
}


size_t myParser::Pass_stmtContext::getRuleIndex() const {
  return myParser::RulePass_stmt;
}

void myParser::Pass_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPass_stmt(this);
}

void myParser::Pass_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPass_stmt(this);
}

myParser::Pass_stmtContext* myParser::pass_stmt() {
  Pass_stmtContext *_localctx = _tracker.createInstance<Pass_stmtContext>(_ctx, getState());
  enterRule(_localctx, 42, myParser::RulePass_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(485);
    match(myParser::PASS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Flow_stmtContext ------------------------------------------------------------------

myParser::Flow_stmtContext::Flow_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Break_stmtContext* myParser::Flow_stmtContext::break_stmt() {
  return getRuleContext<myParser::Break_stmtContext>(0);
}

myParser::Continue_stmtContext* myParser::Flow_stmtContext::continue_stmt() {
  return getRuleContext<myParser::Continue_stmtContext>(0);
}

myParser::Return_stmtContext* myParser::Flow_stmtContext::return_stmt() {
  return getRuleContext<myParser::Return_stmtContext>(0);
}

myParser::Raise_stmtContext* myParser::Flow_stmtContext::raise_stmt() {
  return getRuleContext<myParser::Raise_stmtContext>(0);
}

myParser::Yield_stmtContext* myParser::Flow_stmtContext::yield_stmt() {
  return getRuleContext<myParser::Yield_stmtContext>(0);
}


size_t myParser::Flow_stmtContext::getRuleIndex() const {
  return myParser::RuleFlow_stmt;
}

void myParser::Flow_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFlow_stmt(this);
}

void myParser::Flow_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFlow_stmt(this);
}

myParser::Flow_stmtContext* myParser::flow_stmt() {
  Flow_stmtContext *_localctx = _tracker.createInstance<Flow_stmtContext>(_ctx, getState());
  enterRule(_localctx, 44, myParser::RuleFlow_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(492);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::BREAK: {
        enterOuterAlt(_localctx, 1);
        setState(487);
        break_stmt();
        break;
      }

      case myParser::CONTINUE: {
        enterOuterAlt(_localctx, 2);
        setState(488);
        continue_stmt();
        break;
      }

      case myParser::RETURN: {
        enterOuterAlt(_localctx, 3);
        setState(489);
        return_stmt();
        break;
      }

      case myParser::RAISE: {
        enterOuterAlt(_localctx, 4);
        setState(490);
        raise_stmt();
        break;
      }

      case myParser::YIELD: {
        enterOuterAlt(_localctx, 5);
        setState(491);
        yield_stmt();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Break_stmtContext ------------------------------------------------------------------

myParser::Break_stmtContext::Break_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Break_stmtContext::BREAK() {
  return getToken(myParser::BREAK, 0);
}


size_t myParser::Break_stmtContext::getRuleIndex() const {
  return myParser::RuleBreak_stmt;
}

void myParser::Break_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBreak_stmt(this);
}

void myParser::Break_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBreak_stmt(this);
}

myParser::Break_stmtContext* myParser::break_stmt() {
  Break_stmtContext *_localctx = _tracker.createInstance<Break_stmtContext>(_ctx, getState());
  enterRule(_localctx, 46, myParser::RuleBreak_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(494);
    match(myParser::BREAK);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Continue_stmtContext ------------------------------------------------------------------

myParser::Continue_stmtContext::Continue_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Continue_stmtContext::CONTINUE() {
  return getToken(myParser::CONTINUE, 0);
}


size_t myParser::Continue_stmtContext::getRuleIndex() const {
  return myParser::RuleContinue_stmt;
}

void myParser::Continue_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContinue_stmt(this);
}

void myParser::Continue_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContinue_stmt(this);
}

myParser::Continue_stmtContext* myParser::continue_stmt() {
  Continue_stmtContext *_localctx = _tracker.createInstance<Continue_stmtContext>(_ctx, getState());
  enterRule(_localctx, 48, myParser::RuleContinue_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(496);
    match(myParser::CONTINUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Return_stmtContext ------------------------------------------------------------------

myParser::Return_stmtContext::Return_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Return_stmtContext::RETURN() {
  return getToken(myParser::RETURN, 0);
}

myParser::TestlistContext* myParser::Return_stmtContext::testlist() {
  return getRuleContext<myParser::TestlistContext>(0);
}


size_t myParser::Return_stmtContext::getRuleIndex() const {
  return myParser::RuleReturn_stmt;
}

void myParser::Return_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturn_stmt(this);
}

void myParser::Return_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturn_stmt(this);
}

myParser::Return_stmtContext* myParser::return_stmt() {
  Return_stmtContext *_localctx = _tracker.createInstance<Return_stmtContext>(_ctx, getState());
  enterRule(_localctx, 50, myParser::RuleReturn_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(498);
    match(myParser::RETURN);
    setState(500);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 582091628181716998) != 0 || (((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 99) != 0) {
      setState(499);
      testlist();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Yield_stmtContext ------------------------------------------------------------------

myParser::Yield_stmtContext::Yield_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Yield_exprContext* myParser::Yield_stmtContext::yield_expr() {
  return getRuleContext<myParser::Yield_exprContext>(0);
}


size_t myParser::Yield_stmtContext::getRuleIndex() const {
  return myParser::RuleYield_stmt;
}

void myParser::Yield_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterYield_stmt(this);
}

void myParser::Yield_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitYield_stmt(this);
}

myParser::Yield_stmtContext* myParser::yield_stmt() {
  Yield_stmtContext *_localctx = _tracker.createInstance<Yield_stmtContext>(_ctx, getState());
  enterRule(_localctx, 52, myParser::RuleYield_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(502);
    yield_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Raise_stmtContext ------------------------------------------------------------------

myParser::Raise_stmtContext::Raise_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Raise_stmtContext::RAISE() {
  return getToken(myParser::RAISE, 0);
}

std::vector<myParser::TestContext *> myParser::Raise_stmtContext::test() {
  return getRuleContexts<myParser::TestContext>();
}

myParser::TestContext* myParser::Raise_stmtContext::test(size_t i) {
  return getRuleContext<myParser::TestContext>(i);
}

tree::TerminalNode* myParser::Raise_stmtContext::FROM() {
  return getToken(myParser::FROM, 0);
}


size_t myParser::Raise_stmtContext::getRuleIndex() const {
  return myParser::RuleRaise_stmt;
}

void myParser::Raise_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRaise_stmt(this);
}

void myParser::Raise_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRaise_stmt(this);
}

myParser::Raise_stmtContext* myParser::raise_stmt() {
  Raise_stmtContext *_localctx = _tracker.createInstance<Raise_stmtContext>(_ctx, getState());
  enterRule(_localctx, 54, myParser::RuleRaise_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(504);
    match(myParser::RAISE);
    setState(510);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 582091628181716998) != 0 || (((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 99) != 0) {
      setState(505);
      test();
      setState(508);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::FROM) {
        setState(506);
        match(myParser::FROM);
        setState(507);
        test();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_stmtContext ------------------------------------------------------------------

myParser::Import_stmtContext::Import_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Import_nameContext* myParser::Import_stmtContext::import_name() {
  return getRuleContext<myParser::Import_nameContext>(0);
}

myParser::Import_fromContext* myParser::Import_stmtContext::import_from() {
  return getRuleContext<myParser::Import_fromContext>(0);
}


size_t myParser::Import_stmtContext::getRuleIndex() const {
  return myParser::RuleImport_stmt;
}

void myParser::Import_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_stmt(this);
}

void myParser::Import_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_stmt(this);
}

myParser::Import_stmtContext* myParser::import_stmt() {
  Import_stmtContext *_localctx = _tracker.createInstance<Import_stmtContext>(_ctx, getState());
  enterRule(_localctx, 56, myParser::RuleImport_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(514);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::IMPORT: {
        enterOuterAlt(_localctx, 1);
        setState(512);
        import_name();
        break;
      }

      case myParser::FROM: {
        enterOuterAlt(_localctx, 2);
        setState(513);
        import_from();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_nameContext ------------------------------------------------------------------

myParser::Import_nameContext::Import_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Import_nameContext::IMPORT() {
  return getToken(myParser::IMPORT, 0);
}

myParser::Dotted_as_namesContext* myParser::Import_nameContext::dotted_as_names() {
  return getRuleContext<myParser::Dotted_as_namesContext>(0);
}


size_t myParser::Import_nameContext::getRuleIndex() const {
  return myParser::RuleImport_name;
}

void myParser::Import_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_name(this);
}

void myParser::Import_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_name(this);
}

myParser::Import_nameContext* myParser::import_name() {
  Import_nameContext *_localctx = _tracker.createInstance<Import_nameContext>(_ctx, getState());
  enterRule(_localctx, 58, myParser::RuleImport_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(516);
    match(myParser::IMPORT);
    setState(517);
    dotted_as_names();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_fromContext ------------------------------------------------------------------

myParser::Import_fromContext::Import_fromContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Import_fromContext::FROM() {
  return getToken(myParser::FROM, 0);
}

tree::TerminalNode* myParser::Import_fromContext::IMPORT() {
  return getToken(myParser::IMPORT, 0);
}

myParser::Dotted_nameContext* myParser::Import_fromContext::dotted_name() {
  return getRuleContext<myParser::Dotted_nameContext>(0);
}

tree::TerminalNode* myParser::Import_fromContext::STAR() {
  return getToken(myParser::STAR, 0);
}

tree::TerminalNode* myParser::Import_fromContext::OPEN_PAREN() {
  return getToken(myParser::OPEN_PAREN, 0);
}

myParser::Import_as_namesContext* myParser::Import_fromContext::import_as_names() {
  return getRuleContext<myParser::Import_as_namesContext>(0);
}

tree::TerminalNode* myParser::Import_fromContext::CLOSE_PAREN() {
  return getToken(myParser::CLOSE_PAREN, 0);
}

std::vector<tree::TerminalNode *> myParser::Import_fromContext::DOT() {
  return getTokens(myParser::DOT);
}

tree::TerminalNode* myParser::Import_fromContext::DOT(size_t i) {
  return getToken(myParser::DOT, i);
}

std::vector<tree::TerminalNode *> myParser::Import_fromContext::ELLIPSIS() {
  return getTokens(myParser::ELLIPSIS);
}

tree::TerminalNode* myParser::Import_fromContext::ELLIPSIS(size_t i) {
  return getToken(myParser::ELLIPSIS, i);
}


size_t myParser::Import_fromContext::getRuleIndex() const {
  return myParser::RuleImport_from;
}

void myParser::Import_fromContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_from(this);
}

void myParser::Import_fromContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_from(this);
}

myParser::Import_fromContext* myParser::import_from() {
  Import_fromContext *_localctx = _tracker.createInstance<Import_fromContext>(_ctx, getState());
  enterRule(_localctx, 60, myParser::RuleImport_from);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(519);
    match(myParser::FROM);
    setState(532);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx)) {
    case 1: {
      setState(523);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == myParser::DOT

      || _la == myParser::ELLIPSIS) {
        setState(520);
        _la = _input->LA(1);
        if (!(_la == myParser::DOT

        || _la == myParser::ELLIPSIS)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(525);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(526);
      dotted_name();
      break;
    }

    case 2: {
      setState(528); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(527);
        _la = _input->LA(1);
        if (!(_la == myParser::DOT

        || _la == myParser::ELLIPSIS)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(530); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == myParser::DOT

      || _la == myParser::ELLIPSIS);
      break;
    }

    default:
      break;
    }
    setState(534);
    match(myParser::IMPORT);
    setState(541);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::STAR: {
        setState(535);
        match(myParser::STAR);
        break;
      }

      case myParser::OPEN_PAREN: {
        setState(536);
        match(myParser::OPEN_PAREN);
        setState(537);
        import_as_names();
        setState(538);
        match(myParser::CLOSE_PAREN);
        break;
      }

      case myParser::NAME: {
        setState(540);
        import_as_names();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_as_nameContext ------------------------------------------------------------------

myParser::Import_as_nameContext::Import_as_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> myParser::Import_as_nameContext::NAME() {
  return getTokens(myParser::NAME);
}

tree::TerminalNode* myParser::Import_as_nameContext::NAME(size_t i) {
  return getToken(myParser::NAME, i);
}

tree::TerminalNode* myParser::Import_as_nameContext::AS() {
  return getToken(myParser::AS, 0);
}


size_t myParser::Import_as_nameContext::getRuleIndex() const {
  return myParser::RuleImport_as_name;
}

void myParser::Import_as_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_as_name(this);
}

void myParser::Import_as_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_as_name(this);
}

myParser::Import_as_nameContext* myParser::import_as_name() {
  Import_as_nameContext *_localctx = _tracker.createInstance<Import_as_nameContext>(_ctx, getState());
  enterRule(_localctx, 62, myParser::RuleImport_as_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(543);
    match(myParser::NAME);
    setState(546);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AS) {
      setState(544);
      match(myParser::AS);
      setState(545);
      match(myParser::NAME);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dotted_as_nameContext ------------------------------------------------------------------

myParser::Dotted_as_nameContext::Dotted_as_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Dotted_nameContext* myParser::Dotted_as_nameContext::dotted_name() {
  return getRuleContext<myParser::Dotted_nameContext>(0);
}

tree::TerminalNode* myParser::Dotted_as_nameContext::AS() {
  return getToken(myParser::AS, 0);
}

tree::TerminalNode* myParser::Dotted_as_nameContext::NAME() {
  return getToken(myParser::NAME, 0);
}


size_t myParser::Dotted_as_nameContext::getRuleIndex() const {
  return myParser::RuleDotted_as_name;
}

void myParser::Dotted_as_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDotted_as_name(this);
}

void myParser::Dotted_as_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDotted_as_name(this);
}

myParser::Dotted_as_nameContext* myParser::dotted_as_name() {
  Dotted_as_nameContext *_localctx = _tracker.createInstance<Dotted_as_nameContext>(_ctx, getState());
  enterRule(_localctx, 64, myParser::RuleDotted_as_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(548);
    dotted_name();
    setState(551);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AS) {
      setState(549);
      match(myParser::AS);
      setState(550);
      match(myParser::NAME);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_as_namesContext ------------------------------------------------------------------

myParser::Import_as_namesContext::Import_as_namesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Import_as_nameContext *> myParser::Import_as_namesContext::import_as_name() {
  return getRuleContexts<myParser::Import_as_nameContext>();
}

myParser::Import_as_nameContext* myParser::Import_as_namesContext::import_as_name(size_t i) {
  return getRuleContext<myParser::Import_as_nameContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Import_as_namesContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Import_as_namesContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Import_as_namesContext::getRuleIndex() const {
  return myParser::RuleImport_as_names;
}

void myParser::Import_as_namesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_as_names(this);
}

void myParser::Import_as_namesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_as_names(this);
}

myParser::Import_as_namesContext* myParser::import_as_names() {
  Import_as_namesContext *_localctx = _tracker.createInstance<Import_as_namesContext>(_ctx, getState());
  enterRule(_localctx, 66, myParser::RuleImport_as_names);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(553);
    import_as_name();
    setState(558);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(554);
        match(myParser::COMMA);
        setState(555);
        import_as_name(); 
      }
      setState(560);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx);
    }
    setState(562);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::COMMA) {
      setState(561);
      match(myParser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dotted_as_namesContext ------------------------------------------------------------------

myParser::Dotted_as_namesContext::Dotted_as_namesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Dotted_as_nameContext *> myParser::Dotted_as_namesContext::dotted_as_name() {
  return getRuleContexts<myParser::Dotted_as_nameContext>();
}

myParser::Dotted_as_nameContext* myParser::Dotted_as_namesContext::dotted_as_name(size_t i) {
  return getRuleContext<myParser::Dotted_as_nameContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Dotted_as_namesContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Dotted_as_namesContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Dotted_as_namesContext::getRuleIndex() const {
  return myParser::RuleDotted_as_names;
}

void myParser::Dotted_as_namesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDotted_as_names(this);
}

void myParser::Dotted_as_namesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDotted_as_names(this);
}

myParser::Dotted_as_namesContext* myParser::dotted_as_names() {
  Dotted_as_namesContext *_localctx = _tracker.createInstance<Dotted_as_namesContext>(_ctx, getState());
  enterRule(_localctx, 68, myParser::RuleDotted_as_names);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(564);
    dotted_as_name();
    setState(569);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(565);
      match(myParser::COMMA);
      setState(566);
      dotted_as_name();
      setState(571);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dotted_nameContext ------------------------------------------------------------------

myParser::Dotted_nameContext::Dotted_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> myParser::Dotted_nameContext::NAME() {
  return getTokens(myParser::NAME);
}

tree::TerminalNode* myParser::Dotted_nameContext::NAME(size_t i) {
  return getToken(myParser::NAME, i);
}

std::vector<tree::TerminalNode *> myParser::Dotted_nameContext::DOT() {
  return getTokens(myParser::DOT);
}

tree::TerminalNode* myParser::Dotted_nameContext::DOT(size_t i) {
  return getToken(myParser::DOT, i);
}


size_t myParser::Dotted_nameContext::getRuleIndex() const {
  return myParser::RuleDotted_name;
}

void myParser::Dotted_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDotted_name(this);
}

void myParser::Dotted_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDotted_name(this);
}

myParser::Dotted_nameContext* myParser::dotted_name() {
  Dotted_nameContext *_localctx = _tracker.createInstance<Dotted_nameContext>(_ctx, getState());
  enterRule(_localctx, 70, myParser::RuleDotted_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(572);
    match(myParser::NAME);
    setState(577);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::DOT) {
      setState(573);
      match(myParser::DOT);
      setState(574);
      match(myParser::NAME);
      setState(579);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Global_stmtContext ------------------------------------------------------------------

myParser::Global_stmtContext::Global_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Global_stmtContext::GLOBAL() {
  return getToken(myParser::GLOBAL, 0);
}

std::vector<tree::TerminalNode *> myParser::Global_stmtContext::NAME() {
  return getTokens(myParser::NAME);
}

tree::TerminalNode* myParser::Global_stmtContext::NAME(size_t i) {
  return getToken(myParser::NAME, i);
}

std::vector<tree::TerminalNode *> myParser::Global_stmtContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Global_stmtContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Global_stmtContext::getRuleIndex() const {
  return myParser::RuleGlobal_stmt;
}

void myParser::Global_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGlobal_stmt(this);
}

void myParser::Global_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGlobal_stmt(this);
}

myParser::Global_stmtContext* myParser::global_stmt() {
  Global_stmtContext *_localctx = _tracker.createInstance<Global_stmtContext>(_ctx, getState());
  enterRule(_localctx, 72, myParser::RuleGlobal_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(580);
    match(myParser::GLOBAL);
    setState(581);
    match(myParser::NAME);
    setState(586);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(582);
      match(myParser::COMMA);
      setState(583);
      match(myParser::NAME);
      setState(588);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nonlocal_stmtContext ------------------------------------------------------------------

myParser::Nonlocal_stmtContext::Nonlocal_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Nonlocal_stmtContext::NONLOCAL() {
  return getToken(myParser::NONLOCAL, 0);
}

std::vector<tree::TerminalNode *> myParser::Nonlocal_stmtContext::NAME() {
  return getTokens(myParser::NAME);
}

tree::TerminalNode* myParser::Nonlocal_stmtContext::NAME(size_t i) {
  return getToken(myParser::NAME, i);
}

std::vector<tree::TerminalNode *> myParser::Nonlocal_stmtContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Nonlocal_stmtContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Nonlocal_stmtContext::getRuleIndex() const {
  return myParser::RuleNonlocal_stmt;
}

void myParser::Nonlocal_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNonlocal_stmt(this);
}

void myParser::Nonlocal_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNonlocal_stmt(this);
}

myParser::Nonlocal_stmtContext* myParser::nonlocal_stmt() {
  Nonlocal_stmtContext *_localctx = _tracker.createInstance<Nonlocal_stmtContext>(_ctx, getState());
  enterRule(_localctx, 74, myParser::RuleNonlocal_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(589);
    match(myParser::NONLOCAL);
    setState(590);
    match(myParser::NAME);
    setState(595);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(591);
      match(myParser::COMMA);
      setState(592);
      match(myParser::NAME);
      setState(597);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assert_stmtContext ------------------------------------------------------------------

myParser::Assert_stmtContext::Assert_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Assert_stmtContext::ASSERT() {
  return getToken(myParser::ASSERT, 0);
}

std::vector<myParser::TestContext *> myParser::Assert_stmtContext::test() {
  return getRuleContexts<myParser::TestContext>();
}

myParser::TestContext* myParser::Assert_stmtContext::test(size_t i) {
  return getRuleContext<myParser::TestContext>(i);
}

tree::TerminalNode* myParser::Assert_stmtContext::COMMA() {
  return getToken(myParser::COMMA, 0);
}


size_t myParser::Assert_stmtContext::getRuleIndex() const {
  return myParser::RuleAssert_stmt;
}

void myParser::Assert_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssert_stmt(this);
}

void myParser::Assert_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssert_stmt(this);
}

myParser::Assert_stmtContext* myParser::assert_stmt() {
  Assert_stmtContext *_localctx = _tracker.createInstance<Assert_stmtContext>(_ctx, getState());
  enterRule(_localctx, 76, myParser::RuleAssert_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(598);
    match(myParser::ASSERT);
    setState(599);
    test();
    setState(602);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::COMMA) {
      setState(600);
      match(myParser::COMMA);
      setState(601);
      test();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Compound_stmtContext ------------------------------------------------------------------

myParser::Compound_stmtContext::Compound_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::If_stmtContext* myParser::Compound_stmtContext::if_stmt() {
  return getRuleContext<myParser::If_stmtContext>(0);
}

myParser::While_stmtContext* myParser::Compound_stmtContext::while_stmt() {
  return getRuleContext<myParser::While_stmtContext>(0);
}

myParser::For_stmtContext* myParser::Compound_stmtContext::for_stmt() {
  return getRuleContext<myParser::For_stmtContext>(0);
}

myParser::Try_stmtContext* myParser::Compound_stmtContext::try_stmt() {
  return getRuleContext<myParser::Try_stmtContext>(0);
}

myParser::With_stmtContext* myParser::Compound_stmtContext::with_stmt() {
  return getRuleContext<myParser::With_stmtContext>(0);
}

myParser::FuncdefContext* myParser::Compound_stmtContext::funcdef() {
  return getRuleContext<myParser::FuncdefContext>(0);
}

myParser::ClassdefContext* myParser::Compound_stmtContext::classdef() {
  return getRuleContext<myParser::ClassdefContext>(0);
}

myParser::DecoratedContext* myParser::Compound_stmtContext::decorated() {
  return getRuleContext<myParser::DecoratedContext>(0);
}

myParser::Async_stmtContext* myParser::Compound_stmtContext::async_stmt() {
  return getRuleContext<myParser::Async_stmtContext>(0);
}


size_t myParser::Compound_stmtContext::getRuleIndex() const {
  return myParser::RuleCompound_stmt;
}

void myParser::Compound_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompound_stmt(this);
}

void myParser::Compound_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompound_stmt(this);
}

myParser::Compound_stmtContext* myParser::compound_stmt() {
  Compound_stmtContext *_localctx = _tracker.createInstance<Compound_stmtContext>(_ctx, getState());
  enterRule(_localctx, 78, myParser::RuleCompound_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(613);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::IF: {
        enterOuterAlt(_localctx, 1);
        setState(604);
        if_stmt();
        break;
      }

      case myParser::WHILE: {
        enterOuterAlt(_localctx, 2);
        setState(605);
        while_stmt();
        break;
      }

      case myParser::FOR: {
        enterOuterAlt(_localctx, 3);
        setState(606);
        for_stmt();
        break;
      }

      case myParser::TRY: {
        enterOuterAlt(_localctx, 4);
        setState(607);
        try_stmt();
        break;
      }

      case myParser::WITH: {
        enterOuterAlt(_localctx, 5);
        setState(608);
        with_stmt();
        break;
      }

      case myParser::DEF: {
        enterOuterAlt(_localctx, 6);
        setState(609);
        funcdef();
        break;
      }

      case myParser::CLASS: {
        enterOuterAlt(_localctx, 7);
        setState(610);
        classdef();
        break;
      }

      case myParser::AT: {
        enterOuterAlt(_localctx, 8);
        setState(611);
        decorated();
        break;
      }

      case myParser::ASYNC: {
        enterOuterAlt(_localctx, 9);
        setState(612);
        async_stmt();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Async_stmtContext ------------------------------------------------------------------

myParser::Async_stmtContext::Async_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Async_stmtContext::ASYNC() {
  return getToken(myParser::ASYNC, 0);
}

myParser::FuncdefContext* myParser::Async_stmtContext::funcdef() {
  return getRuleContext<myParser::FuncdefContext>(0);
}

myParser::With_stmtContext* myParser::Async_stmtContext::with_stmt() {
  return getRuleContext<myParser::With_stmtContext>(0);
}

myParser::For_stmtContext* myParser::Async_stmtContext::for_stmt() {
  return getRuleContext<myParser::For_stmtContext>(0);
}


size_t myParser::Async_stmtContext::getRuleIndex() const {
  return myParser::RuleAsync_stmt;
}

void myParser::Async_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAsync_stmt(this);
}

void myParser::Async_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAsync_stmt(this);
}

myParser::Async_stmtContext* myParser::async_stmt() {
  Async_stmtContext *_localctx = _tracker.createInstance<Async_stmtContext>(_ctx, getState());
  enterRule(_localctx, 80, myParser::RuleAsync_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(615);
    match(myParser::ASYNC);
    setState(619);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::DEF: {
        setState(616);
        funcdef();
        break;
      }

      case myParser::WITH: {
        setState(617);
        with_stmt();
        break;
      }

      case myParser::FOR: {
        setState(618);
        for_stmt();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_stmtContext ------------------------------------------------------------------

myParser::If_stmtContext::If_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::If_stmtContext::IF() {
  return getToken(myParser::IF, 0);
}

std::vector<myParser::TestContext *> myParser::If_stmtContext::test() {
  return getRuleContexts<myParser::TestContext>();
}

myParser::TestContext* myParser::If_stmtContext::test(size_t i) {
  return getRuleContext<myParser::TestContext>(i);
}

std::vector<tree::TerminalNode *> myParser::If_stmtContext::COLON() {
  return getTokens(myParser::COLON);
}

tree::TerminalNode* myParser::If_stmtContext::COLON(size_t i) {
  return getToken(myParser::COLON, i);
}

std::vector<myParser::SuiteContext *> myParser::If_stmtContext::suite() {
  return getRuleContexts<myParser::SuiteContext>();
}

myParser::SuiteContext* myParser::If_stmtContext::suite(size_t i) {
  return getRuleContext<myParser::SuiteContext>(i);
}

std::vector<tree::TerminalNode *> myParser::If_stmtContext::ELIF() {
  return getTokens(myParser::ELIF);
}

tree::TerminalNode* myParser::If_stmtContext::ELIF(size_t i) {
  return getToken(myParser::ELIF, i);
}

tree::TerminalNode* myParser::If_stmtContext::ELSE() {
  return getToken(myParser::ELSE, 0);
}


size_t myParser::If_stmtContext::getRuleIndex() const {
  return myParser::RuleIf_stmt;
}

void myParser::If_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_stmt(this);
}

void myParser::If_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_stmt(this);
}

myParser::If_stmtContext* myParser::if_stmt() {
  If_stmtContext *_localctx = _tracker.createInstance<If_stmtContext>(_ctx, getState());
  enterRule(_localctx, 82, myParser::RuleIf_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(621);
    match(myParser::IF);
    setState(622);
    test();
    setState(623);
    match(myParser::COLON);
    setState(624);
    suite();
    setState(632);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::ELIF) {
      setState(625);
      match(myParser::ELIF);
      setState(626);
      test();
      setState(627);
      match(myParser::COLON);
      setState(628);
      suite();
      setState(634);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(638);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::ELSE) {
      setState(635);
      match(myParser::ELSE);
      setState(636);
      match(myParser::COLON);
      setState(637);
      suite();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- While_stmtContext ------------------------------------------------------------------

myParser::While_stmtContext::While_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::While_stmtContext::WHILE() {
  return getToken(myParser::WHILE, 0);
}

myParser::TestContext* myParser::While_stmtContext::test() {
  return getRuleContext<myParser::TestContext>(0);
}

std::vector<tree::TerminalNode *> myParser::While_stmtContext::COLON() {
  return getTokens(myParser::COLON);
}

tree::TerminalNode* myParser::While_stmtContext::COLON(size_t i) {
  return getToken(myParser::COLON, i);
}

std::vector<myParser::SuiteContext *> myParser::While_stmtContext::suite() {
  return getRuleContexts<myParser::SuiteContext>();
}

myParser::SuiteContext* myParser::While_stmtContext::suite(size_t i) {
  return getRuleContext<myParser::SuiteContext>(i);
}

tree::TerminalNode* myParser::While_stmtContext::ELSE() {
  return getToken(myParser::ELSE, 0);
}


size_t myParser::While_stmtContext::getRuleIndex() const {
  return myParser::RuleWhile_stmt;
}

void myParser::While_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhile_stmt(this);
}

void myParser::While_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhile_stmt(this);
}

myParser::While_stmtContext* myParser::while_stmt() {
  While_stmtContext *_localctx = _tracker.createInstance<While_stmtContext>(_ctx, getState());
  enterRule(_localctx, 84, myParser::RuleWhile_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(640);
    match(myParser::WHILE);
    setState(641);
    test();
    setState(642);
    match(myParser::COLON);
    setState(643);
    suite();
    setState(647);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::ELSE) {
      setState(644);
      match(myParser::ELSE);
      setState(645);
      match(myParser::COLON);
      setState(646);
      suite();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_stmtContext ------------------------------------------------------------------

myParser::For_stmtContext::For_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::For_stmtContext::FOR() {
  return getToken(myParser::FOR, 0);
}

myParser::ExprlistContext* myParser::For_stmtContext::exprlist() {
  return getRuleContext<myParser::ExprlistContext>(0);
}

tree::TerminalNode* myParser::For_stmtContext::IN() {
  return getToken(myParser::IN, 0);
}

myParser::TestlistContext* myParser::For_stmtContext::testlist() {
  return getRuleContext<myParser::TestlistContext>(0);
}

std::vector<tree::TerminalNode *> myParser::For_stmtContext::COLON() {
  return getTokens(myParser::COLON);
}

tree::TerminalNode* myParser::For_stmtContext::COLON(size_t i) {
  return getToken(myParser::COLON, i);
}

std::vector<myParser::SuiteContext *> myParser::For_stmtContext::suite() {
  return getRuleContexts<myParser::SuiteContext>();
}

myParser::SuiteContext* myParser::For_stmtContext::suite(size_t i) {
  return getRuleContext<myParser::SuiteContext>(i);
}

tree::TerminalNode* myParser::For_stmtContext::ELSE() {
  return getToken(myParser::ELSE, 0);
}


size_t myParser::For_stmtContext::getRuleIndex() const {
  return myParser::RuleFor_stmt;
}

void myParser::For_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFor_stmt(this);
}

void myParser::For_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFor_stmt(this);
}

myParser::For_stmtContext* myParser::for_stmt() {
  For_stmtContext *_localctx = _tracker.createInstance<For_stmtContext>(_ctx, getState());
  enterRule(_localctx, 86, myParser::RuleFor_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(649);
    match(myParser::FOR);
    setState(650);
    exprlist();
    setState(651);
    match(myParser::IN);
    setState(652);
    testlist();
    setState(653);
    match(myParser::COLON);
    setState(654);
    suite();
    setState(658);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::ELSE) {
      setState(655);
      match(myParser::ELSE);
      setState(656);
      match(myParser::COLON);
      setState(657);
      suite();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Try_stmtContext ------------------------------------------------------------------

myParser::Try_stmtContext::Try_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Try_stmtContext::TRY() {
  return getToken(myParser::TRY, 0);
}

std::vector<tree::TerminalNode *> myParser::Try_stmtContext::COLON() {
  return getTokens(myParser::COLON);
}

tree::TerminalNode* myParser::Try_stmtContext::COLON(size_t i) {
  return getToken(myParser::COLON, i);
}

std::vector<myParser::SuiteContext *> myParser::Try_stmtContext::suite() {
  return getRuleContexts<myParser::SuiteContext>();
}

myParser::SuiteContext* myParser::Try_stmtContext::suite(size_t i) {
  return getRuleContext<myParser::SuiteContext>(i);
}

tree::TerminalNode* myParser::Try_stmtContext::FINALLY() {
  return getToken(myParser::FINALLY, 0);
}

std::vector<myParser::Except_clauseContext *> myParser::Try_stmtContext::except_clause() {
  return getRuleContexts<myParser::Except_clauseContext>();
}

myParser::Except_clauseContext* myParser::Try_stmtContext::except_clause(size_t i) {
  return getRuleContext<myParser::Except_clauseContext>(i);
}

tree::TerminalNode* myParser::Try_stmtContext::ELSE() {
  return getToken(myParser::ELSE, 0);
}


size_t myParser::Try_stmtContext::getRuleIndex() const {
  return myParser::RuleTry_stmt;
}

void myParser::Try_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTry_stmt(this);
}

void myParser::Try_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTry_stmt(this);
}

myParser::Try_stmtContext* myParser::try_stmt() {
  Try_stmtContext *_localctx = _tracker.createInstance<Try_stmtContext>(_ctx, getState());
  enterRule(_localctx, 88, myParser::RuleTry_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(660);
    match(myParser::TRY);
    setState(661);
    match(myParser::COLON);
    setState(662);
    suite();
    setState(684);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::EXCEPT: {
        setState(667); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(663);
          except_clause();
          setState(664);
          match(myParser::COLON);
          setState(665);
          suite();
          setState(669); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == myParser::EXCEPT);
        setState(674);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::ELSE) {
          setState(671);
          match(myParser::ELSE);
          setState(672);
          match(myParser::COLON);
          setState(673);
          suite();
        }
        setState(679);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::FINALLY) {
          setState(676);
          match(myParser::FINALLY);
          setState(677);
          match(myParser::COLON);
          setState(678);
          suite();
        }
        break;
      }

      case myParser::FINALLY: {
        setState(681);
        match(myParser::FINALLY);
        setState(682);
        match(myParser::COLON);
        setState(683);
        suite();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_stmtContext ------------------------------------------------------------------

myParser::With_stmtContext::With_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::With_stmtContext::WITH() {
  return getToken(myParser::WITH, 0);
}

std::vector<myParser::With_itemContext *> myParser::With_stmtContext::with_item() {
  return getRuleContexts<myParser::With_itemContext>();
}

myParser::With_itemContext* myParser::With_stmtContext::with_item(size_t i) {
  return getRuleContext<myParser::With_itemContext>(i);
}

tree::TerminalNode* myParser::With_stmtContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::SuiteContext* myParser::With_stmtContext::suite() {
  return getRuleContext<myParser::SuiteContext>(0);
}

std::vector<tree::TerminalNode *> myParser::With_stmtContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::With_stmtContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::With_stmtContext::getRuleIndex() const {
  return myParser::RuleWith_stmt;
}

void myParser::With_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWith_stmt(this);
}

void myParser::With_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWith_stmt(this);
}

myParser::With_stmtContext* myParser::with_stmt() {
  With_stmtContext *_localctx = _tracker.createInstance<With_stmtContext>(_ctx, getState());
  enterRule(_localctx, 90, myParser::RuleWith_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(686);
    match(myParser::WITH);
    setState(687);
    with_item();
    setState(692);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::COMMA) {
      setState(688);
      match(myParser::COMMA);
      setState(689);
      with_item();
      setState(694);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(695);
    match(myParser::COLON);
    setState(696);
    suite();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_itemContext ------------------------------------------------------------------

myParser::With_itemContext::With_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::TestContext* myParser::With_itemContext::test() {
  return getRuleContext<myParser::TestContext>(0);
}

tree::TerminalNode* myParser::With_itemContext::AS() {
  return getToken(myParser::AS, 0);
}

myParser::ExprContext* myParser::With_itemContext::expr() {
  return getRuleContext<myParser::ExprContext>(0);
}


size_t myParser::With_itemContext::getRuleIndex() const {
  return myParser::RuleWith_item;
}

void myParser::With_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWith_item(this);
}

void myParser::With_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWith_item(this);
}

myParser::With_itemContext* myParser::with_item() {
  With_itemContext *_localctx = _tracker.createInstance<With_itemContext>(_ctx, getState());
  enterRule(_localctx, 92, myParser::RuleWith_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(698);
    test();
    setState(701);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AS) {
      setState(699);
      match(myParser::AS);
      setState(700);
      expr();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Except_clauseContext ------------------------------------------------------------------

myParser::Except_clauseContext::Except_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Except_clauseContext::EXCEPT() {
  return getToken(myParser::EXCEPT, 0);
}

myParser::TestContext* myParser::Except_clauseContext::test() {
  return getRuleContext<myParser::TestContext>(0);
}

tree::TerminalNode* myParser::Except_clauseContext::AS() {
  return getToken(myParser::AS, 0);
}

tree::TerminalNode* myParser::Except_clauseContext::NAME() {
  return getToken(myParser::NAME, 0);
}


size_t myParser::Except_clauseContext::getRuleIndex() const {
  return myParser::RuleExcept_clause;
}

void myParser::Except_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExcept_clause(this);
}

void myParser::Except_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExcept_clause(this);
}

myParser::Except_clauseContext* myParser::except_clause() {
  Except_clauseContext *_localctx = _tracker.createInstance<Except_clauseContext>(_ctx, getState());
  enterRule(_localctx, 94, myParser::RuleExcept_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(703);
    match(myParser::EXCEPT);
    setState(709);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 582091628181716998) != 0 || (((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 99) != 0) {
      setState(704);
      test();
      setState(707);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::AS) {
        setState(705);
        match(myParser::AS);
        setState(706);
        match(myParser::NAME);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SuiteContext ------------------------------------------------------------------

myParser::SuiteContext::SuiteContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Simple_stmtContext* myParser::SuiteContext::simple_stmt() {
  return getRuleContext<myParser::Simple_stmtContext>(0);
}

tree::TerminalNode* myParser::SuiteContext::NEWLINE() {
  return getToken(myParser::NEWLINE, 0);
}

tree::TerminalNode* myParser::SuiteContext::INDENT() {
  return getToken(myParser::INDENT, 0);
}

tree::TerminalNode* myParser::SuiteContext::DEDENT() {
  return getToken(myParser::DEDENT, 0);
}

std::vector<myParser::StmtContext *> myParser::SuiteContext::stmt() {
  return getRuleContexts<myParser::StmtContext>();
}

myParser::StmtContext* myParser::SuiteContext::stmt(size_t i) {
  return getRuleContext<myParser::StmtContext>(i);
}


size_t myParser::SuiteContext::getRuleIndex() const {
  return myParser::RuleSuite;
}

void myParser::SuiteContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSuite(this);
}

void myParser::SuiteContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSuite(this);
}

myParser::SuiteContext* myParser::suite() {
  SuiteContext *_localctx = _tracker.createInstance<SuiteContext>(_ctx, getState());
  enterRule(_localctx, 96, myParser::RuleSuite);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(721);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::STRING:
      case myParser::NUMBER:
      case myParser::RETURN:
      case myParser::RAISE:
      case myParser::FROM:
      case myParser::IMPORT:
      case myParser::GLOBAL:
      case myParser::NONLOCAL:
      case myParser::ASSERT:
      case myParser::LAMBDA:
      case myParser::NOT:
      case myParser::NONE:
      case myParser::TRUE:
      case myParser::FALSE:
      case myParser::YIELD:
      case myParser::DEL:
      case myParser::PASS:
      case myParser::CONTINUE:
      case myParser::BREAK:
      case myParser::AWAIT:
      case myParser::NAME:
      case myParser::ELLIPSIS:
      case myParser::STAR:
      case myParser::OPEN_PAREN:
      case myParser::OPEN_BRACK:
      case myParser::ADD:
      case myParser::MINUS:
      case myParser::NOT_OP:
      case myParser::OPEN_BRACE: {
        enterOuterAlt(_localctx, 1);
        setState(711);
        simple_stmt();
        break;
      }

      case myParser::NEWLINE: {
        enterOuterAlt(_localctx, 2);
        setState(712);
        match(myParser::NEWLINE);
        setState(713);
        match(myParser::INDENT);
        setState(715); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(714);
          stmt();
          setState(717); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 584343700728659446) != 0 || (((_la - 66) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 66)) & 32867) != 0);
        setState(719);
        match(myParser::DEDENT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TestContext ------------------------------------------------------------------

myParser::TestContext::TestContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Or_testContext *> myParser::TestContext::or_test() {
  return getRuleContexts<myParser::Or_testContext>();
}

myParser::Or_testContext* myParser::TestContext::or_test(size_t i) {
  return getRuleContext<myParser::Or_testContext>(i);
}

tree::TerminalNode* myParser::TestContext::IF() {
  return getToken(myParser::IF, 0);
}

tree::TerminalNode* myParser::TestContext::ELSE() {
  return getToken(myParser::ELSE, 0);
}

myParser::TestContext* myParser::TestContext::test() {
  return getRuleContext<myParser::TestContext>(0);
}

myParser::LambdefContext* myParser::TestContext::lambdef() {
  return getRuleContext<myParser::LambdefContext>(0);
}


size_t myParser::TestContext::getRuleIndex() const {
  return myParser::RuleTest;
}

void myParser::TestContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTest(this);
}

void myParser::TestContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTest(this);
}

myParser::TestContext* myParser::test() {
  TestContext *_localctx = _tracker.createInstance<TestContext>(_ctx, getState());
  enterRule(_localctx, 98, myParser::RuleTest);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(732);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::STRING:
      case myParser::NUMBER:
      case myParser::NOT:
      case myParser::NONE:
      case myParser::TRUE:
      case myParser::FALSE:
      case myParser::AWAIT:
      case myParser::NAME:
      case myParser::ELLIPSIS:
      case myParser::OPEN_PAREN:
      case myParser::OPEN_BRACK:
      case myParser::ADD:
      case myParser::MINUS:
      case myParser::NOT_OP:
      case myParser::OPEN_BRACE: {
        enterOuterAlt(_localctx, 1);
        setState(723);
        or_test();
        setState(729);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::IF) {
          setState(724);
          match(myParser::IF);
          setState(725);
          or_test();
          setState(726);
          match(myParser::ELSE);
          setState(727);
          test();
        }
        break;
      }

      case myParser::LAMBDA: {
        enterOuterAlt(_localctx, 2);
        setState(731);
        lambdef();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Test_nocondContext ------------------------------------------------------------------

myParser::Test_nocondContext::Test_nocondContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Or_testContext* myParser::Test_nocondContext::or_test() {
  return getRuleContext<myParser::Or_testContext>(0);
}

myParser::Lambdef_nocondContext* myParser::Test_nocondContext::lambdef_nocond() {
  return getRuleContext<myParser::Lambdef_nocondContext>(0);
}


size_t myParser::Test_nocondContext::getRuleIndex() const {
  return myParser::RuleTest_nocond;
}

void myParser::Test_nocondContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTest_nocond(this);
}

void myParser::Test_nocondContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTest_nocond(this);
}

myParser::Test_nocondContext* myParser::test_nocond() {
  Test_nocondContext *_localctx = _tracker.createInstance<Test_nocondContext>(_ctx, getState());
  enterRule(_localctx, 100, myParser::RuleTest_nocond);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(736);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::STRING:
      case myParser::NUMBER:
      case myParser::NOT:
      case myParser::NONE:
      case myParser::TRUE:
      case myParser::FALSE:
      case myParser::AWAIT:
      case myParser::NAME:
      case myParser::ELLIPSIS:
      case myParser::OPEN_PAREN:
      case myParser::OPEN_BRACK:
      case myParser::ADD:
      case myParser::MINUS:
      case myParser::NOT_OP:
      case myParser::OPEN_BRACE: {
        enterOuterAlt(_localctx, 1);
        setState(734);
        or_test();
        break;
      }

      case myParser::LAMBDA: {
        enterOuterAlt(_localctx, 2);
        setState(735);
        lambdef_nocond();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LambdefContext ------------------------------------------------------------------

myParser::LambdefContext::LambdefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::LambdefContext::LAMBDA() {
  return getToken(myParser::LAMBDA, 0);
}

tree::TerminalNode* myParser::LambdefContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::TestContext* myParser::LambdefContext::test() {
  return getRuleContext<myParser::TestContext>(0);
}

myParser::VarargslistContext* myParser::LambdefContext::varargslist() {
  return getRuleContext<myParser::VarargslistContext>(0);
}


size_t myParser::LambdefContext::getRuleIndex() const {
  return myParser::RuleLambdef;
}

void myParser::LambdefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLambdef(this);
}

void myParser::LambdefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLambdef(this);
}

myParser::LambdefContext* myParser::lambdef() {
  LambdefContext *_localctx = _tracker.createInstance<LambdefContext>(_ctx, getState());
  enterRule(_localctx, 102, myParser::RuleLambdef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(738);
    match(myParser::LAMBDA);
    setState(740);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 146368087401168896) != 0) {
      setState(739);
      varargslist();
    }
    setState(742);
    match(myParser::COLON);
    setState(743);
    test();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Lambdef_nocondContext ------------------------------------------------------------------

myParser::Lambdef_nocondContext::Lambdef_nocondContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Lambdef_nocondContext::LAMBDA() {
  return getToken(myParser::LAMBDA, 0);
}

tree::TerminalNode* myParser::Lambdef_nocondContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::Test_nocondContext* myParser::Lambdef_nocondContext::test_nocond() {
  return getRuleContext<myParser::Test_nocondContext>(0);
}

myParser::VarargslistContext* myParser::Lambdef_nocondContext::varargslist() {
  return getRuleContext<myParser::VarargslistContext>(0);
}


size_t myParser::Lambdef_nocondContext::getRuleIndex() const {
  return myParser::RuleLambdef_nocond;
}

void myParser::Lambdef_nocondContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLambdef_nocond(this);
}

void myParser::Lambdef_nocondContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLambdef_nocond(this);
}

myParser::Lambdef_nocondContext* myParser::lambdef_nocond() {
  Lambdef_nocondContext *_localctx = _tracker.createInstance<Lambdef_nocondContext>(_ctx, getState());
  enterRule(_localctx, 104, myParser::RuleLambdef_nocond);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(745);
    match(myParser::LAMBDA);
    setState(747);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 146368087401168896) != 0) {
      setState(746);
      varargslist();
    }
    setState(749);
    match(myParser::COLON);
    setState(750);
    test_nocond();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Or_testContext ------------------------------------------------------------------

myParser::Or_testContext::Or_testContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::And_testContext *> myParser::Or_testContext::and_test() {
  return getRuleContexts<myParser::And_testContext>();
}

myParser::And_testContext* myParser::Or_testContext::and_test(size_t i) {
  return getRuleContext<myParser::And_testContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Or_testContext::OR() {
  return getTokens(myParser::OR);
}

tree::TerminalNode* myParser::Or_testContext::OR(size_t i) {
  return getToken(myParser::OR, i);
}


size_t myParser::Or_testContext::getRuleIndex() const {
  return myParser::RuleOr_test;
}

void myParser::Or_testContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOr_test(this);
}

void myParser::Or_testContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOr_test(this);
}

myParser::Or_testContext* myParser::or_test() {
  Or_testContext *_localctx = _tracker.createInstance<Or_testContext>(_ctx, getState());
  enterRule(_localctx, 106, myParser::RuleOr_test);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(752);
    and_test();
    setState(757);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::OR) {
      setState(753);
      match(myParser::OR);
      setState(754);
      and_test();
      setState(759);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- And_testContext ------------------------------------------------------------------

myParser::And_testContext::And_testContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Not_testContext *> myParser::And_testContext::not_test() {
  return getRuleContexts<myParser::Not_testContext>();
}

myParser::Not_testContext* myParser::And_testContext::not_test(size_t i) {
  return getRuleContext<myParser::Not_testContext>(i);
}

std::vector<tree::TerminalNode *> myParser::And_testContext::AND() {
  return getTokens(myParser::AND);
}

tree::TerminalNode* myParser::And_testContext::AND(size_t i) {
  return getToken(myParser::AND, i);
}


size_t myParser::And_testContext::getRuleIndex() const {
  return myParser::RuleAnd_test;
}

void myParser::And_testContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnd_test(this);
}

void myParser::And_testContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnd_test(this);
}

myParser::And_testContext* myParser::and_test() {
  And_testContext *_localctx = _tracker.createInstance<And_testContext>(_ctx, getState());
  enterRule(_localctx, 108, myParser::RuleAnd_test);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(760);
    not_test();
    setState(765);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::AND) {
      setState(761);
      match(myParser::AND);
      setState(762);
      not_test();
      setState(767);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Not_testContext ------------------------------------------------------------------

myParser::Not_testContext::Not_testContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Not_testContext::NOT() {
  return getToken(myParser::NOT, 0);
}

myParser::Not_testContext* myParser::Not_testContext::not_test() {
  return getRuleContext<myParser::Not_testContext>(0);
}

myParser::ComparisonContext* myParser::Not_testContext::comparison() {
  return getRuleContext<myParser::ComparisonContext>(0);
}


size_t myParser::Not_testContext::getRuleIndex() const {
  return myParser::RuleNot_test;
}

void myParser::Not_testContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNot_test(this);
}

void myParser::Not_testContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNot_test(this);
}

myParser::Not_testContext* myParser::not_test() {
  Not_testContext *_localctx = _tracker.createInstance<Not_testContext>(_ctx, getState());
  enterRule(_localctx, 110, myParser::RuleNot_test);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(771);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::NOT: {
        enterOuterAlt(_localctx, 1);
        setState(768);
        match(myParser::NOT);
        setState(769);
        not_test();
        break;
      }

      case myParser::STRING:
      case myParser::NUMBER:
      case myParser::NONE:
      case myParser::TRUE:
      case myParser::FALSE:
      case myParser::AWAIT:
      case myParser::NAME:
      case myParser::ELLIPSIS:
      case myParser::OPEN_PAREN:
      case myParser::OPEN_BRACK:
      case myParser::ADD:
      case myParser::MINUS:
      case myParser::NOT_OP:
      case myParser::OPEN_BRACE: {
        enterOuterAlt(_localctx, 2);
        setState(770);
        comparison();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComparisonContext ------------------------------------------------------------------

myParser::ComparisonContext::ComparisonContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::ExprContext *> myParser::ComparisonContext::expr() {
  return getRuleContexts<myParser::ExprContext>();
}

myParser::ExprContext* myParser::ComparisonContext::expr(size_t i) {
  return getRuleContext<myParser::ExprContext>(i);
}

std::vector<myParser::Comp_opContext *> myParser::ComparisonContext::comp_op() {
  return getRuleContexts<myParser::Comp_opContext>();
}

myParser::Comp_opContext* myParser::ComparisonContext::comp_op(size_t i) {
  return getRuleContext<myParser::Comp_opContext>(i);
}


size_t myParser::ComparisonContext::getRuleIndex() const {
  return myParser::RuleComparison;
}

void myParser::ComparisonContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparison(this);
}

void myParser::ComparisonContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparison(this);
}

myParser::ComparisonContext* myParser::comparison() {
  ComparisonContext *_localctx = _tracker.createInstance<ComparisonContext>(_ctx, getState());
  enterRule(_localctx, 112, myParser::RuleComparison);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(773);
    expr();
    setState(779);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la - 18) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 18)) & 9151314442816848641) != 0) {
      setState(774);
      comp_op();
      setState(775);
      expr();
      setState(781);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comp_opContext ------------------------------------------------------------------

myParser::Comp_opContext::Comp_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Comp_opContext::LESS_THAN() {
  return getToken(myParser::LESS_THAN, 0);
}

tree::TerminalNode* myParser::Comp_opContext::GREATER_THAN() {
  return getToken(myParser::GREATER_THAN, 0);
}

tree::TerminalNode* myParser::Comp_opContext::EQUALS() {
  return getToken(myParser::EQUALS, 0);
}

tree::TerminalNode* myParser::Comp_opContext::GT_EQ() {
  return getToken(myParser::GT_EQ, 0);
}

tree::TerminalNode* myParser::Comp_opContext::LT_EQ() {
  return getToken(myParser::LT_EQ, 0);
}

tree::TerminalNode* myParser::Comp_opContext::NOT_EQ_1() {
  return getToken(myParser::NOT_EQ_1, 0);
}

tree::TerminalNode* myParser::Comp_opContext::NOT_EQ_2() {
  return getToken(myParser::NOT_EQ_2, 0);
}

tree::TerminalNode* myParser::Comp_opContext::IN() {
  return getToken(myParser::IN, 0);
}

tree::TerminalNode* myParser::Comp_opContext::NOT() {
  return getToken(myParser::NOT, 0);
}

tree::TerminalNode* myParser::Comp_opContext::IS() {
  return getToken(myParser::IS, 0);
}


size_t myParser::Comp_opContext::getRuleIndex() const {
  return myParser::RuleComp_op;
}

void myParser::Comp_opContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComp_op(this);
}

void myParser::Comp_opContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComp_op(this);
}

myParser::Comp_opContext* myParser::comp_op() {
  Comp_opContext *_localctx = _tracker.createInstance<Comp_opContext>(_ctx, getState());
  enterRule(_localctx, 114, myParser::RuleComp_op);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(795);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(782);
      match(myParser::LESS_THAN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(783);
      match(myParser::GREATER_THAN);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(784);
      match(myParser::EQUALS);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(785);
      match(myParser::GT_EQ);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(786);
      match(myParser::LT_EQ);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(787);
      match(myParser::NOT_EQ_1);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(788);
      match(myParser::NOT_EQ_2);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(789);
      match(myParser::IN);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(790);
      match(myParser::NOT);
      setState(791);
      match(myParser::IN);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(792);
      match(myParser::IS);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(793);
      match(myParser::IS);
      setState(794);
      match(myParser::NOT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Star_exprContext ------------------------------------------------------------------

myParser::Star_exprContext::Star_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Star_exprContext::STAR() {
  return getToken(myParser::STAR, 0);
}

myParser::ExprContext* myParser::Star_exprContext::expr() {
  return getRuleContext<myParser::ExprContext>(0);
}


size_t myParser::Star_exprContext::getRuleIndex() const {
  return myParser::RuleStar_expr;
}

void myParser::Star_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStar_expr(this);
}

void myParser::Star_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStar_expr(this);
}

myParser::Star_exprContext* myParser::star_expr() {
  Star_exprContext *_localctx = _tracker.createInstance<Star_exprContext>(_ctx, getState());
  enterRule(_localctx, 116, myParser::RuleStar_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(797);
    match(myParser::STAR);
    setState(798);
    expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprContext ------------------------------------------------------------------

myParser::ExprContext::ExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Xor_exprContext *> myParser::ExprContext::xor_expr() {
  return getRuleContexts<myParser::Xor_exprContext>();
}

myParser::Xor_exprContext* myParser::ExprContext::xor_expr(size_t i) {
  return getRuleContext<myParser::Xor_exprContext>(i);
}

std::vector<tree::TerminalNode *> myParser::ExprContext::OR_OP() {
  return getTokens(myParser::OR_OP);
}

tree::TerminalNode* myParser::ExprContext::OR_OP(size_t i) {
  return getToken(myParser::OR_OP, i);
}


size_t myParser::ExprContext::getRuleIndex() const {
  return myParser::RuleExpr;
}

void myParser::ExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr(this);
}

void myParser::ExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr(this);
}

myParser::ExprContext* myParser::expr() {
  ExprContext *_localctx = _tracker.createInstance<ExprContext>(_ctx, getState());
  enterRule(_localctx, 118, myParser::RuleExpr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(800);
    xor_expr();
    setState(805);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::OR_OP) {
      setState(801);
      match(myParser::OR_OP);
      setState(802);
      xor_expr();
      setState(807);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xor_exprContext ------------------------------------------------------------------

myParser::Xor_exprContext::Xor_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::And_exprContext *> myParser::Xor_exprContext::and_expr() {
  return getRuleContexts<myParser::And_exprContext>();
}

myParser::And_exprContext* myParser::Xor_exprContext::and_expr(size_t i) {
  return getRuleContext<myParser::And_exprContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Xor_exprContext::XOR() {
  return getTokens(myParser::XOR);
}

tree::TerminalNode* myParser::Xor_exprContext::XOR(size_t i) {
  return getToken(myParser::XOR, i);
}


size_t myParser::Xor_exprContext::getRuleIndex() const {
  return myParser::RuleXor_expr;
}

void myParser::Xor_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXor_expr(this);
}

void myParser::Xor_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXor_expr(this);
}

myParser::Xor_exprContext* myParser::xor_expr() {
  Xor_exprContext *_localctx = _tracker.createInstance<Xor_exprContext>(_ctx, getState());
  enterRule(_localctx, 120, myParser::RuleXor_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(808);
    and_expr();
    setState(813);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::XOR) {
      setState(809);
      match(myParser::XOR);
      setState(810);
      and_expr();
      setState(815);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- And_exprContext ------------------------------------------------------------------

myParser::And_exprContext::And_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Shift_exprContext *> myParser::And_exprContext::shift_expr() {
  return getRuleContexts<myParser::Shift_exprContext>();
}

myParser::Shift_exprContext* myParser::And_exprContext::shift_expr(size_t i) {
  return getRuleContext<myParser::Shift_exprContext>(i);
}

std::vector<tree::TerminalNode *> myParser::And_exprContext::AND_OP() {
  return getTokens(myParser::AND_OP);
}

tree::TerminalNode* myParser::And_exprContext::AND_OP(size_t i) {
  return getToken(myParser::AND_OP, i);
}


size_t myParser::And_exprContext::getRuleIndex() const {
  return myParser::RuleAnd_expr;
}

void myParser::And_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnd_expr(this);
}

void myParser::And_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnd_expr(this);
}

myParser::And_exprContext* myParser::and_expr() {
  And_exprContext *_localctx = _tracker.createInstance<And_exprContext>(_ctx, getState());
  enterRule(_localctx, 122, myParser::RuleAnd_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(816);
    shift_expr();
    setState(821);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::AND_OP) {
      setState(817);
      match(myParser::AND_OP);
      setState(818);
      shift_expr();
      setState(823);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Shift_exprContext ------------------------------------------------------------------

myParser::Shift_exprContext::Shift_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Arith_exprContext *> myParser::Shift_exprContext::arith_expr() {
  return getRuleContexts<myParser::Arith_exprContext>();
}

myParser::Arith_exprContext* myParser::Shift_exprContext::arith_expr(size_t i) {
  return getRuleContext<myParser::Arith_exprContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Shift_exprContext::LEFT_SHIFT() {
  return getTokens(myParser::LEFT_SHIFT);
}

tree::TerminalNode* myParser::Shift_exprContext::LEFT_SHIFT(size_t i) {
  return getToken(myParser::LEFT_SHIFT, i);
}

std::vector<tree::TerminalNode *> myParser::Shift_exprContext::RIGHT_SHIFT() {
  return getTokens(myParser::RIGHT_SHIFT);
}

tree::TerminalNode* myParser::Shift_exprContext::RIGHT_SHIFT(size_t i) {
  return getToken(myParser::RIGHT_SHIFT, i);
}


size_t myParser::Shift_exprContext::getRuleIndex() const {
  return myParser::RuleShift_expr;
}

void myParser::Shift_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShift_expr(this);
}

void myParser::Shift_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShift_expr(this);
}

myParser::Shift_exprContext* myParser::shift_expr() {
  Shift_exprContext *_localctx = _tracker.createInstance<Shift_exprContext>(_ctx, getState());
  enterRule(_localctx, 124, myParser::RuleShift_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(824);
    arith_expr();
    setState(829);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::LEFT_SHIFT

    || _la == myParser::RIGHT_SHIFT) {
      setState(825);
      _la = _input->LA(1);
      if (!(_la == myParser::LEFT_SHIFT

      || _la == myParser::RIGHT_SHIFT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(826);
      arith_expr();
      setState(831);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Arith_exprContext ------------------------------------------------------------------

myParser::Arith_exprContext::Arith_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::TermContext *> myParser::Arith_exprContext::term() {
  return getRuleContexts<myParser::TermContext>();
}

myParser::TermContext* myParser::Arith_exprContext::term(size_t i) {
  return getRuleContext<myParser::TermContext>(i);
}

std::vector<tree::TerminalNode *> myParser::Arith_exprContext::ADD() {
  return getTokens(myParser::ADD);
}

tree::TerminalNode* myParser::Arith_exprContext::ADD(size_t i) {
  return getToken(myParser::ADD, i);
}

std::vector<tree::TerminalNode *> myParser::Arith_exprContext::MINUS() {
  return getTokens(myParser::MINUS);
}

tree::TerminalNode* myParser::Arith_exprContext::MINUS(size_t i) {
  return getToken(myParser::MINUS, i);
}


size_t myParser::Arith_exprContext::getRuleIndex() const {
  return myParser::RuleArith_expr;
}

void myParser::Arith_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArith_expr(this);
}

void myParser::Arith_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArith_expr(this);
}

myParser::Arith_exprContext* myParser::arith_expr() {
  Arith_exprContext *_localctx = _tracker.createInstance<Arith_exprContext>(_ctx, getState());
  enterRule(_localctx, 126, myParser::RuleArith_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(832);
    term();
    setState(837);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::ADD

    || _la == myParser::MINUS) {
      setState(833);
      _la = _input->LA(1);
      if (!(_la == myParser::ADD

      || _la == myParser::MINUS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(834);
      term();
      setState(839);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TermContext ------------------------------------------------------------------

myParser::TermContext::TermContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::FactorContext *> myParser::TermContext::factor() {
  return getRuleContexts<myParser::FactorContext>();
}

myParser::FactorContext* myParser::TermContext::factor(size_t i) {
  return getRuleContext<myParser::FactorContext>(i);
}

std::vector<tree::TerminalNode *> myParser::TermContext::STAR() {
  return getTokens(myParser::STAR);
}

tree::TerminalNode* myParser::TermContext::STAR(size_t i) {
  return getToken(myParser::STAR, i);
}

std::vector<tree::TerminalNode *> myParser::TermContext::AT() {
  return getTokens(myParser::AT);
}

tree::TerminalNode* myParser::TermContext::AT(size_t i) {
  return getToken(myParser::AT, i);
}

std::vector<tree::TerminalNode *> myParser::TermContext::DIV() {
  return getTokens(myParser::DIV);
}

tree::TerminalNode* myParser::TermContext::DIV(size_t i) {
  return getToken(myParser::DIV, i);
}

std::vector<tree::TerminalNode *> myParser::TermContext::MOD() {
  return getTokens(myParser::MOD);
}

tree::TerminalNode* myParser::TermContext::MOD(size_t i) {
  return getToken(myParser::MOD, i);
}

std::vector<tree::TerminalNode *> myParser::TermContext::IDIV() {
  return getTokens(myParser::IDIV);
}

tree::TerminalNode* myParser::TermContext::IDIV(size_t i) {
  return getToken(myParser::IDIV, i);
}


size_t myParser::TermContext::getRuleIndex() const {
  return myParser::RuleTerm;
}

void myParser::TermContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTerm(this);
}

void myParser::TermContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTerm(this);
}

myParser::TermContext* myParser::term() {
  TermContext *_localctx = _tracker.createInstance<TermContext>(_ctx, getState());
  enterRule(_localctx, 128, myParser::RuleTerm);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(840);
    factor();
    setState(845);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la - 51) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 51)) & 1074659329) != 0) {
      setState(841);
      _la = _input->LA(1);
      if (!((((_la - 51) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 51)) & 1074659329) != 0)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(842);
      factor();
      setState(847);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FactorContext ------------------------------------------------------------------

myParser::FactorContext::FactorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::FactorContext* myParser::FactorContext::factor() {
  return getRuleContext<myParser::FactorContext>(0);
}

tree::TerminalNode* myParser::FactorContext::ADD() {
  return getToken(myParser::ADD, 0);
}

tree::TerminalNode* myParser::FactorContext::MINUS() {
  return getToken(myParser::MINUS, 0);
}

tree::TerminalNode* myParser::FactorContext::NOT_OP() {
  return getToken(myParser::NOT_OP, 0);
}

myParser::PowerContext* myParser::FactorContext::power() {
  return getRuleContext<myParser::PowerContext>(0);
}


size_t myParser::FactorContext::getRuleIndex() const {
  return myParser::RuleFactor;
}

void myParser::FactorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFactor(this);
}

void myParser::FactorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFactor(this);
}

myParser::FactorContext* myParser::factor() {
  FactorContext *_localctx = _tracker.createInstance<FactorContext>(_ctx, getState());
  enterRule(_localctx, 130, myParser::RuleFactor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(851);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::ADD:
      case myParser::MINUS:
      case myParser::NOT_OP: {
        enterOuterAlt(_localctx, 1);
        setState(848);
        _la = _input->LA(1);
        if (!((((_la - 66) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 66)) & 35) != 0)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(849);
        factor();
        break;
      }

      case myParser::STRING:
      case myParser::NUMBER:
      case myParser::NONE:
      case myParser::TRUE:
      case myParser::FALSE:
      case myParser::AWAIT:
      case myParser::NAME:
      case myParser::ELLIPSIS:
      case myParser::OPEN_PAREN:
      case myParser::OPEN_BRACK:
      case myParser::OPEN_BRACE: {
        enterOuterAlt(_localctx, 2);
        setState(850);
        power();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PowerContext ------------------------------------------------------------------

myParser::PowerContext::PowerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Atom_exprContext* myParser::PowerContext::atom_expr() {
  return getRuleContext<myParser::Atom_exprContext>(0);
}

tree::TerminalNode* myParser::PowerContext::POWER() {
  return getToken(myParser::POWER, 0);
}

myParser::FactorContext* myParser::PowerContext::factor() {
  return getRuleContext<myParser::FactorContext>(0);
}


size_t myParser::PowerContext::getRuleIndex() const {
  return myParser::RulePower;
}

void myParser::PowerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPower(this);
}

void myParser::PowerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPower(this);
}

myParser::PowerContext* myParser::power() {
  PowerContext *_localctx = _tracker.createInstance<PowerContext>(_ctx, getState());
  enterRule(_localctx, 132, myParser::RulePower);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(853);
    atom_expr();
    setState(856);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::POWER) {
      setState(854);
      match(myParser::POWER);
      setState(855);
      factor();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Atom_exprContext ------------------------------------------------------------------

myParser::Atom_exprContext::Atom_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::AtomContext* myParser::Atom_exprContext::atom() {
  return getRuleContext<myParser::AtomContext>(0);
}

tree::TerminalNode* myParser::Atom_exprContext::AWAIT() {
  return getToken(myParser::AWAIT, 0);
}

std::vector<myParser::TrailerContext *> myParser::Atom_exprContext::trailer() {
  return getRuleContexts<myParser::TrailerContext>();
}

myParser::TrailerContext* myParser::Atom_exprContext::trailer(size_t i) {
  return getRuleContext<myParser::TrailerContext>(i);
}


size_t myParser::Atom_exprContext::getRuleIndex() const {
  return myParser::RuleAtom_expr;
}

void myParser::Atom_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom_expr(this);
}

void myParser::Atom_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom_expr(this);
}

myParser::Atom_exprContext* myParser::atom_expr() {
  Atom_exprContext *_localctx = _tracker.createInstance<Atom_exprContext>(_ctx, getState());
  enterRule(_localctx, 134, myParser::RuleAtom_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(859);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::AWAIT) {
      setState(858);
      match(myParser::AWAIT);
    }
    setState(861);
    atom();
    setState(865);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 581527301884215296) != 0) {
      setState(862);
      trailer();
      setState(867);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AtomContext ------------------------------------------------------------------

myParser::AtomContext::AtomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::AtomContext::OPEN_PAREN() {
  return getToken(myParser::OPEN_PAREN, 0);
}

tree::TerminalNode* myParser::AtomContext::CLOSE_PAREN() {
  return getToken(myParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* myParser::AtomContext::OPEN_BRACK() {
  return getToken(myParser::OPEN_BRACK, 0);
}

tree::TerminalNode* myParser::AtomContext::CLOSE_BRACK() {
  return getToken(myParser::CLOSE_BRACK, 0);
}

tree::TerminalNode* myParser::AtomContext::OPEN_BRACE() {
  return getToken(myParser::OPEN_BRACE, 0);
}

tree::TerminalNode* myParser::AtomContext::CLOSE_BRACE() {
  return getToken(myParser::CLOSE_BRACE, 0);
}

tree::TerminalNode* myParser::AtomContext::NAME() {
  return getToken(myParser::NAME, 0);
}

tree::TerminalNode* myParser::AtomContext::NUMBER() {
  return getToken(myParser::NUMBER, 0);
}

tree::TerminalNode* myParser::AtomContext::ELLIPSIS() {
  return getToken(myParser::ELLIPSIS, 0);
}

tree::TerminalNode* myParser::AtomContext::NONE() {
  return getToken(myParser::NONE, 0);
}

tree::TerminalNode* myParser::AtomContext::TRUE() {
  return getToken(myParser::TRUE, 0);
}

tree::TerminalNode* myParser::AtomContext::FALSE() {
  return getToken(myParser::FALSE, 0);
}

myParser::Yield_exprContext* myParser::AtomContext::yield_expr() {
  return getRuleContext<myParser::Yield_exprContext>(0);
}

myParser::Testlist_compContext* myParser::AtomContext::testlist_comp() {
  return getRuleContext<myParser::Testlist_compContext>(0);
}

myParser::DictorsetmakerContext* myParser::AtomContext::dictorsetmaker() {
  return getRuleContext<myParser::DictorsetmakerContext>(0);
}

std::vector<tree::TerminalNode *> myParser::AtomContext::STRING() {
  return getTokens(myParser::STRING);
}

tree::TerminalNode* myParser::AtomContext::STRING(size_t i) {
  return getToken(myParser::STRING, i);
}


size_t myParser::AtomContext::getRuleIndex() const {
  return myParser::RuleAtom;
}

void myParser::AtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom(this);
}

void myParser::AtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom(this);
}

myParser::AtomContext* myParser::atom() {
  AtomContext *_localctx = _tracker.createInstance<AtomContext>(_ctx, getState());
  enterRule(_localctx, 136, myParser::RuleAtom);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(895);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::OPEN_PAREN: {
        setState(868);
        match(myParser::OPEN_PAREN);
        setState(871);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case myParser::YIELD: {
            setState(869);
            yield_expr();
            break;
          }

          case myParser::STRING:
          case myParser::NUMBER:
          case myParser::LAMBDA:
          case myParser::NOT:
          case myParser::NONE:
          case myParser::TRUE:
          case myParser::FALSE:
          case myParser::AWAIT:
          case myParser::NAME:
          case myParser::ELLIPSIS:
          case myParser::STAR:
          case myParser::OPEN_PAREN:
          case myParser::OPEN_BRACK:
          case myParser::ADD:
          case myParser::MINUS:
          case myParser::NOT_OP:
          case myParser::OPEN_BRACE: {
            setState(870);
            testlist_comp();
            break;
          }

          case myParser::CLOSE_PAREN: {
            break;
          }

        default:
          break;
        }
        setState(873);
        match(myParser::CLOSE_PAREN);
        break;
      }

      case myParser::OPEN_BRACK: {
        setState(874);
        match(myParser::OPEN_BRACK);
        setState(876);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 584343427995402246) != 0 || (((_la - 66) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 66)) & 99) != 0) {
          setState(875);
          testlist_comp();
        }
        setState(878);
        match(myParser::CLOSE_BRACK);
        break;
      }

      case myParser::OPEN_BRACE: {
        setState(879);
        match(myParser::OPEN_BRACE);
        setState(881);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 728458616071258118) != 0 || (((_la - 66) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 66)) & 99) != 0) {
          setState(880);
          dictorsetmaker();
        }
        setState(883);
        match(myParser::CLOSE_BRACE);
        break;
      }

      case myParser::NAME: {
        setState(884);
        match(myParser::NAME);
        break;
      }

      case myParser::NUMBER: {
        setState(885);
        match(myParser::NUMBER);
        break;
      }

      case myParser::STRING: {
        setState(887); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(886);
          match(myParser::STRING);
          setState(889); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == myParser::STRING);
        break;
      }

      case myParser::ELLIPSIS: {
        setState(891);
        match(myParser::ELLIPSIS);
        break;
      }

      case myParser::NONE: {
        setState(892);
        match(myParser::NONE);
        break;
      }

      case myParser::TRUE: {
        setState(893);
        match(myParser::TRUE);
        break;
      }

      case myParser::FALSE: {
        setState(894);
        match(myParser::FALSE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Testlist_compContext ------------------------------------------------------------------

myParser::Testlist_compContext::Testlist_compContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::TestContext *> myParser::Testlist_compContext::test() {
  return getRuleContexts<myParser::TestContext>();
}

myParser::TestContext* myParser::Testlist_compContext::test(size_t i) {
  return getRuleContext<myParser::TestContext>(i);
}

std::vector<myParser::Star_exprContext *> myParser::Testlist_compContext::star_expr() {
  return getRuleContexts<myParser::Star_exprContext>();
}

myParser::Star_exprContext* myParser::Testlist_compContext::star_expr(size_t i) {
  return getRuleContext<myParser::Star_exprContext>(i);
}

myParser::Comp_forContext* myParser::Testlist_compContext::comp_for() {
  return getRuleContext<myParser::Comp_forContext>(0);
}

std::vector<tree::TerminalNode *> myParser::Testlist_compContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::Testlist_compContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::Testlist_compContext::getRuleIndex() const {
  return myParser::RuleTestlist_comp;
}

void myParser::Testlist_compContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTestlist_comp(this);
}

void myParser::Testlist_compContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTestlist_comp(this);
}

myParser::Testlist_compContext* myParser::testlist_comp() {
  Testlist_compContext *_localctx = _tracker.createInstance<Testlist_compContext>(_ctx, getState());
  enterRule(_localctx, 138, myParser::RuleTestlist_comp);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(899);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::STRING:
      case myParser::NUMBER:
      case myParser::LAMBDA:
      case myParser::NOT:
      case myParser::NONE:
      case myParser::TRUE:
      case myParser::FALSE:
      case myParser::AWAIT:
      case myParser::NAME:
      case myParser::ELLIPSIS:
      case myParser::OPEN_PAREN:
      case myParser::OPEN_BRACK:
      case myParser::ADD:
      case myParser::MINUS:
      case myParser::NOT_OP:
      case myParser::OPEN_BRACE: {
        setState(897);
        test();
        break;
      }

      case myParser::STAR: {
        setState(898);
        star_expr();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(915);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::FOR:
      case myParser::ASYNC: {
        setState(901);
        comp_for();
        break;
      }

      case myParser::CLOSE_PAREN:
      case myParser::COMMA:
      case myParser::CLOSE_BRACK: {
        setState(909);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 125, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(902);
            match(myParser::COMMA);
            setState(905);
            _errHandler->sync(this);
            switch (_input->LA(1)) {
              case myParser::STRING:
              case myParser::NUMBER:
              case myParser::LAMBDA:
              case myParser::NOT:
              case myParser::NONE:
              case myParser::TRUE:
              case myParser::FALSE:
              case myParser::AWAIT:
              case myParser::NAME:
              case myParser::ELLIPSIS:
              case myParser::OPEN_PAREN:
              case myParser::OPEN_BRACK:
              case myParser::ADD:
              case myParser::MINUS:
              case myParser::NOT_OP:
              case myParser::OPEN_BRACE: {
                setState(903);
                test();
                break;
              }

              case myParser::STAR: {
                setState(904);
                star_expr();
                break;
              }

            default:
              throw NoViableAltException(this);
            } 
          }
          setState(911);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 125, _ctx);
        }
        setState(913);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::COMMA) {
          setState(912);
          match(myParser::COMMA);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TrailerContext ------------------------------------------------------------------

myParser::TrailerContext::TrailerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TrailerContext::OPEN_PAREN() {
  return getToken(myParser::OPEN_PAREN, 0);
}

tree::TerminalNode* myParser::TrailerContext::CLOSE_PAREN() {
  return getToken(myParser::CLOSE_PAREN, 0);
}

myParser::ArglistContext* myParser::TrailerContext::arglist() {
  return getRuleContext<myParser::ArglistContext>(0);
}

tree::TerminalNode* myParser::TrailerContext::OPEN_BRACK() {
  return getToken(myParser::OPEN_BRACK, 0);
}

myParser::SubscriptlistContext* myParser::TrailerContext::subscriptlist() {
  return getRuleContext<myParser::SubscriptlistContext>(0);
}

tree::TerminalNode* myParser::TrailerContext::CLOSE_BRACK() {
  return getToken(myParser::CLOSE_BRACK, 0);
}

tree::TerminalNode* myParser::TrailerContext::DOT() {
  return getToken(myParser::DOT, 0);
}

tree::TerminalNode* myParser::TrailerContext::NAME() {
  return getToken(myParser::NAME, 0);
}


size_t myParser::TrailerContext::getRuleIndex() const {
  return myParser::RuleTrailer;
}

void myParser::TrailerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrailer(this);
}

void myParser::TrailerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrailer(this);
}

myParser::TrailerContext* myParser::trailer() {
  TrailerContext *_localctx = _tracker.createInstance<TrailerContext>(_ctx, getState());
  enterRule(_localctx, 140, myParser::RuleTrailer);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(928);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::OPEN_PAREN: {
        enterOuterAlt(_localctx, 1);
        setState(917);
        match(myParser::OPEN_PAREN);
        setState(919);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 728458616071258118) != 0 || (((_la - 66) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 66)) & 99) != 0) {
          setState(918);
          arglist();
        }
        setState(921);
        match(myParser::CLOSE_PAREN);
        break;
      }

      case myParser::OPEN_BRACK: {
        enterOuterAlt(_localctx, 2);
        setState(922);
        match(myParser::OPEN_BRACK);
        setState(923);
        subscriptlist();
        setState(924);
        match(myParser::CLOSE_BRACK);
        break;
      }

      case myParser::DOT: {
        enterOuterAlt(_localctx, 3);
        setState(926);
        match(myParser::DOT);
        setState(927);
        match(myParser::NAME);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubscriptlistContext ------------------------------------------------------------------

myParser::SubscriptlistContext::SubscriptlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::SubscriptContext *> myParser::SubscriptlistContext::subscript() {
  return getRuleContexts<myParser::SubscriptContext>();
}

myParser::SubscriptContext* myParser::SubscriptlistContext::subscript(size_t i) {
  return getRuleContext<myParser::SubscriptContext>(i);
}

std::vector<tree::TerminalNode *> myParser::SubscriptlistContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::SubscriptlistContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::SubscriptlistContext::getRuleIndex() const {
  return myParser::RuleSubscriptlist;
}

void myParser::SubscriptlistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubscriptlist(this);
}

void myParser::SubscriptlistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubscriptlist(this);
}

myParser::SubscriptlistContext* myParser::subscriptlist() {
  SubscriptlistContext *_localctx = _tracker.createInstance<SubscriptlistContext>(_ctx, getState());
  enterRule(_localctx, 142, myParser::RuleSubscriptlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(930);
    subscript();
    setState(935);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 130, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(931);
        match(myParser::COMMA);
        setState(932);
        subscript(); 
      }
      setState(937);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 130, _ctx);
    }
    setState(939);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::COMMA) {
      setState(938);
      match(myParser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubscriptContext ------------------------------------------------------------------

myParser::SubscriptContext::SubscriptContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::TestContext *> myParser::SubscriptContext::test() {
  return getRuleContexts<myParser::TestContext>();
}

myParser::TestContext* myParser::SubscriptContext::test(size_t i) {
  return getRuleContext<myParser::TestContext>(i);
}

tree::TerminalNode* myParser::SubscriptContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::SliceopContext* myParser::SubscriptContext::sliceop() {
  return getRuleContext<myParser::SliceopContext>(0);
}


size_t myParser::SubscriptContext::getRuleIndex() const {
  return myParser::RuleSubscript;
}

void myParser::SubscriptContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubscript(this);
}

void myParser::SubscriptContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubscript(this);
}

myParser::SubscriptContext* myParser::subscript() {
  SubscriptContext *_localctx = _tracker.createInstance<SubscriptContext>(_ctx, getState());
  enterRule(_localctx, 144, myParser::RuleSubscript);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(952);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 135, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(941);
      test();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(943);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 582091628181716998) != 0 || (((_la - 66) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 66)) & 99) != 0) {
        setState(942);
        test();
      }
      setState(945);
      match(myParser::COLON);
      setState(947);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 582091628181716998) != 0 || (((_la - 66) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 66)) & 99) != 0) {
        setState(946);
        test();
      }
      setState(950);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::COLON) {
        setState(949);
        sliceop();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SliceopContext ------------------------------------------------------------------

myParser::SliceopContext::SliceopContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::SliceopContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::TestContext* myParser::SliceopContext::test() {
  return getRuleContext<myParser::TestContext>(0);
}


size_t myParser::SliceopContext::getRuleIndex() const {
  return myParser::RuleSliceop;
}

void myParser::SliceopContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSliceop(this);
}

void myParser::SliceopContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSliceop(this);
}

myParser::SliceopContext* myParser::sliceop() {
  SliceopContext *_localctx = _tracker.createInstance<SliceopContext>(_ctx, getState());
  enterRule(_localctx, 146, myParser::RuleSliceop);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(954);
    match(myParser::COLON);
    setState(956);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 582091628181716998) != 0 || (((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 99) != 0) {
      setState(955);
      test();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprlistContext ------------------------------------------------------------------

myParser::ExprlistContext::ExprlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::ExprContext *> myParser::ExprlistContext::expr() {
  return getRuleContexts<myParser::ExprContext>();
}

myParser::ExprContext* myParser::ExprlistContext::expr(size_t i) {
  return getRuleContext<myParser::ExprContext>(i);
}

std::vector<myParser::Star_exprContext *> myParser::ExprlistContext::star_expr() {
  return getRuleContexts<myParser::Star_exprContext>();
}

myParser::Star_exprContext* myParser::ExprlistContext::star_expr(size_t i) {
  return getRuleContext<myParser::Star_exprContext>(i);
}

std::vector<tree::TerminalNode *> myParser::ExprlistContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::ExprlistContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::ExprlistContext::getRuleIndex() const {
  return myParser::RuleExprlist;
}

void myParser::ExprlistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprlist(this);
}

void myParser::ExprlistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprlist(this);
}

myParser::ExprlistContext* myParser::exprlist() {
  ExprlistContext *_localctx = _tracker.createInstance<ExprlistContext>(_ctx, getState());
  enterRule(_localctx, 148, myParser::RuleExprlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(960);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::STRING:
      case myParser::NUMBER:
      case myParser::NONE:
      case myParser::TRUE:
      case myParser::FALSE:
      case myParser::AWAIT:
      case myParser::NAME:
      case myParser::ELLIPSIS:
      case myParser::OPEN_PAREN:
      case myParser::OPEN_BRACK:
      case myParser::ADD:
      case myParser::MINUS:
      case myParser::NOT_OP:
      case myParser::OPEN_BRACE: {
        setState(958);
        expr();
        break;
      }

      case myParser::STAR: {
        setState(959);
        star_expr();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(969);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 139, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(962);
        match(myParser::COMMA);
        setState(965);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case myParser::STRING:
          case myParser::NUMBER:
          case myParser::NONE:
          case myParser::TRUE:
          case myParser::FALSE:
          case myParser::AWAIT:
          case myParser::NAME:
          case myParser::ELLIPSIS:
          case myParser::OPEN_PAREN:
          case myParser::OPEN_BRACK:
          case myParser::ADD:
          case myParser::MINUS:
          case myParser::NOT_OP:
          case myParser::OPEN_BRACE: {
            setState(963);
            expr();
            break;
          }

          case myParser::STAR: {
            setState(964);
            star_expr();
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(971);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 139, _ctx);
    }
    setState(973);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::COMMA) {
      setState(972);
      match(myParser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TestlistContext ------------------------------------------------------------------

myParser::TestlistContext::TestlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::TestContext *> myParser::TestlistContext::test() {
  return getRuleContexts<myParser::TestContext>();
}

myParser::TestContext* myParser::TestlistContext::test(size_t i) {
  return getRuleContext<myParser::TestContext>(i);
}

std::vector<tree::TerminalNode *> myParser::TestlistContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::TestlistContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::TestlistContext::getRuleIndex() const {
  return myParser::RuleTestlist;
}

void myParser::TestlistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTestlist(this);
}

void myParser::TestlistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTestlist(this);
}

myParser::TestlistContext* myParser::testlist() {
  TestlistContext *_localctx = _tracker.createInstance<TestlistContext>(_ctx, getState());
  enterRule(_localctx, 150, myParser::RuleTestlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(975);
    test();
    setState(980);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(976);
        match(myParser::COMMA);
        setState(977);
        test(); 
      }
      setState(982);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx);
    }
    setState(984);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::COMMA) {
      setState(983);
      match(myParser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DictorsetmakerContext ------------------------------------------------------------------

myParser::DictorsetmakerContext::DictorsetmakerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::TestContext *> myParser::DictorsetmakerContext::test() {
  return getRuleContexts<myParser::TestContext>();
}

myParser::TestContext* myParser::DictorsetmakerContext::test(size_t i) {
  return getRuleContext<myParser::TestContext>(i);
}

std::vector<tree::TerminalNode *> myParser::DictorsetmakerContext::COLON() {
  return getTokens(myParser::COLON);
}

tree::TerminalNode* myParser::DictorsetmakerContext::COLON(size_t i) {
  return getToken(myParser::COLON, i);
}

std::vector<tree::TerminalNode *> myParser::DictorsetmakerContext::POWER() {
  return getTokens(myParser::POWER);
}

tree::TerminalNode* myParser::DictorsetmakerContext::POWER(size_t i) {
  return getToken(myParser::POWER, i);
}

std::vector<myParser::ExprContext *> myParser::DictorsetmakerContext::expr() {
  return getRuleContexts<myParser::ExprContext>();
}

myParser::ExprContext* myParser::DictorsetmakerContext::expr(size_t i) {
  return getRuleContext<myParser::ExprContext>(i);
}

myParser::Comp_forContext* myParser::DictorsetmakerContext::comp_for() {
  return getRuleContext<myParser::Comp_forContext>(0);
}

std::vector<myParser::Star_exprContext *> myParser::DictorsetmakerContext::star_expr() {
  return getRuleContexts<myParser::Star_exprContext>();
}

myParser::Star_exprContext* myParser::DictorsetmakerContext::star_expr(size_t i) {
  return getRuleContext<myParser::Star_exprContext>(i);
}

std::vector<tree::TerminalNode *> myParser::DictorsetmakerContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::DictorsetmakerContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::DictorsetmakerContext::getRuleIndex() const {
  return myParser::RuleDictorsetmaker;
}

void myParser::DictorsetmakerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDictorsetmaker(this);
}

void myParser::DictorsetmakerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDictorsetmaker(this);
}

myParser::DictorsetmakerContext* myParser::dictorsetmaker() {
  DictorsetmakerContext *_localctx = _tracker.createInstance<DictorsetmakerContext>(_ctx, getState());
  enterRule(_localctx, 152, myParser::RuleDictorsetmaker);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1034);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 153, _ctx)) {
    case 1: {
      setState(992);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case myParser::STRING:
        case myParser::NUMBER:
        case myParser::LAMBDA:
        case myParser::NOT:
        case myParser::NONE:
        case myParser::TRUE:
        case myParser::FALSE:
        case myParser::AWAIT:
        case myParser::NAME:
        case myParser::ELLIPSIS:
        case myParser::OPEN_PAREN:
        case myParser::OPEN_BRACK:
        case myParser::ADD:
        case myParser::MINUS:
        case myParser::NOT_OP:
        case myParser::OPEN_BRACE: {
          setState(986);
          test();
          setState(987);
          match(myParser::COLON);
          setState(988);
          test();
          break;
        }

        case myParser::POWER: {
          setState(990);
          match(myParser::POWER);
          setState(991);
          expr();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1012);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case myParser::FOR:
        case myParser::ASYNC: {
          setState(994);
          comp_for();
          break;
        }

        case myParser::COMMA:
        case myParser::CLOSE_BRACE: {
          setState(1006);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 145, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(995);
              match(myParser::COMMA);
              setState(1002);
              _errHandler->sync(this);
              switch (_input->LA(1)) {
                case myParser::STRING:
                case myParser::NUMBER:
                case myParser::LAMBDA:
                case myParser::NOT:
                case myParser::NONE:
                case myParser::TRUE:
                case myParser::FALSE:
                case myParser::AWAIT:
                case myParser::NAME:
                case myParser::ELLIPSIS:
                case myParser::OPEN_PAREN:
                case myParser::OPEN_BRACK:
                case myParser::ADD:
                case myParser::MINUS:
                case myParser::NOT_OP:
                case myParser::OPEN_BRACE: {
                  setState(996);
                  test();
                  setState(997);
                  match(myParser::COLON);
                  setState(998);
                  test();
                  break;
                }

                case myParser::POWER: {
                  setState(1000);
                  match(myParser::POWER);
                  setState(1001);
                  expr();
                  break;
                }

              default:
                throw NoViableAltException(this);
              } 
            }
            setState(1008);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 145, _ctx);
          }
          setState(1010);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == myParser::COMMA) {
            setState(1009);
            match(myParser::COMMA);
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      setState(1016);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case myParser::STRING:
        case myParser::NUMBER:
        case myParser::LAMBDA:
        case myParser::NOT:
        case myParser::NONE:
        case myParser::TRUE:
        case myParser::FALSE:
        case myParser::AWAIT:
        case myParser::NAME:
        case myParser::ELLIPSIS:
        case myParser::OPEN_PAREN:
        case myParser::OPEN_BRACK:
        case myParser::ADD:
        case myParser::MINUS:
        case myParser::NOT_OP:
        case myParser::OPEN_BRACE: {
          setState(1014);
          test();
          break;
        }

        case myParser::STAR: {
          setState(1015);
          star_expr();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1032);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case myParser::FOR:
        case myParser::ASYNC: {
          setState(1018);
          comp_for();
          break;
        }

        case myParser::COMMA:
        case myParser::CLOSE_BRACE: {
          setState(1026);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 150, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(1019);
              match(myParser::COMMA);
              setState(1022);
              _errHandler->sync(this);
              switch (_input->LA(1)) {
                case myParser::STRING:
                case myParser::NUMBER:
                case myParser::LAMBDA:
                case myParser::NOT:
                case myParser::NONE:
                case myParser::TRUE:
                case myParser::FALSE:
                case myParser::AWAIT:
                case myParser::NAME:
                case myParser::ELLIPSIS:
                case myParser::OPEN_PAREN:
                case myParser::OPEN_BRACK:
                case myParser::ADD:
                case myParser::MINUS:
                case myParser::NOT_OP:
                case myParser::OPEN_BRACE: {
                  setState(1020);
                  test();
                  break;
                }

                case myParser::STAR: {
                  setState(1021);
                  star_expr();
                  break;
                }

              default:
                throw NoViableAltException(this);
              } 
            }
            setState(1028);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 150, _ctx);
          }
          setState(1030);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == myParser::COMMA) {
            setState(1029);
            match(myParser::COMMA);
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassdefContext ------------------------------------------------------------------

myParser::ClassdefContext::ClassdefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ClassdefContext::CLASS() {
  return getToken(myParser::CLASS, 0);
}

tree::TerminalNode* myParser::ClassdefContext::NAME() {
  return getToken(myParser::NAME, 0);
}

tree::TerminalNode* myParser::ClassdefContext::COLON() {
  return getToken(myParser::COLON, 0);
}

myParser::SuiteContext* myParser::ClassdefContext::suite() {
  return getRuleContext<myParser::SuiteContext>(0);
}

tree::TerminalNode* myParser::ClassdefContext::OPEN_PAREN() {
  return getToken(myParser::OPEN_PAREN, 0);
}

tree::TerminalNode* myParser::ClassdefContext::CLOSE_PAREN() {
  return getToken(myParser::CLOSE_PAREN, 0);
}

myParser::ArglistContext* myParser::ClassdefContext::arglist() {
  return getRuleContext<myParser::ArglistContext>(0);
}


size_t myParser::ClassdefContext::getRuleIndex() const {
  return myParser::RuleClassdef;
}

void myParser::ClassdefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassdef(this);
}

void myParser::ClassdefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassdef(this);
}

myParser::ClassdefContext* myParser::classdef() {
  ClassdefContext *_localctx = _tracker.createInstance<ClassdefContext>(_ctx, getState());
  enterRule(_localctx, 154, myParser::RuleClassdef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1036);
    match(myParser::CLASS);
    setState(1037);
    match(myParser::NAME);
    setState(1043);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::OPEN_PAREN) {
      setState(1038);
      match(myParser::OPEN_PAREN);
      setState(1040);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 728458616071258118) != 0 || (((_la - 66) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 66)) & 99) != 0) {
        setState(1039);
        arglist();
      }
      setState(1042);
      match(myParser::CLOSE_PAREN);
    }
    setState(1045);
    match(myParser::COLON);
    setState(1046);
    suite();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArglistContext ------------------------------------------------------------------

myParser::ArglistContext::ArglistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::ArgumentContext *> myParser::ArglistContext::argument() {
  return getRuleContexts<myParser::ArgumentContext>();
}

myParser::ArgumentContext* myParser::ArglistContext::argument(size_t i) {
  return getRuleContext<myParser::ArgumentContext>(i);
}

std::vector<tree::TerminalNode *> myParser::ArglistContext::COMMA() {
  return getTokens(myParser::COMMA);
}

tree::TerminalNode* myParser::ArglistContext::COMMA(size_t i) {
  return getToken(myParser::COMMA, i);
}


size_t myParser::ArglistContext::getRuleIndex() const {
  return myParser::RuleArglist;
}

void myParser::ArglistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArglist(this);
}

void myParser::ArglistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArglist(this);
}

myParser::ArglistContext* myParser::arglist() {
  ArglistContext *_localctx = _tracker.createInstance<ArglistContext>(_ctx, getState());
  enterRule(_localctx, 156, myParser::RuleArglist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1048);
    argument();
    setState(1053);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1049);
        match(myParser::COMMA);
        setState(1050);
        argument(); 
      }
      setState(1055);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx);
    }
    setState(1057);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::COMMA) {
      setState(1056);
      match(myParser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentContext ------------------------------------------------------------------

myParser::ArgumentContext::ArgumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::TestContext *> myParser::ArgumentContext::test() {
  return getRuleContexts<myParser::TestContext>();
}

myParser::TestContext* myParser::ArgumentContext::test(size_t i) {
  return getRuleContext<myParser::TestContext>(i);
}

tree::TerminalNode* myParser::ArgumentContext::ASSIGN() {
  return getToken(myParser::ASSIGN, 0);
}

tree::TerminalNode* myParser::ArgumentContext::POWER() {
  return getToken(myParser::POWER, 0);
}

tree::TerminalNode* myParser::ArgumentContext::STAR() {
  return getToken(myParser::STAR, 0);
}

myParser::Comp_forContext* myParser::ArgumentContext::comp_for() {
  return getRuleContext<myParser::Comp_forContext>(0);
}


size_t myParser::ArgumentContext::getRuleIndex() const {
  return myParser::RuleArgument;
}

void myParser::ArgumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgument(this);
}

void myParser::ArgumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgument(this);
}

myParser::ArgumentContext* myParser::argument() {
  ArgumentContext *_localctx = _tracker.createInstance<ArgumentContext>(_ctx, getState());
  enterRule(_localctx, 158, myParser::RuleArgument);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1071);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 159, _ctx)) {
    case 1: {
      setState(1059);
      test();
      setState(1061);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::FOR

      || _la == myParser::ASYNC) {
        setState(1060);
        comp_for();
      }
      break;
    }

    case 2: {
      setState(1063);
      test();
      setState(1064);
      match(myParser::ASSIGN);
      setState(1065);
      test();
      break;
    }

    case 3: {
      setState(1067);
      match(myParser::POWER);
      setState(1068);
      test();
      break;
    }

    case 4: {
      setState(1069);
      match(myParser::STAR);
      setState(1070);
      test();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comp_iterContext ------------------------------------------------------------------

myParser::Comp_iterContext::Comp_iterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Comp_forContext* myParser::Comp_iterContext::comp_for() {
  return getRuleContext<myParser::Comp_forContext>(0);
}

myParser::Comp_ifContext* myParser::Comp_iterContext::comp_if() {
  return getRuleContext<myParser::Comp_ifContext>(0);
}


size_t myParser::Comp_iterContext::getRuleIndex() const {
  return myParser::RuleComp_iter;
}

void myParser::Comp_iterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComp_iter(this);
}

void myParser::Comp_iterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComp_iter(this);
}

myParser::Comp_iterContext* myParser::comp_iter() {
  Comp_iterContext *_localctx = _tracker.createInstance<Comp_iterContext>(_ctx, getState());
  enterRule(_localctx, 160, myParser::RuleComp_iter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1075);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::FOR:
      case myParser::ASYNC: {
        enterOuterAlt(_localctx, 1);
        setState(1073);
        comp_for();
        break;
      }

      case myParser::IF: {
        enterOuterAlt(_localctx, 2);
        setState(1074);
        comp_if();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comp_forContext ------------------------------------------------------------------

myParser::Comp_forContext::Comp_forContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Comp_forContext::FOR() {
  return getToken(myParser::FOR, 0);
}

myParser::ExprlistContext* myParser::Comp_forContext::exprlist() {
  return getRuleContext<myParser::ExprlistContext>(0);
}

tree::TerminalNode* myParser::Comp_forContext::IN() {
  return getToken(myParser::IN, 0);
}

myParser::Or_testContext* myParser::Comp_forContext::or_test() {
  return getRuleContext<myParser::Or_testContext>(0);
}

tree::TerminalNode* myParser::Comp_forContext::ASYNC() {
  return getToken(myParser::ASYNC, 0);
}

myParser::Comp_iterContext* myParser::Comp_forContext::comp_iter() {
  return getRuleContext<myParser::Comp_iterContext>(0);
}


size_t myParser::Comp_forContext::getRuleIndex() const {
  return myParser::RuleComp_for;
}

void myParser::Comp_forContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComp_for(this);
}

void myParser::Comp_forContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComp_for(this);
}

myParser::Comp_forContext* myParser::comp_for() {
  Comp_forContext *_localctx = _tracker.createInstance<Comp_forContext>(_ctx, getState());
  enterRule(_localctx, 162, myParser::RuleComp_for);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1078);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::ASYNC) {
      setState(1077);
      match(myParser::ASYNC);
    }
    setState(1080);
    match(myParser::FOR);
    setState(1081);
    exprlist();
    setState(1082);
    match(myParser::IN);
    setState(1083);
    or_test();
    setState(1085);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 137439092736) != 0) {
      setState(1084);
      comp_iter();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comp_ifContext ------------------------------------------------------------------

myParser::Comp_ifContext::Comp_ifContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Comp_ifContext::IF() {
  return getToken(myParser::IF, 0);
}

myParser::Test_nocondContext* myParser::Comp_ifContext::test_nocond() {
  return getRuleContext<myParser::Test_nocondContext>(0);
}

myParser::Comp_iterContext* myParser::Comp_ifContext::comp_iter() {
  return getRuleContext<myParser::Comp_iterContext>(0);
}


size_t myParser::Comp_ifContext::getRuleIndex() const {
  return myParser::RuleComp_if;
}

void myParser::Comp_ifContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComp_if(this);
}

void myParser::Comp_ifContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComp_if(this);
}

myParser::Comp_ifContext* myParser::comp_if() {
  Comp_ifContext *_localctx = _tracker.createInstance<Comp_ifContext>(_ctx, getState());
  enterRule(_localctx, 164, myParser::RuleComp_if);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1087);
    match(myParser::IF);
    setState(1088);
    test_nocond();
    setState(1090);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 137439092736) != 0) {
      setState(1089);
      comp_iter();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Encoding_declContext ------------------------------------------------------------------

myParser::Encoding_declContext::Encoding_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Encoding_declContext::NAME() {
  return getToken(myParser::NAME, 0);
}


size_t myParser::Encoding_declContext::getRuleIndex() const {
  return myParser::RuleEncoding_decl;
}

void myParser::Encoding_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEncoding_decl(this);
}

void myParser::Encoding_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEncoding_decl(this);
}

myParser::Encoding_declContext* myParser::encoding_decl() {
  Encoding_declContext *_localctx = _tracker.createInstance<Encoding_declContext>(_ctx, getState());
  enterRule(_localctx, 166, myParser::RuleEncoding_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1092);
    match(myParser::NAME);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Yield_exprContext ------------------------------------------------------------------

myParser::Yield_exprContext::Yield_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Yield_exprContext::YIELD() {
  return getToken(myParser::YIELD, 0);
}

myParser::Yield_argContext* myParser::Yield_exprContext::yield_arg() {
  return getRuleContext<myParser::Yield_argContext>(0);
}


size_t myParser::Yield_exprContext::getRuleIndex() const {
  return myParser::RuleYield_expr;
}

void myParser::Yield_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterYield_expr(this);
}

void myParser::Yield_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitYield_expr(this);
}

myParser::Yield_exprContext* myParser::yield_expr() {
  Yield_exprContext *_localctx = _tracker.createInstance<Yield_exprContext>(_ctx, getState());
  enterRule(_localctx, 168, myParser::RuleYield_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1094);
    match(myParser::YIELD);
    setState(1096);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 582091628181717126) != 0 || (((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 99) != 0) {
      setState(1095);
      yield_arg();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Yield_argContext ------------------------------------------------------------------

myParser::Yield_argContext::Yield_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::Yield_argContext::FROM() {
  return getToken(myParser::FROM, 0);
}

myParser::TestContext* myParser::Yield_argContext::test() {
  return getRuleContext<myParser::TestContext>(0);
}

myParser::TestlistContext* myParser::Yield_argContext::testlist() {
  return getRuleContext<myParser::TestlistContext>(0);
}


size_t myParser::Yield_argContext::getRuleIndex() const {
  return myParser::RuleYield_arg;
}

void myParser::Yield_argContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterYield_arg(this);
}

void myParser::Yield_argContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitYield_arg(this);
}

myParser::Yield_argContext* myParser::yield_arg() {
  Yield_argContext *_localctx = _tracker.createInstance<Yield_argContext>(_ctx, getState());
  enterRule(_localctx, 170, myParser::RuleYield_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1101);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::FROM: {
        enterOuterAlt(_localctx, 1);
        setState(1098);
        match(myParser::FROM);
        setState(1099);
        test();
        break;
      }

      case myParser::STRING:
      case myParser::NUMBER:
      case myParser::LAMBDA:
      case myParser::NOT:
      case myParser::NONE:
      case myParser::TRUE:
      case myParser::FALSE:
      case myParser::AWAIT:
      case myParser::NAME:
      case myParser::ELLIPSIS:
      case myParser::OPEN_PAREN:
      case myParser::OPEN_BRACK:
      case myParser::ADD:
      case myParser::MINUS:
      case myParser::NOT_OP:
      case myParser::OPEN_BRACE: {
        enterOuterAlt(_localctx, 2);
        setState(1100);
        testlist();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

void myParser::initialize() {
  ::antlr4::internal::call_once(myParserOnceFlag, myParserInitialize);
}


    #include "TypeScriptParserBase.h"


// Generated from TypeScriptParser.g4 by ANTLR 4.13.0


#include "TypeScriptParserListener.h"

#include "TypeScriptParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct TypeScriptParserStaticData final {
  TypeScriptParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  TypeScriptParserStaticData(const TypeScriptParserStaticData&) = delete;
  TypeScriptParserStaticData(TypeScriptParserStaticData&&) = delete;
  TypeScriptParserStaticData& operator=(const TypeScriptParserStaticData&) = delete;
  TypeScriptParserStaticData& operator=(TypeScriptParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag typescriptparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
TypeScriptParserStaticData *typescriptparserParserStaticData = nullptr;

void typescriptparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (typescriptparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(typescriptparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<TypeScriptParserStaticData>(
    std::vector<std::string>{
      "initializer", "bindingPattern", "typeParameters", "typeParameterList", 
      "typeParameter", "constraint", "typeArguments", "typeArgumentList", 
      "typeArgument", "type_", "unionOrIntersectionOrPrimaryType", "primaryType", 
      "predefinedType", "typeReference", "nestedTypeGeneric", "typeGeneric", 
      "typeIncludeGeneric", "typeName", "objectType", "typeBody", "typeMemberList", 
      "typeMember", "arrayType", "tupleType", "tupleElementTypes", "functionType", 
      "constructorType", "typeQuery", "typeQueryExpression", "propertySignatur", 
      "typeAnnotation", "callSignature", "parameterList", "requiredParameterList", 
      "parameter", "optionalParameter", "restParameter", "requiredParameter", 
      "accessibilityModifier", "identifierOrPattern", "constructSignature", 
      "indexSignature", "methodSignature", "typeAliasDeclaration", "constructorDeclaration", 
      "interfaceDeclaration", "interfaceExtendsClause", "classOrInterfaceTypeList", 
      "enumDeclaration", "enumBody", "enumMemberList", "enumMember", "namespaceDeclaration", 
      "namespaceName", "importAliasDeclaration", "decoratorList", "decorator", 
      "decoratorMemberExpression", "decoratorCallExpression", "program", 
      "sourceElement", "statement", "block", "statementList", "abstractDeclaration", 
      "importStatement", "fromBlock", "multipleImportStatement", "exportStatement", 
      "variableStatement", "variableDeclarationList", "variableDeclaration", 
      "emptyStatement_", "expressionStatement", "ifStatement", "iterationStatement", 
      "varModifier", "continueStatement", "breakStatement", "returnStatement", 
      "yieldStatement", "withStatement", "switchStatement", "caseBlock", 
      "caseClauses", "caseClause", "defaultClause", "labelledStatement", 
      "throwStatement", "tryStatement", "catchProduction", "finallyProduction", 
      "debuggerStatement", "functionDeclaration", "classDeclaration", "classHeritage", 
      "classTail", "classExtendsClause", "implementsClause", "classElement", 
      "propertyMemberDeclaration", "propertyMemberBase", "indexMemberDeclaration", 
      "generatorMethod", "generatorFunctionDeclaration", "generatorBlock", 
      "generatorDefinition", "iteratorBlock", "iteratorDefinition", "formalParameterList", 
      "formalParameterArg", "lastFormalParameterArg", "functionBody", "sourceElements", 
      "arrayLiteral", "elementList", "arrayElement", "objectLiteral", "propertyAssignment", 
      "getAccessor", "setAccessor", "propertyName", "arguments", "argumentList", 
      "argument", "expressionSequence", "functionExpressionDeclaration", 
      "singleExpression", "asExpression", "arrowFunctionDeclaration", "arrowFunctionParameters", 
      "arrowFunctionBody", "assignmentOperator", "literal", "templateStringLiteral", 
      "templateStringAtom", "numericLiteral", "identifierName", "identifierOrKeyWord", 
      "reservedWord", "keyword", "getter", "setter", "eos"
    },
    std::vector<std::string>{
      "", "", "", "", "'['", "']'", "'('", "')'", "'{'", "", "'}'", "';'", 
      "','", "'='", "'\\u003F'", "':'", "'...'", "'.'", "'++'", "'--'", 
      "'+'", "'-'", "'~'", "'!'", "'*'", "'/'", "'%'", "'>>'", "'<<'", "'>>>'", 
      "'<'", "'>'", "'<='", "'>='", "'=='", "'!='", "'==='", "'!=='", "'&'", 
      "'^'", "'|'", "'&&'", "'||'", "'*='", "'/='", "'%='", "'+='", "'-='", 
      "'<<='", "'>>='", "'>>>='", "'&='", "'^='", "'|='", "'=>'", "'null'", 
      "", "", "", "", "", "", "'break'", "'do'", "'instanceof'", "'typeof'", 
      "'case'", "'else'", "'new'", "'var'", "'catch'", "'finally'", "'return'", 
      "'void'", "'continue'", "'for'", "'switch'", "'while'", "'debugger'", 
      "'function'", "'this'", "'with'", "'default'", "'if'", "'throw'", 
      "'delete'", "'in'", "'try'", "'as'", "'from'", "'readonly'", "'async'", 
      "'class'", "'enum'", "'extends'", "'super'", "'const'", "'export'", 
      "'import'", "'implements'", "'let'", "'private'", "'public'", "'interface'", 
      "'package'", "'protected'", "'static'", "'yield'", "'any'", "'number'", 
      "'boolean'", "'string'", "'symbol'", "'type'", "'get'", "'set'", "'constructor'", 
      "'namespace'", "'require'", "'module'", "'declare'", "'abstract'", 
      "'is'", "'@'"
    },
    std::vector<std::string>{
      "", "MultiLineComment", "SingleLineComment", "RegularExpressionLiteral", 
      "OpenBracket", "CloseBracket", "OpenParen", "CloseParen", "OpenBrace", 
      "TemplateCloseBrace", "CloseBrace", "SemiColon", "Comma", "Assign", 
      "QuestionMark", "Colon", "Ellipsis", "Dot", "PlusPlus", "MinusMinus", 
      "Plus", "Minus", "BitNot", "Not", "Multiply", "Divide", "Modulus", 
      "RightShiftArithmetic", "LeftShiftArithmetic", "RightShiftLogical", 
      "LessThan", "MoreThan", "LessThanEquals", "GreaterThanEquals", "Equals_", 
      "NotEquals", "IdentityEquals", "IdentityNotEquals", "BitAnd", "BitXOr", 
      "BitOr", "And", "Or", "MultiplyAssign", "DivideAssign", "ModulusAssign", 
      "PlusAssign", "MinusAssign", "LeftShiftArithmeticAssign", "RightShiftArithmeticAssign", 
      "RightShiftLogicalAssign", "BitAndAssign", "BitXorAssign", "BitOrAssign", 
      "ARROW", "NullLiteral", "BooleanLiteral", "DecimalLiteral", "HexIntegerLiteral", 
      "OctalIntegerLiteral", "OctalIntegerLiteral2", "BinaryIntegerLiteral", 
      "Break", "Do", "Instanceof", "Typeof", "Case", "Else", "New", "Var", 
      "Catch", "Finally", "Return", "Void", "Continue", "For", "Switch", 
      "While", "Debugger", "Function_", "This", "With", "Default", "If", 
      "Throw", "Delete", "In", "Try", "As", "From", "ReadOnly", "Async", 
      "Class", "Enum", "Extends", "Super", "Const", "Export", "Import", 
      "Implements", "Let", "Private", "Public", "Interface", "Package", 
      "Protected", "Static", "Yield", "Any", "Number", "Boolean", "String", 
      "Symbol", "TypeAlias", "Get", "Set", "Constructor", "Namespace", "Require", 
      "Module", "Declare", "Abstract", "Is", "At", "Identifier", "StringLiteral", 
      "BackTick", "WhiteSpaces", "LineTerminator", "HtmlComment", "CDataComment", 
      "UnexpectedCharacter", "TemplateStringEscapeAtom", "TemplateStringStartExpression", 
      "TemplateStringAtom"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,134,1687,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,
  	7,134,2,135,7,135,2,136,7,136,2,137,7,137,2,138,7,138,2,139,7,139,2,140,
  	7,140,2,141,7,141,2,142,7,142,2,143,7,143,1,0,1,0,1,0,1,1,1,1,3,1,294,
  	8,1,1,2,1,2,3,2,298,8,2,1,2,1,2,1,3,1,3,1,3,5,3,305,8,3,10,3,12,3,308,
  	9,3,1,4,1,4,3,4,312,8,4,1,4,3,4,315,8,4,1,5,1,5,1,5,1,6,1,6,3,6,322,8,
  	6,1,6,1,6,1,7,1,7,1,7,5,7,329,8,7,10,7,12,7,332,9,7,1,8,1,8,1,9,1,9,1,
  	9,1,9,1,9,3,9,341,8,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,5,
  	10,352,8,10,10,10,12,10,355,9,10,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,
  	11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,3,11,375,8,11,1,
  	11,1,11,1,11,1,11,5,11,381,8,11,10,11,12,11,384,9,11,1,12,1,12,1,13,1,
  	13,3,13,390,8,13,1,14,1,14,3,14,394,8,14,1,15,1,15,1,15,1,15,1,16,1,16,
  	1,16,1,16,1,16,1,16,1,16,1,16,1,16,3,16,409,8,16,1,17,1,17,3,17,413,8,
  	17,1,18,1,18,3,18,417,8,18,1,18,1,18,1,19,1,19,3,19,423,8,19,1,20,1,20,
  	1,20,5,20,428,8,20,10,20,12,20,431,9,20,1,21,1,21,1,21,1,21,1,21,1,21,
  	1,21,3,21,440,8,21,3,21,442,8,21,1,22,1,22,1,22,1,22,1,22,1,23,1,23,1,
  	23,1,23,1,24,1,24,1,24,5,24,456,8,24,10,24,12,24,459,9,24,1,25,3,25,462,
  	8,25,1,25,1,25,3,25,466,8,25,1,25,1,25,1,25,1,25,1,26,1,26,3,26,474,8,
  	26,1,26,1,26,3,26,478,8,26,1,26,1,26,1,26,1,26,1,27,1,27,1,27,1,28,1,
  	28,1,28,1,28,4,28,491,8,28,11,28,12,28,492,1,28,1,28,3,28,497,8,28,1,
  	29,3,29,500,8,29,1,29,1,29,3,29,504,8,29,1,29,3,29,507,8,29,1,29,1,29,
  	3,29,511,8,29,1,30,1,30,1,30,1,31,3,31,517,8,31,1,31,1,31,3,31,521,8,
  	31,1,31,1,31,3,31,525,8,31,1,32,1,32,1,32,1,32,5,32,531,8,32,10,32,12,
  	32,534,9,32,1,32,1,32,3,32,538,8,32,3,32,540,8,32,1,33,1,33,1,33,5,33,
  	545,8,33,10,33,12,33,548,9,33,1,34,1,34,3,34,552,8,34,1,35,3,35,555,8,
  	35,1,35,3,35,558,8,35,1,35,1,35,1,35,3,35,563,8,35,1,35,3,35,566,8,35,
  	1,35,3,35,569,8,35,1,36,1,36,1,36,3,36,574,8,36,1,37,3,37,577,8,37,1,
  	37,3,37,580,8,37,1,37,1,37,3,37,584,8,37,1,38,1,38,1,39,1,39,3,39,590,
  	8,39,1,40,1,40,3,40,594,8,40,1,40,1,40,3,40,598,8,40,1,40,1,40,3,40,602,
  	8,40,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,42,1,42,3,42,613,8,42,1,42,
  	1,42,1,43,1,43,1,43,3,43,620,8,43,1,43,1,43,1,43,1,43,1,44,3,44,627,8,
  	44,1,44,1,44,1,44,3,44,632,8,44,1,44,1,44,1,44,1,44,1,44,1,44,3,44,640,
  	8,44,1,45,3,45,643,8,45,1,45,3,45,646,8,45,1,45,1,45,1,45,3,45,651,8,
  	45,1,45,3,45,654,8,45,1,45,1,45,3,45,658,8,45,1,46,1,46,1,46,1,47,1,47,
  	1,47,5,47,666,8,47,10,47,12,47,669,9,47,1,48,3,48,672,8,48,1,48,1,48,
  	1,48,1,48,3,48,678,8,48,1,48,1,48,1,49,1,49,3,49,684,8,49,1,50,1,50,1,
  	50,5,50,689,8,50,10,50,12,50,692,9,50,1,51,1,51,1,51,3,51,697,8,51,1,
  	52,1,52,1,52,1,52,3,52,703,8,52,1,52,1,52,1,53,1,53,4,53,709,8,53,11,
  	53,12,53,710,1,53,5,53,714,8,53,10,53,12,53,717,9,53,1,54,1,54,1,54,1,
  	54,1,54,1,55,4,55,725,8,55,11,55,12,55,726,1,56,1,56,1,56,3,56,732,8,
  	56,1,57,1,57,1,57,1,57,1,57,1,57,3,57,740,8,57,1,57,1,57,1,57,5,57,745,
  	8,57,10,57,12,57,748,9,57,1,58,1,58,1,58,1,59,3,59,754,8,59,1,59,1,59,
  	1,60,3,60,759,8,60,1,60,1,60,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,
  	1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,
  	1,61,1,61,1,61,1,61,1,61,1,61,1,61,3,61,792,8,61,1,62,1,62,3,62,796,8,
  	62,1,62,1,62,1,63,4,63,801,8,63,11,63,12,63,802,1,64,1,64,1,64,1,64,3,
  	64,809,8,64,1,64,1,64,1,65,1,65,1,65,3,65,816,8,65,1,66,1,66,3,66,820,
  	8,66,1,66,1,66,3,66,824,8,66,1,66,1,66,1,66,1,66,1,67,1,67,1,67,3,67,
  	833,8,67,1,67,1,67,1,67,1,67,5,67,839,8,67,10,67,12,67,842,9,67,1,67,
  	1,67,1,68,1,68,3,68,848,8,68,1,68,1,68,3,68,852,8,68,1,69,1,69,3,69,856,
  	8,69,1,69,1,69,3,69,860,8,69,1,69,3,69,863,8,69,1,69,3,69,866,8,69,1,
  	69,3,69,869,8,69,1,69,1,69,3,69,873,8,69,1,69,1,69,3,69,877,8,69,1,69,
  	1,69,3,69,881,8,69,3,69,883,8,69,1,70,1,70,1,70,5,70,888,8,70,10,70,12,
  	70,891,9,70,1,71,1,71,1,71,3,71,896,8,71,1,71,3,71,899,8,71,1,71,3,71,
  	902,8,71,1,71,1,71,3,71,906,8,71,1,71,3,71,909,8,71,1,72,1,72,1,73,1,
  	73,1,73,3,73,916,8,73,1,74,1,74,1,74,1,74,1,74,1,74,1,74,3,74,925,8,74,
  	1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,
  	1,75,1,75,1,75,3,75,944,8,75,1,75,1,75,3,75,948,8,75,1,75,1,75,3,75,952,
  	8,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,3,75,962,8,75,1,75,1,75,
  	3,75,966,8,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,3,75,977,8,
  	75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,3,75,990,8,
  	75,1,75,1,75,1,75,1,75,3,75,996,8,75,1,76,1,76,1,77,1,77,1,77,3,77,1003,
  	8,77,1,77,1,77,1,78,1,78,1,78,3,78,1010,8,78,1,78,1,78,1,79,1,79,1,79,
  	3,79,1017,8,79,1,79,1,79,1,80,1,80,1,80,3,80,1024,8,80,1,80,1,80,1,81,
  	1,81,1,81,1,81,1,81,1,81,1,82,1,82,1,82,1,82,1,82,1,82,1,83,1,83,3,83,
  	1042,8,83,1,83,1,83,3,83,1046,8,83,3,83,1048,8,83,1,83,1,83,1,84,4,84,
  	1053,8,84,11,84,12,84,1054,1,85,1,85,1,85,1,85,3,85,1061,8,85,1,86,1,
  	86,1,86,3,86,1066,8,86,1,87,1,87,1,87,1,87,1,88,1,88,1,88,1,88,1,88,1,
  	89,1,89,1,89,1,89,3,89,1081,8,89,1,89,3,89,1084,8,89,1,90,1,90,1,90,1,
  	90,1,90,1,90,1,91,1,91,1,91,1,92,1,92,1,92,1,93,1,93,1,93,1,93,1,93,1,
  	93,1,93,1,93,3,93,1106,8,93,1,94,3,94,1109,8,94,1,94,1,94,3,94,1113,8,
  	94,3,94,1115,8,94,1,94,3,94,1118,8,94,1,94,1,94,1,94,3,94,1123,8,94,1,
  	94,1,94,1,94,1,95,3,95,1129,8,95,1,95,3,95,1132,8,95,1,96,1,96,5,96,1136,
  	8,96,10,96,12,96,1139,9,96,1,96,1,96,1,97,1,97,1,97,1,98,1,98,1,98,1,
  	99,1,99,3,99,1151,8,99,1,99,1,99,1,99,3,99,1156,8,99,1,100,1,100,1,100,
  	3,100,1161,8,100,1,100,3,100,1164,8,100,1,100,3,100,1167,8,100,1,100,
  	1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,3,100,1179,8,100,
  	1,100,1,100,1,100,3,100,1184,8,100,1,100,3,100,1187,8,100,1,101,3,101,
  	1190,8,101,1,101,3,101,1193,8,101,1,101,3,101,1196,8,101,1,101,3,101,
  	1199,8,101,1,102,1,102,1,102,1,103,3,103,1205,8,103,1,103,1,103,1,103,
  	3,103,1210,8,103,1,103,1,103,1,103,1,103,1,103,1,104,1,104,1,104,3,104,
  	1220,8,104,1,104,1,104,3,104,1224,8,104,1,104,1,104,1,104,1,104,1,104,
  	1,105,1,105,1,105,1,105,5,105,1235,8,105,10,105,12,105,1238,9,105,1,105,
  	3,105,1241,8,105,1,105,1,105,1,106,1,106,1,106,1,107,1,107,1,107,1,107,
  	5,107,1252,8,107,10,107,12,107,1255,9,107,1,107,3,107,1258,8,107,1,107,
  	1,107,1,108,1,108,1,108,1,108,1,108,3,108,1267,8,108,1,108,1,108,1,108,
  	1,108,1,108,1,109,1,109,1,109,5,109,1277,8,109,10,109,12,109,1280,9,109,
  	1,109,1,109,3,109,1284,8,109,1,109,1,109,1,109,1,109,1,109,3,109,1291,
  	8,109,3,109,1293,8,109,1,110,3,110,1296,8,110,1,110,3,110,1299,8,110,
  	1,110,1,110,3,110,1303,8,110,1,110,3,110,1306,8,110,1,110,1,110,3,110,
  	1310,8,110,1,111,1,111,1,111,3,111,1315,8,111,1,112,3,112,1318,8,112,
  	1,113,4,113,1321,8,113,11,113,12,113,1322,1,114,1,114,3,114,1327,8,114,
  	1,114,1,114,1,115,1,115,4,115,1333,8,115,11,115,12,115,1334,1,115,5,115,
  	1338,8,115,10,115,12,115,1341,9,115,1,116,3,116,1344,8,116,1,116,1,116,
  	3,116,1348,8,116,1,116,3,116,1351,8,116,1,117,1,117,1,117,1,117,5,117,
  	1357,8,117,10,117,12,117,1360,9,117,1,117,3,117,1363,8,117,3,117,1365,
  	8,117,1,117,1,117,1,118,1,118,1,118,1,118,1,118,1,118,1,118,1,118,1,118,
  	1,118,1,118,1,118,1,118,1,118,1,118,3,118,1384,8,118,1,119,1,119,1,119,
  	1,119,3,119,1390,8,119,1,119,1,119,1,119,1,119,1,120,1,120,1,120,1,120,
  	3,120,1400,8,120,1,120,3,120,1403,8,120,1,120,1,120,1,120,1,120,1,120,
  	1,121,1,121,1,121,3,121,1413,8,121,1,122,1,122,1,122,3,122,1418,8,122,
  	3,122,1420,8,122,1,122,1,122,1,123,1,123,1,123,5,123,1427,8,123,10,123,
  	12,123,1430,9,123,1,124,3,124,1433,8,124,1,124,1,124,3,124,1437,8,124,
  	1,125,1,125,1,125,5,125,1442,8,125,10,125,12,125,1445,9,125,1,126,1,126,
  	3,126,1449,8,126,1,126,1,126,3,126,1453,8,126,1,126,1,126,3,126,1457,
  	8,126,1,126,1,126,1,126,1,126,1,127,1,127,1,127,1,127,1,127,1,127,3,127,
  	1469,8,127,1,127,1,127,1,127,1,127,1,127,3,127,1476,8,127,1,127,1,127,
  	1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,
  	1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,3,127,
  	1503,8,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,
  	3,127,1515,8,127,3,127,1517,8,127,1,127,1,127,1,127,1,127,1,127,1,127,
  	1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,
  	1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,
  	1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,
  	1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,
  	1,127,1,127,3,127,1575,8,127,1,127,1,127,1,127,3,127,1580,8,127,1,127,
  	1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,
  	5,127,1595,8,127,10,127,12,127,1598,9,127,1,128,1,128,1,128,3,128,1603,
  	8,128,1,128,3,128,1606,8,128,1,129,3,129,1609,8,129,1,129,1,129,3,129,
  	1613,8,129,1,129,1,129,1,129,1,130,1,130,1,130,3,130,1621,8,130,1,130,
  	3,130,1624,8,130,1,131,1,131,1,131,1,131,1,131,3,131,1631,8,131,1,132,
  	1,132,1,133,1,133,1,133,1,133,1,133,1,133,3,133,1641,8,133,1,134,1,134,
  	5,134,1645,8,134,10,134,12,134,1648,9,134,1,134,1,134,1,135,1,135,1,135,
  	1,135,1,135,1,135,3,135,1658,8,135,1,136,1,136,1,137,1,137,3,137,1664,
  	8,137,1,138,1,138,1,139,1,139,1,139,3,139,1671,8,139,1,140,1,140,1,141,
  	1,141,1,141,1,142,1,142,1,142,1,143,1,143,1,143,1,143,3,143,1685,8,143,
  	1,143,0,4,20,22,114,254,144,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,
  	32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,
  	78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,
  	118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,
  	154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,
  	190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,
  	226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,
  	262,264,266,268,270,272,274,276,278,280,282,284,286,0,15,2,0,73,73,108,
  	112,1,0,11,12,2,0,101,102,105,105,2,0,109,109,111,111,3,0,69,69,96,96,
  	100,100,2,0,13,13,15,15,1,0,24,26,1,0,20,21,1,0,27,29,1,0,30,33,1,0,34,
  	37,1,0,43,53,1,0,57,61,3,0,113,113,118,118,124,124,5,0,62,87,89,107,109,
  	111,113,115,118,119,1863,0,288,1,0,0,0,2,293,1,0,0,0,4,295,1,0,0,0,6,
  	301,1,0,0,0,8,314,1,0,0,0,10,316,1,0,0,0,12,319,1,0,0,0,14,325,1,0,0,
  	0,16,333,1,0,0,0,18,340,1,0,0,0,20,342,1,0,0,0,22,374,1,0,0,0,24,385,
  	1,0,0,0,26,387,1,0,0,0,28,393,1,0,0,0,30,395,1,0,0,0,32,399,1,0,0,0,34,
  	412,1,0,0,0,36,414,1,0,0,0,38,420,1,0,0,0,40,424,1,0,0,0,42,441,1,0,0,
  	0,44,443,1,0,0,0,46,448,1,0,0,0,48,452,1,0,0,0,50,461,1,0,0,0,52,471,
  	1,0,0,0,54,483,1,0,0,0,56,496,1,0,0,0,58,499,1,0,0,0,60,512,1,0,0,0,62,
  	516,1,0,0,0,64,539,1,0,0,0,66,541,1,0,0,0,68,551,1,0,0,0,70,554,1,0,0,
  	0,72,570,1,0,0,0,74,576,1,0,0,0,76,585,1,0,0,0,78,589,1,0,0,0,80,591,
  	1,0,0,0,82,603,1,0,0,0,84,610,1,0,0,0,86,616,1,0,0,0,88,626,1,0,0,0,90,
  	642,1,0,0,0,92,659,1,0,0,0,94,662,1,0,0,0,96,671,1,0,0,0,98,681,1,0,0,
  	0,100,685,1,0,0,0,102,693,1,0,0,0,104,698,1,0,0,0,106,706,1,0,0,0,108,
  	718,1,0,0,0,110,724,1,0,0,0,112,728,1,0,0,0,114,739,1,0,0,0,116,749,1,
  	0,0,0,118,753,1,0,0,0,120,758,1,0,0,0,122,791,1,0,0,0,124,793,1,0,0,0,
  	126,800,1,0,0,0,128,804,1,0,0,0,130,812,1,0,0,0,132,819,1,0,0,0,134,832,
  	1,0,0,0,136,845,1,0,0,0,138,882,1,0,0,0,140,884,1,0,0,0,142,895,1,0,0,
  	0,144,910,1,0,0,0,146,912,1,0,0,0,148,917,1,0,0,0,150,995,1,0,0,0,152,
  	997,1,0,0,0,154,999,1,0,0,0,156,1006,1,0,0,0,158,1013,1,0,0,0,160,1020,
  	1,0,0,0,162,1027,1,0,0,0,164,1033,1,0,0,0,166,1039,1,0,0,0,168,1052,1,
  	0,0,0,170,1056,1,0,0,0,172,1062,1,0,0,0,174,1067,1,0,0,0,176,1071,1,0,
  	0,0,178,1076,1,0,0,0,180,1085,1,0,0,0,182,1091,1,0,0,0,184,1094,1,0,0,
  	0,186,1097,1,0,0,0,188,1108,1,0,0,0,190,1128,1,0,0,0,192,1133,1,0,0,0,
  	194,1142,1,0,0,0,196,1145,1,0,0,0,198,1155,1,0,0,0,200,1186,1,0,0,0,202,
  	1189,1,0,0,0,204,1200,1,0,0,0,206,1204,1,0,0,0,208,1216,1,0,0,0,210,1230,
  	1,0,0,0,212,1244,1,0,0,0,214,1247,1,0,0,0,216,1261,1,0,0,0,218,1292,1,
  	0,0,0,220,1295,1,0,0,0,222,1311,1,0,0,0,224,1317,1,0,0,0,226,1320,1,0,
  	0,0,228,1324,1,0,0,0,230,1330,1,0,0,0,232,1343,1,0,0,0,234,1352,1,0,0,
  	0,236,1383,1,0,0,0,238,1385,1,0,0,0,240,1395,1,0,0,0,242,1412,1,0,0,0,
  	244,1414,1,0,0,0,246,1423,1,0,0,0,248,1432,1,0,0,0,250,1438,1,0,0,0,252,
  	1446,1,0,0,0,254,1516,1,0,0,0,256,1605,1,0,0,0,258,1608,1,0,0,0,260,1623,
  	1,0,0,0,262,1630,1,0,0,0,264,1632,1,0,0,0,266,1640,1,0,0,0,268,1642,1,
  	0,0,0,270,1657,1,0,0,0,272,1659,1,0,0,0,274,1663,1,0,0,0,276,1665,1,0,
  	0,0,278,1670,1,0,0,0,280,1672,1,0,0,0,282,1674,1,0,0,0,284,1677,1,0,0,
  	0,286,1684,1,0,0,0,288,289,5,13,0,0,289,290,3,254,127,0,290,1,1,0,0,0,
  	291,294,3,228,114,0,292,294,3,234,117,0,293,291,1,0,0,0,293,292,1,0,0,
  	0,294,3,1,0,0,0,295,297,5,30,0,0,296,298,3,6,3,0,297,296,1,0,0,0,297,
  	298,1,0,0,0,298,299,1,0,0,0,299,300,5,31,0,0,300,5,1,0,0,0,301,306,3,
  	8,4,0,302,303,5,12,0,0,303,305,3,8,4,0,304,302,1,0,0,0,305,308,1,0,0,
  	0,306,304,1,0,0,0,306,307,1,0,0,0,307,7,1,0,0,0,308,306,1,0,0,0,309,311,
  	5,124,0,0,310,312,3,10,5,0,311,310,1,0,0,0,311,312,1,0,0,0,312,315,1,
  	0,0,0,313,315,3,4,2,0,314,309,1,0,0,0,314,313,1,0,0,0,315,9,1,0,0,0,316,
  	317,5,94,0,0,317,318,3,18,9,0,318,11,1,0,0,0,319,321,5,30,0,0,320,322,
  	3,14,7,0,321,320,1,0,0,0,321,322,1,0,0,0,322,323,1,0,0,0,323,324,5,31,
  	0,0,324,13,1,0,0,0,325,330,3,16,8,0,326,327,5,12,0,0,327,329,3,16,8,0,
  	328,326,1,0,0,0,329,332,1,0,0,0,330,328,1,0,0,0,330,331,1,0,0,0,331,15,
  	1,0,0,0,332,330,1,0,0,0,333,334,3,18,9,0,334,17,1,0,0,0,335,341,3,20,
  	10,0,336,341,3,50,25,0,337,341,3,52,26,0,338,341,3,30,15,0,339,341,5,
  	125,0,0,340,335,1,0,0,0,340,336,1,0,0,0,340,337,1,0,0,0,340,338,1,0,0,
  	0,340,339,1,0,0,0,341,19,1,0,0,0,342,343,6,10,-1,0,343,344,3,22,11,0,
  	344,353,1,0,0,0,345,346,10,3,0,0,346,347,5,40,0,0,347,352,3,20,10,4,348,
  	349,10,2,0,0,349,350,5,38,0,0,350,352,3,20,10,3,351,345,1,0,0,0,351,348,
  	1,0,0,0,352,355,1,0,0,0,353,351,1,0,0,0,353,354,1,0,0,0,354,21,1,0,0,
  	0,355,353,1,0,0,0,356,357,6,11,-1,0,357,358,5,6,0,0,358,359,3,18,9,0,
  	359,360,5,7,0,0,360,375,1,0,0,0,361,375,3,24,12,0,362,375,3,26,13,0,363,
  	375,3,36,18,0,364,365,5,4,0,0,365,366,3,48,24,0,366,367,5,5,0,0,367,375,
  	1,0,0,0,368,375,3,54,27,0,369,375,5,80,0,0,370,371,3,26,13,0,371,372,
  	5,122,0,0,372,373,3,22,11,1,373,375,1,0,0,0,374,356,1,0,0,0,374,361,1,
  	0,0,0,374,362,1,0,0,0,374,363,1,0,0,0,374,364,1,0,0,0,374,368,1,0,0,0,
  	374,369,1,0,0,0,374,370,1,0,0,0,375,382,1,0,0,0,376,377,10,5,0,0,377,
  	378,4,11,3,0,378,379,5,4,0,0,379,381,5,5,0,0,380,376,1,0,0,0,381,384,
  	1,0,0,0,382,380,1,0,0,0,382,383,1,0,0,0,383,23,1,0,0,0,384,382,1,0,0,
  	0,385,386,7,0,0,0,386,25,1,0,0,0,387,389,3,34,17,0,388,390,3,28,14,0,
  	389,388,1,0,0,0,389,390,1,0,0,0,390,27,1,0,0,0,391,394,3,32,16,0,392,
  	394,3,30,15,0,393,391,1,0,0,0,393,392,1,0,0,0,394,29,1,0,0,0,395,396,
  	5,30,0,0,396,397,3,14,7,0,397,398,5,31,0,0,398,31,1,0,0,0,399,400,5,30,
  	0,0,400,401,3,14,7,0,401,402,5,30,0,0,402,408,3,14,7,0,403,404,5,31,0,
  	0,404,405,3,2,1,0,405,406,5,31,0,0,406,409,1,0,0,0,407,409,5,27,0,0,408,
  	403,1,0,0,0,408,407,1,0,0,0,409,33,1,0,0,0,410,413,5,124,0,0,411,413,
  	3,106,53,0,412,410,1,0,0,0,412,411,1,0,0,0,413,35,1,0,0,0,414,416,5,8,
  	0,0,415,417,3,38,19,0,416,415,1,0,0,0,416,417,1,0,0,0,417,418,1,0,0,0,
  	418,419,5,10,0,0,419,37,1,0,0,0,420,422,3,40,20,0,421,423,7,1,0,0,422,
  	421,1,0,0,0,422,423,1,0,0,0,423,39,1,0,0,0,424,429,3,42,21,0,425,426,
  	7,1,0,0,426,428,3,42,21,0,427,425,1,0,0,0,428,431,1,0,0,0,429,427,1,0,
  	0,0,429,430,1,0,0,0,430,41,1,0,0,0,431,429,1,0,0,0,432,442,3,58,29,0,
  	433,442,3,62,31,0,434,442,3,80,40,0,435,442,3,82,41,0,436,439,3,84,42,
  	0,437,438,5,54,0,0,438,440,3,18,9,0,439,437,1,0,0,0,439,440,1,0,0,0,440,
  	442,1,0,0,0,441,432,1,0,0,0,441,433,1,0,0,0,441,434,1,0,0,0,441,435,1,
  	0,0,0,441,436,1,0,0,0,442,43,1,0,0,0,443,444,3,22,11,0,444,445,4,22,4,
  	0,445,446,5,4,0,0,446,447,5,5,0,0,447,45,1,0,0,0,448,449,5,4,0,0,449,
  	450,3,48,24,0,450,451,5,5,0,0,451,47,1,0,0,0,452,457,3,18,9,0,453,454,
  	5,12,0,0,454,456,3,18,9,0,455,453,1,0,0,0,456,459,1,0,0,0,457,455,1,0,
  	0,0,457,458,1,0,0,0,458,49,1,0,0,0,459,457,1,0,0,0,460,462,3,4,2,0,461,
  	460,1,0,0,0,461,462,1,0,0,0,462,463,1,0,0,0,463,465,5,6,0,0,464,466,3,
  	64,32,0,465,464,1,0,0,0,465,466,1,0,0,0,466,467,1,0,0,0,467,468,5,7,0,
  	0,468,469,5,54,0,0,469,470,3,18,9,0,470,51,1,0,0,0,471,473,5,68,0,0,472,
  	474,3,4,2,0,473,472,1,0,0,0,473,474,1,0,0,0,474,475,1,0,0,0,475,477,5,
  	6,0,0,476,478,3,64,32,0,477,476,1,0,0,0,477,478,1,0,0,0,478,479,1,0,0,
  	0,479,480,5,7,0,0,480,481,5,54,0,0,481,482,3,18,9,0,482,53,1,0,0,0,483,
  	484,5,65,0,0,484,485,3,56,28,0,485,55,1,0,0,0,486,497,5,124,0,0,487,488,
  	3,274,137,0,488,489,5,17,0,0,489,491,1,0,0,0,490,487,1,0,0,0,491,492,
  	1,0,0,0,492,490,1,0,0,0,492,493,1,0,0,0,493,494,1,0,0,0,494,495,3,274,
  	137,0,495,497,1,0,0,0,496,486,1,0,0,0,496,490,1,0,0,0,497,57,1,0,0,0,
  	498,500,5,90,0,0,499,498,1,0,0,0,499,500,1,0,0,0,500,501,1,0,0,0,501,
  	503,3,242,121,0,502,504,5,14,0,0,503,502,1,0,0,0,503,504,1,0,0,0,504,
  	506,1,0,0,0,505,507,3,60,30,0,506,505,1,0,0,0,506,507,1,0,0,0,507,510,
  	1,0,0,0,508,509,5,54,0,0,509,511,3,18,9,0,510,508,1,0,0,0,510,511,1,0,
  	0,0,511,59,1,0,0,0,512,513,5,15,0,0,513,514,3,18,9,0,514,61,1,0,0,0,515,
  	517,3,4,2,0,516,515,1,0,0,0,516,517,1,0,0,0,517,518,1,0,0,0,518,520,5,
  	6,0,0,519,521,3,64,32,0,520,519,1,0,0,0,520,521,1,0,0,0,521,522,1,0,0,
  	0,522,524,5,7,0,0,523,525,3,60,30,0,524,523,1,0,0,0,524,525,1,0,0,0,525,
  	63,1,0,0,0,526,540,3,72,36,0,527,532,3,68,34,0,528,529,5,12,0,0,529,531,
  	3,68,34,0,530,528,1,0,0,0,531,534,1,0,0,0,532,530,1,0,0,0,532,533,1,0,
  	0,0,533,537,1,0,0,0,534,532,1,0,0,0,535,536,5,12,0,0,536,538,3,72,36,
  	0,537,535,1,0,0,0,537,538,1,0,0,0,538,540,1,0,0,0,539,526,1,0,0,0,539,
  	527,1,0,0,0,540,65,1,0,0,0,541,546,3,74,37,0,542,543,5,12,0,0,543,545,
  	3,74,37,0,544,542,1,0,0,0,545,548,1,0,0,0,546,544,1,0,0,0,546,547,1,0,
  	0,0,547,67,1,0,0,0,548,546,1,0,0,0,549,552,3,74,37,0,550,552,3,70,35,
  	0,551,549,1,0,0,0,551,550,1,0,0,0,552,69,1,0,0,0,553,555,3,110,55,0,554,
  	553,1,0,0,0,554,555,1,0,0,0,555,557,1,0,0,0,556,558,3,76,38,0,557,556,
  	1,0,0,0,557,558,1,0,0,0,558,559,1,0,0,0,559,568,3,78,39,0,560,562,5,14,
  	0,0,561,563,3,60,30,0,562,561,1,0,0,0,562,563,1,0,0,0,563,569,1,0,0,0,
  	564,566,3,60,30,0,565,564,1,0,0,0,565,566,1,0,0,0,566,567,1,0,0,0,567,
  	569,3,0,0,0,568,560,1,0,0,0,568,565,1,0,0,0,569,71,1,0,0,0,570,571,5,
  	16,0,0,571,573,3,254,127,0,572,574,3,60,30,0,573,572,1,0,0,0,573,574,
  	1,0,0,0,574,73,1,0,0,0,575,577,3,110,55,0,576,575,1,0,0,0,576,577,1,0,
  	0,0,577,579,1,0,0,0,578,580,3,76,38,0,579,578,1,0,0,0,579,580,1,0,0,0,
  	580,581,1,0,0,0,581,583,3,78,39,0,582,584,3,60,30,0,583,582,1,0,0,0,583,
  	584,1,0,0,0,584,75,1,0,0,0,585,586,7,2,0,0,586,77,1,0,0,0,587,590,3,274,
  	137,0,588,590,3,2,1,0,589,587,1,0,0,0,589,588,1,0,0,0,590,79,1,0,0,0,
  	591,593,5,68,0,0,592,594,3,4,2,0,593,592,1,0,0,0,593,594,1,0,0,0,594,
  	595,1,0,0,0,595,597,5,6,0,0,596,598,3,64,32,0,597,596,1,0,0,0,597,598,
  	1,0,0,0,598,599,1,0,0,0,599,601,5,7,0,0,600,602,3,60,30,0,601,600,1,0,
  	0,0,601,602,1,0,0,0,602,81,1,0,0,0,603,604,5,4,0,0,604,605,5,124,0,0,
  	605,606,5,15,0,0,606,607,7,3,0,0,607,608,5,5,0,0,608,609,3,60,30,0,609,
  	83,1,0,0,0,610,612,3,242,121,0,611,613,5,14,0,0,612,611,1,0,0,0,612,613,
  	1,0,0,0,613,614,1,0,0,0,614,615,3,62,31,0,615,85,1,0,0,0,616,617,5,113,
  	0,0,617,619,5,124,0,0,618,620,3,4,2,0,619,618,1,0,0,0,619,620,1,0,0,0,
  	620,621,1,0,0,0,621,622,5,13,0,0,622,623,3,18,9,0,623,624,5,11,0,0,624,
  	87,1,0,0,0,625,627,3,76,38,0,626,625,1,0,0,0,626,627,1,0,0,0,627,628,
  	1,0,0,0,628,629,5,116,0,0,629,631,5,6,0,0,630,632,3,218,109,0,631,630,
  	1,0,0,0,631,632,1,0,0,0,632,633,1,0,0,0,633,639,5,7,0,0,634,635,5,8,0,
  	0,635,636,3,224,112,0,636,637,5,10,0,0,637,640,1,0,0,0,638,640,5,11,0,
  	0,639,634,1,0,0,0,639,638,1,0,0,0,639,640,1,0,0,0,640,89,1,0,0,0,641,
  	643,5,97,0,0,642,641,1,0,0,0,642,643,1,0,0,0,643,645,1,0,0,0,644,646,
  	5,120,0,0,645,644,1,0,0,0,645,646,1,0,0,0,646,647,1,0,0,0,647,648,5,103,
  	0,0,648,650,5,124,0,0,649,651,3,4,2,0,650,649,1,0,0,0,650,651,1,0,0,0,
  	651,653,1,0,0,0,652,654,3,92,46,0,653,652,1,0,0,0,653,654,1,0,0,0,654,
  	655,1,0,0,0,655,657,3,36,18,0,656,658,5,11,0,0,657,656,1,0,0,0,657,658,
  	1,0,0,0,658,91,1,0,0,0,659,660,5,94,0,0,660,661,3,94,47,0,661,93,1,0,
  	0,0,662,667,3,26,13,0,663,664,5,12,0,0,664,666,3,26,13,0,665,663,1,0,
  	0,0,666,669,1,0,0,0,667,665,1,0,0,0,667,668,1,0,0,0,668,95,1,0,0,0,669,
  	667,1,0,0,0,670,672,5,96,0,0,671,670,1,0,0,0,671,672,1,0,0,0,672,673,
  	1,0,0,0,673,674,5,93,0,0,674,675,5,124,0,0,675,677,5,8,0,0,676,678,3,
  	98,49,0,677,676,1,0,0,0,677,678,1,0,0,0,678,679,1,0,0,0,679,680,5,10,
  	0,0,680,97,1,0,0,0,681,683,3,100,50,0,682,684,5,12,0,0,683,682,1,0,0,
  	0,683,684,1,0,0,0,684,99,1,0,0,0,685,690,3,102,51,0,686,687,5,12,0,0,
  	687,689,3,102,51,0,688,686,1,0,0,0,689,692,1,0,0,0,690,688,1,0,0,0,690,
  	691,1,0,0,0,691,101,1,0,0,0,692,690,1,0,0,0,693,696,3,242,121,0,694,695,
  	5,13,0,0,695,697,3,254,127,0,696,694,1,0,0,0,696,697,1,0,0,0,697,103,
  	1,0,0,0,698,699,5,117,0,0,699,700,3,106,53,0,700,702,5,8,0,0,701,703,
  	3,126,63,0,702,701,1,0,0,0,702,703,1,0,0,0,703,704,1,0,0,0,704,705,5,
  	10,0,0,705,105,1,0,0,0,706,715,5,124,0,0,707,709,5,17,0,0,708,707,1,0,
  	0,0,709,710,1,0,0,0,710,708,1,0,0,0,710,711,1,0,0,0,711,712,1,0,0,0,712,
  	714,5,124,0,0,713,708,1,0,0,0,714,717,1,0,0,0,715,713,1,0,0,0,715,716,
  	1,0,0,0,716,107,1,0,0,0,717,715,1,0,0,0,718,719,5,124,0,0,719,720,5,13,
  	0,0,720,721,3,106,53,0,721,722,5,11,0,0,722,109,1,0,0,0,723,725,3,112,
  	56,0,724,723,1,0,0,0,725,726,1,0,0,0,726,724,1,0,0,0,726,727,1,0,0,0,
  	727,111,1,0,0,0,728,731,5,123,0,0,729,732,3,114,57,0,730,732,3,116,58,
  	0,731,729,1,0,0,0,731,730,1,0,0,0,732,113,1,0,0,0,733,734,6,57,-1,0,734,
  	740,5,124,0,0,735,736,5,6,0,0,736,737,3,254,127,0,737,738,5,7,0,0,738,
  	740,1,0,0,0,739,733,1,0,0,0,739,735,1,0,0,0,740,746,1,0,0,0,741,742,10,
  	2,0,0,742,743,5,17,0,0,743,745,3,274,137,0,744,741,1,0,0,0,745,748,1,
  	0,0,0,746,744,1,0,0,0,746,747,1,0,0,0,747,115,1,0,0,0,748,746,1,0,0,0,
  	749,750,3,114,57,0,750,751,3,244,122,0,751,117,1,0,0,0,752,754,3,226,
  	113,0,753,752,1,0,0,0,753,754,1,0,0,0,754,755,1,0,0,0,755,756,5,0,0,1,
  	756,119,1,0,0,0,757,759,5,97,0,0,758,757,1,0,0,0,758,759,1,0,0,0,759,
  	760,1,0,0,0,760,761,3,122,61,0,761,121,1,0,0,0,762,792,3,124,62,0,763,
  	792,3,130,65,0,764,792,3,136,68,0,765,792,3,144,72,0,766,792,3,128,64,
  	0,767,792,3,188,94,0,768,792,3,90,45,0,769,792,3,104,52,0,770,792,3,148,
  	74,0,771,792,3,150,75,0,772,792,3,154,77,0,773,792,3,156,78,0,774,792,
  	3,158,79,0,775,792,3,160,80,0,776,792,3,162,81,0,777,792,3,174,87,0,778,
  	792,3,164,82,0,779,792,3,176,88,0,780,792,3,178,89,0,781,792,3,184,92,
  	0,782,792,3,186,93,0,783,792,3,258,129,0,784,792,3,208,104,0,785,792,
  	3,138,69,0,786,792,3,86,43,0,787,792,3,96,48,0,788,792,3,146,73,0,789,
  	790,5,97,0,0,790,792,3,122,61,0,791,762,1,0,0,0,791,763,1,0,0,0,791,764,
  	1,0,0,0,791,765,1,0,0,0,791,766,1,0,0,0,791,767,1,0,0,0,791,768,1,0,0,
  	0,791,769,1,0,0,0,791,770,1,0,0,0,791,771,1,0,0,0,791,772,1,0,0,0,791,
  	773,1,0,0,0,791,774,1,0,0,0,791,775,1,0,0,0,791,776,1,0,0,0,791,777,1,
  	0,0,0,791,778,1,0,0,0,791,779,1,0,0,0,791,780,1,0,0,0,791,781,1,0,0,0,
  	791,782,1,0,0,0,791,783,1,0,0,0,791,784,1,0,0,0,791,785,1,0,0,0,791,786,
  	1,0,0,0,791,787,1,0,0,0,791,788,1,0,0,0,791,789,1,0,0,0,792,123,1,0,0,
  	0,793,795,5,8,0,0,794,796,3,126,63,0,795,794,1,0,0,0,795,796,1,0,0,0,
  	796,797,1,0,0,0,797,798,5,10,0,0,798,125,1,0,0,0,799,801,3,122,61,0,800,
  	799,1,0,0,0,801,802,1,0,0,0,802,800,1,0,0,0,802,803,1,0,0,0,803,127,1,
  	0,0,0,804,808,5,121,0,0,805,806,5,124,0,0,806,809,3,62,31,0,807,809,3,
  	138,69,0,808,805,1,0,0,0,808,807,1,0,0,0,809,810,1,0,0,0,810,811,3,286,
  	143,0,811,129,1,0,0,0,812,815,5,98,0,0,813,816,3,132,66,0,814,816,3,108,
  	54,0,815,813,1,0,0,0,815,814,1,0,0,0,816,131,1,0,0,0,817,820,5,24,0,0,
  	818,820,3,134,67,0,819,817,1,0,0,0,819,818,1,0,0,0,820,823,1,0,0,0,821,
  	822,5,88,0,0,822,824,3,274,137,0,823,821,1,0,0,0,823,824,1,0,0,0,824,
  	825,1,0,0,0,825,826,5,89,0,0,826,827,5,125,0,0,827,828,3,286,143,0,828,
  	133,1,0,0,0,829,830,3,274,137,0,830,831,5,12,0,0,831,833,1,0,0,0,832,
  	829,1,0,0,0,832,833,1,0,0,0,833,834,1,0,0,0,834,835,5,8,0,0,835,840,3,
  	274,137,0,836,837,5,12,0,0,837,839,3,274,137,0,838,836,1,0,0,0,839,842,
  	1,0,0,0,840,838,1,0,0,0,840,841,1,0,0,0,841,843,1,0,0,0,842,840,1,0,0,
  	0,843,844,5,10,0,0,844,135,1,0,0,0,845,847,5,97,0,0,846,848,5,82,0,0,
  	847,846,1,0,0,0,847,848,1,0,0,0,848,851,1,0,0,0,849,852,3,132,66,0,850,
  	852,3,122,61,0,851,849,1,0,0,0,851,850,1,0,0,0,852,137,1,0,0,0,853,855,
  	3,2,1,0,854,856,3,60,30,0,855,854,1,0,0,0,855,856,1,0,0,0,856,857,1,0,
  	0,0,857,859,3,0,0,0,858,860,5,11,0,0,859,858,1,0,0,0,859,860,1,0,0,0,
  	860,883,1,0,0,0,861,863,3,76,38,0,862,861,1,0,0,0,862,863,1,0,0,0,863,
  	865,1,0,0,0,864,866,3,152,76,0,865,864,1,0,0,0,865,866,1,0,0,0,866,868,
  	1,0,0,0,867,869,5,90,0,0,868,867,1,0,0,0,868,869,1,0,0,0,869,870,1,0,
  	0,0,870,872,3,140,70,0,871,873,5,11,0,0,872,871,1,0,0,0,872,873,1,0,0,
  	0,873,883,1,0,0,0,874,876,5,120,0,0,875,877,3,152,76,0,876,875,1,0,0,
  	0,876,877,1,0,0,0,877,878,1,0,0,0,878,880,3,140,70,0,879,881,5,11,0,0,
  	880,879,1,0,0,0,880,881,1,0,0,0,881,883,1,0,0,0,882,853,1,0,0,0,882,862,
  	1,0,0,0,882,874,1,0,0,0,883,139,1,0,0,0,884,889,3,142,71,0,885,886,5,
  	12,0,0,886,888,3,142,71,0,887,885,1,0,0,0,888,891,1,0,0,0,889,887,1,0,
  	0,0,889,890,1,0,0,0,890,141,1,0,0,0,891,889,1,0,0,0,892,896,3,276,138,
  	0,893,896,3,228,114,0,894,896,3,234,117,0,895,892,1,0,0,0,895,893,1,0,
  	0,0,895,894,1,0,0,0,896,898,1,0,0,0,897,899,3,60,30,0,898,897,1,0,0,0,
  	898,899,1,0,0,0,899,901,1,0,0,0,900,902,3,254,127,0,901,900,1,0,0,0,901,
  	902,1,0,0,0,902,908,1,0,0,0,903,905,5,13,0,0,904,906,3,4,2,0,905,904,
  	1,0,0,0,905,906,1,0,0,0,906,907,1,0,0,0,907,909,3,254,127,0,908,903,1,
  	0,0,0,908,909,1,0,0,0,909,143,1,0,0,0,910,911,5,11,0,0,911,145,1,0,0,
  	0,912,913,4,73,6,0,913,915,3,250,125,0,914,916,5,11,0,0,915,914,1,0,0,
  	0,915,916,1,0,0,0,916,147,1,0,0,0,917,918,5,83,0,0,918,919,5,6,0,0,919,
  	920,3,250,125,0,920,921,5,7,0,0,921,924,3,122,61,0,922,923,5,67,0,0,923,
  	925,3,122,61,0,924,922,1,0,0,0,924,925,1,0,0,0,925,149,1,0,0,0,926,927,
  	5,63,0,0,927,928,3,122,61,0,928,929,5,77,0,0,929,930,5,6,0,0,930,931,
  	3,250,125,0,931,932,5,7,0,0,932,933,3,286,143,0,933,996,1,0,0,0,934,935,
  	5,77,0,0,935,936,5,6,0,0,936,937,3,250,125,0,937,938,5,7,0,0,938,939,
  	3,122,61,0,939,996,1,0,0,0,940,941,5,75,0,0,941,943,5,6,0,0,942,944,3,
  	250,125,0,943,942,1,0,0,0,943,944,1,0,0,0,944,945,1,0,0,0,945,947,5,11,
  	0,0,946,948,3,250,125,0,947,946,1,0,0,0,947,948,1,0,0,0,948,949,1,0,0,
  	0,949,951,5,11,0,0,950,952,3,250,125,0,951,950,1,0,0,0,951,952,1,0,0,
  	0,952,953,1,0,0,0,953,954,5,7,0,0,954,996,3,122,61,0,955,956,5,75,0,0,
  	956,957,5,6,0,0,957,958,3,152,76,0,958,959,3,140,70,0,959,961,5,11,0,
  	0,960,962,3,250,125,0,961,960,1,0,0,0,961,962,1,0,0,0,962,963,1,0,0,0,
  	963,965,5,11,0,0,964,966,3,250,125,0,965,964,1,0,0,0,965,966,1,0,0,0,
  	966,967,1,0,0,0,967,968,5,7,0,0,968,969,3,122,61,0,969,996,1,0,0,0,970,
  	971,5,75,0,0,971,972,5,6,0,0,972,976,3,254,127,0,973,977,5,86,0,0,974,
  	975,5,124,0,0,975,977,4,75,7,0,976,973,1,0,0,0,976,974,1,0,0,0,977,978,
  	1,0,0,0,978,979,3,250,125,0,979,980,5,7,0,0,980,981,3,122,61,0,981,996,
  	1,0,0,0,982,983,5,75,0,0,983,984,5,6,0,0,984,985,3,152,76,0,985,989,3,
  	142,71,0,986,990,5,86,0,0,987,988,5,124,0,0,988,990,4,75,8,0,989,986,
  	1,0,0,0,989,987,1,0,0,0,990,991,1,0,0,0,991,992,3,250,125,0,992,993,5,
  	7,0,0,993,994,3,122,61,0,994,996,1,0,0,0,995,926,1,0,0,0,995,934,1,0,
  	0,0,995,940,1,0,0,0,995,955,1,0,0,0,995,970,1,0,0,0,995,982,1,0,0,0,996,
  	151,1,0,0,0,997,998,7,4,0,0,998,153,1,0,0,0,999,1002,5,74,0,0,1000,1001,
  	4,77,9,0,1001,1003,5,124,0,0,1002,1000,1,0,0,0,1002,1003,1,0,0,0,1003,
  	1004,1,0,0,0,1004,1005,3,286,143,0,1005,155,1,0,0,0,1006,1009,5,62,0,
  	0,1007,1008,4,78,10,0,1008,1010,5,124,0,0,1009,1007,1,0,0,0,1009,1010,
  	1,0,0,0,1010,1011,1,0,0,0,1011,1012,3,286,143,0,1012,157,1,0,0,0,1013,
  	1016,5,72,0,0,1014,1015,4,79,11,0,1015,1017,3,250,125,0,1016,1014,1,0,
  	0,0,1016,1017,1,0,0,0,1017,1018,1,0,0,0,1018,1019,3,286,143,0,1019,159,
  	1,0,0,0,1020,1023,5,107,0,0,1021,1022,4,80,12,0,1022,1024,3,250,125,0,
  	1023,1021,1,0,0,0,1023,1024,1,0,0,0,1024,1025,1,0,0,0,1025,1026,3,286,
  	143,0,1026,161,1,0,0,0,1027,1028,5,81,0,0,1028,1029,5,6,0,0,1029,1030,
  	3,250,125,0,1030,1031,5,7,0,0,1031,1032,3,122,61,0,1032,163,1,0,0,0,1033,
  	1034,5,76,0,0,1034,1035,5,6,0,0,1035,1036,3,250,125,0,1036,1037,5,7,0,
  	0,1037,1038,3,166,83,0,1038,165,1,0,0,0,1039,1041,5,8,0,0,1040,1042,3,
  	168,84,0,1041,1040,1,0,0,0,1041,1042,1,0,0,0,1042,1047,1,0,0,0,1043,1045,
  	3,172,86,0,1044,1046,3,168,84,0,1045,1044,1,0,0,0,1045,1046,1,0,0,0,1046,
  	1048,1,0,0,0,1047,1043,1,0,0,0,1047,1048,1,0,0,0,1048,1049,1,0,0,0,1049,
  	1050,5,10,0,0,1050,167,1,0,0,0,1051,1053,3,170,85,0,1052,1051,1,0,0,0,
  	1053,1054,1,0,0,0,1054,1052,1,0,0,0,1054,1055,1,0,0,0,1055,169,1,0,0,
  	0,1056,1057,5,66,0,0,1057,1058,3,250,125,0,1058,1060,5,15,0,0,1059,1061,
  	3,126,63,0,1060,1059,1,0,0,0,1060,1061,1,0,0,0,1061,171,1,0,0,0,1062,
  	1063,5,82,0,0,1063,1065,5,15,0,0,1064,1066,3,126,63,0,1065,1064,1,0,0,
  	0,1065,1066,1,0,0,0,1066,173,1,0,0,0,1067,1068,5,124,0,0,1068,1069,5,
  	15,0,0,1069,1070,3,122,61,0,1070,175,1,0,0,0,1071,1072,5,84,0,0,1072,
  	1073,4,88,13,0,1073,1074,3,250,125,0,1074,1075,3,286,143,0,1075,177,1,
  	0,0,0,1076,1077,5,87,0,0,1077,1083,3,124,62,0,1078,1080,3,180,90,0,1079,
  	1081,3,182,91,0,1080,1079,1,0,0,0,1080,1081,1,0,0,0,1081,1084,1,0,0,0,
  	1082,1084,3,182,91,0,1083,1078,1,0,0,0,1083,1082,1,0,0,0,1084,179,1,0,
  	0,0,1085,1086,5,70,0,0,1086,1087,5,6,0,0,1087,1088,5,124,0,0,1088,1089,
  	5,7,0,0,1089,1090,3,124,62,0,1090,181,1,0,0,0,1091,1092,5,71,0,0,1092,
  	1093,3,124,62,0,1093,183,1,0,0,0,1094,1095,5,78,0,0,1095,1096,3,286,143,
  	0,1096,185,1,0,0,0,1097,1098,5,79,0,0,1098,1099,5,124,0,0,1099,1105,3,
  	62,31,0,1100,1101,5,8,0,0,1101,1102,3,224,112,0,1102,1103,5,10,0,0,1103,
  	1106,1,0,0,0,1104,1106,5,11,0,0,1105,1100,1,0,0,0,1105,1104,1,0,0,0,1106,
  	187,1,0,0,0,1107,1109,3,110,55,0,1108,1107,1,0,0,0,1108,1109,1,0,0,0,
  	1109,1114,1,0,0,0,1110,1112,5,97,0,0,1111,1113,5,82,0,0,1112,1111,1,0,
  	0,0,1112,1113,1,0,0,0,1113,1115,1,0,0,0,1114,1110,1,0,0,0,1114,1115,1,
  	0,0,0,1115,1117,1,0,0,0,1116,1118,5,121,0,0,1117,1116,1,0,0,0,1117,1118,
  	1,0,0,0,1118,1119,1,0,0,0,1119,1120,5,92,0,0,1120,1122,5,124,0,0,1121,
  	1123,3,4,2,0,1122,1121,1,0,0,0,1122,1123,1,0,0,0,1123,1124,1,0,0,0,1124,
  	1125,3,190,95,0,1125,1126,3,192,96,0,1126,189,1,0,0,0,1127,1129,3,194,
  	97,0,1128,1127,1,0,0,0,1128,1129,1,0,0,0,1129,1131,1,0,0,0,1130,1132,
  	3,196,98,0,1131,1130,1,0,0,0,1131,1132,1,0,0,0,1132,191,1,0,0,0,1133,
  	1137,5,8,0,0,1134,1136,3,198,99,0,1135,1134,1,0,0,0,1136,1139,1,0,0,0,
  	1137,1135,1,0,0,0,1137,1138,1,0,0,0,1138,1140,1,0,0,0,1139,1137,1,0,0,
  	0,1140,1141,5,10,0,0,1141,193,1,0,0,0,1142,1143,5,94,0,0,1143,1144,3,
  	26,13,0,1144,195,1,0,0,0,1145,1146,5,99,0,0,1146,1147,3,94,47,0,1147,
  	197,1,0,0,0,1148,1156,3,88,44,0,1149,1151,3,110,55,0,1150,1149,1,0,0,
  	0,1150,1151,1,0,0,0,1151,1152,1,0,0,0,1152,1156,3,200,100,0,1153,1156,
  	3,204,102,0,1154,1156,3,122,61,0,1155,1148,1,0,0,0,1155,1150,1,0,0,0,
  	1155,1153,1,0,0,0,1155,1154,1,0,0,0,1156,199,1,0,0,0,1157,1158,3,202,
  	101,0,1158,1160,3,242,121,0,1159,1161,5,14,0,0,1160,1159,1,0,0,0,1160,
  	1161,1,0,0,0,1161,1163,1,0,0,0,1162,1164,3,60,30,0,1163,1162,1,0,0,0,
  	1163,1164,1,0,0,0,1164,1166,1,0,0,0,1165,1167,3,0,0,0,1166,1165,1,0,0,
  	0,1166,1167,1,0,0,0,1167,1168,1,0,0,0,1168,1169,5,11,0,0,1169,1187,1,
  	0,0,0,1170,1171,3,202,101,0,1171,1172,3,242,121,0,1172,1178,3,62,31,0,
  	1173,1174,5,8,0,0,1174,1175,3,224,112,0,1175,1176,5,10,0,0,1176,1179,
  	1,0,0,0,1177,1179,5,11,0,0,1178,1173,1,0,0,0,1178,1177,1,0,0,0,1179,1187,
  	1,0,0,0,1180,1183,3,202,101,0,1181,1184,3,238,119,0,1182,1184,3,240,120,
  	0,1183,1181,1,0,0,0,1183,1182,1,0,0,0,1184,1187,1,0,0,0,1185,1187,3,128,
  	64,0,1186,1157,1,0,0,0,1186,1170,1,0,0,0,1186,1180,1,0,0,0,1186,1185,
  	1,0,0,0,1187,201,1,0,0,0,1188,1190,3,76,38,0,1189,1188,1,0,0,0,1189,1190,
  	1,0,0,0,1190,1192,1,0,0,0,1191,1193,5,91,0,0,1192,1191,1,0,0,0,1192,1193,
  	1,0,0,0,1193,1195,1,0,0,0,1194,1196,5,106,0,0,1195,1194,1,0,0,0,1195,
  	1196,1,0,0,0,1196,1198,1,0,0,0,1197,1199,5,90,0,0,1198,1197,1,0,0,0,1198,
  	1199,1,0,0,0,1199,203,1,0,0,0,1200,1201,3,82,41,0,1201,1202,5,11,0,0,
  	1202,205,1,0,0,0,1203,1205,5,24,0,0,1204,1203,1,0,0,0,1204,1205,1,0,0,
  	0,1205,1206,1,0,0,0,1206,1207,5,124,0,0,1207,1209,5,6,0,0,1208,1210,3,
  	218,109,0,1209,1208,1,0,0,0,1209,1210,1,0,0,0,1210,1211,1,0,0,0,1211,
  	1212,5,7,0,0,1212,1213,5,8,0,0,1213,1214,3,224,112,0,1214,1215,5,10,0,
  	0,1215,207,1,0,0,0,1216,1217,5,79,0,0,1217,1219,5,24,0,0,1218,1220,5,
  	124,0,0,1219,1218,1,0,0,0,1219,1220,1,0,0,0,1220,1221,1,0,0,0,1221,1223,
  	5,6,0,0,1222,1224,3,218,109,0,1223,1222,1,0,0,0,1223,1224,1,0,0,0,1224,
  	1225,1,0,0,0,1225,1226,5,7,0,0,1226,1227,5,8,0,0,1227,1228,3,224,112,
  	0,1228,1229,5,10,0,0,1229,209,1,0,0,0,1230,1231,5,8,0,0,1231,1236,3,212,
  	106,0,1232,1233,5,12,0,0,1233,1235,3,212,106,0,1234,1232,1,0,0,0,1235,
  	1238,1,0,0,0,1236,1234,1,0,0,0,1236,1237,1,0,0,0,1237,1240,1,0,0,0,1238,
  	1236,1,0,0,0,1239,1241,5,12,0,0,1240,1239,1,0,0,0,1240,1241,1,0,0,0,1241,
  	1242,1,0,0,0,1242,1243,5,10,0,0,1243,211,1,0,0,0,1244,1245,5,24,0,0,1245,
  	1246,3,216,108,0,1246,213,1,0,0,0,1247,1248,5,8,0,0,1248,1253,3,216,108,
  	0,1249,1250,5,12,0,0,1250,1252,3,216,108,0,1251,1249,1,0,0,0,1252,1255,
  	1,0,0,0,1253,1251,1,0,0,0,1253,1254,1,0,0,0,1254,1257,1,0,0,0,1255,1253,
  	1,0,0,0,1256,1258,5,12,0,0,1257,1256,1,0,0,0,1257,1258,1,0,0,0,1258,1259,
  	1,0,0,0,1259,1260,5,10,0,0,1260,215,1,0,0,0,1261,1262,5,4,0,0,1262,1263,
  	3,254,127,0,1263,1264,5,5,0,0,1264,1266,5,6,0,0,1265,1267,3,218,109,0,
  	1266,1265,1,0,0,0,1266,1267,1,0,0,0,1267,1268,1,0,0,0,1268,1269,5,7,0,
  	0,1269,1270,5,8,0,0,1270,1271,3,224,112,0,1271,1272,5,10,0,0,1272,217,
  	1,0,0,0,1273,1278,3,220,110,0,1274,1275,5,12,0,0,1275,1277,3,220,110,
  	0,1276,1274,1,0,0,0,1277,1280,1,0,0,0,1278,1276,1,0,0,0,1278,1279,1,0,
  	0,0,1279,1283,1,0,0,0,1280,1278,1,0,0,0,1281,1282,5,12,0,0,1282,1284,
  	3,222,111,0,1283,1281,1,0,0,0,1283,1284,1,0,0,0,1284,1293,1,0,0,0,1285,
  	1293,3,222,111,0,1286,1293,3,228,114,0,1287,1290,3,234,117,0,1288,1289,
  	5,15,0,0,1289,1291,3,218,109,0,1290,1288,1,0,0,0,1290,1291,1,0,0,0,1291,
  	1293,1,0,0,0,1292,1273,1,0,0,0,1292,1285,1,0,0,0,1292,1286,1,0,0,0,1292,
  	1287,1,0,0,0,1293,219,1,0,0,0,1294,1296,3,112,56,0,1295,1294,1,0,0,0,
  	1295,1296,1,0,0,0,1296,1298,1,0,0,0,1297,1299,3,76,38,0,1298,1297,1,0,
  	0,0,1298,1299,1,0,0,0,1299,1300,1,0,0,0,1300,1302,3,276,138,0,1301,1303,
  	5,14,0,0,1302,1301,1,0,0,0,1302,1303,1,0,0,0,1303,1305,1,0,0,0,1304,1306,
  	3,60,30,0,1305,1304,1,0,0,0,1305,1306,1,0,0,0,1306,1309,1,0,0,0,1307,
  	1308,5,13,0,0,1308,1310,3,254,127,0,1309,1307,1,0,0,0,1309,1310,1,0,0,
  	0,1310,221,1,0,0,0,1311,1312,5,16,0,0,1312,1314,5,124,0,0,1313,1315,3,
  	60,30,0,1314,1313,1,0,0,0,1314,1315,1,0,0,0,1315,223,1,0,0,0,1316,1318,
  	3,226,113,0,1317,1316,1,0,0,0,1317,1318,1,0,0,0,1318,225,1,0,0,0,1319,
  	1321,3,120,60,0,1320,1319,1,0,0,0,1321,1322,1,0,0,0,1322,1320,1,0,0,0,
  	1322,1323,1,0,0,0,1323,227,1,0,0,0,1324,1326,5,4,0,0,1325,1327,3,230,
  	115,0,1326,1325,1,0,0,0,1326,1327,1,0,0,0,1327,1328,1,0,0,0,1328,1329,
  	5,5,0,0,1329,229,1,0,0,0,1330,1339,3,232,116,0,1331,1333,5,12,0,0,1332,
  	1331,1,0,0,0,1333,1334,1,0,0,0,1334,1332,1,0,0,0,1334,1335,1,0,0,0,1335,
  	1336,1,0,0,0,1336,1338,3,232,116,0,1337,1332,1,0,0,0,1338,1341,1,0,0,
  	0,1339,1337,1,0,0,0,1339,1340,1,0,0,0,1340,231,1,0,0,0,1341,1339,1,0,
  	0,0,1342,1344,5,16,0,0,1343,1342,1,0,0,0,1343,1344,1,0,0,0,1344,1347,
  	1,0,0,0,1345,1348,3,254,127,0,1346,1348,5,124,0,0,1347,1345,1,0,0,0,1347,
  	1346,1,0,0,0,1348,1350,1,0,0,0,1349,1351,5,12,0,0,1350,1349,1,0,0,0,1350,
  	1351,1,0,0,0,1351,233,1,0,0,0,1352,1364,5,8,0,0,1353,1358,3,236,118,0,
  	1354,1355,5,12,0,0,1355,1357,3,236,118,0,1356,1354,1,0,0,0,1357,1360,
  	1,0,0,0,1358,1356,1,0,0,0,1358,1359,1,0,0,0,1359,1362,1,0,0,0,1360,1358,
  	1,0,0,0,1361,1363,5,12,0,0,1362,1361,1,0,0,0,1362,1363,1,0,0,0,1363,1365,
  	1,0,0,0,1364,1353,1,0,0,0,1364,1365,1,0,0,0,1365,1366,1,0,0,0,1366,1367,
  	5,10,0,0,1367,235,1,0,0,0,1368,1369,3,242,121,0,1369,1370,7,5,0,0,1370,
  	1371,3,254,127,0,1371,1384,1,0,0,0,1372,1373,5,4,0,0,1373,1374,3,254,
  	127,0,1374,1375,5,5,0,0,1375,1376,5,15,0,0,1376,1377,3,254,127,0,1377,
  	1384,1,0,0,0,1378,1384,3,238,119,0,1379,1384,3,240,120,0,1380,1384,3,
  	206,103,0,1381,1384,3,276,138,0,1382,1384,3,72,36,0,1383,1368,1,0,0,0,
  	1383,1372,1,0,0,0,1383,1378,1,0,0,0,1383,1379,1,0,0,0,1383,1380,1,0,0,
  	0,1383,1381,1,0,0,0,1383,1382,1,0,0,0,1384,237,1,0,0,0,1385,1386,3,282,
  	141,0,1386,1387,5,6,0,0,1387,1389,5,7,0,0,1388,1390,3,60,30,0,1389,1388,
  	1,0,0,0,1389,1390,1,0,0,0,1390,1391,1,0,0,0,1391,1392,5,8,0,0,1392,1393,
  	3,224,112,0,1393,1394,5,10,0,0,1394,239,1,0,0,0,1395,1396,3,284,142,0,
  	1396,1399,5,6,0,0,1397,1400,5,124,0,0,1398,1400,3,2,1,0,1399,1397,1,0,
  	0,0,1399,1398,1,0,0,0,1400,1402,1,0,0,0,1401,1403,3,60,30,0,1402,1401,
  	1,0,0,0,1402,1403,1,0,0,0,1403,1404,1,0,0,0,1404,1405,5,7,0,0,1405,1406,
  	5,8,0,0,1406,1407,3,224,112,0,1407,1408,5,10,0,0,1408,241,1,0,0,0,1409,
  	1413,3,274,137,0,1410,1413,5,125,0,0,1411,1413,3,272,136,0,1412,1409,
  	1,0,0,0,1412,1410,1,0,0,0,1412,1411,1,0,0,0,1413,243,1,0,0,0,1414,1419,
  	5,6,0,0,1415,1417,3,246,123,0,1416,1418,5,12,0,0,1417,1416,1,0,0,0,1417,
  	1418,1,0,0,0,1418,1420,1,0,0,0,1419,1415,1,0,0,0,1419,1420,1,0,0,0,1420,
  	1421,1,0,0,0,1421,1422,5,7,0,0,1422,245,1,0,0,0,1423,1428,3,248,124,0,
  	1424,1425,5,12,0,0,1425,1427,3,248,124,0,1426,1424,1,0,0,0,1427,1430,
  	1,0,0,0,1428,1426,1,0,0,0,1428,1429,1,0,0,0,1429,247,1,0,0,0,1430,1428,
  	1,0,0,0,1431,1433,5,16,0,0,1432,1431,1,0,0,0,1432,1433,1,0,0,0,1433,1436,
  	1,0,0,0,1434,1437,3,254,127,0,1435,1437,5,124,0,0,1436,1434,1,0,0,0,1436,
  	1435,1,0,0,0,1437,249,1,0,0,0,1438,1443,3,254,127,0,1439,1440,5,12,0,
  	0,1440,1442,3,254,127,0,1441,1439,1,0,0,0,1442,1445,1,0,0,0,1443,1441,
  	1,0,0,0,1443,1444,1,0,0,0,1444,251,1,0,0,0,1445,1443,1,0,0,0,1446,1448,
  	5,79,0,0,1447,1449,5,124,0,0,1448,1447,1,0,0,0,1448,1449,1,0,0,0,1449,
  	1450,1,0,0,0,1450,1452,5,6,0,0,1451,1453,3,218,109,0,1452,1451,1,0,0,
  	0,1452,1453,1,0,0,0,1453,1454,1,0,0,0,1454,1456,5,7,0,0,1455,1457,3,60,
  	30,0,1456,1455,1,0,0,0,1456,1457,1,0,0,0,1457,1458,1,0,0,0,1458,1459,
  	5,8,0,0,1459,1460,3,224,112,0,1460,1461,5,10,0,0,1461,253,1,0,0,0,1462,
  	1463,6,127,-1,0,1463,1517,3,252,126,0,1464,1517,3,258,129,0,1465,1466,
  	5,68,0,0,1466,1468,3,254,127,0,1467,1469,3,12,6,0,1468,1467,1,0,0,0,1468,
  	1469,1,0,0,0,1469,1470,1,0,0,0,1470,1471,3,244,122,0,1471,1517,1,0,0,
  	0,1472,1473,5,68,0,0,1473,1475,3,254,127,0,1474,1476,3,12,6,0,1475,1474,
  	1,0,0,0,1475,1476,1,0,0,0,1476,1517,1,0,0,0,1477,1478,5,85,0,0,1478,1517,
  	3,254,127,38,1479,1480,5,73,0,0,1480,1517,3,254,127,37,1481,1482,5,65,
  	0,0,1482,1517,3,254,127,36,1483,1484,5,18,0,0,1484,1517,3,254,127,35,
  	1485,1486,5,19,0,0,1486,1517,3,254,127,34,1487,1488,5,20,0,0,1488,1517,
  	3,254,127,33,1489,1490,5,21,0,0,1490,1517,3,254,127,32,1491,1492,5,22,
  	0,0,1492,1517,3,254,127,31,1493,1494,5,23,0,0,1494,1517,3,254,127,30,
  	1495,1517,3,214,107,0,1496,1517,3,210,105,0,1497,1517,3,208,104,0,1498,
  	1517,3,160,80,0,1499,1517,5,80,0,0,1500,1502,3,274,137,0,1501,1503,3,
  	254,127,0,1502,1501,1,0,0,0,1502,1503,1,0,0,0,1503,1517,1,0,0,0,1504,
  	1517,5,95,0,0,1505,1517,3,266,133,0,1506,1517,3,228,114,0,1507,1517,3,
  	234,117,0,1508,1509,5,6,0,0,1509,1510,3,250,125,0,1510,1511,5,7,0,0,1511,
  	1517,1,0,0,0,1512,1514,3,12,6,0,1513,1515,3,250,125,0,1514,1513,1,0,0,
  	0,1514,1515,1,0,0,0,1515,1517,1,0,0,0,1516,1462,1,0,0,0,1516,1464,1,0,
  	0,0,1516,1465,1,0,0,0,1516,1472,1,0,0,0,1516,1477,1,0,0,0,1516,1479,1,
  	0,0,0,1516,1481,1,0,0,0,1516,1483,1,0,0,0,1516,1485,1,0,0,0,1516,1487,
  	1,0,0,0,1516,1489,1,0,0,0,1516,1491,1,0,0,0,1516,1493,1,0,0,0,1516,1495,
  	1,0,0,0,1516,1496,1,0,0,0,1516,1497,1,0,0,0,1516,1498,1,0,0,0,1516,1499,
  	1,0,0,0,1516,1500,1,0,0,0,1516,1504,1,0,0,0,1516,1505,1,0,0,0,1516,1506,
  	1,0,0,0,1516,1507,1,0,0,0,1516,1508,1,0,0,0,1516,1512,1,0,0,0,1517,1596,
  	1,0,0,0,1518,1519,10,29,0,0,1519,1520,7,6,0,0,1520,1595,3,254,127,30,
  	1521,1522,10,28,0,0,1522,1523,7,7,0,0,1523,1595,3,254,127,29,1524,1525,
  	10,27,0,0,1525,1526,7,8,0,0,1526,1595,3,254,127,28,1527,1528,10,26,0,
  	0,1528,1529,7,9,0,0,1529,1595,3,254,127,27,1530,1531,10,25,0,0,1531,1532,
  	5,64,0,0,1532,1595,3,254,127,26,1533,1534,10,24,0,0,1534,1535,5,86,0,
  	0,1535,1595,3,254,127,25,1536,1537,10,23,0,0,1537,1538,7,10,0,0,1538,
  	1595,3,254,127,24,1539,1540,10,22,0,0,1540,1541,5,38,0,0,1541,1595,3,
  	254,127,23,1542,1543,10,21,0,0,1543,1544,5,39,0,0,1544,1595,3,254,127,
  	22,1545,1546,10,20,0,0,1546,1547,5,40,0,0,1547,1595,3,254,127,21,1548,
  	1549,10,19,0,0,1549,1550,5,41,0,0,1550,1595,3,254,127,20,1551,1552,10,
  	18,0,0,1552,1553,5,42,0,0,1553,1595,3,254,127,19,1554,1555,10,17,0,0,
  	1555,1556,5,14,0,0,1556,1557,3,254,127,0,1557,1558,5,15,0,0,1558,1559,
  	3,254,127,18,1559,1595,1,0,0,0,1560,1561,10,16,0,0,1561,1562,5,13,0,0,
  	1562,1595,3,254,127,17,1563,1564,10,15,0,0,1564,1565,3,264,132,0,1565,
  	1566,3,254,127,16,1566,1595,1,0,0,0,1567,1568,10,45,0,0,1568,1569,5,4,
  	0,0,1569,1570,3,250,125,0,1570,1571,5,5,0,0,1571,1595,1,0,0,0,1572,1574,
  	10,44,0,0,1573,1575,5,23,0,0,1574,1573,1,0,0,0,1574,1575,1,0,0,0,1575,
  	1576,1,0,0,0,1576,1577,5,17,0,0,1577,1579,3,274,137,0,1578,1580,3,28,
  	14,0,1579,1578,1,0,0,0,1579,1580,1,0,0,0,1580,1595,1,0,0,0,1581,1582,
  	10,41,0,0,1582,1595,3,244,122,0,1583,1584,10,40,0,0,1584,1585,4,127,33,
  	0,1585,1595,5,18,0,0,1586,1587,10,39,0,0,1587,1588,4,127,35,0,1588,1595,
  	5,19,0,0,1589,1590,10,14,0,0,1590,1595,3,268,134,0,1591,1592,10,1,0,0,
  	1592,1593,5,88,0,0,1593,1595,3,256,128,0,1594,1518,1,0,0,0,1594,1521,
  	1,0,0,0,1594,1524,1,0,0,0,1594,1527,1,0,0,0,1594,1530,1,0,0,0,1594,1533,
  	1,0,0,0,1594,1536,1,0,0,0,1594,1539,1,0,0,0,1594,1542,1,0,0,0,1594,1545,
  	1,0,0,0,1594,1548,1,0,0,0,1594,1551,1,0,0,0,1594,1554,1,0,0,0,1594,1560,
  	1,0,0,0,1594,1563,1,0,0,0,1594,1567,1,0,0,0,1594,1572,1,0,0,0,1594,1581,
  	1,0,0,0,1594,1583,1,0,0,0,1594,1586,1,0,0,0,1594,1589,1,0,0,0,1594,1591,
  	1,0,0,0,1595,1598,1,0,0,0,1596,1594,1,0,0,0,1596,1597,1,0,0,0,1597,255,
  	1,0,0,0,1598,1596,1,0,0,0,1599,1602,3,24,12,0,1600,1601,5,4,0,0,1601,
  	1603,5,5,0,0,1602,1600,1,0,0,0,1602,1603,1,0,0,0,1603,1606,1,0,0,0,1604,
  	1606,3,254,127,0,1605,1599,1,0,0,0,1605,1604,1,0,0,0,1606,257,1,0,0,0,
  	1607,1609,5,91,0,0,1608,1607,1,0,0,0,1608,1609,1,0,0,0,1609,1610,1,0,
  	0,0,1610,1612,3,260,130,0,1611,1613,3,60,30,0,1612,1611,1,0,0,0,1612,
  	1613,1,0,0,0,1613,1614,1,0,0,0,1614,1615,5,54,0,0,1615,1616,3,262,131,
  	0,1616,259,1,0,0,0,1617,1624,5,124,0,0,1618,1620,5,6,0,0,1619,1621,3,
  	218,109,0,1620,1619,1,0,0,0,1620,1621,1,0,0,0,1621,1622,1,0,0,0,1622,
  	1624,5,7,0,0,1623,1617,1,0,0,0,1623,1618,1,0,0,0,1624,261,1,0,0,0,1625,
  	1631,3,254,127,0,1626,1627,5,8,0,0,1627,1628,3,224,112,0,1628,1629,5,
  	10,0,0,1629,1631,1,0,0,0,1630,1625,1,0,0,0,1630,1626,1,0,0,0,1631,263,
  	1,0,0,0,1632,1633,7,11,0,0,1633,265,1,0,0,0,1634,1641,5,55,0,0,1635,1641,
  	5,56,0,0,1636,1641,5,125,0,0,1637,1641,3,268,134,0,1638,1641,5,3,0,0,
  	1639,1641,3,272,136,0,1640,1634,1,0,0,0,1640,1635,1,0,0,0,1640,1636,1,
  	0,0,0,1640,1637,1,0,0,0,1640,1638,1,0,0,0,1640,1639,1,0,0,0,1641,267,
  	1,0,0,0,1642,1646,5,126,0,0,1643,1645,3,270,135,0,1644,1643,1,0,0,0,1645,
  	1648,1,0,0,0,1646,1644,1,0,0,0,1646,1647,1,0,0,0,1647,1649,1,0,0,0,1648,
  	1646,1,0,0,0,1649,1650,5,126,0,0,1650,269,1,0,0,0,1651,1658,5,134,0,0,
  	1652,1653,5,133,0,0,1653,1654,3,254,127,0,1654,1655,5,9,0,0,1655,1658,
  	1,0,0,0,1656,1658,5,132,0,0,1657,1651,1,0,0,0,1657,1652,1,0,0,0,1657,
  	1656,1,0,0,0,1658,271,1,0,0,0,1659,1660,7,12,0,0,1660,273,1,0,0,0,1661,
  	1664,5,124,0,0,1662,1664,3,278,139,0,1663,1661,1,0,0,0,1663,1662,1,0,
  	0,0,1664,275,1,0,0,0,1665,1666,7,13,0,0,1666,277,1,0,0,0,1667,1671,3,
  	280,140,0,1668,1671,5,55,0,0,1669,1671,5,56,0,0,1670,1667,1,0,0,0,1670,
  	1668,1,0,0,0,1670,1669,1,0,0,0,1671,279,1,0,0,0,1672,1673,7,14,0,0,1673,
  	281,1,0,0,0,1674,1675,5,114,0,0,1675,1676,3,242,121,0,1676,283,1,0,0,
  	0,1677,1678,5,115,0,0,1678,1679,3,242,121,0,1679,285,1,0,0,0,1680,1685,
  	5,11,0,0,1681,1685,5,0,0,1,1682,1685,4,143,38,0,1683,1685,4,143,39,0,
  	1684,1680,1,0,0,0,1684,1681,1,0,0,0,1684,1682,1,0,0,0,1684,1683,1,0,0,
  	0,1685,287,1,0,0,0,213,293,297,306,311,314,321,330,340,351,353,374,382,
  	389,393,408,412,416,422,429,439,441,457,461,465,473,477,492,496,499,503,
  	506,510,516,520,524,532,537,539,546,551,554,557,562,565,568,573,576,579,
  	583,589,593,597,601,612,619,626,631,639,642,645,650,653,657,667,671,677,
  	683,690,696,702,710,715,726,731,739,746,753,758,791,795,802,808,815,819,
  	823,832,840,847,851,855,859,862,865,868,872,876,880,882,889,895,898,901,
  	905,908,915,924,943,947,951,961,965,976,989,995,1002,1009,1016,1023,1041,
  	1045,1047,1054,1060,1065,1080,1083,1105,1108,1112,1114,1117,1122,1128,
  	1131,1137,1150,1155,1160,1163,1166,1178,1183,1186,1189,1192,1195,1198,
  	1204,1209,1219,1223,1236,1240,1253,1257,1266,1278,1283,1290,1292,1295,
  	1298,1302,1305,1309,1314,1317,1322,1326,1334,1339,1343,1347,1350,1358,
  	1362,1364,1383,1389,1399,1402,1412,1417,1419,1428,1432,1436,1443,1448,
  	1452,1456,1468,1475,1502,1514,1516,1574,1579,1594,1596,1602,1605,1608,
  	1612,1620,1623,1630,1640,1646,1657,1663,1670,1684
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  typescriptparserParserStaticData = staticData.release();
}

}

TypeScriptParser::TypeScriptParser(TokenStream *input) : TypeScriptParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

TypeScriptParser::TypeScriptParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : TypeScriptParserBase(input) {
  TypeScriptParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *typescriptparserParserStaticData->atn, typescriptparserParserStaticData->decisionToDFA, typescriptparserParserStaticData->sharedContextCache, options);
}

TypeScriptParser::~TypeScriptParser() {
  delete _interpreter;
}

const atn::ATN& TypeScriptParser::getATN() const {
  return *typescriptparserParserStaticData->atn;
}

std::string TypeScriptParser::getGrammarFileName() const {
  return "TypeScriptParser.g4";
}

const std::vector<std::string>& TypeScriptParser::getRuleNames() const {
  return typescriptparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& TypeScriptParser::getVocabulary() const {
  return typescriptparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView TypeScriptParser::getSerializedATN() const {
  return typescriptparserParserStaticData->serializedATN;
}


//----------------- InitializerContext ------------------------------------------------------------------

TypeScriptParser::InitializerContext::InitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::InitializerContext::Assign() {
  return getToken(TypeScriptParser::Assign, 0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::InitializerContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}


size_t TypeScriptParser::InitializerContext::getRuleIndex() const {
  return TypeScriptParser::RuleInitializer;
}

void TypeScriptParser::InitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitializer(this);
}

void TypeScriptParser::InitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitializer(this);
}

TypeScriptParser::InitializerContext* TypeScriptParser::initializer() {
  InitializerContext *_localctx = _tracker.createInstance<InitializerContext>(_ctx, getState());
  enterRule(_localctx, 0, TypeScriptParser::RuleInitializer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(288);
    match(TypeScriptParser::Assign);
    setState(289);
    singleExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BindingPatternContext ------------------------------------------------------------------

TypeScriptParser::BindingPatternContext::BindingPatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::ArrayLiteralContext* TypeScriptParser::BindingPatternContext::arrayLiteral() {
  return getRuleContext<TypeScriptParser::ArrayLiteralContext>(0);
}

TypeScriptParser::ObjectLiteralContext* TypeScriptParser::BindingPatternContext::objectLiteral() {
  return getRuleContext<TypeScriptParser::ObjectLiteralContext>(0);
}


size_t TypeScriptParser::BindingPatternContext::getRuleIndex() const {
  return TypeScriptParser::RuleBindingPattern;
}

void TypeScriptParser::BindingPatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBindingPattern(this);
}

void TypeScriptParser::BindingPatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBindingPattern(this);
}

TypeScriptParser::BindingPatternContext* TypeScriptParser::bindingPattern() {
  BindingPatternContext *_localctx = _tracker.createInstance<BindingPatternContext>(_ctx, getState());
  enterRule(_localctx, 2, TypeScriptParser::RuleBindingPattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(293);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TypeScriptParser::OpenBracket: {
        setState(291);
        arrayLiteral();
        break;
      }

      case TypeScriptParser::OpenBrace: {
        setState(292);
        objectLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeParametersContext ------------------------------------------------------------------

TypeScriptParser::TypeParametersContext::TypeParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::TypeParametersContext::LessThan() {
  return getToken(TypeScriptParser::LessThan, 0);
}

tree::TerminalNode* TypeScriptParser::TypeParametersContext::MoreThan() {
  return getToken(TypeScriptParser::MoreThan, 0);
}

TypeScriptParser::TypeParameterListContext* TypeScriptParser::TypeParametersContext::typeParameterList() {
  return getRuleContext<TypeScriptParser::TypeParameterListContext>(0);
}


size_t TypeScriptParser::TypeParametersContext::getRuleIndex() const {
  return TypeScriptParser::RuleTypeParameters;
}

void TypeScriptParser::TypeParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeParameters(this);
}

void TypeScriptParser::TypeParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeParameters(this);
}

TypeScriptParser::TypeParametersContext* TypeScriptParser::typeParameters() {
  TypeParametersContext *_localctx = _tracker.createInstance<TypeParametersContext>(_ctx, getState());
  enterRule(_localctx, 4, TypeScriptParser::RuleTypeParameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(295);
    match(TypeScriptParser::LessThan);
    setState(297);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::LessThan || _la == TypeScriptParser::Identifier) {
      setState(296);
      typeParameterList();
    }
    setState(299);
    match(TypeScriptParser::MoreThan);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeParameterListContext ------------------------------------------------------------------

TypeScriptParser::TypeParameterListContext::TypeParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TypeScriptParser::TypeParameterContext *> TypeScriptParser::TypeParameterListContext::typeParameter() {
  return getRuleContexts<TypeScriptParser::TypeParameterContext>();
}

TypeScriptParser::TypeParameterContext* TypeScriptParser::TypeParameterListContext::typeParameter(size_t i) {
  return getRuleContext<TypeScriptParser::TypeParameterContext>(i);
}

std::vector<tree::TerminalNode *> TypeScriptParser::TypeParameterListContext::Comma() {
  return getTokens(TypeScriptParser::Comma);
}

tree::TerminalNode* TypeScriptParser::TypeParameterListContext::Comma(size_t i) {
  return getToken(TypeScriptParser::Comma, i);
}


size_t TypeScriptParser::TypeParameterListContext::getRuleIndex() const {
  return TypeScriptParser::RuleTypeParameterList;
}

void TypeScriptParser::TypeParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeParameterList(this);
}

void TypeScriptParser::TypeParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeParameterList(this);
}

TypeScriptParser::TypeParameterListContext* TypeScriptParser::typeParameterList() {
  TypeParameterListContext *_localctx = _tracker.createInstance<TypeParameterListContext>(_ctx, getState());
  enterRule(_localctx, 6, TypeScriptParser::RuleTypeParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(301);
    typeParameter();
    setState(306);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TypeScriptParser::Comma) {
      setState(302);
      match(TypeScriptParser::Comma);
      setState(303);
      typeParameter();
      setState(308);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeParameterContext ------------------------------------------------------------------

TypeScriptParser::TypeParameterContext::TypeParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::TypeParameterContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

TypeScriptParser::ConstraintContext* TypeScriptParser::TypeParameterContext::constraint() {
  return getRuleContext<TypeScriptParser::ConstraintContext>(0);
}

TypeScriptParser::TypeParametersContext* TypeScriptParser::TypeParameterContext::typeParameters() {
  return getRuleContext<TypeScriptParser::TypeParametersContext>(0);
}


size_t TypeScriptParser::TypeParameterContext::getRuleIndex() const {
  return TypeScriptParser::RuleTypeParameter;
}

void TypeScriptParser::TypeParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeParameter(this);
}

void TypeScriptParser::TypeParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeParameter(this);
}

TypeScriptParser::TypeParameterContext* TypeScriptParser::typeParameter() {
  TypeParameterContext *_localctx = _tracker.createInstance<TypeParameterContext>(_ctx, getState());
  enterRule(_localctx, 8, TypeScriptParser::RuleTypeParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(314);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TypeScriptParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(309);
        match(TypeScriptParser::Identifier);
        setState(311);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TypeScriptParser::Extends) {
          setState(310);
          constraint();
        }
        break;
      }

      case TypeScriptParser::LessThan: {
        enterOuterAlt(_localctx, 2);
        setState(313);
        typeParameters();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintContext ------------------------------------------------------------------

TypeScriptParser::ConstraintContext::ConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::ConstraintContext::Extends() {
  return getToken(TypeScriptParser::Extends, 0);
}

TypeScriptParser::Type_Context* TypeScriptParser::ConstraintContext::type_() {
  return getRuleContext<TypeScriptParser::Type_Context>(0);
}


size_t TypeScriptParser::ConstraintContext::getRuleIndex() const {
  return TypeScriptParser::RuleConstraint;
}

void TypeScriptParser::ConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraint(this);
}

void TypeScriptParser::ConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraint(this);
}

TypeScriptParser::ConstraintContext* TypeScriptParser::constraint() {
  ConstraintContext *_localctx = _tracker.createInstance<ConstraintContext>(_ctx, getState());
  enterRule(_localctx, 10, TypeScriptParser::RuleConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(316);
    match(TypeScriptParser::Extends);
    setState(317);
    type_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeArgumentsContext ------------------------------------------------------------------

TypeScriptParser::TypeArgumentsContext::TypeArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::TypeArgumentsContext::LessThan() {
  return getToken(TypeScriptParser::LessThan, 0);
}

tree::TerminalNode* TypeScriptParser::TypeArgumentsContext::MoreThan() {
  return getToken(TypeScriptParser::MoreThan, 0);
}

TypeScriptParser::TypeArgumentListContext* TypeScriptParser::TypeArgumentsContext::typeArgumentList() {
  return getRuleContext<TypeScriptParser::TypeArgumentListContext>(0);
}


size_t TypeScriptParser::TypeArgumentsContext::getRuleIndex() const {
  return TypeScriptParser::RuleTypeArguments;
}

void TypeScriptParser::TypeArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeArguments(this);
}

void TypeScriptParser::TypeArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeArguments(this);
}

TypeScriptParser::TypeArgumentsContext* TypeScriptParser::typeArguments() {
  TypeArgumentsContext *_localctx = _tracker.createInstance<TypeArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 12, TypeScriptParser::RuleTypeArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(319);
    match(TypeScriptParser::LessThan);
    setState(321);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1073742160) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & 1729654935793991945) != 0)) {
      setState(320);
      typeArgumentList();
    }
    setState(323);
    match(TypeScriptParser::MoreThan);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeArgumentListContext ------------------------------------------------------------------

TypeScriptParser::TypeArgumentListContext::TypeArgumentListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TypeScriptParser::TypeArgumentContext *> TypeScriptParser::TypeArgumentListContext::typeArgument() {
  return getRuleContexts<TypeScriptParser::TypeArgumentContext>();
}

TypeScriptParser::TypeArgumentContext* TypeScriptParser::TypeArgumentListContext::typeArgument(size_t i) {
  return getRuleContext<TypeScriptParser::TypeArgumentContext>(i);
}

std::vector<tree::TerminalNode *> TypeScriptParser::TypeArgumentListContext::Comma() {
  return getTokens(TypeScriptParser::Comma);
}

tree::TerminalNode* TypeScriptParser::TypeArgumentListContext::Comma(size_t i) {
  return getToken(TypeScriptParser::Comma, i);
}


size_t TypeScriptParser::TypeArgumentListContext::getRuleIndex() const {
  return TypeScriptParser::RuleTypeArgumentList;
}

void TypeScriptParser::TypeArgumentListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeArgumentList(this);
}

void TypeScriptParser::TypeArgumentListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeArgumentList(this);
}

TypeScriptParser::TypeArgumentListContext* TypeScriptParser::typeArgumentList() {
  TypeArgumentListContext *_localctx = _tracker.createInstance<TypeArgumentListContext>(_ctx, getState());
  enterRule(_localctx, 14, TypeScriptParser::RuleTypeArgumentList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(325);
    typeArgument();
    setState(330);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TypeScriptParser::Comma) {
      setState(326);
      match(TypeScriptParser::Comma);
      setState(327);
      typeArgument();
      setState(332);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeArgumentContext ------------------------------------------------------------------

TypeScriptParser::TypeArgumentContext::TypeArgumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::Type_Context* TypeScriptParser::TypeArgumentContext::type_() {
  return getRuleContext<TypeScriptParser::Type_Context>(0);
}


size_t TypeScriptParser::TypeArgumentContext::getRuleIndex() const {
  return TypeScriptParser::RuleTypeArgument;
}

void TypeScriptParser::TypeArgumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeArgument(this);
}

void TypeScriptParser::TypeArgumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeArgument(this);
}

TypeScriptParser::TypeArgumentContext* TypeScriptParser::typeArgument() {
  TypeArgumentContext *_localctx = _tracker.createInstance<TypeArgumentContext>(_ctx, getState());
  enterRule(_localctx, 16, TypeScriptParser::RuleTypeArgument);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(333);
    type_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_Context ------------------------------------------------------------------

TypeScriptParser::Type_Context::Type_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::UnionOrIntersectionOrPrimaryTypeContext* TypeScriptParser::Type_Context::unionOrIntersectionOrPrimaryType() {
  return getRuleContext<TypeScriptParser::UnionOrIntersectionOrPrimaryTypeContext>(0);
}

TypeScriptParser::FunctionTypeContext* TypeScriptParser::Type_Context::functionType() {
  return getRuleContext<TypeScriptParser::FunctionTypeContext>(0);
}

TypeScriptParser::ConstructorTypeContext* TypeScriptParser::Type_Context::constructorType() {
  return getRuleContext<TypeScriptParser::ConstructorTypeContext>(0);
}

TypeScriptParser::TypeGenericContext* TypeScriptParser::Type_Context::typeGeneric() {
  return getRuleContext<TypeScriptParser::TypeGenericContext>(0);
}

tree::TerminalNode* TypeScriptParser::Type_Context::StringLiteral() {
  return getToken(TypeScriptParser::StringLiteral, 0);
}


size_t TypeScriptParser::Type_Context::getRuleIndex() const {
  return TypeScriptParser::RuleType_;
}

void TypeScriptParser::Type_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_(this);
}

void TypeScriptParser::Type_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_(this);
}

TypeScriptParser::Type_Context* TypeScriptParser::type_() {
  Type_Context *_localctx = _tracker.createInstance<Type_Context>(_ctx, getState());
  enterRule(_localctx, 18, TypeScriptParser::RuleType_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(340);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(335);
      unionOrIntersectionOrPrimaryType(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(336);
      functionType();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(337);
      constructorType();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(338);
      typeGeneric();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(339);
      match(TypeScriptParser::StringLiteral);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnionOrIntersectionOrPrimaryTypeContext ------------------------------------------------------------------

TypeScriptParser::UnionOrIntersectionOrPrimaryTypeContext::UnionOrIntersectionOrPrimaryTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t TypeScriptParser::UnionOrIntersectionOrPrimaryTypeContext::getRuleIndex() const {
  return TypeScriptParser::RuleUnionOrIntersectionOrPrimaryType;
}

void TypeScriptParser::UnionOrIntersectionOrPrimaryTypeContext::copyFrom(UnionOrIntersectionOrPrimaryTypeContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- IntersectionContext ------------------------------------------------------------------

std::vector<TypeScriptParser::UnionOrIntersectionOrPrimaryTypeContext *> TypeScriptParser::IntersectionContext::unionOrIntersectionOrPrimaryType() {
  return getRuleContexts<TypeScriptParser::UnionOrIntersectionOrPrimaryTypeContext>();
}

TypeScriptParser::UnionOrIntersectionOrPrimaryTypeContext* TypeScriptParser::IntersectionContext::unionOrIntersectionOrPrimaryType(size_t i) {
  return getRuleContext<TypeScriptParser::UnionOrIntersectionOrPrimaryTypeContext>(i);
}

tree::TerminalNode* TypeScriptParser::IntersectionContext::BitAnd() {
  return getToken(TypeScriptParser::BitAnd, 0);
}

TypeScriptParser::IntersectionContext::IntersectionContext(UnionOrIntersectionOrPrimaryTypeContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::IntersectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntersection(this);
}
void TypeScriptParser::IntersectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntersection(this);
}
//----------------- PrimaryContext ------------------------------------------------------------------

TypeScriptParser::PrimaryTypeContext* TypeScriptParser::PrimaryContext::primaryType() {
  return getRuleContext<TypeScriptParser::PrimaryTypeContext>(0);
}

TypeScriptParser::PrimaryContext::PrimaryContext(UnionOrIntersectionOrPrimaryTypeContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::PrimaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimary(this);
}
void TypeScriptParser::PrimaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimary(this);
}
//----------------- UnionContext ------------------------------------------------------------------

std::vector<TypeScriptParser::UnionOrIntersectionOrPrimaryTypeContext *> TypeScriptParser::UnionContext::unionOrIntersectionOrPrimaryType() {
  return getRuleContexts<TypeScriptParser::UnionOrIntersectionOrPrimaryTypeContext>();
}

TypeScriptParser::UnionOrIntersectionOrPrimaryTypeContext* TypeScriptParser::UnionContext::unionOrIntersectionOrPrimaryType(size_t i) {
  return getRuleContext<TypeScriptParser::UnionOrIntersectionOrPrimaryTypeContext>(i);
}

tree::TerminalNode* TypeScriptParser::UnionContext::BitOr() {
  return getToken(TypeScriptParser::BitOr, 0);
}

TypeScriptParser::UnionContext::UnionContext(UnionOrIntersectionOrPrimaryTypeContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::UnionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnion(this);
}
void TypeScriptParser::UnionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnion(this);
}

TypeScriptParser::UnionOrIntersectionOrPrimaryTypeContext* TypeScriptParser::unionOrIntersectionOrPrimaryType() {
   return unionOrIntersectionOrPrimaryType(0);
}

TypeScriptParser::UnionOrIntersectionOrPrimaryTypeContext* TypeScriptParser::unionOrIntersectionOrPrimaryType(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  TypeScriptParser::UnionOrIntersectionOrPrimaryTypeContext *_localctx = _tracker.createInstance<UnionOrIntersectionOrPrimaryTypeContext>(_ctx, parentState);
  TypeScriptParser::UnionOrIntersectionOrPrimaryTypeContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 20;
  enterRecursionRule(_localctx, 20, TypeScriptParser::RuleUnionOrIntersectionOrPrimaryType, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    _localctx = _tracker.createInstance<PrimaryContext>(_localctx);
    _ctx = _localctx;
    previousContext = _localctx;

    setState(343);
    primaryType(0);
    _ctx->stop = _input->LT(-1);
    setState(353);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(351);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<UnionContext>(_tracker.createInstance<UnionOrIntersectionOrPrimaryTypeContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleUnionOrIntersectionOrPrimaryType);
          setState(345);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(346);
          match(TypeScriptParser::BitOr);
          setState(347);
          unionOrIntersectionOrPrimaryType(4);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<IntersectionContext>(_tracker.createInstance<UnionOrIntersectionOrPrimaryTypeContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleUnionOrIntersectionOrPrimaryType);
          setState(348);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(349);
          match(TypeScriptParser::BitAnd);
          setState(350);
          unionOrIntersectionOrPrimaryType(3);
          break;
        }

        default:
          break;
        } 
      }
      setState(355);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- PrimaryTypeContext ------------------------------------------------------------------

TypeScriptParser::PrimaryTypeContext::PrimaryTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t TypeScriptParser::PrimaryTypeContext::getRuleIndex() const {
  return TypeScriptParser::RulePrimaryType;
}

void TypeScriptParser::PrimaryTypeContext::copyFrom(PrimaryTypeContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- RedefinitionOfTypeContext ------------------------------------------------------------------

TypeScriptParser::TypeReferenceContext* TypeScriptParser::RedefinitionOfTypeContext::typeReference() {
  return getRuleContext<TypeScriptParser::TypeReferenceContext>(0);
}

tree::TerminalNode* TypeScriptParser::RedefinitionOfTypeContext::Is() {
  return getToken(TypeScriptParser::Is, 0);
}

TypeScriptParser::PrimaryTypeContext* TypeScriptParser::RedefinitionOfTypeContext::primaryType() {
  return getRuleContext<TypeScriptParser::PrimaryTypeContext>(0);
}

TypeScriptParser::RedefinitionOfTypeContext::RedefinitionOfTypeContext(PrimaryTypeContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::RedefinitionOfTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRedefinitionOfType(this);
}
void TypeScriptParser::RedefinitionOfTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRedefinitionOfType(this);
}
//----------------- PredefinedPrimTypeContext ------------------------------------------------------------------

TypeScriptParser::PredefinedTypeContext* TypeScriptParser::PredefinedPrimTypeContext::predefinedType() {
  return getRuleContext<TypeScriptParser::PredefinedTypeContext>(0);
}

TypeScriptParser::PredefinedPrimTypeContext::PredefinedPrimTypeContext(PrimaryTypeContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::PredefinedPrimTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredefinedPrimType(this);
}
void TypeScriptParser::PredefinedPrimTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredefinedPrimType(this);
}
//----------------- ArrayPrimTypeContext ------------------------------------------------------------------

TypeScriptParser::PrimaryTypeContext* TypeScriptParser::ArrayPrimTypeContext::primaryType() {
  return getRuleContext<TypeScriptParser::PrimaryTypeContext>(0);
}

tree::TerminalNode* TypeScriptParser::ArrayPrimTypeContext::OpenBracket() {
  return getToken(TypeScriptParser::OpenBracket, 0);
}

tree::TerminalNode* TypeScriptParser::ArrayPrimTypeContext::CloseBracket() {
  return getToken(TypeScriptParser::CloseBracket, 0);
}

TypeScriptParser::ArrayPrimTypeContext::ArrayPrimTypeContext(PrimaryTypeContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::ArrayPrimTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayPrimType(this);
}
void TypeScriptParser::ArrayPrimTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayPrimType(this);
}
//----------------- ParenthesizedPrimTypeContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::ParenthesizedPrimTypeContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

TypeScriptParser::Type_Context* TypeScriptParser::ParenthesizedPrimTypeContext::type_() {
  return getRuleContext<TypeScriptParser::Type_Context>(0);
}

tree::TerminalNode* TypeScriptParser::ParenthesizedPrimTypeContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

TypeScriptParser::ParenthesizedPrimTypeContext::ParenthesizedPrimTypeContext(PrimaryTypeContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::ParenthesizedPrimTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParenthesizedPrimType(this);
}
void TypeScriptParser::ParenthesizedPrimTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParenthesizedPrimType(this);
}
//----------------- ThisPrimTypeContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::ThisPrimTypeContext::This() {
  return getToken(TypeScriptParser::This, 0);
}

TypeScriptParser::ThisPrimTypeContext::ThisPrimTypeContext(PrimaryTypeContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::ThisPrimTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThisPrimType(this);
}
void TypeScriptParser::ThisPrimTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThisPrimType(this);
}
//----------------- TuplePrimTypeContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::TuplePrimTypeContext::OpenBracket() {
  return getToken(TypeScriptParser::OpenBracket, 0);
}

TypeScriptParser::TupleElementTypesContext* TypeScriptParser::TuplePrimTypeContext::tupleElementTypes() {
  return getRuleContext<TypeScriptParser::TupleElementTypesContext>(0);
}

tree::TerminalNode* TypeScriptParser::TuplePrimTypeContext::CloseBracket() {
  return getToken(TypeScriptParser::CloseBracket, 0);
}

TypeScriptParser::TuplePrimTypeContext::TuplePrimTypeContext(PrimaryTypeContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::TuplePrimTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTuplePrimType(this);
}
void TypeScriptParser::TuplePrimTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTuplePrimType(this);
}
//----------------- ObjectPrimTypeContext ------------------------------------------------------------------

TypeScriptParser::ObjectTypeContext* TypeScriptParser::ObjectPrimTypeContext::objectType() {
  return getRuleContext<TypeScriptParser::ObjectTypeContext>(0);
}

TypeScriptParser::ObjectPrimTypeContext::ObjectPrimTypeContext(PrimaryTypeContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::ObjectPrimTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectPrimType(this);
}
void TypeScriptParser::ObjectPrimTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectPrimType(this);
}
//----------------- ReferencePrimTypeContext ------------------------------------------------------------------

TypeScriptParser::TypeReferenceContext* TypeScriptParser::ReferencePrimTypeContext::typeReference() {
  return getRuleContext<TypeScriptParser::TypeReferenceContext>(0);
}

TypeScriptParser::ReferencePrimTypeContext::ReferencePrimTypeContext(PrimaryTypeContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::ReferencePrimTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReferencePrimType(this);
}
void TypeScriptParser::ReferencePrimTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReferencePrimType(this);
}
//----------------- QueryPrimTypeContext ------------------------------------------------------------------

TypeScriptParser::TypeQueryContext* TypeScriptParser::QueryPrimTypeContext::typeQuery() {
  return getRuleContext<TypeScriptParser::TypeQueryContext>(0);
}

TypeScriptParser::QueryPrimTypeContext::QueryPrimTypeContext(PrimaryTypeContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::QueryPrimTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryPrimType(this);
}
void TypeScriptParser::QueryPrimTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryPrimType(this);
}

TypeScriptParser::PrimaryTypeContext* TypeScriptParser::primaryType() {
   return primaryType(0);
}

TypeScriptParser::PrimaryTypeContext* TypeScriptParser::primaryType(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  TypeScriptParser::PrimaryTypeContext *_localctx = _tracker.createInstance<PrimaryTypeContext>(_ctx, parentState);
  TypeScriptParser::PrimaryTypeContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 22;
  enterRecursionRule(_localctx, 22, TypeScriptParser::RulePrimaryType, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(374);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<ParenthesizedPrimTypeContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(357);
      match(TypeScriptParser::OpenParen);
      setState(358);
      type_();
      setState(359);
      match(TypeScriptParser::CloseParen);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<PredefinedPrimTypeContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(361);
      predefinedType();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<ReferencePrimTypeContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(362);
      typeReference();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<ObjectPrimTypeContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(363);
      objectType();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<TuplePrimTypeContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(364);
      match(TypeScriptParser::OpenBracket);
      setState(365);
      tupleElementTypes();
      setState(366);
      match(TypeScriptParser::CloseBracket);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<QueryPrimTypeContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(368);
      typeQuery();
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<ThisPrimTypeContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(369);
      match(TypeScriptParser::This);
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<RedefinitionOfTypeContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(370);
      typeReference();
      setState(371);
      match(TypeScriptParser::Is);
      setState(372);
      primaryType(1);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(382);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        auto newContext = _tracker.createInstance<ArrayPrimTypeContext>(_tracker.createInstance<PrimaryTypeContext>(parentContext, parentState));
        _localctx = newContext;
        pushNewRecursionContext(newContext, startState, RulePrimaryType);
        setState(376);

        if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
        setState(377);

        if (!(notLineTerminator())) throw FailedPredicateException(this, "notLineTerminator()");
        setState(378);
        match(TypeScriptParser::OpenBracket);
        setState(379);
        match(TypeScriptParser::CloseBracket); 
      }
      setState(384);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- PredefinedTypeContext ------------------------------------------------------------------

TypeScriptParser::PredefinedTypeContext::PredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::PredefinedTypeContext::Any() {
  return getToken(TypeScriptParser::Any, 0);
}

tree::TerminalNode* TypeScriptParser::PredefinedTypeContext::Number() {
  return getToken(TypeScriptParser::Number, 0);
}

tree::TerminalNode* TypeScriptParser::PredefinedTypeContext::Boolean() {
  return getToken(TypeScriptParser::Boolean, 0);
}

tree::TerminalNode* TypeScriptParser::PredefinedTypeContext::String() {
  return getToken(TypeScriptParser::String, 0);
}

tree::TerminalNode* TypeScriptParser::PredefinedTypeContext::Symbol() {
  return getToken(TypeScriptParser::Symbol, 0);
}

tree::TerminalNode* TypeScriptParser::PredefinedTypeContext::Void() {
  return getToken(TypeScriptParser::Void, 0);
}


size_t TypeScriptParser::PredefinedTypeContext::getRuleIndex() const {
  return TypeScriptParser::RulePredefinedType;
}

void TypeScriptParser::PredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredefinedType(this);
}

void TypeScriptParser::PredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredefinedType(this);
}

TypeScriptParser::PredefinedTypeContext* TypeScriptParser::predefinedType() {
  PredefinedTypeContext *_localctx = _tracker.createInstance<PredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 24, TypeScriptParser::RulePredefinedType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(385);
    _la = _input->LA(1);
    if (!(((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & 1065151889409) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeReferenceContext ------------------------------------------------------------------

TypeScriptParser::TypeReferenceContext::TypeReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::TypeNameContext* TypeScriptParser::TypeReferenceContext::typeName() {
  return getRuleContext<TypeScriptParser::TypeNameContext>(0);
}

TypeScriptParser::NestedTypeGenericContext* TypeScriptParser::TypeReferenceContext::nestedTypeGeneric() {
  return getRuleContext<TypeScriptParser::NestedTypeGenericContext>(0);
}


size_t TypeScriptParser::TypeReferenceContext::getRuleIndex() const {
  return TypeScriptParser::RuleTypeReference;
}

void TypeScriptParser::TypeReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeReference(this);
}

void TypeScriptParser::TypeReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeReference(this);
}

TypeScriptParser::TypeReferenceContext* TypeScriptParser::typeReference() {
  TypeReferenceContext *_localctx = _tracker.createInstance<TypeReferenceContext>(_ctx, getState());
  enterRule(_localctx, 26, TypeScriptParser::RuleTypeReference);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(387);
    typeName();
    setState(389);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
    case 1: {
      setState(388);
      nestedTypeGeneric();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NestedTypeGenericContext ------------------------------------------------------------------

TypeScriptParser::NestedTypeGenericContext::NestedTypeGenericContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::TypeIncludeGenericContext* TypeScriptParser::NestedTypeGenericContext::typeIncludeGeneric() {
  return getRuleContext<TypeScriptParser::TypeIncludeGenericContext>(0);
}

TypeScriptParser::TypeGenericContext* TypeScriptParser::NestedTypeGenericContext::typeGeneric() {
  return getRuleContext<TypeScriptParser::TypeGenericContext>(0);
}


size_t TypeScriptParser::NestedTypeGenericContext::getRuleIndex() const {
  return TypeScriptParser::RuleNestedTypeGeneric;
}

void TypeScriptParser::NestedTypeGenericContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNestedTypeGeneric(this);
}

void TypeScriptParser::NestedTypeGenericContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNestedTypeGeneric(this);
}

TypeScriptParser::NestedTypeGenericContext* TypeScriptParser::nestedTypeGeneric() {
  NestedTypeGenericContext *_localctx = _tracker.createInstance<NestedTypeGenericContext>(_ctx, getState());
  enterRule(_localctx, 28, TypeScriptParser::RuleNestedTypeGeneric);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(393);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(391);
      typeIncludeGeneric();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(392);
      typeGeneric();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeGenericContext ------------------------------------------------------------------

TypeScriptParser::TypeGenericContext::TypeGenericContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::TypeGenericContext::LessThan() {
  return getToken(TypeScriptParser::LessThan, 0);
}

TypeScriptParser::TypeArgumentListContext* TypeScriptParser::TypeGenericContext::typeArgumentList() {
  return getRuleContext<TypeScriptParser::TypeArgumentListContext>(0);
}

tree::TerminalNode* TypeScriptParser::TypeGenericContext::MoreThan() {
  return getToken(TypeScriptParser::MoreThan, 0);
}


size_t TypeScriptParser::TypeGenericContext::getRuleIndex() const {
  return TypeScriptParser::RuleTypeGeneric;
}

void TypeScriptParser::TypeGenericContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeGeneric(this);
}

void TypeScriptParser::TypeGenericContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeGeneric(this);
}

TypeScriptParser::TypeGenericContext* TypeScriptParser::typeGeneric() {
  TypeGenericContext *_localctx = _tracker.createInstance<TypeGenericContext>(_ctx, getState());
  enterRule(_localctx, 30, TypeScriptParser::RuleTypeGeneric);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(395);
    match(TypeScriptParser::LessThan);
    setState(396);
    typeArgumentList();
    setState(397);
    match(TypeScriptParser::MoreThan);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeIncludeGenericContext ------------------------------------------------------------------

TypeScriptParser::TypeIncludeGenericContext::TypeIncludeGenericContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TypeScriptParser::TypeIncludeGenericContext::LessThan() {
  return getTokens(TypeScriptParser::LessThan);
}

tree::TerminalNode* TypeScriptParser::TypeIncludeGenericContext::LessThan(size_t i) {
  return getToken(TypeScriptParser::LessThan, i);
}

std::vector<TypeScriptParser::TypeArgumentListContext *> TypeScriptParser::TypeIncludeGenericContext::typeArgumentList() {
  return getRuleContexts<TypeScriptParser::TypeArgumentListContext>();
}

TypeScriptParser::TypeArgumentListContext* TypeScriptParser::TypeIncludeGenericContext::typeArgumentList(size_t i) {
  return getRuleContext<TypeScriptParser::TypeArgumentListContext>(i);
}

std::vector<tree::TerminalNode *> TypeScriptParser::TypeIncludeGenericContext::MoreThan() {
  return getTokens(TypeScriptParser::MoreThan);
}

tree::TerminalNode* TypeScriptParser::TypeIncludeGenericContext::MoreThan(size_t i) {
  return getToken(TypeScriptParser::MoreThan, i);
}

TypeScriptParser::BindingPatternContext* TypeScriptParser::TypeIncludeGenericContext::bindingPattern() {
  return getRuleContext<TypeScriptParser::BindingPatternContext>(0);
}

tree::TerminalNode* TypeScriptParser::TypeIncludeGenericContext::RightShiftArithmetic() {
  return getToken(TypeScriptParser::RightShiftArithmetic, 0);
}


size_t TypeScriptParser::TypeIncludeGenericContext::getRuleIndex() const {
  return TypeScriptParser::RuleTypeIncludeGeneric;
}

void TypeScriptParser::TypeIncludeGenericContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeIncludeGeneric(this);
}

void TypeScriptParser::TypeIncludeGenericContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeIncludeGeneric(this);
}

TypeScriptParser::TypeIncludeGenericContext* TypeScriptParser::typeIncludeGeneric() {
  TypeIncludeGenericContext *_localctx = _tracker.createInstance<TypeIncludeGenericContext>(_ctx, getState());
  enterRule(_localctx, 32, TypeScriptParser::RuleTypeIncludeGeneric);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(399);
    match(TypeScriptParser::LessThan);
    setState(400);
    typeArgumentList();
    setState(401);
    match(TypeScriptParser::LessThan);
    setState(402);
    typeArgumentList();
    setState(408);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TypeScriptParser::MoreThan: {
        setState(403);
        match(TypeScriptParser::MoreThan);
        setState(404);
        bindingPattern();
        setState(405);
        match(TypeScriptParser::MoreThan);
        break;
      }

      case TypeScriptParser::RightShiftArithmetic: {
        setState(407);
        match(TypeScriptParser::RightShiftArithmetic);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeNameContext ------------------------------------------------------------------

TypeScriptParser::TypeNameContext::TypeNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::TypeNameContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

TypeScriptParser::NamespaceNameContext* TypeScriptParser::TypeNameContext::namespaceName() {
  return getRuleContext<TypeScriptParser::NamespaceNameContext>(0);
}


size_t TypeScriptParser::TypeNameContext::getRuleIndex() const {
  return TypeScriptParser::RuleTypeName;
}

void TypeScriptParser::TypeNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeName(this);
}

void TypeScriptParser::TypeNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeName(this);
}

TypeScriptParser::TypeNameContext* TypeScriptParser::typeName() {
  TypeNameContext *_localctx = _tracker.createInstance<TypeNameContext>(_ctx, getState());
  enterRule(_localctx, 34, TypeScriptParser::RuleTypeName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(412);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(410);
      match(TypeScriptParser::Identifier);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(411);
      namespaceName();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectTypeContext ------------------------------------------------------------------

TypeScriptParser::ObjectTypeContext::ObjectTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::ObjectTypeContext::OpenBrace() {
  return getToken(TypeScriptParser::OpenBrace, 0);
}

tree::TerminalNode* TypeScriptParser::ObjectTypeContext::CloseBrace() {
  return getToken(TypeScriptParser::CloseBrace, 0);
}

TypeScriptParser::TypeBodyContext* TypeScriptParser::ObjectTypeContext::typeBody() {
  return getRuleContext<TypeScriptParser::TypeBodyContext>(0);
}


size_t TypeScriptParser::ObjectTypeContext::getRuleIndex() const {
  return TypeScriptParser::RuleObjectType;
}

void TypeScriptParser::ObjectTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectType(this);
}

void TypeScriptParser::ObjectTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectType(this);
}

TypeScriptParser::ObjectTypeContext* TypeScriptParser::objectType() {
  ObjectTypeContext *_localctx = _tracker.createInstance<ObjectTypeContext>(_ctx, getState());
  enterRule(_localctx, 36, TypeScriptParser::RuleObjectType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(414);
    match(TypeScriptParser::OpenBrace);
    setState(416);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -36028795945222064) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3517012241796825087) != 0)) {
      setState(415);
      typeBody();
    }
    setState(418);
    match(TypeScriptParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeBodyContext ------------------------------------------------------------------

TypeScriptParser::TypeBodyContext::TypeBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::TypeMemberListContext* TypeScriptParser::TypeBodyContext::typeMemberList() {
  return getRuleContext<TypeScriptParser::TypeMemberListContext>(0);
}

tree::TerminalNode* TypeScriptParser::TypeBodyContext::SemiColon() {
  return getToken(TypeScriptParser::SemiColon, 0);
}

tree::TerminalNode* TypeScriptParser::TypeBodyContext::Comma() {
  return getToken(TypeScriptParser::Comma, 0);
}


size_t TypeScriptParser::TypeBodyContext::getRuleIndex() const {
  return TypeScriptParser::RuleTypeBody;
}

void TypeScriptParser::TypeBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeBody(this);
}

void TypeScriptParser::TypeBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeBody(this);
}

TypeScriptParser::TypeBodyContext* TypeScriptParser::typeBody() {
  TypeBodyContext *_localctx = _tracker.createInstance<TypeBodyContext>(_ctx, getState());
  enterRule(_localctx, 38, TypeScriptParser::RuleTypeBody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(420);
    typeMemberList();
    setState(422);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::SemiColon

    || _la == TypeScriptParser::Comma) {
      setState(421);
      _la = _input->LA(1);
      if (!(_la == TypeScriptParser::SemiColon

      || _la == TypeScriptParser::Comma)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeMemberListContext ------------------------------------------------------------------

TypeScriptParser::TypeMemberListContext::TypeMemberListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TypeScriptParser::TypeMemberContext *> TypeScriptParser::TypeMemberListContext::typeMember() {
  return getRuleContexts<TypeScriptParser::TypeMemberContext>();
}

TypeScriptParser::TypeMemberContext* TypeScriptParser::TypeMemberListContext::typeMember(size_t i) {
  return getRuleContext<TypeScriptParser::TypeMemberContext>(i);
}

std::vector<tree::TerminalNode *> TypeScriptParser::TypeMemberListContext::SemiColon() {
  return getTokens(TypeScriptParser::SemiColon);
}

tree::TerminalNode* TypeScriptParser::TypeMemberListContext::SemiColon(size_t i) {
  return getToken(TypeScriptParser::SemiColon, i);
}

std::vector<tree::TerminalNode *> TypeScriptParser::TypeMemberListContext::Comma() {
  return getTokens(TypeScriptParser::Comma);
}

tree::TerminalNode* TypeScriptParser::TypeMemberListContext::Comma(size_t i) {
  return getToken(TypeScriptParser::Comma, i);
}


size_t TypeScriptParser::TypeMemberListContext::getRuleIndex() const {
  return TypeScriptParser::RuleTypeMemberList;
}

void TypeScriptParser::TypeMemberListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeMemberList(this);
}

void TypeScriptParser::TypeMemberListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeMemberList(this);
}

TypeScriptParser::TypeMemberListContext* TypeScriptParser::typeMemberList() {
  TypeMemberListContext *_localctx = _tracker.createInstance<TypeMemberListContext>(_ctx, getState());
  enterRule(_localctx, 40, TypeScriptParser::RuleTypeMemberList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(424);
    typeMember();
    setState(429);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(425);
        _la = _input->LA(1);
        if (!(_la == TypeScriptParser::SemiColon

        || _la == TypeScriptParser::Comma)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(426);
        typeMember(); 
      }
      setState(431);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeMemberContext ------------------------------------------------------------------

TypeScriptParser::TypeMemberContext::TypeMemberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::PropertySignaturContext* TypeScriptParser::TypeMemberContext::propertySignatur() {
  return getRuleContext<TypeScriptParser::PropertySignaturContext>(0);
}

TypeScriptParser::CallSignatureContext* TypeScriptParser::TypeMemberContext::callSignature() {
  return getRuleContext<TypeScriptParser::CallSignatureContext>(0);
}

TypeScriptParser::ConstructSignatureContext* TypeScriptParser::TypeMemberContext::constructSignature() {
  return getRuleContext<TypeScriptParser::ConstructSignatureContext>(0);
}

TypeScriptParser::IndexSignatureContext* TypeScriptParser::TypeMemberContext::indexSignature() {
  return getRuleContext<TypeScriptParser::IndexSignatureContext>(0);
}

TypeScriptParser::MethodSignatureContext* TypeScriptParser::TypeMemberContext::methodSignature() {
  return getRuleContext<TypeScriptParser::MethodSignatureContext>(0);
}

tree::TerminalNode* TypeScriptParser::TypeMemberContext::ARROW() {
  return getToken(TypeScriptParser::ARROW, 0);
}

TypeScriptParser::Type_Context* TypeScriptParser::TypeMemberContext::type_() {
  return getRuleContext<TypeScriptParser::Type_Context>(0);
}


size_t TypeScriptParser::TypeMemberContext::getRuleIndex() const {
  return TypeScriptParser::RuleTypeMember;
}

void TypeScriptParser::TypeMemberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeMember(this);
}

void TypeScriptParser::TypeMemberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeMember(this);
}

TypeScriptParser::TypeMemberContext* TypeScriptParser::typeMember() {
  TypeMemberContext *_localctx = _tracker.createInstance<TypeMemberContext>(_ctx, getState());
  enterRule(_localctx, 42, TypeScriptParser::RuleTypeMember);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(441);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(432);
      propertySignatur();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(433);
      callSignature();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(434);
      constructSignature();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(435);
      indexSignature();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(436);
      methodSignature();
      setState(439);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TypeScriptParser::ARROW) {
        setState(437);
        match(TypeScriptParser::ARROW);
        setState(438);
        type_();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayTypeContext ------------------------------------------------------------------

TypeScriptParser::ArrayTypeContext::ArrayTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::PrimaryTypeContext* TypeScriptParser::ArrayTypeContext::primaryType() {
  return getRuleContext<TypeScriptParser::PrimaryTypeContext>(0);
}

tree::TerminalNode* TypeScriptParser::ArrayTypeContext::OpenBracket() {
  return getToken(TypeScriptParser::OpenBracket, 0);
}

tree::TerminalNode* TypeScriptParser::ArrayTypeContext::CloseBracket() {
  return getToken(TypeScriptParser::CloseBracket, 0);
}


size_t TypeScriptParser::ArrayTypeContext::getRuleIndex() const {
  return TypeScriptParser::RuleArrayType;
}

void TypeScriptParser::ArrayTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayType(this);
}

void TypeScriptParser::ArrayTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayType(this);
}

TypeScriptParser::ArrayTypeContext* TypeScriptParser::arrayType() {
  ArrayTypeContext *_localctx = _tracker.createInstance<ArrayTypeContext>(_ctx, getState());
  enterRule(_localctx, 44, TypeScriptParser::RuleArrayType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(443);
    primaryType(0);
    setState(444);

    if (!(notLineTerminator())) throw FailedPredicateException(this, "notLineTerminator()");
    setState(445);
    match(TypeScriptParser::OpenBracket);
    setState(446);
    match(TypeScriptParser::CloseBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TupleTypeContext ------------------------------------------------------------------

TypeScriptParser::TupleTypeContext::TupleTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::TupleTypeContext::OpenBracket() {
  return getToken(TypeScriptParser::OpenBracket, 0);
}

TypeScriptParser::TupleElementTypesContext* TypeScriptParser::TupleTypeContext::tupleElementTypes() {
  return getRuleContext<TypeScriptParser::TupleElementTypesContext>(0);
}

tree::TerminalNode* TypeScriptParser::TupleTypeContext::CloseBracket() {
  return getToken(TypeScriptParser::CloseBracket, 0);
}


size_t TypeScriptParser::TupleTypeContext::getRuleIndex() const {
  return TypeScriptParser::RuleTupleType;
}

void TypeScriptParser::TupleTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTupleType(this);
}

void TypeScriptParser::TupleTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTupleType(this);
}

TypeScriptParser::TupleTypeContext* TypeScriptParser::tupleType() {
  TupleTypeContext *_localctx = _tracker.createInstance<TupleTypeContext>(_ctx, getState());
  enterRule(_localctx, 46, TypeScriptParser::RuleTupleType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(448);
    match(TypeScriptParser::OpenBracket);
    setState(449);
    tupleElementTypes();
    setState(450);
    match(TypeScriptParser::CloseBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TupleElementTypesContext ------------------------------------------------------------------

TypeScriptParser::TupleElementTypesContext::TupleElementTypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TypeScriptParser::Type_Context *> TypeScriptParser::TupleElementTypesContext::type_() {
  return getRuleContexts<TypeScriptParser::Type_Context>();
}

TypeScriptParser::Type_Context* TypeScriptParser::TupleElementTypesContext::type_(size_t i) {
  return getRuleContext<TypeScriptParser::Type_Context>(i);
}

std::vector<tree::TerminalNode *> TypeScriptParser::TupleElementTypesContext::Comma() {
  return getTokens(TypeScriptParser::Comma);
}

tree::TerminalNode* TypeScriptParser::TupleElementTypesContext::Comma(size_t i) {
  return getToken(TypeScriptParser::Comma, i);
}


size_t TypeScriptParser::TupleElementTypesContext::getRuleIndex() const {
  return TypeScriptParser::RuleTupleElementTypes;
}

void TypeScriptParser::TupleElementTypesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTupleElementTypes(this);
}

void TypeScriptParser::TupleElementTypesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTupleElementTypes(this);
}

TypeScriptParser::TupleElementTypesContext* TypeScriptParser::tupleElementTypes() {
  TupleElementTypesContext *_localctx = _tracker.createInstance<TupleElementTypesContext>(_ctx, getState());
  enterRule(_localctx, 48, TypeScriptParser::RuleTupleElementTypes);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(452);
    type_();
    setState(457);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TypeScriptParser::Comma) {
      setState(453);
      match(TypeScriptParser::Comma);
      setState(454);
      type_();
      setState(459);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionTypeContext ------------------------------------------------------------------

TypeScriptParser::FunctionTypeContext::FunctionTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::FunctionTypeContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

tree::TerminalNode* TypeScriptParser::FunctionTypeContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

tree::TerminalNode* TypeScriptParser::FunctionTypeContext::ARROW() {
  return getToken(TypeScriptParser::ARROW, 0);
}

TypeScriptParser::Type_Context* TypeScriptParser::FunctionTypeContext::type_() {
  return getRuleContext<TypeScriptParser::Type_Context>(0);
}

TypeScriptParser::TypeParametersContext* TypeScriptParser::FunctionTypeContext::typeParameters() {
  return getRuleContext<TypeScriptParser::TypeParametersContext>(0);
}

TypeScriptParser::ParameterListContext* TypeScriptParser::FunctionTypeContext::parameterList() {
  return getRuleContext<TypeScriptParser::ParameterListContext>(0);
}


size_t TypeScriptParser::FunctionTypeContext::getRuleIndex() const {
  return TypeScriptParser::RuleFunctionType;
}

void TypeScriptParser::FunctionTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionType(this);
}

void TypeScriptParser::FunctionTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionType(this);
}

TypeScriptParser::FunctionTypeContext* TypeScriptParser::functionType() {
  FunctionTypeContext *_localctx = _tracker.createInstance<FunctionTypeContext>(_ctx, getState());
  enterRule(_localctx, 50, TypeScriptParser::RuleFunctionType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(461);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::LessThan) {
      setState(460);
      typeParameters();
    }
    setState(463);
    match(TypeScriptParser::OpenParen);
    setState(465);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4503599627370430192) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1787629984886554623) != 0)) {
      setState(464);
      parameterList();
    }
    setState(467);
    match(TypeScriptParser::CloseParen);
    setState(468);
    match(TypeScriptParser::ARROW);
    setState(469);
    type_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstructorTypeContext ------------------------------------------------------------------

TypeScriptParser::ConstructorTypeContext::ConstructorTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::ConstructorTypeContext::New() {
  return getToken(TypeScriptParser::New, 0);
}

tree::TerminalNode* TypeScriptParser::ConstructorTypeContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

tree::TerminalNode* TypeScriptParser::ConstructorTypeContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

tree::TerminalNode* TypeScriptParser::ConstructorTypeContext::ARROW() {
  return getToken(TypeScriptParser::ARROW, 0);
}

TypeScriptParser::Type_Context* TypeScriptParser::ConstructorTypeContext::type_() {
  return getRuleContext<TypeScriptParser::Type_Context>(0);
}

TypeScriptParser::TypeParametersContext* TypeScriptParser::ConstructorTypeContext::typeParameters() {
  return getRuleContext<TypeScriptParser::TypeParametersContext>(0);
}

TypeScriptParser::ParameterListContext* TypeScriptParser::ConstructorTypeContext::parameterList() {
  return getRuleContext<TypeScriptParser::ParameterListContext>(0);
}


size_t TypeScriptParser::ConstructorTypeContext::getRuleIndex() const {
  return TypeScriptParser::RuleConstructorType;
}

void TypeScriptParser::ConstructorTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstructorType(this);
}

void TypeScriptParser::ConstructorTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstructorType(this);
}

TypeScriptParser::ConstructorTypeContext* TypeScriptParser::constructorType() {
  ConstructorTypeContext *_localctx = _tracker.createInstance<ConstructorTypeContext>(_ctx, getState());
  enterRule(_localctx, 52, TypeScriptParser::RuleConstructorType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(471);
    match(TypeScriptParser::New);
    setState(473);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::LessThan) {
      setState(472);
      typeParameters();
    }
    setState(475);
    match(TypeScriptParser::OpenParen);
    setState(477);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4503599627370430192) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1787629984886554623) != 0)) {
      setState(476);
      parameterList();
    }
    setState(479);
    match(TypeScriptParser::CloseParen);
    setState(480);
    match(TypeScriptParser::ARROW);
    setState(481);
    type_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeQueryContext ------------------------------------------------------------------

TypeScriptParser::TypeQueryContext::TypeQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::TypeQueryContext::Typeof() {
  return getToken(TypeScriptParser::Typeof, 0);
}

TypeScriptParser::TypeQueryExpressionContext* TypeScriptParser::TypeQueryContext::typeQueryExpression() {
  return getRuleContext<TypeScriptParser::TypeQueryExpressionContext>(0);
}


size_t TypeScriptParser::TypeQueryContext::getRuleIndex() const {
  return TypeScriptParser::RuleTypeQuery;
}

void TypeScriptParser::TypeQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeQuery(this);
}

void TypeScriptParser::TypeQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeQuery(this);
}

TypeScriptParser::TypeQueryContext* TypeScriptParser::typeQuery() {
  TypeQueryContext *_localctx = _tracker.createInstance<TypeQueryContext>(_ctx, getState());
  enterRule(_localctx, 54, TypeScriptParser::RuleTypeQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(483);
    match(TypeScriptParser::Typeof);
    setState(484);
    typeQueryExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeQueryExpressionContext ------------------------------------------------------------------

TypeScriptParser::TypeQueryExpressionContext::TypeQueryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::TypeQueryExpressionContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

std::vector<TypeScriptParser::IdentifierNameContext *> TypeScriptParser::TypeQueryExpressionContext::identifierName() {
  return getRuleContexts<TypeScriptParser::IdentifierNameContext>();
}

TypeScriptParser::IdentifierNameContext* TypeScriptParser::TypeQueryExpressionContext::identifierName(size_t i) {
  return getRuleContext<TypeScriptParser::IdentifierNameContext>(i);
}

std::vector<tree::TerminalNode *> TypeScriptParser::TypeQueryExpressionContext::Dot() {
  return getTokens(TypeScriptParser::Dot);
}

tree::TerminalNode* TypeScriptParser::TypeQueryExpressionContext::Dot(size_t i) {
  return getToken(TypeScriptParser::Dot, i);
}


size_t TypeScriptParser::TypeQueryExpressionContext::getRuleIndex() const {
  return TypeScriptParser::RuleTypeQueryExpression;
}

void TypeScriptParser::TypeQueryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeQueryExpression(this);
}

void TypeScriptParser::TypeQueryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeQueryExpression(this);
}

TypeScriptParser::TypeQueryExpressionContext* TypeScriptParser::typeQueryExpression() {
  TypeQueryExpressionContext *_localctx = _tracker.createInstance<TypeQueryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 56, TypeScriptParser::RuleTypeQueryExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(496);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(486);
      match(TypeScriptParser::Identifier);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(490); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(487);
                identifierName();
                setState(488);
                match(TypeScriptParser::Dot);
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(492); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(494);
      identifierName();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertySignaturContext ------------------------------------------------------------------

TypeScriptParser::PropertySignaturContext::PropertySignaturContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::PropertyNameContext* TypeScriptParser::PropertySignaturContext::propertyName() {
  return getRuleContext<TypeScriptParser::PropertyNameContext>(0);
}

tree::TerminalNode* TypeScriptParser::PropertySignaturContext::ReadOnly() {
  return getToken(TypeScriptParser::ReadOnly, 0);
}

tree::TerminalNode* TypeScriptParser::PropertySignaturContext::QuestionMark() {
  return getToken(TypeScriptParser::QuestionMark, 0);
}

TypeScriptParser::TypeAnnotationContext* TypeScriptParser::PropertySignaturContext::typeAnnotation() {
  return getRuleContext<TypeScriptParser::TypeAnnotationContext>(0);
}

tree::TerminalNode* TypeScriptParser::PropertySignaturContext::ARROW() {
  return getToken(TypeScriptParser::ARROW, 0);
}

TypeScriptParser::Type_Context* TypeScriptParser::PropertySignaturContext::type_() {
  return getRuleContext<TypeScriptParser::Type_Context>(0);
}


size_t TypeScriptParser::PropertySignaturContext::getRuleIndex() const {
  return TypeScriptParser::RulePropertySignatur;
}

void TypeScriptParser::PropertySignaturContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertySignatur(this);
}

void TypeScriptParser::PropertySignaturContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertySignatur(this);
}

TypeScriptParser::PropertySignaturContext* TypeScriptParser::propertySignatur() {
  PropertySignaturContext *_localctx = _tracker.createInstance<PropertySignaturContext>(_ctx, getState());
  enterRule(_localctx, 58, TypeScriptParser::RulePropertySignatur);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(499);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
    case 1: {
      setState(498);
      match(TypeScriptParser::ReadOnly);
      break;
    }

    default:
      break;
    }
    setState(501);
    propertyName();
    setState(503);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::QuestionMark) {
      setState(502);
      match(TypeScriptParser::QuestionMark);
    }
    setState(506);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Colon) {
      setState(505);
      typeAnnotation();
    }
    setState(510);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::ARROW) {
      setState(508);
      match(TypeScriptParser::ARROW);
      setState(509);
      type_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeAnnotationContext ------------------------------------------------------------------

TypeScriptParser::TypeAnnotationContext::TypeAnnotationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::TypeAnnotationContext::Colon() {
  return getToken(TypeScriptParser::Colon, 0);
}

TypeScriptParser::Type_Context* TypeScriptParser::TypeAnnotationContext::type_() {
  return getRuleContext<TypeScriptParser::Type_Context>(0);
}


size_t TypeScriptParser::TypeAnnotationContext::getRuleIndex() const {
  return TypeScriptParser::RuleTypeAnnotation;
}

void TypeScriptParser::TypeAnnotationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeAnnotation(this);
}

void TypeScriptParser::TypeAnnotationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeAnnotation(this);
}

TypeScriptParser::TypeAnnotationContext* TypeScriptParser::typeAnnotation() {
  TypeAnnotationContext *_localctx = _tracker.createInstance<TypeAnnotationContext>(_ctx, getState());
  enterRule(_localctx, 60, TypeScriptParser::RuleTypeAnnotation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(512);
    match(TypeScriptParser::Colon);
    setState(513);
    type_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CallSignatureContext ------------------------------------------------------------------

TypeScriptParser::CallSignatureContext::CallSignatureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::CallSignatureContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

tree::TerminalNode* TypeScriptParser::CallSignatureContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

TypeScriptParser::TypeParametersContext* TypeScriptParser::CallSignatureContext::typeParameters() {
  return getRuleContext<TypeScriptParser::TypeParametersContext>(0);
}

TypeScriptParser::ParameterListContext* TypeScriptParser::CallSignatureContext::parameterList() {
  return getRuleContext<TypeScriptParser::ParameterListContext>(0);
}

TypeScriptParser::TypeAnnotationContext* TypeScriptParser::CallSignatureContext::typeAnnotation() {
  return getRuleContext<TypeScriptParser::TypeAnnotationContext>(0);
}


size_t TypeScriptParser::CallSignatureContext::getRuleIndex() const {
  return TypeScriptParser::RuleCallSignature;
}

void TypeScriptParser::CallSignatureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCallSignature(this);
}

void TypeScriptParser::CallSignatureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCallSignature(this);
}

TypeScriptParser::CallSignatureContext* TypeScriptParser::callSignature() {
  CallSignatureContext *_localctx = _tracker.createInstance<CallSignatureContext>(_ctx, getState());
  enterRule(_localctx, 62, TypeScriptParser::RuleCallSignature);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(516);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::LessThan) {
      setState(515);
      typeParameters();
    }
    setState(518);
    match(TypeScriptParser::OpenParen);
    setState(520);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4503599627370430192) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1787629984886554623) != 0)) {
      setState(519);
      parameterList();
    }
    setState(522);
    match(TypeScriptParser::CloseParen);
    setState(524);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {
    case 1: {
      setState(523);
      typeAnnotation();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterListContext ------------------------------------------------------------------

TypeScriptParser::ParameterListContext::ParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::RestParameterContext* TypeScriptParser::ParameterListContext::restParameter() {
  return getRuleContext<TypeScriptParser::RestParameterContext>(0);
}

std::vector<TypeScriptParser::ParameterContext *> TypeScriptParser::ParameterListContext::parameter() {
  return getRuleContexts<TypeScriptParser::ParameterContext>();
}

TypeScriptParser::ParameterContext* TypeScriptParser::ParameterListContext::parameter(size_t i) {
  return getRuleContext<TypeScriptParser::ParameterContext>(i);
}

std::vector<tree::TerminalNode *> TypeScriptParser::ParameterListContext::Comma() {
  return getTokens(TypeScriptParser::Comma);
}

tree::TerminalNode* TypeScriptParser::ParameterListContext::Comma(size_t i) {
  return getToken(TypeScriptParser::Comma, i);
}


size_t TypeScriptParser::ParameterListContext::getRuleIndex() const {
  return TypeScriptParser::RuleParameterList;
}

void TypeScriptParser::ParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameterList(this);
}

void TypeScriptParser::ParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameterList(this);
}

TypeScriptParser::ParameterListContext* TypeScriptParser::parameterList() {
  ParameterListContext *_localctx = _tracker.createInstance<ParameterListContext>(_ctx, getState());
  enterRule(_localctx, 64, TypeScriptParser::RuleParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(539);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TypeScriptParser::Ellipsis: {
        enterOuterAlt(_localctx, 1);
        setState(526);
        restParameter();
        break;
      }

      case TypeScriptParser::OpenBracket:
      case TypeScriptParser::OpenBrace:
      case TypeScriptParser::NullLiteral:
      case TypeScriptParser::BooleanLiteral:
      case TypeScriptParser::Break:
      case TypeScriptParser::Do:
      case TypeScriptParser::Instanceof:
      case TypeScriptParser::Typeof:
      case TypeScriptParser::Case:
      case TypeScriptParser::Else:
      case TypeScriptParser::New:
      case TypeScriptParser::Var:
      case TypeScriptParser::Catch:
      case TypeScriptParser::Finally:
      case TypeScriptParser::Return:
      case TypeScriptParser::Void:
      case TypeScriptParser::Continue:
      case TypeScriptParser::For:
      case TypeScriptParser::Switch:
      case TypeScriptParser::While:
      case TypeScriptParser::Debugger:
      case TypeScriptParser::Function_:
      case TypeScriptParser::This:
      case TypeScriptParser::With:
      case TypeScriptParser::Default:
      case TypeScriptParser::If:
      case TypeScriptParser::Throw:
      case TypeScriptParser::Delete:
      case TypeScriptParser::In:
      case TypeScriptParser::Try:
      case TypeScriptParser::From:
      case TypeScriptParser::ReadOnly:
      case TypeScriptParser::Async:
      case TypeScriptParser::Class:
      case TypeScriptParser::Enum:
      case TypeScriptParser::Extends:
      case TypeScriptParser::Super:
      case TypeScriptParser::Const:
      case TypeScriptParser::Export:
      case TypeScriptParser::Import:
      case TypeScriptParser::Implements:
      case TypeScriptParser::Let:
      case TypeScriptParser::Private:
      case TypeScriptParser::Public:
      case TypeScriptParser::Interface:
      case TypeScriptParser::Package:
      case TypeScriptParser::Protected:
      case TypeScriptParser::Static:
      case TypeScriptParser::Yield:
      case TypeScriptParser::Number:
      case TypeScriptParser::Boolean:
      case TypeScriptParser::String:
      case TypeScriptParser::TypeAlias:
      case TypeScriptParser::Get:
      case TypeScriptParser::Set:
      case TypeScriptParser::Require:
      case TypeScriptParser::Module:
      case TypeScriptParser::At:
      case TypeScriptParser::Identifier: {
        enterOuterAlt(_localctx, 2);
        setState(527);
        parameter();
        setState(532);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(528);
            match(TypeScriptParser::Comma);
            setState(529);
            parameter(); 
          }
          setState(534);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx);
        }
        setState(537);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TypeScriptParser::Comma) {
          setState(535);
          match(TypeScriptParser::Comma);
          setState(536);
          restParameter();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RequiredParameterListContext ------------------------------------------------------------------

TypeScriptParser::RequiredParameterListContext::RequiredParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TypeScriptParser::RequiredParameterContext *> TypeScriptParser::RequiredParameterListContext::requiredParameter() {
  return getRuleContexts<TypeScriptParser::RequiredParameterContext>();
}

TypeScriptParser::RequiredParameterContext* TypeScriptParser::RequiredParameterListContext::requiredParameter(size_t i) {
  return getRuleContext<TypeScriptParser::RequiredParameterContext>(i);
}

std::vector<tree::TerminalNode *> TypeScriptParser::RequiredParameterListContext::Comma() {
  return getTokens(TypeScriptParser::Comma);
}

tree::TerminalNode* TypeScriptParser::RequiredParameterListContext::Comma(size_t i) {
  return getToken(TypeScriptParser::Comma, i);
}


size_t TypeScriptParser::RequiredParameterListContext::getRuleIndex() const {
  return TypeScriptParser::RuleRequiredParameterList;
}

void TypeScriptParser::RequiredParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRequiredParameterList(this);
}

void TypeScriptParser::RequiredParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRequiredParameterList(this);
}

TypeScriptParser::RequiredParameterListContext* TypeScriptParser::requiredParameterList() {
  RequiredParameterListContext *_localctx = _tracker.createInstance<RequiredParameterListContext>(_ctx, getState());
  enterRule(_localctx, 66, TypeScriptParser::RuleRequiredParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(541);
    requiredParameter();
    setState(546);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TypeScriptParser::Comma) {
      setState(542);
      match(TypeScriptParser::Comma);
      setState(543);
      requiredParameter();
      setState(548);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterContext ------------------------------------------------------------------

TypeScriptParser::ParameterContext::ParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::RequiredParameterContext* TypeScriptParser::ParameterContext::requiredParameter() {
  return getRuleContext<TypeScriptParser::RequiredParameterContext>(0);
}

TypeScriptParser::OptionalParameterContext* TypeScriptParser::ParameterContext::optionalParameter() {
  return getRuleContext<TypeScriptParser::OptionalParameterContext>(0);
}


size_t TypeScriptParser::ParameterContext::getRuleIndex() const {
  return TypeScriptParser::RuleParameter;
}

void TypeScriptParser::ParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter(this);
}

void TypeScriptParser::ParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter(this);
}

TypeScriptParser::ParameterContext* TypeScriptParser::parameter() {
  ParameterContext *_localctx = _tracker.createInstance<ParameterContext>(_ctx, getState());
  enterRule(_localctx, 68, TypeScriptParser::RuleParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(551);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(549);
      requiredParameter();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(550);
      optionalParameter();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionalParameterContext ------------------------------------------------------------------

TypeScriptParser::OptionalParameterContext::OptionalParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::IdentifierOrPatternContext* TypeScriptParser::OptionalParameterContext::identifierOrPattern() {
  return getRuleContext<TypeScriptParser::IdentifierOrPatternContext>(0);
}

TypeScriptParser::DecoratorListContext* TypeScriptParser::OptionalParameterContext::decoratorList() {
  return getRuleContext<TypeScriptParser::DecoratorListContext>(0);
}

tree::TerminalNode* TypeScriptParser::OptionalParameterContext::QuestionMark() {
  return getToken(TypeScriptParser::QuestionMark, 0);
}

TypeScriptParser::InitializerContext* TypeScriptParser::OptionalParameterContext::initializer() {
  return getRuleContext<TypeScriptParser::InitializerContext>(0);
}

TypeScriptParser::AccessibilityModifierContext* TypeScriptParser::OptionalParameterContext::accessibilityModifier() {
  return getRuleContext<TypeScriptParser::AccessibilityModifierContext>(0);
}

TypeScriptParser::TypeAnnotationContext* TypeScriptParser::OptionalParameterContext::typeAnnotation() {
  return getRuleContext<TypeScriptParser::TypeAnnotationContext>(0);
}


size_t TypeScriptParser::OptionalParameterContext::getRuleIndex() const {
  return TypeScriptParser::RuleOptionalParameter;
}

void TypeScriptParser::OptionalParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionalParameter(this);
}

void TypeScriptParser::OptionalParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionalParameter(this);
}

TypeScriptParser::OptionalParameterContext* TypeScriptParser::optionalParameter() {
  OptionalParameterContext *_localctx = _tracker.createInstance<OptionalParameterContext>(_ctx, getState());
  enterRule(_localctx, 70, TypeScriptParser::RuleOptionalParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(554);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::At) {
      setState(553);
      decoratorList();
    }

    setState(557);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx)) {
    case 1: {
      setState(556);
      accessibilityModifier();
      break;
    }

    default:
      break;
    }
    setState(559);
    identifierOrPattern();
    setState(568);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TypeScriptParser::QuestionMark: {
        setState(560);
        match(TypeScriptParser::QuestionMark);
        setState(562);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TypeScriptParser::Colon) {
          setState(561);
          typeAnnotation();
        }
        break;
      }

      case TypeScriptParser::Assign:
      case TypeScriptParser::Colon: {
        setState(565);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TypeScriptParser::Colon) {
          setState(564);
          typeAnnotation();
        }
        setState(567);
        initializer();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RestParameterContext ------------------------------------------------------------------

TypeScriptParser::RestParameterContext::RestParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::RestParameterContext::Ellipsis() {
  return getToken(TypeScriptParser::Ellipsis, 0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::RestParameterContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

TypeScriptParser::TypeAnnotationContext* TypeScriptParser::RestParameterContext::typeAnnotation() {
  return getRuleContext<TypeScriptParser::TypeAnnotationContext>(0);
}


size_t TypeScriptParser::RestParameterContext::getRuleIndex() const {
  return TypeScriptParser::RuleRestParameter;
}

void TypeScriptParser::RestParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRestParameter(this);
}

void TypeScriptParser::RestParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRestParameter(this);
}

TypeScriptParser::RestParameterContext* TypeScriptParser::restParameter() {
  RestParameterContext *_localctx = _tracker.createInstance<RestParameterContext>(_ctx, getState());
  enterRule(_localctx, 72, TypeScriptParser::RuleRestParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(570);
    match(TypeScriptParser::Ellipsis);
    setState(571);
    singleExpression(0);
    setState(573);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Colon) {
      setState(572);
      typeAnnotation();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RequiredParameterContext ------------------------------------------------------------------

TypeScriptParser::RequiredParameterContext::RequiredParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::IdentifierOrPatternContext* TypeScriptParser::RequiredParameterContext::identifierOrPattern() {
  return getRuleContext<TypeScriptParser::IdentifierOrPatternContext>(0);
}

TypeScriptParser::DecoratorListContext* TypeScriptParser::RequiredParameterContext::decoratorList() {
  return getRuleContext<TypeScriptParser::DecoratorListContext>(0);
}

TypeScriptParser::AccessibilityModifierContext* TypeScriptParser::RequiredParameterContext::accessibilityModifier() {
  return getRuleContext<TypeScriptParser::AccessibilityModifierContext>(0);
}

TypeScriptParser::TypeAnnotationContext* TypeScriptParser::RequiredParameterContext::typeAnnotation() {
  return getRuleContext<TypeScriptParser::TypeAnnotationContext>(0);
}


size_t TypeScriptParser::RequiredParameterContext::getRuleIndex() const {
  return TypeScriptParser::RuleRequiredParameter;
}

void TypeScriptParser::RequiredParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRequiredParameter(this);
}

void TypeScriptParser::RequiredParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRequiredParameter(this);
}

TypeScriptParser::RequiredParameterContext* TypeScriptParser::requiredParameter() {
  RequiredParameterContext *_localctx = _tracker.createInstance<RequiredParameterContext>(_ctx, getState());
  enterRule(_localctx, 74, TypeScriptParser::RuleRequiredParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(576);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::At) {
      setState(575);
      decoratorList();
    }
    setState(579);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx)) {
    case 1: {
      setState(578);
      accessibilityModifier();
      break;
    }

    default:
      break;
    }
    setState(581);
    identifierOrPattern();
    setState(583);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Colon) {
      setState(582);
      typeAnnotation();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AccessibilityModifierContext ------------------------------------------------------------------

TypeScriptParser::AccessibilityModifierContext::AccessibilityModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::AccessibilityModifierContext::Public() {
  return getToken(TypeScriptParser::Public, 0);
}

tree::TerminalNode* TypeScriptParser::AccessibilityModifierContext::Private() {
  return getToken(TypeScriptParser::Private, 0);
}

tree::TerminalNode* TypeScriptParser::AccessibilityModifierContext::Protected() {
  return getToken(TypeScriptParser::Protected, 0);
}


size_t TypeScriptParser::AccessibilityModifierContext::getRuleIndex() const {
  return TypeScriptParser::RuleAccessibilityModifier;
}

void TypeScriptParser::AccessibilityModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAccessibilityModifier(this);
}

void TypeScriptParser::AccessibilityModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAccessibilityModifier(this);
}

TypeScriptParser::AccessibilityModifierContext* TypeScriptParser::accessibilityModifier() {
  AccessibilityModifierContext *_localctx = _tracker.createInstance<AccessibilityModifierContext>(_ctx, getState());
  enterRule(_localctx, 76, TypeScriptParser::RuleAccessibilityModifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(585);
    _la = _input->LA(1);
    if (!(((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 19) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierOrPatternContext ------------------------------------------------------------------

TypeScriptParser::IdentifierOrPatternContext::IdentifierOrPatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::IdentifierNameContext* TypeScriptParser::IdentifierOrPatternContext::identifierName() {
  return getRuleContext<TypeScriptParser::IdentifierNameContext>(0);
}

TypeScriptParser::BindingPatternContext* TypeScriptParser::IdentifierOrPatternContext::bindingPattern() {
  return getRuleContext<TypeScriptParser::BindingPatternContext>(0);
}


size_t TypeScriptParser::IdentifierOrPatternContext::getRuleIndex() const {
  return TypeScriptParser::RuleIdentifierOrPattern;
}

void TypeScriptParser::IdentifierOrPatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierOrPattern(this);
}

void TypeScriptParser::IdentifierOrPatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierOrPattern(this);
}

TypeScriptParser::IdentifierOrPatternContext* TypeScriptParser::identifierOrPattern() {
  IdentifierOrPatternContext *_localctx = _tracker.createInstance<IdentifierOrPatternContext>(_ctx, getState());
  enterRule(_localctx, 78, TypeScriptParser::RuleIdentifierOrPattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(589);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TypeScriptParser::NullLiteral:
      case TypeScriptParser::BooleanLiteral:
      case TypeScriptParser::Break:
      case TypeScriptParser::Do:
      case TypeScriptParser::Instanceof:
      case TypeScriptParser::Typeof:
      case TypeScriptParser::Case:
      case TypeScriptParser::Else:
      case TypeScriptParser::New:
      case TypeScriptParser::Var:
      case TypeScriptParser::Catch:
      case TypeScriptParser::Finally:
      case TypeScriptParser::Return:
      case TypeScriptParser::Void:
      case TypeScriptParser::Continue:
      case TypeScriptParser::For:
      case TypeScriptParser::Switch:
      case TypeScriptParser::While:
      case TypeScriptParser::Debugger:
      case TypeScriptParser::Function_:
      case TypeScriptParser::This:
      case TypeScriptParser::With:
      case TypeScriptParser::Default:
      case TypeScriptParser::If:
      case TypeScriptParser::Throw:
      case TypeScriptParser::Delete:
      case TypeScriptParser::In:
      case TypeScriptParser::Try:
      case TypeScriptParser::From:
      case TypeScriptParser::ReadOnly:
      case TypeScriptParser::Async:
      case TypeScriptParser::Class:
      case TypeScriptParser::Enum:
      case TypeScriptParser::Extends:
      case TypeScriptParser::Super:
      case TypeScriptParser::Const:
      case TypeScriptParser::Export:
      case TypeScriptParser::Import:
      case TypeScriptParser::Implements:
      case TypeScriptParser::Let:
      case TypeScriptParser::Private:
      case TypeScriptParser::Public:
      case TypeScriptParser::Interface:
      case TypeScriptParser::Package:
      case TypeScriptParser::Protected:
      case TypeScriptParser::Static:
      case TypeScriptParser::Yield:
      case TypeScriptParser::Number:
      case TypeScriptParser::Boolean:
      case TypeScriptParser::String:
      case TypeScriptParser::TypeAlias:
      case TypeScriptParser::Get:
      case TypeScriptParser::Set:
      case TypeScriptParser::Require:
      case TypeScriptParser::Module:
      case TypeScriptParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(587);
        identifierName();
        break;
      }

      case TypeScriptParser::OpenBracket:
      case TypeScriptParser::OpenBrace: {
        enterOuterAlt(_localctx, 2);
        setState(588);
        bindingPattern();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstructSignatureContext ------------------------------------------------------------------

TypeScriptParser::ConstructSignatureContext::ConstructSignatureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::ConstructSignatureContext::New() {
  return getToken(TypeScriptParser::New, 0);
}

tree::TerminalNode* TypeScriptParser::ConstructSignatureContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

tree::TerminalNode* TypeScriptParser::ConstructSignatureContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

TypeScriptParser::TypeParametersContext* TypeScriptParser::ConstructSignatureContext::typeParameters() {
  return getRuleContext<TypeScriptParser::TypeParametersContext>(0);
}

TypeScriptParser::ParameterListContext* TypeScriptParser::ConstructSignatureContext::parameterList() {
  return getRuleContext<TypeScriptParser::ParameterListContext>(0);
}

TypeScriptParser::TypeAnnotationContext* TypeScriptParser::ConstructSignatureContext::typeAnnotation() {
  return getRuleContext<TypeScriptParser::TypeAnnotationContext>(0);
}


size_t TypeScriptParser::ConstructSignatureContext::getRuleIndex() const {
  return TypeScriptParser::RuleConstructSignature;
}

void TypeScriptParser::ConstructSignatureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstructSignature(this);
}

void TypeScriptParser::ConstructSignatureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstructSignature(this);
}

TypeScriptParser::ConstructSignatureContext* TypeScriptParser::constructSignature() {
  ConstructSignatureContext *_localctx = _tracker.createInstance<ConstructSignatureContext>(_ctx, getState());
  enterRule(_localctx, 80, TypeScriptParser::RuleConstructSignature);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(591);
    match(TypeScriptParser::New);
    setState(593);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::LessThan) {
      setState(592);
      typeParameters();
    }
    setState(595);
    match(TypeScriptParser::OpenParen);
    setState(597);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4503599627370430192) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1787629984886554623) != 0)) {
      setState(596);
      parameterList();
    }
    setState(599);
    match(TypeScriptParser::CloseParen);
    setState(601);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Colon) {
      setState(600);
      typeAnnotation();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexSignatureContext ------------------------------------------------------------------

TypeScriptParser::IndexSignatureContext::IndexSignatureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::IndexSignatureContext::OpenBracket() {
  return getToken(TypeScriptParser::OpenBracket, 0);
}

tree::TerminalNode* TypeScriptParser::IndexSignatureContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

tree::TerminalNode* TypeScriptParser::IndexSignatureContext::Colon() {
  return getToken(TypeScriptParser::Colon, 0);
}

tree::TerminalNode* TypeScriptParser::IndexSignatureContext::CloseBracket() {
  return getToken(TypeScriptParser::CloseBracket, 0);
}

TypeScriptParser::TypeAnnotationContext* TypeScriptParser::IndexSignatureContext::typeAnnotation() {
  return getRuleContext<TypeScriptParser::TypeAnnotationContext>(0);
}

tree::TerminalNode* TypeScriptParser::IndexSignatureContext::Number() {
  return getToken(TypeScriptParser::Number, 0);
}

tree::TerminalNode* TypeScriptParser::IndexSignatureContext::String() {
  return getToken(TypeScriptParser::String, 0);
}


size_t TypeScriptParser::IndexSignatureContext::getRuleIndex() const {
  return TypeScriptParser::RuleIndexSignature;
}

void TypeScriptParser::IndexSignatureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexSignature(this);
}

void TypeScriptParser::IndexSignatureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexSignature(this);
}

TypeScriptParser::IndexSignatureContext* TypeScriptParser::indexSignature() {
  IndexSignatureContext *_localctx = _tracker.createInstance<IndexSignatureContext>(_ctx, getState());
  enterRule(_localctx, 82, TypeScriptParser::RuleIndexSignature);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(603);
    match(TypeScriptParser::OpenBracket);
    setState(604);
    match(TypeScriptParser::Identifier);
    setState(605);
    match(TypeScriptParser::Colon);
    setState(606);
    _la = _input->LA(1);
    if (!(_la == TypeScriptParser::Number

    || _la == TypeScriptParser::String)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(607);
    match(TypeScriptParser::CloseBracket);
    setState(608);
    typeAnnotation();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MethodSignatureContext ------------------------------------------------------------------

TypeScriptParser::MethodSignatureContext::MethodSignatureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::PropertyNameContext* TypeScriptParser::MethodSignatureContext::propertyName() {
  return getRuleContext<TypeScriptParser::PropertyNameContext>(0);
}

TypeScriptParser::CallSignatureContext* TypeScriptParser::MethodSignatureContext::callSignature() {
  return getRuleContext<TypeScriptParser::CallSignatureContext>(0);
}

tree::TerminalNode* TypeScriptParser::MethodSignatureContext::QuestionMark() {
  return getToken(TypeScriptParser::QuestionMark, 0);
}


size_t TypeScriptParser::MethodSignatureContext::getRuleIndex() const {
  return TypeScriptParser::RuleMethodSignature;
}

void TypeScriptParser::MethodSignatureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMethodSignature(this);
}

void TypeScriptParser::MethodSignatureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMethodSignature(this);
}

TypeScriptParser::MethodSignatureContext* TypeScriptParser::methodSignature() {
  MethodSignatureContext *_localctx = _tracker.createInstance<MethodSignatureContext>(_ctx, getState());
  enterRule(_localctx, 84, TypeScriptParser::RuleMethodSignature);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(610);
    propertyName();
    setState(612);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::QuestionMark) {
      setState(611);
      match(TypeScriptParser::QuestionMark);
    }
    setState(614);
    callSignature();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeAliasDeclarationContext ------------------------------------------------------------------

TypeScriptParser::TypeAliasDeclarationContext::TypeAliasDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::TypeAliasDeclarationContext::TypeAlias() {
  return getToken(TypeScriptParser::TypeAlias, 0);
}

tree::TerminalNode* TypeScriptParser::TypeAliasDeclarationContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

tree::TerminalNode* TypeScriptParser::TypeAliasDeclarationContext::Assign() {
  return getToken(TypeScriptParser::Assign, 0);
}

TypeScriptParser::Type_Context* TypeScriptParser::TypeAliasDeclarationContext::type_() {
  return getRuleContext<TypeScriptParser::Type_Context>(0);
}

tree::TerminalNode* TypeScriptParser::TypeAliasDeclarationContext::SemiColon() {
  return getToken(TypeScriptParser::SemiColon, 0);
}

TypeScriptParser::TypeParametersContext* TypeScriptParser::TypeAliasDeclarationContext::typeParameters() {
  return getRuleContext<TypeScriptParser::TypeParametersContext>(0);
}


size_t TypeScriptParser::TypeAliasDeclarationContext::getRuleIndex() const {
  return TypeScriptParser::RuleTypeAliasDeclaration;
}

void TypeScriptParser::TypeAliasDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeAliasDeclaration(this);
}

void TypeScriptParser::TypeAliasDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeAliasDeclaration(this);
}

TypeScriptParser::TypeAliasDeclarationContext* TypeScriptParser::typeAliasDeclaration() {
  TypeAliasDeclarationContext *_localctx = _tracker.createInstance<TypeAliasDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 86, TypeScriptParser::RuleTypeAliasDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(616);
    match(TypeScriptParser::TypeAlias);
    setState(617);
    match(TypeScriptParser::Identifier);
    setState(619);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::LessThan) {
      setState(618);
      typeParameters();
    }
    setState(621);
    match(TypeScriptParser::Assign);
    setState(622);
    type_();
    setState(623);
    match(TypeScriptParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstructorDeclarationContext ------------------------------------------------------------------

TypeScriptParser::ConstructorDeclarationContext::ConstructorDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::ConstructorDeclarationContext::Constructor() {
  return getToken(TypeScriptParser::Constructor, 0);
}

tree::TerminalNode* TypeScriptParser::ConstructorDeclarationContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

tree::TerminalNode* TypeScriptParser::ConstructorDeclarationContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

TypeScriptParser::AccessibilityModifierContext* TypeScriptParser::ConstructorDeclarationContext::accessibilityModifier() {
  return getRuleContext<TypeScriptParser::AccessibilityModifierContext>(0);
}

TypeScriptParser::FormalParameterListContext* TypeScriptParser::ConstructorDeclarationContext::formalParameterList() {
  return getRuleContext<TypeScriptParser::FormalParameterListContext>(0);
}

tree::TerminalNode* TypeScriptParser::ConstructorDeclarationContext::SemiColon() {
  return getToken(TypeScriptParser::SemiColon, 0);
}

tree::TerminalNode* TypeScriptParser::ConstructorDeclarationContext::OpenBrace() {
  return getToken(TypeScriptParser::OpenBrace, 0);
}

TypeScriptParser::FunctionBodyContext* TypeScriptParser::ConstructorDeclarationContext::functionBody() {
  return getRuleContext<TypeScriptParser::FunctionBodyContext>(0);
}

tree::TerminalNode* TypeScriptParser::ConstructorDeclarationContext::CloseBrace() {
  return getToken(TypeScriptParser::CloseBrace, 0);
}


size_t TypeScriptParser::ConstructorDeclarationContext::getRuleIndex() const {
  return TypeScriptParser::RuleConstructorDeclaration;
}

void TypeScriptParser::ConstructorDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstructorDeclaration(this);
}

void TypeScriptParser::ConstructorDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstructorDeclaration(this);
}

TypeScriptParser::ConstructorDeclarationContext* TypeScriptParser::constructorDeclaration() {
  ConstructorDeclarationContext *_localctx = _tracker.createInstance<ConstructorDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 88, TypeScriptParser::RuleConstructorDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(626);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 19) != 0)) {
      setState(625);
      accessibilityModifier();
    }
    setState(628);
    match(TypeScriptParser::Constructor);
    setState(629);
    match(TypeScriptParser::OpenParen);
    setState(631);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 65808) != 0) || ((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 12718099) != 0)) {
      setState(630);
      formalParameterList();
    }
    setState(633);
    match(TypeScriptParser::CloseParen);
    setState(639);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
    case 1: {
      setState(634);
      match(TypeScriptParser::OpenBrace);
      setState(635);
      functionBody();
      setState(636);
      match(TypeScriptParser::CloseBrace);
      break;
    }

    case 2: {
      setState(638);
      match(TypeScriptParser::SemiColon);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InterfaceDeclarationContext ------------------------------------------------------------------

TypeScriptParser::InterfaceDeclarationContext::InterfaceDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::InterfaceDeclarationContext::Interface() {
  return getToken(TypeScriptParser::Interface, 0);
}

tree::TerminalNode* TypeScriptParser::InterfaceDeclarationContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

TypeScriptParser::ObjectTypeContext* TypeScriptParser::InterfaceDeclarationContext::objectType() {
  return getRuleContext<TypeScriptParser::ObjectTypeContext>(0);
}

tree::TerminalNode* TypeScriptParser::InterfaceDeclarationContext::Export() {
  return getToken(TypeScriptParser::Export, 0);
}

tree::TerminalNode* TypeScriptParser::InterfaceDeclarationContext::Declare() {
  return getToken(TypeScriptParser::Declare, 0);
}

TypeScriptParser::TypeParametersContext* TypeScriptParser::InterfaceDeclarationContext::typeParameters() {
  return getRuleContext<TypeScriptParser::TypeParametersContext>(0);
}

TypeScriptParser::InterfaceExtendsClauseContext* TypeScriptParser::InterfaceDeclarationContext::interfaceExtendsClause() {
  return getRuleContext<TypeScriptParser::InterfaceExtendsClauseContext>(0);
}

tree::TerminalNode* TypeScriptParser::InterfaceDeclarationContext::SemiColon() {
  return getToken(TypeScriptParser::SemiColon, 0);
}


size_t TypeScriptParser::InterfaceDeclarationContext::getRuleIndex() const {
  return TypeScriptParser::RuleInterfaceDeclaration;
}

void TypeScriptParser::InterfaceDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterfaceDeclaration(this);
}

void TypeScriptParser::InterfaceDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterfaceDeclaration(this);
}

TypeScriptParser::InterfaceDeclarationContext* TypeScriptParser::interfaceDeclaration() {
  InterfaceDeclarationContext *_localctx = _tracker.createInstance<InterfaceDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 90, TypeScriptParser::RuleInterfaceDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(642);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Export) {
      setState(641);
      match(TypeScriptParser::Export);
    }
    setState(645);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Declare) {
      setState(644);
      match(TypeScriptParser::Declare);
    }
    setState(647);
    match(TypeScriptParser::Interface);
    setState(648);
    match(TypeScriptParser::Identifier);
    setState(650);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::LessThan) {
      setState(649);
      typeParameters();
    }
    setState(653);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Extends) {
      setState(652);
      interfaceExtendsClause();
    }
    setState(655);
    objectType();
    setState(657);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
    case 1: {
      setState(656);
      match(TypeScriptParser::SemiColon);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InterfaceExtendsClauseContext ------------------------------------------------------------------

TypeScriptParser::InterfaceExtendsClauseContext::InterfaceExtendsClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::InterfaceExtendsClauseContext::Extends() {
  return getToken(TypeScriptParser::Extends, 0);
}

TypeScriptParser::ClassOrInterfaceTypeListContext* TypeScriptParser::InterfaceExtendsClauseContext::classOrInterfaceTypeList() {
  return getRuleContext<TypeScriptParser::ClassOrInterfaceTypeListContext>(0);
}


size_t TypeScriptParser::InterfaceExtendsClauseContext::getRuleIndex() const {
  return TypeScriptParser::RuleInterfaceExtendsClause;
}

void TypeScriptParser::InterfaceExtendsClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterfaceExtendsClause(this);
}

void TypeScriptParser::InterfaceExtendsClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterfaceExtendsClause(this);
}

TypeScriptParser::InterfaceExtendsClauseContext* TypeScriptParser::interfaceExtendsClause() {
  InterfaceExtendsClauseContext *_localctx = _tracker.createInstance<InterfaceExtendsClauseContext>(_ctx, getState());
  enterRule(_localctx, 92, TypeScriptParser::RuleInterfaceExtendsClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(659);
    match(TypeScriptParser::Extends);
    setState(660);
    classOrInterfaceTypeList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassOrInterfaceTypeListContext ------------------------------------------------------------------

TypeScriptParser::ClassOrInterfaceTypeListContext::ClassOrInterfaceTypeListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TypeScriptParser::TypeReferenceContext *> TypeScriptParser::ClassOrInterfaceTypeListContext::typeReference() {
  return getRuleContexts<TypeScriptParser::TypeReferenceContext>();
}

TypeScriptParser::TypeReferenceContext* TypeScriptParser::ClassOrInterfaceTypeListContext::typeReference(size_t i) {
  return getRuleContext<TypeScriptParser::TypeReferenceContext>(i);
}

std::vector<tree::TerminalNode *> TypeScriptParser::ClassOrInterfaceTypeListContext::Comma() {
  return getTokens(TypeScriptParser::Comma);
}

tree::TerminalNode* TypeScriptParser::ClassOrInterfaceTypeListContext::Comma(size_t i) {
  return getToken(TypeScriptParser::Comma, i);
}


size_t TypeScriptParser::ClassOrInterfaceTypeListContext::getRuleIndex() const {
  return TypeScriptParser::RuleClassOrInterfaceTypeList;
}

void TypeScriptParser::ClassOrInterfaceTypeListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassOrInterfaceTypeList(this);
}

void TypeScriptParser::ClassOrInterfaceTypeListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassOrInterfaceTypeList(this);
}

TypeScriptParser::ClassOrInterfaceTypeListContext* TypeScriptParser::classOrInterfaceTypeList() {
  ClassOrInterfaceTypeListContext *_localctx = _tracker.createInstance<ClassOrInterfaceTypeListContext>(_ctx, getState());
  enterRule(_localctx, 94, TypeScriptParser::RuleClassOrInterfaceTypeList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(662);
    typeReference();
    setState(667);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TypeScriptParser::Comma) {
      setState(663);
      match(TypeScriptParser::Comma);
      setState(664);
      typeReference();
      setState(669);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumDeclarationContext ------------------------------------------------------------------

TypeScriptParser::EnumDeclarationContext::EnumDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::EnumDeclarationContext::Enum() {
  return getToken(TypeScriptParser::Enum, 0);
}

tree::TerminalNode* TypeScriptParser::EnumDeclarationContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

tree::TerminalNode* TypeScriptParser::EnumDeclarationContext::OpenBrace() {
  return getToken(TypeScriptParser::OpenBrace, 0);
}

tree::TerminalNode* TypeScriptParser::EnumDeclarationContext::CloseBrace() {
  return getToken(TypeScriptParser::CloseBrace, 0);
}

tree::TerminalNode* TypeScriptParser::EnumDeclarationContext::Const() {
  return getToken(TypeScriptParser::Const, 0);
}

TypeScriptParser::EnumBodyContext* TypeScriptParser::EnumDeclarationContext::enumBody() {
  return getRuleContext<TypeScriptParser::EnumBodyContext>(0);
}


size_t TypeScriptParser::EnumDeclarationContext::getRuleIndex() const {
  return TypeScriptParser::RuleEnumDeclaration;
}

void TypeScriptParser::EnumDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumDeclaration(this);
}

void TypeScriptParser::EnumDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumDeclaration(this);
}

TypeScriptParser::EnumDeclarationContext* TypeScriptParser::enumDeclaration() {
  EnumDeclarationContext *_localctx = _tracker.createInstance<EnumDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 96, TypeScriptParser::RuleEnumDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(671);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Const) {
      setState(670);
      match(TypeScriptParser::Const);
    }
    setState(673);
    match(TypeScriptParser::Enum);
    setState(674);
    match(TypeScriptParser::Identifier);
    setState(675);
    match(TypeScriptParser::OpenBrace);
    setState(677);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -36028797018963968) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3517012241796825087) != 0)) {
      setState(676);
      enumBody();
    }
    setState(679);
    match(TypeScriptParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumBodyContext ------------------------------------------------------------------

TypeScriptParser::EnumBodyContext::EnumBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::EnumMemberListContext* TypeScriptParser::EnumBodyContext::enumMemberList() {
  return getRuleContext<TypeScriptParser::EnumMemberListContext>(0);
}

tree::TerminalNode* TypeScriptParser::EnumBodyContext::Comma() {
  return getToken(TypeScriptParser::Comma, 0);
}


size_t TypeScriptParser::EnumBodyContext::getRuleIndex() const {
  return TypeScriptParser::RuleEnumBody;
}

void TypeScriptParser::EnumBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumBody(this);
}

void TypeScriptParser::EnumBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumBody(this);
}

TypeScriptParser::EnumBodyContext* TypeScriptParser::enumBody() {
  EnumBodyContext *_localctx = _tracker.createInstance<EnumBodyContext>(_ctx, getState());
  enterRule(_localctx, 98, TypeScriptParser::RuleEnumBody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(681);
    enumMemberList();
    setState(683);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Comma) {
      setState(682);
      match(TypeScriptParser::Comma);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumMemberListContext ------------------------------------------------------------------

TypeScriptParser::EnumMemberListContext::EnumMemberListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TypeScriptParser::EnumMemberContext *> TypeScriptParser::EnumMemberListContext::enumMember() {
  return getRuleContexts<TypeScriptParser::EnumMemberContext>();
}

TypeScriptParser::EnumMemberContext* TypeScriptParser::EnumMemberListContext::enumMember(size_t i) {
  return getRuleContext<TypeScriptParser::EnumMemberContext>(i);
}

std::vector<tree::TerminalNode *> TypeScriptParser::EnumMemberListContext::Comma() {
  return getTokens(TypeScriptParser::Comma);
}

tree::TerminalNode* TypeScriptParser::EnumMemberListContext::Comma(size_t i) {
  return getToken(TypeScriptParser::Comma, i);
}


size_t TypeScriptParser::EnumMemberListContext::getRuleIndex() const {
  return TypeScriptParser::RuleEnumMemberList;
}

void TypeScriptParser::EnumMemberListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumMemberList(this);
}

void TypeScriptParser::EnumMemberListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumMemberList(this);
}

TypeScriptParser::EnumMemberListContext* TypeScriptParser::enumMemberList() {
  EnumMemberListContext *_localctx = _tracker.createInstance<EnumMemberListContext>(_ctx, getState());
  enterRule(_localctx, 100, TypeScriptParser::RuleEnumMemberList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(685);
    enumMember();
    setState(690);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(686);
        match(TypeScriptParser::Comma);
        setState(687);
        enumMember(); 
      }
      setState(692);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumMemberContext ------------------------------------------------------------------

TypeScriptParser::EnumMemberContext::EnumMemberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::PropertyNameContext* TypeScriptParser::EnumMemberContext::propertyName() {
  return getRuleContext<TypeScriptParser::PropertyNameContext>(0);
}

tree::TerminalNode* TypeScriptParser::EnumMemberContext::Assign() {
  return getToken(TypeScriptParser::Assign, 0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::EnumMemberContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}


size_t TypeScriptParser::EnumMemberContext::getRuleIndex() const {
  return TypeScriptParser::RuleEnumMember;
}

void TypeScriptParser::EnumMemberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumMember(this);
}

void TypeScriptParser::EnumMemberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumMember(this);
}

TypeScriptParser::EnumMemberContext* TypeScriptParser::enumMember() {
  EnumMemberContext *_localctx = _tracker.createInstance<EnumMemberContext>(_ctx, getState());
  enterRule(_localctx, 102, TypeScriptParser::RuleEnumMember);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(693);
    propertyName();
    setState(696);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Assign) {
      setState(694);
      match(TypeScriptParser::Assign);
      setState(695);
      singleExpression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamespaceDeclarationContext ------------------------------------------------------------------

TypeScriptParser::NamespaceDeclarationContext::NamespaceDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::NamespaceDeclarationContext::Namespace() {
  return getToken(TypeScriptParser::Namespace, 0);
}

TypeScriptParser::NamespaceNameContext* TypeScriptParser::NamespaceDeclarationContext::namespaceName() {
  return getRuleContext<TypeScriptParser::NamespaceNameContext>(0);
}

tree::TerminalNode* TypeScriptParser::NamespaceDeclarationContext::OpenBrace() {
  return getToken(TypeScriptParser::OpenBrace, 0);
}

tree::TerminalNode* TypeScriptParser::NamespaceDeclarationContext::CloseBrace() {
  return getToken(TypeScriptParser::CloseBrace, 0);
}

TypeScriptParser::StatementListContext* TypeScriptParser::NamespaceDeclarationContext::statementList() {
  return getRuleContext<TypeScriptParser::StatementListContext>(0);
}


size_t TypeScriptParser::NamespaceDeclarationContext::getRuleIndex() const {
  return TypeScriptParser::RuleNamespaceDeclaration;
}

void TypeScriptParser::NamespaceDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamespaceDeclaration(this);
}

void TypeScriptParser::NamespaceDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamespaceDeclaration(this);
}

TypeScriptParser::NamespaceDeclarationContext* TypeScriptParser::namespaceDeclaration() {
  NamespaceDeclarationContext *_localctx = _tracker.createInstance<NamespaceDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 104, TypeScriptParser::RuleNamespaceDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(698);
    match(TypeScriptParser::Namespace);
    setState(699);
    namespaceName();
    setState(700);
    match(TypeScriptParser::OpenBrace);
    setState(702);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
    case 1: {
      setState(701);
      statementList();
      break;
    }

    default:
      break;
    }
    setState(704);
    match(TypeScriptParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamespaceNameContext ------------------------------------------------------------------

TypeScriptParser::NamespaceNameContext::NamespaceNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TypeScriptParser::NamespaceNameContext::Identifier() {
  return getTokens(TypeScriptParser::Identifier);
}

tree::TerminalNode* TypeScriptParser::NamespaceNameContext::Identifier(size_t i) {
  return getToken(TypeScriptParser::Identifier, i);
}

std::vector<tree::TerminalNode *> TypeScriptParser::NamespaceNameContext::Dot() {
  return getTokens(TypeScriptParser::Dot);
}

tree::TerminalNode* TypeScriptParser::NamespaceNameContext::Dot(size_t i) {
  return getToken(TypeScriptParser::Dot, i);
}


size_t TypeScriptParser::NamespaceNameContext::getRuleIndex() const {
  return TypeScriptParser::RuleNamespaceName;
}

void TypeScriptParser::NamespaceNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamespaceName(this);
}

void TypeScriptParser::NamespaceNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamespaceName(this);
}

TypeScriptParser::NamespaceNameContext* TypeScriptParser::namespaceName() {
  NamespaceNameContext *_localctx = _tracker.createInstance<NamespaceNameContext>(_ctx, getState());
  enterRule(_localctx, 106, TypeScriptParser::RuleNamespaceName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(706);
    match(TypeScriptParser::Identifier);
    setState(715);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(708); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(707);
          match(TypeScriptParser::Dot);
          setState(710); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == TypeScriptParser::Dot);
        setState(712);
        match(TypeScriptParser::Identifier); 
      }
      setState(717);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportAliasDeclarationContext ------------------------------------------------------------------

TypeScriptParser::ImportAliasDeclarationContext::ImportAliasDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::ImportAliasDeclarationContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

tree::TerminalNode* TypeScriptParser::ImportAliasDeclarationContext::Assign() {
  return getToken(TypeScriptParser::Assign, 0);
}

TypeScriptParser::NamespaceNameContext* TypeScriptParser::ImportAliasDeclarationContext::namespaceName() {
  return getRuleContext<TypeScriptParser::NamespaceNameContext>(0);
}

tree::TerminalNode* TypeScriptParser::ImportAliasDeclarationContext::SemiColon() {
  return getToken(TypeScriptParser::SemiColon, 0);
}


size_t TypeScriptParser::ImportAliasDeclarationContext::getRuleIndex() const {
  return TypeScriptParser::RuleImportAliasDeclaration;
}

void TypeScriptParser::ImportAliasDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportAliasDeclaration(this);
}

void TypeScriptParser::ImportAliasDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportAliasDeclaration(this);
}

TypeScriptParser::ImportAliasDeclarationContext* TypeScriptParser::importAliasDeclaration() {
  ImportAliasDeclarationContext *_localctx = _tracker.createInstance<ImportAliasDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 108, TypeScriptParser::RuleImportAliasDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(718);
    match(TypeScriptParser::Identifier);
    setState(719);
    match(TypeScriptParser::Assign);
    setState(720);
    namespaceName();
    setState(721);
    match(TypeScriptParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DecoratorListContext ------------------------------------------------------------------

TypeScriptParser::DecoratorListContext::DecoratorListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TypeScriptParser::DecoratorContext *> TypeScriptParser::DecoratorListContext::decorator() {
  return getRuleContexts<TypeScriptParser::DecoratorContext>();
}

TypeScriptParser::DecoratorContext* TypeScriptParser::DecoratorListContext::decorator(size_t i) {
  return getRuleContext<TypeScriptParser::DecoratorContext>(i);
}


size_t TypeScriptParser::DecoratorListContext::getRuleIndex() const {
  return TypeScriptParser::RuleDecoratorList;
}

void TypeScriptParser::DecoratorListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecoratorList(this);
}

void TypeScriptParser::DecoratorListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecoratorList(this);
}

TypeScriptParser::DecoratorListContext* TypeScriptParser::decoratorList() {
  DecoratorListContext *_localctx = _tracker.createInstance<DecoratorListContext>(_ctx, getState());
  enterRule(_localctx, 110, TypeScriptParser::RuleDecoratorList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(724); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(723);
      decorator();
      setState(726); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == TypeScriptParser::At);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DecoratorContext ------------------------------------------------------------------

TypeScriptParser::DecoratorContext::DecoratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::DecoratorContext::At() {
  return getToken(TypeScriptParser::At, 0);
}

TypeScriptParser::DecoratorMemberExpressionContext* TypeScriptParser::DecoratorContext::decoratorMemberExpression() {
  return getRuleContext<TypeScriptParser::DecoratorMemberExpressionContext>(0);
}

TypeScriptParser::DecoratorCallExpressionContext* TypeScriptParser::DecoratorContext::decoratorCallExpression() {
  return getRuleContext<TypeScriptParser::DecoratorCallExpressionContext>(0);
}


size_t TypeScriptParser::DecoratorContext::getRuleIndex() const {
  return TypeScriptParser::RuleDecorator;
}

void TypeScriptParser::DecoratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecorator(this);
}

void TypeScriptParser::DecoratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecorator(this);
}

TypeScriptParser::DecoratorContext* TypeScriptParser::decorator() {
  DecoratorContext *_localctx = _tracker.createInstance<DecoratorContext>(_ctx, getState());
  enterRule(_localctx, 112, TypeScriptParser::RuleDecorator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(728);
    match(TypeScriptParser::At);
    setState(731);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx)) {
    case 1: {
      setState(729);
      decoratorMemberExpression(0);
      break;
    }

    case 2: {
      setState(730);
      decoratorCallExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DecoratorMemberExpressionContext ------------------------------------------------------------------

TypeScriptParser::DecoratorMemberExpressionContext::DecoratorMemberExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::DecoratorMemberExpressionContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

tree::TerminalNode* TypeScriptParser::DecoratorMemberExpressionContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::DecoratorMemberExpressionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* TypeScriptParser::DecoratorMemberExpressionContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

TypeScriptParser::DecoratorMemberExpressionContext* TypeScriptParser::DecoratorMemberExpressionContext::decoratorMemberExpression() {
  return getRuleContext<TypeScriptParser::DecoratorMemberExpressionContext>(0);
}

tree::TerminalNode* TypeScriptParser::DecoratorMemberExpressionContext::Dot() {
  return getToken(TypeScriptParser::Dot, 0);
}

TypeScriptParser::IdentifierNameContext* TypeScriptParser::DecoratorMemberExpressionContext::identifierName() {
  return getRuleContext<TypeScriptParser::IdentifierNameContext>(0);
}


size_t TypeScriptParser::DecoratorMemberExpressionContext::getRuleIndex() const {
  return TypeScriptParser::RuleDecoratorMemberExpression;
}

void TypeScriptParser::DecoratorMemberExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecoratorMemberExpression(this);
}

void TypeScriptParser::DecoratorMemberExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecoratorMemberExpression(this);
}


TypeScriptParser::DecoratorMemberExpressionContext* TypeScriptParser::decoratorMemberExpression() {
   return decoratorMemberExpression(0);
}

TypeScriptParser::DecoratorMemberExpressionContext* TypeScriptParser::decoratorMemberExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  TypeScriptParser::DecoratorMemberExpressionContext *_localctx = _tracker.createInstance<DecoratorMemberExpressionContext>(_ctx, parentState);
  TypeScriptParser::DecoratorMemberExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 114;
  enterRecursionRule(_localctx, 114, TypeScriptParser::RuleDecoratorMemberExpression, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(739);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TypeScriptParser::Identifier: {
        setState(734);
        match(TypeScriptParser::Identifier);
        break;
      }

      case TypeScriptParser::OpenParen: {
        setState(735);
        match(TypeScriptParser::OpenParen);
        setState(736);
        singleExpression(0);
        setState(737);
        match(TypeScriptParser::CloseParen);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(746);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<DecoratorMemberExpressionContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleDecoratorMemberExpression);
        setState(741);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(742);
        match(TypeScriptParser::Dot);
        setState(743);
        identifierName(); 
      }
      setState(748);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- DecoratorCallExpressionContext ------------------------------------------------------------------

TypeScriptParser::DecoratorCallExpressionContext::DecoratorCallExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::DecoratorMemberExpressionContext* TypeScriptParser::DecoratorCallExpressionContext::decoratorMemberExpression() {
  return getRuleContext<TypeScriptParser::DecoratorMemberExpressionContext>(0);
}

TypeScriptParser::ArgumentsContext* TypeScriptParser::DecoratorCallExpressionContext::arguments() {
  return getRuleContext<TypeScriptParser::ArgumentsContext>(0);
}


size_t TypeScriptParser::DecoratorCallExpressionContext::getRuleIndex() const {
  return TypeScriptParser::RuleDecoratorCallExpression;
}

void TypeScriptParser::DecoratorCallExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecoratorCallExpression(this);
}

void TypeScriptParser::DecoratorCallExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecoratorCallExpression(this);
}

TypeScriptParser::DecoratorCallExpressionContext* TypeScriptParser::decoratorCallExpression() {
  DecoratorCallExpressionContext *_localctx = _tracker.createInstance<DecoratorCallExpressionContext>(_ctx, getState());
  enterRule(_localctx, 116, TypeScriptParser::RuleDecoratorCallExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(749);
    decoratorMemberExpression(0);
    setState(750);
    arguments();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProgramContext ------------------------------------------------------------------

TypeScriptParser::ProgramContext::ProgramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::ProgramContext::EOF() {
  return getToken(TypeScriptParser::EOF, 0);
}

TypeScriptParser::SourceElementsContext* TypeScriptParser::ProgramContext::sourceElements() {
  return getRuleContext<TypeScriptParser::SourceElementsContext>(0);
}


size_t TypeScriptParser::ProgramContext::getRuleIndex() const {
  return TypeScriptParser::RuleProgram;
}

void TypeScriptParser::ProgramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProgram(this);
}

void TypeScriptParser::ProgramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProgram(this);
}

TypeScriptParser::ProgramContext* TypeScriptParser::program() {
  ProgramContext *_localctx = _tracker.createInstance<ProgramContext>(_ctx, getState());
  enterRule(_localctx, 118, TypeScriptParser::RuleProgram);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(753);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx)) {
    case 1: {
      setState(752);
      sourceElements();
      break;
    }

    default:
      break;
    }
    setState(755);
    match(TypeScriptParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SourceElementContext ------------------------------------------------------------------

TypeScriptParser::SourceElementContext::SourceElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::StatementContext* TypeScriptParser::SourceElementContext::statement() {
  return getRuleContext<TypeScriptParser::StatementContext>(0);
}

tree::TerminalNode* TypeScriptParser::SourceElementContext::Export() {
  return getToken(TypeScriptParser::Export, 0);
}


size_t TypeScriptParser::SourceElementContext::getRuleIndex() const {
  return TypeScriptParser::RuleSourceElement;
}

void TypeScriptParser::SourceElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSourceElement(this);
}

void TypeScriptParser::SourceElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSourceElement(this);
}

TypeScriptParser::SourceElementContext* TypeScriptParser::sourceElement() {
  SourceElementContext *_localctx = _tracker.createInstance<SourceElementContext>(_ctx, getState());
  enterRule(_localctx, 120, TypeScriptParser::RuleSourceElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(758);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx)) {
    case 1: {
      setState(757);
      match(TypeScriptParser::Export);
      break;
    }

    default:
      break;
    }
    setState(760);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

TypeScriptParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::BlockContext* TypeScriptParser::StatementContext::block() {
  return getRuleContext<TypeScriptParser::BlockContext>(0);
}

TypeScriptParser::ImportStatementContext* TypeScriptParser::StatementContext::importStatement() {
  return getRuleContext<TypeScriptParser::ImportStatementContext>(0);
}

TypeScriptParser::ExportStatementContext* TypeScriptParser::StatementContext::exportStatement() {
  return getRuleContext<TypeScriptParser::ExportStatementContext>(0);
}

TypeScriptParser::EmptyStatement_Context* TypeScriptParser::StatementContext::emptyStatement_() {
  return getRuleContext<TypeScriptParser::EmptyStatement_Context>(0);
}

TypeScriptParser::AbstractDeclarationContext* TypeScriptParser::StatementContext::abstractDeclaration() {
  return getRuleContext<TypeScriptParser::AbstractDeclarationContext>(0);
}

TypeScriptParser::ClassDeclarationContext* TypeScriptParser::StatementContext::classDeclaration() {
  return getRuleContext<TypeScriptParser::ClassDeclarationContext>(0);
}

TypeScriptParser::InterfaceDeclarationContext* TypeScriptParser::StatementContext::interfaceDeclaration() {
  return getRuleContext<TypeScriptParser::InterfaceDeclarationContext>(0);
}

TypeScriptParser::NamespaceDeclarationContext* TypeScriptParser::StatementContext::namespaceDeclaration() {
  return getRuleContext<TypeScriptParser::NamespaceDeclarationContext>(0);
}

TypeScriptParser::IfStatementContext* TypeScriptParser::StatementContext::ifStatement() {
  return getRuleContext<TypeScriptParser::IfStatementContext>(0);
}

TypeScriptParser::IterationStatementContext* TypeScriptParser::StatementContext::iterationStatement() {
  return getRuleContext<TypeScriptParser::IterationStatementContext>(0);
}

TypeScriptParser::ContinueStatementContext* TypeScriptParser::StatementContext::continueStatement() {
  return getRuleContext<TypeScriptParser::ContinueStatementContext>(0);
}

TypeScriptParser::BreakStatementContext* TypeScriptParser::StatementContext::breakStatement() {
  return getRuleContext<TypeScriptParser::BreakStatementContext>(0);
}

TypeScriptParser::ReturnStatementContext* TypeScriptParser::StatementContext::returnStatement() {
  return getRuleContext<TypeScriptParser::ReturnStatementContext>(0);
}

TypeScriptParser::YieldStatementContext* TypeScriptParser::StatementContext::yieldStatement() {
  return getRuleContext<TypeScriptParser::YieldStatementContext>(0);
}

TypeScriptParser::WithStatementContext* TypeScriptParser::StatementContext::withStatement() {
  return getRuleContext<TypeScriptParser::WithStatementContext>(0);
}

TypeScriptParser::LabelledStatementContext* TypeScriptParser::StatementContext::labelledStatement() {
  return getRuleContext<TypeScriptParser::LabelledStatementContext>(0);
}

TypeScriptParser::SwitchStatementContext* TypeScriptParser::StatementContext::switchStatement() {
  return getRuleContext<TypeScriptParser::SwitchStatementContext>(0);
}

TypeScriptParser::ThrowStatementContext* TypeScriptParser::StatementContext::throwStatement() {
  return getRuleContext<TypeScriptParser::ThrowStatementContext>(0);
}

TypeScriptParser::TryStatementContext* TypeScriptParser::StatementContext::tryStatement() {
  return getRuleContext<TypeScriptParser::TryStatementContext>(0);
}

TypeScriptParser::DebuggerStatementContext* TypeScriptParser::StatementContext::debuggerStatement() {
  return getRuleContext<TypeScriptParser::DebuggerStatementContext>(0);
}

TypeScriptParser::FunctionDeclarationContext* TypeScriptParser::StatementContext::functionDeclaration() {
  return getRuleContext<TypeScriptParser::FunctionDeclarationContext>(0);
}

TypeScriptParser::ArrowFunctionDeclarationContext* TypeScriptParser::StatementContext::arrowFunctionDeclaration() {
  return getRuleContext<TypeScriptParser::ArrowFunctionDeclarationContext>(0);
}

TypeScriptParser::GeneratorFunctionDeclarationContext* TypeScriptParser::StatementContext::generatorFunctionDeclaration() {
  return getRuleContext<TypeScriptParser::GeneratorFunctionDeclarationContext>(0);
}

TypeScriptParser::VariableStatementContext* TypeScriptParser::StatementContext::variableStatement() {
  return getRuleContext<TypeScriptParser::VariableStatementContext>(0);
}

TypeScriptParser::TypeAliasDeclarationContext* TypeScriptParser::StatementContext::typeAliasDeclaration() {
  return getRuleContext<TypeScriptParser::TypeAliasDeclarationContext>(0);
}

TypeScriptParser::EnumDeclarationContext* TypeScriptParser::StatementContext::enumDeclaration() {
  return getRuleContext<TypeScriptParser::EnumDeclarationContext>(0);
}

TypeScriptParser::ExpressionStatementContext* TypeScriptParser::StatementContext::expressionStatement() {
  return getRuleContext<TypeScriptParser::ExpressionStatementContext>(0);
}

tree::TerminalNode* TypeScriptParser::StatementContext::Export() {
  return getToken(TypeScriptParser::Export, 0);
}

TypeScriptParser::StatementContext* TypeScriptParser::StatementContext::statement() {
  return getRuleContext<TypeScriptParser::StatementContext>(0);
}


size_t TypeScriptParser::StatementContext::getRuleIndex() const {
  return TypeScriptParser::RuleStatement;
}

void TypeScriptParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void TypeScriptParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}

TypeScriptParser::StatementContext* TypeScriptParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 122, TypeScriptParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(791);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(762);
      block();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(763);
      importStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(764);
      exportStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(765);
      emptyStatement_();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(766);
      abstractDeclaration();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(767);
      classDeclaration();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(768);
      interfaceDeclaration();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(769);
      namespaceDeclaration();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(770);
      ifStatement();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(771);
      iterationStatement();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(772);
      continueStatement();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(773);
      breakStatement();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(774);
      returnStatement();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(775);
      yieldStatement();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(776);
      withStatement();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(777);
      labelledStatement();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(778);
      switchStatement();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(779);
      throwStatement();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(780);
      tryStatement();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(781);
      debuggerStatement();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(782);
      functionDeclaration();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(783);
      arrowFunctionDeclaration();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(784);
      generatorFunctionDeclaration();
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(785);
      variableStatement();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(786);
      typeAliasDeclaration();
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(787);
      enumDeclaration();
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(788);
      expressionStatement();
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(789);
      match(TypeScriptParser::Export);
      setState(790);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContext ------------------------------------------------------------------

TypeScriptParser::BlockContext::BlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::BlockContext::OpenBrace() {
  return getToken(TypeScriptParser::OpenBrace, 0);
}

tree::TerminalNode* TypeScriptParser::BlockContext::CloseBrace() {
  return getToken(TypeScriptParser::CloseBrace, 0);
}

TypeScriptParser::StatementListContext* TypeScriptParser::BlockContext::statementList() {
  return getRuleContext<TypeScriptParser::StatementListContext>(0);
}


size_t TypeScriptParser::BlockContext::getRuleIndex() const {
  return TypeScriptParser::RuleBlock;
}

void TypeScriptParser::BlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock(this);
}

void TypeScriptParser::BlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock(this);
}

TypeScriptParser::BlockContext* TypeScriptParser::block() {
  BlockContext *_localctx = _tracker.createInstance<BlockContext>(_ctx, getState());
  enterRule(_localctx, 124, TypeScriptParser::RuleBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(793);
    match(TypeScriptParser::OpenBrace);
    setState(795);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx)) {
    case 1: {
      setState(794);
      statementList();
      break;
    }

    default:
      break;
    }
    setState(797);
    match(TypeScriptParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementListContext ------------------------------------------------------------------

TypeScriptParser::StatementListContext::StatementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TypeScriptParser::StatementContext *> TypeScriptParser::StatementListContext::statement() {
  return getRuleContexts<TypeScriptParser::StatementContext>();
}

TypeScriptParser::StatementContext* TypeScriptParser::StatementListContext::statement(size_t i) {
  return getRuleContext<TypeScriptParser::StatementContext>(i);
}


size_t TypeScriptParser::StatementListContext::getRuleIndex() const {
  return TypeScriptParser::RuleStatementList;
}

void TypeScriptParser::StatementListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatementList(this);
}

void TypeScriptParser::StatementListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatementList(this);
}

TypeScriptParser::StatementListContext* TypeScriptParser::statementList() {
  StatementListContext *_localctx = _tracker.createInstance<StatementListContext>(_ctx, getState());
  enterRule(_localctx, 126, TypeScriptParser::RuleStatementList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(800); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(799);
              statement();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(802); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AbstractDeclarationContext ------------------------------------------------------------------

TypeScriptParser::AbstractDeclarationContext::AbstractDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::AbstractDeclarationContext::Abstract() {
  return getToken(TypeScriptParser::Abstract, 0);
}

TypeScriptParser::EosContext* TypeScriptParser::AbstractDeclarationContext::eos() {
  return getRuleContext<TypeScriptParser::EosContext>(0);
}

tree::TerminalNode* TypeScriptParser::AbstractDeclarationContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

TypeScriptParser::CallSignatureContext* TypeScriptParser::AbstractDeclarationContext::callSignature() {
  return getRuleContext<TypeScriptParser::CallSignatureContext>(0);
}

TypeScriptParser::VariableStatementContext* TypeScriptParser::AbstractDeclarationContext::variableStatement() {
  return getRuleContext<TypeScriptParser::VariableStatementContext>(0);
}


size_t TypeScriptParser::AbstractDeclarationContext::getRuleIndex() const {
  return TypeScriptParser::RuleAbstractDeclaration;
}

void TypeScriptParser::AbstractDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAbstractDeclaration(this);
}

void TypeScriptParser::AbstractDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAbstractDeclaration(this);
}

TypeScriptParser::AbstractDeclarationContext* TypeScriptParser::abstractDeclaration() {
  AbstractDeclarationContext *_localctx = _tracker.createInstance<AbstractDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 128, TypeScriptParser::RuleAbstractDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(804);
    match(TypeScriptParser::Abstract);
    setState(808);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx)) {
    case 1: {
      setState(805);
      match(TypeScriptParser::Identifier);
      setState(806);
      callSignature();
      break;
    }

    case 2: {
      setState(807);
      variableStatement();
      break;
    }

    default:
      break;
    }
    setState(810);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportStatementContext ------------------------------------------------------------------

TypeScriptParser::ImportStatementContext::ImportStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::ImportStatementContext::Import() {
  return getToken(TypeScriptParser::Import, 0);
}

TypeScriptParser::FromBlockContext* TypeScriptParser::ImportStatementContext::fromBlock() {
  return getRuleContext<TypeScriptParser::FromBlockContext>(0);
}

TypeScriptParser::ImportAliasDeclarationContext* TypeScriptParser::ImportStatementContext::importAliasDeclaration() {
  return getRuleContext<TypeScriptParser::ImportAliasDeclarationContext>(0);
}


size_t TypeScriptParser::ImportStatementContext::getRuleIndex() const {
  return TypeScriptParser::RuleImportStatement;
}

void TypeScriptParser::ImportStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportStatement(this);
}

void TypeScriptParser::ImportStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportStatement(this);
}

TypeScriptParser::ImportStatementContext* TypeScriptParser::importStatement() {
  ImportStatementContext *_localctx = _tracker.createInstance<ImportStatementContext>(_ctx, getState());
  enterRule(_localctx, 130, TypeScriptParser::RuleImportStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(812);
    match(TypeScriptParser::Import);
    setState(815);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx)) {
    case 1: {
      setState(813);
      fromBlock();
      break;
    }

    case 2: {
      setState(814);
      importAliasDeclaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromBlockContext ------------------------------------------------------------------

TypeScriptParser::FromBlockContext::FromBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::FromBlockContext::From() {
  return getToken(TypeScriptParser::From, 0);
}

tree::TerminalNode* TypeScriptParser::FromBlockContext::StringLiteral() {
  return getToken(TypeScriptParser::StringLiteral, 0);
}

TypeScriptParser::EosContext* TypeScriptParser::FromBlockContext::eos() {
  return getRuleContext<TypeScriptParser::EosContext>(0);
}

tree::TerminalNode* TypeScriptParser::FromBlockContext::Multiply() {
  return getToken(TypeScriptParser::Multiply, 0);
}

TypeScriptParser::MultipleImportStatementContext* TypeScriptParser::FromBlockContext::multipleImportStatement() {
  return getRuleContext<TypeScriptParser::MultipleImportStatementContext>(0);
}

tree::TerminalNode* TypeScriptParser::FromBlockContext::As() {
  return getToken(TypeScriptParser::As, 0);
}

TypeScriptParser::IdentifierNameContext* TypeScriptParser::FromBlockContext::identifierName() {
  return getRuleContext<TypeScriptParser::IdentifierNameContext>(0);
}


size_t TypeScriptParser::FromBlockContext::getRuleIndex() const {
  return TypeScriptParser::RuleFromBlock;
}

void TypeScriptParser::FromBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromBlock(this);
}

void TypeScriptParser::FromBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromBlock(this);
}

TypeScriptParser::FromBlockContext* TypeScriptParser::fromBlock() {
  FromBlockContext *_localctx = _tracker.createInstance<FromBlockContext>(_ctx, getState());
  enterRule(_localctx, 132, TypeScriptParser::RuleFromBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(819);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TypeScriptParser::Multiply: {
        setState(817);
        match(TypeScriptParser::Multiply);
        break;
      }

      case TypeScriptParser::OpenBrace:
      case TypeScriptParser::NullLiteral:
      case TypeScriptParser::BooleanLiteral:
      case TypeScriptParser::Break:
      case TypeScriptParser::Do:
      case TypeScriptParser::Instanceof:
      case TypeScriptParser::Typeof:
      case TypeScriptParser::Case:
      case TypeScriptParser::Else:
      case TypeScriptParser::New:
      case TypeScriptParser::Var:
      case TypeScriptParser::Catch:
      case TypeScriptParser::Finally:
      case TypeScriptParser::Return:
      case TypeScriptParser::Void:
      case TypeScriptParser::Continue:
      case TypeScriptParser::For:
      case TypeScriptParser::Switch:
      case TypeScriptParser::While:
      case TypeScriptParser::Debugger:
      case TypeScriptParser::Function_:
      case TypeScriptParser::This:
      case TypeScriptParser::With:
      case TypeScriptParser::Default:
      case TypeScriptParser::If:
      case TypeScriptParser::Throw:
      case TypeScriptParser::Delete:
      case TypeScriptParser::In:
      case TypeScriptParser::Try:
      case TypeScriptParser::From:
      case TypeScriptParser::ReadOnly:
      case TypeScriptParser::Async:
      case TypeScriptParser::Class:
      case TypeScriptParser::Enum:
      case TypeScriptParser::Extends:
      case TypeScriptParser::Super:
      case TypeScriptParser::Const:
      case TypeScriptParser::Export:
      case TypeScriptParser::Import:
      case TypeScriptParser::Implements:
      case TypeScriptParser::Let:
      case TypeScriptParser::Private:
      case TypeScriptParser::Public:
      case TypeScriptParser::Interface:
      case TypeScriptParser::Package:
      case TypeScriptParser::Protected:
      case TypeScriptParser::Static:
      case TypeScriptParser::Yield:
      case TypeScriptParser::Number:
      case TypeScriptParser::Boolean:
      case TypeScriptParser::String:
      case TypeScriptParser::TypeAlias:
      case TypeScriptParser::Get:
      case TypeScriptParser::Set:
      case TypeScriptParser::Require:
      case TypeScriptParser::Module:
      case TypeScriptParser::Identifier: {
        setState(818);
        multipleImportStatement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(823);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::As) {
      setState(821);
      match(TypeScriptParser::As);
      setState(822);
      identifierName();
    }
    setState(825);
    match(TypeScriptParser::From);
    setState(826);
    match(TypeScriptParser::StringLiteral);
    setState(827);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultipleImportStatementContext ------------------------------------------------------------------

TypeScriptParser::MultipleImportStatementContext::MultipleImportStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::MultipleImportStatementContext::OpenBrace() {
  return getToken(TypeScriptParser::OpenBrace, 0);
}

std::vector<TypeScriptParser::IdentifierNameContext *> TypeScriptParser::MultipleImportStatementContext::identifierName() {
  return getRuleContexts<TypeScriptParser::IdentifierNameContext>();
}

TypeScriptParser::IdentifierNameContext* TypeScriptParser::MultipleImportStatementContext::identifierName(size_t i) {
  return getRuleContext<TypeScriptParser::IdentifierNameContext>(i);
}

tree::TerminalNode* TypeScriptParser::MultipleImportStatementContext::CloseBrace() {
  return getToken(TypeScriptParser::CloseBrace, 0);
}

std::vector<tree::TerminalNode *> TypeScriptParser::MultipleImportStatementContext::Comma() {
  return getTokens(TypeScriptParser::Comma);
}

tree::TerminalNode* TypeScriptParser::MultipleImportStatementContext::Comma(size_t i) {
  return getToken(TypeScriptParser::Comma, i);
}


size_t TypeScriptParser::MultipleImportStatementContext::getRuleIndex() const {
  return TypeScriptParser::RuleMultipleImportStatement;
}

void TypeScriptParser::MultipleImportStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultipleImportStatement(this);
}

void TypeScriptParser::MultipleImportStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultipleImportStatement(this);
}

TypeScriptParser::MultipleImportStatementContext* TypeScriptParser::multipleImportStatement() {
  MultipleImportStatementContext *_localctx = _tracker.createInstance<MultipleImportStatementContext>(_ctx, getState());
  enterRule(_localctx, 134, TypeScriptParser::RuleMultipleImportStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(832);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4503599627370496000) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1211169232583131135) != 0)) {
      setState(829);
      identifierName();
      setState(830);
      match(TypeScriptParser::Comma);
    }
    setState(834);
    match(TypeScriptParser::OpenBrace);
    setState(835);
    identifierName();
    setState(840);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TypeScriptParser::Comma) {
      setState(836);
      match(TypeScriptParser::Comma);
      setState(837);
      identifierName();
      setState(842);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(843);
    match(TypeScriptParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExportStatementContext ------------------------------------------------------------------

TypeScriptParser::ExportStatementContext::ExportStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::ExportStatementContext::Export() {
  return getToken(TypeScriptParser::Export, 0);
}

TypeScriptParser::FromBlockContext* TypeScriptParser::ExportStatementContext::fromBlock() {
  return getRuleContext<TypeScriptParser::FromBlockContext>(0);
}

TypeScriptParser::StatementContext* TypeScriptParser::ExportStatementContext::statement() {
  return getRuleContext<TypeScriptParser::StatementContext>(0);
}

tree::TerminalNode* TypeScriptParser::ExportStatementContext::Default() {
  return getToken(TypeScriptParser::Default, 0);
}


size_t TypeScriptParser::ExportStatementContext::getRuleIndex() const {
  return TypeScriptParser::RuleExportStatement;
}

void TypeScriptParser::ExportStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExportStatement(this);
}

void TypeScriptParser::ExportStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExportStatement(this);
}

TypeScriptParser::ExportStatementContext* TypeScriptParser::exportStatement() {
  ExportStatementContext *_localctx = _tracker.createInstance<ExportStatementContext>(_ctx, getState());
  enterRule(_localctx, 136, TypeScriptParser::RuleExportStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(845);
    match(TypeScriptParser::Export);
    setState(847);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx)) {
    case 1: {
      setState(846);
      match(TypeScriptParser::Default);
      break;
    }

    default:
      break;
    }
    setState(851);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx)) {
    case 1: {
      setState(849);
      fromBlock();
      break;
    }

    case 2: {
      setState(850);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableStatementContext ------------------------------------------------------------------

TypeScriptParser::VariableStatementContext::VariableStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::BindingPatternContext* TypeScriptParser::VariableStatementContext::bindingPattern() {
  return getRuleContext<TypeScriptParser::BindingPatternContext>(0);
}

TypeScriptParser::InitializerContext* TypeScriptParser::VariableStatementContext::initializer() {
  return getRuleContext<TypeScriptParser::InitializerContext>(0);
}

TypeScriptParser::TypeAnnotationContext* TypeScriptParser::VariableStatementContext::typeAnnotation() {
  return getRuleContext<TypeScriptParser::TypeAnnotationContext>(0);
}

tree::TerminalNode* TypeScriptParser::VariableStatementContext::SemiColon() {
  return getToken(TypeScriptParser::SemiColon, 0);
}

TypeScriptParser::VariableDeclarationListContext* TypeScriptParser::VariableStatementContext::variableDeclarationList() {
  return getRuleContext<TypeScriptParser::VariableDeclarationListContext>(0);
}

TypeScriptParser::AccessibilityModifierContext* TypeScriptParser::VariableStatementContext::accessibilityModifier() {
  return getRuleContext<TypeScriptParser::AccessibilityModifierContext>(0);
}

TypeScriptParser::VarModifierContext* TypeScriptParser::VariableStatementContext::varModifier() {
  return getRuleContext<TypeScriptParser::VarModifierContext>(0);
}

tree::TerminalNode* TypeScriptParser::VariableStatementContext::ReadOnly() {
  return getToken(TypeScriptParser::ReadOnly, 0);
}

tree::TerminalNode* TypeScriptParser::VariableStatementContext::Declare() {
  return getToken(TypeScriptParser::Declare, 0);
}


size_t TypeScriptParser::VariableStatementContext::getRuleIndex() const {
  return TypeScriptParser::RuleVariableStatement;
}

void TypeScriptParser::VariableStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableStatement(this);
}

void TypeScriptParser::VariableStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableStatement(this);
}

TypeScriptParser::VariableStatementContext* TypeScriptParser::variableStatement() {
  VariableStatementContext *_localctx = _tracker.createInstance<VariableStatementContext>(_ctx, getState());
  enterRule(_localctx, 138, TypeScriptParser::RuleVariableStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(882);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(853);
      bindingPattern();
      setState(855);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TypeScriptParser::Colon) {
        setState(854);
        typeAnnotation();
      }
      setState(857);
      initializer();
      setState(859);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx)) {
      case 1: {
        setState(858);
        match(TypeScriptParser::SemiColon);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(862);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 101) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 101)) & 19) != 0)) {
        setState(861);
        accessibilityModifier();
      }
      setState(865);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 69) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 69)) & 2281701377) != 0)) {
        setState(864);
        varModifier();
      }
      setState(868);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TypeScriptParser::ReadOnly) {
        setState(867);
        match(TypeScriptParser::ReadOnly);
      }
      setState(870);
      variableDeclarationList();
      setState(872);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx)) {
      case 1: {
        setState(871);
        match(TypeScriptParser::SemiColon);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(874);
      match(TypeScriptParser::Declare);
      setState(876);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 69) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 69)) & 2281701377) != 0)) {
        setState(875);
        varModifier();
      }
      setState(878);
      variableDeclarationList();
      setState(880);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 96, _ctx)) {
      case 1: {
        setState(879);
        match(TypeScriptParser::SemiColon);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationListContext ------------------------------------------------------------------

TypeScriptParser::VariableDeclarationListContext::VariableDeclarationListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TypeScriptParser::VariableDeclarationContext *> TypeScriptParser::VariableDeclarationListContext::variableDeclaration() {
  return getRuleContexts<TypeScriptParser::VariableDeclarationContext>();
}

TypeScriptParser::VariableDeclarationContext* TypeScriptParser::VariableDeclarationListContext::variableDeclaration(size_t i) {
  return getRuleContext<TypeScriptParser::VariableDeclarationContext>(i);
}

std::vector<tree::TerminalNode *> TypeScriptParser::VariableDeclarationListContext::Comma() {
  return getTokens(TypeScriptParser::Comma);
}

tree::TerminalNode* TypeScriptParser::VariableDeclarationListContext::Comma(size_t i) {
  return getToken(TypeScriptParser::Comma, i);
}


size_t TypeScriptParser::VariableDeclarationListContext::getRuleIndex() const {
  return TypeScriptParser::RuleVariableDeclarationList;
}

void TypeScriptParser::VariableDeclarationListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclarationList(this);
}

void TypeScriptParser::VariableDeclarationListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclarationList(this);
}

TypeScriptParser::VariableDeclarationListContext* TypeScriptParser::variableDeclarationList() {
  VariableDeclarationListContext *_localctx = _tracker.createInstance<VariableDeclarationListContext>(_ctx, getState());
  enterRule(_localctx, 140, TypeScriptParser::RuleVariableDeclarationList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(884);
    variableDeclaration();
    setState(889);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(885);
        match(TypeScriptParser::Comma);
        setState(886);
        variableDeclaration(); 
      }
      setState(891);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationContext ------------------------------------------------------------------

TypeScriptParser::VariableDeclarationContext::VariableDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::IdentifierOrKeyWordContext* TypeScriptParser::VariableDeclarationContext::identifierOrKeyWord() {
  return getRuleContext<TypeScriptParser::IdentifierOrKeyWordContext>(0);
}

TypeScriptParser::ArrayLiteralContext* TypeScriptParser::VariableDeclarationContext::arrayLiteral() {
  return getRuleContext<TypeScriptParser::ArrayLiteralContext>(0);
}

TypeScriptParser::ObjectLiteralContext* TypeScriptParser::VariableDeclarationContext::objectLiteral() {
  return getRuleContext<TypeScriptParser::ObjectLiteralContext>(0);
}

TypeScriptParser::TypeAnnotationContext* TypeScriptParser::VariableDeclarationContext::typeAnnotation() {
  return getRuleContext<TypeScriptParser::TypeAnnotationContext>(0);
}

std::vector<TypeScriptParser::SingleExpressionContext *> TypeScriptParser::VariableDeclarationContext::singleExpression() {
  return getRuleContexts<TypeScriptParser::SingleExpressionContext>();
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::VariableDeclarationContext::singleExpression(size_t i) {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(i);
}

tree::TerminalNode* TypeScriptParser::VariableDeclarationContext::Assign() {
  return getToken(TypeScriptParser::Assign, 0);
}

TypeScriptParser::TypeParametersContext* TypeScriptParser::VariableDeclarationContext::typeParameters() {
  return getRuleContext<TypeScriptParser::TypeParametersContext>(0);
}


size_t TypeScriptParser::VariableDeclarationContext::getRuleIndex() const {
  return TypeScriptParser::RuleVariableDeclaration;
}

void TypeScriptParser::VariableDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclaration(this);
}

void TypeScriptParser::VariableDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclaration(this);
}

TypeScriptParser::VariableDeclarationContext* TypeScriptParser::variableDeclaration() {
  VariableDeclarationContext *_localctx = _tracker.createInstance<VariableDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 142, TypeScriptParser::RuleVariableDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(895);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TypeScriptParser::TypeAlias:
      case TypeScriptParser::Require:
      case TypeScriptParser::Identifier: {
        setState(892);
        identifierOrKeyWord();
        break;
      }

      case TypeScriptParser::OpenBracket: {
        setState(893);
        arrayLiteral();
        break;
      }

      case TypeScriptParser::OpenBrace: {
        setState(894);
        objectLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(898);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx)) {
    case 1: {
      setState(897);
      typeAnnotation();
      break;
    }

    default:
      break;
    }
    setState(901);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx)) {
    case 1: {
      setState(900);
      singleExpression(0);
      break;
    }

    default:
      break;
    }
    setState(908);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, _ctx)) {
    case 1: {
      setState(903);
      match(TypeScriptParser::Assign);
      setState(905);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx)) {
      case 1: {
        setState(904);
        typeParameters();
        break;
      }

      default:
        break;
      }
      setState(907);
      singleExpression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmptyStatement_Context ------------------------------------------------------------------

TypeScriptParser::EmptyStatement_Context::EmptyStatement_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::EmptyStatement_Context::SemiColon() {
  return getToken(TypeScriptParser::SemiColon, 0);
}


size_t TypeScriptParser::EmptyStatement_Context::getRuleIndex() const {
  return TypeScriptParser::RuleEmptyStatement_;
}

void TypeScriptParser::EmptyStatement_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmptyStatement_(this);
}

void TypeScriptParser::EmptyStatement_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmptyStatement_(this);
}

TypeScriptParser::EmptyStatement_Context* TypeScriptParser::emptyStatement_() {
  EmptyStatement_Context *_localctx = _tracker.createInstance<EmptyStatement_Context>(_ctx, getState());
  enterRule(_localctx, 144, TypeScriptParser::RuleEmptyStatement_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(910);
    match(TypeScriptParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionStatementContext ------------------------------------------------------------------

TypeScriptParser::ExpressionStatementContext::ExpressionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::ExpressionSequenceContext* TypeScriptParser::ExpressionStatementContext::expressionSequence() {
  return getRuleContext<TypeScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* TypeScriptParser::ExpressionStatementContext::SemiColon() {
  return getToken(TypeScriptParser::SemiColon, 0);
}


size_t TypeScriptParser::ExpressionStatementContext::getRuleIndex() const {
  return TypeScriptParser::RuleExpressionStatement;
}

void TypeScriptParser::ExpressionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionStatement(this);
}

void TypeScriptParser::ExpressionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionStatement(this);
}

TypeScriptParser::ExpressionStatementContext* TypeScriptParser::expressionStatement() {
  ExpressionStatementContext *_localctx = _tracker.createInstance<ExpressionStatementContext>(_ctx, getState());
  enterRule(_localctx, 146, TypeScriptParser::RuleExpressionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(912);

    if (!(this->notOpenBraceAndNotFunction())) throw FailedPredicateException(this, "this->notOpenBraceAndNotFunction()");
    setState(913);
    expressionSequence();
    setState(915);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 104, _ctx)) {
    case 1: {
      setState(914);
      match(TypeScriptParser::SemiColon);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStatementContext ------------------------------------------------------------------

TypeScriptParser::IfStatementContext::IfStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::IfStatementContext::If() {
  return getToken(TypeScriptParser::If, 0);
}

tree::TerminalNode* TypeScriptParser::IfStatementContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

TypeScriptParser::ExpressionSequenceContext* TypeScriptParser::IfStatementContext::expressionSequence() {
  return getRuleContext<TypeScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* TypeScriptParser::IfStatementContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

std::vector<TypeScriptParser::StatementContext *> TypeScriptParser::IfStatementContext::statement() {
  return getRuleContexts<TypeScriptParser::StatementContext>();
}

TypeScriptParser::StatementContext* TypeScriptParser::IfStatementContext::statement(size_t i) {
  return getRuleContext<TypeScriptParser::StatementContext>(i);
}

tree::TerminalNode* TypeScriptParser::IfStatementContext::Else() {
  return getToken(TypeScriptParser::Else, 0);
}


size_t TypeScriptParser::IfStatementContext::getRuleIndex() const {
  return TypeScriptParser::RuleIfStatement;
}

void TypeScriptParser::IfStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfStatement(this);
}

void TypeScriptParser::IfStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfStatement(this);
}

TypeScriptParser::IfStatementContext* TypeScriptParser::ifStatement() {
  IfStatementContext *_localctx = _tracker.createInstance<IfStatementContext>(_ctx, getState());
  enterRule(_localctx, 148, TypeScriptParser::RuleIfStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(917);
    match(TypeScriptParser::If);
    setState(918);
    match(TypeScriptParser::OpenParen);
    setState(919);
    expressionSequence();
    setState(920);
    match(TypeScriptParser::CloseParen);
    setState(921);
    statement();
    setState(924);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 105, _ctx)) {
    case 1: {
      setState(922);
      match(TypeScriptParser::Else);
      setState(923);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IterationStatementContext ------------------------------------------------------------------

TypeScriptParser::IterationStatementContext::IterationStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t TypeScriptParser::IterationStatementContext::getRuleIndex() const {
  return TypeScriptParser::RuleIterationStatement;
}

void TypeScriptParser::IterationStatementContext::copyFrom(IterationStatementContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- DoStatementContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::DoStatementContext::Do() {
  return getToken(TypeScriptParser::Do, 0);
}

TypeScriptParser::StatementContext* TypeScriptParser::DoStatementContext::statement() {
  return getRuleContext<TypeScriptParser::StatementContext>(0);
}

tree::TerminalNode* TypeScriptParser::DoStatementContext::While() {
  return getToken(TypeScriptParser::While, 0);
}

tree::TerminalNode* TypeScriptParser::DoStatementContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

TypeScriptParser::ExpressionSequenceContext* TypeScriptParser::DoStatementContext::expressionSequence() {
  return getRuleContext<TypeScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* TypeScriptParser::DoStatementContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

TypeScriptParser::EosContext* TypeScriptParser::DoStatementContext::eos() {
  return getRuleContext<TypeScriptParser::EosContext>(0);
}

TypeScriptParser::DoStatementContext::DoStatementContext(IterationStatementContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::DoStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoStatement(this);
}
void TypeScriptParser::DoStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoStatement(this);
}
//----------------- ForVarStatementContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::ForVarStatementContext::For() {
  return getToken(TypeScriptParser::For, 0);
}

tree::TerminalNode* TypeScriptParser::ForVarStatementContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

TypeScriptParser::VarModifierContext* TypeScriptParser::ForVarStatementContext::varModifier() {
  return getRuleContext<TypeScriptParser::VarModifierContext>(0);
}

TypeScriptParser::VariableDeclarationListContext* TypeScriptParser::ForVarStatementContext::variableDeclarationList() {
  return getRuleContext<TypeScriptParser::VariableDeclarationListContext>(0);
}

std::vector<tree::TerminalNode *> TypeScriptParser::ForVarStatementContext::SemiColon() {
  return getTokens(TypeScriptParser::SemiColon);
}

tree::TerminalNode* TypeScriptParser::ForVarStatementContext::SemiColon(size_t i) {
  return getToken(TypeScriptParser::SemiColon, i);
}

tree::TerminalNode* TypeScriptParser::ForVarStatementContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

TypeScriptParser::StatementContext* TypeScriptParser::ForVarStatementContext::statement() {
  return getRuleContext<TypeScriptParser::StatementContext>(0);
}

std::vector<TypeScriptParser::ExpressionSequenceContext *> TypeScriptParser::ForVarStatementContext::expressionSequence() {
  return getRuleContexts<TypeScriptParser::ExpressionSequenceContext>();
}

TypeScriptParser::ExpressionSequenceContext* TypeScriptParser::ForVarStatementContext::expressionSequence(size_t i) {
  return getRuleContext<TypeScriptParser::ExpressionSequenceContext>(i);
}

TypeScriptParser::ForVarStatementContext::ForVarStatementContext(IterationStatementContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::ForVarStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForVarStatement(this);
}
void TypeScriptParser::ForVarStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForVarStatement(this);
}
//----------------- ForVarInStatementContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::ForVarInStatementContext::For() {
  return getToken(TypeScriptParser::For, 0);
}

tree::TerminalNode* TypeScriptParser::ForVarInStatementContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

TypeScriptParser::VarModifierContext* TypeScriptParser::ForVarInStatementContext::varModifier() {
  return getRuleContext<TypeScriptParser::VarModifierContext>(0);
}

TypeScriptParser::VariableDeclarationContext* TypeScriptParser::ForVarInStatementContext::variableDeclaration() {
  return getRuleContext<TypeScriptParser::VariableDeclarationContext>(0);
}

TypeScriptParser::ExpressionSequenceContext* TypeScriptParser::ForVarInStatementContext::expressionSequence() {
  return getRuleContext<TypeScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* TypeScriptParser::ForVarInStatementContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

TypeScriptParser::StatementContext* TypeScriptParser::ForVarInStatementContext::statement() {
  return getRuleContext<TypeScriptParser::StatementContext>(0);
}

tree::TerminalNode* TypeScriptParser::ForVarInStatementContext::In() {
  return getToken(TypeScriptParser::In, 0);
}

tree::TerminalNode* TypeScriptParser::ForVarInStatementContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

TypeScriptParser::ForVarInStatementContext::ForVarInStatementContext(IterationStatementContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::ForVarInStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForVarInStatement(this);
}
void TypeScriptParser::ForVarInStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForVarInStatement(this);
}
//----------------- WhileStatementContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::WhileStatementContext::While() {
  return getToken(TypeScriptParser::While, 0);
}

tree::TerminalNode* TypeScriptParser::WhileStatementContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

TypeScriptParser::ExpressionSequenceContext* TypeScriptParser::WhileStatementContext::expressionSequence() {
  return getRuleContext<TypeScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* TypeScriptParser::WhileStatementContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

TypeScriptParser::StatementContext* TypeScriptParser::WhileStatementContext::statement() {
  return getRuleContext<TypeScriptParser::StatementContext>(0);
}

TypeScriptParser::WhileStatementContext::WhileStatementContext(IterationStatementContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::WhileStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhileStatement(this);
}
void TypeScriptParser::WhileStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhileStatement(this);
}
//----------------- ForStatementContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::ForStatementContext::For() {
  return getToken(TypeScriptParser::For, 0);
}

tree::TerminalNode* TypeScriptParser::ForStatementContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

std::vector<tree::TerminalNode *> TypeScriptParser::ForStatementContext::SemiColon() {
  return getTokens(TypeScriptParser::SemiColon);
}

tree::TerminalNode* TypeScriptParser::ForStatementContext::SemiColon(size_t i) {
  return getToken(TypeScriptParser::SemiColon, i);
}

tree::TerminalNode* TypeScriptParser::ForStatementContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

TypeScriptParser::StatementContext* TypeScriptParser::ForStatementContext::statement() {
  return getRuleContext<TypeScriptParser::StatementContext>(0);
}

std::vector<TypeScriptParser::ExpressionSequenceContext *> TypeScriptParser::ForStatementContext::expressionSequence() {
  return getRuleContexts<TypeScriptParser::ExpressionSequenceContext>();
}

TypeScriptParser::ExpressionSequenceContext* TypeScriptParser::ForStatementContext::expressionSequence(size_t i) {
  return getRuleContext<TypeScriptParser::ExpressionSequenceContext>(i);
}

TypeScriptParser::ForStatementContext::ForStatementContext(IterationStatementContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::ForStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForStatement(this);
}
void TypeScriptParser::ForStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForStatement(this);
}
//----------------- ForInStatementContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::ForInStatementContext::For() {
  return getToken(TypeScriptParser::For, 0);
}

tree::TerminalNode* TypeScriptParser::ForInStatementContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::ForInStatementContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

TypeScriptParser::ExpressionSequenceContext* TypeScriptParser::ForInStatementContext::expressionSequence() {
  return getRuleContext<TypeScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* TypeScriptParser::ForInStatementContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

TypeScriptParser::StatementContext* TypeScriptParser::ForInStatementContext::statement() {
  return getRuleContext<TypeScriptParser::StatementContext>(0);
}

tree::TerminalNode* TypeScriptParser::ForInStatementContext::In() {
  return getToken(TypeScriptParser::In, 0);
}

tree::TerminalNode* TypeScriptParser::ForInStatementContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

TypeScriptParser::ForInStatementContext::ForInStatementContext(IterationStatementContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::ForInStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForInStatement(this);
}
void TypeScriptParser::ForInStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForInStatement(this);
}
TypeScriptParser::IterationStatementContext* TypeScriptParser::iterationStatement() {
  IterationStatementContext *_localctx = _tracker.createInstance<IterationStatementContext>(_ctx, getState());
  enterRule(_localctx, 150, TypeScriptParser::RuleIterationStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(995);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<TypeScriptParser::DoStatementContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(926);
      match(TypeScriptParser::Do);
      setState(927);
      statement();
      setState(928);
      match(TypeScriptParser::While);
      setState(929);
      match(TypeScriptParser::OpenParen);
      setState(930);
      expressionSequence();
      setState(931);
      match(TypeScriptParser::CloseParen);
      setState(932);
      eos();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<TypeScriptParser::WhileStatementContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(934);
      match(TypeScriptParser::While);
      setState(935);
      match(TypeScriptParser::OpenParen);
      setState(936);
      expressionSequence();
      setState(937);
      match(TypeScriptParser::CloseParen);
      setState(938);
      statement();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<TypeScriptParser::ForStatementContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(940);
      match(TypeScriptParser::For);
      setState(941);
      match(TypeScriptParser::OpenParen);
      setState(943);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -36028795928706728) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 8128698260224212991) != 0)) {
        setState(942);
        expressionSequence();
      }
      setState(945);
      match(TypeScriptParser::SemiColon);
      setState(947);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -36028795928706728) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 8128698260224212991) != 0)) {
        setState(946);
        expressionSequence();
      }
      setState(949);
      match(TypeScriptParser::SemiColon);
      setState(951);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -36028795928706728) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 8128698260224212991) != 0)) {
        setState(950);
        expressionSequence();
      }
      setState(953);
      match(TypeScriptParser::CloseParen);
      setState(954);
      statement();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<TypeScriptParser::ForVarStatementContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(955);
      match(TypeScriptParser::For);
      setState(956);
      match(TypeScriptParser::OpenParen);
      setState(957);
      varModifier();
      setState(958);
      variableDeclarationList();
      setState(959);
      match(TypeScriptParser::SemiColon);
      setState(961);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -36028795928706728) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 8128698260224212991) != 0)) {
        setState(960);
        expressionSequence();
      }
      setState(963);
      match(TypeScriptParser::SemiColon);
      setState(965);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -36028795928706728) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 8128698260224212991) != 0)) {
        setState(964);
        expressionSequence();
      }
      setState(967);
      match(TypeScriptParser::CloseParen);
      setState(968);
      statement();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<TypeScriptParser::ForInStatementContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(970);
      match(TypeScriptParser::For);
      setState(971);
      match(TypeScriptParser::OpenParen);
      setState(972);
      singleExpression(0);
      setState(976);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TypeScriptParser::In: {
          setState(973);
          match(TypeScriptParser::In);
          break;
        }

        case TypeScriptParser::Identifier: {
          setState(974);
          match(TypeScriptParser::Identifier);
          setState(975);

          if (!(this->p("of"))) throw FailedPredicateException(this, "this->p(\"of\")");
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(978);
      expressionSequence();
      setState(979);
      match(TypeScriptParser::CloseParen);
      setState(980);
      statement();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<TypeScriptParser::ForVarInStatementContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(982);
      match(TypeScriptParser::For);
      setState(983);
      match(TypeScriptParser::OpenParen);
      setState(984);
      varModifier();
      setState(985);
      variableDeclaration();
      setState(989);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TypeScriptParser::In: {
          setState(986);
          match(TypeScriptParser::In);
          break;
        }

        case TypeScriptParser::Identifier: {
          setState(987);
          match(TypeScriptParser::Identifier);
          setState(988);

          if (!(this->p("of"))) throw FailedPredicateException(this, "this->p(\"of\")");
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(991);
      expressionSequence();
      setState(992);
      match(TypeScriptParser::CloseParen);
      setState(993);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarModifierContext ------------------------------------------------------------------

TypeScriptParser::VarModifierContext::VarModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::VarModifierContext::Var() {
  return getToken(TypeScriptParser::Var, 0);
}

tree::TerminalNode* TypeScriptParser::VarModifierContext::Let() {
  return getToken(TypeScriptParser::Let, 0);
}

tree::TerminalNode* TypeScriptParser::VarModifierContext::Const() {
  return getToken(TypeScriptParser::Const, 0);
}


size_t TypeScriptParser::VarModifierContext::getRuleIndex() const {
  return TypeScriptParser::RuleVarModifier;
}

void TypeScriptParser::VarModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarModifier(this);
}

void TypeScriptParser::VarModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarModifier(this);
}

TypeScriptParser::VarModifierContext* TypeScriptParser::varModifier() {
  VarModifierContext *_localctx = _tracker.createInstance<VarModifierContext>(_ctx, getState());
  enterRule(_localctx, 152, TypeScriptParser::RuleVarModifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(997);
    _la = _input->LA(1);
    if (!(((((_la - 69) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 69)) & 2281701377) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ContinueStatementContext ------------------------------------------------------------------

TypeScriptParser::ContinueStatementContext::ContinueStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::ContinueStatementContext::Continue() {
  return getToken(TypeScriptParser::Continue, 0);
}

TypeScriptParser::EosContext* TypeScriptParser::ContinueStatementContext::eos() {
  return getRuleContext<TypeScriptParser::EosContext>(0);
}

tree::TerminalNode* TypeScriptParser::ContinueStatementContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}


size_t TypeScriptParser::ContinueStatementContext::getRuleIndex() const {
  return TypeScriptParser::RuleContinueStatement;
}

void TypeScriptParser::ContinueStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContinueStatement(this);
}

void TypeScriptParser::ContinueStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContinueStatement(this);
}

TypeScriptParser::ContinueStatementContext* TypeScriptParser::continueStatement() {
  ContinueStatementContext *_localctx = _tracker.createInstance<ContinueStatementContext>(_ctx, getState());
  enterRule(_localctx, 154, TypeScriptParser::RuleContinueStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(999);
    match(TypeScriptParser::Continue);
    setState(1002);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx)) {
    case 1: {
      setState(1000);

      if (!(this->notLineTerminator())) throw FailedPredicateException(this, "this->notLineTerminator()");
      setState(1001);
      match(TypeScriptParser::Identifier);
      break;
    }

    default:
      break;
    }
    setState(1004);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BreakStatementContext ------------------------------------------------------------------

TypeScriptParser::BreakStatementContext::BreakStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::BreakStatementContext::Break() {
  return getToken(TypeScriptParser::Break, 0);
}

TypeScriptParser::EosContext* TypeScriptParser::BreakStatementContext::eos() {
  return getRuleContext<TypeScriptParser::EosContext>(0);
}

tree::TerminalNode* TypeScriptParser::BreakStatementContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}


size_t TypeScriptParser::BreakStatementContext::getRuleIndex() const {
  return TypeScriptParser::RuleBreakStatement;
}

void TypeScriptParser::BreakStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBreakStatement(this);
}

void TypeScriptParser::BreakStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBreakStatement(this);
}

TypeScriptParser::BreakStatementContext* TypeScriptParser::breakStatement() {
  BreakStatementContext *_localctx = _tracker.createInstance<BreakStatementContext>(_ctx, getState());
  enterRule(_localctx, 156, TypeScriptParser::RuleBreakStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1006);
    match(TypeScriptParser::Break);
    setState(1009);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx)) {
    case 1: {
      setState(1007);

      if (!(this->notLineTerminator())) throw FailedPredicateException(this, "this->notLineTerminator()");
      setState(1008);
      match(TypeScriptParser::Identifier);
      break;
    }

    default:
      break;
    }
    setState(1011);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnStatementContext ------------------------------------------------------------------

TypeScriptParser::ReturnStatementContext::ReturnStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::ReturnStatementContext::Return() {
  return getToken(TypeScriptParser::Return, 0);
}

TypeScriptParser::EosContext* TypeScriptParser::ReturnStatementContext::eos() {
  return getRuleContext<TypeScriptParser::EosContext>(0);
}

TypeScriptParser::ExpressionSequenceContext* TypeScriptParser::ReturnStatementContext::expressionSequence() {
  return getRuleContext<TypeScriptParser::ExpressionSequenceContext>(0);
}


size_t TypeScriptParser::ReturnStatementContext::getRuleIndex() const {
  return TypeScriptParser::RuleReturnStatement;
}

void TypeScriptParser::ReturnStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnStatement(this);
}

void TypeScriptParser::ReturnStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnStatement(this);
}

TypeScriptParser::ReturnStatementContext* TypeScriptParser::returnStatement() {
  ReturnStatementContext *_localctx = _tracker.createInstance<ReturnStatementContext>(_ctx, getState());
  enterRule(_localctx, 158, TypeScriptParser::RuleReturnStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1013);
    match(TypeScriptParser::Return);
    setState(1016);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx)) {
    case 1: {
      setState(1014);

      if (!(this->notLineTerminator())) throw FailedPredicateException(this, "this->notLineTerminator()");
      setState(1015);
      expressionSequence();
      break;
    }

    default:
      break;
    }
    setState(1018);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- YieldStatementContext ------------------------------------------------------------------

TypeScriptParser::YieldStatementContext::YieldStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::YieldStatementContext::Yield() {
  return getToken(TypeScriptParser::Yield, 0);
}

TypeScriptParser::EosContext* TypeScriptParser::YieldStatementContext::eos() {
  return getRuleContext<TypeScriptParser::EosContext>(0);
}

TypeScriptParser::ExpressionSequenceContext* TypeScriptParser::YieldStatementContext::expressionSequence() {
  return getRuleContext<TypeScriptParser::ExpressionSequenceContext>(0);
}


size_t TypeScriptParser::YieldStatementContext::getRuleIndex() const {
  return TypeScriptParser::RuleYieldStatement;
}

void TypeScriptParser::YieldStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterYieldStatement(this);
}

void TypeScriptParser::YieldStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitYieldStatement(this);
}

TypeScriptParser::YieldStatementContext* TypeScriptParser::yieldStatement() {
  YieldStatementContext *_localctx = _tracker.createInstance<YieldStatementContext>(_ctx, getState());
  enterRule(_localctx, 160, TypeScriptParser::RuleYieldStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1020);
    match(TypeScriptParser::Yield);
    setState(1023);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx)) {
    case 1: {
      setState(1021);

      if (!(this->notLineTerminator())) throw FailedPredicateException(this, "this->notLineTerminator()");
      setState(1022);
      expressionSequence();
      break;
    }

    default:
      break;
    }
    setState(1025);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WithStatementContext ------------------------------------------------------------------

TypeScriptParser::WithStatementContext::WithStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::WithStatementContext::With() {
  return getToken(TypeScriptParser::With, 0);
}

tree::TerminalNode* TypeScriptParser::WithStatementContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

TypeScriptParser::ExpressionSequenceContext* TypeScriptParser::WithStatementContext::expressionSequence() {
  return getRuleContext<TypeScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* TypeScriptParser::WithStatementContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

TypeScriptParser::StatementContext* TypeScriptParser::WithStatementContext::statement() {
  return getRuleContext<TypeScriptParser::StatementContext>(0);
}


size_t TypeScriptParser::WithStatementContext::getRuleIndex() const {
  return TypeScriptParser::RuleWithStatement;
}

void TypeScriptParser::WithStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWithStatement(this);
}

void TypeScriptParser::WithStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWithStatement(this);
}

TypeScriptParser::WithStatementContext* TypeScriptParser::withStatement() {
  WithStatementContext *_localctx = _tracker.createInstance<WithStatementContext>(_ctx, getState());
  enterRule(_localctx, 162, TypeScriptParser::RuleWithStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1027);
    match(TypeScriptParser::With);
    setState(1028);
    match(TypeScriptParser::OpenParen);
    setState(1029);
    expressionSequence();
    setState(1030);
    match(TypeScriptParser::CloseParen);
    setState(1031);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SwitchStatementContext ------------------------------------------------------------------

TypeScriptParser::SwitchStatementContext::SwitchStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::SwitchStatementContext::Switch() {
  return getToken(TypeScriptParser::Switch, 0);
}

tree::TerminalNode* TypeScriptParser::SwitchStatementContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

TypeScriptParser::ExpressionSequenceContext* TypeScriptParser::SwitchStatementContext::expressionSequence() {
  return getRuleContext<TypeScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* TypeScriptParser::SwitchStatementContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

TypeScriptParser::CaseBlockContext* TypeScriptParser::SwitchStatementContext::caseBlock() {
  return getRuleContext<TypeScriptParser::CaseBlockContext>(0);
}


size_t TypeScriptParser::SwitchStatementContext::getRuleIndex() const {
  return TypeScriptParser::RuleSwitchStatement;
}

void TypeScriptParser::SwitchStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitchStatement(this);
}

void TypeScriptParser::SwitchStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitchStatement(this);
}

TypeScriptParser::SwitchStatementContext* TypeScriptParser::switchStatement() {
  SwitchStatementContext *_localctx = _tracker.createInstance<SwitchStatementContext>(_ctx, getState());
  enterRule(_localctx, 164, TypeScriptParser::RuleSwitchStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1033);
    match(TypeScriptParser::Switch);
    setState(1034);
    match(TypeScriptParser::OpenParen);
    setState(1035);
    expressionSequence();
    setState(1036);
    match(TypeScriptParser::CloseParen);
    setState(1037);
    caseBlock();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseBlockContext ------------------------------------------------------------------

TypeScriptParser::CaseBlockContext::CaseBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::CaseBlockContext::OpenBrace() {
  return getToken(TypeScriptParser::OpenBrace, 0);
}

tree::TerminalNode* TypeScriptParser::CaseBlockContext::CloseBrace() {
  return getToken(TypeScriptParser::CloseBrace, 0);
}

std::vector<TypeScriptParser::CaseClausesContext *> TypeScriptParser::CaseBlockContext::caseClauses() {
  return getRuleContexts<TypeScriptParser::CaseClausesContext>();
}

TypeScriptParser::CaseClausesContext* TypeScriptParser::CaseBlockContext::caseClauses(size_t i) {
  return getRuleContext<TypeScriptParser::CaseClausesContext>(i);
}

TypeScriptParser::DefaultClauseContext* TypeScriptParser::CaseBlockContext::defaultClause() {
  return getRuleContext<TypeScriptParser::DefaultClauseContext>(0);
}


size_t TypeScriptParser::CaseBlockContext::getRuleIndex() const {
  return TypeScriptParser::RuleCaseBlock;
}

void TypeScriptParser::CaseBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseBlock(this);
}

void TypeScriptParser::CaseBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseBlock(this);
}

TypeScriptParser::CaseBlockContext* TypeScriptParser::caseBlock() {
  CaseBlockContext *_localctx = _tracker.createInstance<CaseBlockContext>(_ctx, getState());
  enterRule(_localctx, 166, TypeScriptParser::RuleCaseBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1039);
    match(TypeScriptParser::OpenBrace);
    setState(1041);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Case) {
      setState(1040);
      caseClauses();
    }
    setState(1047);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Default) {
      setState(1043);
      defaultClause();
      setState(1045);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TypeScriptParser::Case) {
        setState(1044);
        caseClauses();
      }
    }
    setState(1049);
    match(TypeScriptParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseClausesContext ------------------------------------------------------------------

TypeScriptParser::CaseClausesContext::CaseClausesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TypeScriptParser::CaseClauseContext *> TypeScriptParser::CaseClausesContext::caseClause() {
  return getRuleContexts<TypeScriptParser::CaseClauseContext>();
}

TypeScriptParser::CaseClauseContext* TypeScriptParser::CaseClausesContext::caseClause(size_t i) {
  return getRuleContext<TypeScriptParser::CaseClauseContext>(i);
}


size_t TypeScriptParser::CaseClausesContext::getRuleIndex() const {
  return TypeScriptParser::RuleCaseClauses;
}

void TypeScriptParser::CaseClausesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseClauses(this);
}

void TypeScriptParser::CaseClausesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseClauses(this);
}

TypeScriptParser::CaseClausesContext* TypeScriptParser::caseClauses() {
  CaseClausesContext *_localctx = _tracker.createInstance<CaseClausesContext>(_ctx, getState());
  enterRule(_localctx, 168, TypeScriptParser::RuleCaseClauses);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1052); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1051);
      caseClause();
      setState(1054); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == TypeScriptParser::Case);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseClauseContext ------------------------------------------------------------------

TypeScriptParser::CaseClauseContext::CaseClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::CaseClauseContext::Case() {
  return getToken(TypeScriptParser::Case, 0);
}

TypeScriptParser::ExpressionSequenceContext* TypeScriptParser::CaseClauseContext::expressionSequence() {
  return getRuleContext<TypeScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* TypeScriptParser::CaseClauseContext::Colon() {
  return getToken(TypeScriptParser::Colon, 0);
}

TypeScriptParser::StatementListContext* TypeScriptParser::CaseClauseContext::statementList() {
  return getRuleContext<TypeScriptParser::StatementListContext>(0);
}


size_t TypeScriptParser::CaseClauseContext::getRuleIndex() const {
  return TypeScriptParser::RuleCaseClause;
}

void TypeScriptParser::CaseClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseClause(this);
}

void TypeScriptParser::CaseClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseClause(this);
}

TypeScriptParser::CaseClauseContext* TypeScriptParser::caseClause() {
  CaseClauseContext *_localctx = _tracker.createInstance<CaseClauseContext>(_ctx, getState());
  enterRule(_localctx, 170, TypeScriptParser::RuleCaseClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1056);
    match(TypeScriptParser::Case);
    setState(1057);
    expressionSequence();
    setState(1058);
    match(TypeScriptParser::Colon);
    setState(1060);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx)) {
    case 1: {
      setState(1059);
      statementList();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultClauseContext ------------------------------------------------------------------

TypeScriptParser::DefaultClauseContext::DefaultClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::DefaultClauseContext::Default() {
  return getToken(TypeScriptParser::Default, 0);
}

tree::TerminalNode* TypeScriptParser::DefaultClauseContext::Colon() {
  return getToken(TypeScriptParser::Colon, 0);
}

TypeScriptParser::StatementListContext* TypeScriptParser::DefaultClauseContext::statementList() {
  return getRuleContext<TypeScriptParser::StatementListContext>(0);
}


size_t TypeScriptParser::DefaultClauseContext::getRuleIndex() const {
  return TypeScriptParser::RuleDefaultClause;
}

void TypeScriptParser::DefaultClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultClause(this);
}

void TypeScriptParser::DefaultClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultClause(this);
}

TypeScriptParser::DefaultClauseContext* TypeScriptParser::defaultClause() {
  DefaultClauseContext *_localctx = _tracker.createInstance<DefaultClauseContext>(_ctx, getState());
  enterRule(_localctx, 172, TypeScriptParser::RuleDefaultClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1062);
    match(TypeScriptParser::Default);
    setState(1063);
    match(TypeScriptParser::Colon);
    setState(1065);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx)) {
    case 1: {
      setState(1064);
      statementList();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelledStatementContext ------------------------------------------------------------------

TypeScriptParser::LabelledStatementContext::LabelledStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::LabelledStatementContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

tree::TerminalNode* TypeScriptParser::LabelledStatementContext::Colon() {
  return getToken(TypeScriptParser::Colon, 0);
}

TypeScriptParser::StatementContext* TypeScriptParser::LabelledStatementContext::statement() {
  return getRuleContext<TypeScriptParser::StatementContext>(0);
}


size_t TypeScriptParser::LabelledStatementContext::getRuleIndex() const {
  return TypeScriptParser::RuleLabelledStatement;
}

void TypeScriptParser::LabelledStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabelledStatement(this);
}

void TypeScriptParser::LabelledStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabelledStatement(this);
}

TypeScriptParser::LabelledStatementContext* TypeScriptParser::labelledStatement() {
  LabelledStatementContext *_localctx = _tracker.createInstance<LabelledStatementContext>(_ctx, getState());
  enterRule(_localctx, 174, TypeScriptParser::RuleLabelledStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1067);
    match(TypeScriptParser::Identifier);
    setState(1068);
    match(TypeScriptParser::Colon);
    setState(1069);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThrowStatementContext ------------------------------------------------------------------

TypeScriptParser::ThrowStatementContext::ThrowStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::ThrowStatementContext::Throw() {
  return getToken(TypeScriptParser::Throw, 0);
}

TypeScriptParser::ExpressionSequenceContext* TypeScriptParser::ThrowStatementContext::expressionSequence() {
  return getRuleContext<TypeScriptParser::ExpressionSequenceContext>(0);
}

TypeScriptParser::EosContext* TypeScriptParser::ThrowStatementContext::eos() {
  return getRuleContext<TypeScriptParser::EosContext>(0);
}


size_t TypeScriptParser::ThrowStatementContext::getRuleIndex() const {
  return TypeScriptParser::RuleThrowStatement;
}

void TypeScriptParser::ThrowStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrowStatement(this);
}

void TypeScriptParser::ThrowStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrowStatement(this);
}

TypeScriptParser::ThrowStatementContext* TypeScriptParser::throwStatement() {
  ThrowStatementContext *_localctx = _tracker.createInstance<ThrowStatementContext>(_ctx, getState());
  enterRule(_localctx, 176, TypeScriptParser::RuleThrowStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1071);
    match(TypeScriptParser::Throw);
    setState(1072);

    if (!(this->notLineTerminator())) throw FailedPredicateException(this, "this->notLineTerminator()");
    setState(1073);
    expressionSequence();
    setState(1074);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TryStatementContext ------------------------------------------------------------------

TypeScriptParser::TryStatementContext::TryStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::TryStatementContext::Try() {
  return getToken(TypeScriptParser::Try, 0);
}

TypeScriptParser::BlockContext* TypeScriptParser::TryStatementContext::block() {
  return getRuleContext<TypeScriptParser::BlockContext>(0);
}

TypeScriptParser::CatchProductionContext* TypeScriptParser::TryStatementContext::catchProduction() {
  return getRuleContext<TypeScriptParser::CatchProductionContext>(0);
}

TypeScriptParser::FinallyProductionContext* TypeScriptParser::TryStatementContext::finallyProduction() {
  return getRuleContext<TypeScriptParser::FinallyProductionContext>(0);
}


size_t TypeScriptParser::TryStatementContext::getRuleIndex() const {
  return TypeScriptParser::RuleTryStatement;
}

void TypeScriptParser::TryStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTryStatement(this);
}

void TypeScriptParser::TryStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTryStatement(this);
}

TypeScriptParser::TryStatementContext* TypeScriptParser::tryStatement() {
  TryStatementContext *_localctx = _tracker.createInstance<TryStatementContext>(_ctx, getState());
  enterRule(_localctx, 178, TypeScriptParser::RuleTryStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1076);
    match(TypeScriptParser::Try);
    setState(1077);
    block();
    setState(1083);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TypeScriptParser::Catch: {
        setState(1078);
        catchProduction();
        setState(1080);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 124, _ctx)) {
        case 1: {
          setState(1079);
          finallyProduction();
          break;
        }

        default:
          break;
        }
        break;
      }

      case TypeScriptParser::Finally: {
        setState(1082);
        finallyProduction();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CatchProductionContext ------------------------------------------------------------------

TypeScriptParser::CatchProductionContext::CatchProductionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::CatchProductionContext::Catch() {
  return getToken(TypeScriptParser::Catch, 0);
}

tree::TerminalNode* TypeScriptParser::CatchProductionContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

tree::TerminalNode* TypeScriptParser::CatchProductionContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

tree::TerminalNode* TypeScriptParser::CatchProductionContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

TypeScriptParser::BlockContext* TypeScriptParser::CatchProductionContext::block() {
  return getRuleContext<TypeScriptParser::BlockContext>(0);
}


size_t TypeScriptParser::CatchProductionContext::getRuleIndex() const {
  return TypeScriptParser::RuleCatchProduction;
}

void TypeScriptParser::CatchProductionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCatchProduction(this);
}

void TypeScriptParser::CatchProductionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCatchProduction(this);
}

TypeScriptParser::CatchProductionContext* TypeScriptParser::catchProduction() {
  CatchProductionContext *_localctx = _tracker.createInstance<CatchProductionContext>(_ctx, getState());
  enterRule(_localctx, 180, TypeScriptParser::RuleCatchProduction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1085);
    match(TypeScriptParser::Catch);
    setState(1086);
    match(TypeScriptParser::OpenParen);
    setState(1087);
    match(TypeScriptParser::Identifier);
    setState(1088);
    match(TypeScriptParser::CloseParen);
    setState(1089);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FinallyProductionContext ------------------------------------------------------------------

TypeScriptParser::FinallyProductionContext::FinallyProductionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::FinallyProductionContext::Finally() {
  return getToken(TypeScriptParser::Finally, 0);
}

TypeScriptParser::BlockContext* TypeScriptParser::FinallyProductionContext::block() {
  return getRuleContext<TypeScriptParser::BlockContext>(0);
}


size_t TypeScriptParser::FinallyProductionContext::getRuleIndex() const {
  return TypeScriptParser::RuleFinallyProduction;
}

void TypeScriptParser::FinallyProductionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFinallyProduction(this);
}

void TypeScriptParser::FinallyProductionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFinallyProduction(this);
}

TypeScriptParser::FinallyProductionContext* TypeScriptParser::finallyProduction() {
  FinallyProductionContext *_localctx = _tracker.createInstance<FinallyProductionContext>(_ctx, getState());
  enterRule(_localctx, 182, TypeScriptParser::RuleFinallyProduction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1091);
    match(TypeScriptParser::Finally);
    setState(1092);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DebuggerStatementContext ------------------------------------------------------------------

TypeScriptParser::DebuggerStatementContext::DebuggerStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::DebuggerStatementContext::Debugger() {
  return getToken(TypeScriptParser::Debugger, 0);
}

TypeScriptParser::EosContext* TypeScriptParser::DebuggerStatementContext::eos() {
  return getRuleContext<TypeScriptParser::EosContext>(0);
}


size_t TypeScriptParser::DebuggerStatementContext::getRuleIndex() const {
  return TypeScriptParser::RuleDebuggerStatement;
}

void TypeScriptParser::DebuggerStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDebuggerStatement(this);
}

void TypeScriptParser::DebuggerStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDebuggerStatement(this);
}

TypeScriptParser::DebuggerStatementContext* TypeScriptParser::debuggerStatement() {
  DebuggerStatementContext *_localctx = _tracker.createInstance<DebuggerStatementContext>(_ctx, getState());
  enterRule(_localctx, 184, TypeScriptParser::RuleDebuggerStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1094);
    match(TypeScriptParser::Debugger);
    setState(1095);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDeclarationContext ------------------------------------------------------------------

TypeScriptParser::FunctionDeclarationContext::FunctionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::FunctionDeclarationContext::Function_() {
  return getToken(TypeScriptParser::Function_, 0);
}

tree::TerminalNode* TypeScriptParser::FunctionDeclarationContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

TypeScriptParser::CallSignatureContext* TypeScriptParser::FunctionDeclarationContext::callSignature() {
  return getRuleContext<TypeScriptParser::CallSignatureContext>(0);
}

tree::TerminalNode* TypeScriptParser::FunctionDeclarationContext::SemiColon() {
  return getToken(TypeScriptParser::SemiColon, 0);
}

tree::TerminalNode* TypeScriptParser::FunctionDeclarationContext::OpenBrace() {
  return getToken(TypeScriptParser::OpenBrace, 0);
}

TypeScriptParser::FunctionBodyContext* TypeScriptParser::FunctionDeclarationContext::functionBody() {
  return getRuleContext<TypeScriptParser::FunctionBodyContext>(0);
}

tree::TerminalNode* TypeScriptParser::FunctionDeclarationContext::CloseBrace() {
  return getToken(TypeScriptParser::CloseBrace, 0);
}


size_t TypeScriptParser::FunctionDeclarationContext::getRuleIndex() const {
  return TypeScriptParser::RuleFunctionDeclaration;
}

void TypeScriptParser::FunctionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionDeclaration(this);
}

void TypeScriptParser::FunctionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionDeclaration(this);
}

TypeScriptParser::FunctionDeclarationContext* TypeScriptParser::functionDeclaration() {
  FunctionDeclarationContext *_localctx = _tracker.createInstance<FunctionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 186, TypeScriptParser::RuleFunctionDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1097);
    match(TypeScriptParser::Function_);
    setState(1098);
    match(TypeScriptParser::Identifier);
    setState(1099);
    callSignature();
    setState(1105);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TypeScriptParser::OpenBrace: {
        setState(1100);
        match(TypeScriptParser::OpenBrace);
        setState(1101);
        functionBody();
        setState(1102);
        match(TypeScriptParser::CloseBrace);
        break;
      }

      case TypeScriptParser::SemiColon: {
        setState(1104);
        match(TypeScriptParser::SemiColon);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassDeclarationContext ------------------------------------------------------------------

TypeScriptParser::ClassDeclarationContext::ClassDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::ClassDeclarationContext::Class() {
  return getToken(TypeScriptParser::Class, 0);
}

tree::TerminalNode* TypeScriptParser::ClassDeclarationContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

TypeScriptParser::ClassHeritageContext* TypeScriptParser::ClassDeclarationContext::classHeritage() {
  return getRuleContext<TypeScriptParser::ClassHeritageContext>(0);
}

TypeScriptParser::ClassTailContext* TypeScriptParser::ClassDeclarationContext::classTail() {
  return getRuleContext<TypeScriptParser::ClassTailContext>(0);
}

TypeScriptParser::DecoratorListContext* TypeScriptParser::ClassDeclarationContext::decoratorList() {
  return getRuleContext<TypeScriptParser::DecoratorListContext>(0);
}

tree::TerminalNode* TypeScriptParser::ClassDeclarationContext::Export() {
  return getToken(TypeScriptParser::Export, 0);
}

tree::TerminalNode* TypeScriptParser::ClassDeclarationContext::Abstract() {
  return getToken(TypeScriptParser::Abstract, 0);
}

TypeScriptParser::TypeParametersContext* TypeScriptParser::ClassDeclarationContext::typeParameters() {
  return getRuleContext<TypeScriptParser::TypeParametersContext>(0);
}

tree::TerminalNode* TypeScriptParser::ClassDeclarationContext::Default() {
  return getToken(TypeScriptParser::Default, 0);
}


size_t TypeScriptParser::ClassDeclarationContext::getRuleIndex() const {
  return TypeScriptParser::RuleClassDeclaration;
}

void TypeScriptParser::ClassDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassDeclaration(this);
}

void TypeScriptParser::ClassDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassDeclaration(this);
}

TypeScriptParser::ClassDeclarationContext* TypeScriptParser::classDeclaration() {
  ClassDeclarationContext *_localctx = _tracker.createInstance<ClassDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 188, TypeScriptParser::RuleClassDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1108);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::At) {
      setState(1107);
      decoratorList();
    }
    setState(1114);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Export) {
      setState(1110);
      match(TypeScriptParser::Export);
      setState(1112);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TypeScriptParser::Default) {
        setState(1111);
        match(TypeScriptParser::Default);
      }
    }
    setState(1117);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Abstract) {
      setState(1116);
      match(TypeScriptParser::Abstract);
    }
    setState(1119);
    match(TypeScriptParser::Class);
    setState(1120);
    match(TypeScriptParser::Identifier);
    setState(1122);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::LessThan) {
      setState(1121);
      typeParameters();
    }
    setState(1124);
    classHeritage();
    setState(1125);
    classTail();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassHeritageContext ------------------------------------------------------------------

TypeScriptParser::ClassHeritageContext::ClassHeritageContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::ClassExtendsClauseContext* TypeScriptParser::ClassHeritageContext::classExtendsClause() {
  return getRuleContext<TypeScriptParser::ClassExtendsClauseContext>(0);
}

TypeScriptParser::ImplementsClauseContext* TypeScriptParser::ClassHeritageContext::implementsClause() {
  return getRuleContext<TypeScriptParser::ImplementsClauseContext>(0);
}


size_t TypeScriptParser::ClassHeritageContext::getRuleIndex() const {
  return TypeScriptParser::RuleClassHeritage;
}

void TypeScriptParser::ClassHeritageContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassHeritage(this);
}

void TypeScriptParser::ClassHeritageContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassHeritage(this);
}

TypeScriptParser::ClassHeritageContext* TypeScriptParser::classHeritage() {
  ClassHeritageContext *_localctx = _tracker.createInstance<ClassHeritageContext>(_ctx, getState());
  enterRule(_localctx, 190, TypeScriptParser::RuleClassHeritage);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1128);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Extends) {
      setState(1127);
      classExtendsClause();
    }
    setState(1131);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Implements) {
      setState(1130);
      implementsClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassTailContext ------------------------------------------------------------------

TypeScriptParser::ClassTailContext::ClassTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::ClassTailContext::OpenBrace() {
  return getToken(TypeScriptParser::OpenBrace, 0);
}

tree::TerminalNode* TypeScriptParser::ClassTailContext::CloseBrace() {
  return getToken(TypeScriptParser::CloseBrace, 0);
}

std::vector<TypeScriptParser::ClassElementContext *> TypeScriptParser::ClassTailContext::classElement() {
  return getRuleContexts<TypeScriptParser::ClassElementContext>();
}

TypeScriptParser::ClassElementContext* TypeScriptParser::ClassTailContext::classElement(size_t i) {
  return getRuleContext<TypeScriptParser::ClassElementContext>(i);
}


size_t TypeScriptParser::ClassTailContext::getRuleIndex() const {
  return TypeScriptParser::RuleClassTail;
}

void TypeScriptParser::ClassTailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassTail(this);
}

void TypeScriptParser::ClassTailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassTail(this);
}

TypeScriptParser::ClassTailContext* TypeScriptParser::classTail() {
  ClassTailContext *_localctx = _tracker.createInstance<ClassTailContext>(_ctx, getState());
  enterRule(_localctx, 192, TypeScriptParser::RuleClassTail);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1133);
    match(TypeScriptParser::OpenBrace);
    setState(1137);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 134, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1134);
        classElement(); 
      }
      setState(1139);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 134, _ctx);
    }
    setState(1140);
    match(TypeScriptParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassExtendsClauseContext ------------------------------------------------------------------

TypeScriptParser::ClassExtendsClauseContext::ClassExtendsClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::ClassExtendsClauseContext::Extends() {
  return getToken(TypeScriptParser::Extends, 0);
}

TypeScriptParser::TypeReferenceContext* TypeScriptParser::ClassExtendsClauseContext::typeReference() {
  return getRuleContext<TypeScriptParser::TypeReferenceContext>(0);
}


size_t TypeScriptParser::ClassExtendsClauseContext::getRuleIndex() const {
  return TypeScriptParser::RuleClassExtendsClause;
}

void TypeScriptParser::ClassExtendsClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassExtendsClause(this);
}

void TypeScriptParser::ClassExtendsClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassExtendsClause(this);
}

TypeScriptParser::ClassExtendsClauseContext* TypeScriptParser::classExtendsClause() {
  ClassExtendsClauseContext *_localctx = _tracker.createInstance<ClassExtendsClauseContext>(_ctx, getState());
  enterRule(_localctx, 194, TypeScriptParser::RuleClassExtendsClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1142);
    match(TypeScriptParser::Extends);
    setState(1143);
    typeReference();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImplementsClauseContext ------------------------------------------------------------------

TypeScriptParser::ImplementsClauseContext::ImplementsClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::ImplementsClauseContext::Implements() {
  return getToken(TypeScriptParser::Implements, 0);
}

TypeScriptParser::ClassOrInterfaceTypeListContext* TypeScriptParser::ImplementsClauseContext::classOrInterfaceTypeList() {
  return getRuleContext<TypeScriptParser::ClassOrInterfaceTypeListContext>(0);
}


size_t TypeScriptParser::ImplementsClauseContext::getRuleIndex() const {
  return TypeScriptParser::RuleImplementsClause;
}

void TypeScriptParser::ImplementsClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImplementsClause(this);
}

void TypeScriptParser::ImplementsClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImplementsClause(this);
}

TypeScriptParser::ImplementsClauseContext* TypeScriptParser::implementsClause() {
  ImplementsClauseContext *_localctx = _tracker.createInstance<ImplementsClauseContext>(_ctx, getState());
  enterRule(_localctx, 196, TypeScriptParser::RuleImplementsClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1145);
    match(TypeScriptParser::Implements);
    setState(1146);
    classOrInterfaceTypeList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassElementContext ------------------------------------------------------------------

TypeScriptParser::ClassElementContext::ClassElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::ConstructorDeclarationContext* TypeScriptParser::ClassElementContext::constructorDeclaration() {
  return getRuleContext<TypeScriptParser::ConstructorDeclarationContext>(0);
}

TypeScriptParser::PropertyMemberDeclarationContext* TypeScriptParser::ClassElementContext::propertyMemberDeclaration() {
  return getRuleContext<TypeScriptParser::PropertyMemberDeclarationContext>(0);
}

TypeScriptParser::DecoratorListContext* TypeScriptParser::ClassElementContext::decoratorList() {
  return getRuleContext<TypeScriptParser::DecoratorListContext>(0);
}

TypeScriptParser::IndexMemberDeclarationContext* TypeScriptParser::ClassElementContext::indexMemberDeclaration() {
  return getRuleContext<TypeScriptParser::IndexMemberDeclarationContext>(0);
}

TypeScriptParser::StatementContext* TypeScriptParser::ClassElementContext::statement() {
  return getRuleContext<TypeScriptParser::StatementContext>(0);
}


size_t TypeScriptParser::ClassElementContext::getRuleIndex() const {
  return TypeScriptParser::RuleClassElement;
}

void TypeScriptParser::ClassElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassElement(this);
}

void TypeScriptParser::ClassElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassElement(this);
}

TypeScriptParser::ClassElementContext* TypeScriptParser::classElement() {
  ClassElementContext *_localctx = _tracker.createInstance<ClassElementContext>(_ctx, getState());
  enterRule(_localctx, 198, TypeScriptParser::RuleClassElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1155);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1148);
      constructorDeclaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1150);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TypeScriptParser::At) {
        setState(1149);
        decoratorList();
      }
      setState(1152);
      propertyMemberDeclaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1153);
      indexMemberDeclaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1154);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyMemberDeclarationContext ------------------------------------------------------------------

TypeScriptParser::PropertyMemberDeclarationContext::PropertyMemberDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t TypeScriptParser::PropertyMemberDeclarationContext::getRuleIndex() const {
  return TypeScriptParser::RulePropertyMemberDeclaration;
}

void TypeScriptParser::PropertyMemberDeclarationContext::copyFrom(PropertyMemberDeclarationContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PropertyDeclarationExpressionContext ------------------------------------------------------------------

TypeScriptParser::PropertyMemberBaseContext* TypeScriptParser::PropertyDeclarationExpressionContext::propertyMemberBase() {
  return getRuleContext<TypeScriptParser::PropertyMemberBaseContext>(0);
}

TypeScriptParser::PropertyNameContext* TypeScriptParser::PropertyDeclarationExpressionContext::propertyName() {
  return getRuleContext<TypeScriptParser::PropertyNameContext>(0);
}

tree::TerminalNode* TypeScriptParser::PropertyDeclarationExpressionContext::SemiColon() {
  return getToken(TypeScriptParser::SemiColon, 0);
}

tree::TerminalNode* TypeScriptParser::PropertyDeclarationExpressionContext::QuestionMark() {
  return getToken(TypeScriptParser::QuestionMark, 0);
}

TypeScriptParser::TypeAnnotationContext* TypeScriptParser::PropertyDeclarationExpressionContext::typeAnnotation() {
  return getRuleContext<TypeScriptParser::TypeAnnotationContext>(0);
}

TypeScriptParser::InitializerContext* TypeScriptParser::PropertyDeclarationExpressionContext::initializer() {
  return getRuleContext<TypeScriptParser::InitializerContext>(0);
}

TypeScriptParser::PropertyDeclarationExpressionContext::PropertyDeclarationExpressionContext(PropertyMemberDeclarationContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::PropertyDeclarationExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyDeclarationExpression(this);
}
void TypeScriptParser::PropertyDeclarationExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyDeclarationExpression(this);
}
//----------------- MethodDeclarationExpressionContext ------------------------------------------------------------------

TypeScriptParser::PropertyMemberBaseContext* TypeScriptParser::MethodDeclarationExpressionContext::propertyMemberBase() {
  return getRuleContext<TypeScriptParser::PropertyMemberBaseContext>(0);
}

TypeScriptParser::PropertyNameContext* TypeScriptParser::MethodDeclarationExpressionContext::propertyName() {
  return getRuleContext<TypeScriptParser::PropertyNameContext>(0);
}

TypeScriptParser::CallSignatureContext* TypeScriptParser::MethodDeclarationExpressionContext::callSignature() {
  return getRuleContext<TypeScriptParser::CallSignatureContext>(0);
}

tree::TerminalNode* TypeScriptParser::MethodDeclarationExpressionContext::SemiColon() {
  return getToken(TypeScriptParser::SemiColon, 0);
}

tree::TerminalNode* TypeScriptParser::MethodDeclarationExpressionContext::OpenBrace() {
  return getToken(TypeScriptParser::OpenBrace, 0);
}

TypeScriptParser::FunctionBodyContext* TypeScriptParser::MethodDeclarationExpressionContext::functionBody() {
  return getRuleContext<TypeScriptParser::FunctionBodyContext>(0);
}

tree::TerminalNode* TypeScriptParser::MethodDeclarationExpressionContext::CloseBrace() {
  return getToken(TypeScriptParser::CloseBrace, 0);
}

TypeScriptParser::MethodDeclarationExpressionContext::MethodDeclarationExpressionContext(PropertyMemberDeclarationContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::MethodDeclarationExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMethodDeclarationExpression(this);
}
void TypeScriptParser::MethodDeclarationExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMethodDeclarationExpression(this);
}
//----------------- GetterSetterDeclarationExpressionContext ------------------------------------------------------------------

TypeScriptParser::PropertyMemberBaseContext* TypeScriptParser::GetterSetterDeclarationExpressionContext::propertyMemberBase() {
  return getRuleContext<TypeScriptParser::PropertyMemberBaseContext>(0);
}

TypeScriptParser::GetAccessorContext* TypeScriptParser::GetterSetterDeclarationExpressionContext::getAccessor() {
  return getRuleContext<TypeScriptParser::GetAccessorContext>(0);
}

TypeScriptParser::SetAccessorContext* TypeScriptParser::GetterSetterDeclarationExpressionContext::setAccessor() {
  return getRuleContext<TypeScriptParser::SetAccessorContext>(0);
}

TypeScriptParser::GetterSetterDeclarationExpressionContext::GetterSetterDeclarationExpressionContext(PropertyMemberDeclarationContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::GetterSetterDeclarationExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGetterSetterDeclarationExpression(this);
}
void TypeScriptParser::GetterSetterDeclarationExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGetterSetterDeclarationExpression(this);
}
//----------------- AbstractMemberDeclarationContext ------------------------------------------------------------------

TypeScriptParser::AbstractDeclarationContext* TypeScriptParser::AbstractMemberDeclarationContext::abstractDeclaration() {
  return getRuleContext<TypeScriptParser::AbstractDeclarationContext>(0);
}

TypeScriptParser::AbstractMemberDeclarationContext::AbstractMemberDeclarationContext(PropertyMemberDeclarationContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::AbstractMemberDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAbstractMemberDeclaration(this);
}
void TypeScriptParser::AbstractMemberDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAbstractMemberDeclaration(this);
}
TypeScriptParser::PropertyMemberDeclarationContext* TypeScriptParser::propertyMemberDeclaration() {
  PropertyMemberDeclarationContext *_localctx = _tracker.createInstance<PropertyMemberDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 200, TypeScriptParser::RulePropertyMemberDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1186);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<TypeScriptParser::PropertyDeclarationExpressionContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(1157);
      propertyMemberBase();
      setState(1158);
      propertyName();
      setState(1160);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TypeScriptParser::QuestionMark) {
        setState(1159);
        match(TypeScriptParser::QuestionMark);
      }
      setState(1163);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TypeScriptParser::Colon) {
        setState(1162);
        typeAnnotation();
      }
      setState(1166);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TypeScriptParser::Assign) {
        setState(1165);
        initializer();
      }
      setState(1168);
      match(TypeScriptParser::SemiColon);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<TypeScriptParser::MethodDeclarationExpressionContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(1170);
      propertyMemberBase();
      setState(1171);
      propertyName();
      setState(1172);
      callSignature();
      setState(1178);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TypeScriptParser::OpenBrace: {
          setState(1173);
          match(TypeScriptParser::OpenBrace);
          setState(1174);
          functionBody();
          setState(1175);
          match(TypeScriptParser::CloseBrace);
          break;
        }

        case TypeScriptParser::SemiColon: {
          setState(1177);
          match(TypeScriptParser::SemiColon);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<TypeScriptParser::GetterSetterDeclarationExpressionContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(1180);
      propertyMemberBase();
      setState(1183);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TypeScriptParser::Get: {
          setState(1181);
          getAccessor();
          break;
        }

        case TypeScriptParser::Set: {
          setState(1182);
          setAccessor();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<TypeScriptParser::AbstractMemberDeclarationContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(1185);
      abstractDeclaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyMemberBaseContext ------------------------------------------------------------------

TypeScriptParser::PropertyMemberBaseContext::PropertyMemberBaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::AccessibilityModifierContext* TypeScriptParser::PropertyMemberBaseContext::accessibilityModifier() {
  return getRuleContext<TypeScriptParser::AccessibilityModifierContext>(0);
}

tree::TerminalNode* TypeScriptParser::PropertyMemberBaseContext::Async() {
  return getToken(TypeScriptParser::Async, 0);
}

tree::TerminalNode* TypeScriptParser::PropertyMemberBaseContext::Static() {
  return getToken(TypeScriptParser::Static, 0);
}

tree::TerminalNode* TypeScriptParser::PropertyMemberBaseContext::ReadOnly() {
  return getToken(TypeScriptParser::ReadOnly, 0);
}


size_t TypeScriptParser::PropertyMemberBaseContext::getRuleIndex() const {
  return TypeScriptParser::RulePropertyMemberBase;
}

void TypeScriptParser::PropertyMemberBaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyMemberBase(this);
}

void TypeScriptParser::PropertyMemberBaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyMemberBase(this);
}

TypeScriptParser::PropertyMemberBaseContext* TypeScriptParser::propertyMemberBase() {
  PropertyMemberBaseContext *_localctx = _tracker.createInstance<PropertyMemberBaseContext>(_ctx, getState());
  enterRule(_localctx, 202, TypeScriptParser::RulePropertyMemberBase);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1189);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx)) {
    case 1: {
      setState(1188);
      accessibilityModifier();
      break;
    }

    default:
      break;
    }
    setState(1192);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx)) {
    case 1: {
      setState(1191);
      match(TypeScriptParser::Async);
      break;
    }

    default:
      break;
    }
    setState(1195);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 145, _ctx)) {
    case 1: {
      setState(1194);
      match(TypeScriptParser::Static);
      break;
    }

    default:
      break;
    }
    setState(1198);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 146, _ctx)) {
    case 1: {
      setState(1197);
      match(TypeScriptParser::ReadOnly);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexMemberDeclarationContext ------------------------------------------------------------------

TypeScriptParser::IndexMemberDeclarationContext::IndexMemberDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::IndexSignatureContext* TypeScriptParser::IndexMemberDeclarationContext::indexSignature() {
  return getRuleContext<TypeScriptParser::IndexSignatureContext>(0);
}

tree::TerminalNode* TypeScriptParser::IndexMemberDeclarationContext::SemiColon() {
  return getToken(TypeScriptParser::SemiColon, 0);
}


size_t TypeScriptParser::IndexMemberDeclarationContext::getRuleIndex() const {
  return TypeScriptParser::RuleIndexMemberDeclaration;
}

void TypeScriptParser::IndexMemberDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexMemberDeclaration(this);
}

void TypeScriptParser::IndexMemberDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexMemberDeclaration(this);
}

TypeScriptParser::IndexMemberDeclarationContext* TypeScriptParser::indexMemberDeclaration() {
  IndexMemberDeclarationContext *_localctx = _tracker.createInstance<IndexMemberDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 204, TypeScriptParser::RuleIndexMemberDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1200);
    indexSignature();
    setState(1201);
    match(TypeScriptParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeneratorMethodContext ------------------------------------------------------------------

TypeScriptParser::GeneratorMethodContext::GeneratorMethodContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::GeneratorMethodContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

tree::TerminalNode* TypeScriptParser::GeneratorMethodContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

tree::TerminalNode* TypeScriptParser::GeneratorMethodContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

tree::TerminalNode* TypeScriptParser::GeneratorMethodContext::OpenBrace() {
  return getToken(TypeScriptParser::OpenBrace, 0);
}

TypeScriptParser::FunctionBodyContext* TypeScriptParser::GeneratorMethodContext::functionBody() {
  return getRuleContext<TypeScriptParser::FunctionBodyContext>(0);
}

tree::TerminalNode* TypeScriptParser::GeneratorMethodContext::CloseBrace() {
  return getToken(TypeScriptParser::CloseBrace, 0);
}

tree::TerminalNode* TypeScriptParser::GeneratorMethodContext::Multiply() {
  return getToken(TypeScriptParser::Multiply, 0);
}

TypeScriptParser::FormalParameterListContext* TypeScriptParser::GeneratorMethodContext::formalParameterList() {
  return getRuleContext<TypeScriptParser::FormalParameterListContext>(0);
}


size_t TypeScriptParser::GeneratorMethodContext::getRuleIndex() const {
  return TypeScriptParser::RuleGeneratorMethod;
}

void TypeScriptParser::GeneratorMethodContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneratorMethod(this);
}

void TypeScriptParser::GeneratorMethodContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneratorMethod(this);
}

TypeScriptParser::GeneratorMethodContext* TypeScriptParser::generatorMethod() {
  GeneratorMethodContext *_localctx = _tracker.createInstance<GeneratorMethodContext>(_ctx, getState());
  enterRule(_localctx, 206, TypeScriptParser::RuleGeneratorMethod);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1204);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Multiply) {
      setState(1203);
      match(TypeScriptParser::Multiply);
    }
    setState(1206);
    match(TypeScriptParser::Identifier);
    setState(1207);
    match(TypeScriptParser::OpenParen);
    setState(1209);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 65808) != 0) || ((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 12718099) != 0)) {
      setState(1208);
      formalParameterList();
    }
    setState(1211);
    match(TypeScriptParser::CloseParen);
    setState(1212);
    match(TypeScriptParser::OpenBrace);
    setState(1213);
    functionBody();
    setState(1214);
    match(TypeScriptParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeneratorFunctionDeclarationContext ------------------------------------------------------------------

TypeScriptParser::GeneratorFunctionDeclarationContext::GeneratorFunctionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::GeneratorFunctionDeclarationContext::Function_() {
  return getToken(TypeScriptParser::Function_, 0);
}

tree::TerminalNode* TypeScriptParser::GeneratorFunctionDeclarationContext::Multiply() {
  return getToken(TypeScriptParser::Multiply, 0);
}

tree::TerminalNode* TypeScriptParser::GeneratorFunctionDeclarationContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

tree::TerminalNode* TypeScriptParser::GeneratorFunctionDeclarationContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

tree::TerminalNode* TypeScriptParser::GeneratorFunctionDeclarationContext::OpenBrace() {
  return getToken(TypeScriptParser::OpenBrace, 0);
}

TypeScriptParser::FunctionBodyContext* TypeScriptParser::GeneratorFunctionDeclarationContext::functionBody() {
  return getRuleContext<TypeScriptParser::FunctionBodyContext>(0);
}

tree::TerminalNode* TypeScriptParser::GeneratorFunctionDeclarationContext::CloseBrace() {
  return getToken(TypeScriptParser::CloseBrace, 0);
}

tree::TerminalNode* TypeScriptParser::GeneratorFunctionDeclarationContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

TypeScriptParser::FormalParameterListContext* TypeScriptParser::GeneratorFunctionDeclarationContext::formalParameterList() {
  return getRuleContext<TypeScriptParser::FormalParameterListContext>(0);
}


size_t TypeScriptParser::GeneratorFunctionDeclarationContext::getRuleIndex() const {
  return TypeScriptParser::RuleGeneratorFunctionDeclaration;
}

void TypeScriptParser::GeneratorFunctionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneratorFunctionDeclaration(this);
}

void TypeScriptParser::GeneratorFunctionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneratorFunctionDeclaration(this);
}

TypeScriptParser::GeneratorFunctionDeclarationContext* TypeScriptParser::generatorFunctionDeclaration() {
  GeneratorFunctionDeclarationContext *_localctx = _tracker.createInstance<GeneratorFunctionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 208, TypeScriptParser::RuleGeneratorFunctionDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1216);
    match(TypeScriptParser::Function_);
    setState(1217);
    match(TypeScriptParser::Multiply);
    setState(1219);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Identifier) {
      setState(1218);
      match(TypeScriptParser::Identifier);
    }
    setState(1221);
    match(TypeScriptParser::OpenParen);
    setState(1223);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 65808) != 0) || ((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 12718099) != 0)) {
      setState(1222);
      formalParameterList();
    }
    setState(1225);
    match(TypeScriptParser::CloseParen);
    setState(1226);
    match(TypeScriptParser::OpenBrace);
    setState(1227);
    functionBody();
    setState(1228);
    match(TypeScriptParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeneratorBlockContext ------------------------------------------------------------------

TypeScriptParser::GeneratorBlockContext::GeneratorBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::GeneratorBlockContext::OpenBrace() {
  return getToken(TypeScriptParser::OpenBrace, 0);
}

std::vector<TypeScriptParser::GeneratorDefinitionContext *> TypeScriptParser::GeneratorBlockContext::generatorDefinition() {
  return getRuleContexts<TypeScriptParser::GeneratorDefinitionContext>();
}

TypeScriptParser::GeneratorDefinitionContext* TypeScriptParser::GeneratorBlockContext::generatorDefinition(size_t i) {
  return getRuleContext<TypeScriptParser::GeneratorDefinitionContext>(i);
}

tree::TerminalNode* TypeScriptParser::GeneratorBlockContext::CloseBrace() {
  return getToken(TypeScriptParser::CloseBrace, 0);
}

std::vector<tree::TerminalNode *> TypeScriptParser::GeneratorBlockContext::Comma() {
  return getTokens(TypeScriptParser::Comma);
}

tree::TerminalNode* TypeScriptParser::GeneratorBlockContext::Comma(size_t i) {
  return getToken(TypeScriptParser::Comma, i);
}


size_t TypeScriptParser::GeneratorBlockContext::getRuleIndex() const {
  return TypeScriptParser::RuleGeneratorBlock;
}

void TypeScriptParser::GeneratorBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneratorBlock(this);
}

void TypeScriptParser::GeneratorBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneratorBlock(this);
}

TypeScriptParser::GeneratorBlockContext* TypeScriptParser::generatorBlock() {
  GeneratorBlockContext *_localctx = _tracker.createInstance<GeneratorBlockContext>(_ctx, getState());
  enterRule(_localctx, 210, TypeScriptParser::RuleGeneratorBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1230);
    match(TypeScriptParser::OpenBrace);
    setState(1231);
    generatorDefinition();
    setState(1236);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 151, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1232);
        match(TypeScriptParser::Comma);
        setState(1233);
        generatorDefinition(); 
      }
      setState(1238);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 151, _ctx);
    }
    setState(1240);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Comma) {
      setState(1239);
      match(TypeScriptParser::Comma);
    }
    setState(1242);
    match(TypeScriptParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeneratorDefinitionContext ------------------------------------------------------------------

TypeScriptParser::GeneratorDefinitionContext::GeneratorDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::GeneratorDefinitionContext::Multiply() {
  return getToken(TypeScriptParser::Multiply, 0);
}

TypeScriptParser::IteratorDefinitionContext* TypeScriptParser::GeneratorDefinitionContext::iteratorDefinition() {
  return getRuleContext<TypeScriptParser::IteratorDefinitionContext>(0);
}


size_t TypeScriptParser::GeneratorDefinitionContext::getRuleIndex() const {
  return TypeScriptParser::RuleGeneratorDefinition;
}

void TypeScriptParser::GeneratorDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneratorDefinition(this);
}

void TypeScriptParser::GeneratorDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneratorDefinition(this);
}

TypeScriptParser::GeneratorDefinitionContext* TypeScriptParser::generatorDefinition() {
  GeneratorDefinitionContext *_localctx = _tracker.createInstance<GeneratorDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 212, TypeScriptParser::RuleGeneratorDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1244);
    match(TypeScriptParser::Multiply);
    setState(1245);
    iteratorDefinition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IteratorBlockContext ------------------------------------------------------------------

TypeScriptParser::IteratorBlockContext::IteratorBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::IteratorBlockContext::OpenBrace() {
  return getToken(TypeScriptParser::OpenBrace, 0);
}

std::vector<TypeScriptParser::IteratorDefinitionContext *> TypeScriptParser::IteratorBlockContext::iteratorDefinition() {
  return getRuleContexts<TypeScriptParser::IteratorDefinitionContext>();
}

TypeScriptParser::IteratorDefinitionContext* TypeScriptParser::IteratorBlockContext::iteratorDefinition(size_t i) {
  return getRuleContext<TypeScriptParser::IteratorDefinitionContext>(i);
}

tree::TerminalNode* TypeScriptParser::IteratorBlockContext::CloseBrace() {
  return getToken(TypeScriptParser::CloseBrace, 0);
}

std::vector<tree::TerminalNode *> TypeScriptParser::IteratorBlockContext::Comma() {
  return getTokens(TypeScriptParser::Comma);
}

tree::TerminalNode* TypeScriptParser::IteratorBlockContext::Comma(size_t i) {
  return getToken(TypeScriptParser::Comma, i);
}


size_t TypeScriptParser::IteratorBlockContext::getRuleIndex() const {
  return TypeScriptParser::RuleIteratorBlock;
}

void TypeScriptParser::IteratorBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIteratorBlock(this);
}

void TypeScriptParser::IteratorBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIteratorBlock(this);
}

TypeScriptParser::IteratorBlockContext* TypeScriptParser::iteratorBlock() {
  IteratorBlockContext *_localctx = _tracker.createInstance<IteratorBlockContext>(_ctx, getState());
  enterRule(_localctx, 214, TypeScriptParser::RuleIteratorBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1247);
    match(TypeScriptParser::OpenBrace);
    setState(1248);
    iteratorDefinition();
    setState(1253);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 153, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1249);
        match(TypeScriptParser::Comma);
        setState(1250);
        iteratorDefinition(); 
      }
      setState(1255);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 153, _ctx);
    }
    setState(1257);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Comma) {
      setState(1256);
      match(TypeScriptParser::Comma);
    }
    setState(1259);
    match(TypeScriptParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IteratorDefinitionContext ------------------------------------------------------------------

TypeScriptParser::IteratorDefinitionContext::IteratorDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::IteratorDefinitionContext::OpenBracket() {
  return getToken(TypeScriptParser::OpenBracket, 0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::IteratorDefinitionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* TypeScriptParser::IteratorDefinitionContext::CloseBracket() {
  return getToken(TypeScriptParser::CloseBracket, 0);
}

tree::TerminalNode* TypeScriptParser::IteratorDefinitionContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

tree::TerminalNode* TypeScriptParser::IteratorDefinitionContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

tree::TerminalNode* TypeScriptParser::IteratorDefinitionContext::OpenBrace() {
  return getToken(TypeScriptParser::OpenBrace, 0);
}

TypeScriptParser::FunctionBodyContext* TypeScriptParser::IteratorDefinitionContext::functionBody() {
  return getRuleContext<TypeScriptParser::FunctionBodyContext>(0);
}

tree::TerminalNode* TypeScriptParser::IteratorDefinitionContext::CloseBrace() {
  return getToken(TypeScriptParser::CloseBrace, 0);
}

TypeScriptParser::FormalParameterListContext* TypeScriptParser::IteratorDefinitionContext::formalParameterList() {
  return getRuleContext<TypeScriptParser::FormalParameterListContext>(0);
}


size_t TypeScriptParser::IteratorDefinitionContext::getRuleIndex() const {
  return TypeScriptParser::RuleIteratorDefinition;
}

void TypeScriptParser::IteratorDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIteratorDefinition(this);
}

void TypeScriptParser::IteratorDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIteratorDefinition(this);
}

TypeScriptParser::IteratorDefinitionContext* TypeScriptParser::iteratorDefinition() {
  IteratorDefinitionContext *_localctx = _tracker.createInstance<IteratorDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 216, TypeScriptParser::RuleIteratorDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1261);
    match(TypeScriptParser::OpenBracket);
    setState(1262);
    singleExpression(0);
    setState(1263);
    match(TypeScriptParser::CloseBracket);
    setState(1264);
    match(TypeScriptParser::OpenParen);
    setState(1266);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 65808) != 0) || ((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 12718099) != 0)) {
      setState(1265);
      formalParameterList();
    }
    setState(1268);
    match(TypeScriptParser::CloseParen);
    setState(1269);
    match(TypeScriptParser::OpenBrace);
    setState(1270);
    functionBody();
    setState(1271);
    match(TypeScriptParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FormalParameterListContext ------------------------------------------------------------------

TypeScriptParser::FormalParameterListContext::FormalParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TypeScriptParser::FormalParameterArgContext *> TypeScriptParser::FormalParameterListContext::formalParameterArg() {
  return getRuleContexts<TypeScriptParser::FormalParameterArgContext>();
}

TypeScriptParser::FormalParameterArgContext* TypeScriptParser::FormalParameterListContext::formalParameterArg(size_t i) {
  return getRuleContext<TypeScriptParser::FormalParameterArgContext>(i);
}

std::vector<tree::TerminalNode *> TypeScriptParser::FormalParameterListContext::Comma() {
  return getTokens(TypeScriptParser::Comma);
}

tree::TerminalNode* TypeScriptParser::FormalParameterListContext::Comma(size_t i) {
  return getToken(TypeScriptParser::Comma, i);
}

TypeScriptParser::LastFormalParameterArgContext* TypeScriptParser::FormalParameterListContext::lastFormalParameterArg() {
  return getRuleContext<TypeScriptParser::LastFormalParameterArgContext>(0);
}

TypeScriptParser::ArrayLiteralContext* TypeScriptParser::FormalParameterListContext::arrayLiteral() {
  return getRuleContext<TypeScriptParser::ArrayLiteralContext>(0);
}

TypeScriptParser::ObjectLiteralContext* TypeScriptParser::FormalParameterListContext::objectLiteral() {
  return getRuleContext<TypeScriptParser::ObjectLiteralContext>(0);
}

tree::TerminalNode* TypeScriptParser::FormalParameterListContext::Colon() {
  return getToken(TypeScriptParser::Colon, 0);
}

TypeScriptParser::FormalParameterListContext* TypeScriptParser::FormalParameterListContext::formalParameterList() {
  return getRuleContext<TypeScriptParser::FormalParameterListContext>(0);
}


size_t TypeScriptParser::FormalParameterListContext::getRuleIndex() const {
  return TypeScriptParser::RuleFormalParameterList;
}

void TypeScriptParser::FormalParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFormalParameterList(this);
}

void TypeScriptParser::FormalParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFormalParameterList(this);
}

TypeScriptParser::FormalParameterListContext* TypeScriptParser::formalParameterList() {
  FormalParameterListContext *_localctx = _tracker.createInstance<FormalParameterListContext>(_ctx, getState());
  enterRule(_localctx, 218, TypeScriptParser::RuleFormalParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1292);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TypeScriptParser::Private:
      case TypeScriptParser::Public:
      case TypeScriptParser::Protected:
      case TypeScriptParser::TypeAlias:
      case TypeScriptParser::Require:
      case TypeScriptParser::At:
      case TypeScriptParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(1273);
        formalParameterArg();
        setState(1278);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1274);
            match(TypeScriptParser::Comma);
            setState(1275);
            formalParameterArg(); 
          }
          setState(1280);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx);
        }
        setState(1283);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TypeScriptParser::Comma) {
          setState(1281);
          match(TypeScriptParser::Comma);
          setState(1282);
          lastFormalParameterArg();
        }
        break;
      }

      case TypeScriptParser::Ellipsis: {
        enterOuterAlt(_localctx, 2);
        setState(1285);
        lastFormalParameterArg();
        break;
      }

      case TypeScriptParser::OpenBracket: {
        enterOuterAlt(_localctx, 3);
        setState(1286);
        arrayLiteral();
        break;
      }

      case TypeScriptParser::OpenBrace: {
        enterOuterAlt(_localctx, 4);
        setState(1287);
        objectLiteral();
        setState(1290);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TypeScriptParser::Colon) {
          setState(1288);
          match(TypeScriptParser::Colon);
          setState(1289);
          formalParameterList();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FormalParameterArgContext ------------------------------------------------------------------

TypeScriptParser::FormalParameterArgContext::FormalParameterArgContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::IdentifierOrKeyWordContext* TypeScriptParser::FormalParameterArgContext::identifierOrKeyWord() {
  return getRuleContext<TypeScriptParser::IdentifierOrKeyWordContext>(0);
}

TypeScriptParser::DecoratorContext* TypeScriptParser::FormalParameterArgContext::decorator() {
  return getRuleContext<TypeScriptParser::DecoratorContext>(0);
}

TypeScriptParser::AccessibilityModifierContext* TypeScriptParser::FormalParameterArgContext::accessibilityModifier() {
  return getRuleContext<TypeScriptParser::AccessibilityModifierContext>(0);
}

tree::TerminalNode* TypeScriptParser::FormalParameterArgContext::QuestionMark() {
  return getToken(TypeScriptParser::QuestionMark, 0);
}

TypeScriptParser::TypeAnnotationContext* TypeScriptParser::FormalParameterArgContext::typeAnnotation() {
  return getRuleContext<TypeScriptParser::TypeAnnotationContext>(0);
}

tree::TerminalNode* TypeScriptParser::FormalParameterArgContext::Assign() {
  return getToken(TypeScriptParser::Assign, 0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::FormalParameterArgContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}


size_t TypeScriptParser::FormalParameterArgContext::getRuleIndex() const {
  return TypeScriptParser::RuleFormalParameterArg;
}

void TypeScriptParser::FormalParameterArgContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFormalParameterArg(this);
}

void TypeScriptParser::FormalParameterArgContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFormalParameterArg(this);
}

TypeScriptParser::FormalParameterArgContext* TypeScriptParser::formalParameterArg() {
  FormalParameterArgContext *_localctx = _tracker.createInstance<FormalParameterArgContext>(_ctx, getState());
  enterRule(_localctx, 220, TypeScriptParser::RuleFormalParameterArg);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1295);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::At) {
      setState(1294);
      decorator();
    }
    setState(1298);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 19) != 0)) {
      setState(1297);
      accessibilityModifier();
    }
    setState(1300);
    identifierOrKeyWord();
    setState(1302);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::QuestionMark) {
      setState(1301);
      match(TypeScriptParser::QuestionMark);
    }
    setState(1305);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Colon) {
      setState(1304);
      typeAnnotation();
    }
    setState(1309);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Assign) {
      setState(1307);
      match(TypeScriptParser::Assign);
      setState(1308);
      singleExpression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LastFormalParameterArgContext ------------------------------------------------------------------

TypeScriptParser::LastFormalParameterArgContext::LastFormalParameterArgContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::LastFormalParameterArgContext::Ellipsis() {
  return getToken(TypeScriptParser::Ellipsis, 0);
}

tree::TerminalNode* TypeScriptParser::LastFormalParameterArgContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

TypeScriptParser::TypeAnnotationContext* TypeScriptParser::LastFormalParameterArgContext::typeAnnotation() {
  return getRuleContext<TypeScriptParser::TypeAnnotationContext>(0);
}


size_t TypeScriptParser::LastFormalParameterArgContext::getRuleIndex() const {
  return TypeScriptParser::RuleLastFormalParameterArg;
}

void TypeScriptParser::LastFormalParameterArgContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLastFormalParameterArg(this);
}

void TypeScriptParser::LastFormalParameterArgContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLastFormalParameterArg(this);
}

TypeScriptParser::LastFormalParameterArgContext* TypeScriptParser::lastFormalParameterArg() {
  LastFormalParameterArgContext *_localctx = _tracker.createInstance<LastFormalParameterArgContext>(_ctx, getState());
  enterRule(_localctx, 222, TypeScriptParser::RuleLastFormalParameterArg);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1311);
    match(TypeScriptParser::Ellipsis);
    setState(1312);
    match(TypeScriptParser::Identifier);
    setState(1314);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Colon) {
      setState(1313);
      typeAnnotation();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionBodyContext ------------------------------------------------------------------

TypeScriptParser::FunctionBodyContext::FunctionBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::SourceElementsContext* TypeScriptParser::FunctionBodyContext::sourceElements() {
  return getRuleContext<TypeScriptParser::SourceElementsContext>(0);
}


size_t TypeScriptParser::FunctionBodyContext::getRuleIndex() const {
  return TypeScriptParser::RuleFunctionBody;
}

void TypeScriptParser::FunctionBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionBody(this);
}

void TypeScriptParser::FunctionBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionBody(this);
}

TypeScriptParser::FunctionBodyContext* TypeScriptParser::functionBody() {
  FunctionBodyContext *_localctx = _tracker.createInstance<FunctionBodyContext>(_ctx, getState());
  enterRule(_localctx, 224, TypeScriptParser::RuleFunctionBody);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1317);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 166, _ctx)) {
    case 1: {
      setState(1316);
      sourceElements();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SourceElementsContext ------------------------------------------------------------------

TypeScriptParser::SourceElementsContext::SourceElementsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TypeScriptParser::SourceElementContext *> TypeScriptParser::SourceElementsContext::sourceElement() {
  return getRuleContexts<TypeScriptParser::SourceElementContext>();
}

TypeScriptParser::SourceElementContext* TypeScriptParser::SourceElementsContext::sourceElement(size_t i) {
  return getRuleContext<TypeScriptParser::SourceElementContext>(i);
}


size_t TypeScriptParser::SourceElementsContext::getRuleIndex() const {
  return TypeScriptParser::RuleSourceElements;
}

void TypeScriptParser::SourceElementsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSourceElements(this);
}

void TypeScriptParser::SourceElementsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSourceElements(this);
}

TypeScriptParser::SourceElementsContext* TypeScriptParser::sourceElements() {
  SourceElementsContext *_localctx = _tracker.createInstance<SourceElementsContext>(_ctx, getState());
  enterRule(_localctx, 226, TypeScriptParser::RuleSourceElements);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1320); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1319);
              sourceElement();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1322); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayLiteralContext ------------------------------------------------------------------

TypeScriptParser::ArrayLiteralContext::ArrayLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::ArrayLiteralContext::OpenBracket() {
  return getToken(TypeScriptParser::OpenBracket, 0);
}

tree::TerminalNode* TypeScriptParser::ArrayLiteralContext::CloseBracket() {
  return getToken(TypeScriptParser::CloseBracket, 0);
}

TypeScriptParser::ElementListContext* TypeScriptParser::ArrayLiteralContext::elementList() {
  return getRuleContext<TypeScriptParser::ElementListContext>(0);
}


size_t TypeScriptParser::ArrayLiteralContext::getRuleIndex() const {
  return TypeScriptParser::RuleArrayLiteral;
}

void TypeScriptParser::ArrayLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayLiteral(this);
}

void TypeScriptParser::ArrayLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayLiteral(this);
}

TypeScriptParser::ArrayLiteralContext* TypeScriptParser::arrayLiteral() {
  ArrayLiteralContext *_localctx = _tracker.createInstance<ArrayLiteralContext>(_ctx, getState());
  enterRule(_localctx, 228, TypeScriptParser::RuleArrayLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1324);
    match(TypeScriptParser::OpenBracket);
    setState(1326);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -36028795928641192) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 8128698260224212991) != 0)) {
      setState(1325);
      elementList();
    }
    setState(1328);
    match(TypeScriptParser::CloseBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementListContext ------------------------------------------------------------------

TypeScriptParser::ElementListContext::ElementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TypeScriptParser::ArrayElementContext *> TypeScriptParser::ElementListContext::arrayElement() {
  return getRuleContexts<TypeScriptParser::ArrayElementContext>();
}

TypeScriptParser::ArrayElementContext* TypeScriptParser::ElementListContext::arrayElement(size_t i) {
  return getRuleContext<TypeScriptParser::ArrayElementContext>(i);
}

std::vector<tree::TerminalNode *> TypeScriptParser::ElementListContext::Comma() {
  return getTokens(TypeScriptParser::Comma);
}

tree::TerminalNode* TypeScriptParser::ElementListContext::Comma(size_t i) {
  return getToken(TypeScriptParser::Comma, i);
}


size_t TypeScriptParser::ElementListContext::getRuleIndex() const {
  return TypeScriptParser::RuleElementList;
}

void TypeScriptParser::ElementListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElementList(this);
}

void TypeScriptParser::ElementListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElementList(this);
}

TypeScriptParser::ElementListContext* TypeScriptParser::elementList() {
  ElementListContext *_localctx = _tracker.createInstance<ElementListContext>(_ctx, getState());
  enterRule(_localctx, 230, TypeScriptParser::RuleElementList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1330);
    arrayElement();
    setState(1339);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TypeScriptParser::Comma) {
      setState(1332); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1331);
        match(TypeScriptParser::Comma);
        setState(1334); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == TypeScriptParser::Comma);
      setState(1336);
      arrayElement();
      setState(1341);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayElementContext ------------------------------------------------------------------

TypeScriptParser::ArrayElementContext::ArrayElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::ArrayElementContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* TypeScriptParser::ArrayElementContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

tree::TerminalNode* TypeScriptParser::ArrayElementContext::Ellipsis() {
  return getToken(TypeScriptParser::Ellipsis, 0);
}

tree::TerminalNode* TypeScriptParser::ArrayElementContext::Comma() {
  return getToken(TypeScriptParser::Comma, 0);
}


size_t TypeScriptParser::ArrayElementContext::getRuleIndex() const {
  return TypeScriptParser::RuleArrayElement;
}

void TypeScriptParser::ArrayElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayElement(this);
}

void TypeScriptParser::ArrayElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayElement(this);
}

TypeScriptParser::ArrayElementContext* TypeScriptParser::arrayElement() {
  ArrayElementContext *_localctx = _tracker.createInstance<ArrayElementContext>(_ctx, getState());
  enterRule(_localctx, 232, TypeScriptParser::RuleArrayElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1343);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Ellipsis) {
      setState(1342);
      match(TypeScriptParser::Ellipsis);
    }
    setState(1347);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, _ctx)) {
    case 1: {
      setState(1345);
      singleExpression(0);
      break;
    }

    case 2: {
      setState(1346);
      match(TypeScriptParser::Identifier);
      break;
    }

    default:
      break;
    }
    setState(1350);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 173, _ctx)) {
    case 1: {
      setState(1349);
      match(TypeScriptParser::Comma);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectLiteralContext ------------------------------------------------------------------

TypeScriptParser::ObjectLiteralContext::ObjectLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::ObjectLiteralContext::OpenBrace() {
  return getToken(TypeScriptParser::OpenBrace, 0);
}

tree::TerminalNode* TypeScriptParser::ObjectLiteralContext::CloseBrace() {
  return getToken(TypeScriptParser::CloseBrace, 0);
}

std::vector<TypeScriptParser::PropertyAssignmentContext *> TypeScriptParser::ObjectLiteralContext::propertyAssignment() {
  return getRuleContexts<TypeScriptParser::PropertyAssignmentContext>();
}

TypeScriptParser::PropertyAssignmentContext* TypeScriptParser::ObjectLiteralContext::propertyAssignment(size_t i) {
  return getRuleContext<TypeScriptParser::PropertyAssignmentContext>(i);
}

std::vector<tree::TerminalNode *> TypeScriptParser::ObjectLiteralContext::Comma() {
  return getTokens(TypeScriptParser::Comma);
}

tree::TerminalNode* TypeScriptParser::ObjectLiteralContext::Comma(size_t i) {
  return getToken(TypeScriptParser::Comma, i);
}


size_t TypeScriptParser::ObjectLiteralContext::getRuleIndex() const {
  return TypeScriptParser::RuleObjectLiteral;
}

void TypeScriptParser::ObjectLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectLiteral(this);
}

void TypeScriptParser::ObjectLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectLiteral(this);
}

TypeScriptParser::ObjectLiteralContext* TypeScriptParser::objectLiteral() {
  ObjectLiteralContext *_localctx = _tracker.createInstance<ObjectLiteralContext>(_ctx, getState());
  enterRule(_localctx, 234, TypeScriptParser::RuleObjectLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1352);
    match(TypeScriptParser::OpenBrace);
    setState(1364);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -36028797002121200) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3517012241796825087) != 0)) {
      setState(1353);
      propertyAssignment();
      setState(1358);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 174, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1354);
          match(TypeScriptParser::Comma);
          setState(1355);
          propertyAssignment(); 
        }
        setState(1360);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 174, _ctx);
      }
      setState(1362);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TypeScriptParser::Comma) {
        setState(1361);
        match(TypeScriptParser::Comma);
      }
    }
    setState(1366);
    match(TypeScriptParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyAssignmentContext ------------------------------------------------------------------

TypeScriptParser::PropertyAssignmentContext::PropertyAssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t TypeScriptParser::PropertyAssignmentContext::getRuleIndex() const {
  return TypeScriptParser::RulePropertyAssignment;
}

void TypeScriptParser::PropertyAssignmentContext::copyFrom(PropertyAssignmentContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PropertyExpressionAssignmentContext ------------------------------------------------------------------

TypeScriptParser::PropertyNameContext* TypeScriptParser::PropertyExpressionAssignmentContext::propertyName() {
  return getRuleContext<TypeScriptParser::PropertyNameContext>(0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::PropertyExpressionAssignmentContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* TypeScriptParser::PropertyExpressionAssignmentContext::Colon() {
  return getToken(TypeScriptParser::Colon, 0);
}

tree::TerminalNode* TypeScriptParser::PropertyExpressionAssignmentContext::Assign() {
  return getToken(TypeScriptParser::Assign, 0);
}

TypeScriptParser::PropertyExpressionAssignmentContext::PropertyExpressionAssignmentContext(PropertyAssignmentContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::PropertyExpressionAssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyExpressionAssignment(this);
}
void TypeScriptParser::PropertyExpressionAssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyExpressionAssignment(this);
}
//----------------- ComputedPropertyExpressionAssignmentContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::ComputedPropertyExpressionAssignmentContext::OpenBracket() {
  return getToken(TypeScriptParser::OpenBracket, 0);
}

std::vector<TypeScriptParser::SingleExpressionContext *> TypeScriptParser::ComputedPropertyExpressionAssignmentContext::singleExpression() {
  return getRuleContexts<TypeScriptParser::SingleExpressionContext>();
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::ComputedPropertyExpressionAssignmentContext::singleExpression(size_t i) {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(i);
}

tree::TerminalNode* TypeScriptParser::ComputedPropertyExpressionAssignmentContext::CloseBracket() {
  return getToken(TypeScriptParser::CloseBracket, 0);
}

tree::TerminalNode* TypeScriptParser::ComputedPropertyExpressionAssignmentContext::Colon() {
  return getToken(TypeScriptParser::Colon, 0);
}

TypeScriptParser::ComputedPropertyExpressionAssignmentContext::ComputedPropertyExpressionAssignmentContext(PropertyAssignmentContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::ComputedPropertyExpressionAssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComputedPropertyExpressionAssignment(this);
}
void TypeScriptParser::ComputedPropertyExpressionAssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComputedPropertyExpressionAssignment(this);
}
//----------------- PropertyShorthandContext ------------------------------------------------------------------

TypeScriptParser::IdentifierOrKeyWordContext* TypeScriptParser::PropertyShorthandContext::identifierOrKeyWord() {
  return getRuleContext<TypeScriptParser::IdentifierOrKeyWordContext>(0);
}

TypeScriptParser::PropertyShorthandContext::PropertyShorthandContext(PropertyAssignmentContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::PropertyShorthandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyShorthand(this);
}
void TypeScriptParser::PropertyShorthandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyShorthand(this);
}
//----------------- PropertySetterContext ------------------------------------------------------------------

TypeScriptParser::SetAccessorContext* TypeScriptParser::PropertySetterContext::setAccessor() {
  return getRuleContext<TypeScriptParser::SetAccessorContext>(0);
}

TypeScriptParser::PropertySetterContext::PropertySetterContext(PropertyAssignmentContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::PropertySetterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertySetter(this);
}
void TypeScriptParser::PropertySetterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertySetter(this);
}
//----------------- PropertyGetterContext ------------------------------------------------------------------

TypeScriptParser::GetAccessorContext* TypeScriptParser::PropertyGetterContext::getAccessor() {
  return getRuleContext<TypeScriptParser::GetAccessorContext>(0);
}

TypeScriptParser::PropertyGetterContext::PropertyGetterContext(PropertyAssignmentContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::PropertyGetterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyGetter(this);
}
void TypeScriptParser::PropertyGetterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyGetter(this);
}
//----------------- RestParameterInObjectContext ------------------------------------------------------------------

TypeScriptParser::RestParameterContext* TypeScriptParser::RestParameterInObjectContext::restParameter() {
  return getRuleContext<TypeScriptParser::RestParameterContext>(0);
}

TypeScriptParser::RestParameterInObjectContext::RestParameterInObjectContext(PropertyAssignmentContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::RestParameterInObjectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRestParameterInObject(this);
}
void TypeScriptParser::RestParameterInObjectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRestParameterInObject(this);
}
//----------------- MethodPropertyContext ------------------------------------------------------------------

TypeScriptParser::GeneratorMethodContext* TypeScriptParser::MethodPropertyContext::generatorMethod() {
  return getRuleContext<TypeScriptParser::GeneratorMethodContext>(0);
}

TypeScriptParser::MethodPropertyContext::MethodPropertyContext(PropertyAssignmentContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::MethodPropertyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMethodProperty(this);
}
void TypeScriptParser::MethodPropertyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMethodProperty(this);
}
TypeScriptParser::PropertyAssignmentContext* TypeScriptParser::propertyAssignment() {
  PropertyAssignmentContext *_localctx = _tracker.createInstance<PropertyAssignmentContext>(_ctx, getState());
  enterRule(_localctx, 236, TypeScriptParser::RulePropertyAssignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1383);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 177, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<TypeScriptParser::PropertyExpressionAssignmentContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(1368);
      propertyName();
      setState(1369);
      _la = _input->LA(1);
      if (!(_la == TypeScriptParser::Assign

      || _la == TypeScriptParser::Colon)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1370);
      singleExpression(0);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<TypeScriptParser::ComputedPropertyExpressionAssignmentContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(1372);
      match(TypeScriptParser::OpenBracket);
      setState(1373);
      singleExpression(0);
      setState(1374);
      match(TypeScriptParser::CloseBracket);
      setState(1375);
      match(TypeScriptParser::Colon);
      setState(1376);
      singleExpression(0);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<TypeScriptParser::PropertyGetterContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(1378);
      getAccessor();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<TypeScriptParser::PropertySetterContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(1379);
      setAccessor();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<TypeScriptParser::MethodPropertyContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(1380);
      generatorMethod();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<TypeScriptParser::PropertyShorthandContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(1381);
      identifierOrKeyWord();
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<TypeScriptParser::RestParameterInObjectContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(1382);
      restParameter();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GetAccessorContext ------------------------------------------------------------------

TypeScriptParser::GetAccessorContext::GetAccessorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::GetterContext* TypeScriptParser::GetAccessorContext::getter() {
  return getRuleContext<TypeScriptParser::GetterContext>(0);
}

tree::TerminalNode* TypeScriptParser::GetAccessorContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

tree::TerminalNode* TypeScriptParser::GetAccessorContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

tree::TerminalNode* TypeScriptParser::GetAccessorContext::OpenBrace() {
  return getToken(TypeScriptParser::OpenBrace, 0);
}

TypeScriptParser::FunctionBodyContext* TypeScriptParser::GetAccessorContext::functionBody() {
  return getRuleContext<TypeScriptParser::FunctionBodyContext>(0);
}

tree::TerminalNode* TypeScriptParser::GetAccessorContext::CloseBrace() {
  return getToken(TypeScriptParser::CloseBrace, 0);
}

TypeScriptParser::TypeAnnotationContext* TypeScriptParser::GetAccessorContext::typeAnnotation() {
  return getRuleContext<TypeScriptParser::TypeAnnotationContext>(0);
}


size_t TypeScriptParser::GetAccessorContext::getRuleIndex() const {
  return TypeScriptParser::RuleGetAccessor;
}

void TypeScriptParser::GetAccessorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGetAccessor(this);
}

void TypeScriptParser::GetAccessorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGetAccessor(this);
}

TypeScriptParser::GetAccessorContext* TypeScriptParser::getAccessor() {
  GetAccessorContext *_localctx = _tracker.createInstance<GetAccessorContext>(_ctx, getState());
  enterRule(_localctx, 238, TypeScriptParser::RuleGetAccessor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1385);
    getter();
    setState(1386);
    match(TypeScriptParser::OpenParen);
    setState(1387);
    match(TypeScriptParser::CloseParen);
    setState(1389);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Colon) {
      setState(1388);
      typeAnnotation();
    }
    setState(1391);
    match(TypeScriptParser::OpenBrace);
    setState(1392);
    functionBody();
    setState(1393);
    match(TypeScriptParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetAccessorContext ------------------------------------------------------------------

TypeScriptParser::SetAccessorContext::SetAccessorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::SetterContext* TypeScriptParser::SetAccessorContext::setter() {
  return getRuleContext<TypeScriptParser::SetterContext>(0);
}

tree::TerminalNode* TypeScriptParser::SetAccessorContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

tree::TerminalNode* TypeScriptParser::SetAccessorContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

tree::TerminalNode* TypeScriptParser::SetAccessorContext::OpenBrace() {
  return getToken(TypeScriptParser::OpenBrace, 0);
}

TypeScriptParser::FunctionBodyContext* TypeScriptParser::SetAccessorContext::functionBody() {
  return getRuleContext<TypeScriptParser::FunctionBodyContext>(0);
}

tree::TerminalNode* TypeScriptParser::SetAccessorContext::CloseBrace() {
  return getToken(TypeScriptParser::CloseBrace, 0);
}

tree::TerminalNode* TypeScriptParser::SetAccessorContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

TypeScriptParser::BindingPatternContext* TypeScriptParser::SetAccessorContext::bindingPattern() {
  return getRuleContext<TypeScriptParser::BindingPatternContext>(0);
}

TypeScriptParser::TypeAnnotationContext* TypeScriptParser::SetAccessorContext::typeAnnotation() {
  return getRuleContext<TypeScriptParser::TypeAnnotationContext>(0);
}


size_t TypeScriptParser::SetAccessorContext::getRuleIndex() const {
  return TypeScriptParser::RuleSetAccessor;
}

void TypeScriptParser::SetAccessorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetAccessor(this);
}

void TypeScriptParser::SetAccessorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetAccessor(this);
}

TypeScriptParser::SetAccessorContext* TypeScriptParser::setAccessor() {
  SetAccessorContext *_localctx = _tracker.createInstance<SetAccessorContext>(_ctx, getState());
  enterRule(_localctx, 240, TypeScriptParser::RuleSetAccessor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1395);
    setter();
    setState(1396);
    match(TypeScriptParser::OpenParen);
    setState(1399);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TypeScriptParser::Identifier: {
        setState(1397);
        match(TypeScriptParser::Identifier);
        break;
      }

      case TypeScriptParser::OpenBracket:
      case TypeScriptParser::OpenBrace: {
        setState(1398);
        bindingPattern();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1402);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Colon) {
      setState(1401);
      typeAnnotation();
    }
    setState(1404);
    match(TypeScriptParser::CloseParen);
    setState(1405);
    match(TypeScriptParser::OpenBrace);
    setState(1406);
    functionBody();
    setState(1407);
    match(TypeScriptParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyNameContext ------------------------------------------------------------------

TypeScriptParser::PropertyNameContext::PropertyNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::IdentifierNameContext* TypeScriptParser::PropertyNameContext::identifierName() {
  return getRuleContext<TypeScriptParser::IdentifierNameContext>(0);
}

tree::TerminalNode* TypeScriptParser::PropertyNameContext::StringLiteral() {
  return getToken(TypeScriptParser::StringLiteral, 0);
}

TypeScriptParser::NumericLiteralContext* TypeScriptParser::PropertyNameContext::numericLiteral() {
  return getRuleContext<TypeScriptParser::NumericLiteralContext>(0);
}


size_t TypeScriptParser::PropertyNameContext::getRuleIndex() const {
  return TypeScriptParser::RulePropertyName;
}

void TypeScriptParser::PropertyNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyName(this);
}

void TypeScriptParser::PropertyNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyName(this);
}

TypeScriptParser::PropertyNameContext* TypeScriptParser::propertyName() {
  PropertyNameContext *_localctx = _tracker.createInstance<PropertyNameContext>(_ctx, getState());
  enterRule(_localctx, 242, TypeScriptParser::RulePropertyName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1412);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TypeScriptParser::NullLiteral:
      case TypeScriptParser::BooleanLiteral:
      case TypeScriptParser::Break:
      case TypeScriptParser::Do:
      case TypeScriptParser::Instanceof:
      case TypeScriptParser::Typeof:
      case TypeScriptParser::Case:
      case TypeScriptParser::Else:
      case TypeScriptParser::New:
      case TypeScriptParser::Var:
      case TypeScriptParser::Catch:
      case TypeScriptParser::Finally:
      case TypeScriptParser::Return:
      case TypeScriptParser::Void:
      case TypeScriptParser::Continue:
      case TypeScriptParser::For:
      case TypeScriptParser::Switch:
      case TypeScriptParser::While:
      case TypeScriptParser::Debugger:
      case TypeScriptParser::Function_:
      case TypeScriptParser::This:
      case TypeScriptParser::With:
      case TypeScriptParser::Default:
      case TypeScriptParser::If:
      case TypeScriptParser::Throw:
      case TypeScriptParser::Delete:
      case TypeScriptParser::In:
      case TypeScriptParser::Try:
      case TypeScriptParser::From:
      case TypeScriptParser::ReadOnly:
      case TypeScriptParser::Async:
      case TypeScriptParser::Class:
      case TypeScriptParser::Enum:
      case TypeScriptParser::Extends:
      case TypeScriptParser::Super:
      case TypeScriptParser::Const:
      case TypeScriptParser::Export:
      case TypeScriptParser::Import:
      case TypeScriptParser::Implements:
      case TypeScriptParser::Let:
      case TypeScriptParser::Private:
      case TypeScriptParser::Public:
      case TypeScriptParser::Interface:
      case TypeScriptParser::Package:
      case TypeScriptParser::Protected:
      case TypeScriptParser::Static:
      case TypeScriptParser::Yield:
      case TypeScriptParser::Number:
      case TypeScriptParser::Boolean:
      case TypeScriptParser::String:
      case TypeScriptParser::TypeAlias:
      case TypeScriptParser::Get:
      case TypeScriptParser::Set:
      case TypeScriptParser::Require:
      case TypeScriptParser::Module:
      case TypeScriptParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(1409);
        identifierName();
        break;
      }

      case TypeScriptParser::StringLiteral: {
        enterOuterAlt(_localctx, 2);
        setState(1410);
        match(TypeScriptParser::StringLiteral);
        break;
      }

      case TypeScriptParser::DecimalLiteral:
      case TypeScriptParser::HexIntegerLiteral:
      case TypeScriptParser::OctalIntegerLiteral:
      case TypeScriptParser::OctalIntegerLiteral2:
      case TypeScriptParser::BinaryIntegerLiteral: {
        enterOuterAlt(_localctx, 3);
        setState(1411);
        numericLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentsContext ------------------------------------------------------------------

TypeScriptParser::ArgumentsContext::ArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::ArgumentsContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

tree::TerminalNode* TypeScriptParser::ArgumentsContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

TypeScriptParser::ArgumentListContext* TypeScriptParser::ArgumentsContext::argumentList() {
  return getRuleContext<TypeScriptParser::ArgumentListContext>(0);
}

tree::TerminalNode* TypeScriptParser::ArgumentsContext::Comma() {
  return getToken(TypeScriptParser::Comma, 0);
}


size_t TypeScriptParser::ArgumentsContext::getRuleIndex() const {
  return TypeScriptParser::RuleArguments;
}

void TypeScriptParser::ArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArguments(this);
}

void TypeScriptParser::ArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArguments(this);
}

TypeScriptParser::ArgumentsContext* TypeScriptParser::arguments() {
  ArgumentsContext *_localctx = _tracker.createInstance<ArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 244, TypeScriptParser::RuleArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1414);
    match(TypeScriptParser::OpenParen);
    setState(1419);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -36028795928641192) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 8128698260224212991) != 0)) {
      setState(1415);
      argumentList();
      setState(1417);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TypeScriptParser::Comma) {
        setState(1416);
        match(TypeScriptParser::Comma);
      }
    }
    setState(1421);
    match(TypeScriptParser::CloseParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentListContext ------------------------------------------------------------------

TypeScriptParser::ArgumentListContext::ArgumentListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TypeScriptParser::ArgumentContext *> TypeScriptParser::ArgumentListContext::argument() {
  return getRuleContexts<TypeScriptParser::ArgumentContext>();
}

TypeScriptParser::ArgumentContext* TypeScriptParser::ArgumentListContext::argument(size_t i) {
  return getRuleContext<TypeScriptParser::ArgumentContext>(i);
}

std::vector<tree::TerminalNode *> TypeScriptParser::ArgumentListContext::Comma() {
  return getTokens(TypeScriptParser::Comma);
}

tree::TerminalNode* TypeScriptParser::ArgumentListContext::Comma(size_t i) {
  return getToken(TypeScriptParser::Comma, i);
}


size_t TypeScriptParser::ArgumentListContext::getRuleIndex() const {
  return TypeScriptParser::RuleArgumentList;
}

void TypeScriptParser::ArgumentListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgumentList(this);
}

void TypeScriptParser::ArgumentListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgumentList(this);
}

TypeScriptParser::ArgumentListContext* TypeScriptParser::argumentList() {
  ArgumentListContext *_localctx = _tracker.createInstance<ArgumentListContext>(_ctx, getState());
  enterRule(_localctx, 246, TypeScriptParser::RuleArgumentList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1423);
    argument();
    setState(1428);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 184, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1424);
        match(TypeScriptParser::Comma);
        setState(1425);
        argument(); 
      }
      setState(1430);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 184, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentContext ------------------------------------------------------------------

TypeScriptParser::ArgumentContext::ArgumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::ArgumentContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* TypeScriptParser::ArgumentContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

tree::TerminalNode* TypeScriptParser::ArgumentContext::Ellipsis() {
  return getToken(TypeScriptParser::Ellipsis, 0);
}


size_t TypeScriptParser::ArgumentContext::getRuleIndex() const {
  return TypeScriptParser::RuleArgument;
}

void TypeScriptParser::ArgumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgument(this);
}

void TypeScriptParser::ArgumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgument(this);
}

TypeScriptParser::ArgumentContext* TypeScriptParser::argument() {
  ArgumentContext *_localctx = _tracker.createInstance<ArgumentContext>(_ctx, getState());
  enterRule(_localctx, 248, TypeScriptParser::RuleArgument);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1432);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Ellipsis) {
      setState(1431);
      match(TypeScriptParser::Ellipsis);
    }
    setState(1436);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 186, _ctx)) {
    case 1: {
      setState(1434);
      singleExpression(0);
      break;
    }

    case 2: {
      setState(1435);
      match(TypeScriptParser::Identifier);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionSequenceContext ------------------------------------------------------------------

TypeScriptParser::ExpressionSequenceContext::ExpressionSequenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TypeScriptParser::SingleExpressionContext *> TypeScriptParser::ExpressionSequenceContext::singleExpression() {
  return getRuleContexts<TypeScriptParser::SingleExpressionContext>();
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::ExpressionSequenceContext::singleExpression(size_t i) {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(i);
}

std::vector<tree::TerminalNode *> TypeScriptParser::ExpressionSequenceContext::Comma() {
  return getTokens(TypeScriptParser::Comma);
}

tree::TerminalNode* TypeScriptParser::ExpressionSequenceContext::Comma(size_t i) {
  return getToken(TypeScriptParser::Comma, i);
}


size_t TypeScriptParser::ExpressionSequenceContext::getRuleIndex() const {
  return TypeScriptParser::RuleExpressionSequence;
}

void TypeScriptParser::ExpressionSequenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionSequence(this);
}

void TypeScriptParser::ExpressionSequenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionSequence(this);
}

TypeScriptParser::ExpressionSequenceContext* TypeScriptParser::expressionSequence() {
  ExpressionSequenceContext *_localctx = _tracker.createInstance<ExpressionSequenceContext>(_ctx, getState());
  enterRule(_localctx, 250, TypeScriptParser::RuleExpressionSequence);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1438);
    singleExpression(0);
    setState(1443);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 187, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1439);
        match(TypeScriptParser::Comma);
        setState(1440);
        singleExpression(0); 
      }
      setState(1445);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 187, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionExpressionDeclarationContext ------------------------------------------------------------------

TypeScriptParser::FunctionExpressionDeclarationContext::FunctionExpressionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::FunctionExpressionDeclarationContext::Function_() {
  return getToken(TypeScriptParser::Function_, 0);
}

tree::TerminalNode* TypeScriptParser::FunctionExpressionDeclarationContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

tree::TerminalNode* TypeScriptParser::FunctionExpressionDeclarationContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

tree::TerminalNode* TypeScriptParser::FunctionExpressionDeclarationContext::OpenBrace() {
  return getToken(TypeScriptParser::OpenBrace, 0);
}

TypeScriptParser::FunctionBodyContext* TypeScriptParser::FunctionExpressionDeclarationContext::functionBody() {
  return getRuleContext<TypeScriptParser::FunctionBodyContext>(0);
}

tree::TerminalNode* TypeScriptParser::FunctionExpressionDeclarationContext::CloseBrace() {
  return getToken(TypeScriptParser::CloseBrace, 0);
}

tree::TerminalNode* TypeScriptParser::FunctionExpressionDeclarationContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

TypeScriptParser::FormalParameterListContext* TypeScriptParser::FunctionExpressionDeclarationContext::formalParameterList() {
  return getRuleContext<TypeScriptParser::FormalParameterListContext>(0);
}

TypeScriptParser::TypeAnnotationContext* TypeScriptParser::FunctionExpressionDeclarationContext::typeAnnotation() {
  return getRuleContext<TypeScriptParser::TypeAnnotationContext>(0);
}


size_t TypeScriptParser::FunctionExpressionDeclarationContext::getRuleIndex() const {
  return TypeScriptParser::RuleFunctionExpressionDeclaration;
}

void TypeScriptParser::FunctionExpressionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionExpressionDeclaration(this);
}

void TypeScriptParser::FunctionExpressionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionExpressionDeclaration(this);
}

TypeScriptParser::FunctionExpressionDeclarationContext* TypeScriptParser::functionExpressionDeclaration() {
  FunctionExpressionDeclarationContext *_localctx = _tracker.createInstance<FunctionExpressionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 252, TypeScriptParser::RuleFunctionExpressionDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1446);
    match(TypeScriptParser::Function_);
    setState(1448);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Identifier) {
      setState(1447);
      match(TypeScriptParser::Identifier);
    }
    setState(1450);
    match(TypeScriptParser::OpenParen);
    setState(1452);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 65808) != 0) || ((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 12718099) != 0)) {
      setState(1451);
      formalParameterList();
    }
    setState(1454);
    match(TypeScriptParser::CloseParen);
    setState(1456);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Colon) {
      setState(1455);
      typeAnnotation();
    }
    setState(1458);
    match(TypeScriptParser::OpenBrace);
    setState(1459);
    functionBody();
    setState(1460);
    match(TypeScriptParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SingleExpressionContext ------------------------------------------------------------------

TypeScriptParser::SingleExpressionContext::SingleExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t TypeScriptParser::SingleExpressionContext::getRuleIndex() const {
  return TypeScriptParser::RuleSingleExpression;
}

void TypeScriptParser::SingleExpressionContext::copyFrom(SingleExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- TemplateStringExpressionContext ------------------------------------------------------------------

TypeScriptParser::SingleExpressionContext* TypeScriptParser::TemplateStringExpressionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

TypeScriptParser::TemplateStringLiteralContext* TypeScriptParser::TemplateStringExpressionContext::templateStringLiteral() {
  return getRuleContext<TypeScriptParser::TemplateStringLiteralContext>(0);
}

TypeScriptParser::TemplateStringExpressionContext::TemplateStringExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::TemplateStringExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemplateStringExpression(this);
}
void TypeScriptParser::TemplateStringExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemplateStringExpression(this);
}
//----------------- TernaryExpressionContext ------------------------------------------------------------------

std::vector<TypeScriptParser::SingleExpressionContext *> TypeScriptParser::TernaryExpressionContext::singleExpression() {
  return getRuleContexts<TypeScriptParser::SingleExpressionContext>();
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::TernaryExpressionContext::singleExpression(size_t i) {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(i);
}

tree::TerminalNode* TypeScriptParser::TernaryExpressionContext::QuestionMark() {
  return getToken(TypeScriptParser::QuestionMark, 0);
}

tree::TerminalNode* TypeScriptParser::TernaryExpressionContext::Colon() {
  return getToken(TypeScriptParser::Colon, 0);
}

TypeScriptParser::TernaryExpressionContext::TernaryExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::TernaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTernaryExpression(this);
}
void TypeScriptParser::TernaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTernaryExpression(this);
}
//----------------- LogicalAndExpressionContext ------------------------------------------------------------------

std::vector<TypeScriptParser::SingleExpressionContext *> TypeScriptParser::LogicalAndExpressionContext::singleExpression() {
  return getRuleContexts<TypeScriptParser::SingleExpressionContext>();
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::LogicalAndExpressionContext::singleExpression(size_t i) {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(i);
}

tree::TerminalNode* TypeScriptParser::LogicalAndExpressionContext::And() {
  return getToken(TypeScriptParser::And, 0);
}

TypeScriptParser::LogicalAndExpressionContext::LogicalAndExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::LogicalAndExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalAndExpression(this);
}
void TypeScriptParser::LogicalAndExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalAndExpression(this);
}
//----------------- GeneratorsExpressionContext ------------------------------------------------------------------

TypeScriptParser::GeneratorBlockContext* TypeScriptParser::GeneratorsExpressionContext::generatorBlock() {
  return getRuleContext<TypeScriptParser::GeneratorBlockContext>(0);
}

TypeScriptParser::GeneratorsExpressionContext::GeneratorsExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::GeneratorsExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneratorsExpression(this);
}
void TypeScriptParser::GeneratorsExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneratorsExpression(this);
}
//----------------- PreIncrementExpressionContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::PreIncrementExpressionContext::PlusPlus() {
  return getToken(TypeScriptParser::PlusPlus, 0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::PreIncrementExpressionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

TypeScriptParser::PreIncrementExpressionContext::PreIncrementExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::PreIncrementExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreIncrementExpression(this);
}
void TypeScriptParser::PreIncrementExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreIncrementExpression(this);
}
//----------------- ObjectLiteralExpressionContext ------------------------------------------------------------------

TypeScriptParser::ObjectLiteralContext* TypeScriptParser::ObjectLiteralExpressionContext::objectLiteral() {
  return getRuleContext<TypeScriptParser::ObjectLiteralContext>(0);
}

TypeScriptParser::ObjectLiteralExpressionContext::ObjectLiteralExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::ObjectLiteralExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectLiteralExpression(this);
}
void TypeScriptParser::ObjectLiteralExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectLiteralExpression(this);
}
//----------------- InExpressionContext ------------------------------------------------------------------

std::vector<TypeScriptParser::SingleExpressionContext *> TypeScriptParser::InExpressionContext::singleExpression() {
  return getRuleContexts<TypeScriptParser::SingleExpressionContext>();
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::InExpressionContext::singleExpression(size_t i) {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(i);
}

tree::TerminalNode* TypeScriptParser::InExpressionContext::In() {
  return getToken(TypeScriptParser::In, 0);
}

TypeScriptParser::InExpressionContext::InExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::InExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInExpression(this);
}
void TypeScriptParser::InExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInExpression(this);
}
//----------------- LogicalOrExpressionContext ------------------------------------------------------------------

std::vector<TypeScriptParser::SingleExpressionContext *> TypeScriptParser::LogicalOrExpressionContext::singleExpression() {
  return getRuleContexts<TypeScriptParser::SingleExpressionContext>();
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::LogicalOrExpressionContext::singleExpression(size_t i) {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(i);
}

tree::TerminalNode* TypeScriptParser::LogicalOrExpressionContext::Or() {
  return getToken(TypeScriptParser::Or, 0);
}

TypeScriptParser::LogicalOrExpressionContext::LogicalOrExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::LogicalOrExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalOrExpression(this);
}
void TypeScriptParser::LogicalOrExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalOrExpression(this);
}
//----------------- GenericTypesContext ------------------------------------------------------------------

TypeScriptParser::TypeArgumentsContext* TypeScriptParser::GenericTypesContext::typeArguments() {
  return getRuleContext<TypeScriptParser::TypeArgumentsContext>(0);
}

TypeScriptParser::ExpressionSequenceContext* TypeScriptParser::GenericTypesContext::expressionSequence() {
  return getRuleContext<TypeScriptParser::ExpressionSequenceContext>(0);
}

TypeScriptParser::GenericTypesContext::GenericTypesContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::GenericTypesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericTypes(this);
}
void TypeScriptParser::GenericTypesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericTypes(this);
}
//----------------- NotExpressionContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::NotExpressionContext::Not() {
  return getToken(TypeScriptParser::Not, 0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::NotExpressionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

TypeScriptParser::NotExpressionContext::NotExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::NotExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNotExpression(this);
}
void TypeScriptParser::NotExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNotExpression(this);
}
//----------------- PreDecreaseExpressionContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::PreDecreaseExpressionContext::MinusMinus() {
  return getToken(TypeScriptParser::MinusMinus, 0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::PreDecreaseExpressionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

TypeScriptParser::PreDecreaseExpressionContext::PreDecreaseExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::PreDecreaseExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreDecreaseExpression(this);
}
void TypeScriptParser::PreDecreaseExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreDecreaseExpression(this);
}
//----------------- ArgumentsExpressionContext ------------------------------------------------------------------

TypeScriptParser::SingleExpressionContext* TypeScriptParser::ArgumentsExpressionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

TypeScriptParser::ArgumentsContext* TypeScriptParser::ArgumentsExpressionContext::arguments() {
  return getRuleContext<TypeScriptParser::ArgumentsContext>(0);
}

TypeScriptParser::ArgumentsExpressionContext::ArgumentsExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::ArgumentsExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgumentsExpression(this);
}
void TypeScriptParser::ArgumentsExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgumentsExpression(this);
}
//----------------- ThisExpressionContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::ThisExpressionContext::This() {
  return getToken(TypeScriptParser::This, 0);
}

TypeScriptParser::ThisExpressionContext::ThisExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::ThisExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThisExpression(this);
}
void TypeScriptParser::ThisExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThisExpression(this);
}
//----------------- FunctionExpressionContext ------------------------------------------------------------------

TypeScriptParser::FunctionExpressionDeclarationContext* TypeScriptParser::FunctionExpressionContext::functionExpressionDeclaration() {
  return getRuleContext<TypeScriptParser::FunctionExpressionDeclarationContext>(0);
}

TypeScriptParser::FunctionExpressionContext::FunctionExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::FunctionExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionExpression(this);
}
void TypeScriptParser::FunctionExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionExpression(this);
}
//----------------- UnaryMinusExpressionContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::UnaryMinusExpressionContext::Minus() {
  return getToken(TypeScriptParser::Minus, 0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::UnaryMinusExpressionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

TypeScriptParser::UnaryMinusExpressionContext::UnaryMinusExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::UnaryMinusExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryMinusExpression(this);
}
void TypeScriptParser::UnaryMinusExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryMinusExpression(this);
}
//----------------- AssignmentExpressionContext ------------------------------------------------------------------

std::vector<TypeScriptParser::SingleExpressionContext *> TypeScriptParser::AssignmentExpressionContext::singleExpression() {
  return getRuleContexts<TypeScriptParser::SingleExpressionContext>();
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::AssignmentExpressionContext::singleExpression(size_t i) {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(i);
}

tree::TerminalNode* TypeScriptParser::AssignmentExpressionContext::Assign() {
  return getToken(TypeScriptParser::Assign, 0);
}

TypeScriptParser::AssignmentExpressionContext::AssignmentExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::AssignmentExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentExpression(this);
}
void TypeScriptParser::AssignmentExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentExpression(this);
}
//----------------- PostDecreaseExpressionContext ------------------------------------------------------------------

TypeScriptParser::SingleExpressionContext* TypeScriptParser::PostDecreaseExpressionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* TypeScriptParser::PostDecreaseExpressionContext::MinusMinus() {
  return getToken(TypeScriptParser::MinusMinus, 0);
}

TypeScriptParser::PostDecreaseExpressionContext::PostDecreaseExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::PostDecreaseExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostDecreaseExpression(this);
}
void TypeScriptParser::PostDecreaseExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostDecreaseExpression(this);
}
//----------------- TypeofExpressionContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::TypeofExpressionContext::Typeof() {
  return getToken(TypeScriptParser::Typeof, 0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::TypeofExpressionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

TypeScriptParser::TypeofExpressionContext::TypeofExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::TypeofExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeofExpression(this);
}
void TypeScriptParser::TypeofExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeofExpression(this);
}
//----------------- InstanceofExpressionContext ------------------------------------------------------------------

std::vector<TypeScriptParser::SingleExpressionContext *> TypeScriptParser::InstanceofExpressionContext::singleExpression() {
  return getRuleContexts<TypeScriptParser::SingleExpressionContext>();
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::InstanceofExpressionContext::singleExpression(size_t i) {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(i);
}

tree::TerminalNode* TypeScriptParser::InstanceofExpressionContext::Instanceof() {
  return getToken(TypeScriptParser::Instanceof, 0);
}

TypeScriptParser::InstanceofExpressionContext::InstanceofExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::InstanceofExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInstanceofExpression(this);
}
void TypeScriptParser::InstanceofExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInstanceofExpression(this);
}
//----------------- UnaryPlusExpressionContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::UnaryPlusExpressionContext::Plus() {
  return getToken(TypeScriptParser::Plus, 0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::UnaryPlusExpressionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

TypeScriptParser::UnaryPlusExpressionContext::UnaryPlusExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::UnaryPlusExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryPlusExpression(this);
}
void TypeScriptParser::UnaryPlusExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryPlusExpression(this);
}
//----------------- DeleteExpressionContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::DeleteExpressionContext::Delete() {
  return getToken(TypeScriptParser::Delete, 0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::DeleteExpressionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

TypeScriptParser::DeleteExpressionContext::DeleteExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::DeleteExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeleteExpression(this);
}
void TypeScriptParser::DeleteExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeleteExpression(this);
}
//----------------- GeneratorsFunctionExpressionContext ------------------------------------------------------------------

TypeScriptParser::GeneratorFunctionDeclarationContext* TypeScriptParser::GeneratorsFunctionExpressionContext::generatorFunctionDeclaration() {
  return getRuleContext<TypeScriptParser::GeneratorFunctionDeclarationContext>(0);
}

TypeScriptParser::GeneratorsFunctionExpressionContext::GeneratorsFunctionExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::GeneratorsFunctionExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneratorsFunctionExpression(this);
}
void TypeScriptParser::GeneratorsFunctionExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneratorsFunctionExpression(this);
}
//----------------- ArrowFunctionExpressionContext ------------------------------------------------------------------

TypeScriptParser::ArrowFunctionDeclarationContext* TypeScriptParser::ArrowFunctionExpressionContext::arrowFunctionDeclaration() {
  return getRuleContext<TypeScriptParser::ArrowFunctionDeclarationContext>(0);
}

TypeScriptParser::ArrowFunctionExpressionContext::ArrowFunctionExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::ArrowFunctionExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrowFunctionExpression(this);
}
void TypeScriptParser::ArrowFunctionExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrowFunctionExpression(this);
}
//----------------- IteratorsExpressionContext ------------------------------------------------------------------

TypeScriptParser::IteratorBlockContext* TypeScriptParser::IteratorsExpressionContext::iteratorBlock() {
  return getRuleContext<TypeScriptParser::IteratorBlockContext>(0);
}

TypeScriptParser::IteratorsExpressionContext::IteratorsExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::IteratorsExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIteratorsExpression(this);
}
void TypeScriptParser::IteratorsExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIteratorsExpression(this);
}
//----------------- EqualityExpressionContext ------------------------------------------------------------------

std::vector<TypeScriptParser::SingleExpressionContext *> TypeScriptParser::EqualityExpressionContext::singleExpression() {
  return getRuleContexts<TypeScriptParser::SingleExpressionContext>();
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::EqualityExpressionContext::singleExpression(size_t i) {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(i);
}

tree::TerminalNode* TypeScriptParser::EqualityExpressionContext::Equals_() {
  return getToken(TypeScriptParser::Equals_, 0);
}

tree::TerminalNode* TypeScriptParser::EqualityExpressionContext::NotEquals() {
  return getToken(TypeScriptParser::NotEquals, 0);
}

tree::TerminalNode* TypeScriptParser::EqualityExpressionContext::IdentityEquals() {
  return getToken(TypeScriptParser::IdentityEquals, 0);
}

tree::TerminalNode* TypeScriptParser::EqualityExpressionContext::IdentityNotEquals() {
  return getToken(TypeScriptParser::IdentityNotEquals, 0);
}

TypeScriptParser::EqualityExpressionContext::EqualityExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::EqualityExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEqualityExpression(this);
}
void TypeScriptParser::EqualityExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEqualityExpression(this);
}
//----------------- BitXOrExpressionContext ------------------------------------------------------------------

std::vector<TypeScriptParser::SingleExpressionContext *> TypeScriptParser::BitXOrExpressionContext::singleExpression() {
  return getRuleContexts<TypeScriptParser::SingleExpressionContext>();
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::BitXOrExpressionContext::singleExpression(size_t i) {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(i);
}

tree::TerminalNode* TypeScriptParser::BitXOrExpressionContext::BitXOr() {
  return getToken(TypeScriptParser::BitXOr, 0);
}

TypeScriptParser::BitXOrExpressionContext::BitXOrExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::BitXOrExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitXOrExpression(this);
}
void TypeScriptParser::BitXOrExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitXOrExpression(this);
}
//----------------- CastAsExpressionContext ------------------------------------------------------------------

TypeScriptParser::SingleExpressionContext* TypeScriptParser::CastAsExpressionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* TypeScriptParser::CastAsExpressionContext::As() {
  return getToken(TypeScriptParser::As, 0);
}

TypeScriptParser::AsExpressionContext* TypeScriptParser::CastAsExpressionContext::asExpression() {
  return getRuleContext<TypeScriptParser::AsExpressionContext>(0);
}

TypeScriptParser::CastAsExpressionContext::CastAsExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::CastAsExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCastAsExpression(this);
}
void TypeScriptParser::CastAsExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCastAsExpression(this);
}
//----------------- SuperExpressionContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::SuperExpressionContext::Super() {
  return getToken(TypeScriptParser::Super, 0);
}

TypeScriptParser::SuperExpressionContext::SuperExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::SuperExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSuperExpression(this);
}
void TypeScriptParser::SuperExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSuperExpression(this);
}
//----------------- MultiplicativeExpressionContext ------------------------------------------------------------------

std::vector<TypeScriptParser::SingleExpressionContext *> TypeScriptParser::MultiplicativeExpressionContext::singleExpression() {
  return getRuleContexts<TypeScriptParser::SingleExpressionContext>();
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::MultiplicativeExpressionContext::singleExpression(size_t i) {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(i);
}

tree::TerminalNode* TypeScriptParser::MultiplicativeExpressionContext::Multiply() {
  return getToken(TypeScriptParser::Multiply, 0);
}

tree::TerminalNode* TypeScriptParser::MultiplicativeExpressionContext::Divide() {
  return getToken(TypeScriptParser::Divide, 0);
}

tree::TerminalNode* TypeScriptParser::MultiplicativeExpressionContext::Modulus() {
  return getToken(TypeScriptParser::Modulus, 0);
}

TypeScriptParser::MultiplicativeExpressionContext::MultiplicativeExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::MultiplicativeExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiplicativeExpression(this);
}
void TypeScriptParser::MultiplicativeExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiplicativeExpression(this);
}
//----------------- BitShiftExpressionContext ------------------------------------------------------------------

std::vector<TypeScriptParser::SingleExpressionContext *> TypeScriptParser::BitShiftExpressionContext::singleExpression() {
  return getRuleContexts<TypeScriptParser::SingleExpressionContext>();
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::BitShiftExpressionContext::singleExpression(size_t i) {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(i);
}

tree::TerminalNode* TypeScriptParser::BitShiftExpressionContext::LeftShiftArithmetic() {
  return getToken(TypeScriptParser::LeftShiftArithmetic, 0);
}

tree::TerminalNode* TypeScriptParser::BitShiftExpressionContext::RightShiftArithmetic() {
  return getToken(TypeScriptParser::RightShiftArithmetic, 0);
}

tree::TerminalNode* TypeScriptParser::BitShiftExpressionContext::RightShiftLogical() {
  return getToken(TypeScriptParser::RightShiftLogical, 0);
}

TypeScriptParser::BitShiftExpressionContext::BitShiftExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::BitShiftExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitShiftExpression(this);
}
void TypeScriptParser::BitShiftExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitShiftExpression(this);
}
//----------------- ParenthesizedExpressionContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::ParenthesizedExpressionContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

TypeScriptParser::ExpressionSequenceContext* TypeScriptParser::ParenthesizedExpressionContext::expressionSequence() {
  return getRuleContext<TypeScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* TypeScriptParser::ParenthesizedExpressionContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

TypeScriptParser::ParenthesizedExpressionContext::ParenthesizedExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::ParenthesizedExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParenthesizedExpression(this);
}
void TypeScriptParser::ParenthesizedExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParenthesizedExpression(this);
}
//----------------- AdditiveExpressionContext ------------------------------------------------------------------

std::vector<TypeScriptParser::SingleExpressionContext *> TypeScriptParser::AdditiveExpressionContext::singleExpression() {
  return getRuleContexts<TypeScriptParser::SingleExpressionContext>();
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::AdditiveExpressionContext::singleExpression(size_t i) {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(i);
}

tree::TerminalNode* TypeScriptParser::AdditiveExpressionContext::Plus() {
  return getToken(TypeScriptParser::Plus, 0);
}

tree::TerminalNode* TypeScriptParser::AdditiveExpressionContext::Minus() {
  return getToken(TypeScriptParser::Minus, 0);
}

TypeScriptParser::AdditiveExpressionContext::AdditiveExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::AdditiveExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAdditiveExpression(this);
}
void TypeScriptParser::AdditiveExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAdditiveExpression(this);
}
//----------------- RelationalExpressionContext ------------------------------------------------------------------

std::vector<TypeScriptParser::SingleExpressionContext *> TypeScriptParser::RelationalExpressionContext::singleExpression() {
  return getRuleContexts<TypeScriptParser::SingleExpressionContext>();
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::RelationalExpressionContext::singleExpression(size_t i) {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(i);
}

tree::TerminalNode* TypeScriptParser::RelationalExpressionContext::LessThan() {
  return getToken(TypeScriptParser::LessThan, 0);
}

tree::TerminalNode* TypeScriptParser::RelationalExpressionContext::MoreThan() {
  return getToken(TypeScriptParser::MoreThan, 0);
}

tree::TerminalNode* TypeScriptParser::RelationalExpressionContext::LessThanEquals() {
  return getToken(TypeScriptParser::LessThanEquals, 0);
}

tree::TerminalNode* TypeScriptParser::RelationalExpressionContext::GreaterThanEquals() {
  return getToken(TypeScriptParser::GreaterThanEquals, 0);
}

TypeScriptParser::RelationalExpressionContext::RelationalExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::RelationalExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelationalExpression(this);
}
void TypeScriptParser::RelationalExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelationalExpression(this);
}
//----------------- PostIncrementExpressionContext ------------------------------------------------------------------

TypeScriptParser::SingleExpressionContext* TypeScriptParser::PostIncrementExpressionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* TypeScriptParser::PostIncrementExpressionContext::PlusPlus() {
  return getToken(TypeScriptParser::PlusPlus, 0);
}

TypeScriptParser::PostIncrementExpressionContext::PostIncrementExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::PostIncrementExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostIncrementExpression(this);
}
void TypeScriptParser::PostIncrementExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostIncrementExpression(this);
}
//----------------- YieldExpressionContext ------------------------------------------------------------------

TypeScriptParser::YieldStatementContext* TypeScriptParser::YieldExpressionContext::yieldStatement() {
  return getRuleContext<TypeScriptParser::YieldStatementContext>(0);
}

TypeScriptParser::YieldExpressionContext::YieldExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::YieldExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterYieldExpression(this);
}
void TypeScriptParser::YieldExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitYieldExpression(this);
}
//----------------- BitNotExpressionContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::BitNotExpressionContext::BitNot() {
  return getToken(TypeScriptParser::BitNot, 0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::BitNotExpressionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

TypeScriptParser::BitNotExpressionContext::BitNotExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::BitNotExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitNotExpression(this);
}
void TypeScriptParser::BitNotExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitNotExpression(this);
}
//----------------- NewExpressionContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::NewExpressionContext::New() {
  return getToken(TypeScriptParser::New, 0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::NewExpressionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

TypeScriptParser::ArgumentsContext* TypeScriptParser::NewExpressionContext::arguments() {
  return getRuleContext<TypeScriptParser::ArgumentsContext>(0);
}

TypeScriptParser::TypeArgumentsContext* TypeScriptParser::NewExpressionContext::typeArguments() {
  return getRuleContext<TypeScriptParser::TypeArgumentsContext>(0);
}

TypeScriptParser::NewExpressionContext::NewExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::NewExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNewExpression(this);
}
void TypeScriptParser::NewExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNewExpression(this);
}
//----------------- LiteralExpressionContext ------------------------------------------------------------------

TypeScriptParser::LiteralContext* TypeScriptParser::LiteralExpressionContext::literal() {
  return getRuleContext<TypeScriptParser::LiteralContext>(0);
}

TypeScriptParser::LiteralExpressionContext::LiteralExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::LiteralExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteralExpression(this);
}
void TypeScriptParser::LiteralExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteralExpression(this);
}
//----------------- ArrayLiteralExpressionContext ------------------------------------------------------------------

TypeScriptParser::ArrayLiteralContext* TypeScriptParser::ArrayLiteralExpressionContext::arrayLiteral() {
  return getRuleContext<TypeScriptParser::ArrayLiteralContext>(0);
}

TypeScriptParser::ArrayLiteralExpressionContext::ArrayLiteralExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::ArrayLiteralExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayLiteralExpression(this);
}
void TypeScriptParser::ArrayLiteralExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayLiteralExpression(this);
}
//----------------- MemberDotExpressionContext ------------------------------------------------------------------

TypeScriptParser::SingleExpressionContext* TypeScriptParser::MemberDotExpressionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* TypeScriptParser::MemberDotExpressionContext::Dot() {
  return getToken(TypeScriptParser::Dot, 0);
}

TypeScriptParser::IdentifierNameContext* TypeScriptParser::MemberDotExpressionContext::identifierName() {
  return getRuleContext<TypeScriptParser::IdentifierNameContext>(0);
}

tree::TerminalNode* TypeScriptParser::MemberDotExpressionContext::Not() {
  return getToken(TypeScriptParser::Not, 0);
}

TypeScriptParser::NestedTypeGenericContext* TypeScriptParser::MemberDotExpressionContext::nestedTypeGeneric() {
  return getRuleContext<TypeScriptParser::NestedTypeGenericContext>(0);
}

TypeScriptParser::MemberDotExpressionContext::MemberDotExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::MemberDotExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemberDotExpression(this);
}
void TypeScriptParser::MemberDotExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemberDotExpression(this);
}
//----------------- MemberIndexExpressionContext ------------------------------------------------------------------

TypeScriptParser::SingleExpressionContext* TypeScriptParser::MemberIndexExpressionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* TypeScriptParser::MemberIndexExpressionContext::OpenBracket() {
  return getToken(TypeScriptParser::OpenBracket, 0);
}

TypeScriptParser::ExpressionSequenceContext* TypeScriptParser::MemberIndexExpressionContext::expressionSequence() {
  return getRuleContext<TypeScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* TypeScriptParser::MemberIndexExpressionContext::CloseBracket() {
  return getToken(TypeScriptParser::CloseBracket, 0);
}

TypeScriptParser::MemberIndexExpressionContext::MemberIndexExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::MemberIndexExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemberIndexExpression(this);
}
void TypeScriptParser::MemberIndexExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemberIndexExpression(this);
}
//----------------- IdentifierExpressionContext ------------------------------------------------------------------

TypeScriptParser::IdentifierNameContext* TypeScriptParser::IdentifierExpressionContext::identifierName() {
  return getRuleContext<TypeScriptParser::IdentifierNameContext>(0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::IdentifierExpressionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

TypeScriptParser::IdentifierExpressionContext::IdentifierExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::IdentifierExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierExpression(this);
}
void TypeScriptParser::IdentifierExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierExpression(this);
}
//----------------- BitAndExpressionContext ------------------------------------------------------------------

std::vector<TypeScriptParser::SingleExpressionContext *> TypeScriptParser::BitAndExpressionContext::singleExpression() {
  return getRuleContexts<TypeScriptParser::SingleExpressionContext>();
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::BitAndExpressionContext::singleExpression(size_t i) {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(i);
}

tree::TerminalNode* TypeScriptParser::BitAndExpressionContext::BitAnd() {
  return getToken(TypeScriptParser::BitAnd, 0);
}

TypeScriptParser::BitAndExpressionContext::BitAndExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::BitAndExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitAndExpression(this);
}
void TypeScriptParser::BitAndExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitAndExpression(this);
}
//----------------- BitOrExpressionContext ------------------------------------------------------------------

std::vector<TypeScriptParser::SingleExpressionContext *> TypeScriptParser::BitOrExpressionContext::singleExpression() {
  return getRuleContexts<TypeScriptParser::SingleExpressionContext>();
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::BitOrExpressionContext::singleExpression(size_t i) {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(i);
}

tree::TerminalNode* TypeScriptParser::BitOrExpressionContext::BitOr() {
  return getToken(TypeScriptParser::BitOr, 0);
}

TypeScriptParser::BitOrExpressionContext::BitOrExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::BitOrExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitOrExpression(this);
}
void TypeScriptParser::BitOrExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitOrExpression(this);
}
//----------------- AssignmentOperatorExpressionContext ------------------------------------------------------------------

std::vector<TypeScriptParser::SingleExpressionContext *> TypeScriptParser::AssignmentOperatorExpressionContext::singleExpression() {
  return getRuleContexts<TypeScriptParser::SingleExpressionContext>();
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::AssignmentOperatorExpressionContext::singleExpression(size_t i) {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(i);
}

TypeScriptParser::AssignmentOperatorContext* TypeScriptParser::AssignmentOperatorExpressionContext::assignmentOperator() {
  return getRuleContext<TypeScriptParser::AssignmentOperatorContext>(0);
}

TypeScriptParser::AssignmentOperatorExpressionContext::AssignmentOperatorExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::AssignmentOperatorExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentOperatorExpression(this);
}
void TypeScriptParser::AssignmentOperatorExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentOperatorExpression(this);
}
//----------------- VoidExpressionContext ------------------------------------------------------------------

tree::TerminalNode* TypeScriptParser::VoidExpressionContext::Void() {
  return getToken(TypeScriptParser::Void, 0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::VoidExpressionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

TypeScriptParser::VoidExpressionContext::VoidExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void TypeScriptParser::VoidExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVoidExpression(this);
}
void TypeScriptParser::VoidExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVoidExpression(this);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::singleExpression() {
   return singleExpression(0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::singleExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  TypeScriptParser::SingleExpressionContext *_localctx = _tracker.createInstance<SingleExpressionContext>(_ctx, parentState);
  TypeScriptParser::SingleExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 254;
  enterRecursionRule(_localctx, 254, TypeScriptParser::RuleSingleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1516);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 195, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<FunctionExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(1463);
      functionExpressionDeclaration();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<ArrowFunctionExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1464);
      arrowFunctionDeclaration();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<NewExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1465);
      match(TypeScriptParser::New);
      setState(1466);
      singleExpression(0);
      setState(1468);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TypeScriptParser::LessThan) {
        setState(1467);
        typeArguments();
      }
      setState(1470);
      arguments();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<NewExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1472);
      match(TypeScriptParser::New);
      setState(1473);
      singleExpression(0);
      setState(1475);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 192, _ctx)) {
      case 1: {
        setState(1474);
        typeArguments();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<DeleteExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1477);
      match(TypeScriptParser::Delete);
      setState(1478);
      singleExpression(38);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<VoidExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1479);
      match(TypeScriptParser::Void);
      setState(1480);
      singleExpression(37);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<TypeofExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1481);
      match(TypeScriptParser::Typeof);
      setState(1482);
      singleExpression(36);
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<PreIncrementExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1483);
      match(TypeScriptParser::PlusPlus);
      setState(1484);
      singleExpression(35);
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<PreDecreaseExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1485);
      match(TypeScriptParser::MinusMinus);
      setState(1486);
      singleExpression(34);
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<UnaryPlusExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1487);
      match(TypeScriptParser::Plus);
      setState(1488);
      singleExpression(33);
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<UnaryMinusExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1489);
      match(TypeScriptParser::Minus);
      setState(1490);
      singleExpression(32);
      break;
    }

    case 12: {
      _localctx = _tracker.createInstance<BitNotExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1491);
      match(TypeScriptParser::BitNot);
      setState(1492);
      singleExpression(31);
      break;
    }

    case 13: {
      _localctx = _tracker.createInstance<NotExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1493);
      match(TypeScriptParser::Not);
      setState(1494);
      singleExpression(30);
      break;
    }

    case 14: {
      _localctx = _tracker.createInstance<IteratorsExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1495);
      iteratorBlock();
      break;
    }

    case 15: {
      _localctx = _tracker.createInstance<GeneratorsExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1496);
      generatorBlock();
      break;
    }

    case 16: {
      _localctx = _tracker.createInstance<GeneratorsFunctionExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1497);
      generatorFunctionDeclaration();
      break;
    }

    case 17: {
      _localctx = _tracker.createInstance<YieldExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1498);
      yieldStatement();
      break;
    }

    case 18: {
      _localctx = _tracker.createInstance<ThisExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1499);
      match(TypeScriptParser::This);
      break;
    }

    case 19: {
      _localctx = _tracker.createInstance<IdentifierExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1500);
      identifierName();
      setState(1502);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 193, _ctx)) {
      case 1: {
        setState(1501);
        singleExpression(0);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 20: {
      _localctx = _tracker.createInstance<SuperExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1504);
      match(TypeScriptParser::Super);
      break;
    }

    case 21: {
      _localctx = _tracker.createInstance<LiteralExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1505);
      literal();
      break;
    }

    case 22: {
      _localctx = _tracker.createInstance<ArrayLiteralExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1506);
      arrayLiteral();
      break;
    }

    case 23: {
      _localctx = _tracker.createInstance<ObjectLiteralExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1507);
      objectLiteral();
      break;
    }

    case 24: {
      _localctx = _tracker.createInstance<ParenthesizedExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1508);
      match(TypeScriptParser::OpenParen);
      setState(1509);
      expressionSequence();
      setState(1510);
      match(TypeScriptParser::CloseParen);
      break;
    }

    case 25: {
      _localctx = _tracker.createInstance<GenericTypesContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1512);
      typeArguments();
      setState(1514);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 194, _ctx)) {
      case 1: {
        setState(1513);
        expressionSequence();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(1596);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 199, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(1594);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 198, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<MultiplicativeExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1518);

          if (!(precpred(_ctx, 29))) throw FailedPredicateException(this, "precpred(_ctx, 29)");
          setState(1519);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 117440512) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1520);
          singleExpression(30);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<AdditiveExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1521);

          if (!(precpred(_ctx, 28))) throw FailedPredicateException(this, "precpred(_ctx, 28)");
          setState(1522);
          _la = _input->LA(1);
          if (!(_la == TypeScriptParser::Plus

          || _la == TypeScriptParser::Minus)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1523);
          singleExpression(29);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<BitShiftExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1524);

          if (!(precpred(_ctx, 27))) throw FailedPredicateException(this, "precpred(_ctx, 27)");
          setState(1525);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 939524096) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1526);
          singleExpression(28);
          break;
        }

        case 4: {
          auto newContext = _tracker.createInstance<RelationalExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1527);

          if (!(precpred(_ctx, 26))) throw FailedPredicateException(this, "precpred(_ctx, 26)");
          setState(1528);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 16106127360) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1529);
          singleExpression(27);
          break;
        }

        case 5: {
          auto newContext = _tracker.createInstance<InstanceofExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1530);

          if (!(precpred(_ctx, 25))) throw FailedPredicateException(this, "precpred(_ctx, 25)");
          setState(1531);
          match(TypeScriptParser::Instanceof);
          setState(1532);
          singleExpression(26);
          break;
        }

        case 6: {
          auto newContext = _tracker.createInstance<InExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1533);

          if (!(precpred(_ctx, 24))) throw FailedPredicateException(this, "precpred(_ctx, 24)");
          setState(1534);
          match(TypeScriptParser::In);
          setState(1535);
          singleExpression(25);
          break;
        }

        case 7: {
          auto newContext = _tracker.createInstance<EqualityExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1536);

          if (!(precpred(_ctx, 23))) throw FailedPredicateException(this, "precpred(_ctx, 23)");
          setState(1537);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 257698037760) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1538);
          singleExpression(24);
          break;
        }

        case 8: {
          auto newContext = _tracker.createInstance<BitAndExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1539);

          if (!(precpred(_ctx, 22))) throw FailedPredicateException(this, "precpred(_ctx, 22)");
          setState(1540);
          match(TypeScriptParser::BitAnd);
          setState(1541);
          singleExpression(23);
          break;
        }

        case 9: {
          auto newContext = _tracker.createInstance<BitXOrExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1542);

          if (!(precpred(_ctx, 21))) throw FailedPredicateException(this, "precpred(_ctx, 21)");
          setState(1543);
          match(TypeScriptParser::BitXOr);
          setState(1544);
          singleExpression(22);
          break;
        }

        case 10: {
          auto newContext = _tracker.createInstance<BitOrExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1545);

          if (!(precpred(_ctx, 20))) throw FailedPredicateException(this, "precpred(_ctx, 20)");
          setState(1546);
          match(TypeScriptParser::BitOr);
          setState(1547);
          singleExpression(21);
          break;
        }

        case 11: {
          auto newContext = _tracker.createInstance<LogicalAndExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1548);

          if (!(precpred(_ctx, 19))) throw FailedPredicateException(this, "precpred(_ctx, 19)");
          setState(1549);
          match(TypeScriptParser::And);
          setState(1550);
          singleExpression(20);
          break;
        }

        case 12: {
          auto newContext = _tracker.createInstance<LogicalOrExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1551);

          if (!(precpred(_ctx, 18))) throw FailedPredicateException(this, "precpred(_ctx, 18)");
          setState(1552);
          match(TypeScriptParser::Or);
          setState(1553);
          singleExpression(19);
          break;
        }

        case 13: {
          auto newContext = _tracker.createInstance<TernaryExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1554);

          if (!(precpred(_ctx, 17))) throw FailedPredicateException(this, "precpred(_ctx, 17)");
          setState(1555);
          match(TypeScriptParser::QuestionMark);
          setState(1556);
          singleExpression(0);
          setState(1557);
          match(TypeScriptParser::Colon);
          setState(1558);
          singleExpression(18);
          break;
        }

        case 14: {
          auto newContext = _tracker.createInstance<AssignmentExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1560);

          if (!(precpred(_ctx, 16))) throw FailedPredicateException(this, "precpred(_ctx, 16)");
          setState(1561);
          match(TypeScriptParser::Assign);
          setState(1562);
          singleExpression(17);
          break;
        }

        case 15: {
          auto newContext = _tracker.createInstance<AssignmentOperatorExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1563);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(1564);
          assignmentOperator();
          setState(1565);
          singleExpression(16);
          break;
        }

        case 16: {
          auto newContext = _tracker.createInstance<MemberIndexExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1567);

          if (!(precpred(_ctx, 45))) throw FailedPredicateException(this, "precpred(_ctx, 45)");
          setState(1568);
          match(TypeScriptParser::OpenBracket);
          setState(1569);
          expressionSequence();
          setState(1570);
          match(TypeScriptParser::CloseBracket);
          break;
        }

        case 17: {
          auto newContext = _tracker.createInstance<MemberDotExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1572);

          if (!(precpred(_ctx, 44))) throw FailedPredicateException(this, "precpred(_ctx, 44)");
          setState(1574);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == TypeScriptParser::Not) {
            setState(1573);
            match(TypeScriptParser::Not);
          }
          setState(1576);
          match(TypeScriptParser::Dot);
          setState(1577);
          identifierName();
          setState(1579);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 197, _ctx)) {
          case 1: {
            setState(1578);
            nestedTypeGeneric();
            break;
          }

          default:
            break;
          }
          break;
        }

        case 18: {
          auto newContext = _tracker.createInstance<ArgumentsExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1581);

          if (!(precpred(_ctx, 41))) throw FailedPredicateException(this, "precpred(_ctx, 41)");
          setState(1582);
          arguments();
          break;
        }

        case 19: {
          auto newContext = _tracker.createInstance<PostIncrementExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1583);

          if (!(precpred(_ctx, 40))) throw FailedPredicateException(this, "precpred(_ctx, 40)");
          setState(1584);

          if (!(this->notLineTerminator())) throw FailedPredicateException(this, "this->notLineTerminator()");
          setState(1585);
          match(TypeScriptParser::PlusPlus);
          break;
        }

        case 20: {
          auto newContext = _tracker.createInstance<PostDecreaseExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1586);

          if (!(precpred(_ctx, 39))) throw FailedPredicateException(this, "precpred(_ctx, 39)");
          setState(1587);

          if (!(this->notLineTerminator())) throw FailedPredicateException(this, "this->notLineTerminator()");
          setState(1588);
          match(TypeScriptParser::MinusMinus);
          break;
        }

        case 21: {
          auto newContext = _tracker.createInstance<TemplateStringExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1589);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(1590);
          templateStringLiteral();
          break;
        }

        case 22: {
          auto newContext = _tracker.createInstance<CastAsExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1591);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(1592);
          match(TypeScriptParser::As);
          setState(1593);
          asExpression();
          break;
        }

        default:
          break;
        } 
      }
      setState(1598);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 199, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- AsExpressionContext ------------------------------------------------------------------

TypeScriptParser::AsExpressionContext::AsExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::PredefinedTypeContext* TypeScriptParser::AsExpressionContext::predefinedType() {
  return getRuleContext<TypeScriptParser::PredefinedTypeContext>(0);
}

tree::TerminalNode* TypeScriptParser::AsExpressionContext::OpenBracket() {
  return getToken(TypeScriptParser::OpenBracket, 0);
}

tree::TerminalNode* TypeScriptParser::AsExpressionContext::CloseBracket() {
  return getToken(TypeScriptParser::CloseBracket, 0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::AsExpressionContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}


size_t TypeScriptParser::AsExpressionContext::getRuleIndex() const {
  return TypeScriptParser::RuleAsExpression;
}

void TypeScriptParser::AsExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAsExpression(this);
}

void TypeScriptParser::AsExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAsExpression(this);
}

TypeScriptParser::AsExpressionContext* TypeScriptParser::asExpression() {
  AsExpressionContext *_localctx = _tracker.createInstance<AsExpressionContext>(_ctx, getState());
  enterRule(_localctx, 256, TypeScriptParser::RuleAsExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1605);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 201, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1599);
      predefinedType();
      setState(1602);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx)) {
      case 1: {
        setState(1600);
        match(TypeScriptParser::OpenBracket);
        setState(1601);
        match(TypeScriptParser::CloseBracket);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1604);
      singleExpression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrowFunctionDeclarationContext ------------------------------------------------------------------

TypeScriptParser::ArrowFunctionDeclarationContext::ArrowFunctionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::ArrowFunctionParametersContext* TypeScriptParser::ArrowFunctionDeclarationContext::arrowFunctionParameters() {
  return getRuleContext<TypeScriptParser::ArrowFunctionParametersContext>(0);
}

tree::TerminalNode* TypeScriptParser::ArrowFunctionDeclarationContext::ARROW() {
  return getToken(TypeScriptParser::ARROW, 0);
}

TypeScriptParser::ArrowFunctionBodyContext* TypeScriptParser::ArrowFunctionDeclarationContext::arrowFunctionBody() {
  return getRuleContext<TypeScriptParser::ArrowFunctionBodyContext>(0);
}

tree::TerminalNode* TypeScriptParser::ArrowFunctionDeclarationContext::Async() {
  return getToken(TypeScriptParser::Async, 0);
}

TypeScriptParser::TypeAnnotationContext* TypeScriptParser::ArrowFunctionDeclarationContext::typeAnnotation() {
  return getRuleContext<TypeScriptParser::TypeAnnotationContext>(0);
}


size_t TypeScriptParser::ArrowFunctionDeclarationContext::getRuleIndex() const {
  return TypeScriptParser::RuleArrowFunctionDeclaration;
}

void TypeScriptParser::ArrowFunctionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrowFunctionDeclaration(this);
}

void TypeScriptParser::ArrowFunctionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrowFunctionDeclaration(this);
}

TypeScriptParser::ArrowFunctionDeclarationContext* TypeScriptParser::arrowFunctionDeclaration() {
  ArrowFunctionDeclarationContext *_localctx = _tracker.createInstance<ArrowFunctionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 258, TypeScriptParser::RuleArrowFunctionDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1608);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Async) {
      setState(1607);
      match(TypeScriptParser::Async);
    }
    setState(1610);
    arrowFunctionParameters();
    setState(1612);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TypeScriptParser::Colon) {
      setState(1611);
      typeAnnotation();
    }
    setState(1614);
    match(TypeScriptParser::ARROW);
    setState(1615);
    arrowFunctionBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrowFunctionParametersContext ------------------------------------------------------------------

TypeScriptParser::ArrowFunctionParametersContext::ArrowFunctionParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::ArrowFunctionParametersContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

tree::TerminalNode* TypeScriptParser::ArrowFunctionParametersContext::OpenParen() {
  return getToken(TypeScriptParser::OpenParen, 0);
}

tree::TerminalNode* TypeScriptParser::ArrowFunctionParametersContext::CloseParen() {
  return getToken(TypeScriptParser::CloseParen, 0);
}

TypeScriptParser::FormalParameterListContext* TypeScriptParser::ArrowFunctionParametersContext::formalParameterList() {
  return getRuleContext<TypeScriptParser::FormalParameterListContext>(0);
}


size_t TypeScriptParser::ArrowFunctionParametersContext::getRuleIndex() const {
  return TypeScriptParser::RuleArrowFunctionParameters;
}

void TypeScriptParser::ArrowFunctionParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrowFunctionParameters(this);
}

void TypeScriptParser::ArrowFunctionParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrowFunctionParameters(this);
}

TypeScriptParser::ArrowFunctionParametersContext* TypeScriptParser::arrowFunctionParameters() {
  ArrowFunctionParametersContext *_localctx = _tracker.createInstance<ArrowFunctionParametersContext>(_ctx, getState());
  enterRule(_localctx, 260, TypeScriptParser::RuleArrowFunctionParameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1623);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TypeScriptParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(1617);
        match(TypeScriptParser::Identifier);
        break;
      }

      case TypeScriptParser::OpenParen: {
        enterOuterAlt(_localctx, 2);
        setState(1618);
        match(TypeScriptParser::OpenParen);
        setState(1620);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 65808) != 0) || ((((_la - 101) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 101)) & 12718099) != 0)) {
          setState(1619);
          formalParameterList();
        }
        setState(1622);
        match(TypeScriptParser::CloseParen);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrowFunctionBodyContext ------------------------------------------------------------------

TypeScriptParser::ArrowFunctionBodyContext::ArrowFunctionBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::ArrowFunctionBodyContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* TypeScriptParser::ArrowFunctionBodyContext::OpenBrace() {
  return getToken(TypeScriptParser::OpenBrace, 0);
}

TypeScriptParser::FunctionBodyContext* TypeScriptParser::ArrowFunctionBodyContext::functionBody() {
  return getRuleContext<TypeScriptParser::FunctionBodyContext>(0);
}

tree::TerminalNode* TypeScriptParser::ArrowFunctionBodyContext::CloseBrace() {
  return getToken(TypeScriptParser::CloseBrace, 0);
}


size_t TypeScriptParser::ArrowFunctionBodyContext::getRuleIndex() const {
  return TypeScriptParser::RuleArrowFunctionBody;
}

void TypeScriptParser::ArrowFunctionBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrowFunctionBody(this);
}

void TypeScriptParser::ArrowFunctionBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrowFunctionBody(this);
}

TypeScriptParser::ArrowFunctionBodyContext* TypeScriptParser::arrowFunctionBody() {
  ArrowFunctionBodyContext *_localctx = _tracker.createInstance<ArrowFunctionBodyContext>(_ctx, getState());
  enterRule(_localctx, 262, TypeScriptParser::RuleArrowFunctionBody);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1630);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 206, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1625);
      singleExpression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1626);
      match(TypeScriptParser::OpenBrace);
      setState(1627);
      functionBody();
      setState(1628);
      match(TypeScriptParser::CloseBrace);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentOperatorContext ------------------------------------------------------------------

TypeScriptParser::AssignmentOperatorContext::AssignmentOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::AssignmentOperatorContext::MultiplyAssign() {
  return getToken(TypeScriptParser::MultiplyAssign, 0);
}

tree::TerminalNode* TypeScriptParser::AssignmentOperatorContext::DivideAssign() {
  return getToken(TypeScriptParser::DivideAssign, 0);
}

tree::TerminalNode* TypeScriptParser::AssignmentOperatorContext::ModulusAssign() {
  return getToken(TypeScriptParser::ModulusAssign, 0);
}

tree::TerminalNode* TypeScriptParser::AssignmentOperatorContext::PlusAssign() {
  return getToken(TypeScriptParser::PlusAssign, 0);
}

tree::TerminalNode* TypeScriptParser::AssignmentOperatorContext::MinusAssign() {
  return getToken(TypeScriptParser::MinusAssign, 0);
}

tree::TerminalNode* TypeScriptParser::AssignmentOperatorContext::LeftShiftArithmeticAssign() {
  return getToken(TypeScriptParser::LeftShiftArithmeticAssign, 0);
}

tree::TerminalNode* TypeScriptParser::AssignmentOperatorContext::RightShiftArithmeticAssign() {
  return getToken(TypeScriptParser::RightShiftArithmeticAssign, 0);
}

tree::TerminalNode* TypeScriptParser::AssignmentOperatorContext::RightShiftLogicalAssign() {
  return getToken(TypeScriptParser::RightShiftLogicalAssign, 0);
}

tree::TerminalNode* TypeScriptParser::AssignmentOperatorContext::BitAndAssign() {
  return getToken(TypeScriptParser::BitAndAssign, 0);
}

tree::TerminalNode* TypeScriptParser::AssignmentOperatorContext::BitXorAssign() {
  return getToken(TypeScriptParser::BitXorAssign, 0);
}

tree::TerminalNode* TypeScriptParser::AssignmentOperatorContext::BitOrAssign() {
  return getToken(TypeScriptParser::BitOrAssign, 0);
}


size_t TypeScriptParser::AssignmentOperatorContext::getRuleIndex() const {
  return TypeScriptParser::RuleAssignmentOperator;
}

void TypeScriptParser::AssignmentOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentOperator(this);
}

void TypeScriptParser::AssignmentOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentOperator(this);
}

TypeScriptParser::AssignmentOperatorContext* TypeScriptParser::assignmentOperator() {
  AssignmentOperatorContext *_localctx = _tracker.createInstance<AssignmentOperatorContext>(_ctx, getState());
  enterRule(_localctx, 264, TypeScriptParser::RuleAssignmentOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1632);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 18005602416459776) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

TypeScriptParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::LiteralContext::NullLiteral() {
  return getToken(TypeScriptParser::NullLiteral, 0);
}

tree::TerminalNode* TypeScriptParser::LiteralContext::BooleanLiteral() {
  return getToken(TypeScriptParser::BooleanLiteral, 0);
}

tree::TerminalNode* TypeScriptParser::LiteralContext::StringLiteral() {
  return getToken(TypeScriptParser::StringLiteral, 0);
}

TypeScriptParser::TemplateStringLiteralContext* TypeScriptParser::LiteralContext::templateStringLiteral() {
  return getRuleContext<TypeScriptParser::TemplateStringLiteralContext>(0);
}

tree::TerminalNode* TypeScriptParser::LiteralContext::RegularExpressionLiteral() {
  return getToken(TypeScriptParser::RegularExpressionLiteral, 0);
}

TypeScriptParser::NumericLiteralContext* TypeScriptParser::LiteralContext::numericLiteral() {
  return getRuleContext<TypeScriptParser::NumericLiteralContext>(0);
}


size_t TypeScriptParser::LiteralContext::getRuleIndex() const {
  return TypeScriptParser::RuleLiteral;
}

void TypeScriptParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void TypeScriptParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}

TypeScriptParser::LiteralContext* TypeScriptParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 266, TypeScriptParser::RuleLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1640);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TypeScriptParser::NullLiteral: {
        enterOuterAlt(_localctx, 1);
        setState(1634);
        match(TypeScriptParser::NullLiteral);
        break;
      }

      case TypeScriptParser::BooleanLiteral: {
        enterOuterAlt(_localctx, 2);
        setState(1635);
        match(TypeScriptParser::BooleanLiteral);
        break;
      }

      case TypeScriptParser::StringLiteral: {
        enterOuterAlt(_localctx, 3);
        setState(1636);
        match(TypeScriptParser::StringLiteral);
        break;
      }

      case TypeScriptParser::BackTick: {
        enterOuterAlt(_localctx, 4);
        setState(1637);
        templateStringLiteral();
        break;
      }

      case TypeScriptParser::RegularExpressionLiteral: {
        enterOuterAlt(_localctx, 5);
        setState(1638);
        match(TypeScriptParser::RegularExpressionLiteral);
        break;
      }

      case TypeScriptParser::DecimalLiteral:
      case TypeScriptParser::HexIntegerLiteral:
      case TypeScriptParser::OctalIntegerLiteral:
      case TypeScriptParser::OctalIntegerLiteral2:
      case TypeScriptParser::BinaryIntegerLiteral: {
        enterOuterAlt(_localctx, 6);
        setState(1639);
        numericLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemplateStringLiteralContext ------------------------------------------------------------------

TypeScriptParser::TemplateStringLiteralContext::TemplateStringLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TypeScriptParser::TemplateStringLiteralContext::BackTick() {
  return getTokens(TypeScriptParser::BackTick);
}

tree::TerminalNode* TypeScriptParser::TemplateStringLiteralContext::BackTick(size_t i) {
  return getToken(TypeScriptParser::BackTick, i);
}

std::vector<TypeScriptParser::TemplateStringAtomContext *> TypeScriptParser::TemplateStringLiteralContext::templateStringAtom() {
  return getRuleContexts<TypeScriptParser::TemplateStringAtomContext>();
}

TypeScriptParser::TemplateStringAtomContext* TypeScriptParser::TemplateStringLiteralContext::templateStringAtom(size_t i) {
  return getRuleContext<TypeScriptParser::TemplateStringAtomContext>(i);
}


size_t TypeScriptParser::TemplateStringLiteralContext::getRuleIndex() const {
  return TypeScriptParser::RuleTemplateStringLiteral;
}

void TypeScriptParser::TemplateStringLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemplateStringLiteral(this);
}

void TypeScriptParser::TemplateStringLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemplateStringLiteral(this);
}

TypeScriptParser::TemplateStringLiteralContext* TypeScriptParser::templateStringLiteral() {
  TemplateStringLiteralContext *_localctx = _tracker.createInstance<TemplateStringLiteralContext>(_ctx, getState());
  enterRule(_localctx, 268, TypeScriptParser::RuleTemplateStringLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1642);
    match(TypeScriptParser::BackTick);
    setState(1646);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 132) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 132)) & 7) != 0)) {
      setState(1643);
      templateStringAtom();
      setState(1648);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1649);
    match(TypeScriptParser::BackTick);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemplateStringAtomContext ------------------------------------------------------------------

TypeScriptParser::TemplateStringAtomContext::TemplateStringAtomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::TemplateStringAtomContext::TemplateStringAtom() {
  return getToken(TypeScriptParser::TemplateStringAtom, 0);
}

tree::TerminalNode* TypeScriptParser::TemplateStringAtomContext::TemplateStringStartExpression() {
  return getToken(TypeScriptParser::TemplateStringStartExpression, 0);
}

TypeScriptParser::SingleExpressionContext* TypeScriptParser::TemplateStringAtomContext::singleExpression() {
  return getRuleContext<TypeScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* TypeScriptParser::TemplateStringAtomContext::TemplateCloseBrace() {
  return getToken(TypeScriptParser::TemplateCloseBrace, 0);
}

tree::TerminalNode* TypeScriptParser::TemplateStringAtomContext::TemplateStringEscapeAtom() {
  return getToken(TypeScriptParser::TemplateStringEscapeAtom, 0);
}


size_t TypeScriptParser::TemplateStringAtomContext::getRuleIndex() const {
  return TypeScriptParser::RuleTemplateStringAtom;
}

void TypeScriptParser::TemplateStringAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemplateStringAtom(this);
}

void TypeScriptParser::TemplateStringAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemplateStringAtom(this);
}

TypeScriptParser::TemplateStringAtomContext* TypeScriptParser::templateStringAtom() {
  TemplateStringAtomContext *_localctx = _tracker.createInstance<TemplateStringAtomContext>(_ctx, getState());
  enterRule(_localctx, 270, TypeScriptParser::RuleTemplateStringAtom);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1657);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TypeScriptParser::TemplateStringAtom: {
        enterOuterAlt(_localctx, 1);
        setState(1651);
        match(TypeScriptParser::TemplateStringAtom);
        break;
      }

      case TypeScriptParser::TemplateStringStartExpression: {
        enterOuterAlt(_localctx, 2);
        setState(1652);
        match(TypeScriptParser::TemplateStringStartExpression);
        setState(1653);
        singleExpression(0);
        setState(1654);
        match(TypeScriptParser::TemplateCloseBrace);
        break;
      }

      case TypeScriptParser::TemplateStringEscapeAtom: {
        enterOuterAlt(_localctx, 3);
        setState(1656);
        match(TypeScriptParser::TemplateStringEscapeAtom);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericLiteralContext ------------------------------------------------------------------

TypeScriptParser::NumericLiteralContext::NumericLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::NumericLiteralContext::DecimalLiteral() {
  return getToken(TypeScriptParser::DecimalLiteral, 0);
}

tree::TerminalNode* TypeScriptParser::NumericLiteralContext::HexIntegerLiteral() {
  return getToken(TypeScriptParser::HexIntegerLiteral, 0);
}

tree::TerminalNode* TypeScriptParser::NumericLiteralContext::OctalIntegerLiteral() {
  return getToken(TypeScriptParser::OctalIntegerLiteral, 0);
}

tree::TerminalNode* TypeScriptParser::NumericLiteralContext::OctalIntegerLiteral2() {
  return getToken(TypeScriptParser::OctalIntegerLiteral2, 0);
}

tree::TerminalNode* TypeScriptParser::NumericLiteralContext::BinaryIntegerLiteral() {
  return getToken(TypeScriptParser::BinaryIntegerLiteral, 0);
}


size_t TypeScriptParser::NumericLiteralContext::getRuleIndex() const {
  return TypeScriptParser::RuleNumericLiteral;
}

void TypeScriptParser::NumericLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericLiteral(this);
}

void TypeScriptParser::NumericLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericLiteral(this);
}

TypeScriptParser::NumericLiteralContext* TypeScriptParser::numericLiteral() {
  NumericLiteralContext *_localctx = _tracker.createInstance<NumericLiteralContext>(_ctx, getState());
  enterRule(_localctx, 272, TypeScriptParser::RuleNumericLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1659);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4467570830351532032) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierNameContext ------------------------------------------------------------------

TypeScriptParser::IdentifierNameContext::IdentifierNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::IdentifierNameContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

TypeScriptParser::ReservedWordContext* TypeScriptParser::IdentifierNameContext::reservedWord() {
  return getRuleContext<TypeScriptParser::ReservedWordContext>(0);
}


size_t TypeScriptParser::IdentifierNameContext::getRuleIndex() const {
  return TypeScriptParser::RuleIdentifierName;
}

void TypeScriptParser::IdentifierNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierName(this);
}

void TypeScriptParser::IdentifierNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierName(this);
}

TypeScriptParser::IdentifierNameContext* TypeScriptParser::identifierName() {
  IdentifierNameContext *_localctx = _tracker.createInstance<IdentifierNameContext>(_ctx, getState());
  enterRule(_localctx, 274, TypeScriptParser::RuleIdentifierName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1663);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TypeScriptParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(1661);
        match(TypeScriptParser::Identifier);
        break;
      }

      case TypeScriptParser::NullLiteral:
      case TypeScriptParser::BooleanLiteral:
      case TypeScriptParser::Break:
      case TypeScriptParser::Do:
      case TypeScriptParser::Instanceof:
      case TypeScriptParser::Typeof:
      case TypeScriptParser::Case:
      case TypeScriptParser::Else:
      case TypeScriptParser::New:
      case TypeScriptParser::Var:
      case TypeScriptParser::Catch:
      case TypeScriptParser::Finally:
      case TypeScriptParser::Return:
      case TypeScriptParser::Void:
      case TypeScriptParser::Continue:
      case TypeScriptParser::For:
      case TypeScriptParser::Switch:
      case TypeScriptParser::While:
      case TypeScriptParser::Debugger:
      case TypeScriptParser::Function_:
      case TypeScriptParser::This:
      case TypeScriptParser::With:
      case TypeScriptParser::Default:
      case TypeScriptParser::If:
      case TypeScriptParser::Throw:
      case TypeScriptParser::Delete:
      case TypeScriptParser::In:
      case TypeScriptParser::Try:
      case TypeScriptParser::From:
      case TypeScriptParser::ReadOnly:
      case TypeScriptParser::Async:
      case TypeScriptParser::Class:
      case TypeScriptParser::Enum:
      case TypeScriptParser::Extends:
      case TypeScriptParser::Super:
      case TypeScriptParser::Const:
      case TypeScriptParser::Export:
      case TypeScriptParser::Import:
      case TypeScriptParser::Implements:
      case TypeScriptParser::Let:
      case TypeScriptParser::Private:
      case TypeScriptParser::Public:
      case TypeScriptParser::Interface:
      case TypeScriptParser::Package:
      case TypeScriptParser::Protected:
      case TypeScriptParser::Static:
      case TypeScriptParser::Yield:
      case TypeScriptParser::Number:
      case TypeScriptParser::Boolean:
      case TypeScriptParser::String:
      case TypeScriptParser::TypeAlias:
      case TypeScriptParser::Get:
      case TypeScriptParser::Set:
      case TypeScriptParser::Require:
      case TypeScriptParser::Module: {
        enterOuterAlt(_localctx, 2);
        setState(1662);
        reservedWord();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierOrKeyWordContext ------------------------------------------------------------------

TypeScriptParser::IdentifierOrKeyWordContext::IdentifierOrKeyWordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::IdentifierOrKeyWordContext::Identifier() {
  return getToken(TypeScriptParser::Identifier, 0);
}

tree::TerminalNode* TypeScriptParser::IdentifierOrKeyWordContext::TypeAlias() {
  return getToken(TypeScriptParser::TypeAlias, 0);
}

tree::TerminalNode* TypeScriptParser::IdentifierOrKeyWordContext::Require() {
  return getToken(TypeScriptParser::Require, 0);
}


size_t TypeScriptParser::IdentifierOrKeyWordContext::getRuleIndex() const {
  return TypeScriptParser::RuleIdentifierOrKeyWord;
}

void TypeScriptParser::IdentifierOrKeyWordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierOrKeyWord(this);
}

void TypeScriptParser::IdentifierOrKeyWordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierOrKeyWord(this);
}

TypeScriptParser::IdentifierOrKeyWordContext* TypeScriptParser::identifierOrKeyWord() {
  IdentifierOrKeyWordContext *_localctx = _tracker.createInstance<IdentifierOrKeyWordContext>(_ctx, getState());
  enterRule(_localctx, 276, TypeScriptParser::RuleIdentifierOrKeyWord);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1665);
    _la = _input->LA(1);
    if (!(((((_la - 113) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 113)) & 2081) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReservedWordContext ------------------------------------------------------------------

TypeScriptParser::ReservedWordContext::ReservedWordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TypeScriptParser::KeywordContext* TypeScriptParser::ReservedWordContext::keyword() {
  return getRuleContext<TypeScriptParser::KeywordContext>(0);
}

tree::TerminalNode* TypeScriptParser::ReservedWordContext::NullLiteral() {
  return getToken(TypeScriptParser::NullLiteral, 0);
}

tree::TerminalNode* TypeScriptParser::ReservedWordContext::BooleanLiteral() {
  return getToken(TypeScriptParser::BooleanLiteral, 0);
}


size_t TypeScriptParser::ReservedWordContext::getRuleIndex() const {
  return TypeScriptParser::RuleReservedWord;
}

void TypeScriptParser::ReservedWordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReservedWord(this);
}

void TypeScriptParser::ReservedWordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReservedWord(this);
}

TypeScriptParser::ReservedWordContext* TypeScriptParser::reservedWord() {
  ReservedWordContext *_localctx = _tracker.createInstance<ReservedWordContext>(_ctx, getState());
  enterRule(_localctx, 278, TypeScriptParser::RuleReservedWord);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1670);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TypeScriptParser::Break:
      case TypeScriptParser::Do:
      case TypeScriptParser::Instanceof:
      case TypeScriptParser::Typeof:
      case TypeScriptParser::Case:
      case TypeScriptParser::Else:
      case TypeScriptParser::New:
      case TypeScriptParser::Var:
      case TypeScriptParser::Catch:
      case TypeScriptParser::Finally:
      case TypeScriptParser::Return:
      case TypeScriptParser::Void:
      case TypeScriptParser::Continue:
      case TypeScriptParser::For:
      case TypeScriptParser::Switch:
      case TypeScriptParser::While:
      case TypeScriptParser::Debugger:
      case TypeScriptParser::Function_:
      case TypeScriptParser::This:
      case TypeScriptParser::With:
      case TypeScriptParser::Default:
      case TypeScriptParser::If:
      case TypeScriptParser::Throw:
      case TypeScriptParser::Delete:
      case TypeScriptParser::In:
      case TypeScriptParser::Try:
      case TypeScriptParser::From:
      case TypeScriptParser::ReadOnly:
      case TypeScriptParser::Async:
      case TypeScriptParser::Class:
      case TypeScriptParser::Enum:
      case TypeScriptParser::Extends:
      case TypeScriptParser::Super:
      case TypeScriptParser::Const:
      case TypeScriptParser::Export:
      case TypeScriptParser::Import:
      case TypeScriptParser::Implements:
      case TypeScriptParser::Let:
      case TypeScriptParser::Private:
      case TypeScriptParser::Public:
      case TypeScriptParser::Interface:
      case TypeScriptParser::Package:
      case TypeScriptParser::Protected:
      case TypeScriptParser::Static:
      case TypeScriptParser::Yield:
      case TypeScriptParser::Number:
      case TypeScriptParser::Boolean:
      case TypeScriptParser::String:
      case TypeScriptParser::TypeAlias:
      case TypeScriptParser::Get:
      case TypeScriptParser::Set:
      case TypeScriptParser::Require:
      case TypeScriptParser::Module: {
        enterOuterAlt(_localctx, 1);
        setState(1667);
        keyword();
        break;
      }

      case TypeScriptParser::NullLiteral: {
        enterOuterAlt(_localctx, 2);
        setState(1668);
        match(TypeScriptParser::NullLiteral);
        break;
      }

      case TypeScriptParser::BooleanLiteral: {
        enterOuterAlt(_localctx, 3);
        setState(1669);
        match(TypeScriptParser::BooleanLiteral);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeywordContext ------------------------------------------------------------------

TypeScriptParser::KeywordContext::KeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Break() {
  return getToken(TypeScriptParser::Break, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Do() {
  return getToken(TypeScriptParser::Do, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Instanceof() {
  return getToken(TypeScriptParser::Instanceof, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Typeof() {
  return getToken(TypeScriptParser::Typeof, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Case() {
  return getToken(TypeScriptParser::Case, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Else() {
  return getToken(TypeScriptParser::Else, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::New() {
  return getToken(TypeScriptParser::New, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Var() {
  return getToken(TypeScriptParser::Var, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Catch() {
  return getToken(TypeScriptParser::Catch, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Finally() {
  return getToken(TypeScriptParser::Finally, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Return() {
  return getToken(TypeScriptParser::Return, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Void() {
  return getToken(TypeScriptParser::Void, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Continue() {
  return getToken(TypeScriptParser::Continue, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::For() {
  return getToken(TypeScriptParser::For, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Switch() {
  return getToken(TypeScriptParser::Switch, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::While() {
  return getToken(TypeScriptParser::While, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Debugger() {
  return getToken(TypeScriptParser::Debugger, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Function_() {
  return getToken(TypeScriptParser::Function_, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::This() {
  return getToken(TypeScriptParser::This, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::With() {
  return getToken(TypeScriptParser::With, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Default() {
  return getToken(TypeScriptParser::Default, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::If() {
  return getToken(TypeScriptParser::If, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Throw() {
  return getToken(TypeScriptParser::Throw, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Delete() {
  return getToken(TypeScriptParser::Delete, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::In() {
  return getToken(TypeScriptParser::In, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Try() {
  return getToken(TypeScriptParser::Try, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::ReadOnly() {
  return getToken(TypeScriptParser::ReadOnly, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Async() {
  return getToken(TypeScriptParser::Async, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::From() {
  return getToken(TypeScriptParser::From, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Class() {
  return getToken(TypeScriptParser::Class, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Enum() {
  return getToken(TypeScriptParser::Enum, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Extends() {
  return getToken(TypeScriptParser::Extends, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Super() {
  return getToken(TypeScriptParser::Super, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Const() {
  return getToken(TypeScriptParser::Const, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Export() {
  return getToken(TypeScriptParser::Export, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Import() {
  return getToken(TypeScriptParser::Import, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Implements() {
  return getToken(TypeScriptParser::Implements, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Let() {
  return getToken(TypeScriptParser::Let, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Private() {
  return getToken(TypeScriptParser::Private, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Public() {
  return getToken(TypeScriptParser::Public, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Interface() {
  return getToken(TypeScriptParser::Interface, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Package() {
  return getToken(TypeScriptParser::Package, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Protected() {
  return getToken(TypeScriptParser::Protected, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Static() {
  return getToken(TypeScriptParser::Static, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Yield() {
  return getToken(TypeScriptParser::Yield, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Get() {
  return getToken(TypeScriptParser::Get, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Set() {
  return getToken(TypeScriptParser::Set, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Require() {
  return getToken(TypeScriptParser::Require, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::TypeAlias() {
  return getToken(TypeScriptParser::TypeAlias, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::String() {
  return getToken(TypeScriptParser::String, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Boolean() {
  return getToken(TypeScriptParser::Boolean, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Number() {
  return getToken(TypeScriptParser::Number, 0);
}

tree::TerminalNode* TypeScriptParser::KeywordContext::Module() {
  return getToken(TypeScriptParser::Module, 0);
}


size_t TypeScriptParser::KeywordContext::getRuleIndex() const {
  return TypeScriptParser::RuleKeyword;
}

void TypeScriptParser::KeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword(this);
}

void TypeScriptParser::KeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword(this);
}

TypeScriptParser::KeywordContext* TypeScriptParser::keyword() {
  KeywordContext *_localctx = _tracker.createInstance<KeywordContext>(_ctx, getState());
  enterRule(_localctx, 280, TypeScriptParser::RuleKeyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1672);
    _la = _input->LA(1);
    if (!(((((_la - 62) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 62)) & 232990911905136639) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GetterContext ------------------------------------------------------------------

TypeScriptParser::GetterContext::GetterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::GetterContext::Get() {
  return getToken(TypeScriptParser::Get, 0);
}

TypeScriptParser::PropertyNameContext* TypeScriptParser::GetterContext::propertyName() {
  return getRuleContext<TypeScriptParser::PropertyNameContext>(0);
}


size_t TypeScriptParser::GetterContext::getRuleIndex() const {
  return TypeScriptParser::RuleGetter;
}

void TypeScriptParser::GetterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGetter(this);
}

void TypeScriptParser::GetterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGetter(this);
}

TypeScriptParser::GetterContext* TypeScriptParser::getter() {
  GetterContext *_localctx = _tracker.createInstance<GetterContext>(_ctx, getState());
  enterRule(_localctx, 282, TypeScriptParser::RuleGetter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1674);
    match(TypeScriptParser::Get);
    setState(1675);
    propertyName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetterContext ------------------------------------------------------------------

TypeScriptParser::SetterContext::SetterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::SetterContext::Set() {
  return getToken(TypeScriptParser::Set, 0);
}

TypeScriptParser::PropertyNameContext* TypeScriptParser::SetterContext::propertyName() {
  return getRuleContext<TypeScriptParser::PropertyNameContext>(0);
}


size_t TypeScriptParser::SetterContext::getRuleIndex() const {
  return TypeScriptParser::RuleSetter;
}

void TypeScriptParser::SetterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetter(this);
}

void TypeScriptParser::SetterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetter(this);
}

TypeScriptParser::SetterContext* TypeScriptParser::setter() {
  SetterContext *_localctx = _tracker.createInstance<SetterContext>(_ctx, getState());
  enterRule(_localctx, 284, TypeScriptParser::RuleSetter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1677);
    match(TypeScriptParser::Set);
    setState(1678);
    propertyName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EosContext ------------------------------------------------------------------

TypeScriptParser::EosContext::EosContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TypeScriptParser::EosContext::SemiColon() {
  return getToken(TypeScriptParser::SemiColon, 0);
}

tree::TerminalNode* TypeScriptParser::EosContext::EOF() {
  return getToken(TypeScriptParser::EOF, 0);
}


size_t TypeScriptParser::EosContext::getRuleIndex() const {
  return TypeScriptParser::RuleEos;
}

void TypeScriptParser::EosContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEos(this);
}

void TypeScriptParser::EosContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TypeScriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEos(this);
}

TypeScriptParser::EosContext* TypeScriptParser::eos() {
  EosContext *_localctx = _tracker.createInstance<EosContext>(_ctx, getState());
  enterRule(_localctx, 286, TypeScriptParser::RuleEos);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1684);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 212, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1680);
      match(TypeScriptParser::SemiColon);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1681);
      match(TypeScriptParser::EOF);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1682);

      if (!(this->lineTerminatorAhead())) throw FailedPredicateException(this, "this->lineTerminatorAhead()");
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1683);

      if (!(this->closeBrace())) throw FailedPredicateException(this, "this->closeBrace()");
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool TypeScriptParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 10: return unionOrIntersectionOrPrimaryTypeSempred(antlrcpp::downCast<UnionOrIntersectionOrPrimaryTypeContext *>(context), predicateIndex);
    case 11: return primaryTypeSempred(antlrcpp::downCast<PrimaryTypeContext *>(context), predicateIndex);
    case 22: return arrayTypeSempred(antlrcpp::downCast<ArrayTypeContext *>(context), predicateIndex);
    case 57: return decoratorMemberExpressionSempred(antlrcpp::downCast<DecoratorMemberExpressionContext *>(context), predicateIndex);
    case 73: return expressionStatementSempred(antlrcpp::downCast<ExpressionStatementContext *>(context), predicateIndex);
    case 75: return iterationStatementSempred(antlrcpp::downCast<IterationStatementContext *>(context), predicateIndex);
    case 77: return continueStatementSempred(antlrcpp::downCast<ContinueStatementContext *>(context), predicateIndex);
    case 78: return breakStatementSempred(antlrcpp::downCast<BreakStatementContext *>(context), predicateIndex);
    case 79: return returnStatementSempred(antlrcpp::downCast<ReturnStatementContext *>(context), predicateIndex);
    case 80: return yieldStatementSempred(antlrcpp::downCast<YieldStatementContext *>(context), predicateIndex);
    case 88: return throwStatementSempred(antlrcpp::downCast<ThrowStatementContext *>(context), predicateIndex);
    case 127: return singleExpressionSempred(antlrcpp::downCast<SingleExpressionContext *>(context), predicateIndex);
    case 143: return eosSempred(antlrcpp::downCast<EosContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool TypeScriptParser::unionOrIntersectionOrPrimaryTypeSempred(UnionOrIntersectionOrPrimaryTypeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 3);
    case 1: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool TypeScriptParser::primaryTypeSempred(PrimaryTypeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 2: return precpred(_ctx, 5);
    case 3: return notLineTerminator();

  default:
    break;
  }
  return true;
}

bool TypeScriptParser::arrayTypeSempred(ArrayTypeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 4: return notLineTerminator();

  default:
    break;
  }
  return true;
}

bool TypeScriptParser::decoratorMemberExpressionSempred(DecoratorMemberExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 5: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool TypeScriptParser::expressionStatementSempred(ExpressionStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 6: return this->notOpenBraceAndNotFunction();

  default:
    break;
  }
  return true;
}

bool TypeScriptParser::iterationStatementSempred(IterationStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 7: return this->p("of");
    case 8: return this->p("of");

  default:
    break;
  }
  return true;
}

bool TypeScriptParser::continueStatementSempred(ContinueStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 9: return this->notLineTerminator();

  default:
    break;
  }
  return true;
}

bool TypeScriptParser::breakStatementSempred(BreakStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 10: return this->notLineTerminator();

  default:
    break;
  }
  return true;
}

bool TypeScriptParser::returnStatementSempred(ReturnStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 11: return this->notLineTerminator();

  default:
    break;
  }
  return true;
}

bool TypeScriptParser::yieldStatementSempred(YieldStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 12: return this->notLineTerminator();

  default:
    break;
  }
  return true;
}

bool TypeScriptParser::throwStatementSempred(ThrowStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 13: return this->notLineTerminator();

  default:
    break;
  }
  return true;
}

bool TypeScriptParser::singleExpressionSempred(SingleExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 14: return precpred(_ctx, 29);
    case 15: return precpred(_ctx, 28);
    case 16: return precpred(_ctx, 27);
    case 17: return precpred(_ctx, 26);
    case 18: return precpred(_ctx, 25);
    case 19: return precpred(_ctx, 24);
    case 20: return precpred(_ctx, 23);
    case 21: return precpred(_ctx, 22);
    case 22: return precpred(_ctx, 21);
    case 23: return precpred(_ctx, 20);
    case 24: return precpred(_ctx, 19);
    case 25: return precpred(_ctx, 18);
    case 26: return precpred(_ctx, 17);
    case 27: return precpred(_ctx, 16);
    case 28: return precpred(_ctx, 15);
    case 29: return precpred(_ctx, 45);
    case 30: return precpred(_ctx, 44);
    case 31: return precpred(_ctx, 41);
    case 32: return precpred(_ctx, 40);
    case 33: return this->notLineTerminator();
    case 34: return precpred(_ctx, 39);
    case 35: return this->notLineTerminator();
    case 36: return precpred(_ctx, 14);
    case 37: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool TypeScriptParser::eosSempred(EosContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 38: return this->lineTerminatorAhead();
    case 39: return this->closeBrace();

  default:
    break;
  }
  return true;
}

void TypeScriptParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  typescriptparserParserInitialize();
#else
  ::antlr4::internal::call_once(typescriptparserParserOnceFlag, typescriptparserParserInitialize);
#endif
}


// Generated from myParser.g4 by ANTLR 4.13.0


#include "myParserListener.h"

#include "myParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct MyParserStaticData final {
  MyParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  MyParserStaticData(const MyParserStaticData&) = delete;
  MyParserStaticData(MyParserStaticData&&) = delete;
  MyParserStaticData& operator=(const MyParserStaticData&) = delete;
  MyParserStaticData& operator=(MyParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag myparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
MyParserStaticData *myparserParserStaticData = nullptr;

void myparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (myparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(myparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<MyParserStaticData>(
    std::vector<std::string>{
      "initializer", "bindingPattern", "typeParameters", "typeParameterList", 
      "typeParameter", "constraint", "typeArguments", "typeArgumentList", 
      "typeArgument", "type_", "unionOrIntersectionOrPrimaryType", "primaryType", 
      "predefinedType", "typeReference", "nestedTypeGeneric", "typeGeneric", 
      "typeIncludeGeneric", "typeName", "objectType", "typeBody", "typeMemberList", 
      "typeMember", "arrayType", "tupleType", "tupleElementTypes", "functionType", 
      "constructorType", "typeQuery", "typeQueryExpression", "propertySignatur", 
      "typeAnnotation", "callSignature", "parameterList", "requiredParameterList", 
      "parameter", "optionalParameter", "restParameter", "requiredParameter", 
      "accessibilityModifier", "identifierOrPattern", "constructSignature", 
      "indexSignature", "methodSignature", "typeAliasDeclaration", "constructorDeclaration", 
      "interfaceDeclaration", "interfaceExtendsClause", "classOrInterfaceTypeList", 
      "enumDeclaration", "enumBody", "enumMemberList", "enumMember", "namespaceDeclaration", 
      "namespaceName", "importAliasDeclaration", "decoratorList", "decorator", 
      "decoratorMemberExpression", "decoratorCallExpression", "program", 
      "sourceElement", "statement", "block", "statementList", "abstractDeclaration", 
      "importStatement", "fromBlock", "multipleImportStatement", "exportStatement", 
      "variableStatement", "variableDeclarationList", "variableDeclaration", 
      "emptyStatement_", "expressionStatement", "ifStatement", "iterationStatement", 
      "varModifier", "continueStatement", "breakStatement", "returnStatement", 
      "yieldStatement", "withStatement", "switchStatement", "caseBlock", 
      "caseClauses", "caseClause", "defaultClause", "labelledStatement", 
      "throwStatement", "tryStatement", "catchProduction", "finallyProduction", 
      "debuggerStatement", "functionDeclaration", "classDeclaration", "classHeritage", 
      "classTail", "classExtendsClause", "implementsClause", "classElement", 
      "propertyMemberDeclaration", "propertyMemberBase", "indexMemberDeclaration", 
      "generatorMethod", "generatorFunctionDeclaration", "generatorBlock", 
      "generatorDefinition", "iteratorBlock", "iteratorDefinition", "formalParameterList", 
      "formalParameterArg", "lastFormalParameterArg", "functionBody", "sourceElements", 
      "arrayLiteral", "elementList", "arrayElement", "objectLiteral", "propertyAssignment", 
      "getAccessor", "setAccessor", "propertyName", "arguments", "argumentList", 
      "argument", "expressionSequence", "functionExpressionDeclaration", 
      "singleExpression", "asExpression", "arrowFunctionDeclaration", "arrowFunctionParameters", 
      "arrowFunctionBody", "assignmentOperator", "literal", "templateStringLiteral", 
      "templateStringAtom", "numericLiteral", "identifierName", "identifierOrKeyWord", 
      "reservedWord", "keyword", "getter", "setter", "eos"
    },
    std::vector<std::string>{
      "", "", "", "", "'['", "']'", "'('", "')'", "'{'", "", "'}'", "';'", 
      "','", "'='", "'\\u003F'", "':'", "'...'", "'.'", "'++'", "'--'", 
      "'+'", "'-'", "'~'", "'!'", "'*'", "'/'", "'%'", "'>>'", "'<<'", "'>>>'", 
      "'<'", "'>'", "'<='", "'>='", "'=='", "'!='", "'==='", "'!=='", "'&'", 
      "'^'", "'|'", "'&&'", "'||'", "'*='", "'/='", "'%='", "'+='", "'-='", 
      "'<<='", "'>>='", "'>>>='", "'&='", "'^='", "'|='", "'=>'", "'null'", 
      "", "", "", "", "", "", "'break'", "'do'", "'instanceof'", "'typeof'", 
      "'case'", "'else'", "'new'", "'var'", "'catch'", "'finally'", "'return'", 
      "'void'", "'continue'", "'for'", "'switch'", "'while'", "'debugger'", 
      "'function'", "'this'", "'with'", "'default'", "'if'", "'throw'", 
      "'delete'", "'in'", "'try'", "'as'", "'from'", "'readonly'", "'async'", 
      "'class'", "'enum'", "'extends'", "'super'", "'const'", "'export'", 
      "'import'", "'implements'", "'let'", "'private'", "'public'", "'interface'", 
      "'package'", "'protected'", "'static'", "'yield'", "'any'", "'number'", 
      "'boolean'", "'string'", "'symbol'", "'type'", "'get'", "'set'", "'constructor'", 
      "'namespace'", "'require'", "'module'", "'declare'", "'abstract'", 
      "'is'", "'@'", "", "", "", "", "", "", "", "", "'${'"
    },
    std::vector<std::string>{
      "", "MultiLineComment", "SingleLineComment", "RegularExpressionLiteral", 
      "OpenBracket", "CloseBracket", "OpenParen", "CloseParen", "OpenBrace", 
      "TemplateCloseBrace", "CloseBrace", "SemiColon", "Comma", "Assign", 
      "QuestionMark", "Colon", "Ellipsis", "Dot", "PlusPlus", "MinusMinus", 
      "Plus", "Minus", "BitNot", "Not", "Multiply", "Divide", "Modulus", 
      "RightShiftArithmetic", "LeftShiftArithmetic", "RightShiftLogical", 
      "LessThan", "MoreThan", "LessThanEquals", "GreaterThanEquals", "Equals_", 
      "NotEquals", "IdentityEquals", "IdentityNotEquals", "BitAnd", "BitXOr", 
      "BitOr", "And", "Or", "MultiplyAssign", "DivideAssign", "ModulusAssign", 
      "PlusAssign", "MinusAssign", "LeftShiftArithmeticAssign", "RightShiftArithmeticAssign", 
      "RightShiftLogicalAssign", "BitAndAssign", "BitXorAssign", "BitOrAssign", 
      "ARROW", "NullLiteral", "BooleanLiteral", "DecimalLiteral", "HexIntegerLiteral", 
      "OctalIntegerLiteral", "OctalIntegerLiteral2", "BinaryIntegerLiteral", 
      "Break", "Do", "Instanceof", "Typeof", "Case", "Else", "New", "Var", 
      "Catch", "Finally", "Return", "Void", "Continue", "For", "Switch", 
      "While", "Debugger", "Function_", "This", "With", "Default", "If", 
      "Throw", "Delete", "In", "Try", "As", "From", "ReadOnly", "Async", 
      "Class", "Enum", "Extends", "Super", "Const", "Export", "Import", 
      "Implements", "Let", "Private", "Public", "Interface", "Package", 
      "Protected", "Static", "Yield", "Any", "Number", "Boolean", "String", 
      "Symbol", "TypeAlias", "Get", "Set", "Constructor", "Namespace", "Require", 
      "Module", "Declare", "Abstract", "Is", "At", "Identifier", "StringLiteral", 
      "BackTick", "WhiteSpaces", "LineTerminator", "HtmlComment", "CDataComment", 
      "UnexpectedCharacter", "TemplateStringStartExpression", "TemplateStringAtom"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,133,1678,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,
  	7,134,2,135,7,135,2,136,7,136,2,137,7,137,2,138,7,138,2,139,7,139,2,140,
  	7,140,2,141,7,141,2,142,7,142,2,143,7,143,1,0,1,0,1,0,1,1,1,1,3,1,294,
  	8,1,1,2,1,2,3,2,298,8,2,1,2,1,2,1,3,1,3,1,3,5,3,305,8,3,10,3,12,3,308,
  	9,3,1,4,1,4,3,4,312,8,4,1,4,3,4,315,8,4,1,5,1,5,1,5,1,6,1,6,3,6,322,8,
  	6,1,6,1,6,1,7,1,7,1,7,5,7,329,8,7,10,7,12,7,332,9,7,1,8,1,8,1,9,1,9,1,
  	9,1,9,1,9,3,9,341,8,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,5,
  	10,352,8,10,10,10,12,10,355,9,10,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,
  	11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,3,11,375,8,11,1,
  	11,1,11,1,11,1,11,5,11,381,8,11,10,11,12,11,384,9,11,1,12,1,12,1,13,1,
  	13,3,13,390,8,13,1,14,1,14,3,14,394,8,14,1,15,1,15,1,15,1,15,1,16,1,16,
  	1,16,1,16,1,16,1,16,1,16,1,16,1,16,3,16,409,8,16,1,17,1,17,3,17,413,8,
  	17,1,18,1,18,3,18,417,8,18,1,18,1,18,1,19,1,19,3,19,423,8,19,1,20,1,20,
  	1,20,5,20,428,8,20,10,20,12,20,431,9,20,1,21,1,21,1,21,1,21,1,21,1,21,
  	1,21,3,21,440,8,21,3,21,442,8,21,1,22,1,22,1,22,1,22,1,22,1,23,1,23,1,
  	23,1,23,1,24,1,24,1,24,5,24,456,8,24,10,24,12,24,459,9,24,1,25,3,25,462,
  	8,25,1,25,1,25,3,25,466,8,25,1,25,1,25,1,25,1,25,1,26,1,26,3,26,474,8,
  	26,1,26,1,26,3,26,478,8,26,1,26,1,26,1,26,1,26,1,27,1,27,1,27,1,28,1,
  	28,1,28,1,28,4,28,491,8,28,11,28,12,28,492,1,28,1,28,3,28,497,8,28,1,
  	29,3,29,500,8,29,1,29,1,29,3,29,504,8,29,1,29,3,29,507,8,29,1,29,1,29,
  	3,29,511,8,29,1,30,1,30,1,30,1,31,3,31,517,8,31,1,31,1,31,3,31,521,8,
  	31,1,31,1,31,3,31,525,8,31,1,32,1,32,1,32,1,32,5,32,531,8,32,10,32,12,
  	32,534,9,32,1,32,1,32,3,32,538,8,32,3,32,540,8,32,1,33,1,33,1,33,5,33,
  	545,8,33,10,33,12,33,548,9,33,1,34,1,34,3,34,552,8,34,1,35,3,35,555,8,
  	35,1,35,3,35,558,8,35,1,35,1,35,1,35,3,35,563,8,35,1,35,3,35,566,8,35,
  	1,35,3,35,569,8,35,1,36,1,36,1,36,3,36,574,8,36,1,37,3,37,577,8,37,1,
  	37,3,37,580,8,37,1,37,1,37,3,37,584,8,37,1,38,1,38,1,39,1,39,3,39,590,
  	8,39,1,40,1,40,3,40,594,8,40,1,40,1,40,3,40,598,8,40,1,40,1,40,3,40,602,
  	8,40,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,42,1,42,3,42,613,8,42,1,42,
  	1,42,1,43,1,43,1,43,3,43,620,8,43,1,43,1,43,1,43,1,43,1,44,3,44,627,8,
  	44,1,44,1,44,1,44,3,44,632,8,44,1,44,1,44,1,44,1,44,1,44,1,44,3,44,640,
  	8,44,1,45,3,45,643,8,45,1,45,3,45,646,8,45,1,45,1,45,1,45,3,45,651,8,
  	45,1,45,3,45,654,8,45,1,45,1,45,3,45,658,8,45,1,46,1,46,1,46,1,47,1,47,
  	1,47,5,47,666,8,47,10,47,12,47,669,9,47,1,48,3,48,672,8,48,1,48,1,48,
  	1,48,1,48,3,48,678,8,48,1,48,1,48,1,49,1,49,3,49,684,8,49,1,50,1,50,1,
  	50,5,50,689,8,50,10,50,12,50,692,9,50,1,51,1,51,1,51,3,51,697,8,51,1,
  	52,1,52,1,52,1,52,3,52,703,8,52,1,52,1,52,1,53,1,53,4,53,709,8,53,11,
  	53,12,53,710,1,53,5,53,714,8,53,10,53,12,53,717,9,53,1,54,1,54,1,54,1,
  	54,1,54,1,55,4,55,725,8,55,11,55,12,55,726,1,56,1,56,1,56,3,56,732,8,
  	56,1,57,1,57,1,57,1,57,1,57,1,57,3,57,740,8,57,1,57,1,57,1,57,5,57,745,
  	8,57,10,57,12,57,748,9,57,1,58,1,58,1,58,1,59,3,59,754,8,59,1,59,1,59,
  	1,60,3,60,759,8,60,1,60,1,60,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,
  	1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,
  	1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,3,61,793,8,61,1,62,1,62,3,62,
  	797,8,62,1,62,1,62,1,63,4,63,802,8,63,11,63,12,63,803,1,64,1,64,1,64,
  	1,64,3,64,810,8,64,1,64,1,64,1,65,1,65,1,65,3,65,817,8,65,1,66,1,66,3,
  	66,821,8,66,1,66,1,66,3,66,825,8,66,1,66,1,66,1,66,1,66,1,67,1,67,1,67,
  	3,67,834,8,67,1,67,1,67,1,67,1,67,5,67,840,8,67,10,67,12,67,843,9,67,
  	1,67,1,67,1,68,1,68,3,68,849,8,68,1,68,1,68,3,68,853,8,68,1,69,1,69,3,
  	69,857,8,69,1,69,1,69,3,69,861,8,69,1,69,3,69,864,8,69,1,69,3,69,867,
  	8,69,1,69,3,69,870,8,69,1,69,1,69,3,69,874,8,69,1,69,1,69,3,69,878,8,
  	69,1,69,1,69,3,69,882,8,69,3,69,884,8,69,1,70,1,70,1,70,5,70,889,8,70,
  	10,70,12,70,892,9,70,1,71,1,71,1,71,3,71,897,8,71,1,71,3,71,900,8,71,
  	1,71,3,71,903,8,71,1,71,1,71,3,71,907,8,71,1,71,3,71,910,8,71,1,72,1,
  	72,1,73,1,73,1,73,3,73,917,8,73,1,74,1,74,1,74,1,74,1,74,1,74,1,74,3,
  	74,926,8,74,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,
  	75,1,75,1,75,1,75,1,75,1,75,3,75,945,8,75,1,75,1,75,3,75,949,8,75,1,75,
  	1,75,3,75,953,8,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,3,75,963,8,
  	75,1,75,1,75,3,75,967,8,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,
  	75,3,75,978,8,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,
  	75,3,75,991,8,75,1,75,1,75,1,75,1,75,3,75,997,8,75,1,76,1,76,1,77,1,77,
  	1,77,3,77,1004,8,77,1,77,1,77,1,78,1,78,1,78,3,78,1011,8,78,1,78,1,78,
  	1,79,1,79,1,79,3,79,1018,8,79,1,79,1,79,1,80,1,80,1,80,3,80,1025,8,80,
  	1,80,1,80,1,81,1,81,1,81,1,81,1,81,1,81,1,82,1,82,1,82,1,82,1,82,1,82,
  	1,83,1,83,3,83,1043,8,83,1,83,1,83,3,83,1047,8,83,3,83,1049,8,83,1,83,
  	1,83,1,84,4,84,1054,8,84,11,84,12,84,1055,1,85,1,85,1,85,1,85,3,85,1062,
  	8,85,1,86,1,86,1,86,3,86,1067,8,86,1,87,1,87,1,87,1,87,1,88,1,88,1,88,
  	1,88,1,88,1,89,1,89,1,89,1,89,3,89,1082,8,89,1,89,3,89,1085,8,89,1,90,
  	1,90,1,90,1,90,1,90,1,90,1,91,1,91,1,91,1,92,1,92,1,92,1,93,1,93,1,93,
  	1,93,1,93,1,93,1,93,1,93,3,93,1107,8,93,1,94,3,94,1110,8,94,1,94,1,94,
  	1,94,3,94,1115,8,94,1,94,1,94,1,94,1,95,3,95,1121,8,95,1,95,3,95,1124,
  	8,95,1,96,1,96,5,96,1128,8,96,10,96,12,96,1131,9,96,1,96,1,96,1,97,1,
  	97,1,97,1,98,1,98,1,98,1,99,1,99,3,99,1143,8,99,1,99,1,99,1,99,3,99,1148,
  	8,99,1,100,1,100,1,100,3,100,1153,8,100,1,100,3,100,1156,8,100,1,100,
  	3,100,1159,8,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,
  	1,100,3,100,1171,8,100,1,100,1,100,1,100,3,100,1176,8,100,1,100,3,100,
  	1179,8,100,1,101,3,101,1182,8,101,1,101,3,101,1185,8,101,1,101,3,101,
  	1188,8,101,1,101,3,101,1191,8,101,1,102,1,102,1,102,1,103,3,103,1197,
  	8,103,1,103,1,103,1,103,3,103,1202,8,103,1,103,1,103,1,103,1,103,1,103,
  	1,104,1,104,1,104,3,104,1212,8,104,1,104,1,104,3,104,1216,8,104,1,104,
  	1,104,1,104,1,104,1,104,1,105,1,105,1,105,1,105,5,105,1227,8,105,10,105,
  	12,105,1230,9,105,1,105,3,105,1233,8,105,1,105,1,105,1,106,1,106,1,106,
  	1,107,1,107,1,107,1,107,5,107,1244,8,107,10,107,12,107,1247,9,107,1,107,
  	3,107,1250,8,107,1,107,1,107,1,108,1,108,1,108,1,108,1,108,3,108,1259,
  	8,108,1,108,1,108,1,108,1,108,1,108,1,109,1,109,1,109,5,109,1269,8,109,
  	10,109,12,109,1272,9,109,1,109,1,109,3,109,1276,8,109,1,109,1,109,1,109,
  	1,109,1,109,3,109,1283,8,109,3,109,1285,8,109,1,110,3,110,1288,8,110,
  	1,110,3,110,1291,8,110,1,110,1,110,3,110,1295,8,110,1,110,3,110,1298,
  	8,110,1,110,1,110,3,110,1302,8,110,1,111,1,111,1,111,1,112,3,112,1308,
  	8,112,1,113,4,113,1311,8,113,11,113,12,113,1312,1,114,1,114,3,114,1317,
  	8,114,1,114,1,114,1,115,1,115,4,115,1323,8,115,11,115,12,115,1324,1,115,
  	5,115,1328,8,115,10,115,12,115,1331,9,115,1,116,3,116,1334,8,116,1,116,
  	1,116,3,116,1338,8,116,1,116,3,116,1341,8,116,1,117,1,117,1,117,1,117,
  	5,117,1347,8,117,10,117,12,117,1350,9,117,1,117,3,117,1353,8,117,3,117,
  	1355,8,117,1,117,1,117,1,118,1,118,1,118,1,118,1,118,1,118,1,118,1,118,
  	1,118,1,118,1,118,1,118,1,118,1,118,1,118,3,118,1374,8,118,1,119,1,119,
  	1,119,1,119,3,119,1380,8,119,1,119,1,119,1,119,1,119,1,120,1,120,1,120,
  	1,120,3,120,1390,8,120,1,120,3,120,1393,8,120,1,120,1,120,1,120,1,120,
  	1,120,1,121,1,121,1,121,3,121,1403,8,121,1,122,1,122,1,122,3,122,1408,
  	8,122,3,122,1410,8,122,1,122,1,122,1,123,1,123,1,123,5,123,1417,8,123,
  	10,123,12,123,1420,9,123,1,124,3,124,1423,8,124,1,124,1,124,3,124,1427,
  	8,124,1,125,1,125,1,125,5,125,1432,8,125,10,125,12,125,1435,9,125,1,126,
  	1,126,3,126,1439,8,126,1,126,1,126,3,126,1443,8,126,1,126,1,126,3,126,
  	1447,8,126,1,126,1,126,1,126,1,126,1,127,1,127,1,127,1,127,1,127,3,127,
  	1458,8,127,1,127,1,127,1,127,1,127,3,127,1464,8,127,1,127,1,127,1,127,
  	1,127,1,127,3,127,1471,8,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,
  	1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,
  	1,127,1,127,1,127,1,127,1,127,1,127,3,127,1498,8,127,1,127,1,127,1,127,
  	1,127,1,127,1,127,1,127,1,127,1,127,1,127,3,127,1510,8,127,3,127,1512,
  	8,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,
  	1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,
  	1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,
  	1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,
  	1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,3,127,
  	1572,8,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,
  	1,127,1,127,1,127,5,127,1587,8,127,10,127,12,127,1590,9,127,1,128,1,128,
  	1,128,3,128,1595,8,128,1,128,3,128,1598,8,128,1,129,3,129,1601,8,129,
  	1,129,1,129,3,129,1605,8,129,1,129,1,129,1,129,1,130,1,130,1,130,3,130,
  	1613,8,130,1,130,3,130,1616,8,130,1,131,1,131,1,131,1,131,1,131,3,131,
  	1623,8,131,1,132,1,132,1,133,1,133,1,133,1,133,1,133,1,133,3,133,1633,
  	8,133,1,134,1,134,5,134,1637,8,134,10,134,12,134,1640,9,134,1,134,1,134,
  	1,135,1,135,1,135,1,135,1,135,3,135,1649,8,135,1,136,1,136,1,137,1,137,
  	3,137,1655,8,137,1,138,1,138,1,139,1,139,1,139,3,139,1662,8,139,1,140,
  	1,140,1,141,1,141,1,141,1,142,1,142,1,142,1,143,1,143,1,143,1,143,3,143,
  	1676,8,143,1,143,0,4,20,22,114,254,144,0,2,4,6,8,10,12,14,16,18,20,22,
  	24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,
  	70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,
  	112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,
  	148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,
  	184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,
  	220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,
  	256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,0,15,
  	2,0,73,73,108,112,1,0,11,12,2,0,101,102,105,105,2,0,109,109,111,111,3,
  	0,69,69,96,96,100,100,2,0,13,13,15,15,1,0,24,26,1,0,20,21,1,0,27,29,1,
  	0,30,33,1,0,34,37,1,0,43,53,1,0,57,61,3,0,113,113,118,118,124,124,5,0,
  	62,87,89,107,111,111,113,115,118,118,1851,0,288,1,0,0,0,2,293,1,0,0,0,
  	4,295,1,0,0,0,6,301,1,0,0,0,8,314,1,0,0,0,10,316,1,0,0,0,12,319,1,0,0,
  	0,14,325,1,0,0,0,16,333,1,0,0,0,18,340,1,0,0,0,20,342,1,0,0,0,22,374,
  	1,0,0,0,24,385,1,0,0,0,26,387,1,0,0,0,28,393,1,0,0,0,30,395,1,0,0,0,32,
  	399,1,0,0,0,34,412,1,0,0,0,36,414,1,0,0,0,38,420,1,0,0,0,40,424,1,0,0,
  	0,42,441,1,0,0,0,44,443,1,0,0,0,46,448,1,0,0,0,48,452,1,0,0,0,50,461,
  	1,0,0,0,52,471,1,0,0,0,54,483,1,0,0,0,56,496,1,0,0,0,58,499,1,0,0,0,60,
  	512,1,0,0,0,62,516,1,0,0,0,64,539,1,0,0,0,66,541,1,0,0,0,68,551,1,0,0,
  	0,70,554,1,0,0,0,72,570,1,0,0,0,74,576,1,0,0,0,76,585,1,0,0,0,78,589,
  	1,0,0,0,80,591,1,0,0,0,82,603,1,0,0,0,84,610,1,0,0,0,86,616,1,0,0,0,88,
  	626,1,0,0,0,90,642,1,0,0,0,92,659,1,0,0,0,94,662,1,0,0,0,96,671,1,0,0,
  	0,98,681,1,0,0,0,100,685,1,0,0,0,102,693,1,0,0,0,104,698,1,0,0,0,106,
  	706,1,0,0,0,108,718,1,0,0,0,110,724,1,0,0,0,112,728,1,0,0,0,114,739,1,
  	0,0,0,116,749,1,0,0,0,118,753,1,0,0,0,120,758,1,0,0,0,122,792,1,0,0,0,
  	124,794,1,0,0,0,126,801,1,0,0,0,128,805,1,0,0,0,130,813,1,0,0,0,132,820,
  	1,0,0,0,134,833,1,0,0,0,136,846,1,0,0,0,138,883,1,0,0,0,140,885,1,0,0,
  	0,142,896,1,0,0,0,144,911,1,0,0,0,146,913,1,0,0,0,148,918,1,0,0,0,150,
  	996,1,0,0,0,152,998,1,0,0,0,154,1000,1,0,0,0,156,1007,1,0,0,0,158,1014,
  	1,0,0,0,160,1021,1,0,0,0,162,1028,1,0,0,0,164,1034,1,0,0,0,166,1040,1,
  	0,0,0,168,1053,1,0,0,0,170,1057,1,0,0,0,172,1063,1,0,0,0,174,1068,1,0,
  	0,0,176,1072,1,0,0,0,178,1077,1,0,0,0,180,1086,1,0,0,0,182,1092,1,0,0,
  	0,184,1095,1,0,0,0,186,1098,1,0,0,0,188,1109,1,0,0,0,190,1120,1,0,0,0,
  	192,1125,1,0,0,0,194,1134,1,0,0,0,196,1137,1,0,0,0,198,1147,1,0,0,0,200,
  	1178,1,0,0,0,202,1181,1,0,0,0,204,1192,1,0,0,0,206,1196,1,0,0,0,208,1208,
  	1,0,0,0,210,1222,1,0,0,0,212,1236,1,0,0,0,214,1239,1,0,0,0,216,1253,1,
  	0,0,0,218,1284,1,0,0,0,220,1287,1,0,0,0,222,1303,1,0,0,0,224,1307,1,0,
  	0,0,226,1310,1,0,0,0,228,1314,1,0,0,0,230,1320,1,0,0,0,232,1333,1,0,0,
  	0,234,1342,1,0,0,0,236,1373,1,0,0,0,238,1375,1,0,0,0,240,1385,1,0,0,0,
  	242,1402,1,0,0,0,244,1404,1,0,0,0,246,1413,1,0,0,0,248,1422,1,0,0,0,250,
  	1428,1,0,0,0,252,1436,1,0,0,0,254,1511,1,0,0,0,256,1597,1,0,0,0,258,1600,
  	1,0,0,0,260,1615,1,0,0,0,262,1622,1,0,0,0,264,1624,1,0,0,0,266,1632,1,
  	0,0,0,268,1634,1,0,0,0,270,1648,1,0,0,0,272,1650,1,0,0,0,274,1654,1,0,
  	0,0,276,1656,1,0,0,0,278,1661,1,0,0,0,280,1663,1,0,0,0,282,1665,1,0,0,
  	0,284,1668,1,0,0,0,286,1675,1,0,0,0,288,289,5,13,0,0,289,290,3,254,127,
  	0,290,1,1,0,0,0,291,294,3,228,114,0,292,294,3,234,117,0,293,291,1,0,0,
  	0,293,292,1,0,0,0,294,3,1,0,0,0,295,297,5,30,0,0,296,298,3,6,3,0,297,
  	296,1,0,0,0,297,298,1,0,0,0,298,299,1,0,0,0,299,300,5,31,0,0,300,5,1,
  	0,0,0,301,306,3,8,4,0,302,303,5,12,0,0,303,305,3,8,4,0,304,302,1,0,0,
  	0,305,308,1,0,0,0,306,304,1,0,0,0,306,307,1,0,0,0,307,7,1,0,0,0,308,306,
  	1,0,0,0,309,311,5,124,0,0,310,312,3,10,5,0,311,310,1,0,0,0,311,312,1,
  	0,0,0,312,315,1,0,0,0,313,315,3,4,2,0,314,309,1,0,0,0,314,313,1,0,0,0,
  	315,9,1,0,0,0,316,317,5,94,0,0,317,318,3,18,9,0,318,11,1,0,0,0,319,321,
  	5,30,0,0,320,322,3,14,7,0,321,320,1,0,0,0,321,322,1,0,0,0,322,323,1,0,
  	0,0,323,324,5,31,0,0,324,13,1,0,0,0,325,330,3,16,8,0,326,327,5,12,0,0,
  	327,329,3,16,8,0,328,326,1,0,0,0,329,332,1,0,0,0,330,328,1,0,0,0,330,
  	331,1,0,0,0,331,15,1,0,0,0,332,330,1,0,0,0,333,334,3,18,9,0,334,17,1,
  	0,0,0,335,341,3,20,10,0,336,341,3,50,25,0,337,341,3,52,26,0,338,341,3,
  	30,15,0,339,341,5,125,0,0,340,335,1,0,0,0,340,336,1,0,0,0,340,337,1,0,
  	0,0,340,338,1,0,0,0,340,339,1,0,0,0,341,19,1,0,0,0,342,343,6,10,-1,0,
  	343,344,3,22,11,0,344,353,1,0,0,0,345,346,10,3,0,0,346,347,5,40,0,0,347,
  	352,3,20,10,4,348,349,10,2,0,0,349,350,5,38,0,0,350,352,3,20,10,3,351,
  	345,1,0,0,0,351,348,1,0,0,0,352,355,1,0,0,0,353,351,1,0,0,0,353,354,1,
  	0,0,0,354,21,1,0,0,0,355,353,1,0,0,0,356,357,6,11,-1,0,357,358,5,6,0,
  	0,358,359,3,18,9,0,359,360,5,7,0,0,360,375,1,0,0,0,361,375,3,24,12,0,
  	362,375,3,26,13,0,363,375,3,36,18,0,364,365,5,4,0,0,365,366,3,48,24,0,
  	366,367,5,5,0,0,367,375,1,0,0,0,368,375,3,54,27,0,369,375,5,80,0,0,370,
  	371,3,26,13,0,371,372,5,122,0,0,372,373,3,22,11,1,373,375,1,0,0,0,374,
  	356,1,0,0,0,374,361,1,0,0,0,374,362,1,0,0,0,374,363,1,0,0,0,374,364,1,
  	0,0,0,374,368,1,0,0,0,374,369,1,0,0,0,374,370,1,0,0,0,375,382,1,0,0,0,
  	376,377,10,5,0,0,377,378,4,11,3,0,378,379,5,4,0,0,379,381,5,5,0,0,380,
  	376,1,0,0,0,381,384,1,0,0,0,382,380,1,0,0,0,382,383,1,0,0,0,383,23,1,
  	0,0,0,384,382,1,0,0,0,385,386,7,0,0,0,386,25,1,0,0,0,387,389,3,34,17,
  	0,388,390,3,28,14,0,389,388,1,0,0,0,389,390,1,0,0,0,390,27,1,0,0,0,391,
  	394,3,32,16,0,392,394,3,30,15,0,393,391,1,0,0,0,393,392,1,0,0,0,394,29,
  	1,0,0,0,395,396,5,30,0,0,396,397,3,14,7,0,397,398,5,31,0,0,398,31,1,0,
  	0,0,399,400,5,30,0,0,400,401,3,14,7,0,401,402,5,30,0,0,402,408,3,14,7,
  	0,403,404,5,31,0,0,404,405,3,2,1,0,405,406,5,31,0,0,406,409,1,0,0,0,407,
  	409,5,27,0,0,408,403,1,0,0,0,408,407,1,0,0,0,409,33,1,0,0,0,410,413,5,
  	124,0,0,411,413,3,106,53,0,412,410,1,0,0,0,412,411,1,0,0,0,413,35,1,0,
  	0,0,414,416,5,8,0,0,415,417,3,38,19,0,416,415,1,0,0,0,416,417,1,0,0,0,
  	417,418,1,0,0,0,418,419,5,10,0,0,419,37,1,0,0,0,420,422,3,40,20,0,421,
  	423,7,1,0,0,422,421,1,0,0,0,422,423,1,0,0,0,423,39,1,0,0,0,424,429,3,
  	42,21,0,425,426,7,1,0,0,426,428,3,42,21,0,427,425,1,0,0,0,428,431,1,0,
  	0,0,429,427,1,0,0,0,429,430,1,0,0,0,430,41,1,0,0,0,431,429,1,0,0,0,432,
  	442,3,58,29,0,433,442,3,62,31,0,434,442,3,80,40,0,435,442,3,82,41,0,436,
  	439,3,84,42,0,437,438,5,54,0,0,438,440,3,18,9,0,439,437,1,0,0,0,439,440,
  	1,0,0,0,440,442,1,0,0,0,441,432,1,0,0,0,441,433,1,0,0,0,441,434,1,0,0,
  	0,441,435,1,0,0,0,441,436,1,0,0,0,442,43,1,0,0,0,443,444,3,22,11,0,444,
  	445,4,22,4,0,445,446,5,4,0,0,446,447,5,5,0,0,447,45,1,0,0,0,448,449,5,
  	4,0,0,449,450,3,48,24,0,450,451,5,5,0,0,451,47,1,0,0,0,452,457,3,18,9,
  	0,453,454,5,12,0,0,454,456,3,18,9,0,455,453,1,0,0,0,456,459,1,0,0,0,457,
  	455,1,0,0,0,457,458,1,0,0,0,458,49,1,0,0,0,459,457,1,0,0,0,460,462,3,
  	4,2,0,461,460,1,0,0,0,461,462,1,0,0,0,462,463,1,0,0,0,463,465,5,6,0,0,
  	464,466,3,64,32,0,465,464,1,0,0,0,465,466,1,0,0,0,466,467,1,0,0,0,467,
  	468,5,7,0,0,468,469,5,54,0,0,469,470,3,18,9,0,470,51,1,0,0,0,471,473,
  	5,68,0,0,472,474,3,4,2,0,473,472,1,0,0,0,473,474,1,0,0,0,474,475,1,0,
  	0,0,475,477,5,6,0,0,476,478,3,64,32,0,477,476,1,0,0,0,477,478,1,0,0,0,
  	478,479,1,0,0,0,479,480,5,7,0,0,480,481,5,54,0,0,481,482,3,18,9,0,482,
  	53,1,0,0,0,483,484,5,65,0,0,484,485,3,56,28,0,485,55,1,0,0,0,486,497,
  	5,124,0,0,487,488,3,274,137,0,488,489,5,17,0,0,489,491,1,0,0,0,490,487,
  	1,0,0,0,491,492,1,0,0,0,492,490,1,0,0,0,492,493,1,0,0,0,493,494,1,0,0,
  	0,494,495,3,274,137,0,495,497,1,0,0,0,496,486,1,0,0,0,496,490,1,0,0,0,
  	497,57,1,0,0,0,498,500,5,90,0,0,499,498,1,0,0,0,499,500,1,0,0,0,500,501,
  	1,0,0,0,501,503,3,242,121,0,502,504,5,14,0,0,503,502,1,0,0,0,503,504,
  	1,0,0,0,504,506,1,0,0,0,505,507,3,60,30,0,506,505,1,0,0,0,506,507,1,0,
  	0,0,507,510,1,0,0,0,508,509,5,54,0,0,509,511,3,18,9,0,510,508,1,0,0,0,
  	510,511,1,0,0,0,511,59,1,0,0,0,512,513,5,15,0,0,513,514,3,18,9,0,514,
  	61,1,0,0,0,515,517,3,4,2,0,516,515,1,0,0,0,516,517,1,0,0,0,517,518,1,
  	0,0,0,518,520,5,6,0,0,519,521,3,64,32,0,520,519,1,0,0,0,520,521,1,0,0,
  	0,521,522,1,0,0,0,522,524,5,7,0,0,523,525,3,60,30,0,524,523,1,0,0,0,524,
  	525,1,0,0,0,525,63,1,0,0,0,526,540,3,72,36,0,527,532,3,68,34,0,528,529,
  	5,12,0,0,529,531,3,68,34,0,530,528,1,0,0,0,531,534,1,0,0,0,532,530,1,
  	0,0,0,532,533,1,0,0,0,533,537,1,0,0,0,534,532,1,0,0,0,535,536,5,12,0,
  	0,536,538,3,72,36,0,537,535,1,0,0,0,537,538,1,0,0,0,538,540,1,0,0,0,539,
  	526,1,0,0,0,539,527,1,0,0,0,540,65,1,0,0,0,541,546,3,74,37,0,542,543,
  	5,12,0,0,543,545,3,74,37,0,544,542,1,0,0,0,545,548,1,0,0,0,546,544,1,
  	0,0,0,546,547,1,0,0,0,547,67,1,0,0,0,548,546,1,0,0,0,549,552,3,74,37,
  	0,550,552,3,70,35,0,551,549,1,0,0,0,551,550,1,0,0,0,552,69,1,0,0,0,553,
  	555,3,110,55,0,554,553,1,0,0,0,554,555,1,0,0,0,555,557,1,0,0,0,556,558,
  	3,76,38,0,557,556,1,0,0,0,557,558,1,0,0,0,558,559,1,0,0,0,559,568,3,78,
  	39,0,560,562,5,14,0,0,561,563,3,60,30,0,562,561,1,0,0,0,562,563,1,0,0,
  	0,563,569,1,0,0,0,564,566,3,60,30,0,565,564,1,0,0,0,565,566,1,0,0,0,566,
  	567,1,0,0,0,567,569,3,0,0,0,568,560,1,0,0,0,568,565,1,0,0,0,569,71,1,
  	0,0,0,570,571,5,16,0,0,571,573,3,254,127,0,572,574,3,60,30,0,573,572,
  	1,0,0,0,573,574,1,0,0,0,574,73,1,0,0,0,575,577,3,110,55,0,576,575,1,0,
  	0,0,576,577,1,0,0,0,577,579,1,0,0,0,578,580,3,76,38,0,579,578,1,0,0,0,
  	579,580,1,0,0,0,580,581,1,0,0,0,581,583,3,78,39,0,582,584,3,60,30,0,583,
  	582,1,0,0,0,583,584,1,0,0,0,584,75,1,0,0,0,585,586,7,2,0,0,586,77,1,0,
  	0,0,587,590,3,274,137,0,588,590,3,2,1,0,589,587,1,0,0,0,589,588,1,0,0,
  	0,590,79,1,0,0,0,591,593,5,68,0,0,592,594,3,4,2,0,593,592,1,0,0,0,593,
  	594,1,0,0,0,594,595,1,0,0,0,595,597,5,6,0,0,596,598,3,64,32,0,597,596,
  	1,0,0,0,597,598,1,0,0,0,598,599,1,0,0,0,599,601,5,7,0,0,600,602,3,60,
  	30,0,601,600,1,0,0,0,601,602,1,0,0,0,602,81,1,0,0,0,603,604,5,4,0,0,604,
  	605,5,124,0,0,605,606,5,15,0,0,606,607,7,3,0,0,607,608,5,5,0,0,608,609,
  	3,60,30,0,609,83,1,0,0,0,610,612,3,242,121,0,611,613,5,14,0,0,612,611,
  	1,0,0,0,612,613,1,0,0,0,613,614,1,0,0,0,614,615,3,62,31,0,615,85,1,0,
  	0,0,616,617,5,113,0,0,617,619,5,124,0,0,618,620,3,4,2,0,619,618,1,0,0,
  	0,619,620,1,0,0,0,620,621,1,0,0,0,621,622,5,13,0,0,622,623,3,18,9,0,623,
  	624,5,11,0,0,624,87,1,0,0,0,625,627,3,76,38,0,626,625,1,0,0,0,626,627,
  	1,0,0,0,627,628,1,0,0,0,628,629,5,116,0,0,629,631,5,6,0,0,630,632,3,218,
  	109,0,631,630,1,0,0,0,631,632,1,0,0,0,632,633,1,0,0,0,633,639,5,7,0,0,
  	634,635,5,8,0,0,635,636,3,224,112,0,636,637,5,10,0,0,637,640,1,0,0,0,
  	638,640,5,11,0,0,639,634,1,0,0,0,639,638,1,0,0,0,639,640,1,0,0,0,640,
  	89,1,0,0,0,641,643,5,97,0,0,642,641,1,0,0,0,642,643,1,0,0,0,643,645,1,
  	0,0,0,644,646,5,120,0,0,645,644,1,0,0,0,645,646,1,0,0,0,646,647,1,0,0,
  	0,647,648,5,103,0,0,648,650,5,124,0,0,649,651,3,4,2,0,650,649,1,0,0,0,
  	650,651,1,0,0,0,651,653,1,0,0,0,652,654,3,92,46,0,653,652,1,0,0,0,653,
  	654,1,0,0,0,654,655,1,0,0,0,655,657,3,36,18,0,656,658,5,11,0,0,657,656,
  	1,0,0,0,657,658,1,0,0,0,658,91,1,0,0,0,659,660,5,94,0,0,660,661,3,94,
  	47,0,661,93,1,0,0,0,662,667,3,26,13,0,663,664,5,12,0,0,664,666,3,26,13,
  	0,665,663,1,0,0,0,666,669,1,0,0,0,667,665,1,0,0,0,667,668,1,0,0,0,668,
  	95,1,0,0,0,669,667,1,0,0,0,670,672,5,96,0,0,671,670,1,0,0,0,671,672,1,
  	0,0,0,672,673,1,0,0,0,673,674,5,93,0,0,674,675,5,124,0,0,675,677,5,8,
  	0,0,676,678,3,98,49,0,677,676,1,0,0,0,677,678,1,0,0,0,678,679,1,0,0,0,
  	679,680,5,10,0,0,680,97,1,0,0,0,681,683,3,100,50,0,682,684,5,12,0,0,683,
  	682,1,0,0,0,683,684,1,0,0,0,684,99,1,0,0,0,685,690,3,102,51,0,686,687,
  	5,12,0,0,687,689,3,102,51,0,688,686,1,0,0,0,689,692,1,0,0,0,690,688,1,
  	0,0,0,690,691,1,0,0,0,691,101,1,0,0,0,692,690,1,0,0,0,693,696,3,242,121,
  	0,694,695,5,13,0,0,695,697,3,254,127,0,696,694,1,0,0,0,696,697,1,0,0,
  	0,697,103,1,0,0,0,698,699,5,117,0,0,699,700,3,106,53,0,700,702,5,8,0,
  	0,701,703,3,126,63,0,702,701,1,0,0,0,702,703,1,0,0,0,703,704,1,0,0,0,
  	704,705,5,10,0,0,705,105,1,0,0,0,706,715,5,124,0,0,707,709,5,17,0,0,708,
  	707,1,0,0,0,709,710,1,0,0,0,710,708,1,0,0,0,710,711,1,0,0,0,711,712,1,
  	0,0,0,712,714,5,124,0,0,713,708,1,0,0,0,714,717,1,0,0,0,715,713,1,0,0,
  	0,715,716,1,0,0,0,716,107,1,0,0,0,717,715,1,0,0,0,718,719,5,124,0,0,719,
  	720,5,13,0,0,720,721,3,106,53,0,721,722,5,11,0,0,722,109,1,0,0,0,723,
  	725,3,112,56,0,724,723,1,0,0,0,725,726,1,0,0,0,726,724,1,0,0,0,726,727,
  	1,0,0,0,727,111,1,0,0,0,728,731,5,123,0,0,729,732,3,114,57,0,730,732,
  	3,116,58,0,731,729,1,0,0,0,731,730,1,0,0,0,732,113,1,0,0,0,733,734,6,
  	57,-1,0,734,740,5,124,0,0,735,736,5,6,0,0,736,737,3,254,127,0,737,738,
  	5,7,0,0,738,740,1,0,0,0,739,733,1,0,0,0,739,735,1,0,0,0,740,746,1,0,0,
  	0,741,742,10,2,0,0,742,743,5,17,0,0,743,745,3,274,137,0,744,741,1,0,0,
  	0,745,748,1,0,0,0,746,744,1,0,0,0,746,747,1,0,0,0,747,115,1,0,0,0,748,
  	746,1,0,0,0,749,750,3,114,57,0,750,751,3,244,122,0,751,117,1,0,0,0,752,
  	754,3,226,113,0,753,752,1,0,0,0,753,754,1,0,0,0,754,755,1,0,0,0,755,756,
  	5,0,0,1,756,119,1,0,0,0,757,759,5,97,0,0,758,757,1,0,0,0,758,759,1,0,
  	0,0,759,760,1,0,0,0,760,761,3,122,61,0,761,121,1,0,0,0,762,793,3,124,
  	62,0,763,793,3,130,65,0,764,793,3,136,68,0,765,793,3,144,72,0,766,793,
  	3,128,64,0,767,793,3,110,55,0,768,793,3,188,94,0,769,793,3,90,45,0,770,
  	793,3,104,52,0,771,793,3,148,74,0,772,793,3,150,75,0,773,793,3,154,77,
  	0,774,793,3,156,78,0,775,793,3,158,79,0,776,793,3,160,80,0,777,793,3,
  	162,81,0,778,793,3,174,87,0,779,793,3,164,82,0,780,793,3,176,88,0,781,
  	793,3,178,89,0,782,793,3,184,92,0,783,793,3,186,93,0,784,793,3,258,129,
  	0,785,793,3,208,104,0,786,793,3,138,69,0,787,793,3,86,43,0,788,793,3,
  	96,48,0,789,793,3,146,73,0,790,791,5,97,0,0,791,793,3,122,61,0,792,762,
  	1,0,0,0,792,763,1,0,0,0,792,764,1,0,0,0,792,765,1,0,0,0,792,766,1,0,0,
  	0,792,767,1,0,0,0,792,768,1,0,0,0,792,769,1,0,0,0,792,770,1,0,0,0,792,
  	771,1,0,0,0,792,772,1,0,0,0,792,773,1,0,0,0,792,774,1,0,0,0,792,775,1,
  	0,0,0,792,776,1,0,0,0,792,777,1,0,0,0,792,778,1,0,0,0,792,779,1,0,0,0,
  	792,780,1,0,0,0,792,781,1,0,0,0,792,782,1,0,0,0,792,783,1,0,0,0,792,784,
  	1,0,0,0,792,785,1,0,0,0,792,786,1,0,0,0,792,787,1,0,0,0,792,788,1,0,0,
  	0,792,789,1,0,0,0,792,790,1,0,0,0,793,123,1,0,0,0,794,796,5,8,0,0,795,
  	797,3,126,63,0,796,795,1,0,0,0,796,797,1,0,0,0,797,798,1,0,0,0,798,799,
  	5,10,0,0,799,125,1,0,0,0,800,802,3,122,61,0,801,800,1,0,0,0,802,803,1,
  	0,0,0,803,801,1,0,0,0,803,804,1,0,0,0,804,127,1,0,0,0,805,809,5,121,0,
  	0,806,807,5,124,0,0,807,810,3,62,31,0,808,810,3,138,69,0,809,806,1,0,
  	0,0,809,808,1,0,0,0,810,811,1,0,0,0,811,812,3,286,143,0,812,129,1,0,0,
  	0,813,816,5,98,0,0,814,817,3,132,66,0,815,817,3,108,54,0,816,814,1,0,
  	0,0,816,815,1,0,0,0,817,131,1,0,0,0,818,821,5,24,0,0,819,821,3,134,67,
  	0,820,818,1,0,0,0,820,819,1,0,0,0,821,824,1,0,0,0,822,823,5,88,0,0,823,
  	825,3,274,137,0,824,822,1,0,0,0,824,825,1,0,0,0,825,826,1,0,0,0,826,827,
  	5,89,0,0,827,828,5,125,0,0,828,829,3,286,143,0,829,133,1,0,0,0,830,831,
  	3,274,137,0,831,832,5,12,0,0,832,834,1,0,0,0,833,830,1,0,0,0,833,834,
  	1,0,0,0,834,835,1,0,0,0,835,836,5,8,0,0,836,841,3,274,137,0,837,838,5,
  	12,0,0,838,840,3,274,137,0,839,837,1,0,0,0,840,843,1,0,0,0,841,839,1,
  	0,0,0,841,842,1,0,0,0,842,844,1,0,0,0,843,841,1,0,0,0,844,845,5,10,0,
  	0,845,135,1,0,0,0,846,848,5,97,0,0,847,849,5,82,0,0,848,847,1,0,0,0,848,
  	849,1,0,0,0,849,852,1,0,0,0,850,853,3,132,66,0,851,853,3,122,61,0,852,
  	850,1,0,0,0,852,851,1,0,0,0,853,137,1,0,0,0,854,856,3,2,1,0,855,857,3,
  	60,30,0,856,855,1,0,0,0,856,857,1,0,0,0,857,858,1,0,0,0,858,860,3,0,0,
  	0,859,861,5,11,0,0,860,859,1,0,0,0,860,861,1,0,0,0,861,884,1,0,0,0,862,
  	864,3,76,38,0,863,862,1,0,0,0,863,864,1,0,0,0,864,866,1,0,0,0,865,867,
  	3,152,76,0,866,865,1,0,0,0,866,867,1,0,0,0,867,869,1,0,0,0,868,870,5,
  	90,0,0,869,868,1,0,0,0,869,870,1,0,0,0,870,871,1,0,0,0,871,873,3,140,
  	70,0,872,874,5,11,0,0,873,872,1,0,0,0,873,874,1,0,0,0,874,884,1,0,0,0,
  	875,877,5,120,0,0,876,878,3,152,76,0,877,876,1,0,0,0,877,878,1,0,0,0,
  	878,879,1,0,0,0,879,881,3,140,70,0,880,882,5,11,0,0,881,880,1,0,0,0,881,
  	882,1,0,0,0,882,884,1,0,0,0,883,854,1,0,0,0,883,863,1,0,0,0,883,875,1,
  	0,0,0,884,139,1,0,0,0,885,890,3,142,71,0,886,887,5,12,0,0,887,889,3,142,
  	71,0,888,886,1,0,0,0,889,892,1,0,0,0,890,888,1,0,0,0,890,891,1,0,0,0,
  	891,141,1,0,0,0,892,890,1,0,0,0,893,897,3,276,138,0,894,897,3,228,114,
  	0,895,897,3,234,117,0,896,893,1,0,0,0,896,894,1,0,0,0,896,895,1,0,0,0,
  	897,899,1,0,0,0,898,900,3,60,30,0,899,898,1,0,0,0,899,900,1,0,0,0,900,
  	902,1,0,0,0,901,903,3,254,127,0,902,901,1,0,0,0,902,903,1,0,0,0,903,909,
  	1,0,0,0,904,906,5,13,0,0,905,907,3,4,2,0,906,905,1,0,0,0,906,907,1,0,
  	0,0,907,908,1,0,0,0,908,910,3,254,127,0,909,904,1,0,0,0,909,910,1,0,0,
  	0,910,143,1,0,0,0,911,912,5,11,0,0,912,145,1,0,0,0,913,914,4,73,6,0,914,
  	916,3,250,125,0,915,917,5,11,0,0,916,915,1,0,0,0,916,917,1,0,0,0,917,
  	147,1,0,0,0,918,919,5,83,0,0,919,920,5,6,0,0,920,921,3,250,125,0,921,
  	922,5,7,0,0,922,925,3,122,61,0,923,924,5,67,0,0,924,926,3,122,61,0,925,
  	923,1,0,0,0,925,926,1,0,0,0,926,149,1,0,0,0,927,928,5,63,0,0,928,929,
  	3,122,61,0,929,930,5,77,0,0,930,931,5,6,0,0,931,932,3,250,125,0,932,933,
  	5,7,0,0,933,934,3,286,143,0,934,997,1,0,0,0,935,936,5,77,0,0,936,937,
  	5,6,0,0,937,938,3,250,125,0,938,939,5,7,0,0,939,940,3,122,61,0,940,997,
  	1,0,0,0,941,942,5,75,0,0,942,944,5,6,0,0,943,945,3,250,125,0,944,943,
  	1,0,0,0,944,945,1,0,0,0,945,946,1,0,0,0,946,948,5,11,0,0,947,949,3,250,
  	125,0,948,947,1,0,0,0,948,949,1,0,0,0,949,950,1,0,0,0,950,952,5,11,0,
  	0,951,953,3,250,125,0,952,951,1,0,0,0,952,953,1,0,0,0,953,954,1,0,0,0,
  	954,955,5,7,0,0,955,997,3,122,61,0,956,957,5,75,0,0,957,958,5,6,0,0,958,
  	959,3,152,76,0,959,960,3,140,70,0,960,962,5,11,0,0,961,963,3,250,125,
  	0,962,961,1,0,0,0,962,963,1,0,0,0,963,964,1,0,0,0,964,966,5,11,0,0,965,
  	967,3,250,125,0,966,965,1,0,0,0,966,967,1,0,0,0,967,968,1,0,0,0,968,969,
  	5,7,0,0,969,970,3,122,61,0,970,997,1,0,0,0,971,972,5,75,0,0,972,973,5,
  	6,0,0,973,977,3,254,127,0,974,978,5,86,0,0,975,976,5,124,0,0,976,978,
  	4,75,7,0,977,974,1,0,0,0,977,975,1,0,0,0,978,979,1,0,0,0,979,980,3,250,
  	125,0,980,981,5,7,0,0,981,982,3,122,61,0,982,997,1,0,0,0,983,984,5,75,
  	0,0,984,985,5,6,0,0,985,986,3,152,76,0,986,990,3,142,71,0,987,991,5,86,
  	0,0,988,989,5,124,0,0,989,991,4,75,8,0,990,987,1,0,0,0,990,988,1,0,0,
  	0,991,992,1,0,0,0,992,993,3,250,125,0,993,994,5,7,0,0,994,995,3,122,61,
  	0,995,997,1,0,0,0,996,927,1,0,0,0,996,935,1,0,0,0,996,941,1,0,0,0,996,
  	956,1,0,0,0,996,971,1,0,0,0,996,983,1,0,0,0,997,151,1,0,0,0,998,999,7,
  	4,0,0,999,153,1,0,0,0,1000,1003,5,74,0,0,1001,1002,4,77,9,0,1002,1004,
  	5,124,0,0,1003,1001,1,0,0,0,1003,1004,1,0,0,0,1004,1005,1,0,0,0,1005,
  	1006,3,286,143,0,1006,155,1,0,0,0,1007,1010,5,62,0,0,1008,1009,4,78,10,
  	0,1009,1011,5,124,0,0,1010,1008,1,0,0,0,1010,1011,1,0,0,0,1011,1012,1,
  	0,0,0,1012,1013,3,286,143,0,1013,157,1,0,0,0,1014,1017,5,72,0,0,1015,
  	1016,4,79,11,0,1016,1018,3,250,125,0,1017,1015,1,0,0,0,1017,1018,1,0,
  	0,0,1018,1019,1,0,0,0,1019,1020,3,286,143,0,1020,159,1,0,0,0,1021,1024,
  	5,107,0,0,1022,1023,4,80,12,0,1023,1025,3,250,125,0,1024,1022,1,0,0,0,
  	1024,1025,1,0,0,0,1025,1026,1,0,0,0,1026,1027,3,286,143,0,1027,161,1,
  	0,0,0,1028,1029,5,81,0,0,1029,1030,5,6,0,0,1030,1031,3,250,125,0,1031,
  	1032,5,7,0,0,1032,1033,3,122,61,0,1033,163,1,0,0,0,1034,1035,5,76,0,0,
  	1035,1036,5,6,0,0,1036,1037,3,250,125,0,1037,1038,5,7,0,0,1038,1039,3,
  	166,83,0,1039,165,1,0,0,0,1040,1042,5,8,0,0,1041,1043,3,168,84,0,1042,
  	1041,1,0,0,0,1042,1043,1,0,0,0,1043,1048,1,0,0,0,1044,1046,3,172,86,0,
  	1045,1047,3,168,84,0,1046,1045,1,0,0,0,1046,1047,1,0,0,0,1047,1049,1,
  	0,0,0,1048,1044,1,0,0,0,1048,1049,1,0,0,0,1049,1050,1,0,0,0,1050,1051,
  	5,10,0,0,1051,167,1,0,0,0,1052,1054,3,170,85,0,1053,1052,1,0,0,0,1054,
  	1055,1,0,0,0,1055,1053,1,0,0,0,1055,1056,1,0,0,0,1056,169,1,0,0,0,1057,
  	1058,5,66,0,0,1058,1059,3,250,125,0,1059,1061,5,15,0,0,1060,1062,3,126,
  	63,0,1061,1060,1,0,0,0,1061,1062,1,0,0,0,1062,171,1,0,0,0,1063,1064,5,
  	82,0,0,1064,1066,5,15,0,0,1065,1067,3,126,63,0,1066,1065,1,0,0,0,1066,
  	1067,1,0,0,0,1067,173,1,0,0,0,1068,1069,5,124,0,0,1069,1070,5,15,0,0,
  	1070,1071,3,122,61,0,1071,175,1,0,0,0,1072,1073,5,84,0,0,1073,1074,4,
  	88,13,0,1074,1075,3,250,125,0,1075,1076,3,286,143,0,1076,177,1,0,0,0,
  	1077,1078,5,87,0,0,1078,1084,3,124,62,0,1079,1081,3,180,90,0,1080,1082,
  	3,182,91,0,1081,1080,1,0,0,0,1081,1082,1,0,0,0,1082,1085,1,0,0,0,1083,
  	1085,3,182,91,0,1084,1079,1,0,0,0,1084,1083,1,0,0,0,1085,179,1,0,0,0,
  	1086,1087,5,70,0,0,1087,1088,5,6,0,0,1088,1089,5,124,0,0,1089,1090,5,
  	7,0,0,1090,1091,3,124,62,0,1091,181,1,0,0,0,1092,1093,5,71,0,0,1093,1094,
  	3,124,62,0,1094,183,1,0,0,0,1095,1096,5,78,0,0,1096,1097,3,286,143,0,
  	1097,185,1,0,0,0,1098,1099,5,79,0,0,1099,1100,5,124,0,0,1100,1106,3,62,
  	31,0,1101,1102,5,8,0,0,1102,1103,3,224,112,0,1103,1104,5,10,0,0,1104,
  	1107,1,0,0,0,1105,1107,5,11,0,0,1106,1101,1,0,0,0,1106,1105,1,0,0,0,1107,
  	187,1,0,0,0,1108,1110,5,121,0,0,1109,1108,1,0,0,0,1109,1110,1,0,0,0,1110,
  	1111,1,0,0,0,1111,1112,5,92,0,0,1112,1114,5,124,0,0,1113,1115,3,4,2,0,
  	1114,1113,1,0,0,0,1114,1115,1,0,0,0,1115,1116,1,0,0,0,1116,1117,3,190,
  	95,0,1117,1118,3,192,96,0,1118,189,1,0,0,0,1119,1121,3,194,97,0,1120,
  	1119,1,0,0,0,1120,1121,1,0,0,0,1121,1123,1,0,0,0,1122,1124,3,196,98,0,
  	1123,1122,1,0,0,0,1123,1124,1,0,0,0,1124,191,1,0,0,0,1125,1129,5,8,0,
  	0,1126,1128,3,198,99,0,1127,1126,1,0,0,0,1128,1131,1,0,0,0,1129,1127,
  	1,0,0,0,1129,1130,1,0,0,0,1130,1132,1,0,0,0,1131,1129,1,0,0,0,1132,1133,
  	5,10,0,0,1133,193,1,0,0,0,1134,1135,5,94,0,0,1135,1136,3,26,13,0,1136,
  	195,1,0,0,0,1137,1138,5,99,0,0,1138,1139,3,94,47,0,1139,197,1,0,0,0,1140,
  	1148,3,88,44,0,1141,1143,3,110,55,0,1142,1141,1,0,0,0,1142,1143,1,0,0,
  	0,1143,1144,1,0,0,0,1144,1148,3,200,100,0,1145,1148,3,204,102,0,1146,
  	1148,3,122,61,0,1147,1140,1,0,0,0,1147,1142,1,0,0,0,1147,1145,1,0,0,0,
  	1147,1146,1,0,0,0,1148,199,1,0,0,0,1149,1150,3,202,101,0,1150,1152,3,
  	242,121,0,1151,1153,5,14,0,0,1152,1151,1,0,0,0,1152,1153,1,0,0,0,1153,
  	1155,1,0,0,0,1154,1156,3,60,30,0,1155,1154,1,0,0,0,1155,1156,1,0,0,0,
  	1156,1158,1,0,0,0,1157,1159,3,0,0,0,1158,1157,1,0,0,0,1158,1159,1,0,0,
  	0,1159,1160,1,0,0,0,1160,1161,5,11,0,0,1161,1179,1,0,0,0,1162,1163,3,
  	202,101,0,1163,1164,3,242,121,0,1164,1170,3,62,31,0,1165,1166,5,8,0,0,
  	1166,1167,3,224,112,0,1167,1168,5,10,0,0,1168,1171,1,0,0,0,1169,1171,
  	5,11,0,0,1170,1165,1,0,0,0,1170,1169,1,0,0,0,1171,1179,1,0,0,0,1172,1175,
  	3,202,101,0,1173,1176,3,238,119,0,1174,1176,3,240,120,0,1175,1173,1,0,
  	0,0,1175,1174,1,0,0,0,1176,1179,1,0,0,0,1177,1179,3,128,64,0,1178,1149,
  	1,0,0,0,1178,1162,1,0,0,0,1178,1172,1,0,0,0,1178,1177,1,0,0,0,1179,201,
  	1,0,0,0,1180,1182,5,91,0,0,1181,1180,1,0,0,0,1181,1182,1,0,0,0,1182,1184,
  	1,0,0,0,1183,1185,3,76,38,0,1184,1183,1,0,0,0,1184,1185,1,0,0,0,1185,
  	1187,1,0,0,0,1186,1188,5,106,0,0,1187,1186,1,0,0,0,1187,1188,1,0,0,0,
  	1188,1190,1,0,0,0,1189,1191,5,90,0,0,1190,1189,1,0,0,0,1190,1191,1,0,
  	0,0,1191,203,1,0,0,0,1192,1193,3,82,41,0,1193,1194,5,11,0,0,1194,205,
  	1,0,0,0,1195,1197,5,24,0,0,1196,1195,1,0,0,0,1196,1197,1,0,0,0,1197,1198,
  	1,0,0,0,1198,1199,5,124,0,0,1199,1201,5,6,0,0,1200,1202,3,218,109,0,1201,
  	1200,1,0,0,0,1201,1202,1,0,0,0,1202,1203,1,0,0,0,1203,1204,5,7,0,0,1204,
  	1205,5,8,0,0,1205,1206,3,224,112,0,1206,1207,5,10,0,0,1207,207,1,0,0,
  	0,1208,1209,5,79,0,0,1209,1211,5,24,0,0,1210,1212,5,124,0,0,1211,1210,
  	1,0,0,0,1211,1212,1,0,0,0,1212,1213,1,0,0,0,1213,1215,5,6,0,0,1214,1216,
  	3,218,109,0,1215,1214,1,0,0,0,1215,1216,1,0,0,0,1216,1217,1,0,0,0,1217,
  	1218,5,7,0,0,1218,1219,5,8,0,0,1219,1220,3,224,112,0,1220,1221,5,10,0,
  	0,1221,209,1,0,0,0,1222,1223,5,8,0,0,1223,1228,3,212,106,0,1224,1225,
  	5,12,0,0,1225,1227,3,212,106,0,1226,1224,1,0,0,0,1227,1230,1,0,0,0,1228,
  	1226,1,0,0,0,1228,1229,1,0,0,0,1229,1232,1,0,0,0,1230,1228,1,0,0,0,1231,
  	1233,5,12,0,0,1232,1231,1,0,0,0,1232,1233,1,0,0,0,1233,1234,1,0,0,0,1234,
  	1235,5,10,0,0,1235,211,1,0,0,0,1236,1237,5,24,0,0,1237,1238,3,216,108,
  	0,1238,213,1,0,0,0,1239,1240,5,8,0,0,1240,1245,3,216,108,0,1241,1242,
  	5,12,0,0,1242,1244,3,216,108,0,1243,1241,1,0,0,0,1244,1247,1,0,0,0,1245,
  	1243,1,0,0,0,1245,1246,1,0,0,0,1246,1249,1,0,0,0,1247,1245,1,0,0,0,1248,
  	1250,5,12,0,0,1249,1248,1,0,0,0,1249,1250,1,0,0,0,1250,1251,1,0,0,0,1251,
  	1252,5,10,0,0,1252,215,1,0,0,0,1253,1254,5,4,0,0,1254,1255,3,254,127,
  	0,1255,1256,5,5,0,0,1256,1258,5,6,0,0,1257,1259,3,218,109,0,1258,1257,
  	1,0,0,0,1258,1259,1,0,0,0,1259,1260,1,0,0,0,1260,1261,5,7,0,0,1261,1262,
  	5,8,0,0,1262,1263,3,224,112,0,1263,1264,5,10,0,0,1264,217,1,0,0,0,1265,
  	1270,3,220,110,0,1266,1267,5,12,0,0,1267,1269,3,220,110,0,1268,1266,1,
  	0,0,0,1269,1272,1,0,0,0,1270,1268,1,0,0,0,1270,1271,1,0,0,0,1271,1275,
  	1,0,0,0,1272,1270,1,0,0,0,1273,1274,5,12,0,0,1274,1276,3,222,111,0,1275,
  	1273,1,0,0,0,1275,1276,1,0,0,0,1276,1285,1,0,0,0,1277,1285,3,222,111,
  	0,1278,1285,3,228,114,0,1279,1282,3,234,117,0,1280,1281,5,15,0,0,1281,
  	1283,3,218,109,0,1282,1280,1,0,0,0,1282,1283,1,0,0,0,1283,1285,1,0,0,
  	0,1284,1265,1,0,0,0,1284,1277,1,0,0,0,1284,1278,1,0,0,0,1284,1279,1,0,
  	0,0,1285,219,1,0,0,0,1286,1288,3,112,56,0,1287,1286,1,0,0,0,1287,1288,
  	1,0,0,0,1288,1290,1,0,0,0,1289,1291,3,76,38,0,1290,1289,1,0,0,0,1290,
  	1291,1,0,0,0,1291,1292,1,0,0,0,1292,1294,3,276,138,0,1293,1295,5,14,0,
  	0,1294,1293,1,0,0,0,1294,1295,1,0,0,0,1295,1297,1,0,0,0,1296,1298,3,60,
  	30,0,1297,1296,1,0,0,0,1297,1298,1,0,0,0,1298,1301,1,0,0,0,1299,1300,
  	5,13,0,0,1300,1302,3,254,127,0,1301,1299,1,0,0,0,1301,1302,1,0,0,0,1302,
  	221,1,0,0,0,1303,1304,5,16,0,0,1304,1305,5,124,0,0,1305,223,1,0,0,0,1306,
  	1308,3,226,113,0,1307,1306,1,0,0,0,1307,1308,1,0,0,0,1308,225,1,0,0,0,
  	1309,1311,3,120,60,0,1310,1309,1,0,0,0,1311,1312,1,0,0,0,1312,1310,1,
  	0,0,0,1312,1313,1,0,0,0,1313,227,1,0,0,0,1314,1316,5,4,0,0,1315,1317,
  	3,230,115,0,1316,1315,1,0,0,0,1316,1317,1,0,0,0,1317,1318,1,0,0,0,1318,
  	1319,5,5,0,0,1319,229,1,0,0,0,1320,1329,3,232,116,0,1321,1323,5,12,0,
  	0,1322,1321,1,0,0,0,1323,1324,1,0,0,0,1324,1322,1,0,0,0,1324,1325,1,0,
  	0,0,1325,1326,1,0,0,0,1326,1328,3,232,116,0,1327,1322,1,0,0,0,1328,1331,
  	1,0,0,0,1329,1327,1,0,0,0,1329,1330,1,0,0,0,1330,231,1,0,0,0,1331,1329,
  	1,0,0,0,1332,1334,5,16,0,0,1333,1332,1,0,0,0,1333,1334,1,0,0,0,1334,1337,
  	1,0,0,0,1335,1338,3,254,127,0,1336,1338,5,124,0,0,1337,1335,1,0,0,0,1337,
  	1336,1,0,0,0,1338,1340,1,0,0,0,1339,1341,5,12,0,0,1340,1339,1,0,0,0,1340,
  	1341,1,0,0,0,1341,233,1,0,0,0,1342,1354,5,8,0,0,1343,1348,3,236,118,0,
  	1344,1345,5,12,0,0,1345,1347,3,236,118,0,1346,1344,1,0,0,0,1347,1350,
  	1,0,0,0,1348,1346,1,0,0,0,1348,1349,1,0,0,0,1349,1352,1,0,0,0,1350,1348,
  	1,0,0,0,1351,1353,5,12,0,0,1352,1351,1,0,0,0,1352,1353,1,0,0,0,1353,1355,
  	1,0,0,0,1354,1343,1,0,0,0,1354,1355,1,0,0,0,1355,1356,1,0,0,0,1356,1357,
  	5,10,0,0,1357,235,1,0,0,0,1358,1359,3,242,121,0,1359,1360,7,5,0,0,1360,
  	1361,3,254,127,0,1361,1374,1,0,0,0,1362,1363,5,4,0,0,1363,1364,3,254,
  	127,0,1364,1365,5,5,0,0,1365,1366,5,15,0,0,1366,1367,3,254,127,0,1367,
  	1374,1,0,0,0,1368,1374,3,238,119,0,1369,1374,3,240,120,0,1370,1374,3,
  	206,103,0,1371,1374,3,276,138,0,1372,1374,3,72,36,0,1373,1358,1,0,0,0,
  	1373,1362,1,0,0,0,1373,1368,1,0,0,0,1373,1369,1,0,0,0,1373,1370,1,0,0,
  	0,1373,1371,1,0,0,0,1373,1372,1,0,0,0,1374,237,1,0,0,0,1375,1376,3,282,
  	141,0,1376,1377,5,6,0,0,1377,1379,5,7,0,0,1378,1380,3,60,30,0,1379,1378,
  	1,0,0,0,1379,1380,1,0,0,0,1380,1381,1,0,0,0,1381,1382,5,8,0,0,1382,1383,
  	3,224,112,0,1383,1384,5,10,0,0,1384,239,1,0,0,0,1385,1386,3,284,142,0,
  	1386,1389,5,6,0,0,1387,1390,5,124,0,0,1388,1390,3,2,1,0,1389,1387,1,0,
  	0,0,1389,1388,1,0,0,0,1390,1392,1,0,0,0,1391,1393,3,60,30,0,1392,1391,
  	1,0,0,0,1392,1393,1,0,0,0,1393,1394,1,0,0,0,1394,1395,5,7,0,0,1395,1396,
  	5,8,0,0,1396,1397,3,224,112,0,1397,1398,5,10,0,0,1398,241,1,0,0,0,1399,
  	1403,3,274,137,0,1400,1403,5,125,0,0,1401,1403,3,272,136,0,1402,1399,
  	1,0,0,0,1402,1400,1,0,0,0,1402,1401,1,0,0,0,1403,243,1,0,0,0,1404,1409,
  	5,6,0,0,1405,1407,3,246,123,0,1406,1408,5,12,0,0,1407,1406,1,0,0,0,1407,
  	1408,1,0,0,0,1408,1410,1,0,0,0,1409,1405,1,0,0,0,1409,1410,1,0,0,0,1410,
  	1411,1,0,0,0,1411,1412,5,7,0,0,1412,245,1,0,0,0,1413,1418,3,248,124,0,
  	1414,1415,5,12,0,0,1415,1417,3,248,124,0,1416,1414,1,0,0,0,1417,1420,
  	1,0,0,0,1418,1416,1,0,0,0,1418,1419,1,0,0,0,1419,247,1,0,0,0,1420,1418,
  	1,0,0,0,1421,1423,5,16,0,0,1422,1421,1,0,0,0,1422,1423,1,0,0,0,1423,1426,
  	1,0,0,0,1424,1427,3,254,127,0,1425,1427,5,124,0,0,1426,1424,1,0,0,0,1426,
  	1425,1,0,0,0,1427,249,1,0,0,0,1428,1433,3,254,127,0,1429,1430,5,12,0,
  	0,1430,1432,3,254,127,0,1431,1429,1,0,0,0,1432,1435,1,0,0,0,1433,1431,
  	1,0,0,0,1433,1434,1,0,0,0,1434,251,1,0,0,0,1435,1433,1,0,0,0,1436,1438,
  	5,79,0,0,1437,1439,5,124,0,0,1438,1437,1,0,0,0,1438,1439,1,0,0,0,1439,
  	1440,1,0,0,0,1440,1442,5,6,0,0,1441,1443,3,218,109,0,1442,1441,1,0,0,
  	0,1442,1443,1,0,0,0,1443,1444,1,0,0,0,1444,1446,5,7,0,0,1445,1447,3,60,
  	30,0,1446,1445,1,0,0,0,1446,1447,1,0,0,0,1447,1448,1,0,0,0,1448,1449,
  	5,8,0,0,1449,1450,3,224,112,0,1450,1451,5,10,0,0,1451,253,1,0,0,0,1452,
  	1453,6,127,-1,0,1453,1512,3,252,126,0,1454,1512,3,258,129,0,1455,1457,
  	5,92,0,0,1456,1458,5,124,0,0,1457,1456,1,0,0,0,1457,1458,1,0,0,0,1458,
  	1459,1,0,0,0,1459,1512,3,192,96,0,1460,1461,5,68,0,0,1461,1463,3,254,
  	127,0,1462,1464,3,12,6,0,1463,1462,1,0,0,0,1463,1464,1,0,0,0,1464,1465,
  	1,0,0,0,1465,1466,3,244,122,0,1466,1512,1,0,0,0,1467,1468,5,68,0,0,1468,
  	1470,3,254,127,0,1469,1471,3,12,6,0,1470,1469,1,0,0,0,1470,1471,1,0,0,
  	0,1471,1512,1,0,0,0,1472,1473,5,85,0,0,1473,1512,3,254,127,38,1474,1475,
  	5,73,0,0,1475,1512,3,254,127,37,1476,1477,5,65,0,0,1477,1512,3,254,127,
  	36,1478,1479,5,18,0,0,1479,1512,3,254,127,35,1480,1481,5,19,0,0,1481,
  	1512,3,254,127,34,1482,1483,5,20,0,0,1483,1512,3,254,127,33,1484,1485,
  	5,21,0,0,1485,1512,3,254,127,32,1486,1487,5,22,0,0,1487,1512,3,254,127,
  	31,1488,1489,5,23,0,0,1489,1512,3,254,127,30,1490,1512,3,214,107,0,1491,
  	1512,3,210,105,0,1492,1512,3,208,104,0,1493,1512,3,160,80,0,1494,1512,
  	5,80,0,0,1495,1497,3,274,137,0,1496,1498,3,254,127,0,1497,1496,1,0,0,
  	0,1497,1498,1,0,0,0,1498,1512,1,0,0,0,1499,1512,5,95,0,0,1500,1512,3,
  	266,133,0,1501,1512,3,228,114,0,1502,1512,3,234,117,0,1503,1504,5,6,0,
  	0,1504,1505,3,250,125,0,1505,1506,5,7,0,0,1506,1512,1,0,0,0,1507,1509,
  	3,12,6,0,1508,1510,3,250,125,0,1509,1508,1,0,0,0,1509,1510,1,0,0,0,1510,
  	1512,1,0,0,0,1511,1452,1,0,0,0,1511,1454,1,0,0,0,1511,1455,1,0,0,0,1511,
  	1460,1,0,0,0,1511,1467,1,0,0,0,1511,1472,1,0,0,0,1511,1474,1,0,0,0,1511,
  	1476,1,0,0,0,1511,1478,1,0,0,0,1511,1480,1,0,0,0,1511,1482,1,0,0,0,1511,
  	1484,1,0,0,0,1511,1486,1,0,0,0,1511,1488,1,0,0,0,1511,1490,1,0,0,0,1511,
  	1491,1,0,0,0,1511,1492,1,0,0,0,1511,1493,1,0,0,0,1511,1494,1,0,0,0,1511,
  	1495,1,0,0,0,1511,1499,1,0,0,0,1511,1500,1,0,0,0,1511,1501,1,0,0,0,1511,
  	1502,1,0,0,0,1511,1503,1,0,0,0,1511,1507,1,0,0,0,1512,1588,1,0,0,0,1513,
  	1514,10,29,0,0,1514,1515,7,6,0,0,1515,1587,3,254,127,30,1516,1517,10,
  	28,0,0,1517,1518,7,7,0,0,1518,1587,3,254,127,29,1519,1520,10,27,0,0,1520,
  	1521,7,8,0,0,1521,1587,3,254,127,28,1522,1523,10,26,0,0,1523,1524,7,9,
  	0,0,1524,1587,3,254,127,27,1525,1526,10,25,0,0,1526,1527,5,64,0,0,1527,
  	1587,3,254,127,26,1528,1529,10,24,0,0,1529,1530,5,86,0,0,1530,1587,3,
  	254,127,25,1531,1532,10,23,0,0,1532,1533,7,10,0,0,1533,1587,3,254,127,
  	24,1534,1535,10,22,0,0,1535,1536,5,38,0,0,1536,1587,3,254,127,23,1537,
  	1538,10,21,0,0,1538,1539,5,39,0,0,1539,1587,3,254,127,22,1540,1541,10,
  	20,0,0,1541,1542,5,40,0,0,1542,1587,3,254,127,21,1543,1544,10,19,0,0,
  	1544,1545,5,41,0,0,1545,1587,3,254,127,20,1546,1547,10,18,0,0,1547,1548,
  	5,42,0,0,1548,1587,3,254,127,19,1549,1550,10,17,0,0,1550,1551,5,14,0,
  	0,1551,1552,3,254,127,0,1552,1553,5,15,0,0,1553,1554,3,254,127,18,1554,
  	1587,1,0,0,0,1555,1556,10,16,0,0,1556,1557,5,13,0,0,1557,1587,3,254,127,
  	17,1558,1559,10,15,0,0,1559,1560,3,264,132,0,1560,1561,3,254,127,16,1561,
  	1587,1,0,0,0,1562,1563,10,45,0,0,1563,1564,5,4,0,0,1564,1565,3,250,125,
  	0,1565,1566,5,5,0,0,1566,1587,1,0,0,0,1567,1568,10,44,0,0,1568,1569,5,
  	17,0,0,1569,1571,3,274,137,0,1570,1572,3,28,14,0,1571,1570,1,0,0,0,1571,
  	1572,1,0,0,0,1572,1587,1,0,0,0,1573,1574,10,41,0,0,1574,1587,3,244,122,
  	0,1575,1576,10,40,0,0,1576,1577,4,127,33,0,1577,1587,5,18,0,0,1578,1579,
  	10,39,0,0,1579,1580,4,127,35,0,1580,1587,5,19,0,0,1581,1582,10,14,0,0,
  	1582,1587,3,268,134,0,1583,1584,10,1,0,0,1584,1585,5,88,0,0,1585,1587,
  	3,256,128,0,1586,1513,1,0,0,0,1586,1516,1,0,0,0,1586,1519,1,0,0,0,1586,
  	1522,1,0,0,0,1586,1525,1,0,0,0,1586,1528,1,0,0,0,1586,1531,1,0,0,0,1586,
  	1534,1,0,0,0,1586,1537,1,0,0,0,1586,1540,1,0,0,0,1586,1543,1,0,0,0,1586,
  	1546,1,0,0,0,1586,1549,1,0,0,0,1586,1555,1,0,0,0,1586,1558,1,0,0,0,1586,
  	1562,1,0,0,0,1586,1567,1,0,0,0,1586,1573,1,0,0,0,1586,1575,1,0,0,0,1586,
  	1578,1,0,0,0,1586,1581,1,0,0,0,1586,1583,1,0,0,0,1587,1590,1,0,0,0,1588,
  	1586,1,0,0,0,1588,1589,1,0,0,0,1589,255,1,0,0,0,1590,1588,1,0,0,0,1591,
  	1594,3,24,12,0,1592,1593,5,4,0,0,1593,1595,5,5,0,0,1594,1592,1,0,0,0,
  	1594,1595,1,0,0,0,1595,1598,1,0,0,0,1596,1598,3,254,127,0,1597,1591,1,
  	0,0,0,1597,1596,1,0,0,0,1598,257,1,0,0,0,1599,1601,5,91,0,0,1600,1599,
  	1,0,0,0,1600,1601,1,0,0,0,1601,1602,1,0,0,0,1602,1604,3,260,130,0,1603,
  	1605,3,60,30,0,1604,1603,1,0,0,0,1604,1605,1,0,0,0,1605,1606,1,0,0,0,
  	1606,1607,5,54,0,0,1607,1608,3,262,131,0,1608,259,1,0,0,0,1609,1616,5,
  	124,0,0,1610,1612,5,6,0,0,1611,1613,3,218,109,0,1612,1611,1,0,0,0,1612,
  	1613,1,0,0,0,1613,1614,1,0,0,0,1614,1616,5,7,0,0,1615,1609,1,0,0,0,1615,
  	1610,1,0,0,0,1616,261,1,0,0,0,1617,1623,3,254,127,0,1618,1619,5,8,0,0,
  	1619,1620,3,224,112,0,1620,1621,5,10,0,0,1621,1623,1,0,0,0,1622,1617,
  	1,0,0,0,1622,1618,1,0,0,0,1623,263,1,0,0,0,1624,1625,7,11,0,0,1625,265,
  	1,0,0,0,1626,1633,5,55,0,0,1627,1633,5,56,0,0,1628,1633,5,125,0,0,1629,
  	1633,3,268,134,0,1630,1633,5,3,0,0,1631,1633,3,272,136,0,1632,1626,1,
  	0,0,0,1632,1627,1,0,0,0,1632,1628,1,0,0,0,1632,1629,1,0,0,0,1632,1630,
  	1,0,0,0,1632,1631,1,0,0,0,1633,267,1,0,0,0,1634,1638,5,126,0,0,1635,1637,
  	3,270,135,0,1636,1635,1,0,0,0,1637,1640,1,0,0,0,1638,1636,1,0,0,0,1638,
  	1639,1,0,0,0,1639,1641,1,0,0,0,1640,1638,1,0,0,0,1641,1642,5,126,0,0,
  	1642,269,1,0,0,0,1643,1649,5,133,0,0,1644,1645,5,132,0,0,1645,1646,3,
  	254,127,0,1646,1647,5,9,0,0,1647,1649,1,0,0,0,1648,1643,1,0,0,0,1648,
  	1644,1,0,0,0,1649,271,1,0,0,0,1650,1651,7,12,0,0,1651,273,1,0,0,0,1652,
  	1655,5,124,0,0,1653,1655,3,278,139,0,1654,1652,1,0,0,0,1654,1653,1,0,
  	0,0,1655,275,1,0,0,0,1656,1657,7,13,0,0,1657,277,1,0,0,0,1658,1662,3,
  	280,140,0,1659,1662,5,55,0,0,1660,1662,5,56,0,0,1661,1658,1,0,0,0,1661,
  	1659,1,0,0,0,1661,1660,1,0,0,0,1662,279,1,0,0,0,1663,1664,7,14,0,0,1664,
  	281,1,0,0,0,1665,1666,5,114,0,0,1666,1667,3,242,121,0,1667,283,1,0,0,
  	0,1668,1669,5,115,0,0,1669,1670,3,242,121,0,1670,285,1,0,0,0,1671,1676,
  	5,11,0,0,1672,1676,5,0,0,1,1673,1676,4,143,38,0,1674,1676,4,143,39,0,
  	1675,1671,1,0,0,0,1675,1672,1,0,0,0,1675,1673,1,0,0,0,1675,1674,1,0,0,
  	0,1676,287,1,0,0,0,209,293,297,306,311,314,321,330,340,351,353,374,382,
  	389,393,408,412,416,422,429,439,441,457,461,465,473,477,492,496,499,503,
  	506,510,516,520,524,532,537,539,546,551,554,557,562,565,568,573,576,579,
  	583,589,593,597,601,612,619,626,631,639,642,645,650,653,657,667,671,677,
  	683,690,696,702,710,715,726,731,739,746,753,758,792,796,803,809,816,820,
  	824,833,841,848,852,856,860,863,866,869,873,877,881,883,890,896,899,902,
  	906,909,916,925,944,948,952,962,966,977,990,996,1003,1010,1017,1024,1042,
  	1046,1048,1055,1061,1066,1081,1084,1106,1109,1114,1120,1123,1129,1142,
  	1147,1152,1155,1158,1170,1175,1178,1181,1184,1187,1190,1196,1201,1211,
  	1215,1228,1232,1245,1249,1258,1270,1275,1282,1284,1287,1290,1294,1297,
  	1301,1307,1312,1316,1324,1329,1333,1337,1340,1348,1352,1354,1373,1379,
  	1389,1392,1402,1407,1409,1418,1422,1426,1433,1438,1442,1446,1457,1463,
  	1470,1497,1509,1511,1571,1586,1588,1594,1597,1600,1604,1612,1615,1622,
  	1632,1638,1648,1654,1661,1675
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  myparserParserStaticData = staticData.release();
}

}

myParser::myParser(TokenStream *input) : myParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

myParser::myParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : myParserBase(input) {
  myParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *myparserParserStaticData->atn, myparserParserStaticData->decisionToDFA, myparserParserStaticData->sharedContextCache, options);
}

myParser::~myParser() {
  delete _interpreter;
}

const atn::ATN& myParser::getATN() const {
  return *myparserParserStaticData->atn;
}

std::string myParser::getGrammarFileName() const {
  return "myParser.g4";
}

const std::vector<std::string>& myParser::getRuleNames() const {
  return myparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& myParser::getVocabulary() const {
  return myparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView myParser::getSerializedATN() const {
  return myparserParserStaticData->serializedATN;
}


//----------------- InitializerContext ------------------------------------------------------------------

myParser::InitializerContext::InitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::InitializerContext::Assign() {
  return getToken(myParser::Assign, 0);
}

myParser::SingleExpressionContext* myParser::InitializerContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}


size_t myParser::InitializerContext::getRuleIndex() const {
  return myParser::RuleInitializer;
}

void myParser::InitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitializer(this);
}

void myParser::InitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitializer(this);
}

myParser::InitializerContext* myParser::initializer() {
  InitializerContext *_localctx = _tracker.createInstance<InitializerContext>(_ctx, getState());
  enterRule(_localctx, 0, myParser::RuleInitializer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(288);
    match(myParser::Assign);
    setState(289);
    singleExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BindingPatternContext ------------------------------------------------------------------

myParser::BindingPatternContext::BindingPatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ArrayLiteralContext* myParser::BindingPatternContext::arrayLiteral() {
  return getRuleContext<myParser::ArrayLiteralContext>(0);
}

myParser::ObjectLiteralContext* myParser::BindingPatternContext::objectLiteral() {
  return getRuleContext<myParser::ObjectLiteralContext>(0);
}


size_t myParser::BindingPatternContext::getRuleIndex() const {
  return myParser::RuleBindingPattern;
}

void myParser::BindingPatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBindingPattern(this);
}

void myParser::BindingPatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBindingPattern(this);
}

myParser::BindingPatternContext* myParser::bindingPattern() {
  BindingPatternContext *_localctx = _tracker.createInstance<BindingPatternContext>(_ctx, getState());
  enterRule(_localctx, 2, myParser::RuleBindingPattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(293);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::OpenBracket: {
        setState(291);
        arrayLiteral();
        break;
      }

      case myParser::OpenBrace: {
        setState(292);
        objectLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeParametersContext ------------------------------------------------------------------

myParser::TypeParametersContext::TypeParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TypeParametersContext::LessThan() {
  return getToken(myParser::LessThan, 0);
}

tree::TerminalNode* myParser::TypeParametersContext::MoreThan() {
  return getToken(myParser::MoreThan, 0);
}

myParser::TypeParameterListContext* myParser::TypeParametersContext::typeParameterList() {
  return getRuleContext<myParser::TypeParameterListContext>(0);
}


size_t myParser::TypeParametersContext::getRuleIndex() const {
  return myParser::RuleTypeParameters;
}

void myParser::TypeParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeParameters(this);
}

void myParser::TypeParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeParameters(this);
}

myParser::TypeParametersContext* myParser::typeParameters() {
  TypeParametersContext *_localctx = _tracker.createInstance<TypeParametersContext>(_ctx, getState());
  enterRule(_localctx, 4, myParser::RuleTypeParameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(295);
    match(myParser::LessThan);
    setState(297);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LessThan || _la == myParser::Identifier) {
      setState(296);
      typeParameterList();
    }
    setState(299);
    match(myParser::MoreThan);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeParameterListContext ------------------------------------------------------------------

myParser::TypeParameterListContext::TypeParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::TypeParameterContext *> myParser::TypeParameterListContext::typeParameter() {
  return getRuleContexts<myParser::TypeParameterContext>();
}

myParser::TypeParameterContext* myParser::TypeParameterListContext::typeParameter(size_t i) {
  return getRuleContext<myParser::TypeParameterContext>(i);
}

std::vector<tree::TerminalNode *> myParser::TypeParameterListContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::TypeParameterListContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::TypeParameterListContext::getRuleIndex() const {
  return myParser::RuleTypeParameterList;
}

void myParser::TypeParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeParameterList(this);
}

void myParser::TypeParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeParameterList(this);
}

myParser::TypeParameterListContext* myParser::typeParameterList() {
  TypeParameterListContext *_localctx = _tracker.createInstance<TypeParameterListContext>(_ctx, getState());
  enterRule(_localctx, 6, myParser::RuleTypeParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(301);
    typeParameter();
    setState(306);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::Comma) {
      setState(302);
      match(myParser::Comma);
      setState(303);
      typeParameter();
      setState(308);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeParameterContext ------------------------------------------------------------------

myParser::TypeParameterContext::TypeParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TypeParameterContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

myParser::ConstraintContext* myParser::TypeParameterContext::constraint() {
  return getRuleContext<myParser::ConstraintContext>(0);
}

myParser::TypeParametersContext* myParser::TypeParameterContext::typeParameters() {
  return getRuleContext<myParser::TypeParametersContext>(0);
}


size_t myParser::TypeParameterContext::getRuleIndex() const {
  return myParser::RuleTypeParameter;
}

void myParser::TypeParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeParameter(this);
}

void myParser::TypeParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeParameter(this);
}

myParser::TypeParameterContext* myParser::typeParameter() {
  TypeParameterContext *_localctx = _tracker.createInstance<TypeParameterContext>(_ctx, getState());
  enterRule(_localctx, 8, myParser::RuleTypeParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(314);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(309);
        match(myParser::Identifier);
        setState(311);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::Extends) {
          setState(310);
          constraint();
        }
        break;
      }

      case myParser::LessThan: {
        enterOuterAlt(_localctx, 2);
        setState(313);
        typeParameters();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintContext ------------------------------------------------------------------

myParser::ConstraintContext::ConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ConstraintContext::Extends() {
  return getToken(myParser::Extends, 0);
}

myParser::Type_Context* myParser::ConstraintContext::type_() {
  return getRuleContext<myParser::Type_Context>(0);
}


size_t myParser::ConstraintContext::getRuleIndex() const {
  return myParser::RuleConstraint;
}

void myParser::ConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraint(this);
}

void myParser::ConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraint(this);
}

myParser::ConstraintContext* myParser::constraint() {
  ConstraintContext *_localctx = _tracker.createInstance<ConstraintContext>(_ctx, getState());
  enterRule(_localctx, 10, myParser::RuleConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(316);
    match(myParser::Extends);
    setState(317);
    type_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeArgumentsContext ------------------------------------------------------------------

myParser::TypeArgumentsContext::TypeArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TypeArgumentsContext::LessThan() {
  return getToken(myParser::LessThan, 0);
}

tree::TerminalNode* myParser::TypeArgumentsContext::MoreThan() {
  return getToken(myParser::MoreThan, 0);
}

myParser::TypeArgumentListContext* myParser::TypeArgumentsContext::typeArgumentList() {
  return getRuleContext<myParser::TypeArgumentListContext>(0);
}


size_t myParser::TypeArgumentsContext::getRuleIndex() const {
  return myParser::RuleTypeArguments;
}

void myParser::TypeArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeArguments(this);
}

void myParser::TypeArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeArguments(this);
}

myParser::TypeArgumentsContext* myParser::typeArguments() {
  TypeArgumentsContext *_localctx = _tracker.createInstance<TypeArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 12, myParser::RuleTypeArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(319);
    match(myParser::LessThan);
    setState(321);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1073742160) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & 1729654935793991945) != 0)) {
      setState(320);
      typeArgumentList();
    }
    setState(323);
    match(myParser::MoreThan);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeArgumentListContext ------------------------------------------------------------------

myParser::TypeArgumentListContext::TypeArgumentListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::TypeArgumentContext *> myParser::TypeArgumentListContext::typeArgument() {
  return getRuleContexts<myParser::TypeArgumentContext>();
}

myParser::TypeArgumentContext* myParser::TypeArgumentListContext::typeArgument(size_t i) {
  return getRuleContext<myParser::TypeArgumentContext>(i);
}

std::vector<tree::TerminalNode *> myParser::TypeArgumentListContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::TypeArgumentListContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::TypeArgumentListContext::getRuleIndex() const {
  return myParser::RuleTypeArgumentList;
}

void myParser::TypeArgumentListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeArgumentList(this);
}

void myParser::TypeArgumentListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeArgumentList(this);
}

myParser::TypeArgumentListContext* myParser::typeArgumentList() {
  TypeArgumentListContext *_localctx = _tracker.createInstance<TypeArgumentListContext>(_ctx, getState());
  enterRule(_localctx, 14, myParser::RuleTypeArgumentList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(325);
    typeArgument();
    setState(330);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::Comma) {
      setState(326);
      match(myParser::Comma);
      setState(327);
      typeArgument();
      setState(332);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeArgumentContext ------------------------------------------------------------------

myParser::TypeArgumentContext::TypeArgumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::Type_Context* myParser::TypeArgumentContext::type_() {
  return getRuleContext<myParser::Type_Context>(0);
}


size_t myParser::TypeArgumentContext::getRuleIndex() const {
  return myParser::RuleTypeArgument;
}

void myParser::TypeArgumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeArgument(this);
}

void myParser::TypeArgumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeArgument(this);
}

myParser::TypeArgumentContext* myParser::typeArgument() {
  TypeArgumentContext *_localctx = _tracker.createInstance<TypeArgumentContext>(_ctx, getState());
  enterRule(_localctx, 16, myParser::RuleTypeArgument);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(333);
    type_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_Context ------------------------------------------------------------------

myParser::Type_Context::Type_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::UnionOrIntersectionOrPrimaryTypeContext* myParser::Type_Context::unionOrIntersectionOrPrimaryType() {
  return getRuleContext<myParser::UnionOrIntersectionOrPrimaryTypeContext>(0);
}

myParser::FunctionTypeContext* myParser::Type_Context::functionType() {
  return getRuleContext<myParser::FunctionTypeContext>(0);
}

myParser::ConstructorTypeContext* myParser::Type_Context::constructorType() {
  return getRuleContext<myParser::ConstructorTypeContext>(0);
}

myParser::TypeGenericContext* myParser::Type_Context::typeGeneric() {
  return getRuleContext<myParser::TypeGenericContext>(0);
}

tree::TerminalNode* myParser::Type_Context::StringLiteral() {
  return getToken(myParser::StringLiteral, 0);
}


size_t myParser::Type_Context::getRuleIndex() const {
  return myParser::RuleType_;
}

void myParser::Type_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_(this);
}

void myParser::Type_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_(this);
}

myParser::Type_Context* myParser::type_() {
  Type_Context *_localctx = _tracker.createInstance<Type_Context>(_ctx, getState());
  enterRule(_localctx, 18, myParser::RuleType_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(340);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(335);
      unionOrIntersectionOrPrimaryType(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(336);
      functionType();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(337);
      constructorType();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(338);
      typeGeneric();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(339);
      match(myParser::StringLiteral);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnionOrIntersectionOrPrimaryTypeContext ------------------------------------------------------------------

myParser::UnionOrIntersectionOrPrimaryTypeContext::UnionOrIntersectionOrPrimaryTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t myParser::UnionOrIntersectionOrPrimaryTypeContext::getRuleIndex() const {
  return myParser::RuleUnionOrIntersectionOrPrimaryType;
}

void myParser::UnionOrIntersectionOrPrimaryTypeContext::copyFrom(UnionOrIntersectionOrPrimaryTypeContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- IntersectionContext ------------------------------------------------------------------

std::vector<myParser::UnionOrIntersectionOrPrimaryTypeContext *> myParser::IntersectionContext::unionOrIntersectionOrPrimaryType() {
  return getRuleContexts<myParser::UnionOrIntersectionOrPrimaryTypeContext>();
}

myParser::UnionOrIntersectionOrPrimaryTypeContext* myParser::IntersectionContext::unionOrIntersectionOrPrimaryType(size_t i) {
  return getRuleContext<myParser::UnionOrIntersectionOrPrimaryTypeContext>(i);
}

tree::TerminalNode* myParser::IntersectionContext::BitAnd() {
  return getToken(myParser::BitAnd, 0);
}

myParser::IntersectionContext::IntersectionContext(UnionOrIntersectionOrPrimaryTypeContext *ctx) { copyFrom(ctx); }

void myParser::IntersectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntersection(this);
}
void myParser::IntersectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntersection(this);
}
//----------------- PrimaryContext ------------------------------------------------------------------

myParser::PrimaryTypeContext* myParser::PrimaryContext::primaryType() {
  return getRuleContext<myParser::PrimaryTypeContext>(0);
}

myParser::PrimaryContext::PrimaryContext(UnionOrIntersectionOrPrimaryTypeContext *ctx) { copyFrom(ctx); }

void myParser::PrimaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimary(this);
}
void myParser::PrimaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimary(this);
}
//----------------- UnionContext ------------------------------------------------------------------

std::vector<myParser::UnionOrIntersectionOrPrimaryTypeContext *> myParser::UnionContext::unionOrIntersectionOrPrimaryType() {
  return getRuleContexts<myParser::UnionOrIntersectionOrPrimaryTypeContext>();
}

myParser::UnionOrIntersectionOrPrimaryTypeContext* myParser::UnionContext::unionOrIntersectionOrPrimaryType(size_t i) {
  return getRuleContext<myParser::UnionOrIntersectionOrPrimaryTypeContext>(i);
}

tree::TerminalNode* myParser::UnionContext::BitOr() {
  return getToken(myParser::BitOr, 0);
}

myParser::UnionContext::UnionContext(UnionOrIntersectionOrPrimaryTypeContext *ctx) { copyFrom(ctx); }

void myParser::UnionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnion(this);
}
void myParser::UnionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnion(this);
}

myParser::UnionOrIntersectionOrPrimaryTypeContext* myParser::unionOrIntersectionOrPrimaryType() {
   return unionOrIntersectionOrPrimaryType(0);
}

myParser::UnionOrIntersectionOrPrimaryTypeContext* myParser::unionOrIntersectionOrPrimaryType(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  myParser::UnionOrIntersectionOrPrimaryTypeContext *_localctx = _tracker.createInstance<UnionOrIntersectionOrPrimaryTypeContext>(_ctx, parentState);
  myParser::UnionOrIntersectionOrPrimaryTypeContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 20;
  enterRecursionRule(_localctx, 20, myParser::RuleUnionOrIntersectionOrPrimaryType, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    _localctx = _tracker.createInstance<PrimaryContext>(_localctx);
    _ctx = _localctx;
    previousContext = _localctx;

    setState(343);
    primaryType(0);
    _ctx->stop = _input->LT(-1);
    setState(353);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(351);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<UnionContext>(_tracker.createInstance<UnionOrIntersectionOrPrimaryTypeContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleUnionOrIntersectionOrPrimaryType);
          setState(345);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(346);
          match(myParser::BitOr);
          setState(347);
          unionOrIntersectionOrPrimaryType(4);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<IntersectionContext>(_tracker.createInstance<UnionOrIntersectionOrPrimaryTypeContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleUnionOrIntersectionOrPrimaryType);
          setState(348);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(349);
          match(myParser::BitAnd);
          setState(350);
          unionOrIntersectionOrPrimaryType(3);
          break;
        }

        default:
          break;
        } 
      }
      setState(355);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- PrimaryTypeContext ------------------------------------------------------------------

myParser::PrimaryTypeContext::PrimaryTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t myParser::PrimaryTypeContext::getRuleIndex() const {
  return myParser::RulePrimaryType;
}

void myParser::PrimaryTypeContext::copyFrom(PrimaryTypeContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- RedefinitionOfTypeContext ------------------------------------------------------------------

myParser::TypeReferenceContext* myParser::RedefinitionOfTypeContext::typeReference() {
  return getRuleContext<myParser::TypeReferenceContext>(0);
}

tree::TerminalNode* myParser::RedefinitionOfTypeContext::Is() {
  return getToken(myParser::Is, 0);
}

myParser::PrimaryTypeContext* myParser::RedefinitionOfTypeContext::primaryType() {
  return getRuleContext<myParser::PrimaryTypeContext>(0);
}

myParser::RedefinitionOfTypeContext::RedefinitionOfTypeContext(PrimaryTypeContext *ctx) { copyFrom(ctx); }

void myParser::RedefinitionOfTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRedefinitionOfType(this);
}
void myParser::RedefinitionOfTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRedefinitionOfType(this);
}
//----------------- PredefinedPrimTypeContext ------------------------------------------------------------------

myParser::PredefinedTypeContext* myParser::PredefinedPrimTypeContext::predefinedType() {
  return getRuleContext<myParser::PredefinedTypeContext>(0);
}

myParser::PredefinedPrimTypeContext::PredefinedPrimTypeContext(PrimaryTypeContext *ctx) { copyFrom(ctx); }

void myParser::PredefinedPrimTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredefinedPrimType(this);
}
void myParser::PredefinedPrimTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredefinedPrimType(this);
}
//----------------- ArrayPrimTypeContext ------------------------------------------------------------------

myParser::PrimaryTypeContext* myParser::ArrayPrimTypeContext::primaryType() {
  return getRuleContext<myParser::PrimaryTypeContext>(0);
}

tree::TerminalNode* myParser::ArrayPrimTypeContext::OpenBracket() {
  return getToken(myParser::OpenBracket, 0);
}

tree::TerminalNode* myParser::ArrayPrimTypeContext::CloseBracket() {
  return getToken(myParser::CloseBracket, 0);
}

myParser::ArrayPrimTypeContext::ArrayPrimTypeContext(PrimaryTypeContext *ctx) { copyFrom(ctx); }

void myParser::ArrayPrimTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayPrimType(this);
}
void myParser::ArrayPrimTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayPrimType(this);
}
//----------------- ParenthesizedPrimTypeContext ------------------------------------------------------------------

tree::TerminalNode* myParser::ParenthesizedPrimTypeContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

myParser::Type_Context* myParser::ParenthesizedPrimTypeContext::type_() {
  return getRuleContext<myParser::Type_Context>(0);
}

tree::TerminalNode* myParser::ParenthesizedPrimTypeContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::ParenthesizedPrimTypeContext::ParenthesizedPrimTypeContext(PrimaryTypeContext *ctx) { copyFrom(ctx); }

void myParser::ParenthesizedPrimTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParenthesizedPrimType(this);
}
void myParser::ParenthesizedPrimTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParenthesizedPrimType(this);
}
//----------------- ThisPrimTypeContext ------------------------------------------------------------------

tree::TerminalNode* myParser::ThisPrimTypeContext::This() {
  return getToken(myParser::This, 0);
}

myParser::ThisPrimTypeContext::ThisPrimTypeContext(PrimaryTypeContext *ctx) { copyFrom(ctx); }

void myParser::ThisPrimTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThisPrimType(this);
}
void myParser::ThisPrimTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThisPrimType(this);
}
//----------------- TuplePrimTypeContext ------------------------------------------------------------------

tree::TerminalNode* myParser::TuplePrimTypeContext::OpenBracket() {
  return getToken(myParser::OpenBracket, 0);
}

myParser::TupleElementTypesContext* myParser::TuplePrimTypeContext::tupleElementTypes() {
  return getRuleContext<myParser::TupleElementTypesContext>(0);
}

tree::TerminalNode* myParser::TuplePrimTypeContext::CloseBracket() {
  return getToken(myParser::CloseBracket, 0);
}

myParser::TuplePrimTypeContext::TuplePrimTypeContext(PrimaryTypeContext *ctx) { copyFrom(ctx); }

void myParser::TuplePrimTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTuplePrimType(this);
}
void myParser::TuplePrimTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTuplePrimType(this);
}
//----------------- ObjectPrimTypeContext ------------------------------------------------------------------

myParser::ObjectTypeContext* myParser::ObjectPrimTypeContext::objectType() {
  return getRuleContext<myParser::ObjectTypeContext>(0);
}

myParser::ObjectPrimTypeContext::ObjectPrimTypeContext(PrimaryTypeContext *ctx) { copyFrom(ctx); }

void myParser::ObjectPrimTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectPrimType(this);
}
void myParser::ObjectPrimTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectPrimType(this);
}
//----------------- ReferencePrimTypeContext ------------------------------------------------------------------

myParser::TypeReferenceContext* myParser::ReferencePrimTypeContext::typeReference() {
  return getRuleContext<myParser::TypeReferenceContext>(0);
}

myParser::ReferencePrimTypeContext::ReferencePrimTypeContext(PrimaryTypeContext *ctx) { copyFrom(ctx); }

void myParser::ReferencePrimTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReferencePrimType(this);
}
void myParser::ReferencePrimTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReferencePrimType(this);
}
//----------------- QueryPrimTypeContext ------------------------------------------------------------------

myParser::TypeQueryContext* myParser::QueryPrimTypeContext::typeQuery() {
  return getRuleContext<myParser::TypeQueryContext>(0);
}

myParser::QueryPrimTypeContext::QueryPrimTypeContext(PrimaryTypeContext *ctx) { copyFrom(ctx); }

void myParser::QueryPrimTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryPrimType(this);
}
void myParser::QueryPrimTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryPrimType(this);
}

myParser::PrimaryTypeContext* myParser::primaryType() {
   return primaryType(0);
}

myParser::PrimaryTypeContext* myParser::primaryType(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  myParser::PrimaryTypeContext *_localctx = _tracker.createInstance<PrimaryTypeContext>(_ctx, parentState);
  myParser::PrimaryTypeContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 22;
  enterRecursionRule(_localctx, 22, myParser::RulePrimaryType, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(374);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<ParenthesizedPrimTypeContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(357);
      match(myParser::OpenParen);
      setState(358);
      type_();
      setState(359);
      match(myParser::CloseParen);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<PredefinedPrimTypeContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(361);
      predefinedType();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<ReferencePrimTypeContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(362);
      typeReference();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<ObjectPrimTypeContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(363);
      objectType();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<TuplePrimTypeContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(364);
      match(myParser::OpenBracket);
      setState(365);
      tupleElementTypes();
      setState(366);
      match(myParser::CloseBracket);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<QueryPrimTypeContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(368);
      typeQuery();
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<ThisPrimTypeContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(369);
      match(myParser::This);
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<RedefinitionOfTypeContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(370);
      typeReference();
      setState(371);
      match(myParser::Is);
      setState(372);
      primaryType(1);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(382);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        auto newContext = _tracker.createInstance<ArrayPrimTypeContext>(_tracker.createInstance<PrimaryTypeContext>(parentContext, parentState));
        _localctx = newContext;
        pushNewRecursionContext(newContext, startState, RulePrimaryType);
        setState(376);

        if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
        setState(377);

        if (!(notLineTerminator())) throw FailedPredicateException(this, "notLineTerminator()");
        setState(378);
        match(myParser::OpenBracket);
        setState(379);
        match(myParser::CloseBracket); 
      }
      setState(384);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- PredefinedTypeContext ------------------------------------------------------------------

myParser::PredefinedTypeContext::PredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::PredefinedTypeContext::Any() {
  return getToken(myParser::Any, 0);
}

tree::TerminalNode* myParser::PredefinedTypeContext::Number() {
  return getToken(myParser::Number, 0);
}

tree::TerminalNode* myParser::PredefinedTypeContext::Boolean() {
  return getToken(myParser::Boolean, 0);
}

tree::TerminalNode* myParser::PredefinedTypeContext::String() {
  return getToken(myParser::String, 0);
}

tree::TerminalNode* myParser::PredefinedTypeContext::Symbol() {
  return getToken(myParser::Symbol, 0);
}

tree::TerminalNode* myParser::PredefinedTypeContext::Void() {
  return getToken(myParser::Void, 0);
}


size_t myParser::PredefinedTypeContext::getRuleIndex() const {
  return myParser::RulePredefinedType;
}

void myParser::PredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredefinedType(this);
}

void myParser::PredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredefinedType(this);
}

myParser::PredefinedTypeContext* myParser::predefinedType() {
  PredefinedTypeContext *_localctx = _tracker.createInstance<PredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 24, myParser::RulePredefinedType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(385);
    _la = _input->LA(1);
    if (!(((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & 1065151889409) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeReferenceContext ------------------------------------------------------------------

myParser::TypeReferenceContext::TypeReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::TypeNameContext* myParser::TypeReferenceContext::typeName() {
  return getRuleContext<myParser::TypeNameContext>(0);
}

myParser::NestedTypeGenericContext* myParser::TypeReferenceContext::nestedTypeGeneric() {
  return getRuleContext<myParser::NestedTypeGenericContext>(0);
}


size_t myParser::TypeReferenceContext::getRuleIndex() const {
  return myParser::RuleTypeReference;
}

void myParser::TypeReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeReference(this);
}

void myParser::TypeReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeReference(this);
}

myParser::TypeReferenceContext* myParser::typeReference() {
  TypeReferenceContext *_localctx = _tracker.createInstance<TypeReferenceContext>(_ctx, getState());
  enterRule(_localctx, 26, myParser::RuleTypeReference);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(387);
    typeName();
    setState(389);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
    case 1: {
      setState(388);
      nestedTypeGeneric();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NestedTypeGenericContext ------------------------------------------------------------------

myParser::NestedTypeGenericContext::NestedTypeGenericContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::TypeIncludeGenericContext* myParser::NestedTypeGenericContext::typeIncludeGeneric() {
  return getRuleContext<myParser::TypeIncludeGenericContext>(0);
}

myParser::TypeGenericContext* myParser::NestedTypeGenericContext::typeGeneric() {
  return getRuleContext<myParser::TypeGenericContext>(0);
}


size_t myParser::NestedTypeGenericContext::getRuleIndex() const {
  return myParser::RuleNestedTypeGeneric;
}

void myParser::NestedTypeGenericContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNestedTypeGeneric(this);
}

void myParser::NestedTypeGenericContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNestedTypeGeneric(this);
}

myParser::NestedTypeGenericContext* myParser::nestedTypeGeneric() {
  NestedTypeGenericContext *_localctx = _tracker.createInstance<NestedTypeGenericContext>(_ctx, getState());
  enterRule(_localctx, 28, myParser::RuleNestedTypeGeneric);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(393);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(391);
      typeIncludeGeneric();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(392);
      typeGeneric();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeGenericContext ------------------------------------------------------------------

myParser::TypeGenericContext::TypeGenericContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TypeGenericContext::LessThan() {
  return getToken(myParser::LessThan, 0);
}

myParser::TypeArgumentListContext* myParser::TypeGenericContext::typeArgumentList() {
  return getRuleContext<myParser::TypeArgumentListContext>(0);
}

tree::TerminalNode* myParser::TypeGenericContext::MoreThan() {
  return getToken(myParser::MoreThan, 0);
}


size_t myParser::TypeGenericContext::getRuleIndex() const {
  return myParser::RuleTypeGeneric;
}

void myParser::TypeGenericContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeGeneric(this);
}

void myParser::TypeGenericContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeGeneric(this);
}

myParser::TypeGenericContext* myParser::typeGeneric() {
  TypeGenericContext *_localctx = _tracker.createInstance<TypeGenericContext>(_ctx, getState());
  enterRule(_localctx, 30, myParser::RuleTypeGeneric);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(395);
    match(myParser::LessThan);
    setState(396);
    typeArgumentList();
    setState(397);
    match(myParser::MoreThan);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeIncludeGenericContext ------------------------------------------------------------------

myParser::TypeIncludeGenericContext::TypeIncludeGenericContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> myParser::TypeIncludeGenericContext::LessThan() {
  return getTokens(myParser::LessThan);
}

tree::TerminalNode* myParser::TypeIncludeGenericContext::LessThan(size_t i) {
  return getToken(myParser::LessThan, i);
}

std::vector<myParser::TypeArgumentListContext *> myParser::TypeIncludeGenericContext::typeArgumentList() {
  return getRuleContexts<myParser::TypeArgumentListContext>();
}

myParser::TypeArgumentListContext* myParser::TypeIncludeGenericContext::typeArgumentList(size_t i) {
  return getRuleContext<myParser::TypeArgumentListContext>(i);
}

std::vector<tree::TerminalNode *> myParser::TypeIncludeGenericContext::MoreThan() {
  return getTokens(myParser::MoreThan);
}

tree::TerminalNode* myParser::TypeIncludeGenericContext::MoreThan(size_t i) {
  return getToken(myParser::MoreThan, i);
}

myParser::BindingPatternContext* myParser::TypeIncludeGenericContext::bindingPattern() {
  return getRuleContext<myParser::BindingPatternContext>(0);
}

tree::TerminalNode* myParser::TypeIncludeGenericContext::RightShiftArithmetic() {
  return getToken(myParser::RightShiftArithmetic, 0);
}


size_t myParser::TypeIncludeGenericContext::getRuleIndex() const {
  return myParser::RuleTypeIncludeGeneric;
}

void myParser::TypeIncludeGenericContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeIncludeGeneric(this);
}

void myParser::TypeIncludeGenericContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeIncludeGeneric(this);
}

myParser::TypeIncludeGenericContext* myParser::typeIncludeGeneric() {
  TypeIncludeGenericContext *_localctx = _tracker.createInstance<TypeIncludeGenericContext>(_ctx, getState());
  enterRule(_localctx, 32, myParser::RuleTypeIncludeGeneric);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(399);
    match(myParser::LessThan);
    setState(400);
    typeArgumentList();
    setState(401);
    match(myParser::LessThan);
    setState(402);
    typeArgumentList();
    setState(408);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::MoreThan: {
        setState(403);
        match(myParser::MoreThan);
        setState(404);
        bindingPattern();
        setState(405);
        match(myParser::MoreThan);
        break;
      }

      case myParser::RightShiftArithmetic: {
        setState(407);
        match(myParser::RightShiftArithmetic);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeNameContext ------------------------------------------------------------------

myParser::TypeNameContext::TypeNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TypeNameContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

myParser::NamespaceNameContext* myParser::TypeNameContext::namespaceName() {
  return getRuleContext<myParser::NamespaceNameContext>(0);
}


size_t myParser::TypeNameContext::getRuleIndex() const {
  return myParser::RuleTypeName;
}

void myParser::TypeNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeName(this);
}

void myParser::TypeNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeName(this);
}

myParser::TypeNameContext* myParser::typeName() {
  TypeNameContext *_localctx = _tracker.createInstance<TypeNameContext>(_ctx, getState());
  enterRule(_localctx, 34, myParser::RuleTypeName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(412);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(410);
      match(myParser::Identifier);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(411);
      namespaceName();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectTypeContext ------------------------------------------------------------------

myParser::ObjectTypeContext::ObjectTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ObjectTypeContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

tree::TerminalNode* myParser::ObjectTypeContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

myParser::TypeBodyContext* myParser::ObjectTypeContext::typeBody() {
  return getRuleContext<myParser::TypeBodyContext>(0);
}


size_t myParser::ObjectTypeContext::getRuleIndex() const {
  return myParser::RuleObjectType;
}

void myParser::ObjectTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectType(this);
}

void myParser::ObjectTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectType(this);
}

myParser::ObjectTypeContext* myParser::objectType() {
  ObjectTypeContext *_localctx = _tracker.createInstance<ObjectTypeContext>(_ctx, getState());
  enterRule(_localctx, 36, myParser::RuleObjectType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(414);
    match(myParser::OpenBrace);
    setState(416);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -36028795945222064) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3480877891661594623) != 0)) {
      setState(415);
      typeBody();
    }
    setState(418);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeBodyContext ------------------------------------------------------------------

myParser::TypeBodyContext::TypeBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::TypeMemberListContext* myParser::TypeBodyContext::typeMemberList() {
  return getRuleContext<myParser::TypeMemberListContext>(0);
}

tree::TerminalNode* myParser::TypeBodyContext::SemiColon() {
  return getToken(myParser::SemiColon, 0);
}

tree::TerminalNode* myParser::TypeBodyContext::Comma() {
  return getToken(myParser::Comma, 0);
}


size_t myParser::TypeBodyContext::getRuleIndex() const {
  return myParser::RuleTypeBody;
}

void myParser::TypeBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeBody(this);
}

void myParser::TypeBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeBody(this);
}

myParser::TypeBodyContext* myParser::typeBody() {
  TypeBodyContext *_localctx = _tracker.createInstance<TypeBodyContext>(_ctx, getState());
  enterRule(_localctx, 38, myParser::RuleTypeBody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(420);
    typeMemberList();
    setState(422);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::SemiColon

    || _la == myParser::Comma) {
      setState(421);
      _la = _input->LA(1);
      if (!(_la == myParser::SemiColon

      || _la == myParser::Comma)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeMemberListContext ------------------------------------------------------------------

myParser::TypeMemberListContext::TypeMemberListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::TypeMemberContext *> myParser::TypeMemberListContext::typeMember() {
  return getRuleContexts<myParser::TypeMemberContext>();
}

myParser::TypeMemberContext* myParser::TypeMemberListContext::typeMember(size_t i) {
  return getRuleContext<myParser::TypeMemberContext>(i);
}

std::vector<tree::TerminalNode *> myParser::TypeMemberListContext::SemiColon() {
  return getTokens(myParser::SemiColon);
}

tree::TerminalNode* myParser::TypeMemberListContext::SemiColon(size_t i) {
  return getToken(myParser::SemiColon, i);
}

std::vector<tree::TerminalNode *> myParser::TypeMemberListContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::TypeMemberListContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::TypeMemberListContext::getRuleIndex() const {
  return myParser::RuleTypeMemberList;
}

void myParser::TypeMemberListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeMemberList(this);
}

void myParser::TypeMemberListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeMemberList(this);
}

myParser::TypeMemberListContext* myParser::typeMemberList() {
  TypeMemberListContext *_localctx = _tracker.createInstance<TypeMemberListContext>(_ctx, getState());
  enterRule(_localctx, 40, myParser::RuleTypeMemberList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(424);
    typeMember();
    setState(429);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(425);
        _la = _input->LA(1);
        if (!(_la == myParser::SemiColon

        || _la == myParser::Comma)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(426);
        typeMember(); 
      }
      setState(431);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeMemberContext ------------------------------------------------------------------

myParser::TypeMemberContext::TypeMemberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::PropertySignaturContext* myParser::TypeMemberContext::propertySignatur() {
  return getRuleContext<myParser::PropertySignaturContext>(0);
}

myParser::CallSignatureContext* myParser::TypeMemberContext::callSignature() {
  return getRuleContext<myParser::CallSignatureContext>(0);
}

myParser::ConstructSignatureContext* myParser::TypeMemberContext::constructSignature() {
  return getRuleContext<myParser::ConstructSignatureContext>(0);
}

myParser::IndexSignatureContext* myParser::TypeMemberContext::indexSignature() {
  return getRuleContext<myParser::IndexSignatureContext>(0);
}

myParser::MethodSignatureContext* myParser::TypeMemberContext::methodSignature() {
  return getRuleContext<myParser::MethodSignatureContext>(0);
}

tree::TerminalNode* myParser::TypeMemberContext::ARROW() {
  return getToken(myParser::ARROW, 0);
}

myParser::Type_Context* myParser::TypeMemberContext::type_() {
  return getRuleContext<myParser::Type_Context>(0);
}


size_t myParser::TypeMemberContext::getRuleIndex() const {
  return myParser::RuleTypeMember;
}

void myParser::TypeMemberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeMember(this);
}

void myParser::TypeMemberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeMember(this);
}

myParser::TypeMemberContext* myParser::typeMember() {
  TypeMemberContext *_localctx = _tracker.createInstance<TypeMemberContext>(_ctx, getState());
  enterRule(_localctx, 42, myParser::RuleTypeMember);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(441);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(432);
      propertySignatur();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(433);
      callSignature();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(434);
      constructSignature();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(435);
      indexSignature();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(436);
      methodSignature();
      setState(439);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::ARROW) {
        setState(437);
        match(myParser::ARROW);
        setState(438);
        type_();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayTypeContext ------------------------------------------------------------------

myParser::ArrayTypeContext::ArrayTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::PrimaryTypeContext* myParser::ArrayTypeContext::primaryType() {
  return getRuleContext<myParser::PrimaryTypeContext>(0);
}

tree::TerminalNode* myParser::ArrayTypeContext::OpenBracket() {
  return getToken(myParser::OpenBracket, 0);
}

tree::TerminalNode* myParser::ArrayTypeContext::CloseBracket() {
  return getToken(myParser::CloseBracket, 0);
}


size_t myParser::ArrayTypeContext::getRuleIndex() const {
  return myParser::RuleArrayType;
}

void myParser::ArrayTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayType(this);
}

void myParser::ArrayTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayType(this);
}

myParser::ArrayTypeContext* myParser::arrayType() {
  ArrayTypeContext *_localctx = _tracker.createInstance<ArrayTypeContext>(_ctx, getState());
  enterRule(_localctx, 44, myParser::RuleArrayType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(443);
    primaryType(0);
    setState(444);

    if (!(notLineTerminator())) throw FailedPredicateException(this, "notLineTerminator()");
    setState(445);
    match(myParser::OpenBracket);
    setState(446);
    match(myParser::CloseBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TupleTypeContext ------------------------------------------------------------------

myParser::TupleTypeContext::TupleTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TupleTypeContext::OpenBracket() {
  return getToken(myParser::OpenBracket, 0);
}

myParser::TupleElementTypesContext* myParser::TupleTypeContext::tupleElementTypes() {
  return getRuleContext<myParser::TupleElementTypesContext>(0);
}

tree::TerminalNode* myParser::TupleTypeContext::CloseBracket() {
  return getToken(myParser::CloseBracket, 0);
}


size_t myParser::TupleTypeContext::getRuleIndex() const {
  return myParser::RuleTupleType;
}

void myParser::TupleTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTupleType(this);
}

void myParser::TupleTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTupleType(this);
}

myParser::TupleTypeContext* myParser::tupleType() {
  TupleTypeContext *_localctx = _tracker.createInstance<TupleTypeContext>(_ctx, getState());
  enterRule(_localctx, 46, myParser::RuleTupleType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(448);
    match(myParser::OpenBracket);
    setState(449);
    tupleElementTypes();
    setState(450);
    match(myParser::CloseBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TupleElementTypesContext ------------------------------------------------------------------

myParser::TupleElementTypesContext::TupleElementTypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::Type_Context *> myParser::TupleElementTypesContext::type_() {
  return getRuleContexts<myParser::Type_Context>();
}

myParser::Type_Context* myParser::TupleElementTypesContext::type_(size_t i) {
  return getRuleContext<myParser::Type_Context>(i);
}

std::vector<tree::TerminalNode *> myParser::TupleElementTypesContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::TupleElementTypesContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::TupleElementTypesContext::getRuleIndex() const {
  return myParser::RuleTupleElementTypes;
}

void myParser::TupleElementTypesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTupleElementTypes(this);
}

void myParser::TupleElementTypesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTupleElementTypes(this);
}

myParser::TupleElementTypesContext* myParser::tupleElementTypes() {
  TupleElementTypesContext *_localctx = _tracker.createInstance<TupleElementTypesContext>(_ctx, getState());
  enterRule(_localctx, 48, myParser::RuleTupleElementTypes);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(452);
    type_();
    setState(457);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::Comma) {
      setState(453);
      match(myParser::Comma);
      setState(454);
      type_();
      setState(459);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionTypeContext ------------------------------------------------------------------

myParser::FunctionTypeContext::FunctionTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::FunctionTypeContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::FunctionTypeContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

tree::TerminalNode* myParser::FunctionTypeContext::ARROW() {
  return getToken(myParser::ARROW, 0);
}

myParser::Type_Context* myParser::FunctionTypeContext::type_() {
  return getRuleContext<myParser::Type_Context>(0);
}

myParser::TypeParametersContext* myParser::FunctionTypeContext::typeParameters() {
  return getRuleContext<myParser::TypeParametersContext>(0);
}

myParser::ParameterListContext* myParser::FunctionTypeContext::parameterList() {
  return getRuleContext<myParser::ParameterListContext>(0);
}


size_t myParser::FunctionTypeContext::getRuleIndex() const {
  return myParser::RuleFunctionType;
}

void myParser::FunctionTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionType(this);
}

void myParser::FunctionTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionType(this);
}

myParser::FunctionTypeContext* myParser::functionType() {
  FunctionTypeContext *_localctx = _tracker.createInstance<FunctionTypeContext>(_ctx, getState());
  enterRule(_localctx, 50, myParser::RuleFunctionType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(461);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LessThan) {
      setState(460);
      typeParameters();
    }
    setState(463);
    match(myParser::OpenParen);
    setState(465);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4503599627370430192) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1751495634751324159) != 0)) {
      setState(464);
      parameterList();
    }
    setState(467);
    match(myParser::CloseParen);
    setState(468);
    match(myParser::ARROW);
    setState(469);
    type_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstructorTypeContext ------------------------------------------------------------------

myParser::ConstructorTypeContext::ConstructorTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ConstructorTypeContext::New() {
  return getToken(myParser::New, 0);
}

tree::TerminalNode* myParser::ConstructorTypeContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::ConstructorTypeContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

tree::TerminalNode* myParser::ConstructorTypeContext::ARROW() {
  return getToken(myParser::ARROW, 0);
}

myParser::Type_Context* myParser::ConstructorTypeContext::type_() {
  return getRuleContext<myParser::Type_Context>(0);
}

myParser::TypeParametersContext* myParser::ConstructorTypeContext::typeParameters() {
  return getRuleContext<myParser::TypeParametersContext>(0);
}

myParser::ParameterListContext* myParser::ConstructorTypeContext::parameterList() {
  return getRuleContext<myParser::ParameterListContext>(0);
}


size_t myParser::ConstructorTypeContext::getRuleIndex() const {
  return myParser::RuleConstructorType;
}

void myParser::ConstructorTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstructorType(this);
}

void myParser::ConstructorTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstructorType(this);
}

myParser::ConstructorTypeContext* myParser::constructorType() {
  ConstructorTypeContext *_localctx = _tracker.createInstance<ConstructorTypeContext>(_ctx, getState());
  enterRule(_localctx, 52, myParser::RuleConstructorType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(471);
    match(myParser::New);
    setState(473);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LessThan) {
      setState(472);
      typeParameters();
    }
    setState(475);
    match(myParser::OpenParen);
    setState(477);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4503599627370430192) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1751495634751324159) != 0)) {
      setState(476);
      parameterList();
    }
    setState(479);
    match(myParser::CloseParen);
    setState(480);
    match(myParser::ARROW);
    setState(481);
    type_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeQueryContext ------------------------------------------------------------------

myParser::TypeQueryContext::TypeQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TypeQueryContext::Typeof() {
  return getToken(myParser::Typeof, 0);
}

myParser::TypeQueryExpressionContext* myParser::TypeQueryContext::typeQueryExpression() {
  return getRuleContext<myParser::TypeQueryExpressionContext>(0);
}


size_t myParser::TypeQueryContext::getRuleIndex() const {
  return myParser::RuleTypeQuery;
}

void myParser::TypeQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeQuery(this);
}

void myParser::TypeQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeQuery(this);
}

myParser::TypeQueryContext* myParser::typeQuery() {
  TypeQueryContext *_localctx = _tracker.createInstance<TypeQueryContext>(_ctx, getState());
  enterRule(_localctx, 54, myParser::RuleTypeQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(483);
    match(myParser::Typeof);
    setState(484);
    typeQueryExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeQueryExpressionContext ------------------------------------------------------------------

myParser::TypeQueryExpressionContext::TypeQueryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TypeQueryExpressionContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

std::vector<myParser::IdentifierNameContext *> myParser::TypeQueryExpressionContext::identifierName() {
  return getRuleContexts<myParser::IdentifierNameContext>();
}

myParser::IdentifierNameContext* myParser::TypeQueryExpressionContext::identifierName(size_t i) {
  return getRuleContext<myParser::IdentifierNameContext>(i);
}

std::vector<tree::TerminalNode *> myParser::TypeQueryExpressionContext::Dot() {
  return getTokens(myParser::Dot);
}

tree::TerminalNode* myParser::TypeQueryExpressionContext::Dot(size_t i) {
  return getToken(myParser::Dot, i);
}


size_t myParser::TypeQueryExpressionContext::getRuleIndex() const {
  return myParser::RuleTypeQueryExpression;
}

void myParser::TypeQueryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeQueryExpression(this);
}

void myParser::TypeQueryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeQueryExpression(this);
}

myParser::TypeQueryExpressionContext* myParser::typeQueryExpression() {
  TypeQueryExpressionContext *_localctx = _tracker.createInstance<TypeQueryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 56, myParser::RuleTypeQueryExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(496);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(486);
      match(myParser::Identifier);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(490); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(487);
                identifierName();
                setState(488);
                match(myParser::Dot);
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(492); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(494);
      identifierName();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertySignaturContext ------------------------------------------------------------------

myParser::PropertySignaturContext::PropertySignaturContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::PropertyNameContext* myParser::PropertySignaturContext::propertyName() {
  return getRuleContext<myParser::PropertyNameContext>(0);
}

tree::TerminalNode* myParser::PropertySignaturContext::ReadOnly() {
  return getToken(myParser::ReadOnly, 0);
}

tree::TerminalNode* myParser::PropertySignaturContext::QuestionMark() {
  return getToken(myParser::QuestionMark, 0);
}

myParser::TypeAnnotationContext* myParser::PropertySignaturContext::typeAnnotation() {
  return getRuleContext<myParser::TypeAnnotationContext>(0);
}

tree::TerminalNode* myParser::PropertySignaturContext::ARROW() {
  return getToken(myParser::ARROW, 0);
}

myParser::Type_Context* myParser::PropertySignaturContext::type_() {
  return getRuleContext<myParser::Type_Context>(0);
}


size_t myParser::PropertySignaturContext::getRuleIndex() const {
  return myParser::RulePropertySignatur;
}

void myParser::PropertySignaturContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertySignatur(this);
}

void myParser::PropertySignaturContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertySignatur(this);
}

myParser::PropertySignaturContext* myParser::propertySignatur() {
  PropertySignaturContext *_localctx = _tracker.createInstance<PropertySignaturContext>(_ctx, getState());
  enterRule(_localctx, 58, myParser::RulePropertySignatur);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(499);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
    case 1: {
      setState(498);
      match(myParser::ReadOnly);
      break;
    }

    default:
      break;
    }
    setState(501);
    propertyName();
    setState(503);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::QuestionMark) {
      setState(502);
      match(myParser::QuestionMark);
    }
    setState(506);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Colon) {
      setState(505);
      typeAnnotation();
    }
    setState(510);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::ARROW) {
      setState(508);
      match(myParser::ARROW);
      setState(509);
      type_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeAnnotationContext ------------------------------------------------------------------

myParser::TypeAnnotationContext::TypeAnnotationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TypeAnnotationContext::Colon() {
  return getToken(myParser::Colon, 0);
}

myParser::Type_Context* myParser::TypeAnnotationContext::type_() {
  return getRuleContext<myParser::Type_Context>(0);
}


size_t myParser::TypeAnnotationContext::getRuleIndex() const {
  return myParser::RuleTypeAnnotation;
}

void myParser::TypeAnnotationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeAnnotation(this);
}

void myParser::TypeAnnotationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeAnnotation(this);
}

myParser::TypeAnnotationContext* myParser::typeAnnotation() {
  TypeAnnotationContext *_localctx = _tracker.createInstance<TypeAnnotationContext>(_ctx, getState());
  enterRule(_localctx, 60, myParser::RuleTypeAnnotation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(512);
    match(myParser::Colon);
    setState(513);
    type_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CallSignatureContext ------------------------------------------------------------------

myParser::CallSignatureContext::CallSignatureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::CallSignatureContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::CallSignatureContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::TypeParametersContext* myParser::CallSignatureContext::typeParameters() {
  return getRuleContext<myParser::TypeParametersContext>(0);
}

myParser::ParameterListContext* myParser::CallSignatureContext::parameterList() {
  return getRuleContext<myParser::ParameterListContext>(0);
}

myParser::TypeAnnotationContext* myParser::CallSignatureContext::typeAnnotation() {
  return getRuleContext<myParser::TypeAnnotationContext>(0);
}


size_t myParser::CallSignatureContext::getRuleIndex() const {
  return myParser::RuleCallSignature;
}

void myParser::CallSignatureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCallSignature(this);
}

void myParser::CallSignatureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCallSignature(this);
}

myParser::CallSignatureContext* myParser::callSignature() {
  CallSignatureContext *_localctx = _tracker.createInstance<CallSignatureContext>(_ctx, getState());
  enterRule(_localctx, 62, myParser::RuleCallSignature);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(516);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LessThan) {
      setState(515);
      typeParameters();
    }
    setState(518);
    match(myParser::OpenParen);
    setState(520);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4503599627370430192) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1751495634751324159) != 0)) {
      setState(519);
      parameterList();
    }
    setState(522);
    match(myParser::CloseParen);
    setState(524);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {
    case 1: {
      setState(523);
      typeAnnotation();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterListContext ------------------------------------------------------------------

myParser::ParameterListContext::ParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::RestParameterContext* myParser::ParameterListContext::restParameter() {
  return getRuleContext<myParser::RestParameterContext>(0);
}

std::vector<myParser::ParameterContext *> myParser::ParameterListContext::parameter() {
  return getRuleContexts<myParser::ParameterContext>();
}

myParser::ParameterContext* myParser::ParameterListContext::parameter(size_t i) {
  return getRuleContext<myParser::ParameterContext>(i);
}

std::vector<tree::TerminalNode *> myParser::ParameterListContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::ParameterListContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::ParameterListContext::getRuleIndex() const {
  return myParser::RuleParameterList;
}

void myParser::ParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameterList(this);
}

void myParser::ParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameterList(this);
}

myParser::ParameterListContext* myParser::parameterList() {
  ParameterListContext *_localctx = _tracker.createInstance<ParameterListContext>(_ctx, getState());
  enterRule(_localctx, 64, myParser::RuleParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(539);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Ellipsis: {
        enterOuterAlt(_localctx, 1);
        setState(526);
        restParameter();
        break;
      }

      case myParser::OpenBracket:
      case myParser::OpenBrace:
      case myParser::NullLiteral:
      case myParser::BooleanLiteral:
      case myParser::Break:
      case myParser::Do:
      case myParser::Instanceof:
      case myParser::Typeof:
      case myParser::Case:
      case myParser::Else:
      case myParser::New:
      case myParser::Var:
      case myParser::Catch:
      case myParser::Finally:
      case myParser::Return:
      case myParser::Void:
      case myParser::Continue:
      case myParser::For:
      case myParser::Switch:
      case myParser::While:
      case myParser::Debugger:
      case myParser::Function_:
      case myParser::This:
      case myParser::With:
      case myParser::Default:
      case myParser::If:
      case myParser::Throw:
      case myParser::Delete:
      case myParser::In:
      case myParser::Try:
      case myParser::From:
      case myParser::ReadOnly:
      case myParser::Async:
      case myParser::Class:
      case myParser::Enum:
      case myParser::Extends:
      case myParser::Super:
      case myParser::Const:
      case myParser::Export:
      case myParser::Import:
      case myParser::Implements:
      case myParser::Let:
      case myParser::Private:
      case myParser::Public:
      case myParser::Interface:
      case myParser::Package:
      case myParser::Protected:
      case myParser::Static:
      case myParser::Yield:
      case myParser::String:
      case myParser::TypeAlias:
      case myParser::Get:
      case myParser::Set:
      case myParser::Require:
      case myParser::At:
      case myParser::Identifier: {
        enterOuterAlt(_localctx, 2);
        setState(527);
        parameter();
        setState(532);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(528);
            match(myParser::Comma);
            setState(529);
            parameter(); 
          }
          setState(534);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx);
        }
        setState(537);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::Comma) {
          setState(535);
          match(myParser::Comma);
          setState(536);
          restParameter();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RequiredParameterListContext ------------------------------------------------------------------

myParser::RequiredParameterListContext::RequiredParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::RequiredParameterContext *> myParser::RequiredParameterListContext::requiredParameter() {
  return getRuleContexts<myParser::RequiredParameterContext>();
}

myParser::RequiredParameterContext* myParser::RequiredParameterListContext::requiredParameter(size_t i) {
  return getRuleContext<myParser::RequiredParameterContext>(i);
}

std::vector<tree::TerminalNode *> myParser::RequiredParameterListContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::RequiredParameterListContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::RequiredParameterListContext::getRuleIndex() const {
  return myParser::RuleRequiredParameterList;
}

void myParser::RequiredParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRequiredParameterList(this);
}

void myParser::RequiredParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRequiredParameterList(this);
}

myParser::RequiredParameterListContext* myParser::requiredParameterList() {
  RequiredParameterListContext *_localctx = _tracker.createInstance<RequiredParameterListContext>(_ctx, getState());
  enterRule(_localctx, 66, myParser::RuleRequiredParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(541);
    requiredParameter();
    setState(546);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::Comma) {
      setState(542);
      match(myParser::Comma);
      setState(543);
      requiredParameter();
      setState(548);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterContext ------------------------------------------------------------------

myParser::ParameterContext::ParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::RequiredParameterContext* myParser::ParameterContext::requiredParameter() {
  return getRuleContext<myParser::RequiredParameterContext>(0);
}

myParser::OptionalParameterContext* myParser::ParameterContext::optionalParameter() {
  return getRuleContext<myParser::OptionalParameterContext>(0);
}


size_t myParser::ParameterContext::getRuleIndex() const {
  return myParser::RuleParameter;
}

void myParser::ParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter(this);
}

void myParser::ParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter(this);
}

myParser::ParameterContext* myParser::parameter() {
  ParameterContext *_localctx = _tracker.createInstance<ParameterContext>(_ctx, getState());
  enterRule(_localctx, 68, myParser::RuleParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(551);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(549);
      requiredParameter();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(550);
      optionalParameter();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionalParameterContext ------------------------------------------------------------------

myParser::OptionalParameterContext::OptionalParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierOrPatternContext* myParser::OptionalParameterContext::identifierOrPattern() {
  return getRuleContext<myParser::IdentifierOrPatternContext>(0);
}

myParser::DecoratorListContext* myParser::OptionalParameterContext::decoratorList() {
  return getRuleContext<myParser::DecoratorListContext>(0);
}

tree::TerminalNode* myParser::OptionalParameterContext::QuestionMark() {
  return getToken(myParser::QuestionMark, 0);
}

myParser::InitializerContext* myParser::OptionalParameterContext::initializer() {
  return getRuleContext<myParser::InitializerContext>(0);
}

myParser::AccessibilityModifierContext* myParser::OptionalParameterContext::accessibilityModifier() {
  return getRuleContext<myParser::AccessibilityModifierContext>(0);
}

myParser::TypeAnnotationContext* myParser::OptionalParameterContext::typeAnnotation() {
  return getRuleContext<myParser::TypeAnnotationContext>(0);
}


size_t myParser::OptionalParameterContext::getRuleIndex() const {
  return myParser::RuleOptionalParameter;
}

void myParser::OptionalParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionalParameter(this);
}

void myParser::OptionalParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionalParameter(this);
}

myParser::OptionalParameterContext* myParser::optionalParameter() {
  OptionalParameterContext *_localctx = _tracker.createInstance<OptionalParameterContext>(_ctx, getState());
  enterRule(_localctx, 70, myParser::RuleOptionalParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(554);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::At) {
      setState(553);
      decoratorList();
    }

    setState(557);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx)) {
    case 1: {
      setState(556);
      accessibilityModifier();
      break;
    }

    default:
      break;
    }
    setState(559);
    identifierOrPattern();
    setState(568);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::QuestionMark: {
        setState(560);
        match(myParser::QuestionMark);
        setState(562);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::Colon) {
          setState(561);
          typeAnnotation();
        }
        break;
      }

      case myParser::Assign:
      case myParser::Colon: {
        setState(565);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::Colon) {
          setState(564);
          typeAnnotation();
        }
        setState(567);
        initializer();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RestParameterContext ------------------------------------------------------------------

myParser::RestParameterContext::RestParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::RestParameterContext::Ellipsis() {
  return getToken(myParser::Ellipsis, 0);
}

myParser::SingleExpressionContext* myParser::RestParameterContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::TypeAnnotationContext* myParser::RestParameterContext::typeAnnotation() {
  return getRuleContext<myParser::TypeAnnotationContext>(0);
}


size_t myParser::RestParameterContext::getRuleIndex() const {
  return myParser::RuleRestParameter;
}

void myParser::RestParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRestParameter(this);
}

void myParser::RestParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRestParameter(this);
}

myParser::RestParameterContext* myParser::restParameter() {
  RestParameterContext *_localctx = _tracker.createInstance<RestParameterContext>(_ctx, getState());
  enterRule(_localctx, 72, myParser::RuleRestParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(570);
    match(myParser::Ellipsis);
    setState(571);
    singleExpression(0);
    setState(573);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Colon) {
      setState(572);
      typeAnnotation();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RequiredParameterContext ------------------------------------------------------------------

myParser::RequiredParameterContext::RequiredParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierOrPatternContext* myParser::RequiredParameterContext::identifierOrPattern() {
  return getRuleContext<myParser::IdentifierOrPatternContext>(0);
}

myParser::DecoratorListContext* myParser::RequiredParameterContext::decoratorList() {
  return getRuleContext<myParser::DecoratorListContext>(0);
}

myParser::AccessibilityModifierContext* myParser::RequiredParameterContext::accessibilityModifier() {
  return getRuleContext<myParser::AccessibilityModifierContext>(0);
}

myParser::TypeAnnotationContext* myParser::RequiredParameterContext::typeAnnotation() {
  return getRuleContext<myParser::TypeAnnotationContext>(0);
}


size_t myParser::RequiredParameterContext::getRuleIndex() const {
  return myParser::RuleRequiredParameter;
}

void myParser::RequiredParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRequiredParameter(this);
}

void myParser::RequiredParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRequiredParameter(this);
}

myParser::RequiredParameterContext* myParser::requiredParameter() {
  RequiredParameterContext *_localctx = _tracker.createInstance<RequiredParameterContext>(_ctx, getState());
  enterRule(_localctx, 74, myParser::RuleRequiredParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(576);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::At) {
      setState(575);
      decoratorList();
    }
    setState(579);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx)) {
    case 1: {
      setState(578);
      accessibilityModifier();
      break;
    }

    default:
      break;
    }
    setState(581);
    identifierOrPattern();
    setState(583);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Colon) {
      setState(582);
      typeAnnotation();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AccessibilityModifierContext ------------------------------------------------------------------

myParser::AccessibilityModifierContext::AccessibilityModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::AccessibilityModifierContext::Public() {
  return getToken(myParser::Public, 0);
}

tree::TerminalNode* myParser::AccessibilityModifierContext::Private() {
  return getToken(myParser::Private, 0);
}

tree::TerminalNode* myParser::AccessibilityModifierContext::Protected() {
  return getToken(myParser::Protected, 0);
}


size_t myParser::AccessibilityModifierContext::getRuleIndex() const {
  return myParser::RuleAccessibilityModifier;
}

void myParser::AccessibilityModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAccessibilityModifier(this);
}

void myParser::AccessibilityModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAccessibilityModifier(this);
}

myParser::AccessibilityModifierContext* myParser::accessibilityModifier() {
  AccessibilityModifierContext *_localctx = _tracker.createInstance<AccessibilityModifierContext>(_ctx, getState());
  enterRule(_localctx, 76, myParser::RuleAccessibilityModifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(585);
    _la = _input->LA(1);
    if (!(((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 19) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierOrPatternContext ------------------------------------------------------------------

myParser::IdentifierOrPatternContext::IdentifierOrPatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierNameContext* myParser::IdentifierOrPatternContext::identifierName() {
  return getRuleContext<myParser::IdentifierNameContext>(0);
}

myParser::BindingPatternContext* myParser::IdentifierOrPatternContext::bindingPattern() {
  return getRuleContext<myParser::BindingPatternContext>(0);
}


size_t myParser::IdentifierOrPatternContext::getRuleIndex() const {
  return myParser::RuleIdentifierOrPattern;
}

void myParser::IdentifierOrPatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierOrPattern(this);
}

void myParser::IdentifierOrPatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierOrPattern(this);
}

myParser::IdentifierOrPatternContext* myParser::identifierOrPattern() {
  IdentifierOrPatternContext *_localctx = _tracker.createInstance<IdentifierOrPatternContext>(_ctx, getState());
  enterRule(_localctx, 78, myParser::RuleIdentifierOrPattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(589);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::NullLiteral:
      case myParser::BooleanLiteral:
      case myParser::Break:
      case myParser::Do:
      case myParser::Instanceof:
      case myParser::Typeof:
      case myParser::Case:
      case myParser::Else:
      case myParser::New:
      case myParser::Var:
      case myParser::Catch:
      case myParser::Finally:
      case myParser::Return:
      case myParser::Void:
      case myParser::Continue:
      case myParser::For:
      case myParser::Switch:
      case myParser::While:
      case myParser::Debugger:
      case myParser::Function_:
      case myParser::This:
      case myParser::With:
      case myParser::Default:
      case myParser::If:
      case myParser::Throw:
      case myParser::Delete:
      case myParser::In:
      case myParser::Try:
      case myParser::From:
      case myParser::ReadOnly:
      case myParser::Async:
      case myParser::Class:
      case myParser::Enum:
      case myParser::Extends:
      case myParser::Super:
      case myParser::Const:
      case myParser::Export:
      case myParser::Import:
      case myParser::Implements:
      case myParser::Let:
      case myParser::Private:
      case myParser::Public:
      case myParser::Interface:
      case myParser::Package:
      case myParser::Protected:
      case myParser::Static:
      case myParser::Yield:
      case myParser::String:
      case myParser::TypeAlias:
      case myParser::Get:
      case myParser::Set:
      case myParser::Require:
      case myParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(587);
        identifierName();
        break;
      }

      case myParser::OpenBracket:
      case myParser::OpenBrace: {
        enterOuterAlt(_localctx, 2);
        setState(588);
        bindingPattern();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstructSignatureContext ------------------------------------------------------------------

myParser::ConstructSignatureContext::ConstructSignatureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ConstructSignatureContext::New() {
  return getToken(myParser::New, 0);
}

tree::TerminalNode* myParser::ConstructSignatureContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::ConstructSignatureContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::TypeParametersContext* myParser::ConstructSignatureContext::typeParameters() {
  return getRuleContext<myParser::TypeParametersContext>(0);
}

myParser::ParameterListContext* myParser::ConstructSignatureContext::parameterList() {
  return getRuleContext<myParser::ParameterListContext>(0);
}

myParser::TypeAnnotationContext* myParser::ConstructSignatureContext::typeAnnotation() {
  return getRuleContext<myParser::TypeAnnotationContext>(0);
}


size_t myParser::ConstructSignatureContext::getRuleIndex() const {
  return myParser::RuleConstructSignature;
}

void myParser::ConstructSignatureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstructSignature(this);
}

void myParser::ConstructSignatureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstructSignature(this);
}

myParser::ConstructSignatureContext* myParser::constructSignature() {
  ConstructSignatureContext *_localctx = _tracker.createInstance<ConstructSignatureContext>(_ctx, getState());
  enterRule(_localctx, 80, myParser::RuleConstructSignature);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(591);
    match(myParser::New);
    setState(593);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LessThan) {
      setState(592);
      typeParameters();
    }
    setState(595);
    match(myParser::OpenParen);
    setState(597);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4503599627370430192) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1751495634751324159) != 0)) {
      setState(596);
      parameterList();
    }
    setState(599);
    match(myParser::CloseParen);
    setState(601);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Colon) {
      setState(600);
      typeAnnotation();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexSignatureContext ------------------------------------------------------------------

myParser::IndexSignatureContext::IndexSignatureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::IndexSignatureContext::OpenBracket() {
  return getToken(myParser::OpenBracket, 0);
}

tree::TerminalNode* myParser::IndexSignatureContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

tree::TerminalNode* myParser::IndexSignatureContext::Colon() {
  return getToken(myParser::Colon, 0);
}

tree::TerminalNode* myParser::IndexSignatureContext::CloseBracket() {
  return getToken(myParser::CloseBracket, 0);
}

myParser::TypeAnnotationContext* myParser::IndexSignatureContext::typeAnnotation() {
  return getRuleContext<myParser::TypeAnnotationContext>(0);
}

tree::TerminalNode* myParser::IndexSignatureContext::Number() {
  return getToken(myParser::Number, 0);
}

tree::TerminalNode* myParser::IndexSignatureContext::String() {
  return getToken(myParser::String, 0);
}


size_t myParser::IndexSignatureContext::getRuleIndex() const {
  return myParser::RuleIndexSignature;
}

void myParser::IndexSignatureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexSignature(this);
}

void myParser::IndexSignatureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexSignature(this);
}

myParser::IndexSignatureContext* myParser::indexSignature() {
  IndexSignatureContext *_localctx = _tracker.createInstance<IndexSignatureContext>(_ctx, getState());
  enterRule(_localctx, 82, myParser::RuleIndexSignature);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(603);
    match(myParser::OpenBracket);
    setState(604);
    match(myParser::Identifier);
    setState(605);
    match(myParser::Colon);
    setState(606);
    _la = _input->LA(1);
    if (!(_la == myParser::Number

    || _la == myParser::String)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(607);
    match(myParser::CloseBracket);
    setState(608);
    typeAnnotation();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MethodSignatureContext ------------------------------------------------------------------

myParser::MethodSignatureContext::MethodSignatureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::PropertyNameContext* myParser::MethodSignatureContext::propertyName() {
  return getRuleContext<myParser::PropertyNameContext>(0);
}

myParser::CallSignatureContext* myParser::MethodSignatureContext::callSignature() {
  return getRuleContext<myParser::CallSignatureContext>(0);
}

tree::TerminalNode* myParser::MethodSignatureContext::QuestionMark() {
  return getToken(myParser::QuestionMark, 0);
}


size_t myParser::MethodSignatureContext::getRuleIndex() const {
  return myParser::RuleMethodSignature;
}

void myParser::MethodSignatureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMethodSignature(this);
}

void myParser::MethodSignatureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMethodSignature(this);
}

myParser::MethodSignatureContext* myParser::methodSignature() {
  MethodSignatureContext *_localctx = _tracker.createInstance<MethodSignatureContext>(_ctx, getState());
  enterRule(_localctx, 84, myParser::RuleMethodSignature);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(610);
    propertyName();
    setState(612);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::QuestionMark) {
      setState(611);
      match(myParser::QuestionMark);
    }
    setState(614);
    callSignature();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeAliasDeclarationContext ------------------------------------------------------------------

myParser::TypeAliasDeclarationContext::TypeAliasDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TypeAliasDeclarationContext::TypeAlias() {
  return getToken(myParser::TypeAlias, 0);
}

tree::TerminalNode* myParser::TypeAliasDeclarationContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

tree::TerminalNode* myParser::TypeAliasDeclarationContext::Assign() {
  return getToken(myParser::Assign, 0);
}

myParser::Type_Context* myParser::TypeAliasDeclarationContext::type_() {
  return getRuleContext<myParser::Type_Context>(0);
}

tree::TerminalNode* myParser::TypeAliasDeclarationContext::SemiColon() {
  return getToken(myParser::SemiColon, 0);
}

myParser::TypeParametersContext* myParser::TypeAliasDeclarationContext::typeParameters() {
  return getRuleContext<myParser::TypeParametersContext>(0);
}


size_t myParser::TypeAliasDeclarationContext::getRuleIndex() const {
  return myParser::RuleTypeAliasDeclaration;
}

void myParser::TypeAliasDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeAliasDeclaration(this);
}

void myParser::TypeAliasDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeAliasDeclaration(this);
}

myParser::TypeAliasDeclarationContext* myParser::typeAliasDeclaration() {
  TypeAliasDeclarationContext *_localctx = _tracker.createInstance<TypeAliasDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 86, myParser::RuleTypeAliasDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(616);
    match(myParser::TypeAlias);
    setState(617);
    match(myParser::Identifier);
    setState(619);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LessThan) {
      setState(618);
      typeParameters();
    }
    setState(621);
    match(myParser::Assign);
    setState(622);
    type_();
    setState(623);
    match(myParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstructorDeclarationContext ------------------------------------------------------------------

myParser::ConstructorDeclarationContext::ConstructorDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ConstructorDeclarationContext::Constructor() {
  return getToken(myParser::Constructor, 0);
}

tree::TerminalNode* myParser::ConstructorDeclarationContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::ConstructorDeclarationContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::AccessibilityModifierContext* myParser::ConstructorDeclarationContext::accessibilityModifier() {
  return getRuleContext<myParser::AccessibilityModifierContext>(0);
}

myParser::FormalParameterListContext* myParser::ConstructorDeclarationContext::formalParameterList() {
  return getRuleContext<myParser::FormalParameterListContext>(0);
}

tree::TerminalNode* myParser::ConstructorDeclarationContext::SemiColon() {
  return getToken(myParser::SemiColon, 0);
}

tree::TerminalNode* myParser::ConstructorDeclarationContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

myParser::FunctionBodyContext* myParser::ConstructorDeclarationContext::functionBody() {
  return getRuleContext<myParser::FunctionBodyContext>(0);
}

tree::TerminalNode* myParser::ConstructorDeclarationContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}


size_t myParser::ConstructorDeclarationContext::getRuleIndex() const {
  return myParser::RuleConstructorDeclaration;
}

void myParser::ConstructorDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstructorDeclaration(this);
}

void myParser::ConstructorDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstructorDeclaration(this);
}

myParser::ConstructorDeclarationContext* myParser::constructorDeclaration() {
  ConstructorDeclarationContext *_localctx = _tracker.createInstance<ConstructorDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 88, myParser::RuleConstructorDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(626);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 19) != 0)) {
      setState(625);
      accessibilityModifier();
    }
    setState(628);
    match(myParser::Constructor);
    setState(629);
    match(myParser::OpenParen);
    setState(631);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 65808) != 0) || ((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 12718099) != 0)) {
      setState(630);
      formalParameterList();
    }
    setState(633);
    match(myParser::CloseParen);
    setState(639);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
    case 1: {
      setState(634);
      match(myParser::OpenBrace);
      setState(635);
      functionBody();
      setState(636);
      match(myParser::CloseBrace);
      break;
    }

    case 2: {
      setState(638);
      match(myParser::SemiColon);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InterfaceDeclarationContext ------------------------------------------------------------------

myParser::InterfaceDeclarationContext::InterfaceDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::InterfaceDeclarationContext::Interface() {
  return getToken(myParser::Interface, 0);
}

tree::TerminalNode* myParser::InterfaceDeclarationContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

myParser::ObjectTypeContext* myParser::InterfaceDeclarationContext::objectType() {
  return getRuleContext<myParser::ObjectTypeContext>(0);
}

tree::TerminalNode* myParser::InterfaceDeclarationContext::Export() {
  return getToken(myParser::Export, 0);
}

tree::TerminalNode* myParser::InterfaceDeclarationContext::Declare() {
  return getToken(myParser::Declare, 0);
}

myParser::TypeParametersContext* myParser::InterfaceDeclarationContext::typeParameters() {
  return getRuleContext<myParser::TypeParametersContext>(0);
}

myParser::InterfaceExtendsClauseContext* myParser::InterfaceDeclarationContext::interfaceExtendsClause() {
  return getRuleContext<myParser::InterfaceExtendsClauseContext>(0);
}

tree::TerminalNode* myParser::InterfaceDeclarationContext::SemiColon() {
  return getToken(myParser::SemiColon, 0);
}


size_t myParser::InterfaceDeclarationContext::getRuleIndex() const {
  return myParser::RuleInterfaceDeclaration;
}

void myParser::InterfaceDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterfaceDeclaration(this);
}

void myParser::InterfaceDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterfaceDeclaration(this);
}

myParser::InterfaceDeclarationContext* myParser::interfaceDeclaration() {
  InterfaceDeclarationContext *_localctx = _tracker.createInstance<InterfaceDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 90, myParser::RuleInterfaceDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(642);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Export) {
      setState(641);
      match(myParser::Export);
    }
    setState(645);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Declare) {
      setState(644);
      match(myParser::Declare);
    }
    setState(647);
    match(myParser::Interface);
    setState(648);
    match(myParser::Identifier);
    setState(650);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LessThan) {
      setState(649);
      typeParameters();
    }
    setState(653);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Extends) {
      setState(652);
      interfaceExtendsClause();
    }
    setState(655);
    objectType();
    setState(657);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
    case 1: {
      setState(656);
      match(myParser::SemiColon);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InterfaceExtendsClauseContext ------------------------------------------------------------------

myParser::InterfaceExtendsClauseContext::InterfaceExtendsClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::InterfaceExtendsClauseContext::Extends() {
  return getToken(myParser::Extends, 0);
}

myParser::ClassOrInterfaceTypeListContext* myParser::InterfaceExtendsClauseContext::classOrInterfaceTypeList() {
  return getRuleContext<myParser::ClassOrInterfaceTypeListContext>(0);
}


size_t myParser::InterfaceExtendsClauseContext::getRuleIndex() const {
  return myParser::RuleInterfaceExtendsClause;
}

void myParser::InterfaceExtendsClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterfaceExtendsClause(this);
}

void myParser::InterfaceExtendsClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterfaceExtendsClause(this);
}

myParser::InterfaceExtendsClauseContext* myParser::interfaceExtendsClause() {
  InterfaceExtendsClauseContext *_localctx = _tracker.createInstance<InterfaceExtendsClauseContext>(_ctx, getState());
  enterRule(_localctx, 92, myParser::RuleInterfaceExtendsClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(659);
    match(myParser::Extends);
    setState(660);
    classOrInterfaceTypeList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassOrInterfaceTypeListContext ------------------------------------------------------------------

myParser::ClassOrInterfaceTypeListContext::ClassOrInterfaceTypeListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::TypeReferenceContext *> myParser::ClassOrInterfaceTypeListContext::typeReference() {
  return getRuleContexts<myParser::TypeReferenceContext>();
}

myParser::TypeReferenceContext* myParser::ClassOrInterfaceTypeListContext::typeReference(size_t i) {
  return getRuleContext<myParser::TypeReferenceContext>(i);
}

std::vector<tree::TerminalNode *> myParser::ClassOrInterfaceTypeListContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::ClassOrInterfaceTypeListContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::ClassOrInterfaceTypeListContext::getRuleIndex() const {
  return myParser::RuleClassOrInterfaceTypeList;
}

void myParser::ClassOrInterfaceTypeListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassOrInterfaceTypeList(this);
}

void myParser::ClassOrInterfaceTypeListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassOrInterfaceTypeList(this);
}

myParser::ClassOrInterfaceTypeListContext* myParser::classOrInterfaceTypeList() {
  ClassOrInterfaceTypeListContext *_localctx = _tracker.createInstance<ClassOrInterfaceTypeListContext>(_ctx, getState());
  enterRule(_localctx, 94, myParser::RuleClassOrInterfaceTypeList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(662);
    typeReference();
    setState(667);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::Comma) {
      setState(663);
      match(myParser::Comma);
      setState(664);
      typeReference();
      setState(669);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumDeclarationContext ------------------------------------------------------------------

myParser::EnumDeclarationContext::EnumDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::EnumDeclarationContext::Enum() {
  return getToken(myParser::Enum, 0);
}

tree::TerminalNode* myParser::EnumDeclarationContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

tree::TerminalNode* myParser::EnumDeclarationContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

tree::TerminalNode* myParser::EnumDeclarationContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

tree::TerminalNode* myParser::EnumDeclarationContext::Const() {
  return getToken(myParser::Const, 0);
}

myParser::EnumBodyContext* myParser::EnumDeclarationContext::enumBody() {
  return getRuleContext<myParser::EnumBodyContext>(0);
}


size_t myParser::EnumDeclarationContext::getRuleIndex() const {
  return myParser::RuleEnumDeclaration;
}

void myParser::EnumDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumDeclaration(this);
}

void myParser::EnumDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumDeclaration(this);
}

myParser::EnumDeclarationContext* myParser::enumDeclaration() {
  EnumDeclarationContext *_localctx = _tracker.createInstance<EnumDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 96, myParser::RuleEnumDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(671);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Const) {
      setState(670);
      match(myParser::Const);
    }
    setState(673);
    match(myParser::Enum);
    setState(674);
    match(myParser::Identifier);
    setState(675);
    match(myParser::OpenBrace);
    setState(677);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -36028797018963968) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3480877891661594623) != 0)) {
      setState(676);
      enumBody();
    }
    setState(679);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumBodyContext ------------------------------------------------------------------

myParser::EnumBodyContext::EnumBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::EnumMemberListContext* myParser::EnumBodyContext::enumMemberList() {
  return getRuleContext<myParser::EnumMemberListContext>(0);
}

tree::TerminalNode* myParser::EnumBodyContext::Comma() {
  return getToken(myParser::Comma, 0);
}


size_t myParser::EnumBodyContext::getRuleIndex() const {
  return myParser::RuleEnumBody;
}

void myParser::EnumBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumBody(this);
}

void myParser::EnumBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumBody(this);
}

myParser::EnumBodyContext* myParser::enumBody() {
  EnumBodyContext *_localctx = _tracker.createInstance<EnumBodyContext>(_ctx, getState());
  enterRule(_localctx, 98, myParser::RuleEnumBody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(681);
    enumMemberList();
    setState(683);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Comma) {
      setState(682);
      match(myParser::Comma);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumMemberListContext ------------------------------------------------------------------

myParser::EnumMemberListContext::EnumMemberListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::EnumMemberContext *> myParser::EnumMemberListContext::enumMember() {
  return getRuleContexts<myParser::EnumMemberContext>();
}

myParser::EnumMemberContext* myParser::EnumMemberListContext::enumMember(size_t i) {
  return getRuleContext<myParser::EnumMemberContext>(i);
}

std::vector<tree::TerminalNode *> myParser::EnumMemberListContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::EnumMemberListContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::EnumMemberListContext::getRuleIndex() const {
  return myParser::RuleEnumMemberList;
}

void myParser::EnumMemberListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumMemberList(this);
}

void myParser::EnumMemberListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumMemberList(this);
}

myParser::EnumMemberListContext* myParser::enumMemberList() {
  EnumMemberListContext *_localctx = _tracker.createInstance<EnumMemberListContext>(_ctx, getState());
  enterRule(_localctx, 100, myParser::RuleEnumMemberList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(685);
    enumMember();
    setState(690);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(686);
        match(myParser::Comma);
        setState(687);
        enumMember(); 
      }
      setState(692);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumMemberContext ------------------------------------------------------------------

myParser::EnumMemberContext::EnumMemberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::PropertyNameContext* myParser::EnumMemberContext::propertyName() {
  return getRuleContext<myParser::PropertyNameContext>(0);
}

tree::TerminalNode* myParser::EnumMemberContext::Assign() {
  return getToken(myParser::Assign, 0);
}

myParser::SingleExpressionContext* myParser::EnumMemberContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}


size_t myParser::EnumMemberContext::getRuleIndex() const {
  return myParser::RuleEnumMember;
}

void myParser::EnumMemberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumMember(this);
}

void myParser::EnumMemberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumMember(this);
}

myParser::EnumMemberContext* myParser::enumMember() {
  EnumMemberContext *_localctx = _tracker.createInstance<EnumMemberContext>(_ctx, getState());
  enterRule(_localctx, 102, myParser::RuleEnumMember);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(693);
    propertyName();
    setState(696);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Assign) {
      setState(694);
      match(myParser::Assign);
      setState(695);
      singleExpression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamespaceDeclarationContext ------------------------------------------------------------------

myParser::NamespaceDeclarationContext::NamespaceDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::NamespaceDeclarationContext::Namespace() {
  return getToken(myParser::Namespace, 0);
}

myParser::NamespaceNameContext* myParser::NamespaceDeclarationContext::namespaceName() {
  return getRuleContext<myParser::NamespaceNameContext>(0);
}

tree::TerminalNode* myParser::NamespaceDeclarationContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

tree::TerminalNode* myParser::NamespaceDeclarationContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

myParser::StatementListContext* myParser::NamespaceDeclarationContext::statementList() {
  return getRuleContext<myParser::StatementListContext>(0);
}


size_t myParser::NamespaceDeclarationContext::getRuleIndex() const {
  return myParser::RuleNamespaceDeclaration;
}

void myParser::NamespaceDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamespaceDeclaration(this);
}

void myParser::NamespaceDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamespaceDeclaration(this);
}

myParser::NamespaceDeclarationContext* myParser::namespaceDeclaration() {
  NamespaceDeclarationContext *_localctx = _tracker.createInstance<NamespaceDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 104, myParser::RuleNamespaceDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(698);
    match(myParser::Namespace);
    setState(699);
    namespaceName();
    setState(700);
    match(myParser::OpenBrace);
    setState(702);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
    case 1: {
      setState(701);
      statementList();
      break;
    }

    default:
      break;
    }
    setState(704);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamespaceNameContext ------------------------------------------------------------------

myParser::NamespaceNameContext::NamespaceNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> myParser::NamespaceNameContext::Identifier() {
  return getTokens(myParser::Identifier);
}

tree::TerminalNode* myParser::NamespaceNameContext::Identifier(size_t i) {
  return getToken(myParser::Identifier, i);
}

std::vector<tree::TerminalNode *> myParser::NamespaceNameContext::Dot() {
  return getTokens(myParser::Dot);
}

tree::TerminalNode* myParser::NamespaceNameContext::Dot(size_t i) {
  return getToken(myParser::Dot, i);
}


size_t myParser::NamespaceNameContext::getRuleIndex() const {
  return myParser::RuleNamespaceName;
}

void myParser::NamespaceNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamespaceName(this);
}

void myParser::NamespaceNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamespaceName(this);
}

myParser::NamespaceNameContext* myParser::namespaceName() {
  NamespaceNameContext *_localctx = _tracker.createInstance<NamespaceNameContext>(_ctx, getState());
  enterRule(_localctx, 106, myParser::RuleNamespaceName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(706);
    match(myParser::Identifier);
    setState(715);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(708); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(707);
          match(myParser::Dot);
          setState(710); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == myParser::Dot);
        setState(712);
        match(myParser::Identifier); 
      }
      setState(717);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportAliasDeclarationContext ------------------------------------------------------------------

myParser::ImportAliasDeclarationContext::ImportAliasDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ImportAliasDeclarationContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

tree::TerminalNode* myParser::ImportAliasDeclarationContext::Assign() {
  return getToken(myParser::Assign, 0);
}

myParser::NamespaceNameContext* myParser::ImportAliasDeclarationContext::namespaceName() {
  return getRuleContext<myParser::NamespaceNameContext>(0);
}

tree::TerminalNode* myParser::ImportAliasDeclarationContext::SemiColon() {
  return getToken(myParser::SemiColon, 0);
}


size_t myParser::ImportAliasDeclarationContext::getRuleIndex() const {
  return myParser::RuleImportAliasDeclaration;
}

void myParser::ImportAliasDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportAliasDeclaration(this);
}

void myParser::ImportAliasDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportAliasDeclaration(this);
}

myParser::ImportAliasDeclarationContext* myParser::importAliasDeclaration() {
  ImportAliasDeclarationContext *_localctx = _tracker.createInstance<ImportAliasDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 108, myParser::RuleImportAliasDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(718);
    match(myParser::Identifier);
    setState(719);
    match(myParser::Assign);
    setState(720);
    namespaceName();
    setState(721);
    match(myParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DecoratorListContext ------------------------------------------------------------------

myParser::DecoratorListContext::DecoratorListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::DecoratorContext *> myParser::DecoratorListContext::decorator() {
  return getRuleContexts<myParser::DecoratorContext>();
}

myParser::DecoratorContext* myParser::DecoratorListContext::decorator(size_t i) {
  return getRuleContext<myParser::DecoratorContext>(i);
}


size_t myParser::DecoratorListContext::getRuleIndex() const {
  return myParser::RuleDecoratorList;
}

void myParser::DecoratorListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecoratorList(this);
}

void myParser::DecoratorListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecoratorList(this);
}

myParser::DecoratorListContext* myParser::decoratorList() {
  DecoratorListContext *_localctx = _tracker.createInstance<DecoratorListContext>(_ctx, getState());
  enterRule(_localctx, 110, myParser::RuleDecoratorList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(724); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(723);
              decorator();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(726); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DecoratorContext ------------------------------------------------------------------

myParser::DecoratorContext::DecoratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::DecoratorContext::At() {
  return getToken(myParser::At, 0);
}

myParser::DecoratorMemberExpressionContext* myParser::DecoratorContext::decoratorMemberExpression() {
  return getRuleContext<myParser::DecoratorMemberExpressionContext>(0);
}

myParser::DecoratorCallExpressionContext* myParser::DecoratorContext::decoratorCallExpression() {
  return getRuleContext<myParser::DecoratorCallExpressionContext>(0);
}


size_t myParser::DecoratorContext::getRuleIndex() const {
  return myParser::RuleDecorator;
}

void myParser::DecoratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecorator(this);
}

void myParser::DecoratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecorator(this);
}

myParser::DecoratorContext* myParser::decorator() {
  DecoratorContext *_localctx = _tracker.createInstance<DecoratorContext>(_ctx, getState());
  enterRule(_localctx, 112, myParser::RuleDecorator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(728);
    match(myParser::At);
    setState(731);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx)) {
    case 1: {
      setState(729);
      decoratorMemberExpression(0);
      break;
    }

    case 2: {
      setState(730);
      decoratorCallExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DecoratorMemberExpressionContext ------------------------------------------------------------------

myParser::DecoratorMemberExpressionContext::DecoratorMemberExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::DecoratorMemberExpressionContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

tree::TerminalNode* myParser::DecoratorMemberExpressionContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

myParser::SingleExpressionContext* myParser::DecoratorMemberExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::DecoratorMemberExpressionContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::DecoratorMemberExpressionContext* myParser::DecoratorMemberExpressionContext::decoratorMemberExpression() {
  return getRuleContext<myParser::DecoratorMemberExpressionContext>(0);
}

tree::TerminalNode* myParser::DecoratorMemberExpressionContext::Dot() {
  return getToken(myParser::Dot, 0);
}

myParser::IdentifierNameContext* myParser::DecoratorMemberExpressionContext::identifierName() {
  return getRuleContext<myParser::IdentifierNameContext>(0);
}


size_t myParser::DecoratorMemberExpressionContext::getRuleIndex() const {
  return myParser::RuleDecoratorMemberExpression;
}

void myParser::DecoratorMemberExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecoratorMemberExpression(this);
}

void myParser::DecoratorMemberExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecoratorMemberExpression(this);
}


myParser::DecoratorMemberExpressionContext* myParser::decoratorMemberExpression() {
   return decoratorMemberExpression(0);
}

myParser::DecoratorMemberExpressionContext* myParser::decoratorMemberExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  myParser::DecoratorMemberExpressionContext *_localctx = _tracker.createInstance<DecoratorMemberExpressionContext>(_ctx, parentState);
  myParser::DecoratorMemberExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 114;
  enterRecursionRule(_localctx, 114, myParser::RuleDecoratorMemberExpression, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(739);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Identifier: {
        setState(734);
        match(myParser::Identifier);
        break;
      }

      case myParser::OpenParen: {
        setState(735);
        match(myParser::OpenParen);
        setState(736);
        singleExpression(0);
        setState(737);
        match(myParser::CloseParen);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(746);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<DecoratorMemberExpressionContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleDecoratorMemberExpression);
        setState(741);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(742);
        match(myParser::Dot);
        setState(743);
        identifierName(); 
      }
      setState(748);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- DecoratorCallExpressionContext ------------------------------------------------------------------

myParser::DecoratorCallExpressionContext::DecoratorCallExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::DecoratorMemberExpressionContext* myParser::DecoratorCallExpressionContext::decoratorMemberExpression() {
  return getRuleContext<myParser::DecoratorMemberExpressionContext>(0);
}

myParser::ArgumentsContext* myParser::DecoratorCallExpressionContext::arguments() {
  return getRuleContext<myParser::ArgumentsContext>(0);
}


size_t myParser::DecoratorCallExpressionContext::getRuleIndex() const {
  return myParser::RuleDecoratorCallExpression;
}

void myParser::DecoratorCallExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecoratorCallExpression(this);
}

void myParser::DecoratorCallExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecoratorCallExpression(this);
}

myParser::DecoratorCallExpressionContext* myParser::decoratorCallExpression() {
  DecoratorCallExpressionContext *_localctx = _tracker.createInstance<DecoratorCallExpressionContext>(_ctx, getState());
  enterRule(_localctx, 116, myParser::RuleDecoratorCallExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(749);
    decoratorMemberExpression(0);
    setState(750);
    arguments();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProgramContext ------------------------------------------------------------------

myParser::ProgramContext::ProgramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ProgramContext::EOF() {
  return getToken(myParser::EOF, 0);
}

myParser::SourceElementsContext* myParser::ProgramContext::sourceElements() {
  return getRuleContext<myParser::SourceElementsContext>(0);
}


size_t myParser::ProgramContext::getRuleIndex() const {
  return myParser::RuleProgram;
}

void myParser::ProgramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProgram(this);
}

void myParser::ProgramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProgram(this);
}

myParser::ProgramContext* myParser::program() {
  ProgramContext *_localctx = _tracker.createInstance<ProgramContext>(_ctx, getState());
  enterRule(_localctx, 118, myParser::RuleProgram);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(753);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx)) {
    case 1: {
      setState(752);
      sourceElements();
      break;
    }

    default:
      break;
    }
    setState(755);
    match(myParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SourceElementContext ------------------------------------------------------------------

myParser::SourceElementContext::SourceElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::StatementContext* myParser::SourceElementContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}

tree::TerminalNode* myParser::SourceElementContext::Export() {
  return getToken(myParser::Export, 0);
}


size_t myParser::SourceElementContext::getRuleIndex() const {
  return myParser::RuleSourceElement;
}

void myParser::SourceElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSourceElement(this);
}

void myParser::SourceElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSourceElement(this);
}

myParser::SourceElementContext* myParser::sourceElement() {
  SourceElementContext *_localctx = _tracker.createInstance<SourceElementContext>(_ctx, getState());
  enterRule(_localctx, 120, myParser::RuleSourceElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(758);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx)) {
    case 1: {
      setState(757);
      match(myParser::Export);
      break;
    }

    default:
      break;
    }
    setState(760);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

myParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::BlockContext* myParser::StatementContext::block() {
  return getRuleContext<myParser::BlockContext>(0);
}

myParser::ImportStatementContext* myParser::StatementContext::importStatement() {
  return getRuleContext<myParser::ImportStatementContext>(0);
}

myParser::ExportStatementContext* myParser::StatementContext::exportStatement() {
  return getRuleContext<myParser::ExportStatementContext>(0);
}

myParser::EmptyStatement_Context* myParser::StatementContext::emptyStatement_() {
  return getRuleContext<myParser::EmptyStatement_Context>(0);
}

myParser::AbstractDeclarationContext* myParser::StatementContext::abstractDeclaration() {
  return getRuleContext<myParser::AbstractDeclarationContext>(0);
}

myParser::DecoratorListContext* myParser::StatementContext::decoratorList() {
  return getRuleContext<myParser::DecoratorListContext>(0);
}

myParser::ClassDeclarationContext* myParser::StatementContext::classDeclaration() {
  return getRuleContext<myParser::ClassDeclarationContext>(0);
}

myParser::InterfaceDeclarationContext* myParser::StatementContext::interfaceDeclaration() {
  return getRuleContext<myParser::InterfaceDeclarationContext>(0);
}

myParser::NamespaceDeclarationContext* myParser::StatementContext::namespaceDeclaration() {
  return getRuleContext<myParser::NamespaceDeclarationContext>(0);
}

myParser::IfStatementContext* myParser::StatementContext::ifStatement() {
  return getRuleContext<myParser::IfStatementContext>(0);
}

myParser::IterationStatementContext* myParser::StatementContext::iterationStatement() {
  return getRuleContext<myParser::IterationStatementContext>(0);
}

myParser::ContinueStatementContext* myParser::StatementContext::continueStatement() {
  return getRuleContext<myParser::ContinueStatementContext>(0);
}

myParser::BreakStatementContext* myParser::StatementContext::breakStatement() {
  return getRuleContext<myParser::BreakStatementContext>(0);
}

myParser::ReturnStatementContext* myParser::StatementContext::returnStatement() {
  return getRuleContext<myParser::ReturnStatementContext>(0);
}

myParser::YieldStatementContext* myParser::StatementContext::yieldStatement() {
  return getRuleContext<myParser::YieldStatementContext>(0);
}

myParser::WithStatementContext* myParser::StatementContext::withStatement() {
  return getRuleContext<myParser::WithStatementContext>(0);
}

myParser::LabelledStatementContext* myParser::StatementContext::labelledStatement() {
  return getRuleContext<myParser::LabelledStatementContext>(0);
}

myParser::SwitchStatementContext* myParser::StatementContext::switchStatement() {
  return getRuleContext<myParser::SwitchStatementContext>(0);
}

myParser::ThrowStatementContext* myParser::StatementContext::throwStatement() {
  return getRuleContext<myParser::ThrowStatementContext>(0);
}

myParser::TryStatementContext* myParser::StatementContext::tryStatement() {
  return getRuleContext<myParser::TryStatementContext>(0);
}

myParser::DebuggerStatementContext* myParser::StatementContext::debuggerStatement() {
  return getRuleContext<myParser::DebuggerStatementContext>(0);
}

myParser::FunctionDeclarationContext* myParser::StatementContext::functionDeclaration() {
  return getRuleContext<myParser::FunctionDeclarationContext>(0);
}

myParser::ArrowFunctionDeclarationContext* myParser::StatementContext::arrowFunctionDeclaration() {
  return getRuleContext<myParser::ArrowFunctionDeclarationContext>(0);
}

myParser::GeneratorFunctionDeclarationContext* myParser::StatementContext::generatorFunctionDeclaration() {
  return getRuleContext<myParser::GeneratorFunctionDeclarationContext>(0);
}

myParser::VariableStatementContext* myParser::StatementContext::variableStatement() {
  return getRuleContext<myParser::VariableStatementContext>(0);
}

myParser::TypeAliasDeclarationContext* myParser::StatementContext::typeAliasDeclaration() {
  return getRuleContext<myParser::TypeAliasDeclarationContext>(0);
}

myParser::EnumDeclarationContext* myParser::StatementContext::enumDeclaration() {
  return getRuleContext<myParser::EnumDeclarationContext>(0);
}

myParser::ExpressionStatementContext* myParser::StatementContext::expressionStatement() {
  return getRuleContext<myParser::ExpressionStatementContext>(0);
}

tree::TerminalNode* myParser::StatementContext::Export() {
  return getToken(myParser::Export, 0);
}

myParser::StatementContext* myParser::StatementContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}


size_t myParser::StatementContext::getRuleIndex() const {
  return myParser::RuleStatement;
}

void myParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void myParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}

myParser::StatementContext* myParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 122, myParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(792);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(762);
      block();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(763);
      importStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(764);
      exportStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(765);
      emptyStatement_();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(766);
      abstractDeclaration();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(767);
      decoratorList();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(768);
      classDeclaration();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(769);
      interfaceDeclaration();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(770);
      namespaceDeclaration();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(771);
      ifStatement();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(772);
      iterationStatement();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(773);
      continueStatement();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(774);
      breakStatement();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(775);
      returnStatement();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(776);
      yieldStatement();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(777);
      withStatement();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(778);
      labelledStatement();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(779);
      switchStatement();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(780);
      throwStatement();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(781);
      tryStatement();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(782);
      debuggerStatement();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(783);
      functionDeclaration();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(784);
      arrowFunctionDeclaration();
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(785);
      generatorFunctionDeclaration();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(786);
      variableStatement();
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(787);
      typeAliasDeclaration();
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(788);
      enumDeclaration();
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(789);
      expressionStatement();
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(790);
      match(myParser::Export);
      setState(791);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContext ------------------------------------------------------------------

myParser::BlockContext::BlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::BlockContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

tree::TerminalNode* myParser::BlockContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

myParser::StatementListContext* myParser::BlockContext::statementList() {
  return getRuleContext<myParser::StatementListContext>(0);
}


size_t myParser::BlockContext::getRuleIndex() const {
  return myParser::RuleBlock;
}

void myParser::BlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock(this);
}

void myParser::BlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock(this);
}

myParser::BlockContext* myParser::block() {
  BlockContext *_localctx = _tracker.createInstance<BlockContext>(_ctx, getState());
  enterRule(_localctx, 124, myParser::RuleBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(794);
    match(myParser::OpenBrace);
    setState(796);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx)) {
    case 1: {
      setState(795);
      statementList();
      break;
    }

    default:
      break;
    }
    setState(798);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementListContext ------------------------------------------------------------------

myParser::StatementListContext::StatementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::StatementContext *> myParser::StatementListContext::statement() {
  return getRuleContexts<myParser::StatementContext>();
}

myParser::StatementContext* myParser::StatementListContext::statement(size_t i) {
  return getRuleContext<myParser::StatementContext>(i);
}


size_t myParser::StatementListContext::getRuleIndex() const {
  return myParser::RuleStatementList;
}

void myParser::StatementListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatementList(this);
}

void myParser::StatementListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatementList(this);
}

myParser::StatementListContext* myParser::statementList() {
  StatementListContext *_localctx = _tracker.createInstance<StatementListContext>(_ctx, getState());
  enterRule(_localctx, 126, myParser::RuleStatementList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(801); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(800);
              statement();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(803); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AbstractDeclarationContext ------------------------------------------------------------------

myParser::AbstractDeclarationContext::AbstractDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::AbstractDeclarationContext::Abstract() {
  return getToken(myParser::Abstract, 0);
}

myParser::EosContext* myParser::AbstractDeclarationContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}

tree::TerminalNode* myParser::AbstractDeclarationContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

myParser::CallSignatureContext* myParser::AbstractDeclarationContext::callSignature() {
  return getRuleContext<myParser::CallSignatureContext>(0);
}

myParser::VariableStatementContext* myParser::AbstractDeclarationContext::variableStatement() {
  return getRuleContext<myParser::VariableStatementContext>(0);
}


size_t myParser::AbstractDeclarationContext::getRuleIndex() const {
  return myParser::RuleAbstractDeclaration;
}

void myParser::AbstractDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAbstractDeclaration(this);
}

void myParser::AbstractDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAbstractDeclaration(this);
}

myParser::AbstractDeclarationContext* myParser::abstractDeclaration() {
  AbstractDeclarationContext *_localctx = _tracker.createInstance<AbstractDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 128, myParser::RuleAbstractDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(805);
    match(myParser::Abstract);
    setState(809);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx)) {
    case 1: {
      setState(806);
      match(myParser::Identifier);
      setState(807);
      callSignature();
      break;
    }

    case 2: {
      setState(808);
      variableStatement();
      break;
    }

    default:
      break;
    }
    setState(811);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportStatementContext ------------------------------------------------------------------

myParser::ImportStatementContext::ImportStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ImportStatementContext::Import() {
  return getToken(myParser::Import, 0);
}

myParser::FromBlockContext* myParser::ImportStatementContext::fromBlock() {
  return getRuleContext<myParser::FromBlockContext>(0);
}

myParser::ImportAliasDeclarationContext* myParser::ImportStatementContext::importAliasDeclaration() {
  return getRuleContext<myParser::ImportAliasDeclarationContext>(0);
}


size_t myParser::ImportStatementContext::getRuleIndex() const {
  return myParser::RuleImportStatement;
}

void myParser::ImportStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportStatement(this);
}

void myParser::ImportStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportStatement(this);
}

myParser::ImportStatementContext* myParser::importStatement() {
  ImportStatementContext *_localctx = _tracker.createInstance<ImportStatementContext>(_ctx, getState());
  enterRule(_localctx, 130, myParser::RuleImportStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(813);
    match(myParser::Import);
    setState(816);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx)) {
    case 1: {
      setState(814);
      fromBlock();
      break;
    }

    case 2: {
      setState(815);
      importAliasDeclaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromBlockContext ------------------------------------------------------------------

myParser::FromBlockContext::FromBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::FromBlockContext::From() {
  return getToken(myParser::From, 0);
}

tree::TerminalNode* myParser::FromBlockContext::StringLiteral() {
  return getToken(myParser::StringLiteral, 0);
}

myParser::EosContext* myParser::FromBlockContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}

tree::TerminalNode* myParser::FromBlockContext::Multiply() {
  return getToken(myParser::Multiply, 0);
}

myParser::MultipleImportStatementContext* myParser::FromBlockContext::multipleImportStatement() {
  return getRuleContext<myParser::MultipleImportStatementContext>(0);
}

tree::TerminalNode* myParser::FromBlockContext::As() {
  return getToken(myParser::As, 0);
}

myParser::IdentifierNameContext* myParser::FromBlockContext::identifierName() {
  return getRuleContext<myParser::IdentifierNameContext>(0);
}


size_t myParser::FromBlockContext::getRuleIndex() const {
  return myParser::RuleFromBlock;
}

void myParser::FromBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromBlock(this);
}

void myParser::FromBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromBlock(this);
}

myParser::FromBlockContext* myParser::fromBlock() {
  FromBlockContext *_localctx = _tracker.createInstance<FromBlockContext>(_ctx, getState());
  enterRule(_localctx, 132, myParser::RuleFromBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(820);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Multiply: {
        setState(818);
        match(myParser::Multiply);
        break;
      }

      case myParser::OpenBrace:
      case myParser::NullLiteral:
      case myParser::BooleanLiteral:
      case myParser::Break:
      case myParser::Do:
      case myParser::Instanceof:
      case myParser::Typeof:
      case myParser::Case:
      case myParser::Else:
      case myParser::New:
      case myParser::Var:
      case myParser::Catch:
      case myParser::Finally:
      case myParser::Return:
      case myParser::Void:
      case myParser::Continue:
      case myParser::For:
      case myParser::Switch:
      case myParser::While:
      case myParser::Debugger:
      case myParser::Function_:
      case myParser::This:
      case myParser::With:
      case myParser::Default:
      case myParser::If:
      case myParser::Throw:
      case myParser::Delete:
      case myParser::In:
      case myParser::Try:
      case myParser::From:
      case myParser::ReadOnly:
      case myParser::Async:
      case myParser::Class:
      case myParser::Enum:
      case myParser::Extends:
      case myParser::Super:
      case myParser::Const:
      case myParser::Export:
      case myParser::Import:
      case myParser::Implements:
      case myParser::Let:
      case myParser::Private:
      case myParser::Public:
      case myParser::Interface:
      case myParser::Package:
      case myParser::Protected:
      case myParser::Static:
      case myParser::Yield:
      case myParser::String:
      case myParser::TypeAlias:
      case myParser::Get:
      case myParser::Set:
      case myParser::Require:
      case myParser::Identifier: {
        setState(819);
        multipleImportStatement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(824);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::As) {
      setState(822);
      match(myParser::As);
      setState(823);
      identifierName();
    }
    setState(826);
    match(myParser::From);
    setState(827);
    match(myParser::StringLiteral);
    setState(828);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultipleImportStatementContext ------------------------------------------------------------------

myParser::MultipleImportStatementContext::MultipleImportStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::MultipleImportStatementContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

std::vector<myParser::IdentifierNameContext *> myParser::MultipleImportStatementContext::identifierName() {
  return getRuleContexts<myParser::IdentifierNameContext>();
}

myParser::IdentifierNameContext* myParser::MultipleImportStatementContext::identifierName(size_t i) {
  return getRuleContext<myParser::IdentifierNameContext>(i);
}

tree::TerminalNode* myParser::MultipleImportStatementContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

std::vector<tree::TerminalNode *> myParser::MultipleImportStatementContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::MultipleImportStatementContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::MultipleImportStatementContext::getRuleIndex() const {
  return myParser::RuleMultipleImportStatement;
}

void myParser::MultipleImportStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultipleImportStatement(this);
}

void myParser::MultipleImportStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultipleImportStatement(this);
}

myParser::MultipleImportStatementContext* myParser::multipleImportStatement() {
  MultipleImportStatementContext *_localctx = _tracker.createInstance<MultipleImportStatementContext>(_ctx, getState());
  enterRule(_localctx, 134, myParser::RuleMultipleImportStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(833);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4503599627370496000) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1175034882447900671) != 0)) {
      setState(830);
      identifierName();
      setState(831);
      match(myParser::Comma);
    }
    setState(835);
    match(myParser::OpenBrace);
    setState(836);
    identifierName();
    setState(841);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::Comma) {
      setState(837);
      match(myParser::Comma);
      setState(838);
      identifierName();
      setState(843);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(844);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExportStatementContext ------------------------------------------------------------------

myParser::ExportStatementContext::ExportStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ExportStatementContext::Export() {
  return getToken(myParser::Export, 0);
}

myParser::FromBlockContext* myParser::ExportStatementContext::fromBlock() {
  return getRuleContext<myParser::FromBlockContext>(0);
}

myParser::StatementContext* myParser::ExportStatementContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}

tree::TerminalNode* myParser::ExportStatementContext::Default() {
  return getToken(myParser::Default, 0);
}


size_t myParser::ExportStatementContext::getRuleIndex() const {
  return myParser::RuleExportStatement;
}

void myParser::ExportStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExportStatement(this);
}

void myParser::ExportStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExportStatement(this);
}

myParser::ExportStatementContext* myParser::exportStatement() {
  ExportStatementContext *_localctx = _tracker.createInstance<ExportStatementContext>(_ctx, getState());
  enterRule(_localctx, 136, myParser::RuleExportStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(846);
    match(myParser::Export);
    setState(848);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx)) {
    case 1: {
      setState(847);
      match(myParser::Default);
      break;
    }

    default:
      break;
    }
    setState(852);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx)) {
    case 1: {
      setState(850);
      fromBlock();
      break;
    }

    case 2: {
      setState(851);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableStatementContext ------------------------------------------------------------------

myParser::VariableStatementContext::VariableStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::BindingPatternContext* myParser::VariableStatementContext::bindingPattern() {
  return getRuleContext<myParser::BindingPatternContext>(0);
}

myParser::InitializerContext* myParser::VariableStatementContext::initializer() {
  return getRuleContext<myParser::InitializerContext>(0);
}

myParser::TypeAnnotationContext* myParser::VariableStatementContext::typeAnnotation() {
  return getRuleContext<myParser::TypeAnnotationContext>(0);
}

tree::TerminalNode* myParser::VariableStatementContext::SemiColon() {
  return getToken(myParser::SemiColon, 0);
}

myParser::VariableDeclarationListContext* myParser::VariableStatementContext::variableDeclarationList() {
  return getRuleContext<myParser::VariableDeclarationListContext>(0);
}

myParser::AccessibilityModifierContext* myParser::VariableStatementContext::accessibilityModifier() {
  return getRuleContext<myParser::AccessibilityModifierContext>(0);
}

myParser::VarModifierContext* myParser::VariableStatementContext::varModifier() {
  return getRuleContext<myParser::VarModifierContext>(0);
}

tree::TerminalNode* myParser::VariableStatementContext::ReadOnly() {
  return getToken(myParser::ReadOnly, 0);
}

tree::TerminalNode* myParser::VariableStatementContext::Declare() {
  return getToken(myParser::Declare, 0);
}


size_t myParser::VariableStatementContext::getRuleIndex() const {
  return myParser::RuleVariableStatement;
}

void myParser::VariableStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableStatement(this);
}

void myParser::VariableStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableStatement(this);
}

myParser::VariableStatementContext* myParser::variableStatement() {
  VariableStatementContext *_localctx = _tracker.createInstance<VariableStatementContext>(_ctx, getState());
  enterRule(_localctx, 138, myParser::RuleVariableStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(883);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(854);
      bindingPattern();
      setState(856);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::Colon) {
        setState(855);
        typeAnnotation();
      }
      setState(858);
      initializer();
      setState(860);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx)) {
      case 1: {
        setState(859);
        match(myParser::SemiColon);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(863);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 101) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 101)) & 19) != 0)) {
        setState(862);
        accessibilityModifier();
      }
      setState(866);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 69) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 69)) & 2281701377) != 0)) {
        setState(865);
        varModifier();
      }
      setState(869);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::ReadOnly) {
        setState(868);
        match(myParser::ReadOnly);
      }
      setState(871);
      variableDeclarationList();
      setState(873);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx)) {
      case 1: {
        setState(872);
        match(myParser::SemiColon);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(875);
      match(myParser::Declare);
      setState(877);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 69) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 69)) & 2281701377) != 0)) {
        setState(876);
        varModifier();
      }
      setState(879);
      variableDeclarationList();
      setState(881);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 96, _ctx)) {
      case 1: {
        setState(880);
        match(myParser::SemiColon);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationListContext ------------------------------------------------------------------

myParser::VariableDeclarationListContext::VariableDeclarationListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::VariableDeclarationContext *> myParser::VariableDeclarationListContext::variableDeclaration() {
  return getRuleContexts<myParser::VariableDeclarationContext>();
}

myParser::VariableDeclarationContext* myParser::VariableDeclarationListContext::variableDeclaration(size_t i) {
  return getRuleContext<myParser::VariableDeclarationContext>(i);
}

std::vector<tree::TerminalNode *> myParser::VariableDeclarationListContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::VariableDeclarationListContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::VariableDeclarationListContext::getRuleIndex() const {
  return myParser::RuleVariableDeclarationList;
}

void myParser::VariableDeclarationListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclarationList(this);
}

void myParser::VariableDeclarationListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclarationList(this);
}

myParser::VariableDeclarationListContext* myParser::variableDeclarationList() {
  VariableDeclarationListContext *_localctx = _tracker.createInstance<VariableDeclarationListContext>(_ctx, getState());
  enterRule(_localctx, 140, myParser::RuleVariableDeclarationList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(885);
    variableDeclaration();
    setState(890);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(886);
        match(myParser::Comma);
        setState(887);
        variableDeclaration(); 
      }
      setState(892);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationContext ------------------------------------------------------------------

myParser::VariableDeclarationContext::VariableDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierOrKeyWordContext* myParser::VariableDeclarationContext::identifierOrKeyWord() {
  return getRuleContext<myParser::IdentifierOrKeyWordContext>(0);
}

myParser::ArrayLiteralContext* myParser::VariableDeclarationContext::arrayLiteral() {
  return getRuleContext<myParser::ArrayLiteralContext>(0);
}

myParser::ObjectLiteralContext* myParser::VariableDeclarationContext::objectLiteral() {
  return getRuleContext<myParser::ObjectLiteralContext>(0);
}

myParser::TypeAnnotationContext* myParser::VariableDeclarationContext::typeAnnotation() {
  return getRuleContext<myParser::TypeAnnotationContext>(0);
}

std::vector<myParser::SingleExpressionContext *> myParser::VariableDeclarationContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::VariableDeclarationContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::VariableDeclarationContext::Assign() {
  return getToken(myParser::Assign, 0);
}

myParser::TypeParametersContext* myParser::VariableDeclarationContext::typeParameters() {
  return getRuleContext<myParser::TypeParametersContext>(0);
}


size_t myParser::VariableDeclarationContext::getRuleIndex() const {
  return myParser::RuleVariableDeclaration;
}

void myParser::VariableDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclaration(this);
}

void myParser::VariableDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclaration(this);
}

myParser::VariableDeclarationContext* myParser::variableDeclaration() {
  VariableDeclarationContext *_localctx = _tracker.createInstance<VariableDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 142, myParser::RuleVariableDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(896);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::TypeAlias:
      case myParser::Require:
      case myParser::Identifier: {
        setState(893);
        identifierOrKeyWord();
        break;
      }

      case myParser::OpenBracket: {
        setState(894);
        arrayLiteral();
        break;
      }

      case myParser::OpenBrace: {
        setState(895);
        objectLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(899);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx)) {
    case 1: {
      setState(898);
      typeAnnotation();
      break;
    }

    default:
      break;
    }
    setState(902);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx)) {
    case 1: {
      setState(901);
      singleExpression(0);
      break;
    }

    default:
      break;
    }
    setState(909);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, _ctx)) {
    case 1: {
      setState(904);
      match(myParser::Assign);
      setState(906);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx)) {
      case 1: {
        setState(905);
        typeParameters();
        break;
      }

      default:
        break;
      }
      setState(908);
      singleExpression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmptyStatement_Context ------------------------------------------------------------------

myParser::EmptyStatement_Context::EmptyStatement_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::EmptyStatement_Context::SemiColon() {
  return getToken(myParser::SemiColon, 0);
}


size_t myParser::EmptyStatement_Context::getRuleIndex() const {
  return myParser::RuleEmptyStatement_;
}

void myParser::EmptyStatement_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmptyStatement_(this);
}

void myParser::EmptyStatement_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmptyStatement_(this);
}

myParser::EmptyStatement_Context* myParser::emptyStatement_() {
  EmptyStatement_Context *_localctx = _tracker.createInstance<EmptyStatement_Context>(_ctx, getState());
  enterRule(_localctx, 144, myParser::RuleEmptyStatement_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(911);
    match(myParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionStatementContext ------------------------------------------------------------------

myParser::ExpressionStatementContext::ExpressionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ExpressionSequenceContext* myParser::ExpressionStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::ExpressionStatementContext::SemiColon() {
  return getToken(myParser::SemiColon, 0);
}


size_t myParser::ExpressionStatementContext::getRuleIndex() const {
  return myParser::RuleExpressionStatement;
}

void myParser::ExpressionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionStatement(this);
}

void myParser::ExpressionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionStatement(this);
}

myParser::ExpressionStatementContext* myParser::expressionStatement() {
  ExpressionStatementContext *_localctx = _tracker.createInstance<ExpressionStatementContext>(_ctx, getState());
  enterRule(_localctx, 146, myParser::RuleExpressionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(913);

    if (!(this.notOpenBraceAndNotFunction())) throw FailedPredicateException(this, "this.notOpenBraceAndNotFunction()");
    setState(914);
    expressionSequence();
    setState(916);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 104, _ctx)) {
    case 1: {
      setState(915);
      match(myParser::SemiColon);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStatementContext ------------------------------------------------------------------

myParser::IfStatementContext::IfStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::IfStatementContext::If() {
  return getToken(myParser::If, 0);
}

tree::TerminalNode* myParser::IfStatementContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

myParser::ExpressionSequenceContext* myParser::IfStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::IfStatementContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

std::vector<myParser::StatementContext *> myParser::IfStatementContext::statement() {
  return getRuleContexts<myParser::StatementContext>();
}

myParser::StatementContext* myParser::IfStatementContext::statement(size_t i) {
  return getRuleContext<myParser::StatementContext>(i);
}

tree::TerminalNode* myParser::IfStatementContext::Else() {
  return getToken(myParser::Else, 0);
}


size_t myParser::IfStatementContext::getRuleIndex() const {
  return myParser::RuleIfStatement;
}

void myParser::IfStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfStatement(this);
}

void myParser::IfStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfStatement(this);
}

myParser::IfStatementContext* myParser::ifStatement() {
  IfStatementContext *_localctx = _tracker.createInstance<IfStatementContext>(_ctx, getState());
  enterRule(_localctx, 148, myParser::RuleIfStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(918);
    match(myParser::If);
    setState(919);
    match(myParser::OpenParen);
    setState(920);
    expressionSequence();
    setState(921);
    match(myParser::CloseParen);
    setState(922);
    statement();
    setState(925);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 105, _ctx)) {
    case 1: {
      setState(923);
      match(myParser::Else);
      setState(924);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IterationStatementContext ------------------------------------------------------------------

myParser::IterationStatementContext::IterationStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t myParser::IterationStatementContext::getRuleIndex() const {
  return myParser::RuleIterationStatement;
}

void myParser::IterationStatementContext::copyFrom(IterationStatementContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- DoStatementContext ------------------------------------------------------------------

tree::TerminalNode* myParser::DoStatementContext::Do() {
  return getToken(myParser::Do, 0);
}

myParser::StatementContext* myParser::DoStatementContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}

tree::TerminalNode* myParser::DoStatementContext::While() {
  return getToken(myParser::While, 0);
}

tree::TerminalNode* myParser::DoStatementContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

myParser::ExpressionSequenceContext* myParser::DoStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::DoStatementContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::EosContext* myParser::DoStatementContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}

myParser::DoStatementContext::DoStatementContext(IterationStatementContext *ctx) { copyFrom(ctx); }

void myParser::DoStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoStatement(this);
}
void myParser::DoStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoStatement(this);
}
//----------------- ForVarStatementContext ------------------------------------------------------------------

tree::TerminalNode* myParser::ForVarStatementContext::For() {
  return getToken(myParser::For, 0);
}

tree::TerminalNode* myParser::ForVarStatementContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

myParser::VarModifierContext* myParser::ForVarStatementContext::varModifier() {
  return getRuleContext<myParser::VarModifierContext>(0);
}

myParser::VariableDeclarationListContext* myParser::ForVarStatementContext::variableDeclarationList() {
  return getRuleContext<myParser::VariableDeclarationListContext>(0);
}

std::vector<tree::TerminalNode *> myParser::ForVarStatementContext::SemiColon() {
  return getTokens(myParser::SemiColon);
}

tree::TerminalNode* myParser::ForVarStatementContext::SemiColon(size_t i) {
  return getToken(myParser::SemiColon, i);
}

tree::TerminalNode* myParser::ForVarStatementContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::StatementContext* myParser::ForVarStatementContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}

std::vector<myParser::ExpressionSequenceContext *> myParser::ForVarStatementContext::expressionSequence() {
  return getRuleContexts<myParser::ExpressionSequenceContext>();
}

myParser::ExpressionSequenceContext* myParser::ForVarStatementContext::expressionSequence(size_t i) {
  return getRuleContext<myParser::ExpressionSequenceContext>(i);
}

myParser::ForVarStatementContext::ForVarStatementContext(IterationStatementContext *ctx) { copyFrom(ctx); }

void myParser::ForVarStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForVarStatement(this);
}
void myParser::ForVarStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForVarStatement(this);
}
//----------------- ForVarInStatementContext ------------------------------------------------------------------

tree::TerminalNode* myParser::ForVarInStatementContext::For() {
  return getToken(myParser::For, 0);
}

tree::TerminalNode* myParser::ForVarInStatementContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

myParser::VarModifierContext* myParser::ForVarInStatementContext::varModifier() {
  return getRuleContext<myParser::VarModifierContext>(0);
}

myParser::VariableDeclarationContext* myParser::ForVarInStatementContext::variableDeclaration() {
  return getRuleContext<myParser::VariableDeclarationContext>(0);
}

myParser::ExpressionSequenceContext* myParser::ForVarInStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::ForVarInStatementContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::StatementContext* myParser::ForVarInStatementContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}

tree::TerminalNode* myParser::ForVarInStatementContext::In() {
  return getToken(myParser::In, 0);
}

tree::TerminalNode* myParser::ForVarInStatementContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

myParser::ForVarInStatementContext::ForVarInStatementContext(IterationStatementContext *ctx) { copyFrom(ctx); }

void myParser::ForVarInStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForVarInStatement(this);
}
void myParser::ForVarInStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForVarInStatement(this);
}
//----------------- WhileStatementContext ------------------------------------------------------------------

tree::TerminalNode* myParser::WhileStatementContext::While() {
  return getToken(myParser::While, 0);
}

tree::TerminalNode* myParser::WhileStatementContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

myParser::ExpressionSequenceContext* myParser::WhileStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::WhileStatementContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::StatementContext* myParser::WhileStatementContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}

myParser::WhileStatementContext::WhileStatementContext(IterationStatementContext *ctx) { copyFrom(ctx); }

void myParser::WhileStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhileStatement(this);
}
void myParser::WhileStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhileStatement(this);
}
//----------------- ForStatementContext ------------------------------------------------------------------

tree::TerminalNode* myParser::ForStatementContext::For() {
  return getToken(myParser::For, 0);
}

tree::TerminalNode* myParser::ForStatementContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

std::vector<tree::TerminalNode *> myParser::ForStatementContext::SemiColon() {
  return getTokens(myParser::SemiColon);
}

tree::TerminalNode* myParser::ForStatementContext::SemiColon(size_t i) {
  return getToken(myParser::SemiColon, i);
}

tree::TerminalNode* myParser::ForStatementContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::StatementContext* myParser::ForStatementContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}

std::vector<myParser::ExpressionSequenceContext *> myParser::ForStatementContext::expressionSequence() {
  return getRuleContexts<myParser::ExpressionSequenceContext>();
}

myParser::ExpressionSequenceContext* myParser::ForStatementContext::expressionSequence(size_t i) {
  return getRuleContext<myParser::ExpressionSequenceContext>(i);
}

myParser::ForStatementContext::ForStatementContext(IterationStatementContext *ctx) { copyFrom(ctx); }

void myParser::ForStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForStatement(this);
}
void myParser::ForStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForStatement(this);
}
//----------------- ForInStatementContext ------------------------------------------------------------------

tree::TerminalNode* myParser::ForInStatementContext::For() {
  return getToken(myParser::For, 0);
}

tree::TerminalNode* myParser::ForInStatementContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

myParser::SingleExpressionContext* myParser::ForInStatementContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::ExpressionSequenceContext* myParser::ForInStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::ForInStatementContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::StatementContext* myParser::ForInStatementContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}

tree::TerminalNode* myParser::ForInStatementContext::In() {
  return getToken(myParser::In, 0);
}

tree::TerminalNode* myParser::ForInStatementContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

myParser::ForInStatementContext::ForInStatementContext(IterationStatementContext *ctx) { copyFrom(ctx); }

void myParser::ForInStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForInStatement(this);
}
void myParser::ForInStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForInStatement(this);
}
myParser::IterationStatementContext* myParser::iterationStatement() {
  IterationStatementContext *_localctx = _tracker.createInstance<IterationStatementContext>(_ctx, getState());
  enterRule(_localctx, 150, myParser::RuleIterationStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(996);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<myParser::DoStatementContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(927);
      match(myParser::Do);
      setState(928);
      statement();
      setState(929);
      match(myParser::While);
      setState(930);
      match(myParser::OpenParen);
      setState(931);
      expressionSequence();
      setState(932);
      match(myParser::CloseParen);
      setState(933);
      eos();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<myParser::WhileStatementContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(935);
      match(myParser::While);
      setState(936);
      match(myParser::OpenParen);
      setState(937);
      expressionSequence();
      setState(938);
      match(myParser::CloseParen);
      setState(939);
      statement();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<myParser::ForStatementContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(941);
      match(myParser::For);
      setState(942);
      match(myParser::OpenParen);
      setState(944);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -36028795928706728) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 8092563910088982527) != 0)) {
        setState(943);
        expressionSequence();
      }
      setState(946);
      match(myParser::SemiColon);
      setState(948);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -36028795928706728) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 8092563910088982527) != 0)) {
        setState(947);
        expressionSequence();
      }
      setState(950);
      match(myParser::SemiColon);
      setState(952);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -36028795928706728) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 8092563910088982527) != 0)) {
        setState(951);
        expressionSequence();
      }
      setState(954);
      match(myParser::CloseParen);
      setState(955);
      statement();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<myParser::ForVarStatementContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(956);
      match(myParser::For);
      setState(957);
      match(myParser::OpenParen);
      setState(958);
      varModifier();
      setState(959);
      variableDeclarationList();
      setState(960);
      match(myParser::SemiColon);
      setState(962);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -36028795928706728) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 8092563910088982527) != 0)) {
        setState(961);
        expressionSequence();
      }
      setState(964);
      match(myParser::SemiColon);
      setState(966);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -36028795928706728) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 8092563910088982527) != 0)) {
        setState(965);
        expressionSequence();
      }
      setState(968);
      match(myParser::CloseParen);
      setState(969);
      statement();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<myParser::ForInStatementContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(971);
      match(myParser::For);
      setState(972);
      match(myParser::OpenParen);
      setState(973);
      singleExpression(0);
      setState(977);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case myParser::In: {
          setState(974);
          match(myParser::In);
          break;
        }

        case myParser::Identifier: {
          setState(975);
          match(myParser::Identifier);
          setState(976);

          if (!(this.p("of"))) throw FailedPredicateException(this, "this.p(\"of\")");
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(979);
      expressionSequence();
      setState(980);
      match(myParser::CloseParen);
      setState(981);
      statement();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<myParser::ForVarInStatementContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(983);
      match(myParser::For);
      setState(984);
      match(myParser::OpenParen);
      setState(985);
      varModifier();
      setState(986);
      variableDeclaration();
      setState(990);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case myParser::In: {
          setState(987);
          match(myParser::In);
          break;
        }

        case myParser::Identifier: {
          setState(988);
          match(myParser::Identifier);
          setState(989);

          if (!(this.p("of"))) throw FailedPredicateException(this, "this.p(\"of\")");
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(992);
      expressionSequence();
      setState(993);
      match(myParser::CloseParen);
      setState(994);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarModifierContext ------------------------------------------------------------------

myParser::VarModifierContext::VarModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::VarModifierContext::Var() {
  return getToken(myParser::Var, 0);
}

tree::TerminalNode* myParser::VarModifierContext::Let() {
  return getToken(myParser::Let, 0);
}

tree::TerminalNode* myParser::VarModifierContext::Const() {
  return getToken(myParser::Const, 0);
}


size_t myParser::VarModifierContext::getRuleIndex() const {
  return myParser::RuleVarModifier;
}

void myParser::VarModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarModifier(this);
}

void myParser::VarModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarModifier(this);
}

myParser::VarModifierContext* myParser::varModifier() {
  VarModifierContext *_localctx = _tracker.createInstance<VarModifierContext>(_ctx, getState());
  enterRule(_localctx, 152, myParser::RuleVarModifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(998);
    _la = _input->LA(1);
    if (!(((((_la - 69) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 69)) & 2281701377) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ContinueStatementContext ------------------------------------------------------------------

myParser::ContinueStatementContext::ContinueStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ContinueStatementContext::Continue() {
  return getToken(myParser::Continue, 0);
}

myParser::EosContext* myParser::ContinueStatementContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}

tree::TerminalNode* myParser::ContinueStatementContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}


size_t myParser::ContinueStatementContext::getRuleIndex() const {
  return myParser::RuleContinueStatement;
}

void myParser::ContinueStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContinueStatement(this);
}

void myParser::ContinueStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContinueStatement(this);
}

myParser::ContinueStatementContext* myParser::continueStatement() {
  ContinueStatementContext *_localctx = _tracker.createInstance<ContinueStatementContext>(_ctx, getState());
  enterRule(_localctx, 154, myParser::RuleContinueStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1000);
    match(myParser::Continue);
    setState(1003);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx)) {
    case 1: {
      setState(1001);

      if (!(this.notLineTerminator())) throw FailedPredicateException(this, "this.notLineTerminator()");
      setState(1002);
      match(myParser::Identifier);
      break;
    }

    default:
      break;
    }
    setState(1005);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BreakStatementContext ------------------------------------------------------------------

myParser::BreakStatementContext::BreakStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::BreakStatementContext::Break() {
  return getToken(myParser::Break, 0);
}

myParser::EosContext* myParser::BreakStatementContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}

tree::TerminalNode* myParser::BreakStatementContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}


size_t myParser::BreakStatementContext::getRuleIndex() const {
  return myParser::RuleBreakStatement;
}

void myParser::BreakStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBreakStatement(this);
}

void myParser::BreakStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBreakStatement(this);
}

myParser::BreakStatementContext* myParser::breakStatement() {
  BreakStatementContext *_localctx = _tracker.createInstance<BreakStatementContext>(_ctx, getState());
  enterRule(_localctx, 156, myParser::RuleBreakStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1007);
    match(myParser::Break);
    setState(1010);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx)) {
    case 1: {
      setState(1008);

      if (!(this.notLineTerminator())) throw FailedPredicateException(this, "this.notLineTerminator()");
      setState(1009);
      match(myParser::Identifier);
      break;
    }

    default:
      break;
    }
    setState(1012);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnStatementContext ------------------------------------------------------------------

myParser::ReturnStatementContext::ReturnStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ReturnStatementContext::Return() {
  return getToken(myParser::Return, 0);
}

myParser::EosContext* myParser::ReturnStatementContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}

myParser::ExpressionSequenceContext* myParser::ReturnStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}


size_t myParser::ReturnStatementContext::getRuleIndex() const {
  return myParser::RuleReturnStatement;
}

void myParser::ReturnStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnStatement(this);
}

void myParser::ReturnStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnStatement(this);
}

myParser::ReturnStatementContext* myParser::returnStatement() {
  ReturnStatementContext *_localctx = _tracker.createInstance<ReturnStatementContext>(_ctx, getState());
  enterRule(_localctx, 158, myParser::RuleReturnStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1014);
    match(myParser::Return);
    setState(1017);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx)) {
    case 1: {
      setState(1015);

      if (!(this.notLineTerminator())) throw FailedPredicateException(this, "this.notLineTerminator()");
      setState(1016);
      expressionSequence();
      break;
    }

    default:
      break;
    }
    setState(1019);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- YieldStatementContext ------------------------------------------------------------------

myParser::YieldStatementContext::YieldStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::YieldStatementContext::Yield() {
  return getToken(myParser::Yield, 0);
}

myParser::EosContext* myParser::YieldStatementContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}

myParser::ExpressionSequenceContext* myParser::YieldStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}


size_t myParser::YieldStatementContext::getRuleIndex() const {
  return myParser::RuleYieldStatement;
}

void myParser::YieldStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterYieldStatement(this);
}

void myParser::YieldStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitYieldStatement(this);
}

myParser::YieldStatementContext* myParser::yieldStatement() {
  YieldStatementContext *_localctx = _tracker.createInstance<YieldStatementContext>(_ctx, getState());
  enterRule(_localctx, 160, myParser::RuleYieldStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1021);
    match(myParser::Yield);
    setState(1024);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx)) {
    case 1: {
      setState(1022);

      if (!(this.notLineTerminator())) throw FailedPredicateException(this, "this.notLineTerminator()");
      setState(1023);
      expressionSequence();
      break;
    }

    default:
      break;
    }
    setState(1026);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WithStatementContext ------------------------------------------------------------------

myParser::WithStatementContext::WithStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::WithStatementContext::With() {
  return getToken(myParser::With, 0);
}

tree::TerminalNode* myParser::WithStatementContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

myParser::ExpressionSequenceContext* myParser::WithStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::WithStatementContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::StatementContext* myParser::WithStatementContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}


size_t myParser::WithStatementContext::getRuleIndex() const {
  return myParser::RuleWithStatement;
}

void myParser::WithStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWithStatement(this);
}

void myParser::WithStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWithStatement(this);
}

myParser::WithStatementContext* myParser::withStatement() {
  WithStatementContext *_localctx = _tracker.createInstance<WithStatementContext>(_ctx, getState());
  enterRule(_localctx, 162, myParser::RuleWithStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1028);
    match(myParser::With);
    setState(1029);
    match(myParser::OpenParen);
    setState(1030);
    expressionSequence();
    setState(1031);
    match(myParser::CloseParen);
    setState(1032);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SwitchStatementContext ------------------------------------------------------------------

myParser::SwitchStatementContext::SwitchStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::SwitchStatementContext::Switch() {
  return getToken(myParser::Switch, 0);
}

tree::TerminalNode* myParser::SwitchStatementContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

myParser::ExpressionSequenceContext* myParser::SwitchStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::SwitchStatementContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::CaseBlockContext* myParser::SwitchStatementContext::caseBlock() {
  return getRuleContext<myParser::CaseBlockContext>(0);
}


size_t myParser::SwitchStatementContext::getRuleIndex() const {
  return myParser::RuleSwitchStatement;
}

void myParser::SwitchStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitchStatement(this);
}

void myParser::SwitchStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitchStatement(this);
}

myParser::SwitchStatementContext* myParser::switchStatement() {
  SwitchStatementContext *_localctx = _tracker.createInstance<SwitchStatementContext>(_ctx, getState());
  enterRule(_localctx, 164, myParser::RuleSwitchStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1034);
    match(myParser::Switch);
    setState(1035);
    match(myParser::OpenParen);
    setState(1036);
    expressionSequence();
    setState(1037);
    match(myParser::CloseParen);
    setState(1038);
    caseBlock();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseBlockContext ------------------------------------------------------------------

myParser::CaseBlockContext::CaseBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::CaseBlockContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

tree::TerminalNode* myParser::CaseBlockContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

std::vector<myParser::CaseClausesContext *> myParser::CaseBlockContext::caseClauses() {
  return getRuleContexts<myParser::CaseClausesContext>();
}

myParser::CaseClausesContext* myParser::CaseBlockContext::caseClauses(size_t i) {
  return getRuleContext<myParser::CaseClausesContext>(i);
}

myParser::DefaultClauseContext* myParser::CaseBlockContext::defaultClause() {
  return getRuleContext<myParser::DefaultClauseContext>(0);
}


size_t myParser::CaseBlockContext::getRuleIndex() const {
  return myParser::RuleCaseBlock;
}

void myParser::CaseBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseBlock(this);
}

void myParser::CaseBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseBlock(this);
}

myParser::CaseBlockContext* myParser::caseBlock() {
  CaseBlockContext *_localctx = _tracker.createInstance<CaseBlockContext>(_ctx, getState());
  enterRule(_localctx, 166, myParser::RuleCaseBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1040);
    match(myParser::OpenBrace);
    setState(1042);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Case) {
      setState(1041);
      caseClauses();
    }
    setState(1048);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Default) {
      setState(1044);
      defaultClause();
      setState(1046);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::Case) {
        setState(1045);
        caseClauses();
      }
    }
    setState(1050);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseClausesContext ------------------------------------------------------------------

myParser::CaseClausesContext::CaseClausesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::CaseClauseContext *> myParser::CaseClausesContext::caseClause() {
  return getRuleContexts<myParser::CaseClauseContext>();
}

myParser::CaseClauseContext* myParser::CaseClausesContext::caseClause(size_t i) {
  return getRuleContext<myParser::CaseClauseContext>(i);
}


size_t myParser::CaseClausesContext::getRuleIndex() const {
  return myParser::RuleCaseClauses;
}

void myParser::CaseClausesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseClauses(this);
}

void myParser::CaseClausesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseClauses(this);
}

myParser::CaseClausesContext* myParser::caseClauses() {
  CaseClausesContext *_localctx = _tracker.createInstance<CaseClausesContext>(_ctx, getState());
  enterRule(_localctx, 168, myParser::RuleCaseClauses);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1053); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1052);
      caseClause();
      setState(1055); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == myParser::Case);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseClauseContext ------------------------------------------------------------------

myParser::CaseClauseContext::CaseClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::CaseClauseContext::Case() {
  return getToken(myParser::Case, 0);
}

myParser::ExpressionSequenceContext* myParser::CaseClauseContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::CaseClauseContext::Colon() {
  return getToken(myParser::Colon, 0);
}

myParser::StatementListContext* myParser::CaseClauseContext::statementList() {
  return getRuleContext<myParser::StatementListContext>(0);
}


size_t myParser::CaseClauseContext::getRuleIndex() const {
  return myParser::RuleCaseClause;
}

void myParser::CaseClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseClause(this);
}

void myParser::CaseClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseClause(this);
}

myParser::CaseClauseContext* myParser::caseClause() {
  CaseClauseContext *_localctx = _tracker.createInstance<CaseClauseContext>(_ctx, getState());
  enterRule(_localctx, 170, myParser::RuleCaseClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1057);
    match(myParser::Case);
    setState(1058);
    expressionSequence();
    setState(1059);
    match(myParser::Colon);
    setState(1061);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx)) {
    case 1: {
      setState(1060);
      statementList();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultClauseContext ------------------------------------------------------------------

myParser::DefaultClauseContext::DefaultClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::DefaultClauseContext::Default() {
  return getToken(myParser::Default, 0);
}

tree::TerminalNode* myParser::DefaultClauseContext::Colon() {
  return getToken(myParser::Colon, 0);
}

myParser::StatementListContext* myParser::DefaultClauseContext::statementList() {
  return getRuleContext<myParser::StatementListContext>(0);
}


size_t myParser::DefaultClauseContext::getRuleIndex() const {
  return myParser::RuleDefaultClause;
}

void myParser::DefaultClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultClause(this);
}

void myParser::DefaultClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultClause(this);
}

myParser::DefaultClauseContext* myParser::defaultClause() {
  DefaultClauseContext *_localctx = _tracker.createInstance<DefaultClauseContext>(_ctx, getState());
  enterRule(_localctx, 172, myParser::RuleDefaultClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1063);
    match(myParser::Default);
    setState(1064);
    match(myParser::Colon);
    setState(1066);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx)) {
    case 1: {
      setState(1065);
      statementList();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelledStatementContext ------------------------------------------------------------------

myParser::LabelledStatementContext::LabelledStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::LabelledStatementContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

tree::TerminalNode* myParser::LabelledStatementContext::Colon() {
  return getToken(myParser::Colon, 0);
}

myParser::StatementContext* myParser::LabelledStatementContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}


size_t myParser::LabelledStatementContext::getRuleIndex() const {
  return myParser::RuleLabelledStatement;
}

void myParser::LabelledStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabelledStatement(this);
}

void myParser::LabelledStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabelledStatement(this);
}

myParser::LabelledStatementContext* myParser::labelledStatement() {
  LabelledStatementContext *_localctx = _tracker.createInstance<LabelledStatementContext>(_ctx, getState());
  enterRule(_localctx, 174, myParser::RuleLabelledStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1068);
    match(myParser::Identifier);
    setState(1069);
    match(myParser::Colon);
    setState(1070);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThrowStatementContext ------------------------------------------------------------------

myParser::ThrowStatementContext::ThrowStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ThrowStatementContext::Throw() {
  return getToken(myParser::Throw, 0);
}

myParser::ExpressionSequenceContext* myParser::ThrowStatementContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

myParser::EosContext* myParser::ThrowStatementContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}


size_t myParser::ThrowStatementContext::getRuleIndex() const {
  return myParser::RuleThrowStatement;
}

void myParser::ThrowStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrowStatement(this);
}

void myParser::ThrowStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrowStatement(this);
}

myParser::ThrowStatementContext* myParser::throwStatement() {
  ThrowStatementContext *_localctx = _tracker.createInstance<ThrowStatementContext>(_ctx, getState());
  enterRule(_localctx, 176, myParser::RuleThrowStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1072);
    match(myParser::Throw);
    setState(1073);

    if (!(this.notLineTerminator())) throw FailedPredicateException(this, "this.notLineTerminator()");
    setState(1074);
    expressionSequence();
    setState(1075);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TryStatementContext ------------------------------------------------------------------

myParser::TryStatementContext::TryStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TryStatementContext::Try() {
  return getToken(myParser::Try, 0);
}

myParser::BlockContext* myParser::TryStatementContext::block() {
  return getRuleContext<myParser::BlockContext>(0);
}

myParser::CatchProductionContext* myParser::TryStatementContext::catchProduction() {
  return getRuleContext<myParser::CatchProductionContext>(0);
}

myParser::FinallyProductionContext* myParser::TryStatementContext::finallyProduction() {
  return getRuleContext<myParser::FinallyProductionContext>(0);
}


size_t myParser::TryStatementContext::getRuleIndex() const {
  return myParser::RuleTryStatement;
}

void myParser::TryStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTryStatement(this);
}

void myParser::TryStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTryStatement(this);
}

myParser::TryStatementContext* myParser::tryStatement() {
  TryStatementContext *_localctx = _tracker.createInstance<TryStatementContext>(_ctx, getState());
  enterRule(_localctx, 178, myParser::RuleTryStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1077);
    match(myParser::Try);
    setState(1078);
    block();
    setState(1084);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Catch: {
        setState(1079);
        catchProduction();
        setState(1081);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 124, _ctx)) {
        case 1: {
          setState(1080);
          finallyProduction();
          break;
        }

        default:
          break;
        }
        break;
      }

      case myParser::Finally: {
        setState(1083);
        finallyProduction();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CatchProductionContext ------------------------------------------------------------------

myParser::CatchProductionContext::CatchProductionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::CatchProductionContext::Catch() {
  return getToken(myParser::Catch, 0);
}

tree::TerminalNode* myParser::CatchProductionContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::CatchProductionContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

tree::TerminalNode* myParser::CatchProductionContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::BlockContext* myParser::CatchProductionContext::block() {
  return getRuleContext<myParser::BlockContext>(0);
}


size_t myParser::CatchProductionContext::getRuleIndex() const {
  return myParser::RuleCatchProduction;
}

void myParser::CatchProductionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCatchProduction(this);
}

void myParser::CatchProductionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCatchProduction(this);
}

myParser::CatchProductionContext* myParser::catchProduction() {
  CatchProductionContext *_localctx = _tracker.createInstance<CatchProductionContext>(_ctx, getState());
  enterRule(_localctx, 180, myParser::RuleCatchProduction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1086);
    match(myParser::Catch);
    setState(1087);
    match(myParser::OpenParen);
    setState(1088);
    match(myParser::Identifier);
    setState(1089);
    match(myParser::CloseParen);
    setState(1090);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FinallyProductionContext ------------------------------------------------------------------

myParser::FinallyProductionContext::FinallyProductionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::FinallyProductionContext::Finally() {
  return getToken(myParser::Finally, 0);
}

myParser::BlockContext* myParser::FinallyProductionContext::block() {
  return getRuleContext<myParser::BlockContext>(0);
}


size_t myParser::FinallyProductionContext::getRuleIndex() const {
  return myParser::RuleFinallyProduction;
}

void myParser::FinallyProductionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFinallyProduction(this);
}

void myParser::FinallyProductionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFinallyProduction(this);
}

myParser::FinallyProductionContext* myParser::finallyProduction() {
  FinallyProductionContext *_localctx = _tracker.createInstance<FinallyProductionContext>(_ctx, getState());
  enterRule(_localctx, 182, myParser::RuleFinallyProduction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1092);
    match(myParser::Finally);
    setState(1093);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DebuggerStatementContext ------------------------------------------------------------------

myParser::DebuggerStatementContext::DebuggerStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::DebuggerStatementContext::Debugger() {
  return getToken(myParser::Debugger, 0);
}

myParser::EosContext* myParser::DebuggerStatementContext::eos() {
  return getRuleContext<myParser::EosContext>(0);
}


size_t myParser::DebuggerStatementContext::getRuleIndex() const {
  return myParser::RuleDebuggerStatement;
}

void myParser::DebuggerStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDebuggerStatement(this);
}

void myParser::DebuggerStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDebuggerStatement(this);
}

myParser::DebuggerStatementContext* myParser::debuggerStatement() {
  DebuggerStatementContext *_localctx = _tracker.createInstance<DebuggerStatementContext>(_ctx, getState());
  enterRule(_localctx, 184, myParser::RuleDebuggerStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1095);
    match(myParser::Debugger);
    setState(1096);
    eos();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDeclarationContext ------------------------------------------------------------------

myParser::FunctionDeclarationContext::FunctionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::FunctionDeclarationContext::Function_() {
  return getToken(myParser::Function_, 0);
}

tree::TerminalNode* myParser::FunctionDeclarationContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

myParser::CallSignatureContext* myParser::FunctionDeclarationContext::callSignature() {
  return getRuleContext<myParser::CallSignatureContext>(0);
}

tree::TerminalNode* myParser::FunctionDeclarationContext::SemiColon() {
  return getToken(myParser::SemiColon, 0);
}

tree::TerminalNode* myParser::FunctionDeclarationContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

myParser::FunctionBodyContext* myParser::FunctionDeclarationContext::functionBody() {
  return getRuleContext<myParser::FunctionBodyContext>(0);
}

tree::TerminalNode* myParser::FunctionDeclarationContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}


size_t myParser::FunctionDeclarationContext::getRuleIndex() const {
  return myParser::RuleFunctionDeclaration;
}

void myParser::FunctionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionDeclaration(this);
}

void myParser::FunctionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionDeclaration(this);
}

myParser::FunctionDeclarationContext* myParser::functionDeclaration() {
  FunctionDeclarationContext *_localctx = _tracker.createInstance<FunctionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 186, myParser::RuleFunctionDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1098);
    match(myParser::Function_);
    setState(1099);
    match(myParser::Identifier);
    setState(1100);
    callSignature();
    setState(1106);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::OpenBrace: {
        setState(1101);
        match(myParser::OpenBrace);
        setState(1102);
        functionBody();
        setState(1103);
        match(myParser::CloseBrace);
        break;
      }

      case myParser::SemiColon: {
        setState(1105);
        match(myParser::SemiColon);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassDeclarationContext ------------------------------------------------------------------

myParser::ClassDeclarationContext::ClassDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ClassDeclarationContext::Class() {
  return getToken(myParser::Class, 0);
}

tree::TerminalNode* myParser::ClassDeclarationContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

myParser::ClassHeritageContext* myParser::ClassDeclarationContext::classHeritage() {
  return getRuleContext<myParser::ClassHeritageContext>(0);
}

myParser::ClassTailContext* myParser::ClassDeclarationContext::classTail() {
  return getRuleContext<myParser::ClassTailContext>(0);
}

tree::TerminalNode* myParser::ClassDeclarationContext::Abstract() {
  return getToken(myParser::Abstract, 0);
}

myParser::TypeParametersContext* myParser::ClassDeclarationContext::typeParameters() {
  return getRuleContext<myParser::TypeParametersContext>(0);
}


size_t myParser::ClassDeclarationContext::getRuleIndex() const {
  return myParser::RuleClassDeclaration;
}

void myParser::ClassDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassDeclaration(this);
}

void myParser::ClassDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassDeclaration(this);
}

myParser::ClassDeclarationContext* myParser::classDeclaration() {
  ClassDeclarationContext *_localctx = _tracker.createInstance<ClassDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 188, myParser::RuleClassDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1109);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Abstract) {
      setState(1108);
      match(myParser::Abstract);
    }
    setState(1111);
    match(myParser::Class);
    setState(1112);
    match(myParser::Identifier);
    setState(1114);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::LessThan) {
      setState(1113);
      typeParameters();
    }
    setState(1116);
    classHeritage();
    setState(1117);
    classTail();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassHeritageContext ------------------------------------------------------------------

myParser::ClassHeritageContext::ClassHeritageContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ClassExtendsClauseContext* myParser::ClassHeritageContext::classExtendsClause() {
  return getRuleContext<myParser::ClassExtendsClauseContext>(0);
}

myParser::ImplementsClauseContext* myParser::ClassHeritageContext::implementsClause() {
  return getRuleContext<myParser::ImplementsClauseContext>(0);
}


size_t myParser::ClassHeritageContext::getRuleIndex() const {
  return myParser::RuleClassHeritage;
}

void myParser::ClassHeritageContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassHeritage(this);
}

void myParser::ClassHeritageContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassHeritage(this);
}

myParser::ClassHeritageContext* myParser::classHeritage() {
  ClassHeritageContext *_localctx = _tracker.createInstance<ClassHeritageContext>(_ctx, getState());
  enterRule(_localctx, 190, myParser::RuleClassHeritage);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1120);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Extends) {
      setState(1119);
      classExtendsClause();
    }
    setState(1123);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Implements) {
      setState(1122);
      implementsClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassTailContext ------------------------------------------------------------------

myParser::ClassTailContext::ClassTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ClassTailContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

tree::TerminalNode* myParser::ClassTailContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

std::vector<myParser::ClassElementContext *> myParser::ClassTailContext::classElement() {
  return getRuleContexts<myParser::ClassElementContext>();
}

myParser::ClassElementContext* myParser::ClassTailContext::classElement(size_t i) {
  return getRuleContext<myParser::ClassElementContext>(i);
}


size_t myParser::ClassTailContext::getRuleIndex() const {
  return myParser::RuleClassTail;
}

void myParser::ClassTailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassTail(this);
}

void myParser::ClassTailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassTail(this);
}

myParser::ClassTailContext* myParser::classTail() {
  ClassTailContext *_localctx = _tracker.createInstance<ClassTailContext>(_ctx, getState());
  enterRule(_localctx, 192, myParser::RuleClassTail);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1125);
    match(myParser::OpenBrace);
    setState(1129);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 131, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1126);
        classElement(); 
      }
      setState(1131);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 131, _ctx);
    }
    setState(1132);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassExtendsClauseContext ------------------------------------------------------------------

myParser::ClassExtendsClauseContext::ClassExtendsClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ClassExtendsClauseContext::Extends() {
  return getToken(myParser::Extends, 0);
}

myParser::TypeReferenceContext* myParser::ClassExtendsClauseContext::typeReference() {
  return getRuleContext<myParser::TypeReferenceContext>(0);
}


size_t myParser::ClassExtendsClauseContext::getRuleIndex() const {
  return myParser::RuleClassExtendsClause;
}

void myParser::ClassExtendsClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassExtendsClause(this);
}

void myParser::ClassExtendsClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassExtendsClause(this);
}

myParser::ClassExtendsClauseContext* myParser::classExtendsClause() {
  ClassExtendsClauseContext *_localctx = _tracker.createInstance<ClassExtendsClauseContext>(_ctx, getState());
  enterRule(_localctx, 194, myParser::RuleClassExtendsClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1134);
    match(myParser::Extends);
    setState(1135);
    typeReference();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImplementsClauseContext ------------------------------------------------------------------

myParser::ImplementsClauseContext::ImplementsClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ImplementsClauseContext::Implements() {
  return getToken(myParser::Implements, 0);
}

myParser::ClassOrInterfaceTypeListContext* myParser::ImplementsClauseContext::classOrInterfaceTypeList() {
  return getRuleContext<myParser::ClassOrInterfaceTypeListContext>(0);
}


size_t myParser::ImplementsClauseContext::getRuleIndex() const {
  return myParser::RuleImplementsClause;
}

void myParser::ImplementsClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImplementsClause(this);
}

void myParser::ImplementsClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImplementsClause(this);
}

myParser::ImplementsClauseContext* myParser::implementsClause() {
  ImplementsClauseContext *_localctx = _tracker.createInstance<ImplementsClauseContext>(_ctx, getState());
  enterRule(_localctx, 196, myParser::RuleImplementsClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1137);
    match(myParser::Implements);
    setState(1138);
    classOrInterfaceTypeList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassElementContext ------------------------------------------------------------------

myParser::ClassElementContext::ClassElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ConstructorDeclarationContext* myParser::ClassElementContext::constructorDeclaration() {
  return getRuleContext<myParser::ConstructorDeclarationContext>(0);
}

myParser::PropertyMemberDeclarationContext* myParser::ClassElementContext::propertyMemberDeclaration() {
  return getRuleContext<myParser::PropertyMemberDeclarationContext>(0);
}

myParser::DecoratorListContext* myParser::ClassElementContext::decoratorList() {
  return getRuleContext<myParser::DecoratorListContext>(0);
}

myParser::IndexMemberDeclarationContext* myParser::ClassElementContext::indexMemberDeclaration() {
  return getRuleContext<myParser::IndexMemberDeclarationContext>(0);
}

myParser::StatementContext* myParser::ClassElementContext::statement() {
  return getRuleContext<myParser::StatementContext>(0);
}


size_t myParser::ClassElementContext::getRuleIndex() const {
  return myParser::RuleClassElement;
}

void myParser::ClassElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassElement(this);
}

void myParser::ClassElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassElement(this);
}

myParser::ClassElementContext* myParser::classElement() {
  ClassElementContext *_localctx = _tracker.createInstance<ClassElementContext>(_ctx, getState());
  enterRule(_localctx, 198, myParser::RuleClassElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1147);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 133, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1140);
      constructorDeclaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1142);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::At) {
        setState(1141);
        decoratorList();
      }
      setState(1144);
      propertyMemberDeclaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1145);
      indexMemberDeclaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1146);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyMemberDeclarationContext ------------------------------------------------------------------

myParser::PropertyMemberDeclarationContext::PropertyMemberDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t myParser::PropertyMemberDeclarationContext::getRuleIndex() const {
  return myParser::RulePropertyMemberDeclaration;
}

void myParser::PropertyMemberDeclarationContext::copyFrom(PropertyMemberDeclarationContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PropertyDeclarationExpressionContext ------------------------------------------------------------------

myParser::PropertyMemberBaseContext* myParser::PropertyDeclarationExpressionContext::propertyMemberBase() {
  return getRuleContext<myParser::PropertyMemberBaseContext>(0);
}

myParser::PropertyNameContext* myParser::PropertyDeclarationExpressionContext::propertyName() {
  return getRuleContext<myParser::PropertyNameContext>(0);
}

tree::TerminalNode* myParser::PropertyDeclarationExpressionContext::SemiColon() {
  return getToken(myParser::SemiColon, 0);
}

tree::TerminalNode* myParser::PropertyDeclarationExpressionContext::QuestionMark() {
  return getToken(myParser::QuestionMark, 0);
}

myParser::TypeAnnotationContext* myParser::PropertyDeclarationExpressionContext::typeAnnotation() {
  return getRuleContext<myParser::TypeAnnotationContext>(0);
}

myParser::InitializerContext* myParser::PropertyDeclarationExpressionContext::initializer() {
  return getRuleContext<myParser::InitializerContext>(0);
}

myParser::PropertyDeclarationExpressionContext::PropertyDeclarationExpressionContext(PropertyMemberDeclarationContext *ctx) { copyFrom(ctx); }

void myParser::PropertyDeclarationExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyDeclarationExpression(this);
}
void myParser::PropertyDeclarationExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyDeclarationExpression(this);
}
//----------------- MethodDeclarationExpressionContext ------------------------------------------------------------------

myParser::PropertyMemberBaseContext* myParser::MethodDeclarationExpressionContext::propertyMemberBase() {
  return getRuleContext<myParser::PropertyMemberBaseContext>(0);
}

myParser::PropertyNameContext* myParser::MethodDeclarationExpressionContext::propertyName() {
  return getRuleContext<myParser::PropertyNameContext>(0);
}

myParser::CallSignatureContext* myParser::MethodDeclarationExpressionContext::callSignature() {
  return getRuleContext<myParser::CallSignatureContext>(0);
}

tree::TerminalNode* myParser::MethodDeclarationExpressionContext::SemiColon() {
  return getToken(myParser::SemiColon, 0);
}

tree::TerminalNode* myParser::MethodDeclarationExpressionContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

myParser::FunctionBodyContext* myParser::MethodDeclarationExpressionContext::functionBody() {
  return getRuleContext<myParser::FunctionBodyContext>(0);
}

tree::TerminalNode* myParser::MethodDeclarationExpressionContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

myParser::MethodDeclarationExpressionContext::MethodDeclarationExpressionContext(PropertyMemberDeclarationContext *ctx) { copyFrom(ctx); }

void myParser::MethodDeclarationExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMethodDeclarationExpression(this);
}
void myParser::MethodDeclarationExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMethodDeclarationExpression(this);
}
//----------------- GetterSetterDeclarationExpressionContext ------------------------------------------------------------------

myParser::PropertyMemberBaseContext* myParser::GetterSetterDeclarationExpressionContext::propertyMemberBase() {
  return getRuleContext<myParser::PropertyMemberBaseContext>(0);
}

myParser::GetAccessorContext* myParser::GetterSetterDeclarationExpressionContext::getAccessor() {
  return getRuleContext<myParser::GetAccessorContext>(0);
}

myParser::SetAccessorContext* myParser::GetterSetterDeclarationExpressionContext::setAccessor() {
  return getRuleContext<myParser::SetAccessorContext>(0);
}

myParser::GetterSetterDeclarationExpressionContext::GetterSetterDeclarationExpressionContext(PropertyMemberDeclarationContext *ctx) { copyFrom(ctx); }

void myParser::GetterSetterDeclarationExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGetterSetterDeclarationExpression(this);
}
void myParser::GetterSetterDeclarationExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGetterSetterDeclarationExpression(this);
}
//----------------- AbstractMemberDeclarationContext ------------------------------------------------------------------

myParser::AbstractDeclarationContext* myParser::AbstractMemberDeclarationContext::abstractDeclaration() {
  return getRuleContext<myParser::AbstractDeclarationContext>(0);
}

myParser::AbstractMemberDeclarationContext::AbstractMemberDeclarationContext(PropertyMemberDeclarationContext *ctx) { copyFrom(ctx); }

void myParser::AbstractMemberDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAbstractMemberDeclaration(this);
}
void myParser::AbstractMemberDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAbstractMemberDeclaration(this);
}
myParser::PropertyMemberDeclarationContext* myParser::propertyMemberDeclaration() {
  PropertyMemberDeclarationContext *_localctx = _tracker.createInstance<PropertyMemberDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 200, myParser::RulePropertyMemberDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1178);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 139, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<myParser::PropertyDeclarationExpressionContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(1149);
      propertyMemberBase();
      setState(1150);
      propertyName();
      setState(1152);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::QuestionMark) {
        setState(1151);
        match(myParser::QuestionMark);
      }
      setState(1155);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::Colon) {
        setState(1154);
        typeAnnotation();
      }
      setState(1158);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::Assign) {
        setState(1157);
        initializer();
      }
      setState(1160);
      match(myParser::SemiColon);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<myParser::MethodDeclarationExpressionContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(1162);
      propertyMemberBase();
      setState(1163);
      propertyName();
      setState(1164);
      callSignature();
      setState(1170);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case myParser::OpenBrace: {
          setState(1165);
          match(myParser::OpenBrace);
          setState(1166);
          functionBody();
          setState(1167);
          match(myParser::CloseBrace);
          break;
        }

        case myParser::SemiColon: {
          setState(1169);
          match(myParser::SemiColon);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<myParser::GetterSetterDeclarationExpressionContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(1172);
      propertyMemberBase();
      setState(1175);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case myParser::Get: {
          setState(1173);
          getAccessor();
          break;
        }

        case myParser::Set: {
          setState(1174);
          setAccessor();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<myParser::AbstractMemberDeclarationContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(1177);
      abstractDeclaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyMemberBaseContext ------------------------------------------------------------------

myParser::PropertyMemberBaseContext::PropertyMemberBaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::PropertyMemberBaseContext::Async() {
  return getToken(myParser::Async, 0);
}

myParser::AccessibilityModifierContext* myParser::PropertyMemberBaseContext::accessibilityModifier() {
  return getRuleContext<myParser::AccessibilityModifierContext>(0);
}

tree::TerminalNode* myParser::PropertyMemberBaseContext::Static() {
  return getToken(myParser::Static, 0);
}

tree::TerminalNode* myParser::PropertyMemberBaseContext::ReadOnly() {
  return getToken(myParser::ReadOnly, 0);
}


size_t myParser::PropertyMemberBaseContext::getRuleIndex() const {
  return myParser::RulePropertyMemberBase;
}

void myParser::PropertyMemberBaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyMemberBase(this);
}

void myParser::PropertyMemberBaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyMemberBase(this);
}

myParser::PropertyMemberBaseContext* myParser::propertyMemberBase() {
  PropertyMemberBaseContext *_localctx = _tracker.createInstance<PropertyMemberBaseContext>(_ctx, getState());
  enterRule(_localctx, 202, myParser::RulePropertyMemberBase);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1181);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 140, _ctx)) {
    case 1: {
      setState(1180);
      match(myParser::Async);
      break;
    }

    default:
      break;
    }
    setState(1184);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx)) {
    case 1: {
      setState(1183);
      accessibilityModifier();
      break;
    }

    default:
      break;
    }
    setState(1187);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, _ctx)) {
    case 1: {
      setState(1186);
      match(myParser::Static);
      break;
    }

    default:
      break;
    }
    setState(1190);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx)) {
    case 1: {
      setState(1189);
      match(myParser::ReadOnly);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexMemberDeclarationContext ------------------------------------------------------------------

myParser::IndexMemberDeclarationContext::IndexMemberDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IndexSignatureContext* myParser::IndexMemberDeclarationContext::indexSignature() {
  return getRuleContext<myParser::IndexSignatureContext>(0);
}

tree::TerminalNode* myParser::IndexMemberDeclarationContext::SemiColon() {
  return getToken(myParser::SemiColon, 0);
}


size_t myParser::IndexMemberDeclarationContext::getRuleIndex() const {
  return myParser::RuleIndexMemberDeclaration;
}

void myParser::IndexMemberDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexMemberDeclaration(this);
}

void myParser::IndexMemberDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexMemberDeclaration(this);
}

myParser::IndexMemberDeclarationContext* myParser::indexMemberDeclaration() {
  IndexMemberDeclarationContext *_localctx = _tracker.createInstance<IndexMemberDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 204, myParser::RuleIndexMemberDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1192);
    indexSignature();
    setState(1193);
    match(myParser::SemiColon);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeneratorMethodContext ------------------------------------------------------------------

myParser::GeneratorMethodContext::GeneratorMethodContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::GeneratorMethodContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

tree::TerminalNode* myParser::GeneratorMethodContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::GeneratorMethodContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

tree::TerminalNode* myParser::GeneratorMethodContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

myParser::FunctionBodyContext* myParser::GeneratorMethodContext::functionBody() {
  return getRuleContext<myParser::FunctionBodyContext>(0);
}

tree::TerminalNode* myParser::GeneratorMethodContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

tree::TerminalNode* myParser::GeneratorMethodContext::Multiply() {
  return getToken(myParser::Multiply, 0);
}

myParser::FormalParameterListContext* myParser::GeneratorMethodContext::formalParameterList() {
  return getRuleContext<myParser::FormalParameterListContext>(0);
}


size_t myParser::GeneratorMethodContext::getRuleIndex() const {
  return myParser::RuleGeneratorMethod;
}

void myParser::GeneratorMethodContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneratorMethod(this);
}

void myParser::GeneratorMethodContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneratorMethod(this);
}

myParser::GeneratorMethodContext* myParser::generatorMethod() {
  GeneratorMethodContext *_localctx = _tracker.createInstance<GeneratorMethodContext>(_ctx, getState());
  enterRule(_localctx, 206, myParser::RuleGeneratorMethod);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1196);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Multiply) {
      setState(1195);
      match(myParser::Multiply);
    }
    setState(1198);
    match(myParser::Identifier);
    setState(1199);
    match(myParser::OpenParen);
    setState(1201);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 65808) != 0) || ((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 12718099) != 0)) {
      setState(1200);
      formalParameterList();
    }
    setState(1203);
    match(myParser::CloseParen);
    setState(1204);
    match(myParser::OpenBrace);
    setState(1205);
    functionBody();
    setState(1206);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeneratorFunctionDeclarationContext ------------------------------------------------------------------

myParser::GeneratorFunctionDeclarationContext::GeneratorFunctionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::GeneratorFunctionDeclarationContext::Function_() {
  return getToken(myParser::Function_, 0);
}

tree::TerminalNode* myParser::GeneratorFunctionDeclarationContext::Multiply() {
  return getToken(myParser::Multiply, 0);
}

tree::TerminalNode* myParser::GeneratorFunctionDeclarationContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::GeneratorFunctionDeclarationContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

tree::TerminalNode* myParser::GeneratorFunctionDeclarationContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

myParser::FunctionBodyContext* myParser::GeneratorFunctionDeclarationContext::functionBody() {
  return getRuleContext<myParser::FunctionBodyContext>(0);
}

tree::TerminalNode* myParser::GeneratorFunctionDeclarationContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

tree::TerminalNode* myParser::GeneratorFunctionDeclarationContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

myParser::FormalParameterListContext* myParser::GeneratorFunctionDeclarationContext::formalParameterList() {
  return getRuleContext<myParser::FormalParameterListContext>(0);
}


size_t myParser::GeneratorFunctionDeclarationContext::getRuleIndex() const {
  return myParser::RuleGeneratorFunctionDeclaration;
}

void myParser::GeneratorFunctionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneratorFunctionDeclaration(this);
}

void myParser::GeneratorFunctionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneratorFunctionDeclaration(this);
}

myParser::GeneratorFunctionDeclarationContext* myParser::generatorFunctionDeclaration() {
  GeneratorFunctionDeclarationContext *_localctx = _tracker.createInstance<GeneratorFunctionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 208, myParser::RuleGeneratorFunctionDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1208);
    match(myParser::Function_);
    setState(1209);
    match(myParser::Multiply);
    setState(1211);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Identifier) {
      setState(1210);
      match(myParser::Identifier);
    }
    setState(1213);
    match(myParser::OpenParen);
    setState(1215);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 65808) != 0) || ((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 12718099) != 0)) {
      setState(1214);
      formalParameterList();
    }
    setState(1217);
    match(myParser::CloseParen);
    setState(1218);
    match(myParser::OpenBrace);
    setState(1219);
    functionBody();
    setState(1220);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeneratorBlockContext ------------------------------------------------------------------

myParser::GeneratorBlockContext::GeneratorBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::GeneratorBlockContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

std::vector<myParser::GeneratorDefinitionContext *> myParser::GeneratorBlockContext::generatorDefinition() {
  return getRuleContexts<myParser::GeneratorDefinitionContext>();
}

myParser::GeneratorDefinitionContext* myParser::GeneratorBlockContext::generatorDefinition(size_t i) {
  return getRuleContext<myParser::GeneratorDefinitionContext>(i);
}

tree::TerminalNode* myParser::GeneratorBlockContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

std::vector<tree::TerminalNode *> myParser::GeneratorBlockContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::GeneratorBlockContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::GeneratorBlockContext::getRuleIndex() const {
  return myParser::RuleGeneratorBlock;
}

void myParser::GeneratorBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneratorBlock(this);
}

void myParser::GeneratorBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneratorBlock(this);
}

myParser::GeneratorBlockContext* myParser::generatorBlock() {
  GeneratorBlockContext *_localctx = _tracker.createInstance<GeneratorBlockContext>(_ctx, getState());
  enterRule(_localctx, 210, myParser::RuleGeneratorBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1222);
    match(myParser::OpenBrace);
    setState(1223);
    generatorDefinition();
    setState(1228);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 148, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1224);
        match(myParser::Comma);
        setState(1225);
        generatorDefinition(); 
      }
      setState(1230);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 148, _ctx);
    }
    setState(1232);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Comma) {
      setState(1231);
      match(myParser::Comma);
    }
    setState(1234);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeneratorDefinitionContext ------------------------------------------------------------------

myParser::GeneratorDefinitionContext::GeneratorDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::GeneratorDefinitionContext::Multiply() {
  return getToken(myParser::Multiply, 0);
}

myParser::IteratorDefinitionContext* myParser::GeneratorDefinitionContext::iteratorDefinition() {
  return getRuleContext<myParser::IteratorDefinitionContext>(0);
}


size_t myParser::GeneratorDefinitionContext::getRuleIndex() const {
  return myParser::RuleGeneratorDefinition;
}

void myParser::GeneratorDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneratorDefinition(this);
}

void myParser::GeneratorDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneratorDefinition(this);
}

myParser::GeneratorDefinitionContext* myParser::generatorDefinition() {
  GeneratorDefinitionContext *_localctx = _tracker.createInstance<GeneratorDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 212, myParser::RuleGeneratorDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1236);
    match(myParser::Multiply);
    setState(1237);
    iteratorDefinition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IteratorBlockContext ------------------------------------------------------------------

myParser::IteratorBlockContext::IteratorBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::IteratorBlockContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

std::vector<myParser::IteratorDefinitionContext *> myParser::IteratorBlockContext::iteratorDefinition() {
  return getRuleContexts<myParser::IteratorDefinitionContext>();
}

myParser::IteratorDefinitionContext* myParser::IteratorBlockContext::iteratorDefinition(size_t i) {
  return getRuleContext<myParser::IteratorDefinitionContext>(i);
}

tree::TerminalNode* myParser::IteratorBlockContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

std::vector<tree::TerminalNode *> myParser::IteratorBlockContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::IteratorBlockContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::IteratorBlockContext::getRuleIndex() const {
  return myParser::RuleIteratorBlock;
}

void myParser::IteratorBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIteratorBlock(this);
}

void myParser::IteratorBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIteratorBlock(this);
}

myParser::IteratorBlockContext* myParser::iteratorBlock() {
  IteratorBlockContext *_localctx = _tracker.createInstance<IteratorBlockContext>(_ctx, getState());
  enterRule(_localctx, 214, myParser::RuleIteratorBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1239);
    match(myParser::OpenBrace);
    setState(1240);
    iteratorDefinition();
    setState(1245);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 150, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1241);
        match(myParser::Comma);
        setState(1242);
        iteratorDefinition(); 
      }
      setState(1247);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 150, _ctx);
    }
    setState(1249);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Comma) {
      setState(1248);
      match(myParser::Comma);
    }
    setState(1251);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IteratorDefinitionContext ------------------------------------------------------------------

myParser::IteratorDefinitionContext::IteratorDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::IteratorDefinitionContext::OpenBracket() {
  return getToken(myParser::OpenBracket, 0);
}

myParser::SingleExpressionContext* myParser::IteratorDefinitionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::IteratorDefinitionContext::CloseBracket() {
  return getToken(myParser::CloseBracket, 0);
}

tree::TerminalNode* myParser::IteratorDefinitionContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::IteratorDefinitionContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

tree::TerminalNode* myParser::IteratorDefinitionContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

myParser::FunctionBodyContext* myParser::IteratorDefinitionContext::functionBody() {
  return getRuleContext<myParser::FunctionBodyContext>(0);
}

tree::TerminalNode* myParser::IteratorDefinitionContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

myParser::FormalParameterListContext* myParser::IteratorDefinitionContext::formalParameterList() {
  return getRuleContext<myParser::FormalParameterListContext>(0);
}


size_t myParser::IteratorDefinitionContext::getRuleIndex() const {
  return myParser::RuleIteratorDefinition;
}

void myParser::IteratorDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIteratorDefinition(this);
}

void myParser::IteratorDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIteratorDefinition(this);
}

myParser::IteratorDefinitionContext* myParser::iteratorDefinition() {
  IteratorDefinitionContext *_localctx = _tracker.createInstance<IteratorDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 216, myParser::RuleIteratorDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1253);
    match(myParser::OpenBracket);
    setState(1254);
    singleExpression(0);
    setState(1255);
    match(myParser::CloseBracket);
    setState(1256);
    match(myParser::OpenParen);
    setState(1258);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 65808) != 0) || ((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 12718099) != 0)) {
      setState(1257);
      formalParameterList();
    }
    setState(1260);
    match(myParser::CloseParen);
    setState(1261);
    match(myParser::OpenBrace);
    setState(1262);
    functionBody();
    setState(1263);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FormalParameterListContext ------------------------------------------------------------------

myParser::FormalParameterListContext::FormalParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::FormalParameterArgContext *> myParser::FormalParameterListContext::formalParameterArg() {
  return getRuleContexts<myParser::FormalParameterArgContext>();
}

myParser::FormalParameterArgContext* myParser::FormalParameterListContext::formalParameterArg(size_t i) {
  return getRuleContext<myParser::FormalParameterArgContext>(i);
}

std::vector<tree::TerminalNode *> myParser::FormalParameterListContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::FormalParameterListContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}

myParser::LastFormalParameterArgContext* myParser::FormalParameterListContext::lastFormalParameterArg() {
  return getRuleContext<myParser::LastFormalParameterArgContext>(0);
}

myParser::ArrayLiteralContext* myParser::FormalParameterListContext::arrayLiteral() {
  return getRuleContext<myParser::ArrayLiteralContext>(0);
}

myParser::ObjectLiteralContext* myParser::FormalParameterListContext::objectLiteral() {
  return getRuleContext<myParser::ObjectLiteralContext>(0);
}

tree::TerminalNode* myParser::FormalParameterListContext::Colon() {
  return getToken(myParser::Colon, 0);
}

myParser::FormalParameterListContext* myParser::FormalParameterListContext::formalParameterList() {
  return getRuleContext<myParser::FormalParameterListContext>(0);
}


size_t myParser::FormalParameterListContext::getRuleIndex() const {
  return myParser::RuleFormalParameterList;
}

void myParser::FormalParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFormalParameterList(this);
}

void myParser::FormalParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFormalParameterList(this);
}

myParser::FormalParameterListContext* myParser::formalParameterList() {
  FormalParameterListContext *_localctx = _tracker.createInstance<FormalParameterListContext>(_ctx, getState());
  enterRule(_localctx, 218, myParser::RuleFormalParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1284);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Private:
      case myParser::Public:
      case myParser::Protected:
      case myParser::TypeAlias:
      case myParser::Require:
      case myParser::At:
      case myParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(1265);
        formalParameterArg();
        setState(1270);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 153, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1266);
            match(myParser::Comma);
            setState(1267);
            formalParameterArg(); 
          }
          setState(1272);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 153, _ctx);
        }
        setState(1275);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::Comma) {
          setState(1273);
          match(myParser::Comma);
          setState(1274);
          lastFormalParameterArg();
        }
        break;
      }

      case myParser::Ellipsis: {
        enterOuterAlt(_localctx, 2);
        setState(1277);
        lastFormalParameterArg();
        break;
      }

      case myParser::OpenBracket: {
        enterOuterAlt(_localctx, 3);
        setState(1278);
        arrayLiteral();
        break;
      }

      case myParser::OpenBrace: {
        enterOuterAlt(_localctx, 4);
        setState(1279);
        objectLiteral();
        setState(1282);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == myParser::Colon) {
          setState(1280);
          match(myParser::Colon);
          setState(1281);
          formalParameterList();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FormalParameterArgContext ------------------------------------------------------------------

myParser::FormalParameterArgContext::FormalParameterArgContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierOrKeyWordContext* myParser::FormalParameterArgContext::identifierOrKeyWord() {
  return getRuleContext<myParser::IdentifierOrKeyWordContext>(0);
}

myParser::DecoratorContext* myParser::FormalParameterArgContext::decorator() {
  return getRuleContext<myParser::DecoratorContext>(0);
}

myParser::AccessibilityModifierContext* myParser::FormalParameterArgContext::accessibilityModifier() {
  return getRuleContext<myParser::AccessibilityModifierContext>(0);
}

tree::TerminalNode* myParser::FormalParameterArgContext::QuestionMark() {
  return getToken(myParser::QuestionMark, 0);
}

myParser::TypeAnnotationContext* myParser::FormalParameterArgContext::typeAnnotation() {
  return getRuleContext<myParser::TypeAnnotationContext>(0);
}

tree::TerminalNode* myParser::FormalParameterArgContext::Assign() {
  return getToken(myParser::Assign, 0);
}

myParser::SingleExpressionContext* myParser::FormalParameterArgContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}


size_t myParser::FormalParameterArgContext::getRuleIndex() const {
  return myParser::RuleFormalParameterArg;
}

void myParser::FormalParameterArgContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFormalParameterArg(this);
}

void myParser::FormalParameterArgContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFormalParameterArg(this);
}

myParser::FormalParameterArgContext* myParser::formalParameterArg() {
  FormalParameterArgContext *_localctx = _tracker.createInstance<FormalParameterArgContext>(_ctx, getState());
  enterRule(_localctx, 220, myParser::RuleFormalParameterArg);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1287);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::At) {
      setState(1286);
      decorator();
    }
    setState(1290);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 19) != 0)) {
      setState(1289);
      accessibilityModifier();
    }
    setState(1292);
    identifierOrKeyWord();
    setState(1294);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::QuestionMark) {
      setState(1293);
      match(myParser::QuestionMark);
    }
    setState(1297);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Colon) {
      setState(1296);
      typeAnnotation();
    }
    setState(1301);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Assign) {
      setState(1299);
      match(myParser::Assign);
      setState(1300);
      singleExpression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LastFormalParameterArgContext ------------------------------------------------------------------

myParser::LastFormalParameterArgContext::LastFormalParameterArgContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::LastFormalParameterArgContext::Ellipsis() {
  return getToken(myParser::Ellipsis, 0);
}

tree::TerminalNode* myParser::LastFormalParameterArgContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}


size_t myParser::LastFormalParameterArgContext::getRuleIndex() const {
  return myParser::RuleLastFormalParameterArg;
}

void myParser::LastFormalParameterArgContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLastFormalParameterArg(this);
}

void myParser::LastFormalParameterArgContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLastFormalParameterArg(this);
}

myParser::LastFormalParameterArgContext* myParser::lastFormalParameterArg() {
  LastFormalParameterArgContext *_localctx = _tracker.createInstance<LastFormalParameterArgContext>(_ctx, getState());
  enterRule(_localctx, 222, myParser::RuleLastFormalParameterArg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1303);
    match(myParser::Ellipsis);
    setState(1304);
    match(myParser::Identifier);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionBodyContext ------------------------------------------------------------------

myParser::FunctionBodyContext::FunctionBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SourceElementsContext* myParser::FunctionBodyContext::sourceElements() {
  return getRuleContext<myParser::SourceElementsContext>(0);
}


size_t myParser::FunctionBodyContext::getRuleIndex() const {
  return myParser::RuleFunctionBody;
}

void myParser::FunctionBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionBody(this);
}

void myParser::FunctionBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionBody(this);
}

myParser::FunctionBodyContext* myParser::functionBody() {
  FunctionBodyContext *_localctx = _tracker.createInstance<FunctionBodyContext>(_ctx, getState());
  enterRule(_localctx, 224, myParser::RuleFunctionBody);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1307);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 162, _ctx)) {
    case 1: {
      setState(1306);
      sourceElements();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SourceElementsContext ------------------------------------------------------------------

myParser::SourceElementsContext::SourceElementsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::SourceElementContext *> myParser::SourceElementsContext::sourceElement() {
  return getRuleContexts<myParser::SourceElementContext>();
}

myParser::SourceElementContext* myParser::SourceElementsContext::sourceElement(size_t i) {
  return getRuleContext<myParser::SourceElementContext>(i);
}


size_t myParser::SourceElementsContext::getRuleIndex() const {
  return myParser::RuleSourceElements;
}

void myParser::SourceElementsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSourceElements(this);
}

void myParser::SourceElementsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSourceElements(this);
}

myParser::SourceElementsContext* myParser::sourceElements() {
  SourceElementsContext *_localctx = _tracker.createInstance<SourceElementsContext>(_ctx, getState());
  enterRule(_localctx, 226, myParser::RuleSourceElements);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1310); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1309);
              sourceElement();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1312); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayLiteralContext ------------------------------------------------------------------

myParser::ArrayLiteralContext::ArrayLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ArrayLiteralContext::OpenBracket() {
  return getToken(myParser::OpenBracket, 0);
}

tree::TerminalNode* myParser::ArrayLiteralContext::CloseBracket() {
  return getToken(myParser::CloseBracket, 0);
}

myParser::ElementListContext* myParser::ArrayLiteralContext::elementList() {
  return getRuleContext<myParser::ElementListContext>(0);
}


size_t myParser::ArrayLiteralContext::getRuleIndex() const {
  return myParser::RuleArrayLiteral;
}

void myParser::ArrayLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayLiteral(this);
}

void myParser::ArrayLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayLiteral(this);
}

myParser::ArrayLiteralContext* myParser::arrayLiteral() {
  ArrayLiteralContext *_localctx = _tracker.createInstance<ArrayLiteralContext>(_ctx, getState());
  enterRule(_localctx, 228, myParser::RuleArrayLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1314);
    match(myParser::OpenBracket);
    setState(1316);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -36028795928641192) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 8092563910088982527) != 0)) {
      setState(1315);
      elementList();
    }
    setState(1318);
    match(myParser::CloseBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementListContext ------------------------------------------------------------------

myParser::ElementListContext::ElementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::ArrayElementContext *> myParser::ElementListContext::arrayElement() {
  return getRuleContexts<myParser::ArrayElementContext>();
}

myParser::ArrayElementContext* myParser::ElementListContext::arrayElement(size_t i) {
  return getRuleContext<myParser::ArrayElementContext>(i);
}

std::vector<tree::TerminalNode *> myParser::ElementListContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::ElementListContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::ElementListContext::getRuleIndex() const {
  return myParser::RuleElementList;
}

void myParser::ElementListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElementList(this);
}

void myParser::ElementListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElementList(this);
}

myParser::ElementListContext* myParser::elementList() {
  ElementListContext *_localctx = _tracker.createInstance<ElementListContext>(_ctx, getState());
  enterRule(_localctx, 230, myParser::RuleElementList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1320);
    arrayElement();
    setState(1329);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::Comma) {
      setState(1322); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1321);
        match(myParser::Comma);
        setState(1324); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == myParser::Comma);
      setState(1326);
      arrayElement();
      setState(1331);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayElementContext ------------------------------------------------------------------

myParser::ArrayElementContext::ArrayElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SingleExpressionContext* myParser::ArrayElementContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::ArrayElementContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

tree::TerminalNode* myParser::ArrayElementContext::Ellipsis() {
  return getToken(myParser::Ellipsis, 0);
}

tree::TerminalNode* myParser::ArrayElementContext::Comma() {
  return getToken(myParser::Comma, 0);
}


size_t myParser::ArrayElementContext::getRuleIndex() const {
  return myParser::RuleArrayElement;
}

void myParser::ArrayElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayElement(this);
}

void myParser::ArrayElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayElement(this);
}

myParser::ArrayElementContext* myParser::arrayElement() {
  ArrayElementContext *_localctx = _tracker.createInstance<ArrayElementContext>(_ctx, getState());
  enterRule(_localctx, 232, myParser::RuleArrayElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1333);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Ellipsis) {
      setState(1332);
      match(myParser::Ellipsis);
    }
    setState(1337);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 168, _ctx)) {
    case 1: {
      setState(1335);
      singleExpression(0);
      break;
    }

    case 2: {
      setState(1336);
      match(myParser::Identifier);
      break;
    }

    default:
      break;
    }
    setState(1340);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx)) {
    case 1: {
      setState(1339);
      match(myParser::Comma);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectLiteralContext ------------------------------------------------------------------

myParser::ObjectLiteralContext::ObjectLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ObjectLiteralContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

tree::TerminalNode* myParser::ObjectLiteralContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

std::vector<myParser::PropertyAssignmentContext *> myParser::ObjectLiteralContext::propertyAssignment() {
  return getRuleContexts<myParser::PropertyAssignmentContext>();
}

myParser::PropertyAssignmentContext* myParser::ObjectLiteralContext::propertyAssignment(size_t i) {
  return getRuleContext<myParser::PropertyAssignmentContext>(i);
}

std::vector<tree::TerminalNode *> myParser::ObjectLiteralContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::ObjectLiteralContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::ObjectLiteralContext::getRuleIndex() const {
  return myParser::RuleObjectLiteral;
}

void myParser::ObjectLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectLiteral(this);
}

void myParser::ObjectLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectLiteral(this);
}

myParser::ObjectLiteralContext* myParser::objectLiteral() {
  ObjectLiteralContext *_localctx = _tracker.createInstance<ObjectLiteralContext>(_ctx, getState());
  enterRule(_localctx, 234, myParser::RuleObjectLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1342);
    match(myParser::OpenBrace);
    setState(1354);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -36028797002121200) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3480877891661594623) != 0)) {
      setState(1343);
      propertyAssignment();
      setState(1348);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 170, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1344);
          match(myParser::Comma);
          setState(1345);
          propertyAssignment(); 
        }
        setState(1350);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 170, _ctx);
      }
      setState(1352);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::Comma) {
        setState(1351);
        match(myParser::Comma);
      }
    }
    setState(1356);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyAssignmentContext ------------------------------------------------------------------

myParser::PropertyAssignmentContext::PropertyAssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t myParser::PropertyAssignmentContext::getRuleIndex() const {
  return myParser::RulePropertyAssignment;
}

void myParser::PropertyAssignmentContext::copyFrom(PropertyAssignmentContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PropertyExpressionAssignmentContext ------------------------------------------------------------------

myParser::PropertyNameContext* myParser::PropertyExpressionAssignmentContext::propertyName() {
  return getRuleContext<myParser::PropertyNameContext>(0);
}

myParser::SingleExpressionContext* myParser::PropertyExpressionAssignmentContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::PropertyExpressionAssignmentContext::Colon() {
  return getToken(myParser::Colon, 0);
}

tree::TerminalNode* myParser::PropertyExpressionAssignmentContext::Assign() {
  return getToken(myParser::Assign, 0);
}

myParser::PropertyExpressionAssignmentContext::PropertyExpressionAssignmentContext(PropertyAssignmentContext *ctx) { copyFrom(ctx); }

void myParser::PropertyExpressionAssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyExpressionAssignment(this);
}
void myParser::PropertyExpressionAssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyExpressionAssignment(this);
}
//----------------- ComputedPropertyExpressionAssignmentContext ------------------------------------------------------------------

tree::TerminalNode* myParser::ComputedPropertyExpressionAssignmentContext::OpenBracket() {
  return getToken(myParser::OpenBracket, 0);
}

std::vector<myParser::SingleExpressionContext *> myParser::ComputedPropertyExpressionAssignmentContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::ComputedPropertyExpressionAssignmentContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::ComputedPropertyExpressionAssignmentContext::CloseBracket() {
  return getToken(myParser::CloseBracket, 0);
}

tree::TerminalNode* myParser::ComputedPropertyExpressionAssignmentContext::Colon() {
  return getToken(myParser::Colon, 0);
}

myParser::ComputedPropertyExpressionAssignmentContext::ComputedPropertyExpressionAssignmentContext(PropertyAssignmentContext *ctx) { copyFrom(ctx); }

void myParser::ComputedPropertyExpressionAssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComputedPropertyExpressionAssignment(this);
}
void myParser::ComputedPropertyExpressionAssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComputedPropertyExpressionAssignment(this);
}
//----------------- PropertyShorthandContext ------------------------------------------------------------------

myParser::IdentifierOrKeyWordContext* myParser::PropertyShorthandContext::identifierOrKeyWord() {
  return getRuleContext<myParser::IdentifierOrKeyWordContext>(0);
}

myParser::PropertyShorthandContext::PropertyShorthandContext(PropertyAssignmentContext *ctx) { copyFrom(ctx); }

void myParser::PropertyShorthandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyShorthand(this);
}
void myParser::PropertyShorthandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyShorthand(this);
}
//----------------- PropertySetterContext ------------------------------------------------------------------

myParser::SetAccessorContext* myParser::PropertySetterContext::setAccessor() {
  return getRuleContext<myParser::SetAccessorContext>(0);
}

myParser::PropertySetterContext::PropertySetterContext(PropertyAssignmentContext *ctx) { copyFrom(ctx); }

void myParser::PropertySetterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertySetter(this);
}
void myParser::PropertySetterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertySetter(this);
}
//----------------- PropertyGetterContext ------------------------------------------------------------------

myParser::GetAccessorContext* myParser::PropertyGetterContext::getAccessor() {
  return getRuleContext<myParser::GetAccessorContext>(0);
}

myParser::PropertyGetterContext::PropertyGetterContext(PropertyAssignmentContext *ctx) { copyFrom(ctx); }

void myParser::PropertyGetterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyGetter(this);
}
void myParser::PropertyGetterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyGetter(this);
}
//----------------- RestParameterInObjectContext ------------------------------------------------------------------

myParser::RestParameterContext* myParser::RestParameterInObjectContext::restParameter() {
  return getRuleContext<myParser::RestParameterContext>(0);
}

myParser::RestParameterInObjectContext::RestParameterInObjectContext(PropertyAssignmentContext *ctx) { copyFrom(ctx); }

void myParser::RestParameterInObjectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRestParameterInObject(this);
}
void myParser::RestParameterInObjectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRestParameterInObject(this);
}
//----------------- MethodPropertyContext ------------------------------------------------------------------

myParser::GeneratorMethodContext* myParser::MethodPropertyContext::generatorMethod() {
  return getRuleContext<myParser::GeneratorMethodContext>(0);
}

myParser::MethodPropertyContext::MethodPropertyContext(PropertyAssignmentContext *ctx) { copyFrom(ctx); }

void myParser::MethodPropertyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMethodProperty(this);
}
void myParser::MethodPropertyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMethodProperty(this);
}
myParser::PropertyAssignmentContext* myParser::propertyAssignment() {
  PropertyAssignmentContext *_localctx = _tracker.createInstance<PropertyAssignmentContext>(_ctx, getState());
  enterRule(_localctx, 236, myParser::RulePropertyAssignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1373);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 173, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<myParser::PropertyExpressionAssignmentContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(1358);
      propertyName();
      setState(1359);
      _la = _input->LA(1);
      if (!(_la == myParser::Assign

      || _la == myParser::Colon)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1360);
      singleExpression(0);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<myParser::ComputedPropertyExpressionAssignmentContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(1362);
      match(myParser::OpenBracket);
      setState(1363);
      singleExpression(0);
      setState(1364);
      match(myParser::CloseBracket);
      setState(1365);
      match(myParser::Colon);
      setState(1366);
      singleExpression(0);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<myParser::PropertyGetterContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(1368);
      getAccessor();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<myParser::PropertySetterContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(1369);
      setAccessor();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<myParser::MethodPropertyContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(1370);
      generatorMethod();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<myParser::PropertyShorthandContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(1371);
      identifierOrKeyWord();
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<myParser::RestParameterInObjectContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(1372);
      restParameter();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GetAccessorContext ------------------------------------------------------------------

myParser::GetAccessorContext::GetAccessorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::GetterContext* myParser::GetAccessorContext::getter() {
  return getRuleContext<myParser::GetterContext>(0);
}

tree::TerminalNode* myParser::GetAccessorContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::GetAccessorContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

tree::TerminalNode* myParser::GetAccessorContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

myParser::FunctionBodyContext* myParser::GetAccessorContext::functionBody() {
  return getRuleContext<myParser::FunctionBodyContext>(0);
}

tree::TerminalNode* myParser::GetAccessorContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

myParser::TypeAnnotationContext* myParser::GetAccessorContext::typeAnnotation() {
  return getRuleContext<myParser::TypeAnnotationContext>(0);
}


size_t myParser::GetAccessorContext::getRuleIndex() const {
  return myParser::RuleGetAccessor;
}

void myParser::GetAccessorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGetAccessor(this);
}

void myParser::GetAccessorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGetAccessor(this);
}

myParser::GetAccessorContext* myParser::getAccessor() {
  GetAccessorContext *_localctx = _tracker.createInstance<GetAccessorContext>(_ctx, getState());
  enterRule(_localctx, 238, myParser::RuleGetAccessor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1375);
    getter();
    setState(1376);
    match(myParser::OpenParen);
    setState(1377);
    match(myParser::CloseParen);
    setState(1379);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Colon) {
      setState(1378);
      typeAnnotation();
    }
    setState(1381);
    match(myParser::OpenBrace);
    setState(1382);
    functionBody();
    setState(1383);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetAccessorContext ------------------------------------------------------------------

myParser::SetAccessorContext::SetAccessorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SetterContext* myParser::SetAccessorContext::setter() {
  return getRuleContext<myParser::SetterContext>(0);
}

tree::TerminalNode* myParser::SetAccessorContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::SetAccessorContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

tree::TerminalNode* myParser::SetAccessorContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

myParser::FunctionBodyContext* myParser::SetAccessorContext::functionBody() {
  return getRuleContext<myParser::FunctionBodyContext>(0);
}

tree::TerminalNode* myParser::SetAccessorContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

tree::TerminalNode* myParser::SetAccessorContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

myParser::BindingPatternContext* myParser::SetAccessorContext::bindingPattern() {
  return getRuleContext<myParser::BindingPatternContext>(0);
}

myParser::TypeAnnotationContext* myParser::SetAccessorContext::typeAnnotation() {
  return getRuleContext<myParser::TypeAnnotationContext>(0);
}


size_t myParser::SetAccessorContext::getRuleIndex() const {
  return myParser::RuleSetAccessor;
}

void myParser::SetAccessorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetAccessor(this);
}

void myParser::SetAccessorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetAccessor(this);
}

myParser::SetAccessorContext* myParser::setAccessor() {
  SetAccessorContext *_localctx = _tracker.createInstance<SetAccessorContext>(_ctx, getState());
  enterRule(_localctx, 240, myParser::RuleSetAccessor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1385);
    setter();
    setState(1386);
    match(myParser::OpenParen);
    setState(1389);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Identifier: {
        setState(1387);
        match(myParser::Identifier);
        break;
      }

      case myParser::OpenBracket:
      case myParser::OpenBrace: {
        setState(1388);
        bindingPattern();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1392);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Colon) {
      setState(1391);
      typeAnnotation();
    }
    setState(1394);
    match(myParser::CloseParen);
    setState(1395);
    match(myParser::OpenBrace);
    setState(1396);
    functionBody();
    setState(1397);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyNameContext ------------------------------------------------------------------

myParser::PropertyNameContext::PropertyNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::IdentifierNameContext* myParser::PropertyNameContext::identifierName() {
  return getRuleContext<myParser::IdentifierNameContext>(0);
}

tree::TerminalNode* myParser::PropertyNameContext::StringLiteral() {
  return getToken(myParser::StringLiteral, 0);
}

myParser::NumericLiteralContext* myParser::PropertyNameContext::numericLiteral() {
  return getRuleContext<myParser::NumericLiteralContext>(0);
}


size_t myParser::PropertyNameContext::getRuleIndex() const {
  return myParser::RulePropertyName;
}

void myParser::PropertyNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyName(this);
}

void myParser::PropertyNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyName(this);
}

myParser::PropertyNameContext* myParser::propertyName() {
  PropertyNameContext *_localctx = _tracker.createInstance<PropertyNameContext>(_ctx, getState());
  enterRule(_localctx, 242, myParser::RulePropertyName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1402);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::NullLiteral:
      case myParser::BooleanLiteral:
      case myParser::Break:
      case myParser::Do:
      case myParser::Instanceof:
      case myParser::Typeof:
      case myParser::Case:
      case myParser::Else:
      case myParser::New:
      case myParser::Var:
      case myParser::Catch:
      case myParser::Finally:
      case myParser::Return:
      case myParser::Void:
      case myParser::Continue:
      case myParser::For:
      case myParser::Switch:
      case myParser::While:
      case myParser::Debugger:
      case myParser::Function_:
      case myParser::This:
      case myParser::With:
      case myParser::Default:
      case myParser::If:
      case myParser::Throw:
      case myParser::Delete:
      case myParser::In:
      case myParser::Try:
      case myParser::From:
      case myParser::ReadOnly:
      case myParser::Async:
      case myParser::Class:
      case myParser::Enum:
      case myParser::Extends:
      case myParser::Super:
      case myParser::Const:
      case myParser::Export:
      case myParser::Import:
      case myParser::Implements:
      case myParser::Let:
      case myParser::Private:
      case myParser::Public:
      case myParser::Interface:
      case myParser::Package:
      case myParser::Protected:
      case myParser::Static:
      case myParser::Yield:
      case myParser::String:
      case myParser::TypeAlias:
      case myParser::Get:
      case myParser::Set:
      case myParser::Require:
      case myParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(1399);
        identifierName();
        break;
      }

      case myParser::StringLiteral: {
        enterOuterAlt(_localctx, 2);
        setState(1400);
        match(myParser::StringLiteral);
        break;
      }

      case myParser::DecimalLiteral:
      case myParser::HexIntegerLiteral:
      case myParser::OctalIntegerLiteral:
      case myParser::OctalIntegerLiteral2:
      case myParser::BinaryIntegerLiteral: {
        enterOuterAlt(_localctx, 3);
        setState(1401);
        numericLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentsContext ------------------------------------------------------------------

myParser::ArgumentsContext::ArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ArgumentsContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::ArgumentsContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::ArgumentListContext* myParser::ArgumentsContext::argumentList() {
  return getRuleContext<myParser::ArgumentListContext>(0);
}

tree::TerminalNode* myParser::ArgumentsContext::Comma() {
  return getToken(myParser::Comma, 0);
}


size_t myParser::ArgumentsContext::getRuleIndex() const {
  return myParser::RuleArguments;
}

void myParser::ArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArguments(this);
}

void myParser::ArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArguments(this);
}

myParser::ArgumentsContext* myParser::arguments() {
  ArgumentsContext *_localctx = _tracker.createInstance<ArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 244, myParser::RuleArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1404);
    match(myParser::OpenParen);
    setState(1409);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -36028795928641192) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 8092563910088982527) != 0)) {
      setState(1405);
      argumentList();
      setState(1407);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::Comma) {
        setState(1406);
        match(myParser::Comma);
      }
    }
    setState(1411);
    match(myParser::CloseParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentListContext ------------------------------------------------------------------

myParser::ArgumentListContext::ArgumentListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::ArgumentContext *> myParser::ArgumentListContext::argument() {
  return getRuleContexts<myParser::ArgumentContext>();
}

myParser::ArgumentContext* myParser::ArgumentListContext::argument(size_t i) {
  return getRuleContext<myParser::ArgumentContext>(i);
}

std::vector<tree::TerminalNode *> myParser::ArgumentListContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::ArgumentListContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::ArgumentListContext::getRuleIndex() const {
  return myParser::RuleArgumentList;
}

void myParser::ArgumentListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgumentList(this);
}

void myParser::ArgumentListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgumentList(this);
}

myParser::ArgumentListContext* myParser::argumentList() {
  ArgumentListContext *_localctx = _tracker.createInstance<ArgumentListContext>(_ctx, getState());
  enterRule(_localctx, 246, myParser::RuleArgumentList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1413);
    argument();
    setState(1418);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 180, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1414);
        match(myParser::Comma);
        setState(1415);
        argument(); 
      }
      setState(1420);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 180, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentContext ------------------------------------------------------------------

myParser::ArgumentContext::ArgumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SingleExpressionContext* myParser::ArgumentContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::ArgumentContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

tree::TerminalNode* myParser::ArgumentContext::Ellipsis() {
  return getToken(myParser::Ellipsis, 0);
}


size_t myParser::ArgumentContext::getRuleIndex() const {
  return myParser::RuleArgument;
}

void myParser::ArgumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgument(this);
}

void myParser::ArgumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgument(this);
}

myParser::ArgumentContext* myParser::argument() {
  ArgumentContext *_localctx = _tracker.createInstance<ArgumentContext>(_ctx, getState());
  enterRule(_localctx, 248, myParser::RuleArgument);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1422);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Ellipsis) {
      setState(1421);
      match(myParser::Ellipsis);
    }
    setState(1426);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 182, _ctx)) {
    case 1: {
      setState(1424);
      singleExpression(0);
      break;
    }

    case 2: {
      setState(1425);
      match(myParser::Identifier);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionSequenceContext ------------------------------------------------------------------

myParser::ExpressionSequenceContext::ExpressionSequenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<myParser::SingleExpressionContext *> myParser::ExpressionSequenceContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::ExpressionSequenceContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

std::vector<tree::TerminalNode *> myParser::ExpressionSequenceContext::Comma() {
  return getTokens(myParser::Comma);
}

tree::TerminalNode* myParser::ExpressionSequenceContext::Comma(size_t i) {
  return getToken(myParser::Comma, i);
}


size_t myParser::ExpressionSequenceContext::getRuleIndex() const {
  return myParser::RuleExpressionSequence;
}

void myParser::ExpressionSequenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionSequence(this);
}

void myParser::ExpressionSequenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionSequence(this);
}

myParser::ExpressionSequenceContext* myParser::expressionSequence() {
  ExpressionSequenceContext *_localctx = _tracker.createInstance<ExpressionSequenceContext>(_ctx, getState());
  enterRule(_localctx, 250, myParser::RuleExpressionSequence);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1428);
    singleExpression(0);
    setState(1433);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 183, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1429);
        match(myParser::Comma);
        setState(1430);
        singleExpression(0); 
      }
      setState(1435);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 183, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionExpressionDeclarationContext ------------------------------------------------------------------

myParser::FunctionExpressionDeclarationContext::FunctionExpressionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::FunctionExpressionDeclarationContext::Function_() {
  return getToken(myParser::Function_, 0);
}

tree::TerminalNode* myParser::FunctionExpressionDeclarationContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::FunctionExpressionDeclarationContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

tree::TerminalNode* myParser::FunctionExpressionDeclarationContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

myParser::FunctionBodyContext* myParser::FunctionExpressionDeclarationContext::functionBody() {
  return getRuleContext<myParser::FunctionBodyContext>(0);
}

tree::TerminalNode* myParser::FunctionExpressionDeclarationContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}

tree::TerminalNode* myParser::FunctionExpressionDeclarationContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

myParser::FormalParameterListContext* myParser::FunctionExpressionDeclarationContext::formalParameterList() {
  return getRuleContext<myParser::FormalParameterListContext>(0);
}

myParser::TypeAnnotationContext* myParser::FunctionExpressionDeclarationContext::typeAnnotation() {
  return getRuleContext<myParser::TypeAnnotationContext>(0);
}


size_t myParser::FunctionExpressionDeclarationContext::getRuleIndex() const {
  return myParser::RuleFunctionExpressionDeclaration;
}

void myParser::FunctionExpressionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionExpressionDeclaration(this);
}

void myParser::FunctionExpressionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionExpressionDeclaration(this);
}

myParser::FunctionExpressionDeclarationContext* myParser::functionExpressionDeclaration() {
  FunctionExpressionDeclarationContext *_localctx = _tracker.createInstance<FunctionExpressionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 252, myParser::RuleFunctionExpressionDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1436);
    match(myParser::Function_);
    setState(1438);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Identifier) {
      setState(1437);
      match(myParser::Identifier);
    }
    setState(1440);
    match(myParser::OpenParen);
    setState(1442);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 65808) != 0) || ((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 12718099) != 0)) {
      setState(1441);
      formalParameterList();
    }
    setState(1444);
    match(myParser::CloseParen);
    setState(1446);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Colon) {
      setState(1445);
      typeAnnotation();
    }
    setState(1448);
    match(myParser::OpenBrace);
    setState(1449);
    functionBody();
    setState(1450);
    match(myParser::CloseBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SingleExpressionContext ------------------------------------------------------------------

myParser::SingleExpressionContext::SingleExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t myParser::SingleExpressionContext::getRuleIndex() const {
  return myParser::RuleSingleExpression;
}

void myParser::SingleExpressionContext::copyFrom(SingleExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- TemplateStringExpressionContext ------------------------------------------------------------------

myParser::SingleExpressionContext* myParser::TemplateStringExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::TemplateStringLiteralContext* myParser::TemplateStringExpressionContext::templateStringLiteral() {
  return getRuleContext<myParser::TemplateStringLiteralContext>(0);
}

myParser::TemplateStringExpressionContext::TemplateStringExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::TemplateStringExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemplateStringExpression(this);
}
void myParser::TemplateStringExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemplateStringExpression(this);
}
//----------------- TernaryExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::TernaryExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::TernaryExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::TernaryExpressionContext::QuestionMark() {
  return getToken(myParser::QuestionMark, 0);
}

tree::TerminalNode* myParser::TernaryExpressionContext::Colon() {
  return getToken(myParser::Colon, 0);
}

myParser::TernaryExpressionContext::TernaryExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::TernaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTernaryExpression(this);
}
void myParser::TernaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTernaryExpression(this);
}
//----------------- LogicalAndExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::LogicalAndExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::LogicalAndExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::LogicalAndExpressionContext::And() {
  return getToken(myParser::And, 0);
}

myParser::LogicalAndExpressionContext::LogicalAndExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::LogicalAndExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalAndExpression(this);
}
void myParser::LogicalAndExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalAndExpression(this);
}
//----------------- GeneratorsExpressionContext ------------------------------------------------------------------

myParser::GeneratorBlockContext* myParser::GeneratorsExpressionContext::generatorBlock() {
  return getRuleContext<myParser::GeneratorBlockContext>(0);
}

myParser::GeneratorsExpressionContext::GeneratorsExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::GeneratorsExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneratorsExpression(this);
}
void myParser::GeneratorsExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneratorsExpression(this);
}
//----------------- PreIncrementExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::PreIncrementExpressionContext::PlusPlus() {
  return getToken(myParser::PlusPlus, 0);
}

myParser::SingleExpressionContext* myParser::PreIncrementExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::PreIncrementExpressionContext::PreIncrementExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::PreIncrementExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreIncrementExpression(this);
}
void myParser::PreIncrementExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreIncrementExpression(this);
}
//----------------- ObjectLiteralExpressionContext ------------------------------------------------------------------

myParser::ObjectLiteralContext* myParser::ObjectLiteralExpressionContext::objectLiteral() {
  return getRuleContext<myParser::ObjectLiteralContext>(0);
}

myParser::ObjectLiteralExpressionContext::ObjectLiteralExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::ObjectLiteralExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectLiteralExpression(this);
}
void myParser::ObjectLiteralExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectLiteralExpression(this);
}
//----------------- InExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::InExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::InExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::InExpressionContext::In() {
  return getToken(myParser::In, 0);
}

myParser::InExpressionContext::InExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::InExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInExpression(this);
}
void myParser::InExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInExpression(this);
}
//----------------- LogicalOrExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::LogicalOrExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::LogicalOrExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::LogicalOrExpressionContext::Or() {
  return getToken(myParser::Or, 0);
}

myParser::LogicalOrExpressionContext::LogicalOrExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::LogicalOrExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalOrExpression(this);
}
void myParser::LogicalOrExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalOrExpression(this);
}
//----------------- GenericTypesContext ------------------------------------------------------------------

myParser::TypeArgumentsContext* myParser::GenericTypesContext::typeArguments() {
  return getRuleContext<myParser::TypeArgumentsContext>(0);
}

myParser::ExpressionSequenceContext* myParser::GenericTypesContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

myParser::GenericTypesContext::GenericTypesContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::GenericTypesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericTypes(this);
}
void myParser::GenericTypesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericTypes(this);
}
//----------------- NotExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::NotExpressionContext::Not() {
  return getToken(myParser::Not, 0);
}

myParser::SingleExpressionContext* myParser::NotExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::NotExpressionContext::NotExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::NotExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNotExpression(this);
}
void myParser::NotExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNotExpression(this);
}
//----------------- PreDecreaseExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::PreDecreaseExpressionContext::MinusMinus() {
  return getToken(myParser::MinusMinus, 0);
}

myParser::SingleExpressionContext* myParser::PreDecreaseExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::PreDecreaseExpressionContext::PreDecreaseExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::PreDecreaseExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreDecreaseExpression(this);
}
void myParser::PreDecreaseExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreDecreaseExpression(this);
}
//----------------- ArgumentsExpressionContext ------------------------------------------------------------------

myParser::SingleExpressionContext* myParser::ArgumentsExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::ArgumentsContext* myParser::ArgumentsExpressionContext::arguments() {
  return getRuleContext<myParser::ArgumentsContext>(0);
}

myParser::ArgumentsExpressionContext::ArgumentsExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::ArgumentsExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgumentsExpression(this);
}
void myParser::ArgumentsExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgumentsExpression(this);
}
//----------------- ThisExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::ThisExpressionContext::This() {
  return getToken(myParser::This, 0);
}

myParser::ThisExpressionContext::ThisExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::ThisExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThisExpression(this);
}
void myParser::ThisExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThisExpression(this);
}
//----------------- FunctionExpressionContext ------------------------------------------------------------------

myParser::FunctionExpressionDeclarationContext* myParser::FunctionExpressionContext::functionExpressionDeclaration() {
  return getRuleContext<myParser::FunctionExpressionDeclarationContext>(0);
}

myParser::FunctionExpressionContext::FunctionExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::FunctionExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionExpression(this);
}
void myParser::FunctionExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionExpression(this);
}
//----------------- UnaryMinusExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::UnaryMinusExpressionContext::Minus() {
  return getToken(myParser::Minus, 0);
}

myParser::SingleExpressionContext* myParser::UnaryMinusExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::UnaryMinusExpressionContext::UnaryMinusExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::UnaryMinusExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryMinusExpression(this);
}
void myParser::UnaryMinusExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryMinusExpression(this);
}
//----------------- AssignmentExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::AssignmentExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::AssignmentExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::AssignmentExpressionContext::Assign() {
  return getToken(myParser::Assign, 0);
}

myParser::AssignmentExpressionContext::AssignmentExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::AssignmentExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentExpression(this);
}
void myParser::AssignmentExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentExpression(this);
}
//----------------- PostDecreaseExpressionContext ------------------------------------------------------------------

myParser::SingleExpressionContext* myParser::PostDecreaseExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::PostDecreaseExpressionContext::MinusMinus() {
  return getToken(myParser::MinusMinus, 0);
}

myParser::PostDecreaseExpressionContext::PostDecreaseExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::PostDecreaseExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostDecreaseExpression(this);
}
void myParser::PostDecreaseExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostDecreaseExpression(this);
}
//----------------- TypeofExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::TypeofExpressionContext::Typeof() {
  return getToken(myParser::Typeof, 0);
}

myParser::SingleExpressionContext* myParser::TypeofExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::TypeofExpressionContext::TypeofExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::TypeofExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeofExpression(this);
}
void myParser::TypeofExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeofExpression(this);
}
//----------------- InstanceofExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::InstanceofExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::InstanceofExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::InstanceofExpressionContext::Instanceof() {
  return getToken(myParser::Instanceof, 0);
}

myParser::InstanceofExpressionContext::InstanceofExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::InstanceofExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInstanceofExpression(this);
}
void myParser::InstanceofExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInstanceofExpression(this);
}
//----------------- UnaryPlusExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::UnaryPlusExpressionContext::Plus() {
  return getToken(myParser::Plus, 0);
}

myParser::SingleExpressionContext* myParser::UnaryPlusExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::UnaryPlusExpressionContext::UnaryPlusExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::UnaryPlusExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryPlusExpression(this);
}
void myParser::UnaryPlusExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryPlusExpression(this);
}
//----------------- DeleteExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::DeleteExpressionContext::Delete() {
  return getToken(myParser::Delete, 0);
}

myParser::SingleExpressionContext* myParser::DeleteExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::DeleteExpressionContext::DeleteExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::DeleteExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeleteExpression(this);
}
void myParser::DeleteExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeleteExpression(this);
}
//----------------- GeneratorsFunctionExpressionContext ------------------------------------------------------------------

myParser::GeneratorFunctionDeclarationContext* myParser::GeneratorsFunctionExpressionContext::generatorFunctionDeclaration() {
  return getRuleContext<myParser::GeneratorFunctionDeclarationContext>(0);
}

myParser::GeneratorsFunctionExpressionContext::GeneratorsFunctionExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::GeneratorsFunctionExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneratorsFunctionExpression(this);
}
void myParser::GeneratorsFunctionExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneratorsFunctionExpression(this);
}
//----------------- ArrowFunctionExpressionContext ------------------------------------------------------------------

myParser::ArrowFunctionDeclarationContext* myParser::ArrowFunctionExpressionContext::arrowFunctionDeclaration() {
  return getRuleContext<myParser::ArrowFunctionDeclarationContext>(0);
}

myParser::ArrowFunctionExpressionContext::ArrowFunctionExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::ArrowFunctionExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrowFunctionExpression(this);
}
void myParser::ArrowFunctionExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrowFunctionExpression(this);
}
//----------------- IteratorsExpressionContext ------------------------------------------------------------------

myParser::IteratorBlockContext* myParser::IteratorsExpressionContext::iteratorBlock() {
  return getRuleContext<myParser::IteratorBlockContext>(0);
}

myParser::IteratorsExpressionContext::IteratorsExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::IteratorsExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIteratorsExpression(this);
}
void myParser::IteratorsExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIteratorsExpression(this);
}
//----------------- EqualityExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::EqualityExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::EqualityExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::EqualityExpressionContext::Equals_() {
  return getToken(myParser::Equals_, 0);
}

tree::TerminalNode* myParser::EqualityExpressionContext::NotEquals() {
  return getToken(myParser::NotEquals, 0);
}

tree::TerminalNode* myParser::EqualityExpressionContext::IdentityEquals() {
  return getToken(myParser::IdentityEquals, 0);
}

tree::TerminalNode* myParser::EqualityExpressionContext::IdentityNotEquals() {
  return getToken(myParser::IdentityNotEquals, 0);
}

myParser::EqualityExpressionContext::EqualityExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::EqualityExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEqualityExpression(this);
}
void myParser::EqualityExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEqualityExpression(this);
}
//----------------- BitXOrExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::BitXOrExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::BitXOrExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::BitXOrExpressionContext::BitXOr() {
  return getToken(myParser::BitXOr, 0);
}

myParser::BitXOrExpressionContext::BitXOrExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::BitXOrExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitXOrExpression(this);
}
void myParser::BitXOrExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitXOrExpression(this);
}
//----------------- CastAsExpressionContext ------------------------------------------------------------------

myParser::SingleExpressionContext* myParser::CastAsExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::CastAsExpressionContext::As() {
  return getToken(myParser::As, 0);
}

myParser::AsExpressionContext* myParser::CastAsExpressionContext::asExpression() {
  return getRuleContext<myParser::AsExpressionContext>(0);
}

myParser::CastAsExpressionContext::CastAsExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::CastAsExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCastAsExpression(this);
}
void myParser::CastAsExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCastAsExpression(this);
}
//----------------- SuperExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::SuperExpressionContext::Super() {
  return getToken(myParser::Super, 0);
}

myParser::SuperExpressionContext::SuperExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::SuperExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSuperExpression(this);
}
void myParser::SuperExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSuperExpression(this);
}
//----------------- MultiplicativeExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::MultiplicativeExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::MultiplicativeExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::MultiplicativeExpressionContext::Multiply() {
  return getToken(myParser::Multiply, 0);
}

tree::TerminalNode* myParser::MultiplicativeExpressionContext::Divide() {
  return getToken(myParser::Divide, 0);
}

tree::TerminalNode* myParser::MultiplicativeExpressionContext::Modulus() {
  return getToken(myParser::Modulus, 0);
}

myParser::MultiplicativeExpressionContext::MultiplicativeExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::MultiplicativeExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiplicativeExpression(this);
}
void myParser::MultiplicativeExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiplicativeExpression(this);
}
//----------------- BitShiftExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::BitShiftExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::BitShiftExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::BitShiftExpressionContext::LeftShiftArithmetic() {
  return getToken(myParser::LeftShiftArithmetic, 0);
}

tree::TerminalNode* myParser::BitShiftExpressionContext::RightShiftArithmetic() {
  return getToken(myParser::RightShiftArithmetic, 0);
}

tree::TerminalNode* myParser::BitShiftExpressionContext::RightShiftLogical() {
  return getToken(myParser::RightShiftLogical, 0);
}

myParser::BitShiftExpressionContext::BitShiftExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::BitShiftExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitShiftExpression(this);
}
void myParser::BitShiftExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitShiftExpression(this);
}
//----------------- ParenthesizedExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::ParenthesizedExpressionContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

myParser::ExpressionSequenceContext* myParser::ParenthesizedExpressionContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::ParenthesizedExpressionContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::ParenthesizedExpressionContext::ParenthesizedExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::ParenthesizedExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParenthesizedExpression(this);
}
void myParser::ParenthesizedExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParenthesizedExpression(this);
}
//----------------- AdditiveExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::AdditiveExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::AdditiveExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::AdditiveExpressionContext::Plus() {
  return getToken(myParser::Plus, 0);
}

tree::TerminalNode* myParser::AdditiveExpressionContext::Minus() {
  return getToken(myParser::Minus, 0);
}

myParser::AdditiveExpressionContext::AdditiveExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::AdditiveExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAdditiveExpression(this);
}
void myParser::AdditiveExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAdditiveExpression(this);
}
//----------------- RelationalExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::RelationalExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::RelationalExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::RelationalExpressionContext::LessThan() {
  return getToken(myParser::LessThan, 0);
}

tree::TerminalNode* myParser::RelationalExpressionContext::MoreThan() {
  return getToken(myParser::MoreThan, 0);
}

tree::TerminalNode* myParser::RelationalExpressionContext::LessThanEquals() {
  return getToken(myParser::LessThanEquals, 0);
}

tree::TerminalNode* myParser::RelationalExpressionContext::GreaterThanEquals() {
  return getToken(myParser::GreaterThanEquals, 0);
}

myParser::RelationalExpressionContext::RelationalExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::RelationalExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelationalExpression(this);
}
void myParser::RelationalExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelationalExpression(this);
}
//----------------- PostIncrementExpressionContext ------------------------------------------------------------------

myParser::SingleExpressionContext* myParser::PostIncrementExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::PostIncrementExpressionContext::PlusPlus() {
  return getToken(myParser::PlusPlus, 0);
}

myParser::PostIncrementExpressionContext::PostIncrementExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::PostIncrementExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostIncrementExpression(this);
}
void myParser::PostIncrementExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostIncrementExpression(this);
}
//----------------- YieldExpressionContext ------------------------------------------------------------------

myParser::YieldStatementContext* myParser::YieldExpressionContext::yieldStatement() {
  return getRuleContext<myParser::YieldStatementContext>(0);
}

myParser::YieldExpressionContext::YieldExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::YieldExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterYieldExpression(this);
}
void myParser::YieldExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitYieldExpression(this);
}
//----------------- BitNotExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::BitNotExpressionContext::BitNot() {
  return getToken(myParser::BitNot, 0);
}

myParser::SingleExpressionContext* myParser::BitNotExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::BitNotExpressionContext::BitNotExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::BitNotExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitNotExpression(this);
}
void myParser::BitNotExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitNotExpression(this);
}
//----------------- NewExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::NewExpressionContext::New() {
  return getToken(myParser::New, 0);
}

myParser::SingleExpressionContext* myParser::NewExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::ArgumentsContext* myParser::NewExpressionContext::arguments() {
  return getRuleContext<myParser::ArgumentsContext>(0);
}

myParser::TypeArgumentsContext* myParser::NewExpressionContext::typeArguments() {
  return getRuleContext<myParser::TypeArgumentsContext>(0);
}

myParser::NewExpressionContext::NewExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::NewExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNewExpression(this);
}
void myParser::NewExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNewExpression(this);
}
//----------------- LiteralExpressionContext ------------------------------------------------------------------

myParser::LiteralContext* myParser::LiteralExpressionContext::literal() {
  return getRuleContext<myParser::LiteralContext>(0);
}

myParser::LiteralExpressionContext::LiteralExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::LiteralExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteralExpression(this);
}
void myParser::LiteralExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteralExpression(this);
}
//----------------- ArrayLiteralExpressionContext ------------------------------------------------------------------

myParser::ArrayLiteralContext* myParser::ArrayLiteralExpressionContext::arrayLiteral() {
  return getRuleContext<myParser::ArrayLiteralContext>(0);
}

myParser::ArrayLiteralExpressionContext::ArrayLiteralExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::ArrayLiteralExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayLiteralExpression(this);
}
void myParser::ArrayLiteralExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayLiteralExpression(this);
}
//----------------- MemberDotExpressionContext ------------------------------------------------------------------

myParser::SingleExpressionContext* myParser::MemberDotExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::MemberDotExpressionContext::Dot() {
  return getToken(myParser::Dot, 0);
}

myParser::IdentifierNameContext* myParser::MemberDotExpressionContext::identifierName() {
  return getRuleContext<myParser::IdentifierNameContext>(0);
}

myParser::NestedTypeGenericContext* myParser::MemberDotExpressionContext::nestedTypeGeneric() {
  return getRuleContext<myParser::NestedTypeGenericContext>(0);
}

myParser::MemberDotExpressionContext::MemberDotExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::MemberDotExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemberDotExpression(this);
}
void myParser::MemberDotExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemberDotExpression(this);
}
//----------------- ClassExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::ClassExpressionContext::Class() {
  return getToken(myParser::Class, 0);
}

myParser::ClassTailContext* myParser::ClassExpressionContext::classTail() {
  return getRuleContext<myParser::ClassTailContext>(0);
}

tree::TerminalNode* myParser::ClassExpressionContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

myParser::ClassExpressionContext::ClassExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::ClassExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassExpression(this);
}
void myParser::ClassExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassExpression(this);
}
//----------------- MemberIndexExpressionContext ------------------------------------------------------------------

myParser::SingleExpressionContext* myParser::MemberIndexExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::MemberIndexExpressionContext::OpenBracket() {
  return getToken(myParser::OpenBracket, 0);
}

myParser::ExpressionSequenceContext* myParser::MemberIndexExpressionContext::expressionSequence() {
  return getRuleContext<myParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* myParser::MemberIndexExpressionContext::CloseBracket() {
  return getToken(myParser::CloseBracket, 0);
}

myParser::MemberIndexExpressionContext::MemberIndexExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::MemberIndexExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemberIndexExpression(this);
}
void myParser::MemberIndexExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemberIndexExpression(this);
}
//----------------- IdentifierExpressionContext ------------------------------------------------------------------

myParser::IdentifierNameContext* myParser::IdentifierExpressionContext::identifierName() {
  return getRuleContext<myParser::IdentifierNameContext>(0);
}

myParser::SingleExpressionContext* myParser::IdentifierExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::IdentifierExpressionContext::IdentifierExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::IdentifierExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierExpression(this);
}
void myParser::IdentifierExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierExpression(this);
}
//----------------- BitAndExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::BitAndExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::BitAndExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::BitAndExpressionContext::BitAnd() {
  return getToken(myParser::BitAnd, 0);
}

myParser::BitAndExpressionContext::BitAndExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::BitAndExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitAndExpression(this);
}
void myParser::BitAndExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitAndExpression(this);
}
//----------------- BitOrExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::BitOrExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::BitOrExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

tree::TerminalNode* myParser::BitOrExpressionContext::BitOr() {
  return getToken(myParser::BitOr, 0);
}

myParser::BitOrExpressionContext::BitOrExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::BitOrExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitOrExpression(this);
}
void myParser::BitOrExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitOrExpression(this);
}
//----------------- AssignmentOperatorExpressionContext ------------------------------------------------------------------

std::vector<myParser::SingleExpressionContext *> myParser::AssignmentOperatorExpressionContext::singleExpression() {
  return getRuleContexts<myParser::SingleExpressionContext>();
}

myParser::SingleExpressionContext* myParser::AssignmentOperatorExpressionContext::singleExpression(size_t i) {
  return getRuleContext<myParser::SingleExpressionContext>(i);
}

myParser::AssignmentOperatorContext* myParser::AssignmentOperatorExpressionContext::assignmentOperator() {
  return getRuleContext<myParser::AssignmentOperatorContext>(0);
}

myParser::AssignmentOperatorExpressionContext::AssignmentOperatorExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::AssignmentOperatorExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentOperatorExpression(this);
}
void myParser::AssignmentOperatorExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentOperatorExpression(this);
}
//----------------- VoidExpressionContext ------------------------------------------------------------------

tree::TerminalNode* myParser::VoidExpressionContext::Void() {
  return getToken(myParser::Void, 0);
}

myParser::SingleExpressionContext* myParser::VoidExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

myParser::VoidExpressionContext::VoidExpressionContext(SingleExpressionContext *ctx) { copyFrom(ctx); }

void myParser::VoidExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVoidExpression(this);
}
void myParser::VoidExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVoidExpression(this);
}

myParser::SingleExpressionContext* myParser::singleExpression() {
   return singleExpression(0);
}

myParser::SingleExpressionContext* myParser::singleExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  myParser::SingleExpressionContext *_localctx = _tracker.createInstance<SingleExpressionContext>(_ctx, parentState);
  myParser::SingleExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 254;
  enterRecursionRule(_localctx, 254, myParser::RuleSingleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1511);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 192, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<FunctionExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(1453);
      functionExpressionDeclaration();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<ArrowFunctionExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1454);
      arrowFunctionDeclaration();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<ClassExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1455);
      match(myParser::Class);
      setState(1457);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::Identifier) {
        setState(1456);
        match(myParser::Identifier);
      }
      setState(1459);
      classTail();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<NewExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1460);
      match(myParser::New);
      setState(1461);
      singleExpression(0);
      setState(1463);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == myParser::LessThan) {
        setState(1462);
        typeArguments();
      }
      setState(1465);
      arguments();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<NewExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1467);
      match(myParser::New);
      setState(1468);
      singleExpression(0);
      setState(1470);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 189, _ctx)) {
      case 1: {
        setState(1469);
        typeArguments();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<DeleteExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1472);
      match(myParser::Delete);
      setState(1473);
      singleExpression(38);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<VoidExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1474);
      match(myParser::Void);
      setState(1475);
      singleExpression(37);
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<TypeofExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1476);
      match(myParser::Typeof);
      setState(1477);
      singleExpression(36);
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<PreIncrementExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1478);
      match(myParser::PlusPlus);
      setState(1479);
      singleExpression(35);
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<PreDecreaseExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1480);
      match(myParser::MinusMinus);
      setState(1481);
      singleExpression(34);
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<UnaryPlusExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1482);
      match(myParser::Plus);
      setState(1483);
      singleExpression(33);
      break;
    }

    case 12: {
      _localctx = _tracker.createInstance<UnaryMinusExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1484);
      match(myParser::Minus);
      setState(1485);
      singleExpression(32);
      break;
    }

    case 13: {
      _localctx = _tracker.createInstance<BitNotExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1486);
      match(myParser::BitNot);
      setState(1487);
      singleExpression(31);
      break;
    }

    case 14: {
      _localctx = _tracker.createInstance<NotExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1488);
      match(myParser::Not);
      setState(1489);
      singleExpression(30);
      break;
    }

    case 15: {
      _localctx = _tracker.createInstance<IteratorsExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1490);
      iteratorBlock();
      break;
    }

    case 16: {
      _localctx = _tracker.createInstance<GeneratorsExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1491);
      generatorBlock();
      break;
    }

    case 17: {
      _localctx = _tracker.createInstance<GeneratorsFunctionExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1492);
      generatorFunctionDeclaration();
      break;
    }

    case 18: {
      _localctx = _tracker.createInstance<YieldExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1493);
      yieldStatement();
      break;
    }

    case 19: {
      _localctx = _tracker.createInstance<ThisExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1494);
      match(myParser::This);
      break;
    }

    case 20: {
      _localctx = _tracker.createInstance<IdentifierExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1495);
      identifierName();
      setState(1497);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 190, _ctx)) {
      case 1: {
        setState(1496);
        singleExpression(0);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 21: {
      _localctx = _tracker.createInstance<SuperExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1499);
      match(myParser::Super);
      break;
    }

    case 22: {
      _localctx = _tracker.createInstance<LiteralExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1500);
      literal();
      break;
    }

    case 23: {
      _localctx = _tracker.createInstance<ArrayLiteralExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1501);
      arrayLiteral();
      break;
    }

    case 24: {
      _localctx = _tracker.createInstance<ObjectLiteralExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1502);
      objectLiteral();
      break;
    }

    case 25: {
      _localctx = _tracker.createInstance<ParenthesizedExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1503);
      match(myParser::OpenParen);
      setState(1504);
      expressionSequence();
      setState(1505);
      match(myParser::CloseParen);
      break;
    }

    case 26: {
      _localctx = _tracker.createInstance<GenericTypesContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1507);
      typeArguments();
      setState(1509);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 191, _ctx)) {
      case 1: {
        setState(1508);
        expressionSequence();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(1588);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 195, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(1586);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 194, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<MultiplicativeExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1513);

          if (!(precpred(_ctx, 29))) throw FailedPredicateException(this, "precpred(_ctx, 29)");
          setState(1514);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 117440512) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1515);
          singleExpression(30);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<AdditiveExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1516);

          if (!(precpred(_ctx, 28))) throw FailedPredicateException(this, "precpred(_ctx, 28)");
          setState(1517);
          _la = _input->LA(1);
          if (!(_la == myParser::Plus

          || _la == myParser::Minus)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1518);
          singleExpression(29);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<BitShiftExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1519);

          if (!(precpred(_ctx, 27))) throw FailedPredicateException(this, "precpred(_ctx, 27)");
          setState(1520);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 939524096) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1521);
          singleExpression(28);
          break;
        }

        case 4: {
          auto newContext = _tracker.createInstance<RelationalExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1522);

          if (!(precpred(_ctx, 26))) throw FailedPredicateException(this, "precpred(_ctx, 26)");
          setState(1523);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 16106127360) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1524);
          singleExpression(27);
          break;
        }

        case 5: {
          auto newContext = _tracker.createInstance<InstanceofExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1525);

          if (!(precpred(_ctx, 25))) throw FailedPredicateException(this, "precpred(_ctx, 25)");
          setState(1526);
          match(myParser::Instanceof);
          setState(1527);
          singleExpression(26);
          break;
        }

        case 6: {
          auto newContext = _tracker.createInstance<InExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1528);

          if (!(precpred(_ctx, 24))) throw FailedPredicateException(this, "precpred(_ctx, 24)");
          setState(1529);
          match(myParser::In);
          setState(1530);
          singleExpression(25);
          break;
        }

        case 7: {
          auto newContext = _tracker.createInstance<EqualityExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1531);

          if (!(precpred(_ctx, 23))) throw FailedPredicateException(this, "precpred(_ctx, 23)");
          setState(1532);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 257698037760) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1533);
          singleExpression(24);
          break;
        }

        case 8: {
          auto newContext = _tracker.createInstance<BitAndExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1534);

          if (!(precpred(_ctx, 22))) throw FailedPredicateException(this, "precpred(_ctx, 22)");
          setState(1535);
          match(myParser::BitAnd);
          setState(1536);
          singleExpression(23);
          break;
        }

        case 9: {
          auto newContext = _tracker.createInstance<BitXOrExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1537);

          if (!(precpred(_ctx, 21))) throw FailedPredicateException(this, "precpred(_ctx, 21)");
          setState(1538);
          match(myParser::BitXOr);
          setState(1539);
          singleExpression(22);
          break;
        }

        case 10: {
          auto newContext = _tracker.createInstance<BitOrExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1540);

          if (!(precpred(_ctx, 20))) throw FailedPredicateException(this, "precpred(_ctx, 20)");
          setState(1541);
          match(myParser::BitOr);
          setState(1542);
          singleExpression(21);
          break;
        }

        case 11: {
          auto newContext = _tracker.createInstance<LogicalAndExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1543);

          if (!(precpred(_ctx, 19))) throw FailedPredicateException(this, "precpred(_ctx, 19)");
          setState(1544);
          match(myParser::And);
          setState(1545);
          singleExpression(20);
          break;
        }

        case 12: {
          auto newContext = _tracker.createInstance<LogicalOrExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1546);

          if (!(precpred(_ctx, 18))) throw FailedPredicateException(this, "precpred(_ctx, 18)");
          setState(1547);
          match(myParser::Or);
          setState(1548);
          singleExpression(19);
          break;
        }

        case 13: {
          auto newContext = _tracker.createInstance<TernaryExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1549);

          if (!(precpred(_ctx, 17))) throw FailedPredicateException(this, "precpred(_ctx, 17)");
          setState(1550);
          match(myParser::QuestionMark);
          setState(1551);
          singleExpression(0);
          setState(1552);
          match(myParser::Colon);
          setState(1553);
          singleExpression(18);
          break;
        }

        case 14: {
          auto newContext = _tracker.createInstance<AssignmentExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1555);

          if (!(precpred(_ctx, 16))) throw FailedPredicateException(this, "precpred(_ctx, 16)");
          setState(1556);
          match(myParser::Assign);
          setState(1557);
          singleExpression(17);
          break;
        }

        case 15: {
          auto newContext = _tracker.createInstance<AssignmentOperatorExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1558);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(1559);
          assignmentOperator();
          setState(1560);
          singleExpression(16);
          break;
        }

        case 16: {
          auto newContext = _tracker.createInstance<MemberIndexExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1562);

          if (!(precpred(_ctx, 45))) throw FailedPredicateException(this, "precpred(_ctx, 45)");
          setState(1563);
          match(myParser::OpenBracket);
          setState(1564);
          expressionSequence();
          setState(1565);
          match(myParser::CloseBracket);
          break;
        }

        case 17: {
          auto newContext = _tracker.createInstance<MemberDotExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1567);

          if (!(precpred(_ctx, 44))) throw FailedPredicateException(this, "precpred(_ctx, 44)");
          setState(1568);
          match(myParser::Dot);
          setState(1569);
          identifierName();
          setState(1571);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 193, _ctx)) {
          case 1: {
            setState(1570);
            nestedTypeGeneric();
            break;
          }

          default:
            break;
          }
          break;
        }

        case 18: {
          auto newContext = _tracker.createInstance<ArgumentsExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1573);

          if (!(precpred(_ctx, 41))) throw FailedPredicateException(this, "precpred(_ctx, 41)");
          setState(1574);
          arguments();
          break;
        }

        case 19: {
          auto newContext = _tracker.createInstance<PostIncrementExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1575);

          if (!(precpred(_ctx, 40))) throw FailedPredicateException(this, "precpred(_ctx, 40)");
          setState(1576);

          if (!(this.notLineTerminator())) throw FailedPredicateException(this, "this.notLineTerminator()");
          setState(1577);
          match(myParser::PlusPlus);
          break;
        }

        case 20: {
          auto newContext = _tracker.createInstance<PostDecreaseExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1578);

          if (!(precpred(_ctx, 39))) throw FailedPredicateException(this, "precpred(_ctx, 39)");
          setState(1579);

          if (!(this.notLineTerminator())) throw FailedPredicateException(this, "this.notLineTerminator()");
          setState(1580);
          match(myParser::MinusMinus);
          break;
        }

        case 21: {
          auto newContext = _tracker.createInstance<TemplateStringExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1581);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(1582);
          templateStringLiteral();
          break;
        }

        case 22: {
          auto newContext = _tracker.createInstance<CastAsExpressionContext>(_tracker.createInstance<SingleExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSingleExpression);
          setState(1583);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(1584);
          match(myParser::As);
          setState(1585);
          asExpression();
          break;
        }

        default:
          break;
        } 
      }
      setState(1590);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 195, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- AsExpressionContext ------------------------------------------------------------------

myParser::AsExpressionContext::AsExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::PredefinedTypeContext* myParser::AsExpressionContext::predefinedType() {
  return getRuleContext<myParser::PredefinedTypeContext>(0);
}

tree::TerminalNode* myParser::AsExpressionContext::OpenBracket() {
  return getToken(myParser::OpenBracket, 0);
}

tree::TerminalNode* myParser::AsExpressionContext::CloseBracket() {
  return getToken(myParser::CloseBracket, 0);
}

myParser::SingleExpressionContext* myParser::AsExpressionContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}


size_t myParser::AsExpressionContext::getRuleIndex() const {
  return myParser::RuleAsExpression;
}

void myParser::AsExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAsExpression(this);
}

void myParser::AsExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAsExpression(this);
}

myParser::AsExpressionContext* myParser::asExpression() {
  AsExpressionContext *_localctx = _tracker.createInstance<AsExpressionContext>(_ctx, getState());
  enterRule(_localctx, 256, myParser::RuleAsExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1597);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 197, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1591);
      predefinedType();
      setState(1594);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 196, _ctx)) {
      case 1: {
        setState(1592);
        match(myParser::OpenBracket);
        setState(1593);
        match(myParser::CloseBracket);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1596);
      singleExpression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrowFunctionDeclarationContext ------------------------------------------------------------------

myParser::ArrowFunctionDeclarationContext::ArrowFunctionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::ArrowFunctionParametersContext* myParser::ArrowFunctionDeclarationContext::arrowFunctionParameters() {
  return getRuleContext<myParser::ArrowFunctionParametersContext>(0);
}

tree::TerminalNode* myParser::ArrowFunctionDeclarationContext::ARROW() {
  return getToken(myParser::ARROW, 0);
}

myParser::ArrowFunctionBodyContext* myParser::ArrowFunctionDeclarationContext::arrowFunctionBody() {
  return getRuleContext<myParser::ArrowFunctionBodyContext>(0);
}

tree::TerminalNode* myParser::ArrowFunctionDeclarationContext::Async() {
  return getToken(myParser::Async, 0);
}

myParser::TypeAnnotationContext* myParser::ArrowFunctionDeclarationContext::typeAnnotation() {
  return getRuleContext<myParser::TypeAnnotationContext>(0);
}


size_t myParser::ArrowFunctionDeclarationContext::getRuleIndex() const {
  return myParser::RuleArrowFunctionDeclaration;
}

void myParser::ArrowFunctionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrowFunctionDeclaration(this);
}

void myParser::ArrowFunctionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrowFunctionDeclaration(this);
}

myParser::ArrowFunctionDeclarationContext* myParser::arrowFunctionDeclaration() {
  ArrowFunctionDeclarationContext *_localctx = _tracker.createInstance<ArrowFunctionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 258, myParser::RuleArrowFunctionDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1600);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Async) {
      setState(1599);
      match(myParser::Async);
    }
    setState(1602);
    arrowFunctionParameters();
    setState(1604);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == myParser::Colon) {
      setState(1603);
      typeAnnotation();
    }
    setState(1606);
    match(myParser::ARROW);
    setState(1607);
    arrowFunctionBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrowFunctionParametersContext ------------------------------------------------------------------

myParser::ArrowFunctionParametersContext::ArrowFunctionParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::ArrowFunctionParametersContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

tree::TerminalNode* myParser::ArrowFunctionParametersContext::OpenParen() {
  return getToken(myParser::OpenParen, 0);
}

tree::TerminalNode* myParser::ArrowFunctionParametersContext::CloseParen() {
  return getToken(myParser::CloseParen, 0);
}

myParser::FormalParameterListContext* myParser::ArrowFunctionParametersContext::formalParameterList() {
  return getRuleContext<myParser::FormalParameterListContext>(0);
}


size_t myParser::ArrowFunctionParametersContext::getRuleIndex() const {
  return myParser::RuleArrowFunctionParameters;
}

void myParser::ArrowFunctionParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrowFunctionParameters(this);
}

void myParser::ArrowFunctionParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrowFunctionParameters(this);
}

myParser::ArrowFunctionParametersContext* myParser::arrowFunctionParameters() {
  ArrowFunctionParametersContext *_localctx = _tracker.createInstance<ArrowFunctionParametersContext>(_ctx, getState());
  enterRule(_localctx, 260, myParser::RuleArrowFunctionParameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1615);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(1609);
        match(myParser::Identifier);
        break;
      }

      case myParser::OpenParen: {
        enterOuterAlt(_localctx, 2);
        setState(1610);
        match(myParser::OpenParen);
        setState(1612);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 65808) != 0) || ((((_la - 101) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 101)) & 12718099) != 0)) {
          setState(1611);
          formalParameterList();
        }
        setState(1614);
        match(myParser::CloseParen);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrowFunctionBodyContext ------------------------------------------------------------------

myParser::ArrowFunctionBodyContext::ArrowFunctionBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::SingleExpressionContext* myParser::ArrowFunctionBodyContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::ArrowFunctionBodyContext::OpenBrace() {
  return getToken(myParser::OpenBrace, 0);
}

myParser::FunctionBodyContext* myParser::ArrowFunctionBodyContext::functionBody() {
  return getRuleContext<myParser::FunctionBodyContext>(0);
}

tree::TerminalNode* myParser::ArrowFunctionBodyContext::CloseBrace() {
  return getToken(myParser::CloseBrace, 0);
}


size_t myParser::ArrowFunctionBodyContext::getRuleIndex() const {
  return myParser::RuleArrowFunctionBody;
}

void myParser::ArrowFunctionBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrowFunctionBody(this);
}

void myParser::ArrowFunctionBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrowFunctionBody(this);
}

myParser::ArrowFunctionBodyContext* myParser::arrowFunctionBody() {
  ArrowFunctionBodyContext *_localctx = _tracker.createInstance<ArrowFunctionBodyContext>(_ctx, getState());
  enterRule(_localctx, 262, myParser::RuleArrowFunctionBody);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1622);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 202, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1617);
      singleExpression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1618);
      match(myParser::OpenBrace);
      setState(1619);
      functionBody();
      setState(1620);
      match(myParser::CloseBrace);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentOperatorContext ------------------------------------------------------------------

myParser::AssignmentOperatorContext::AssignmentOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::AssignmentOperatorContext::MultiplyAssign() {
  return getToken(myParser::MultiplyAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::DivideAssign() {
  return getToken(myParser::DivideAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::ModulusAssign() {
  return getToken(myParser::ModulusAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::PlusAssign() {
  return getToken(myParser::PlusAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::MinusAssign() {
  return getToken(myParser::MinusAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::LeftShiftArithmeticAssign() {
  return getToken(myParser::LeftShiftArithmeticAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::RightShiftArithmeticAssign() {
  return getToken(myParser::RightShiftArithmeticAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::RightShiftLogicalAssign() {
  return getToken(myParser::RightShiftLogicalAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::BitAndAssign() {
  return getToken(myParser::BitAndAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::BitXorAssign() {
  return getToken(myParser::BitXorAssign, 0);
}

tree::TerminalNode* myParser::AssignmentOperatorContext::BitOrAssign() {
  return getToken(myParser::BitOrAssign, 0);
}


size_t myParser::AssignmentOperatorContext::getRuleIndex() const {
  return myParser::RuleAssignmentOperator;
}

void myParser::AssignmentOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentOperator(this);
}

void myParser::AssignmentOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentOperator(this);
}

myParser::AssignmentOperatorContext* myParser::assignmentOperator() {
  AssignmentOperatorContext *_localctx = _tracker.createInstance<AssignmentOperatorContext>(_ctx, getState());
  enterRule(_localctx, 264, myParser::RuleAssignmentOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1624);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 18005602416459776) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

myParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::LiteralContext::NullLiteral() {
  return getToken(myParser::NullLiteral, 0);
}

tree::TerminalNode* myParser::LiteralContext::BooleanLiteral() {
  return getToken(myParser::BooleanLiteral, 0);
}

tree::TerminalNode* myParser::LiteralContext::StringLiteral() {
  return getToken(myParser::StringLiteral, 0);
}

myParser::TemplateStringLiteralContext* myParser::LiteralContext::templateStringLiteral() {
  return getRuleContext<myParser::TemplateStringLiteralContext>(0);
}

tree::TerminalNode* myParser::LiteralContext::RegularExpressionLiteral() {
  return getToken(myParser::RegularExpressionLiteral, 0);
}

myParser::NumericLiteralContext* myParser::LiteralContext::numericLiteral() {
  return getRuleContext<myParser::NumericLiteralContext>(0);
}


size_t myParser::LiteralContext::getRuleIndex() const {
  return myParser::RuleLiteral;
}

void myParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void myParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}

myParser::LiteralContext* myParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 266, myParser::RuleLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1632);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::NullLiteral: {
        enterOuterAlt(_localctx, 1);
        setState(1626);
        match(myParser::NullLiteral);
        break;
      }

      case myParser::BooleanLiteral: {
        enterOuterAlt(_localctx, 2);
        setState(1627);
        match(myParser::BooleanLiteral);
        break;
      }

      case myParser::StringLiteral: {
        enterOuterAlt(_localctx, 3);
        setState(1628);
        match(myParser::StringLiteral);
        break;
      }

      case myParser::BackTick: {
        enterOuterAlt(_localctx, 4);
        setState(1629);
        templateStringLiteral();
        break;
      }

      case myParser::RegularExpressionLiteral: {
        enterOuterAlt(_localctx, 5);
        setState(1630);
        match(myParser::RegularExpressionLiteral);
        break;
      }

      case myParser::DecimalLiteral:
      case myParser::HexIntegerLiteral:
      case myParser::OctalIntegerLiteral:
      case myParser::OctalIntegerLiteral2:
      case myParser::BinaryIntegerLiteral: {
        enterOuterAlt(_localctx, 6);
        setState(1631);
        numericLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemplateStringLiteralContext ------------------------------------------------------------------

myParser::TemplateStringLiteralContext::TemplateStringLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> myParser::TemplateStringLiteralContext::BackTick() {
  return getTokens(myParser::BackTick);
}

tree::TerminalNode* myParser::TemplateStringLiteralContext::BackTick(size_t i) {
  return getToken(myParser::BackTick, i);
}

std::vector<myParser::TemplateStringAtomContext *> myParser::TemplateStringLiteralContext::templateStringAtom() {
  return getRuleContexts<myParser::TemplateStringAtomContext>();
}

myParser::TemplateStringAtomContext* myParser::TemplateStringLiteralContext::templateStringAtom(size_t i) {
  return getRuleContext<myParser::TemplateStringAtomContext>(i);
}


size_t myParser::TemplateStringLiteralContext::getRuleIndex() const {
  return myParser::RuleTemplateStringLiteral;
}

void myParser::TemplateStringLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemplateStringLiteral(this);
}

void myParser::TemplateStringLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemplateStringLiteral(this);
}

myParser::TemplateStringLiteralContext* myParser::templateStringLiteral() {
  TemplateStringLiteralContext *_localctx = _tracker.createInstance<TemplateStringLiteralContext>(_ctx, getState());
  enterRule(_localctx, 268, myParser::RuleTemplateStringLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1634);
    match(myParser::BackTick);
    setState(1638);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == myParser::TemplateStringStartExpression

    || _la == myParser::TemplateStringAtom) {
      setState(1635);
      templateStringAtom();
      setState(1640);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1641);
    match(myParser::BackTick);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemplateStringAtomContext ------------------------------------------------------------------

myParser::TemplateStringAtomContext::TemplateStringAtomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::TemplateStringAtomContext::TemplateStringAtom() {
  return getToken(myParser::TemplateStringAtom, 0);
}

tree::TerminalNode* myParser::TemplateStringAtomContext::TemplateStringStartExpression() {
  return getToken(myParser::TemplateStringStartExpression, 0);
}

myParser::SingleExpressionContext* myParser::TemplateStringAtomContext::singleExpression() {
  return getRuleContext<myParser::SingleExpressionContext>(0);
}

tree::TerminalNode* myParser::TemplateStringAtomContext::TemplateCloseBrace() {
  return getToken(myParser::TemplateCloseBrace, 0);
}


size_t myParser::TemplateStringAtomContext::getRuleIndex() const {
  return myParser::RuleTemplateStringAtom;
}

void myParser::TemplateStringAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemplateStringAtom(this);
}

void myParser::TemplateStringAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemplateStringAtom(this);
}

myParser::TemplateStringAtomContext* myParser::templateStringAtom() {
  TemplateStringAtomContext *_localctx = _tracker.createInstance<TemplateStringAtomContext>(_ctx, getState());
  enterRule(_localctx, 270, myParser::RuleTemplateStringAtom);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1648);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::TemplateStringAtom: {
        enterOuterAlt(_localctx, 1);
        setState(1643);
        match(myParser::TemplateStringAtom);
        break;
      }

      case myParser::TemplateStringStartExpression: {
        enterOuterAlt(_localctx, 2);
        setState(1644);
        match(myParser::TemplateStringStartExpression);
        setState(1645);
        singleExpression(0);
        setState(1646);
        match(myParser::TemplateCloseBrace);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericLiteralContext ------------------------------------------------------------------

myParser::NumericLiteralContext::NumericLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::NumericLiteralContext::DecimalLiteral() {
  return getToken(myParser::DecimalLiteral, 0);
}

tree::TerminalNode* myParser::NumericLiteralContext::HexIntegerLiteral() {
  return getToken(myParser::HexIntegerLiteral, 0);
}

tree::TerminalNode* myParser::NumericLiteralContext::OctalIntegerLiteral() {
  return getToken(myParser::OctalIntegerLiteral, 0);
}

tree::TerminalNode* myParser::NumericLiteralContext::OctalIntegerLiteral2() {
  return getToken(myParser::OctalIntegerLiteral2, 0);
}

tree::TerminalNode* myParser::NumericLiteralContext::BinaryIntegerLiteral() {
  return getToken(myParser::BinaryIntegerLiteral, 0);
}


size_t myParser::NumericLiteralContext::getRuleIndex() const {
  return myParser::RuleNumericLiteral;
}

void myParser::NumericLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericLiteral(this);
}

void myParser::NumericLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericLiteral(this);
}

myParser::NumericLiteralContext* myParser::numericLiteral() {
  NumericLiteralContext *_localctx = _tracker.createInstance<NumericLiteralContext>(_ctx, getState());
  enterRule(_localctx, 272, myParser::RuleNumericLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1650);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4467570830351532032) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierNameContext ------------------------------------------------------------------

myParser::IdentifierNameContext::IdentifierNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::IdentifierNameContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

myParser::ReservedWordContext* myParser::IdentifierNameContext::reservedWord() {
  return getRuleContext<myParser::ReservedWordContext>(0);
}


size_t myParser::IdentifierNameContext::getRuleIndex() const {
  return myParser::RuleIdentifierName;
}

void myParser::IdentifierNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierName(this);
}

void myParser::IdentifierNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierName(this);
}

myParser::IdentifierNameContext* myParser::identifierName() {
  IdentifierNameContext *_localctx = _tracker.createInstance<IdentifierNameContext>(_ctx, getState());
  enterRule(_localctx, 274, myParser::RuleIdentifierName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1654);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(1652);
        match(myParser::Identifier);
        break;
      }

      case myParser::NullLiteral:
      case myParser::BooleanLiteral:
      case myParser::Break:
      case myParser::Do:
      case myParser::Instanceof:
      case myParser::Typeof:
      case myParser::Case:
      case myParser::Else:
      case myParser::New:
      case myParser::Var:
      case myParser::Catch:
      case myParser::Finally:
      case myParser::Return:
      case myParser::Void:
      case myParser::Continue:
      case myParser::For:
      case myParser::Switch:
      case myParser::While:
      case myParser::Debugger:
      case myParser::Function_:
      case myParser::This:
      case myParser::With:
      case myParser::Default:
      case myParser::If:
      case myParser::Throw:
      case myParser::Delete:
      case myParser::In:
      case myParser::Try:
      case myParser::From:
      case myParser::ReadOnly:
      case myParser::Async:
      case myParser::Class:
      case myParser::Enum:
      case myParser::Extends:
      case myParser::Super:
      case myParser::Const:
      case myParser::Export:
      case myParser::Import:
      case myParser::Implements:
      case myParser::Let:
      case myParser::Private:
      case myParser::Public:
      case myParser::Interface:
      case myParser::Package:
      case myParser::Protected:
      case myParser::Static:
      case myParser::Yield:
      case myParser::String:
      case myParser::TypeAlias:
      case myParser::Get:
      case myParser::Set:
      case myParser::Require: {
        enterOuterAlt(_localctx, 2);
        setState(1653);
        reservedWord();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierOrKeyWordContext ------------------------------------------------------------------

myParser::IdentifierOrKeyWordContext::IdentifierOrKeyWordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::IdentifierOrKeyWordContext::Identifier() {
  return getToken(myParser::Identifier, 0);
}

tree::TerminalNode* myParser::IdentifierOrKeyWordContext::TypeAlias() {
  return getToken(myParser::TypeAlias, 0);
}

tree::TerminalNode* myParser::IdentifierOrKeyWordContext::Require() {
  return getToken(myParser::Require, 0);
}


size_t myParser::IdentifierOrKeyWordContext::getRuleIndex() const {
  return myParser::RuleIdentifierOrKeyWord;
}

void myParser::IdentifierOrKeyWordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierOrKeyWord(this);
}

void myParser::IdentifierOrKeyWordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierOrKeyWord(this);
}

myParser::IdentifierOrKeyWordContext* myParser::identifierOrKeyWord() {
  IdentifierOrKeyWordContext *_localctx = _tracker.createInstance<IdentifierOrKeyWordContext>(_ctx, getState());
  enterRule(_localctx, 276, myParser::RuleIdentifierOrKeyWord);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1656);
    _la = _input->LA(1);
    if (!(((((_la - 113) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 113)) & 2081) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReservedWordContext ------------------------------------------------------------------

myParser::ReservedWordContext::ReservedWordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

myParser::KeywordContext* myParser::ReservedWordContext::keyword() {
  return getRuleContext<myParser::KeywordContext>(0);
}

tree::TerminalNode* myParser::ReservedWordContext::NullLiteral() {
  return getToken(myParser::NullLiteral, 0);
}

tree::TerminalNode* myParser::ReservedWordContext::BooleanLiteral() {
  return getToken(myParser::BooleanLiteral, 0);
}


size_t myParser::ReservedWordContext::getRuleIndex() const {
  return myParser::RuleReservedWord;
}

void myParser::ReservedWordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReservedWord(this);
}

void myParser::ReservedWordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReservedWord(this);
}

myParser::ReservedWordContext* myParser::reservedWord() {
  ReservedWordContext *_localctx = _tracker.createInstance<ReservedWordContext>(_ctx, getState());
  enterRule(_localctx, 278, myParser::RuleReservedWord);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1661);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case myParser::Break:
      case myParser::Do:
      case myParser::Instanceof:
      case myParser::Typeof:
      case myParser::Case:
      case myParser::Else:
      case myParser::New:
      case myParser::Var:
      case myParser::Catch:
      case myParser::Finally:
      case myParser::Return:
      case myParser::Void:
      case myParser::Continue:
      case myParser::For:
      case myParser::Switch:
      case myParser::While:
      case myParser::Debugger:
      case myParser::Function_:
      case myParser::This:
      case myParser::With:
      case myParser::Default:
      case myParser::If:
      case myParser::Throw:
      case myParser::Delete:
      case myParser::In:
      case myParser::Try:
      case myParser::From:
      case myParser::ReadOnly:
      case myParser::Async:
      case myParser::Class:
      case myParser::Enum:
      case myParser::Extends:
      case myParser::Super:
      case myParser::Const:
      case myParser::Export:
      case myParser::Import:
      case myParser::Implements:
      case myParser::Let:
      case myParser::Private:
      case myParser::Public:
      case myParser::Interface:
      case myParser::Package:
      case myParser::Protected:
      case myParser::Static:
      case myParser::Yield:
      case myParser::String:
      case myParser::TypeAlias:
      case myParser::Get:
      case myParser::Set:
      case myParser::Require: {
        enterOuterAlt(_localctx, 1);
        setState(1658);
        keyword();
        break;
      }

      case myParser::NullLiteral: {
        enterOuterAlt(_localctx, 2);
        setState(1659);
        match(myParser::NullLiteral);
        break;
      }

      case myParser::BooleanLiteral: {
        enterOuterAlt(_localctx, 3);
        setState(1660);
        match(myParser::BooleanLiteral);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeywordContext ------------------------------------------------------------------

myParser::KeywordContext::KeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::KeywordContext::Break() {
  return getToken(myParser::Break, 0);
}

tree::TerminalNode* myParser::KeywordContext::Do() {
  return getToken(myParser::Do, 0);
}

tree::TerminalNode* myParser::KeywordContext::Instanceof() {
  return getToken(myParser::Instanceof, 0);
}

tree::TerminalNode* myParser::KeywordContext::Typeof() {
  return getToken(myParser::Typeof, 0);
}

tree::TerminalNode* myParser::KeywordContext::Case() {
  return getToken(myParser::Case, 0);
}

tree::TerminalNode* myParser::KeywordContext::Else() {
  return getToken(myParser::Else, 0);
}

tree::TerminalNode* myParser::KeywordContext::New() {
  return getToken(myParser::New, 0);
}

tree::TerminalNode* myParser::KeywordContext::Var() {
  return getToken(myParser::Var, 0);
}

tree::TerminalNode* myParser::KeywordContext::Catch() {
  return getToken(myParser::Catch, 0);
}

tree::TerminalNode* myParser::KeywordContext::Finally() {
  return getToken(myParser::Finally, 0);
}

tree::TerminalNode* myParser::KeywordContext::Return() {
  return getToken(myParser::Return, 0);
}

tree::TerminalNode* myParser::KeywordContext::Void() {
  return getToken(myParser::Void, 0);
}

tree::TerminalNode* myParser::KeywordContext::Continue() {
  return getToken(myParser::Continue, 0);
}

tree::TerminalNode* myParser::KeywordContext::For() {
  return getToken(myParser::For, 0);
}

tree::TerminalNode* myParser::KeywordContext::Switch() {
  return getToken(myParser::Switch, 0);
}

tree::TerminalNode* myParser::KeywordContext::While() {
  return getToken(myParser::While, 0);
}

tree::TerminalNode* myParser::KeywordContext::Debugger() {
  return getToken(myParser::Debugger, 0);
}

tree::TerminalNode* myParser::KeywordContext::Function_() {
  return getToken(myParser::Function_, 0);
}

tree::TerminalNode* myParser::KeywordContext::This() {
  return getToken(myParser::This, 0);
}

tree::TerminalNode* myParser::KeywordContext::With() {
  return getToken(myParser::With, 0);
}

tree::TerminalNode* myParser::KeywordContext::Default() {
  return getToken(myParser::Default, 0);
}

tree::TerminalNode* myParser::KeywordContext::If() {
  return getToken(myParser::If, 0);
}

tree::TerminalNode* myParser::KeywordContext::Throw() {
  return getToken(myParser::Throw, 0);
}

tree::TerminalNode* myParser::KeywordContext::Delete() {
  return getToken(myParser::Delete, 0);
}

tree::TerminalNode* myParser::KeywordContext::In() {
  return getToken(myParser::In, 0);
}

tree::TerminalNode* myParser::KeywordContext::Try() {
  return getToken(myParser::Try, 0);
}

tree::TerminalNode* myParser::KeywordContext::ReadOnly() {
  return getToken(myParser::ReadOnly, 0);
}

tree::TerminalNode* myParser::KeywordContext::Async() {
  return getToken(myParser::Async, 0);
}

tree::TerminalNode* myParser::KeywordContext::From() {
  return getToken(myParser::From, 0);
}

tree::TerminalNode* myParser::KeywordContext::Class() {
  return getToken(myParser::Class, 0);
}

tree::TerminalNode* myParser::KeywordContext::Enum() {
  return getToken(myParser::Enum, 0);
}

tree::TerminalNode* myParser::KeywordContext::Extends() {
  return getToken(myParser::Extends, 0);
}

tree::TerminalNode* myParser::KeywordContext::Super() {
  return getToken(myParser::Super, 0);
}

tree::TerminalNode* myParser::KeywordContext::Const() {
  return getToken(myParser::Const, 0);
}

tree::TerminalNode* myParser::KeywordContext::Export() {
  return getToken(myParser::Export, 0);
}

tree::TerminalNode* myParser::KeywordContext::Import() {
  return getToken(myParser::Import, 0);
}

tree::TerminalNode* myParser::KeywordContext::Implements() {
  return getToken(myParser::Implements, 0);
}

tree::TerminalNode* myParser::KeywordContext::Let() {
  return getToken(myParser::Let, 0);
}

tree::TerminalNode* myParser::KeywordContext::Private() {
  return getToken(myParser::Private, 0);
}

tree::TerminalNode* myParser::KeywordContext::Public() {
  return getToken(myParser::Public, 0);
}

tree::TerminalNode* myParser::KeywordContext::Interface() {
  return getToken(myParser::Interface, 0);
}

tree::TerminalNode* myParser::KeywordContext::Package() {
  return getToken(myParser::Package, 0);
}

tree::TerminalNode* myParser::KeywordContext::Protected() {
  return getToken(myParser::Protected, 0);
}

tree::TerminalNode* myParser::KeywordContext::Static() {
  return getToken(myParser::Static, 0);
}

tree::TerminalNode* myParser::KeywordContext::Yield() {
  return getToken(myParser::Yield, 0);
}

tree::TerminalNode* myParser::KeywordContext::Get() {
  return getToken(myParser::Get, 0);
}

tree::TerminalNode* myParser::KeywordContext::Set() {
  return getToken(myParser::Set, 0);
}

tree::TerminalNode* myParser::KeywordContext::Require() {
  return getToken(myParser::Require, 0);
}

tree::TerminalNode* myParser::KeywordContext::TypeAlias() {
  return getToken(myParser::TypeAlias, 0);
}

tree::TerminalNode* myParser::KeywordContext::String() {
  return getToken(myParser::String, 0);
}


size_t myParser::KeywordContext::getRuleIndex() const {
  return myParser::RuleKeyword;
}

void myParser::KeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword(this);
}

void myParser::KeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword(this);
}

myParser::KeywordContext* myParser::keyword() {
  KeywordContext *_localctx = _tracker.createInstance<KeywordContext>(_ctx, getState());
  enterRule(_localctx, 280, myParser::RuleKeyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1663);
    _la = _input->LA(1);
    if (!(((((_la - 62) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 62)) & 88453511364214783) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GetterContext ------------------------------------------------------------------

myParser::GetterContext::GetterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::GetterContext::Get() {
  return getToken(myParser::Get, 0);
}

myParser::PropertyNameContext* myParser::GetterContext::propertyName() {
  return getRuleContext<myParser::PropertyNameContext>(0);
}


size_t myParser::GetterContext::getRuleIndex() const {
  return myParser::RuleGetter;
}

void myParser::GetterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGetter(this);
}

void myParser::GetterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGetter(this);
}

myParser::GetterContext* myParser::getter() {
  GetterContext *_localctx = _tracker.createInstance<GetterContext>(_ctx, getState());
  enterRule(_localctx, 282, myParser::RuleGetter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1665);
    match(myParser::Get);
    setState(1666);
    propertyName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetterContext ------------------------------------------------------------------

myParser::SetterContext::SetterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::SetterContext::Set() {
  return getToken(myParser::Set, 0);
}

myParser::PropertyNameContext* myParser::SetterContext::propertyName() {
  return getRuleContext<myParser::PropertyNameContext>(0);
}


size_t myParser::SetterContext::getRuleIndex() const {
  return myParser::RuleSetter;
}

void myParser::SetterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetter(this);
}

void myParser::SetterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetter(this);
}

myParser::SetterContext* myParser::setter() {
  SetterContext *_localctx = _tracker.createInstance<SetterContext>(_ctx, getState());
  enterRule(_localctx, 284, myParser::RuleSetter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1668);
    match(myParser::Set);
    setState(1669);
    propertyName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EosContext ------------------------------------------------------------------

myParser::EosContext::EosContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* myParser::EosContext::SemiColon() {
  return getToken(myParser::SemiColon, 0);
}

tree::TerminalNode* myParser::EosContext::EOF() {
  return getToken(myParser::EOF, 0);
}


size_t myParser::EosContext::getRuleIndex() const {
  return myParser::RuleEos;
}

void myParser::EosContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEos(this);
}

void myParser::EosContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<myParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEos(this);
}

myParser::EosContext* myParser::eos() {
  EosContext *_localctx = _tracker.createInstance<EosContext>(_ctx, getState());
  enterRule(_localctx, 286, myParser::RuleEos);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1675);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 208, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1671);
      match(myParser::SemiColon);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1672);
      match(myParser::EOF);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1673);

      if (!(this.lineTerminatorAhead())) throw FailedPredicateException(this, "this.lineTerminatorAhead()");
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1674);

      if (!(this.closeBrace())) throw FailedPredicateException(this, "this.closeBrace()");
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool myParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 10: return unionOrIntersectionOrPrimaryTypeSempred(antlrcpp::downCast<UnionOrIntersectionOrPrimaryTypeContext *>(context), predicateIndex);
    case 11: return primaryTypeSempred(antlrcpp::downCast<PrimaryTypeContext *>(context), predicateIndex);
    case 22: return arrayTypeSempred(antlrcpp::downCast<ArrayTypeContext *>(context), predicateIndex);
    case 57: return decoratorMemberExpressionSempred(antlrcpp::downCast<DecoratorMemberExpressionContext *>(context), predicateIndex);
    case 73: return expressionStatementSempred(antlrcpp::downCast<ExpressionStatementContext *>(context), predicateIndex);
    case 75: return iterationStatementSempred(antlrcpp::downCast<IterationStatementContext *>(context), predicateIndex);
    case 77: return continueStatementSempred(antlrcpp::downCast<ContinueStatementContext *>(context), predicateIndex);
    case 78: return breakStatementSempred(antlrcpp::downCast<BreakStatementContext *>(context), predicateIndex);
    case 79: return returnStatementSempred(antlrcpp::downCast<ReturnStatementContext *>(context), predicateIndex);
    case 80: return yieldStatementSempred(antlrcpp::downCast<YieldStatementContext *>(context), predicateIndex);
    case 88: return throwStatementSempred(antlrcpp::downCast<ThrowStatementContext *>(context), predicateIndex);
    case 127: return singleExpressionSempred(antlrcpp::downCast<SingleExpressionContext *>(context), predicateIndex);
    case 143: return eosSempred(antlrcpp::downCast<EosContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool myParser::unionOrIntersectionOrPrimaryTypeSempred(UnionOrIntersectionOrPrimaryTypeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 3);
    case 1: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool myParser::primaryTypeSempred(PrimaryTypeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 2: return precpred(_ctx, 5);
    case 3: return notLineTerminator();

  default:
    break;
  }
  return true;
}

bool myParser::arrayTypeSempred(ArrayTypeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 4: return notLineTerminator();

  default:
    break;
  }
  return true;
}

bool myParser::decoratorMemberExpressionSempred(DecoratorMemberExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 5: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool myParser::expressionStatementSempred(ExpressionStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 6: return this.notOpenBraceAndNotFunction();

  default:
    break;
  }
  return true;
}

bool myParser::iterationStatementSempred(IterationStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 7: return this.p("of");
    case 8: return this.p("of");

  default:
    break;
  }
  return true;
}

bool myParser::continueStatementSempred(ContinueStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 9: return this.notLineTerminator();

  default:
    break;
  }
  return true;
}

bool myParser::breakStatementSempred(BreakStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 10: return this.notLineTerminator();

  default:
    break;
  }
  return true;
}

bool myParser::returnStatementSempred(ReturnStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 11: return this.notLineTerminator();

  default:
    break;
  }
  return true;
}

bool myParser::yieldStatementSempred(YieldStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 12: return this.notLineTerminator();

  default:
    break;
  }
  return true;
}

bool myParser::throwStatementSempred(ThrowStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 13: return this.notLineTerminator();

  default:
    break;
  }
  return true;
}

bool myParser::singleExpressionSempred(SingleExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 14: return precpred(_ctx, 29);
    case 15: return precpred(_ctx, 28);
    case 16: return precpred(_ctx, 27);
    case 17: return precpred(_ctx, 26);
    case 18: return precpred(_ctx, 25);
    case 19: return precpred(_ctx, 24);
    case 20: return precpred(_ctx, 23);
    case 21: return precpred(_ctx, 22);
    case 22: return precpred(_ctx, 21);
    case 23: return precpred(_ctx, 20);
    case 24: return precpred(_ctx, 19);
    case 25: return precpred(_ctx, 18);
    case 26: return precpred(_ctx, 17);
    case 27: return precpred(_ctx, 16);
    case 28: return precpred(_ctx, 15);
    case 29: return precpred(_ctx, 45);
    case 30: return precpred(_ctx, 44);
    case 31: return precpred(_ctx, 41);
    case 32: return precpred(_ctx, 40);
    case 33: return this.notLineTerminator();
    case 34: return precpred(_ctx, 39);
    case 35: return this.notLineTerminator();
    case 36: return precpred(_ctx, 14);
    case 37: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool myParser::eosSempred(EosContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 38: return this.lineTerminatorAhead();
    case 39: return this.closeBrace();

  default:
    break;
  }
  return true;
}

void myParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  myparserParserInitialize();
#else
  ::antlr4::internal::call_once(myparserParserOnceFlag, myparserParserInitialize);
#endif
}


// Generated from Solidity.g4 by ANTLR 4.11.1


#include "SolidityListener.h"

#include "SolidityParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct SolidityParserStaticData final {
  SolidityParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  SolidityParserStaticData(const SolidityParserStaticData&) = delete;
  SolidityParserStaticData(SolidityParserStaticData&&) = delete;
  SolidityParserStaticData& operator=(const SolidityParserStaticData&) = delete;
  SolidityParserStaticData& operator=(SolidityParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag solidityParserOnceFlag;
SolidityParserStaticData *solidityParserStaticData = nullptr;

void solidityParserInitialize() {
  assert(solidityParserStaticData == nullptr);
  auto staticData = std::make_unique<SolidityParserStaticData>(
    std::vector<std::string>{
      "sourceUnit", "pragmaDirective", "pragmaName", "pragmaValue", "version", 
      "versionConstraint", "versionOperator", "importDirective", "importDeclaration", 
      "contractDefinition", "inheritanceSpecifier", "contractPart", "stateVariableDeclaration", 
      "overrideSpecifier", "usingForDeclaration", "structDefinition", "modifierDefinition", 
      "functionDefinition", "functionDescriptor", "returnParameters", "modifierList", 
      "modifierInvocation", "eventDefinition", "enumDefinition", "enumValue", 
      "parameterList", "parameter", "eventParameterList", "eventParameter", 
      "variableDeclaration", "typeName", "userDefinedTypeName", "mapping", 
      "functionTypeName", "storageLocation", "stateMutability", "block", 
      "statement", "expressionStatement", "ifStatement", "tryStatement", 
      "catchClause", "whileStatement", "forStatement", "simpleStatement", 
      "inlineAssemblyStatement", "doWhileStatement", "continueStatement", 
      "breakStatement", "returnStatement", "throwStatement", "emitStatement", 
      "variableDeclarationStatement", "variableDeclarationList", "identifierList", 
      "elementaryTypeName", "expression", "primaryExpression", "expressionList", 
      "nameValueList", "nameValue", "functionCallArguments", "functionCall", 
      "tupleExpression", "typeNameExpression", "assemblyItem", "assemblyBlock", 
      "assemblyExpression", "assemblyCall", "assemblyLocalDefinition", "assemblyAssignment", 
      "assemblyIdentifierList", "assemblyStackAssignment", "labelDefinition", 
      "assemblySwitch", "assemblyCase", "assemblyFunctionDefinition", "assemblyFunctionReturns", 
      "assemblyFor", "assemblyIf", "assemblyLiteral", "assemblyTypedVariableList", 
      "assemblyType", "subAssembly", "numberLiteral", "identifier", "hexLiteral", 
      "stringLiteral"
    },
    std::vector<std::string>{
      "", "'pragma'", "';'", "'^'", "'~'", "'>='", "'>'", "'<'", "'<='", 
      "'='", "'import'", "'as'", "'*'", "'from'", "'{'", "','", "'}'", "'abstract'", 
      "'contract'", "'interface'", "'library'", "'is'", "'('", "')'", "'override'", 
      "'using'", "'for'", "'struct'", "'modifier'", "'function'", "'returns'", 
      "'event'", "'enum'", "'['", "']'", "'.'", "'mapping'", "'=>'", "'memory'", 
      "'storage'", "'calldata'", "'if'", "'else'", "'try'", "'catch'", "'while'", 
      "'assembly'", "'do'", "'return'", "'throw'", "'emit'", "'var'", "'address'", 
      "'bool'", "'string'", "'byte'", "'++'", "'--'", "'new'", "':'", "'+'", 
      "'-'", "'after'", "'delete'", "'!'", "'**'", "'/'", "'%'", "'<<'", 
      "'>>'", "'&'", "'|'", "'=='", "'!='", "'&&'", "'||'", "'\\u003F'", 
      "'|='", "'^='", "'&='", "'<<='", "'>>='", "'+='", "'-='", "'*='", 
      "'/='", "'%='", "'let'", "':='", "'=:'", "'switch'", "'case'", "'default'", 
      "", "", "", "", "", "", "", "", "", "", "", "'anonymous'", "'break'", 
      "'constant'", "'immutable'", "'continue'", "'leave'", "'external'", 
      "'indexed'", "'internal'", "'payable'", "'private'", "'public'", "'virtual'", 
      "'pure'", "'type'", "'view'", "'constructor'", "'fallback'", "'receive'"
    },
    std::vector<std::string>{
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "Int", "Uint", "Byte", "Fixed", "Ufixed", 
      "BooleanLiteral", "DecimalNumber", "HexNumber", "NumberUnit", "HexLiteralFragment", 
      "ReservedKeyword", "AnonymousKeyword", "BreakKeyword", "ConstantKeyword", 
      "ImmutableKeyword", "ContinueKeyword", "LeaveKeyword", "ExternalKeyword", 
      "IndexedKeyword", "InternalKeyword", "PayableKeyword", "PrivateKeyword", 
      "PublicKeyword", "VirtualKeyword", "PureKeyword", "TypeKeyword", "ViewKeyword", 
      "ConstructorKeyword", "FallbackKeyword", "ReceiveKeyword", "Identifier", 
      "StringLiteralFragment", "VersionLiteral", "WS", "COMMENT", "LINE_COMMENT"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,128,1057,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,1,0,1,0,1,0,1,0,1,0,5,0,182,8,0,10,
  	0,12,0,185,9,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,3,1,3,3,3,198,8,
  	3,1,4,1,4,3,4,202,8,4,1,5,3,5,205,8,5,1,5,1,5,1,6,1,6,1,7,1,7,1,7,1,7,
  	3,7,215,8,7,1,7,1,7,1,7,1,7,3,7,221,8,7,1,7,1,7,3,7,225,8,7,1,7,1,7,1,
  	7,1,7,1,7,1,7,1,7,1,7,5,7,235,8,7,10,7,12,7,238,9,7,1,7,1,7,1,7,1,7,1,
  	7,3,7,245,8,7,1,8,1,8,1,8,3,8,250,8,8,1,9,3,9,253,8,9,1,9,1,9,1,9,1,9,
  	1,9,1,9,5,9,261,8,9,10,9,12,9,264,9,9,3,9,266,8,9,1,9,1,9,5,9,270,8,9,
  	10,9,12,9,273,9,9,1,9,1,9,1,10,1,10,1,10,3,10,280,8,10,1,10,3,10,283,
  	8,10,1,11,1,11,1,11,1,11,1,11,1,11,1,11,3,11,292,8,11,1,12,1,12,1,12,
  	1,12,1,12,1,12,1,12,5,12,301,8,12,10,12,12,12,304,9,12,1,12,1,12,1,12,
  	3,12,309,8,12,1,12,1,12,1,13,1,13,1,13,1,13,1,13,5,13,318,8,13,10,13,
  	12,13,321,9,13,1,13,1,13,3,13,325,8,13,1,14,1,14,1,14,1,14,1,14,3,14,
  	332,8,14,1,14,1,14,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,5,15,344,8,
  	15,10,15,12,15,347,9,15,3,15,349,8,15,1,15,1,15,1,16,1,16,1,16,3,16,356,
  	8,16,1,16,1,16,5,16,360,8,16,10,16,12,16,363,9,16,1,16,1,16,3,16,367,
  	8,16,1,17,1,17,1,17,1,17,3,17,373,8,17,1,17,1,17,3,17,377,8,17,1,18,1,
  	18,1,18,1,18,3,18,383,8,18,1,18,1,18,1,18,3,18,388,8,18,1,19,1,19,1,19,
  	1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,5,20,401,8,20,10,20,12,20,404,
  	9,20,1,21,1,21,1,21,3,21,409,8,21,1,21,3,21,412,8,21,1,22,1,22,1,22,1,
  	22,3,22,418,8,22,1,22,1,22,1,23,1,23,1,23,1,23,3,23,426,8,23,1,23,1,23,
  	5,23,430,8,23,10,23,12,23,433,9,23,1,23,1,23,1,24,1,24,1,25,1,25,1,25,
  	1,25,5,25,443,8,25,10,25,12,25,446,9,25,3,25,448,8,25,1,25,1,25,1,26,
  	1,26,3,26,454,8,26,1,26,3,26,457,8,26,1,27,1,27,1,27,1,27,5,27,463,8,
  	27,10,27,12,27,466,9,27,3,27,468,8,27,1,27,1,27,1,28,1,28,3,28,474,8,
  	28,1,28,3,28,477,8,28,1,29,1,29,3,29,481,8,29,1,29,1,29,1,30,1,30,1,30,
  	1,30,1,30,3,30,490,8,30,1,30,1,30,1,30,3,30,495,8,30,1,30,5,30,498,8,
  	30,10,30,12,30,501,9,30,1,31,1,31,1,31,5,31,506,8,31,10,31,12,31,509,
  	9,31,1,32,1,32,1,32,1,32,3,32,515,8,32,1,32,1,32,1,32,1,32,1,33,1,33,
  	1,33,1,33,3,33,525,8,33,1,34,1,34,1,35,1,35,1,36,1,36,5,36,533,8,36,10,
  	36,12,36,536,9,36,1,36,1,36,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,
  	37,1,37,1,37,1,37,1,37,3,37,553,8,37,1,38,1,38,1,38,1,39,1,39,1,39,1,
  	39,1,39,1,39,1,39,3,39,565,8,39,1,40,1,40,1,40,3,40,570,8,40,1,40,1,40,
  	4,40,574,8,40,11,40,12,40,575,1,41,1,41,3,41,580,8,41,1,41,3,41,583,8,
  	41,1,41,1,41,1,42,1,42,1,42,1,42,1,42,1,42,1,43,1,43,1,43,1,43,3,43,597,
  	8,43,1,43,1,43,3,43,601,8,43,1,43,3,43,604,8,43,1,43,1,43,1,43,1,44,1,
  	44,3,44,611,8,44,1,45,1,45,3,45,615,8,45,1,45,1,45,1,46,1,46,1,46,1,46,
  	1,46,1,46,1,46,1,46,1,47,1,47,1,47,1,48,1,48,1,48,1,49,1,49,3,49,635,
  	8,49,1,49,1,49,1,50,1,50,1,50,1,51,1,51,1,51,1,51,1,52,1,52,1,52,1,52,
  	1,52,1,52,1,52,3,52,653,8,52,1,52,1,52,3,52,657,8,52,1,52,1,52,1,53,3,
  	53,662,8,53,1,53,1,53,3,53,666,8,53,5,53,668,8,53,10,53,12,53,671,9,53,
  	1,54,1,54,3,54,675,8,54,1,54,5,54,678,8,54,10,54,12,54,681,9,54,1,54,
  	3,54,684,8,54,1,54,1,54,1,55,1,55,3,55,690,8,55,1,55,1,55,1,55,1,55,1,
  	55,1,55,1,55,1,55,1,55,3,55,701,8,55,1,56,1,56,1,56,1,56,1,56,1,56,1,
  	56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,
  	56,1,56,1,56,3,56,726,8,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,
  	56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,
  	56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,
  	56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,3,56,775,8,56,1,
  	56,1,56,1,56,1,56,3,56,781,8,56,1,56,1,56,3,56,785,8,56,1,56,1,56,1,56,
  	1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,5,56,801,8,56,
  	10,56,12,56,804,9,56,1,57,1,57,1,57,1,57,1,57,1,57,1,57,3,57,813,8,57,
  	1,57,1,57,1,57,1,57,1,57,3,57,820,8,57,3,57,822,8,57,1,58,1,58,1,58,5,
  	58,827,8,58,10,58,12,58,830,9,58,1,59,1,59,1,59,5,59,835,8,59,10,59,12,
  	59,838,9,59,1,59,3,59,841,8,59,1,60,1,60,1,60,1,60,1,61,1,61,3,61,849,
  	8,61,1,61,1,61,3,61,853,8,61,3,61,855,8,61,1,62,1,62,1,62,1,62,1,62,1,
  	63,1,63,3,63,864,8,63,1,63,1,63,3,63,868,8,63,5,63,870,8,63,10,63,12,
  	63,873,9,63,1,63,1,63,1,63,1,63,1,63,5,63,880,8,63,10,63,12,63,883,9,
  	63,3,63,885,8,63,1,63,3,63,888,8,63,1,64,1,64,3,64,892,8,64,1,65,1,65,
  	1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,
  	1,65,1,65,3,65,912,8,65,1,66,1,66,5,66,916,8,66,10,66,12,66,919,9,66,
  	1,66,1,66,1,67,1,67,3,67,925,8,67,1,68,1,68,1,68,1,68,3,68,931,8,68,1,
  	68,1,68,3,68,935,8,68,1,68,1,68,5,68,939,8,68,10,68,12,68,942,9,68,1,
  	68,3,68,945,8,68,1,69,1,69,1,69,1,69,3,69,951,8,69,1,70,1,70,1,70,1,70,
  	1,71,1,71,1,71,5,71,960,8,71,10,71,12,71,963,9,71,1,72,1,72,1,72,1,73,
  	1,73,1,73,1,74,1,74,1,74,5,74,974,8,74,10,74,12,74,977,9,74,1,75,1,75,
  	1,75,3,75,982,8,75,1,75,1,75,1,75,1,75,3,75,988,8,75,1,76,1,76,1,76,1,
  	76,3,76,994,8,76,1,76,1,76,3,76,998,8,76,1,76,1,76,1,77,1,77,1,77,1,77,
  	1,78,1,78,1,78,1,78,1,78,1,78,1,79,1,79,1,79,1,79,1,80,1,80,1,80,1,80,
  	1,80,3,80,1021,8,80,1,80,3,80,1024,8,80,1,81,1,81,3,81,1028,8,81,1,81,
  	1,81,3,81,1032,8,81,1,82,1,82,1,82,1,83,1,83,1,83,1,83,1,84,1,84,3,84,
  	1043,8,84,1,85,1,85,1,86,4,86,1048,8,86,11,86,12,86,1049,1,87,4,87,1053,
  	8,87,11,87,12,87,1054,1,87,0,2,60,112,88,0,2,4,6,8,10,12,14,16,18,20,
  	22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,
  	68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,
  	112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,
  	148,150,152,154,156,158,160,162,164,166,168,170,172,174,0,14,1,0,3,9,
  	1,0,18,20,1,0,38,40,4,0,106,106,113,113,117,117,119,119,1,0,56,57,1,0,
  	60,61,1,0,62,63,2,0,12,12,66,67,1,0,68,69,1,0,5,8,1,0,72,73,2,0,9,9,77,
  	86,1,0,99,100,4,0,13,13,40,40,52,52,123,123,1186,0,183,1,0,0,0,2,188,
  	1,0,0,0,4,193,1,0,0,0,6,197,1,0,0,0,8,199,1,0,0,0,10,204,1,0,0,0,12,208,
  	1,0,0,0,14,244,1,0,0,0,16,246,1,0,0,0,18,252,1,0,0,0,20,276,1,0,0,0,22,
  	291,1,0,0,0,24,293,1,0,0,0,26,312,1,0,0,0,28,326,1,0,0,0,30,335,1,0,0,
  	0,32,352,1,0,0,0,34,368,1,0,0,0,36,387,1,0,0,0,38,389,1,0,0,0,40,402,
  	1,0,0,0,42,405,1,0,0,0,44,413,1,0,0,0,46,421,1,0,0,0,48,436,1,0,0,0,50,
  	438,1,0,0,0,52,451,1,0,0,0,54,458,1,0,0,0,56,471,1,0,0,0,58,478,1,0,0,
  	0,60,489,1,0,0,0,62,502,1,0,0,0,64,510,1,0,0,0,66,520,1,0,0,0,68,526,
  	1,0,0,0,70,528,1,0,0,0,72,530,1,0,0,0,74,552,1,0,0,0,76,554,1,0,0,0,78,
  	557,1,0,0,0,80,566,1,0,0,0,82,577,1,0,0,0,84,586,1,0,0,0,86,592,1,0,0,
  	0,88,610,1,0,0,0,90,612,1,0,0,0,92,618,1,0,0,0,94,626,1,0,0,0,96,629,
  	1,0,0,0,98,632,1,0,0,0,100,638,1,0,0,0,102,641,1,0,0,0,104,652,1,0,0,
  	0,106,661,1,0,0,0,108,672,1,0,0,0,110,700,1,0,0,0,112,725,1,0,0,0,114,
  	821,1,0,0,0,116,823,1,0,0,0,118,831,1,0,0,0,120,842,1,0,0,0,122,854,1,
  	0,0,0,124,856,1,0,0,0,126,887,1,0,0,0,128,891,1,0,0,0,130,911,1,0,0,0,
  	132,913,1,0,0,0,134,924,1,0,0,0,136,930,1,0,0,0,138,946,1,0,0,0,140,952,
  	1,0,0,0,142,956,1,0,0,0,144,964,1,0,0,0,146,967,1,0,0,0,148,970,1,0,0,
  	0,150,987,1,0,0,0,152,989,1,0,0,0,154,1001,1,0,0,0,156,1005,1,0,0,0,158,
  	1011,1,0,0,0,160,1020,1,0,0,0,162,1025,1,0,0,0,164,1033,1,0,0,0,166,1036,
  	1,0,0,0,168,1040,1,0,0,0,170,1044,1,0,0,0,172,1047,1,0,0,0,174,1052,1,
  	0,0,0,176,182,3,2,1,0,177,182,3,14,7,0,178,182,3,30,15,0,179,182,3,46,
  	23,0,180,182,3,18,9,0,181,176,1,0,0,0,181,177,1,0,0,0,181,178,1,0,0,0,
  	181,179,1,0,0,0,181,180,1,0,0,0,182,185,1,0,0,0,183,181,1,0,0,0,183,184,
  	1,0,0,0,184,186,1,0,0,0,185,183,1,0,0,0,186,187,5,0,0,1,187,1,1,0,0,0,
  	188,189,5,1,0,0,189,190,3,4,2,0,190,191,3,6,3,0,191,192,5,2,0,0,192,3,
  	1,0,0,0,193,194,3,170,85,0,194,5,1,0,0,0,195,198,3,8,4,0,196,198,3,112,
  	56,0,197,195,1,0,0,0,197,196,1,0,0,0,198,7,1,0,0,0,199,201,3,10,5,0,200,
  	202,3,10,5,0,201,200,1,0,0,0,201,202,1,0,0,0,202,9,1,0,0,0,203,205,3,
  	12,6,0,204,203,1,0,0,0,204,205,1,0,0,0,205,206,1,0,0,0,206,207,5,125,
  	0,0,207,11,1,0,0,0,208,209,7,0,0,0,209,13,1,0,0,0,210,211,5,10,0,0,211,
  	214,5,124,0,0,212,213,5,11,0,0,213,215,3,170,85,0,214,212,1,0,0,0,214,
  	215,1,0,0,0,215,216,1,0,0,0,216,245,5,2,0,0,217,220,5,10,0,0,218,221,
  	5,12,0,0,219,221,3,170,85,0,220,218,1,0,0,0,220,219,1,0,0,0,221,224,1,
  	0,0,0,222,223,5,11,0,0,223,225,3,170,85,0,224,222,1,0,0,0,224,225,1,0,
  	0,0,225,226,1,0,0,0,226,227,5,13,0,0,227,228,5,124,0,0,228,245,5,2,0,
  	0,229,230,5,10,0,0,230,231,5,14,0,0,231,236,3,16,8,0,232,233,5,15,0,0,
  	233,235,3,16,8,0,234,232,1,0,0,0,235,238,1,0,0,0,236,234,1,0,0,0,236,
  	237,1,0,0,0,237,239,1,0,0,0,238,236,1,0,0,0,239,240,5,16,0,0,240,241,
  	5,13,0,0,241,242,5,124,0,0,242,243,5,2,0,0,243,245,1,0,0,0,244,210,1,
  	0,0,0,244,217,1,0,0,0,244,229,1,0,0,0,245,15,1,0,0,0,246,249,3,170,85,
  	0,247,248,5,11,0,0,248,250,3,170,85,0,249,247,1,0,0,0,249,250,1,0,0,0,
  	250,17,1,0,0,0,251,253,5,17,0,0,252,251,1,0,0,0,252,253,1,0,0,0,253,254,
  	1,0,0,0,254,255,7,1,0,0,255,265,3,170,85,0,256,257,5,21,0,0,257,262,3,
  	20,10,0,258,259,5,15,0,0,259,261,3,20,10,0,260,258,1,0,0,0,261,264,1,
  	0,0,0,262,260,1,0,0,0,262,263,1,0,0,0,263,266,1,0,0,0,264,262,1,0,0,0,
  	265,256,1,0,0,0,265,266,1,0,0,0,266,267,1,0,0,0,267,271,5,14,0,0,268,
  	270,3,22,11,0,269,268,1,0,0,0,270,273,1,0,0,0,271,269,1,0,0,0,271,272,
  	1,0,0,0,272,274,1,0,0,0,273,271,1,0,0,0,274,275,5,16,0,0,275,19,1,0,0,
  	0,276,282,3,62,31,0,277,279,5,22,0,0,278,280,3,116,58,0,279,278,1,0,0,
  	0,279,280,1,0,0,0,280,281,1,0,0,0,281,283,5,23,0,0,282,277,1,0,0,0,282,
  	283,1,0,0,0,283,21,1,0,0,0,284,292,3,24,12,0,285,292,3,28,14,0,286,292,
  	3,30,15,0,287,292,3,32,16,0,288,292,3,34,17,0,289,292,3,44,22,0,290,292,
  	3,46,23,0,291,284,1,0,0,0,291,285,1,0,0,0,291,286,1,0,0,0,291,287,1,0,
  	0,0,291,288,1,0,0,0,291,289,1,0,0,0,291,290,1,0,0,0,292,23,1,0,0,0,293,
  	302,3,60,30,0,294,301,5,115,0,0,295,301,5,112,0,0,296,301,5,114,0,0,297,
  	301,5,106,0,0,298,301,5,107,0,0,299,301,3,26,13,0,300,294,1,0,0,0,300,
  	295,1,0,0,0,300,296,1,0,0,0,300,297,1,0,0,0,300,298,1,0,0,0,300,299,1,
  	0,0,0,301,304,1,0,0,0,302,300,1,0,0,0,302,303,1,0,0,0,303,305,1,0,0,0,
  	304,302,1,0,0,0,305,308,3,170,85,0,306,307,5,9,0,0,307,309,3,112,56,0,
  	308,306,1,0,0,0,308,309,1,0,0,0,309,310,1,0,0,0,310,311,5,2,0,0,311,25,
  	1,0,0,0,312,324,5,24,0,0,313,314,5,22,0,0,314,319,3,62,31,0,315,316,5,
  	15,0,0,316,318,3,62,31,0,317,315,1,0,0,0,318,321,1,0,0,0,319,317,1,0,
  	0,0,319,320,1,0,0,0,320,322,1,0,0,0,321,319,1,0,0,0,322,323,5,23,0,0,
  	323,325,1,0,0,0,324,313,1,0,0,0,324,325,1,0,0,0,325,27,1,0,0,0,326,327,
  	5,25,0,0,327,328,3,170,85,0,328,331,5,26,0,0,329,332,5,12,0,0,330,332,
  	3,60,30,0,331,329,1,0,0,0,331,330,1,0,0,0,332,333,1,0,0,0,333,334,5,2,
  	0,0,334,29,1,0,0,0,335,336,5,27,0,0,336,337,3,170,85,0,337,348,5,14,0,
  	0,338,339,3,58,29,0,339,345,5,2,0,0,340,341,3,58,29,0,341,342,5,2,0,0,
  	342,344,1,0,0,0,343,340,1,0,0,0,344,347,1,0,0,0,345,343,1,0,0,0,345,346,
  	1,0,0,0,346,349,1,0,0,0,347,345,1,0,0,0,348,338,1,0,0,0,348,349,1,0,0,
  	0,349,350,1,0,0,0,350,351,5,16,0,0,351,31,1,0,0,0,352,353,5,28,0,0,353,
  	355,3,170,85,0,354,356,3,50,25,0,355,354,1,0,0,0,355,356,1,0,0,0,356,
  	361,1,0,0,0,357,360,5,116,0,0,358,360,3,26,13,0,359,357,1,0,0,0,359,358,
  	1,0,0,0,360,363,1,0,0,0,361,359,1,0,0,0,361,362,1,0,0,0,362,366,1,0,0,
  	0,363,361,1,0,0,0,364,367,5,2,0,0,365,367,3,72,36,0,366,364,1,0,0,0,366,
  	365,1,0,0,0,367,33,1,0,0,0,368,369,3,36,18,0,369,370,3,50,25,0,370,372,
  	3,40,20,0,371,373,3,38,19,0,372,371,1,0,0,0,372,373,1,0,0,0,373,376,1,
  	0,0,0,374,377,5,2,0,0,375,377,3,72,36,0,376,374,1,0,0,0,376,375,1,0,0,
  	0,377,35,1,0,0,0,378,382,5,29,0,0,379,383,3,170,85,0,380,383,5,122,0,
  	0,381,383,5,121,0,0,382,379,1,0,0,0,382,380,1,0,0,0,382,381,1,0,0,0,382,
  	383,1,0,0,0,383,388,1,0,0,0,384,388,5,120,0,0,385,388,5,121,0,0,386,388,
  	5,122,0,0,387,378,1,0,0,0,387,384,1,0,0,0,387,385,1,0,0,0,387,386,1,0,
  	0,0,388,37,1,0,0,0,389,390,5,30,0,0,390,391,3,50,25,0,391,39,1,0,0,0,
  	392,401,3,42,21,0,393,401,3,70,35,0,394,401,5,110,0,0,395,401,5,115,0,
  	0,396,401,5,112,0,0,397,401,5,114,0,0,398,401,5,116,0,0,399,401,3,26,
  	13,0,400,392,1,0,0,0,400,393,1,0,0,0,400,394,1,0,0,0,400,395,1,0,0,0,
  	400,396,1,0,0,0,400,397,1,0,0,0,400,398,1,0,0,0,400,399,1,0,0,0,401,404,
  	1,0,0,0,402,400,1,0,0,0,402,403,1,0,0,0,403,41,1,0,0,0,404,402,1,0,0,
  	0,405,411,3,170,85,0,406,408,5,22,0,0,407,409,3,116,58,0,408,407,1,0,
  	0,0,408,409,1,0,0,0,409,410,1,0,0,0,410,412,5,23,0,0,411,406,1,0,0,0,
  	411,412,1,0,0,0,412,43,1,0,0,0,413,414,5,31,0,0,414,415,3,170,85,0,415,
  	417,3,54,27,0,416,418,5,104,0,0,417,416,1,0,0,0,417,418,1,0,0,0,418,419,
  	1,0,0,0,419,420,5,2,0,0,420,45,1,0,0,0,421,422,5,32,0,0,422,423,3,170,
  	85,0,423,425,5,14,0,0,424,426,3,48,24,0,425,424,1,0,0,0,425,426,1,0,0,
  	0,426,431,1,0,0,0,427,428,5,15,0,0,428,430,3,48,24,0,429,427,1,0,0,0,
  	430,433,1,0,0,0,431,429,1,0,0,0,431,432,1,0,0,0,432,434,1,0,0,0,433,431,
  	1,0,0,0,434,435,5,16,0,0,435,47,1,0,0,0,436,437,3,170,85,0,437,49,1,0,
  	0,0,438,447,5,22,0,0,439,444,3,52,26,0,440,441,5,15,0,0,441,443,3,52,
  	26,0,442,440,1,0,0,0,443,446,1,0,0,0,444,442,1,0,0,0,444,445,1,0,0,0,
  	445,448,1,0,0,0,446,444,1,0,0,0,447,439,1,0,0,0,447,448,1,0,0,0,448,449,
  	1,0,0,0,449,450,5,23,0,0,450,51,1,0,0,0,451,453,3,60,30,0,452,454,3,68,
  	34,0,453,452,1,0,0,0,453,454,1,0,0,0,454,456,1,0,0,0,455,457,3,170,85,
  	0,456,455,1,0,0,0,456,457,1,0,0,0,457,53,1,0,0,0,458,467,5,22,0,0,459,
  	464,3,56,28,0,460,461,5,15,0,0,461,463,3,56,28,0,462,460,1,0,0,0,463,
  	466,1,0,0,0,464,462,1,0,0,0,464,465,1,0,0,0,465,468,1,0,0,0,466,464,1,
  	0,0,0,467,459,1,0,0,0,467,468,1,0,0,0,468,469,1,0,0,0,469,470,5,23,0,
  	0,470,55,1,0,0,0,471,473,3,60,30,0,472,474,5,111,0,0,473,472,1,0,0,0,
  	473,474,1,0,0,0,474,476,1,0,0,0,475,477,3,170,85,0,476,475,1,0,0,0,476,
  	477,1,0,0,0,477,57,1,0,0,0,478,480,3,60,30,0,479,481,3,68,34,0,480,479,
  	1,0,0,0,480,481,1,0,0,0,481,482,1,0,0,0,482,483,3,170,85,0,483,59,1,0,
  	0,0,484,485,6,30,-1,0,485,490,3,110,55,0,486,490,3,62,31,0,487,490,3,
  	64,32,0,488,490,3,66,33,0,489,484,1,0,0,0,489,486,1,0,0,0,489,487,1,0,
  	0,0,489,488,1,0,0,0,490,499,1,0,0,0,491,492,10,2,0,0,492,494,5,33,0,0,
  	493,495,3,112,56,0,494,493,1,0,0,0,494,495,1,0,0,0,495,496,1,0,0,0,496,
  	498,5,34,0,0,497,491,1,0,0,0,498,501,1,0,0,0,499,497,1,0,0,0,499,500,
  	1,0,0,0,500,61,1,0,0,0,501,499,1,0,0,0,502,507,3,170,85,0,503,504,5,35,
  	0,0,504,506,3,170,85,0,505,503,1,0,0,0,506,509,1,0,0,0,507,505,1,0,0,
  	0,507,508,1,0,0,0,508,63,1,0,0,0,509,507,1,0,0,0,510,511,5,36,0,0,511,
  	514,5,22,0,0,512,515,3,110,55,0,513,515,3,62,31,0,514,512,1,0,0,0,514,
  	513,1,0,0,0,515,516,1,0,0,0,516,517,5,37,0,0,517,518,3,60,30,0,518,519,
  	5,23,0,0,519,65,1,0,0,0,520,521,5,29,0,0,521,522,3,50,25,0,522,524,3,
  	40,20,0,523,525,3,38,19,0,524,523,1,0,0,0,524,525,1,0,0,0,525,67,1,0,
  	0,0,526,527,7,2,0,0,527,69,1,0,0,0,528,529,7,3,0,0,529,71,1,0,0,0,530,
  	534,5,14,0,0,531,533,3,74,37,0,532,531,1,0,0,0,533,536,1,0,0,0,534,532,
  	1,0,0,0,534,535,1,0,0,0,535,537,1,0,0,0,536,534,1,0,0,0,537,538,5,16,
  	0,0,538,73,1,0,0,0,539,553,3,78,39,0,540,553,3,80,40,0,541,553,3,84,42,
  	0,542,553,3,86,43,0,543,553,3,72,36,0,544,553,3,90,45,0,545,553,3,92,
  	46,0,546,553,3,94,47,0,547,553,3,96,48,0,548,553,3,98,49,0,549,553,3,
  	100,50,0,550,553,3,102,51,0,551,553,3,88,44,0,552,539,1,0,0,0,552,540,
  	1,0,0,0,552,541,1,0,0,0,552,542,1,0,0,0,552,543,1,0,0,0,552,544,1,0,0,
  	0,552,545,1,0,0,0,552,546,1,0,0,0,552,547,1,0,0,0,552,548,1,0,0,0,552,
  	549,1,0,0,0,552,550,1,0,0,0,552,551,1,0,0,0,553,75,1,0,0,0,554,555,3,
  	112,56,0,555,556,5,2,0,0,556,77,1,0,0,0,557,558,5,41,0,0,558,559,5,22,
  	0,0,559,560,3,112,56,0,560,561,5,23,0,0,561,564,3,74,37,0,562,563,5,42,
  	0,0,563,565,3,74,37,0,564,562,1,0,0,0,564,565,1,0,0,0,565,79,1,0,0,0,
  	566,567,5,43,0,0,567,569,3,112,56,0,568,570,3,38,19,0,569,568,1,0,0,0,
  	569,570,1,0,0,0,570,571,1,0,0,0,571,573,3,72,36,0,572,574,3,82,41,0,573,
  	572,1,0,0,0,574,575,1,0,0,0,575,573,1,0,0,0,575,576,1,0,0,0,576,81,1,
  	0,0,0,577,582,5,44,0,0,578,580,3,170,85,0,579,578,1,0,0,0,579,580,1,0,
  	0,0,580,581,1,0,0,0,581,583,3,50,25,0,582,579,1,0,0,0,582,583,1,0,0,0,
  	583,584,1,0,0,0,584,585,3,72,36,0,585,83,1,0,0,0,586,587,5,45,0,0,587,
  	588,5,22,0,0,588,589,3,112,56,0,589,590,5,23,0,0,590,591,3,74,37,0,591,
  	85,1,0,0,0,592,593,5,26,0,0,593,596,5,22,0,0,594,597,3,88,44,0,595,597,
  	5,2,0,0,596,594,1,0,0,0,596,595,1,0,0,0,597,600,1,0,0,0,598,601,3,76,
  	38,0,599,601,5,2,0,0,600,598,1,0,0,0,600,599,1,0,0,0,601,603,1,0,0,0,
  	602,604,3,112,56,0,603,602,1,0,0,0,603,604,1,0,0,0,604,605,1,0,0,0,605,
  	606,5,23,0,0,606,607,3,74,37,0,607,87,1,0,0,0,608,611,3,104,52,0,609,
  	611,3,76,38,0,610,608,1,0,0,0,610,609,1,0,0,0,611,89,1,0,0,0,612,614,
  	5,46,0,0,613,615,5,124,0,0,614,613,1,0,0,0,614,615,1,0,0,0,615,616,1,
  	0,0,0,616,617,3,132,66,0,617,91,1,0,0,0,618,619,5,47,0,0,619,620,3,74,
  	37,0,620,621,5,45,0,0,621,622,5,22,0,0,622,623,3,112,56,0,623,624,5,23,
  	0,0,624,625,5,2,0,0,625,93,1,0,0,0,626,627,5,108,0,0,627,628,5,2,0,0,
  	628,95,1,0,0,0,629,630,5,105,0,0,630,631,5,2,0,0,631,97,1,0,0,0,632,634,
  	5,48,0,0,633,635,3,112,56,0,634,633,1,0,0,0,634,635,1,0,0,0,635,636,1,
  	0,0,0,636,637,5,2,0,0,637,99,1,0,0,0,638,639,5,49,0,0,639,640,5,2,0,0,
  	640,101,1,0,0,0,641,642,5,50,0,0,642,643,3,124,62,0,643,644,5,2,0,0,644,
  	103,1,0,0,0,645,646,5,51,0,0,646,653,3,108,54,0,647,653,3,58,29,0,648,
  	649,5,22,0,0,649,650,3,106,53,0,650,651,5,23,0,0,651,653,1,0,0,0,652,
  	645,1,0,0,0,652,647,1,0,0,0,652,648,1,0,0,0,653,656,1,0,0,0,654,655,5,
  	9,0,0,655,657,3,112,56,0,656,654,1,0,0,0,656,657,1,0,0,0,657,658,1,0,
  	0,0,658,659,5,2,0,0,659,105,1,0,0,0,660,662,3,58,29,0,661,660,1,0,0,0,
  	661,662,1,0,0,0,662,669,1,0,0,0,663,665,5,15,0,0,664,666,3,58,29,0,665,
  	664,1,0,0,0,665,666,1,0,0,0,666,668,1,0,0,0,667,663,1,0,0,0,668,671,1,
  	0,0,0,669,667,1,0,0,0,669,670,1,0,0,0,670,107,1,0,0,0,671,669,1,0,0,0,
  	672,679,5,22,0,0,673,675,3,170,85,0,674,673,1,0,0,0,674,675,1,0,0,0,675,
  	676,1,0,0,0,676,678,5,15,0,0,677,674,1,0,0,0,678,681,1,0,0,0,679,677,
  	1,0,0,0,679,680,1,0,0,0,680,683,1,0,0,0,681,679,1,0,0,0,682,684,3,170,
  	85,0,683,682,1,0,0,0,683,684,1,0,0,0,684,685,1,0,0,0,685,686,5,23,0,0,
  	686,109,1,0,0,0,687,689,5,52,0,0,688,690,5,113,0,0,689,688,1,0,0,0,689,
  	690,1,0,0,0,690,701,1,0,0,0,691,701,5,53,0,0,692,701,5,54,0,0,693,701,
  	5,51,0,0,694,701,5,93,0,0,695,701,5,94,0,0,696,701,5,55,0,0,697,701,5,
  	95,0,0,698,701,5,96,0,0,699,701,5,97,0,0,700,687,1,0,0,0,700,691,1,0,
  	0,0,700,692,1,0,0,0,700,693,1,0,0,0,700,694,1,0,0,0,700,695,1,0,0,0,700,
  	696,1,0,0,0,700,697,1,0,0,0,700,698,1,0,0,0,700,699,1,0,0,0,701,111,1,
  	0,0,0,702,703,6,56,-1,0,703,704,5,58,0,0,704,726,3,60,30,0,705,706,5,
  	113,0,0,706,707,5,22,0,0,707,708,3,112,56,0,708,709,5,23,0,0,709,726,
  	1,0,0,0,710,711,5,22,0,0,711,712,3,112,56,0,712,713,5,23,0,0,713,726,
  	1,0,0,0,714,715,7,4,0,0,715,726,3,112,56,19,716,717,7,5,0,0,717,726,3,
  	112,56,18,718,719,7,6,0,0,719,726,3,112,56,17,720,721,5,64,0,0,721,726,
  	3,112,56,16,722,723,5,4,0,0,723,726,3,112,56,15,724,726,3,114,57,0,725,
  	702,1,0,0,0,725,705,1,0,0,0,725,710,1,0,0,0,725,714,1,0,0,0,725,716,1,
  	0,0,0,725,718,1,0,0,0,725,720,1,0,0,0,725,722,1,0,0,0,725,724,1,0,0,0,
  	726,802,1,0,0,0,727,728,10,14,0,0,728,729,5,65,0,0,729,801,3,112,56,15,
  	730,731,10,13,0,0,731,732,7,7,0,0,732,801,3,112,56,14,733,734,10,12,0,
  	0,734,735,7,5,0,0,735,801,3,112,56,13,736,737,10,11,0,0,737,738,7,8,0,
  	0,738,801,3,112,56,12,739,740,10,10,0,0,740,741,5,70,0,0,741,801,3,112,
  	56,11,742,743,10,9,0,0,743,744,5,3,0,0,744,801,3,112,56,10,745,746,10,
  	8,0,0,746,747,5,71,0,0,747,801,3,112,56,9,748,749,10,7,0,0,749,750,7,
  	9,0,0,750,801,3,112,56,8,751,752,10,6,0,0,752,753,7,10,0,0,753,801,3,
  	112,56,7,754,755,10,5,0,0,755,756,5,74,0,0,756,801,3,112,56,6,757,758,
  	10,4,0,0,758,759,5,75,0,0,759,801,3,112,56,5,760,761,10,3,0,0,761,762,
  	5,76,0,0,762,763,3,112,56,0,763,764,5,59,0,0,764,765,3,112,56,4,765,801,
  	1,0,0,0,766,767,10,2,0,0,767,768,7,11,0,0,768,801,3,112,56,3,769,770,
  	10,28,0,0,770,801,7,4,0,0,771,772,10,26,0,0,772,774,5,33,0,0,773,775,
  	3,112,56,0,774,773,1,0,0,0,774,775,1,0,0,0,775,776,1,0,0,0,776,801,5,
  	34,0,0,777,778,10,25,0,0,778,780,5,33,0,0,779,781,3,112,56,0,780,779,
  	1,0,0,0,780,781,1,0,0,0,781,782,1,0,0,0,782,784,5,59,0,0,783,785,3,112,
  	56,0,784,783,1,0,0,0,784,785,1,0,0,0,785,786,1,0,0,0,786,801,5,34,0,0,
  	787,788,10,24,0,0,788,789,5,35,0,0,789,801,3,170,85,0,790,791,10,23,0,
  	0,791,792,5,14,0,0,792,793,3,118,59,0,793,794,5,16,0,0,794,801,1,0,0,
  	0,795,796,10,22,0,0,796,797,5,22,0,0,797,798,3,122,61,0,798,799,5,23,
  	0,0,799,801,1,0,0,0,800,727,1,0,0,0,800,730,1,0,0,0,800,733,1,0,0,0,800,
  	736,1,0,0,0,800,739,1,0,0,0,800,742,1,0,0,0,800,745,1,0,0,0,800,748,1,
  	0,0,0,800,751,1,0,0,0,800,754,1,0,0,0,800,757,1,0,0,0,800,760,1,0,0,0,
  	800,766,1,0,0,0,800,769,1,0,0,0,800,771,1,0,0,0,800,777,1,0,0,0,800,787,
  	1,0,0,0,800,790,1,0,0,0,800,795,1,0,0,0,801,804,1,0,0,0,802,800,1,0,0,
  	0,802,803,1,0,0,0,803,113,1,0,0,0,804,802,1,0,0,0,805,822,5,98,0,0,806,
  	822,3,168,84,0,807,822,3,172,86,0,808,822,3,174,87,0,809,812,3,170,85,
  	0,810,811,5,33,0,0,811,813,5,34,0,0,812,810,1,0,0,0,812,813,1,0,0,0,813,
  	822,1,0,0,0,814,822,5,118,0,0,815,822,3,126,63,0,816,819,3,128,64,0,817,
  	818,5,33,0,0,818,820,5,34,0,0,819,817,1,0,0,0,819,820,1,0,0,0,820,822,
  	1,0,0,0,821,805,1,0,0,0,821,806,1,0,0,0,821,807,1,0,0,0,821,808,1,0,0,
  	0,821,809,1,0,0,0,821,814,1,0,0,0,821,815,1,0,0,0,821,816,1,0,0,0,822,
  	115,1,0,0,0,823,828,3,112,56,0,824,825,5,15,0,0,825,827,3,112,56,0,826,
  	824,1,0,0,0,827,830,1,0,0,0,828,826,1,0,0,0,828,829,1,0,0,0,829,117,1,
  	0,0,0,830,828,1,0,0,0,831,836,3,120,60,0,832,833,5,15,0,0,833,835,3,120,
  	60,0,834,832,1,0,0,0,835,838,1,0,0,0,836,834,1,0,0,0,836,837,1,0,0,0,
  	837,840,1,0,0,0,838,836,1,0,0,0,839,841,5,15,0,0,840,839,1,0,0,0,840,
  	841,1,0,0,0,841,119,1,0,0,0,842,843,3,170,85,0,843,844,5,59,0,0,844,845,
  	3,112,56,0,845,121,1,0,0,0,846,848,5,14,0,0,847,849,3,118,59,0,848,847,
  	1,0,0,0,848,849,1,0,0,0,849,850,1,0,0,0,850,855,5,16,0,0,851,853,3,116,
  	58,0,852,851,1,0,0,0,852,853,1,0,0,0,853,855,1,0,0,0,854,846,1,0,0,0,
  	854,852,1,0,0,0,855,123,1,0,0,0,856,857,3,112,56,0,857,858,5,22,0,0,858,
  	859,3,122,61,0,859,860,5,23,0,0,860,125,1,0,0,0,861,863,5,22,0,0,862,
  	864,3,112,56,0,863,862,1,0,0,0,863,864,1,0,0,0,864,871,1,0,0,0,865,867,
  	5,15,0,0,866,868,3,112,56,0,867,866,1,0,0,0,867,868,1,0,0,0,868,870,1,
  	0,0,0,869,865,1,0,0,0,870,873,1,0,0,0,871,869,1,0,0,0,871,872,1,0,0,0,
  	872,874,1,0,0,0,873,871,1,0,0,0,874,888,5,23,0,0,875,884,5,33,0,0,876,
  	881,3,112,56,0,877,878,5,15,0,0,878,880,3,112,56,0,879,877,1,0,0,0,880,
  	883,1,0,0,0,881,879,1,0,0,0,881,882,1,0,0,0,882,885,1,0,0,0,883,881,1,
  	0,0,0,884,876,1,0,0,0,884,885,1,0,0,0,885,886,1,0,0,0,886,888,5,34,0,
  	0,887,861,1,0,0,0,887,875,1,0,0,0,888,127,1,0,0,0,889,892,3,110,55,0,
  	890,892,3,62,31,0,891,889,1,0,0,0,891,890,1,0,0,0,892,129,1,0,0,0,893,
  	912,3,170,85,0,894,912,3,132,66,0,895,912,3,134,67,0,896,912,3,138,69,
  	0,897,912,3,140,70,0,898,912,3,144,72,0,899,912,3,146,73,0,900,912,3,
  	148,74,0,901,912,3,152,76,0,902,912,3,156,78,0,903,912,3,158,79,0,904,
  	912,5,105,0,0,905,912,5,108,0,0,906,912,5,109,0,0,907,912,3,166,83,0,
  	908,912,3,168,84,0,909,912,3,174,87,0,910,912,3,172,86,0,911,893,1,0,
  	0,0,911,894,1,0,0,0,911,895,1,0,0,0,911,896,1,0,0,0,911,897,1,0,0,0,911,
  	898,1,0,0,0,911,899,1,0,0,0,911,900,1,0,0,0,911,901,1,0,0,0,911,902,1,
  	0,0,0,911,903,1,0,0,0,911,904,1,0,0,0,911,905,1,0,0,0,911,906,1,0,0,0,
  	911,907,1,0,0,0,911,908,1,0,0,0,911,909,1,0,0,0,911,910,1,0,0,0,912,131,
  	1,0,0,0,913,917,5,14,0,0,914,916,3,130,65,0,915,914,1,0,0,0,916,919,1,
  	0,0,0,917,915,1,0,0,0,917,918,1,0,0,0,918,920,1,0,0,0,919,917,1,0,0,0,
  	920,921,5,16,0,0,921,133,1,0,0,0,922,925,3,136,68,0,923,925,3,160,80,
  	0,924,922,1,0,0,0,924,923,1,0,0,0,925,135,1,0,0,0,926,931,5,48,0,0,927,
  	931,5,52,0,0,928,931,5,55,0,0,929,931,3,170,85,0,930,926,1,0,0,0,930,
  	927,1,0,0,0,930,928,1,0,0,0,930,929,1,0,0,0,931,944,1,0,0,0,932,934,5,
  	22,0,0,933,935,3,134,67,0,934,933,1,0,0,0,934,935,1,0,0,0,935,940,1,0,
  	0,0,936,937,5,15,0,0,937,939,3,134,67,0,938,936,1,0,0,0,939,942,1,0,0,
  	0,940,938,1,0,0,0,940,941,1,0,0,0,941,943,1,0,0,0,942,940,1,0,0,0,943,
  	945,5,23,0,0,944,932,1,0,0,0,944,945,1,0,0,0,945,137,1,0,0,0,946,947,
  	5,87,0,0,947,950,3,142,71,0,948,949,5,88,0,0,949,951,3,134,67,0,950,948,
  	1,0,0,0,950,951,1,0,0,0,951,139,1,0,0,0,952,953,3,142,71,0,953,954,5,
  	88,0,0,954,955,3,134,67,0,955,141,1,0,0,0,956,961,3,170,85,0,957,958,
  	5,15,0,0,958,960,3,170,85,0,959,957,1,0,0,0,960,963,1,0,0,0,961,959,1,
  	0,0,0,961,962,1,0,0,0,962,143,1,0,0,0,963,961,1,0,0,0,964,965,5,89,0,
  	0,965,966,3,170,85,0,966,145,1,0,0,0,967,968,3,170,85,0,968,969,5,59,
  	0,0,969,147,1,0,0,0,970,971,5,90,0,0,971,975,3,134,67,0,972,974,3,150,
  	75,0,973,972,1,0,0,0,974,977,1,0,0,0,975,973,1,0,0,0,975,976,1,0,0,0,
  	976,149,1,0,0,0,977,975,1,0,0,0,978,979,5,91,0,0,979,981,3,160,80,0,980,
  	982,3,164,82,0,981,980,1,0,0,0,981,982,1,0,0,0,982,983,1,0,0,0,983,984,
  	3,132,66,0,984,988,1,0,0,0,985,986,5,92,0,0,986,988,3,132,66,0,987,978,
  	1,0,0,0,987,985,1,0,0,0,988,151,1,0,0,0,989,990,5,29,0,0,990,991,3,170,
  	85,0,991,993,5,22,0,0,992,994,3,162,81,0,993,992,1,0,0,0,993,994,1,0,
  	0,0,994,995,1,0,0,0,995,997,5,23,0,0,996,998,3,154,77,0,997,996,1,0,0,
  	0,997,998,1,0,0,0,998,999,1,0,0,0,999,1000,3,132,66,0,1000,153,1,0,0,
  	0,1001,1002,5,61,0,0,1002,1003,5,6,0,0,1003,1004,3,162,81,0,1004,155,
  	1,0,0,0,1005,1006,5,26,0,0,1006,1007,3,132,66,0,1007,1008,3,134,67,0,
  	1008,1009,3,132,66,0,1009,1010,3,132,66,0,1010,157,1,0,0,0,1011,1012,
  	5,41,0,0,1012,1013,3,134,67,0,1013,1014,3,132,66,0,1014,159,1,0,0,0,1015,
  	1021,3,174,87,0,1016,1021,5,99,0,0,1017,1021,5,100,0,0,1018,1021,3,172,
  	86,0,1019,1021,5,98,0,0,1020,1015,1,0,0,0,1020,1016,1,0,0,0,1020,1017,
  	1,0,0,0,1020,1018,1,0,0,0,1020,1019,1,0,0,0,1021,1023,1,0,0,0,1022,1024,
  	3,164,82,0,1023,1022,1,0,0,0,1023,1024,1,0,0,0,1024,161,1,0,0,0,1025,
  	1027,3,170,85,0,1026,1028,3,164,82,0,1027,1026,1,0,0,0,1027,1028,1,0,
  	0,0,1028,1031,1,0,0,0,1029,1030,5,15,0,0,1030,1032,3,162,81,0,1031,1029,
  	1,0,0,0,1031,1032,1,0,0,0,1032,163,1,0,0,0,1033,1034,5,59,0,0,1034,1035,
  	3,170,85,0,1035,165,1,0,0,0,1036,1037,5,46,0,0,1037,1038,3,170,85,0,1038,
  	1039,3,132,66,0,1039,167,1,0,0,0,1040,1042,7,12,0,0,1041,1043,5,101,0,
  	0,1042,1041,1,0,0,0,1042,1043,1,0,0,0,1043,169,1,0,0,0,1044,1045,7,13,
  	0,0,1045,171,1,0,0,0,1046,1048,5,102,0,0,1047,1046,1,0,0,0,1048,1049,
  	1,0,0,0,1049,1047,1,0,0,0,1049,1050,1,0,0,0,1050,173,1,0,0,0,1051,1053,
  	5,124,0,0,1052,1051,1,0,0,0,1053,1054,1,0,0,0,1054,1052,1,0,0,0,1054,
  	1055,1,0,0,0,1055,175,1,0,0,0,122,181,183,197,201,204,214,220,224,236,
  	244,249,252,262,265,271,279,282,291,300,302,308,319,324,331,345,348,355,
  	359,361,366,372,376,382,387,400,402,408,411,417,425,431,444,447,453,456,
  	464,467,473,476,480,489,494,499,507,514,524,534,552,564,569,575,579,582,
  	596,600,603,610,614,634,652,656,661,665,669,674,679,683,689,700,725,774,
  	780,784,800,802,812,819,821,828,836,840,848,852,854,863,867,871,881,884,
  	887,891,911,917,924,930,934,940,944,950,961,975,981,987,993,997,1020,
  	1023,1027,1031,1042,1049,1054
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  solidityParserStaticData = staticData.release();
}

}

SolidityParser::SolidityParser(TokenStream *input) : SolidityParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

SolidityParser::SolidityParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  SolidityParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *solidityParserStaticData->atn, solidityParserStaticData->decisionToDFA, solidityParserStaticData->sharedContextCache, options);
}

SolidityParser::~SolidityParser() {
  delete _interpreter;
}

const atn::ATN& SolidityParser::getATN() const {
  return *solidityParserStaticData->atn;
}

std::string SolidityParser::getGrammarFileName() const {
  return "Solidity.g4";
}

const std::vector<std::string>& SolidityParser::getRuleNames() const {
  return solidityParserStaticData->ruleNames;
}

const dfa::Vocabulary& SolidityParser::getVocabulary() const {
  return solidityParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView SolidityParser::getSerializedATN() const {
  return solidityParserStaticData->serializedATN;
}


//----------------- SourceUnitContext ------------------------------------------------------------------

SolidityParser::SourceUnitContext::SourceUnitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SolidityParser::SourceUnitContext::EOF() {
  return getToken(SolidityParser::EOF, 0);
}

std::vector<SolidityParser::PragmaDirectiveContext *> SolidityParser::SourceUnitContext::pragmaDirective() {
  return getRuleContexts<SolidityParser::PragmaDirectiveContext>();
}

SolidityParser::PragmaDirectiveContext* SolidityParser::SourceUnitContext::pragmaDirective(size_t i) {
  return getRuleContext<SolidityParser::PragmaDirectiveContext>(i);
}

std::vector<SolidityParser::ImportDirectiveContext *> SolidityParser::SourceUnitContext::importDirective() {
  return getRuleContexts<SolidityParser::ImportDirectiveContext>();
}

SolidityParser::ImportDirectiveContext* SolidityParser::SourceUnitContext::importDirective(size_t i) {
  return getRuleContext<SolidityParser::ImportDirectiveContext>(i);
}

std::vector<SolidityParser::StructDefinitionContext *> SolidityParser::SourceUnitContext::structDefinition() {
  return getRuleContexts<SolidityParser::StructDefinitionContext>();
}

SolidityParser::StructDefinitionContext* SolidityParser::SourceUnitContext::structDefinition(size_t i) {
  return getRuleContext<SolidityParser::StructDefinitionContext>(i);
}

std::vector<SolidityParser::EnumDefinitionContext *> SolidityParser::SourceUnitContext::enumDefinition() {
  return getRuleContexts<SolidityParser::EnumDefinitionContext>();
}

SolidityParser::EnumDefinitionContext* SolidityParser::SourceUnitContext::enumDefinition(size_t i) {
  return getRuleContext<SolidityParser::EnumDefinitionContext>(i);
}

std::vector<SolidityParser::ContractDefinitionContext *> SolidityParser::SourceUnitContext::contractDefinition() {
  return getRuleContexts<SolidityParser::ContractDefinitionContext>();
}

SolidityParser::ContractDefinitionContext* SolidityParser::SourceUnitContext::contractDefinition(size_t i) {
  return getRuleContext<SolidityParser::ContractDefinitionContext>(i);
}


size_t SolidityParser::SourceUnitContext::getRuleIndex() const {
  return SolidityParser::RuleSourceUnit;
}

void SolidityParser::SourceUnitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSourceUnit(this);
}

void SolidityParser::SourceUnitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSourceUnit(this);
}

SolidityParser::SourceUnitContext* SolidityParser::sourceUnit() {
  SourceUnitContext *_localctx = _tracker.createInstance<SourceUnitContext>(_ctx, getState());
  enterRule(_localctx, 0, SolidityParser::RuleSourceUnit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(183);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4431152130) != 0) {
      setState(181);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SolidityParser::T__0: {
          setState(176);
          pragmaDirective();
          break;
        }

        case SolidityParser::T__9: {
          setState(177);
          importDirective();
          break;
        }

        case SolidityParser::T__26: {
          setState(178);
          structDefinition();
          break;
        }

        case SolidityParser::T__31: {
          setState(179);
          enumDefinition();
          break;
        }

        case SolidityParser::T__16:
        case SolidityParser::T__17:
        case SolidityParser::T__18:
        case SolidityParser::T__19: {
          setState(180);
          contractDefinition();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(185);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(186);
    match(SolidityParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PragmaDirectiveContext ------------------------------------------------------------------

SolidityParser::PragmaDirectiveContext::PragmaDirectiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::PragmaNameContext* SolidityParser::PragmaDirectiveContext::pragmaName() {
  return getRuleContext<SolidityParser::PragmaNameContext>(0);
}

SolidityParser::PragmaValueContext* SolidityParser::PragmaDirectiveContext::pragmaValue() {
  return getRuleContext<SolidityParser::PragmaValueContext>(0);
}


size_t SolidityParser::PragmaDirectiveContext::getRuleIndex() const {
  return SolidityParser::RulePragmaDirective;
}

void SolidityParser::PragmaDirectiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragmaDirective(this);
}

void SolidityParser::PragmaDirectiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragmaDirective(this);
}

SolidityParser::PragmaDirectiveContext* SolidityParser::pragmaDirective() {
  PragmaDirectiveContext *_localctx = _tracker.createInstance<PragmaDirectiveContext>(_ctx, getState());
  enterRule(_localctx, 2, SolidityParser::RulePragmaDirective);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(188);
    match(SolidityParser::T__0);
    setState(189);
    pragmaName();
    setState(190);
    pragmaValue();
    setState(191);
    match(SolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PragmaNameContext ------------------------------------------------------------------

SolidityParser::PragmaNameContext::PragmaNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IdentifierContext* SolidityParser::PragmaNameContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}


size_t SolidityParser::PragmaNameContext::getRuleIndex() const {
  return SolidityParser::RulePragmaName;
}

void SolidityParser::PragmaNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragmaName(this);
}

void SolidityParser::PragmaNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragmaName(this);
}

SolidityParser::PragmaNameContext* SolidityParser::pragmaName() {
  PragmaNameContext *_localctx = _tracker.createInstance<PragmaNameContext>(_ctx, getState());
  enterRule(_localctx, 4, SolidityParser::RulePragmaName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(193);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PragmaValueContext ------------------------------------------------------------------

SolidityParser::PragmaValueContext::PragmaValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::VersionContext* SolidityParser::PragmaValueContext::version() {
  return getRuleContext<SolidityParser::VersionContext>(0);
}

SolidityParser::ExpressionContext* SolidityParser::PragmaValueContext::expression() {
  return getRuleContext<SolidityParser::ExpressionContext>(0);
}


size_t SolidityParser::PragmaValueContext::getRuleIndex() const {
  return SolidityParser::RulePragmaValue;
}

void SolidityParser::PragmaValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragmaValue(this);
}

void SolidityParser::PragmaValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragmaValue(this);
}

SolidityParser::PragmaValueContext* SolidityParser::pragmaValue() {
  PragmaValueContext *_localctx = _tracker.createInstance<PragmaValueContext>(_ctx, getState());
  enterRule(_localctx, 6, SolidityParser::RulePragmaValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(197);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(195);
      version();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(196);
      expression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VersionContext ------------------------------------------------------------------

SolidityParser::VersionContext::VersionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SolidityParser::VersionConstraintContext *> SolidityParser::VersionContext::versionConstraint() {
  return getRuleContexts<SolidityParser::VersionConstraintContext>();
}

SolidityParser::VersionConstraintContext* SolidityParser::VersionContext::versionConstraint(size_t i) {
  return getRuleContext<SolidityParser::VersionConstraintContext>(i);
}


size_t SolidityParser::VersionContext::getRuleIndex() const {
  return SolidityParser::RuleVersion;
}

void SolidityParser::VersionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVersion(this);
}

void SolidityParser::VersionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVersion(this);
}

SolidityParser::VersionContext* SolidityParser::version() {
  VersionContext *_localctx = _tracker.createInstance<VersionContext>(_ctx, getState());
  enterRule(_localctx, 8, SolidityParser::RuleVersion);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(199);
    versionConstraint();
    setState(201);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1016) != 0 || _la == SolidityParser::VersionLiteral) {
      setState(200);
      versionConstraint();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VersionConstraintContext ------------------------------------------------------------------

SolidityParser::VersionConstraintContext::VersionConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SolidityParser::VersionConstraintContext::VersionLiteral() {
  return getToken(SolidityParser::VersionLiteral, 0);
}

SolidityParser::VersionOperatorContext* SolidityParser::VersionConstraintContext::versionOperator() {
  return getRuleContext<SolidityParser::VersionOperatorContext>(0);
}


size_t SolidityParser::VersionConstraintContext::getRuleIndex() const {
  return SolidityParser::RuleVersionConstraint;
}

void SolidityParser::VersionConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVersionConstraint(this);
}

void SolidityParser::VersionConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVersionConstraint(this);
}

SolidityParser::VersionConstraintContext* SolidityParser::versionConstraint() {
  VersionConstraintContext *_localctx = _tracker.createInstance<VersionConstraintContext>(_ctx, getState());
  enterRule(_localctx, 10, SolidityParser::RuleVersionConstraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(204);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1016) != 0) {
      setState(203);
      versionOperator();
    }
    setState(206);
    match(SolidityParser::VersionLiteral);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VersionOperatorContext ------------------------------------------------------------------

SolidityParser::VersionOperatorContext::VersionOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SolidityParser::VersionOperatorContext::getRuleIndex() const {
  return SolidityParser::RuleVersionOperator;
}

void SolidityParser::VersionOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVersionOperator(this);
}

void SolidityParser::VersionOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVersionOperator(this);
}

SolidityParser::VersionOperatorContext* SolidityParser::versionOperator() {
  VersionOperatorContext *_localctx = _tracker.createInstance<VersionOperatorContext>(_ctx, getState());
  enterRule(_localctx, 12, SolidityParser::RuleVersionOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(208);
    _la = _input->LA(1);
    if (!(((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1016) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportDirectiveContext ------------------------------------------------------------------

SolidityParser::ImportDirectiveContext::ImportDirectiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SolidityParser::ImportDirectiveContext::StringLiteralFragment() {
  return getToken(SolidityParser::StringLiteralFragment, 0);
}

std::vector<SolidityParser::IdentifierContext *> SolidityParser::ImportDirectiveContext::identifier() {
  return getRuleContexts<SolidityParser::IdentifierContext>();
}

SolidityParser::IdentifierContext* SolidityParser::ImportDirectiveContext::identifier(size_t i) {
  return getRuleContext<SolidityParser::IdentifierContext>(i);
}

std::vector<SolidityParser::ImportDeclarationContext *> SolidityParser::ImportDirectiveContext::importDeclaration() {
  return getRuleContexts<SolidityParser::ImportDeclarationContext>();
}

SolidityParser::ImportDeclarationContext* SolidityParser::ImportDirectiveContext::importDeclaration(size_t i) {
  return getRuleContext<SolidityParser::ImportDeclarationContext>(i);
}


size_t SolidityParser::ImportDirectiveContext::getRuleIndex() const {
  return SolidityParser::RuleImportDirective;
}

void SolidityParser::ImportDirectiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportDirective(this);
}

void SolidityParser::ImportDirectiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportDirective(this);
}

SolidityParser::ImportDirectiveContext* SolidityParser::importDirective() {
  ImportDirectiveContext *_localctx = _tracker.createInstance<ImportDirectiveContext>(_ctx, getState());
  enterRule(_localctx, 14, SolidityParser::RuleImportDirective);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(244);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(210);
      match(SolidityParser::T__9);
      setState(211);
      match(SolidityParser::StringLiteralFragment);
      setState(214);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SolidityParser::T__10) {
        setState(212);
        match(SolidityParser::T__10);
        setState(213);
        identifier();
      }
      setState(216);
      match(SolidityParser::T__1);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(217);
      match(SolidityParser::T__9);
      setState(220);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SolidityParser::T__11: {
          setState(218);
          match(SolidityParser::T__11);
          break;
        }

        case SolidityParser::T__12:
        case SolidityParser::T__39:
        case SolidityParser::T__51:
        case SolidityParser::Identifier: {
          setState(219);
          identifier();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(224);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SolidityParser::T__10) {
        setState(222);
        match(SolidityParser::T__10);
        setState(223);
        identifier();
      }
      setState(226);
      match(SolidityParser::T__12);
      setState(227);
      match(SolidityParser::StringLiteralFragment);
      setState(228);
      match(SolidityParser::T__1);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(229);
      match(SolidityParser::T__9);
      setState(230);
      match(SolidityParser::T__13);
      setState(231);
      importDeclaration();
      setState(236);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SolidityParser::T__14) {
        setState(232);
        match(SolidityParser::T__14);
        setState(233);
        importDeclaration();
        setState(238);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(239);
      match(SolidityParser::T__15);
      setState(240);
      match(SolidityParser::T__12);
      setState(241);
      match(SolidityParser::StringLiteralFragment);
      setState(242);
      match(SolidityParser::T__1);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportDeclarationContext ------------------------------------------------------------------

SolidityParser::ImportDeclarationContext::ImportDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SolidityParser::IdentifierContext *> SolidityParser::ImportDeclarationContext::identifier() {
  return getRuleContexts<SolidityParser::IdentifierContext>();
}

SolidityParser::IdentifierContext* SolidityParser::ImportDeclarationContext::identifier(size_t i) {
  return getRuleContext<SolidityParser::IdentifierContext>(i);
}


size_t SolidityParser::ImportDeclarationContext::getRuleIndex() const {
  return SolidityParser::RuleImportDeclaration;
}

void SolidityParser::ImportDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportDeclaration(this);
}

void SolidityParser::ImportDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportDeclaration(this);
}

SolidityParser::ImportDeclarationContext* SolidityParser::importDeclaration() {
  ImportDeclarationContext *_localctx = _tracker.createInstance<ImportDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 16, SolidityParser::RuleImportDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(246);
    identifier();
    setState(249);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SolidityParser::T__10) {
      setState(247);
      match(SolidityParser::T__10);
      setState(248);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ContractDefinitionContext ------------------------------------------------------------------

SolidityParser::ContractDefinitionContext::ContractDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IdentifierContext* SolidityParser::ContractDefinitionContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}

std::vector<SolidityParser::InheritanceSpecifierContext *> SolidityParser::ContractDefinitionContext::inheritanceSpecifier() {
  return getRuleContexts<SolidityParser::InheritanceSpecifierContext>();
}

SolidityParser::InheritanceSpecifierContext* SolidityParser::ContractDefinitionContext::inheritanceSpecifier(size_t i) {
  return getRuleContext<SolidityParser::InheritanceSpecifierContext>(i);
}

std::vector<SolidityParser::ContractPartContext *> SolidityParser::ContractDefinitionContext::contractPart() {
  return getRuleContexts<SolidityParser::ContractPartContext>();
}

SolidityParser::ContractPartContext* SolidityParser::ContractDefinitionContext::contractPart(size_t i) {
  return getRuleContext<SolidityParser::ContractPartContext>(i);
}


size_t SolidityParser::ContractDefinitionContext::getRuleIndex() const {
  return SolidityParser::RuleContractDefinition;
}

void SolidityParser::ContractDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContractDefinition(this);
}

void SolidityParser::ContractDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContractDefinition(this);
}

SolidityParser::ContractDefinitionContext* SolidityParser::contractDefinition() {
  ContractDefinitionContext *_localctx = _tracker.createInstance<ContractDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 18, SolidityParser::RuleContractDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(252);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SolidityParser::T__16) {
      setState(251);
      match(SolidityParser::T__16);
    }
    setState(254);
    _la = _input->LA(1);
    if (!(((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1835008) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(255);
    identifier();
    setState(265);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SolidityParser::T__20) {
      setState(256);
      match(SolidityParser::T__20);
      setState(257);
      inheritanceSpecifier();
      setState(262);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SolidityParser::T__14) {
        setState(258);
        match(SolidityParser::T__14);
        setState(259);
        inheritanceSpecifier();
        setState(264);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(267);
    match(SolidityParser::T__13);
    setState(271);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 69806969870884864) != 0 || (((_la - 93) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 93)) & 2013265951) != 0) {
      setState(268);
      contractPart();
      setState(273);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(274);
    match(SolidityParser::T__15);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InheritanceSpecifierContext ------------------------------------------------------------------

SolidityParser::InheritanceSpecifierContext::InheritanceSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::UserDefinedTypeNameContext* SolidityParser::InheritanceSpecifierContext::userDefinedTypeName() {
  return getRuleContext<SolidityParser::UserDefinedTypeNameContext>(0);
}

SolidityParser::ExpressionListContext* SolidityParser::InheritanceSpecifierContext::expressionList() {
  return getRuleContext<SolidityParser::ExpressionListContext>(0);
}


size_t SolidityParser::InheritanceSpecifierContext::getRuleIndex() const {
  return SolidityParser::RuleInheritanceSpecifier;
}

void SolidityParser::InheritanceSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInheritanceSpecifier(this);
}

void SolidityParser::InheritanceSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInheritanceSpecifier(this);
}

SolidityParser::InheritanceSpecifierContext* SolidityParser::inheritanceSpecifier() {
  InheritanceSpecifierContext *_localctx = _tracker.createInstance<InheritanceSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 20, SolidityParser::RuleInheritanceSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(276);
    userDefinedTypeName();
    setState(282);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SolidityParser::T__21) {
      setState(277);
      match(SolidityParser::T__21);
      setState(279);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -578711444011343856) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 1747960017153163265) != 0) {
        setState(278);
        expressionList();
      }
      setState(281);
      match(SolidityParser::T__22);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ContractPartContext ------------------------------------------------------------------

SolidityParser::ContractPartContext::ContractPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::StateVariableDeclarationContext* SolidityParser::ContractPartContext::stateVariableDeclaration() {
  return getRuleContext<SolidityParser::StateVariableDeclarationContext>(0);
}

SolidityParser::UsingForDeclarationContext* SolidityParser::ContractPartContext::usingForDeclaration() {
  return getRuleContext<SolidityParser::UsingForDeclarationContext>(0);
}

SolidityParser::StructDefinitionContext* SolidityParser::ContractPartContext::structDefinition() {
  return getRuleContext<SolidityParser::StructDefinitionContext>(0);
}

SolidityParser::ModifierDefinitionContext* SolidityParser::ContractPartContext::modifierDefinition() {
  return getRuleContext<SolidityParser::ModifierDefinitionContext>(0);
}

SolidityParser::FunctionDefinitionContext* SolidityParser::ContractPartContext::functionDefinition() {
  return getRuleContext<SolidityParser::FunctionDefinitionContext>(0);
}

SolidityParser::EventDefinitionContext* SolidityParser::ContractPartContext::eventDefinition() {
  return getRuleContext<SolidityParser::EventDefinitionContext>(0);
}

SolidityParser::EnumDefinitionContext* SolidityParser::ContractPartContext::enumDefinition() {
  return getRuleContext<SolidityParser::EnumDefinitionContext>(0);
}


size_t SolidityParser::ContractPartContext::getRuleIndex() const {
  return SolidityParser::RuleContractPart;
}

void SolidityParser::ContractPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContractPart(this);
}

void SolidityParser::ContractPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContractPart(this);
}

SolidityParser::ContractPartContext* SolidityParser::contractPart() {
  ContractPartContext *_localctx = _tracker.createInstance<ContractPartContext>(_ctx, getState());
  enterRule(_localctx, 22, SolidityParser::RuleContractPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(291);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(284);
      stateVariableDeclaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(285);
      usingForDeclaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(286);
      structDefinition();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(287);
      modifierDefinition();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(288);
      functionDefinition();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(289);
      eventDefinition();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(290);
      enumDefinition();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StateVariableDeclarationContext ------------------------------------------------------------------

SolidityParser::StateVariableDeclarationContext::StateVariableDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::TypeNameContext* SolidityParser::StateVariableDeclarationContext::typeName() {
  return getRuleContext<SolidityParser::TypeNameContext>(0);
}

SolidityParser::IdentifierContext* SolidityParser::StateVariableDeclarationContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}

std::vector<tree::TerminalNode *> SolidityParser::StateVariableDeclarationContext::PublicKeyword() {
  return getTokens(SolidityParser::PublicKeyword);
}

tree::TerminalNode* SolidityParser::StateVariableDeclarationContext::PublicKeyword(size_t i) {
  return getToken(SolidityParser::PublicKeyword, i);
}

std::vector<tree::TerminalNode *> SolidityParser::StateVariableDeclarationContext::InternalKeyword() {
  return getTokens(SolidityParser::InternalKeyword);
}

tree::TerminalNode* SolidityParser::StateVariableDeclarationContext::InternalKeyword(size_t i) {
  return getToken(SolidityParser::InternalKeyword, i);
}

std::vector<tree::TerminalNode *> SolidityParser::StateVariableDeclarationContext::PrivateKeyword() {
  return getTokens(SolidityParser::PrivateKeyword);
}

tree::TerminalNode* SolidityParser::StateVariableDeclarationContext::PrivateKeyword(size_t i) {
  return getToken(SolidityParser::PrivateKeyword, i);
}

std::vector<tree::TerminalNode *> SolidityParser::StateVariableDeclarationContext::ConstantKeyword() {
  return getTokens(SolidityParser::ConstantKeyword);
}

tree::TerminalNode* SolidityParser::StateVariableDeclarationContext::ConstantKeyword(size_t i) {
  return getToken(SolidityParser::ConstantKeyword, i);
}

std::vector<tree::TerminalNode *> SolidityParser::StateVariableDeclarationContext::ImmutableKeyword() {
  return getTokens(SolidityParser::ImmutableKeyword);
}

tree::TerminalNode* SolidityParser::StateVariableDeclarationContext::ImmutableKeyword(size_t i) {
  return getToken(SolidityParser::ImmutableKeyword, i);
}

std::vector<SolidityParser::OverrideSpecifierContext *> SolidityParser::StateVariableDeclarationContext::overrideSpecifier() {
  return getRuleContexts<SolidityParser::OverrideSpecifierContext>();
}

SolidityParser::OverrideSpecifierContext* SolidityParser::StateVariableDeclarationContext::overrideSpecifier(size_t i) {
  return getRuleContext<SolidityParser::OverrideSpecifierContext>(i);
}

SolidityParser::ExpressionContext* SolidityParser::StateVariableDeclarationContext::expression() {
  return getRuleContext<SolidityParser::ExpressionContext>(0);
}


size_t SolidityParser::StateVariableDeclarationContext::getRuleIndex() const {
  return SolidityParser::RuleStateVariableDeclaration;
}

void SolidityParser::StateVariableDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStateVariableDeclaration(this);
}

void SolidityParser::StateVariableDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStateVariableDeclaration(this);
}

SolidityParser::StateVariableDeclarationContext* SolidityParser::stateVariableDeclaration() {
  StateVariableDeclarationContext *_localctx = _tracker.createInstance<StateVariableDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 24, SolidityParser::RuleStateVariableDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(293);
    typeName(0);
    setState(302);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SolidityParser::T__23 || (((_la - 106) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 106)) & 835) != 0) {
      setState(300);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SolidityParser::PublicKeyword: {
          setState(294);
          match(SolidityParser::PublicKeyword);
          break;
        }

        case SolidityParser::InternalKeyword: {
          setState(295);
          match(SolidityParser::InternalKeyword);
          break;
        }

        case SolidityParser::PrivateKeyword: {
          setState(296);
          match(SolidityParser::PrivateKeyword);
          break;
        }

        case SolidityParser::ConstantKeyword: {
          setState(297);
          match(SolidityParser::ConstantKeyword);
          break;
        }

        case SolidityParser::ImmutableKeyword: {
          setState(298);
          match(SolidityParser::ImmutableKeyword);
          break;
        }

        case SolidityParser::T__23: {
          setState(299);
          overrideSpecifier();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(304);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(305);
    identifier();
    setState(308);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SolidityParser::T__8) {
      setState(306);
      match(SolidityParser::T__8);
      setState(307);
      expression(0);
    }
    setState(310);
    match(SolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OverrideSpecifierContext ------------------------------------------------------------------

SolidityParser::OverrideSpecifierContext::OverrideSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SolidityParser::UserDefinedTypeNameContext *> SolidityParser::OverrideSpecifierContext::userDefinedTypeName() {
  return getRuleContexts<SolidityParser::UserDefinedTypeNameContext>();
}

SolidityParser::UserDefinedTypeNameContext* SolidityParser::OverrideSpecifierContext::userDefinedTypeName(size_t i) {
  return getRuleContext<SolidityParser::UserDefinedTypeNameContext>(i);
}


size_t SolidityParser::OverrideSpecifierContext::getRuleIndex() const {
  return SolidityParser::RuleOverrideSpecifier;
}

void SolidityParser::OverrideSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverrideSpecifier(this);
}

void SolidityParser::OverrideSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverrideSpecifier(this);
}

SolidityParser::OverrideSpecifierContext* SolidityParser::overrideSpecifier() {
  OverrideSpecifierContext *_localctx = _tracker.createInstance<OverrideSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 26, SolidityParser::RuleOverrideSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(312);
    match(SolidityParser::T__23);
    setState(324);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx)) {
    case 1: {
      setState(313);
      match(SolidityParser::T__21);
      setState(314);
      userDefinedTypeName();
      setState(319);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SolidityParser::T__14) {
        setState(315);
        match(SolidityParser::T__14);
        setState(316);
        userDefinedTypeName();
        setState(321);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(322);
      match(SolidityParser::T__22);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UsingForDeclarationContext ------------------------------------------------------------------

SolidityParser::UsingForDeclarationContext::UsingForDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IdentifierContext* SolidityParser::UsingForDeclarationContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}

SolidityParser::TypeNameContext* SolidityParser::UsingForDeclarationContext::typeName() {
  return getRuleContext<SolidityParser::TypeNameContext>(0);
}


size_t SolidityParser::UsingForDeclarationContext::getRuleIndex() const {
  return SolidityParser::RuleUsingForDeclaration;
}

void SolidityParser::UsingForDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUsingForDeclaration(this);
}

void SolidityParser::UsingForDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUsingForDeclaration(this);
}

SolidityParser::UsingForDeclarationContext* SolidityParser::usingForDeclaration() {
  UsingForDeclarationContext *_localctx = _tracker.createInstance<UsingForDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 28, SolidityParser::RuleUsingForDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(326);
    match(SolidityParser::T__24);
    setState(327);
    identifier();
    setState(328);
    match(SolidityParser::T__25);
    setState(331);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SolidityParser::T__11: {
        setState(329);
        match(SolidityParser::T__11);
        break;
      }

      case SolidityParser::T__12:
      case SolidityParser::T__28:
      case SolidityParser::T__35:
      case SolidityParser::T__39:
      case SolidityParser::T__50:
      case SolidityParser::T__51:
      case SolidityParser::T__52:
      case SolidityParser::T__53:
      case SolidityParser::T__54:
      case SolidityParser::Int:
      case SolidityParser::Uint:
      case SolidityParser::Byte:
      case SolidityParser::Fixed:
      case SolidityParser::Ufixed:
      case SolidityParser::Identifier: {
        setState(330);
        typeName(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(333);
    match(SolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StructDefinitionContext ------------------------------------------------------------------

SolidityParser::StructDefinitionContext::StructDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IdentifierContext* SolidityParser::StructDefinitionContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}

std::vector<SolidityParser::VariableDeclarationContext *> SolidityParser::StructDefinitionContext::variableDeclaration() {
  return getRuleContexts<SolidityParser::VariableDeclarationContext>();
}

SolidityParser::VariableDeclarationContext* SolidityParser::StructDefinitionContext::variableDeclaration(size_t i) {
  return getRuleContext<SolidityParser::VariableDeclarationContext>(i);
}


size_t SolidityParser::StructDefinitionContext::getRuleIndex() const {
  return SolidityParser::RuleStructDefinition;
}

void SolidityParser::StructDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStructDefinition(this);
}

void SolidityParser::StructDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStructDefinition(this);
}

SolidityParser::StructDefinitionContext* SolidityParser::structDefinition() {
  StructDefinitionContext *_localctx = _tracker.createInstance<StructDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 30, SolidityParser::RuleStructDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(335);
    match(SolidityParser::T__26);
    setState(336);
    identifier();
    setState(337);
    match(SolidityParser::T__13);
    setState(348);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 69806962992226304) != 0 || (((_la - 93) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 93)) & 1073741855) != 0) {
      setState(338);
      variableDeclaration();
      setState(339);
      match(SolidityParser::T__1);
      setState(345);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 69806962992226304) != 0 || (((_la - 93) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 93)) & 1073741855) != 0) {
        setState(340);
        variableDeclaration();
        setState(341);
        match(SolidityParser::T__1);
        setState(347);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(350);
    match(SolidityParser::T__15);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModifierDefinitionContext ------------------------------------------------------------------

SolidityParser::ModifierDefinitionContext::ModifierDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IdentifierContext* SolidityParser::ModifierDefinitionContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}

SolidityParser::BlockContext* SolidityParser::ModifierDefinitionContext::block() {
  return getRuleContext<SolidityParser::BlockContext>(0);
}

SolidityParser::ParameterListContext* SolidityParser::ModifierDefinitionContext::parameterList() {
  return getRuleContext<SolidityParser::ParameterListContext>(0);
}

std::vector<tree::TerminalNode *> SolidityParser::ModifierDefinitionContext::VirtualKeyword() {
  return getTokens(SolidityParser::VirtualKeyword);
}

tree::TerminalNode* SolidityParser::ModifierDefinitionContext::VirtualKeyword(size_t i) {
  return getToken(SolidityParser::VirtualKeyword, i);
}

std::vector<SolidityParser::OverrideSpecifierContext *> SolidityParser::ModifierDefinitionContext::overrideSpecifier() {
  return getRuleContexts<SolidityParser::OverrideSpecifierContext>();
}

SolidityParser::OverrideSpecifierContext* SolidityParser::ModifierDefinitionContext::overrideSpecifier(size_t i) {
  return getRuleContext<SolidityParser::OverrideSpecifierContext>(i);
}


size_t SolidityParser::ModifierDefinitionContext::getRuleIndex() const {
  return SolidityParser::RuleModifierDefinition;
}

void SolidityParser::ModifierDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModifierDefinition(this);
}

void SolidityParser::ModifierDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModifierDefinition(this);
}

SolidityParser::ModifierDefinitionContext* SolidityParser::modifierDefinition() {
  ModifierDefinitionContext *_localctx = _tracker.createInstance<ModifierDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 32, SolidityParser::RuleModifierDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(352);
    match(SolidityParser::T__27);
    setState(353);
    identifier();
    setState(355);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SolidityParser::T__21) {
      setState(354);
      parameterList();
    }
    setState(361);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SolidityParser::T__23 || _la == SolidityParser::VirtualKeyword) {
      setState(359);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SolidityParser::VirtualKeyword: {
          setState(357);
          match(SolidityParser::VirtualKeyword);
          break;
        }

        case SolidityParser::T__23: {
          setState(358);
          overrideSpecifier();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(363);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(366);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SolidityParser::T__1: {
        setState(364);
        match(SolidityParser::T__1);
        break;
      }

      case SolidityParser::T__13: {
        setState(365);
        block();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDefinitionContext ------------------------------------------------------------------

SolidityParser::FunctionDefinitionContext::FunctionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::FunctionDescriptorContext* SolidityParser::FunctionDefinitionContext::functionDescriptor() {
  return getRuleContext<SolidityParser::FunctionDescriptorContext>(0);
}

SolidityParser::ParameterListContext* SolidityParser::FunctionDefinitionContext::parameterList() {
  return getRuleContext<SolidityParser::ParameterListContext>(0);
}

SolidityParser::ModifierListContext* SolidityParser::FunctionDefinitionContext::modifierList() {
  return getRuleContext<SolidityParser::ModifierListContext>(0);
}

SolidityParser::BlockContext* SolidityParser::FunctionDefinitionContext::block() {
  return getRuleContext<SolidityParser::BlockContext>(0);
}

SolidityParser::ReturnParametersContext* SolidityParser::FunctionDefinitionContext::returnParameters() {
  return getRuleContext<SolidityParser::ReturnParametersContext>(0);
}


size_t SolidityParser::FunctionDefinitionContext::getRuleIndex() const {
  return SolidityParser::RuleFunctionDefinition;
}

void SolidityParser::FunctionDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionDefinition(this);
}

void SolidityParser::FunctionDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionDefinition(this);
}

SolidityParser::FunctionDefinitionContext* SolidityParser::functionDefinition() {
  FunctionDefinitionContext *_localctx = _tracker.createInstance<FunctionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 34, SolidityParser::RuleFunctionDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(368);
    functionDescriptor();
    setState(369);
    parameterList();
    setState(370);
    modifierList();
    setState(372);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SolidityParser::T__29) {
      setState(371);
      returnParameters();
    }
    setState(376);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SolidityParser::T__1: {
        setState(374);
        match(SolidityParser::T__1);
        break;
      }

      case SolidityParser::T__13: {
        setState(375);
        block();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDescriptorContext ------------------------------------------------------------------

SolidityParser::FunctionDescriptorContext::FunctionDescriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IdentifierContext* SolidityParser::FunctionDescriptorContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}

tree::TerminalNode* SolidityParser::FunctionDescriptorContext::ReceiveKeyword() {
  return getToken(SolidityParser::ReceiveKeyword, 0);
}

tree::TerminalNode* SolidityParser::FunctionDescriptorContext::FallbackKeyword() {
  return getToken(SolidityParser::FallbackKeyword, 0);
}

tree::TerminalNode* SolidityParser::FunctionDescriptorContext::ConstructorKeyword() {
  return getToken(SolidityParser::ConstructorKeyword, 0);
}


size_t SolidityParser::FunctionDescriptorContext::getRuleIndex() const {
  return SolidityParser::RuleFunctionDescriptor;
}

void SolidityParser::FunctionDescriptorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionDescriptor(this);
}

void SolidityParser::FunctionDescriptorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionDescriptor(this);
}

SolidityParser::FunctionDescriptorContext* SolidityParser::functionDescriptor() {
  FunctionDescriptorContext *_localctx = _tracker.createInstance<FunctionDescriptorContext>(_ctx, getState());
  enterRule(_localctx, 36, SolidityParser::RuleFunctionDescriptor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(387);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SolidityParser::T__28: {
        enterOuterAlt(_localctx, 1);
        setState(378);
        match(SolidityParser::T__28);
        setState(382);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SolidityParser::T__12:
          case SolidityParser::T__39:
          case SolidityParser::T__51:
          case SolidityParser::Identifier: {
            setState(379);
            identifier();
            break;
          }

          case SolidityParser::ReceiveKeyword: {
            setState(380);
            match(SolidityParser::ReceiveKeyword);
            break;
          }

          case SolidityParser::FallbackKeyword: {
            setState(381);
            match(SolidityParser::FallbackKeyword);
            break;
          }

          case SolidityParser::T__21: {
            break;
          }

        default:
          break;
        }
        break;
      }

      case SolidityParser::ConstructorKeyword: {
        enterOuterAlt(_localctx, 2);
        setState(384);
        match(SolidityParser::ConstructorKeyword);
        break;
      }

      case SolidityParser::FallbackKeyword: {
        enterOuterAlt(_localctx, 3);
        setState(385);
        match(SolidityParser::FallbackKeyword);
        break;
      }

      case SolidityParser::ReceiveKeyword: {
        enterOuterAlt(_localctx, 4);
        setState(386);
        match(SolidityParser::ReceiveKeyword);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnParametersContext ------------------------------------------------------------------

SolidityParser::ReturnParametersContext::ReturnParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::ParameterListContext* SolidityParser::ReturnParametersContext::parameterList() {
  return getRuleContext<SolidityParser::ParameterListContext>(0);
}


size_t SolidityParser::ReturnParametersContext::getRuleIndex() const {
  return SolidityParser::RuleReturnParameters;
}

void SolidityParser::ReturnParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnParameters(this);
}

void SolidityParser::ReturnParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnParameters(this);
}

SolidityParser::ReturnParametersContext* SolidityParser::returnParameters() {
  ReturnParametersContext *_localctx = _tracker.createInstance<ReturnParametersContext>(_ctx, getState());
  enterRule(_localctx, 38, SolidityParser::RuleReturnParameters);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(389);
    match(SolidityParser::T__29);
    setState(390);
    parameterList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModifierListContext ------------------------------------------------------------------

SolidityParser::ModifierListContext::ModifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SolidityParser::ModifierInvocationContext *> SolidityParser::ModifierListContext::modifierInvocation() {
  return getRuleContexts<SolidityParser::ModifierInvocationContext>();
}

SolidityParser::ModifierInvocationContext* SolidityParser::ModifierListContext::modifierInvocation(size_t i) {
  return getRuleContext<SolidityParser::ModifierInvocationContext>(i);
}

std::vector<SolidityParser::StateMutabilityContext *> SolidityParser::ModifierListContext::stateMutability() {
  return getRuleContexts<SolidityParser::StateMutabilityContext>();
}

SolidityParser::StateMutabilityContext* SolidityParser::ModifierListContext::stateMutability(size_t i) {
  return getRuleContext<SolidityParser::StateMutabilityContext>(i);
}

std::vector<tree::TerminalNode *> SolidityParser::ModifierListContext::ExternalKeyword() {
  return getTokens(SolidityParser::ExternalKeyword);
}

tree::TerminalNode* SolidityParser::ModifierListContext::ExternalKeyword(size_t i) {
  return getToken(SolidityParser::ExternalKeyword, i);
}

std::vector<tree::TerminalNode *> SolidityParser::ModifierListContext::PublicKeyword() {
  return getTokens(SolidityParser::PublicKeyword);
}

tree::TerminalNode* SolidityParser::ModifierListContext::PublicKeyword(size_t i) {
  return getToken(SolidityParser::PublicKeyword, i);
}

std::vector<tree::TerminalNode *> SolidityParser::ModifierListContext::InternalKeyword() {
  return getTokens(SolidityParser::InternalKeyword);
}

tree::TerminalNode* SolidityParser::ModifierListContext::InternalKeyword(size_t i) {
  return getToken(SolidityParser::InternalKeyword, i);
}

std::vector<tree::TerminalNode *> SolidityParser::ModifierListContext::PrivateKeyword() {
  return getTokens(SolidityParser::PrivateKeyword);
}

tree::TerminalNode* SolidityParser::ModifierListContext::PrivateKeyword(size_t i) {
  return getToken(SolidityParser::PrivateKeyword, i);
}

std::vector<tree::TerminalNode *> SolidityParser::ModifierListContext::VirtualKeyword() {
  return getTokens(SolidityParser::VirtualKeyword);
}

tree::TerminalNode* SolidityParser::ModifierListContext::VirtualKeyword(size_t i) {
  return getToken(SolidityParser::VirtualKeyword, i);
}

std::vector<SolidityParser::OverrideSpecifierContext *> SolidityParser::ModifierListContext::overrideSpecifier() {
  return getRuleContexts<SolidityParser::OverrideSpecifierContext>();
}

SolidityParser::OverrideSpecifierContext* SolidityParser::ModifierListContext::overrideSpecifier(size_t i) {
  return getRuleContext<SolidityParser::OverrideSpecifierContext>(i);
}


size_t SolidityParser::ModifierListContext::getRuleIndex() const {
  return SolidityParser::RuleModifierList;
}

void SolidityParser::ModifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModifierList(this);
}

void SolidityParser::ModifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModifierList(this);
}

SolidityParser::ModifierListContext* SolidityParser::modifierList() {
  ModifierListContext *_localctx = _tracker.createInstance<ModifierListContext>(_ctx, getState());
  enterRule(_localctx, 40, SolidityParser::RuleModifierList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(402);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(400);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SolidityParser::T__12:
          case SolidityParser::T__39:
          case SolidityParser::T__51:
          case SolidityParser::Identifier: {
            setState(392);
            modifierInvocation();
            break;
          }

          case SolidityParser::ConstantKeyword:
          case SolidityParser::PayableKeyword:
          case SolidityParser::PureKeyword:
          case SolidityParser::ViewKeyword: {
            setState(393);
            stateMutability();
            break;
          }

          case SolidityParser::ExternalKeyword: {
            setState(394);
            match(SolidityParser::ExternalKeyword);
            break;
          }

          case SolidityParser::PublicKeyword: {
            setState(395);
            match(SolidityParser::PublicKeyword);
            break;
          }

          case SolidityParser::InternalKeyword: {
            setState(396);
            match(SolidityParser::InternalKeyword);
            break;
          }

          case SolidityParser::PrivateKeyword: {
            setState(397);
            match(SolidityParser::PrivateKeyword);
            break;
          }

          case SolidityParser::VirtualKeyword: {
            setState(398);
            match(SolidityParser::VirtualKeyword);
            break;
          }

          case SolidityParser::T__23: {
            setState(399);
            overrideSpecifier();
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(404);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModifierInvocationContext ------------------------------------------------------------------

SolidityParser::ModifierInvocationContext::ModifierInvocationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IdentifierContext* SolidityParser::ModifierInvocationContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}

SolidityParser::ExpressionListContext* SolidityParser::ModifierInvocationContext::expressionList() {
  return getRuleContext<SolidityParser::ExpressionListContext>(0);
}


size_t SolidityParser::ModifierInvocationContext::getRuleIndex() const {
  return SolidityParser::RuleModifierInvocation;
}

void SolidityParser::ModifierInvocationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModifierInvocation(this);
}

void SolidityParser::ModifierInvocationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModifierInvocation(this);
}

SolidityParser::ModifierInvocationContext* SolidityParser::modifierInvocation() {
  ModifierInvocationContext *_localctx = _tracker.createInstance<ModifierInvocationContext>(_ctx, getState());
  enterRule(_localctx, 42, SolidityParser::RuleModifierInvocation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(405);
    identifier();
    setState(411);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
    case 1: {
      setState(406);
      match(SolidityParser::T__21);
      setState(408);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -578711444011343856) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 1747960017153163265) != 0) {
        setState(407);
        expressionList();
      }
      setState(410);
      match(SolidityParser::T__22);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EventDefinitionContext ------------------------------------------------------------------

SolidityParser::EventDefinitionContext::EventDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IdentifierContext* SolidityParser::EventDefinitionContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}

SolidityParser::EventParameterListContext* SolidityParser::EventDefinitionContext::eventParameterList() {
  return getRuleContext<SolidityParser::EventParameterListContext>(0);
}

tree::TerminalNode* SolidityParser::EventDefinitionContext::AnonymousKeyword() {
  return getToken(SolidityParser::AnonymousKeyword, 0);
}


size_t SolidityParser::EventDefinitionContext::getRuleIndex() const {
  return SolidityParser::RuleEventDefinition;
}

void SolidityParser::EventDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEventDefinition(this);
}

void SolidityParser::EventDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEventDefinition(this);
}

SolidityParser::EventDefinitionContext* SolidityParser::eventDefinition() {
  EventDefinitionContext *_localctx = _tracker.createInstance<EventDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 44, SolidityParser::RuleEventDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(413);
    match(SolidityParser::T__30);
    setState(414);
    identifier();
    setState(415);
    eventParameterList();
    setState(417);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SolidityParser::AnonymousKeyword) {
      setState(416);
      match(SolidityParser::AnonymousKeyword);
    }
    setState(419);
    match(SolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumDefinitionContext ------------------------------------------------------------------

SolidityParser::EnumDefinitionContext::EnumDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IdentifierContext* SolidityParser::EnumDefinitionContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}

std::vector<SolidityParser::EnumValueContext *> SolidityParser::EnumDefinitionContext::enumValue() {
  return getRuleContexts<SolidityParser::EnumValueContext>();
}

SolidityParser::EnumValueContext* SolidityParser::EnumDefinitionContext::enumValue(size_t i) {
  return getRuleContext<SolidityParser::EnumValueContext>(i);
}


size_t SolidityParser::EnumDefinitionContext::getRuleIndex() const {
  return SolidityParser::RuleEnumDefinition;
}

void SolidityParser::EnumDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumDefinition(this);
}

void SolidityParser::EnumDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumDefinition(this);
}

SolidityParser::EnumDefinitionContext* SolidityParser::enumDefinition() {
  EnumDefinitionContext *_localctx = _tracker.createInstance<EnumDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 46, SolidityParser::RuleEnumDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(421);
    match(SolidityParser::T__31);
    setState(422);
    identifier();
    setState(423);
    match(SolidityParser::T__13);
    setState(425);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4504699139006464) != 0 || _la == SolidityParser::Identifier) {
      setState(424);
      enumValue();
    }
    setState(431);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SolidityParser::T__14) {
      setState(427);
      match(SolidityParser::T__14);
      setState(428);
      enumValue();
      setState(433);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(434);
    match(SolidityParser::T__15);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumValueContext ------------------------------------------------------------------

SolidityParser::EnumValueContext::EnumValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IdentifierContext* SolidityParser::EnumValueContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}


size_t SolidityParser::EnumValueContext::getRuleIndex() const {
  return SolidityParser::RuleEnumValue;
}

void SolidityParser::EnumValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumValue(this);
}

void SolidityParser::EnumValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumValue(this);
}

SolidityParser::EnumValueContext* SolidityParser::enumValue() {
  EnumValueContext *_localctx = _tracker.createInstance<EnumValueContext>(_ctx, getState());
  enterRule(_localctx, 48, SolidityParser::RuleEnumValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(436);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterListContext ------------------------------------------------------------------

SolidityParser::ParameterListContext::ParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SolidityParser::ParameterContext *> SolidityParser::ParameterListContext::parameter() {
  return getRuleContexts<SolidityParser::ParameterContext>();
}

SolidityParser::ParameterContext* SolidityParser::ParameterListContext::parameter(size_t i) {
  return getRuleContext<SolidityParser::ParameterContext>(i);
}


size_t SolidityParser::ParameterListContext::getRuleIndex() const {
  return SolidityParser::RuleParameterList;
}

void SolidityParser::ParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameterList(this);
}

void SolidityParser::ParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameterList(this);
}

SolidityParser::ParameterListContext* SolidityParser::parameterList() {
  ParameterListContext *_localctx = _tracker.createInstance<ParameterListContext>(_ctx, getState());
  enterRule(_localctx, 50, SolidityParser::RuleParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(438);
    match(SolidityParser::T__21);
    setState(447);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 69806962992226304) != 0 || (((_la - 93) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 93)) & 1073741855) != 0) {
      setState(439);
      parameter();
      setState(444);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SolidityParser::T__14) {
        setState(440);
        match(SolidityParser::T__14);
        setState(441);
        parameter();
        setState(446);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(449);
    match(SolidityParser::T__22);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterContext ------------------------------------------------------------------

SolidityParser::ParameterContext::ParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::TypeNameContext* SolidityParser::ParameterContext::typeName() {
  return getRuleContext<SolidityParser::TypeNameContext>(0);
}

SolidityParser::StorageLocationContext* SolidityParser::ParameterContext::storageLocation() {
  return getRuleContext<SolidityParser::StorageLocationContext>(0);
}

SolidityParser::IdentifierContext* SolidityParser::ParameterContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}


size_t SolidityParser::ParameterContext::getRuleIndex() const {
  return SolidityParser::RuleParameter;
}

void SolidityParser::ParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter(this);
}

void SolidityParser::ParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter(this);
}

SolidityParser::ParameterContext* SolidityParser::parameter() {
  ParameterContext *_localctx = _tracker.createInstance<ParameterContext>(_ctx, getState());
  enterRule(_localctx, 52, SolidityParser::RuleParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(451);
    typeName(0);
    setState(453);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
    case 1: {
      setState(452);
      storageLocation();
      break;
    }

    default:
      break;
    }
    setState(456);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4504699139006464) != 0 || _la == SolidityParser::Identifier) {
      setState(455);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EventParameterListContext ------------------------------------------------------------------

SolidityParser::EventParameterListContext::EventParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SolidityParser::EventParameterContext *> SolidityParser::EventParameterListContext::eventParameter() {
  return getRuleContexts<SolidityParser::EventParameterContext>();
}

SolidityParser::EventParameterContext* SolidityParser::EventParameterListContext::eventParameter(size_t i) {
  return getRuleContext<SolidityParser::EventParameterContext>(i);
}


size_t SolidityParser::EventParameterListContext::getRuleIndex() const {
  return SolidityParser::RuleEventParameterList;
}

void SolidityParser::EventParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEventParameterList(this);
}

void SolidityParser::EventParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEventParameterList(this);
}

SolidityParser::EventParameterListContext* SolidityParser::eventParameterList() {
  EventParameterListContext *_localctx = _tracker.createInstance<EventParameterListContext>(_ctx, getState());
  enterRule(_localctx, 54, SolidityParser::RuleEventParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(458);
    match(SolidityParser::T__21);
    setState(467);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 69806962992226304) != 0 || (((_la - 93) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 93)) & 1073741855) != 0) {
      setState(459);
      eventParameter();
      setState(464);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SolidityParser::T__14) {
        setState(460);
        match(SolidityParser::T__14);
        setState(461);
        eventParameter();
        setState(466);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(469);
    match(SolidityParser::T__22);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EventParameterContext ------------------------------------------------------------------

SolidityParser::EventParameterContext::EventParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::TypeNameContext* SolidityParser::EventParameterContext::typeName() {
  return getRuleContext<SolidityParser::TypeNameContext>(0);
}

tree::TerminalNode* SolidityParser::EventParameterContext::IndexedKeyword() {
  return getToken(SolidityParser::IndexedKeyword, 0);
}

SolidityParser::IdentifierContext* SolidityParser::EventParameterContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}


size_t SolidityParser::EventParameterContext::getRuleIndex() const {
  return SolidityParser::RuleEventParameter;
}

void SolidityParser::EventParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEventParameter(this);
}

void SolidityParser::EventParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEventParameter(this);
}

SolidityParser::EventParameterContext* SolidityParser::eventParameter() {
  EventParameterContext *_localctx = _tracker.createInstance<EventParameterContext>(_ctx, getState());
  enterRule(_localctx, 56, SolidityParser::RuleEventParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(471);
    typeName(0);
    setState(473);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SolidityParser::IndexedKeyword) {
      setState(472);
      match(SolidityParser::IndexedKeyword);
    }
    setState(476);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4504699139006464) != 0 || _la == SolidityParser::Identifier) {
      setState(475);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationContext ------------------------------------------------------------------

SolidityParser::VariableDeclarationContext::VariableDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::TypeNameContext* SolidityParser::VariableDeclarationContext::typeName() {
  return getRuleContext<SolidityParser::TypeNameContext>(0);
}

SolidityParser::IdentifierContext* SolidityParser::VariableDeclarationContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}

SolidityParser::StorageLocationContext* SolidityParser::VariableDeclarationContext::storageLocation() {
  return getRuleContext<SolidityParser::StorageLocationContext>(0);
}


size_t SolidityParser::VariableDeclarationContext::getRuleIndex() const {
  return SolidityParser::RuleVariableDeclaration;
}

void SolidityParser::VariableDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclaration(this);
}

void SolidityParser::VariableDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclaration(this);
}

SolidityParser::VariableDeclarationContext* SolidityParser::variableDeclaration() {
  VariableDeclarationContext *_localctx = _tracker.createInstance<VariableDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 58, SolidityParser::RuleVariableDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(478);
    typeName(0);
    setState(480);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
    case 1: {
      setState(479);
      storageLocation();
      break;
    }

    default:
      break;
    }
    setState(482);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeNameContext ------------------------------------------------------------------

SolidityParser::TypeNameContext::TypeNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::ElementaryTypeNameContext* SolidityParser::TypeNameContext::elementaryTypeName() {
  return getRuleContext<SolidityParser::ElementaryTypeNameContext>(0);
}

SolidityParser::UserDefinedTypeNameContext* SolidityParser::TypeNameContext::userDefinedTypeName() {
  return getRuleContext<SolidityParser::UserDefinedTypeNameContext>(0);
}

SolidityParser::MappingContext* SolidityParser::TypeNameContext::mapping() {
  return getRuleContext<SolidityParser::MappingContext>(0);
}

SolidityParser::FunctionTypeNameContext* SolidityParser::TypeNameContext::functionTypeName() {
  return getRuleContext<SolidityParser::FunctionTypeNameContext>(0);
}

SolidityParser::TypeNameContext* SolidityParser::TypeNameContext::typeName() {
  return getRuleContext<SolidityParser::TypeNameContext>(0);
}

SolidityParser::ExpressionContext* SolidityParser::TypeNameContext::expression() {
  return getRuleContext<SolidityParser::ExpressionContext>(0);
}


size_t SolidityParser::TypeNameContext::getRuleIndex() const {
  return SolidityParser::RuleTypeName;
}

void SolidityParser::TypeNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeName(this);
}

void SolidityParser::TypeNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeName(this);
}


SolidityParser::TypeNameContext* SolidityParser::typeName() {
   return typeName(0);
}

SolidityParser::TypeNameContext* SolidityParser::typeName(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  SolidityParser::TypeNameContext *_localctx = _tracker.createInstance<TypeNameContext>(_ctx, parentState);
  SolidityParser::TypeNameContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 60;
  enterRecursionRule(_localctx, 60, SolidityParser::RuleTypeName, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(489);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx)) {
    case 1: {
      setState(485);
      elementaryTypeName();
      break;
    }

    case 2: {
      setState(486);
      userDefinedTypeName();
      break;
    }

    case 3: {
      setState(487);
      mapping();
      break;
    }

    case 4: {
      setState(488);
      functionTypeName();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(499);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<TypeNameContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleTypeName);
        setState(491);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(492);
        match(SolidityParser::T__32);
        setState(494);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & -578711444011343856) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1747960017153163265) != 0) {
          setState(493);
          expression(0);
        }
        setState(496);
        match(SolidityParser::T__33); 
      }
      setState(501);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- UserDefinedTypeNameContext ------------------------------------------------------------------

SolidityParser::UserDefinedTypeNameContext::UserDefinedTypeNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SolidityParser::IdentifierContext *> SolidityParser::UserDefinedTypeNameContext::identifier() {
  return getRuleContexts<SolidityParser::IdentifierContext>();
}

SolidityParser::IdentifierContext* SolidityParser::UserDefinedTypeNameContext::identifier(size_t i) {
  return getRuleContext<SolidityParser::IdentifierContext>(i);
}


size_t SolidityParser::UserDefinedTypeNameContext::getRuleIndex() const {
  return SolidityParser::RuleUserDefinedTypeName;
}

void SolidityParser::UserDefinedTypeNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserDefinedTypeName(this);
}

void SolidityParser::UserDefinedTypeNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserDefinedTypeName(this);
}

SolidityParser::UserDefinedTypeNameContext* SolidityParser::userDefinedTypeName() {
  UserDefinedTypeNameContext *_localctx = _tracker.createInstance<UserDefinedTypeNameContext>(_ctx, getState());
  enterRule(_localctx, 62, SolidityParser::RuleUserDefinedTypeName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(502);
    identifier();
    setState(507);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(503);
        match(SolidityParser::T__34);
        setState(504);
        identifier(); 
      }
      setState(509);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MappingContext ------------------------------------------------------------------

SolidityParser::MappingContext::MappingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::TypeNameContext* SolidityParser::MappingContext::typeName() {
  return getRuleContext<SolidityParser::TypeNameContext>(0);
}

SolidityParser::ElementaryTypeNameContext* SolidityParser::MappingContext::elementaryTypeName() {
  return getRuleContext<SolidityParser::ElementaryTypeNameContext>(0);
}

SolidityParser::UserDefinedTypeNameContext* SolidityParser::MappingContext::userDefinedTypeName() {
  return getRuleContext<SolidityParser::UserDefinedTypeNameContext>(0);
}


size_t SolidityParser::MappingContext::getRuleIndex() const {
  return SolidityParser::RuleMapping;
}

void SolidityParser::MappingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMapping(this);
}

void SolidityParser::MappingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMapping(this);
}

SolidityParser::MappingContext* SolidityParser::mapping() {
  MappingContext *_localctx = _tracker.createInstance<MappingContext>(_ctx, getState());
  enterRule(_localctx, 64, SolidityParser::RuleMapping);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(510);
    match(SolidityParser::T__35);
    setState(511);
    match(SolidityParser::T__21);
    setState(514);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx)) {
    case 1: {
      setState(512);
      elementaryTypeName();
      break;
    }

    case 2: {
      setState(513);
      userDefinedTypeName();
      break;
    }

    default:
      break;
    }
    setState(516);
    match(SolidityParser::T__36);
    setState(517);
    typeName(0);
    setState(518);
    match(SolidityParser::T__22);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionTypeNameContext ------------------------------------------------------------------

SolidityParser::FunctionTypeNameContext::FunctionTypeNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::ParameterListContext* SolidityParser::FunctionTypeNameContext::parameterList() {
  return getRuleContext<SolidityParser::ParameterListContext>(0);
}

SolidityParser::ModifierListContext* SolidityParser::FunctionTypeNameContext::modifierList() {
  return getRuleContext<SolidityParser::ModifierListContext>(0);
}

SolidityParser::ReturnParametersContext* SolidityParser::FunctionTypeNameContext::returnParameters() {
  return getRuleContext<SolidityParser::ReturnParametersContext>(0);
}


size_t SolidityParser::FunctionTypeNameContext::getRuleIndex() const {
  return SolidityParser::RuleFunctionTypeName;
}

void SolidityParser::FunctionTypeNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionTypeName(this);
}

void SolidityParser::FunctionTypeNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionTypeName(this);
}

SolidityParser::FunctionTypeNameContext* SolidityParser::functionTypeName() {
  FunctionTypeNameContext *_localctx = _tracker.createInstance<FunctionTypeNameContext>(_ctx, getState());
  enterRule(_localctx, 66, SolidityParser::RuleFunctionTypeName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(520);
    match(SolidityParser::T__28);
    setState(521);
    parameterList();
    setState(522);
    modifierList();
    setState(524);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, _ctx)) {
    case 1: {
      setState(523);
      returnParameters();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StorageLocationContext ------------------------------------------------------------------

SolidityParser::StorageLocationContext::StorageLocationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SolidityParser::StorageLocationContext::getRuleIndex() const {
  return SolidityParser::RuleStorageLocation;
}

void SolidityParser::StorageLocationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStorageLocation(this);
}

void SolidityParser::StorageLocationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStorageLocation(this);
}

SolidityParser::StorageLocationContext* SolidityParser::storageLocation() {
  StorageLocationContext *_localctx = _tracker.createInstance<StorageLocationContext>(_ctx, getState());
  enterRule(_localctx, 68, SolidityParser::RuleStorageLocation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(526);
    _la = _input->LA(1);
    if (!(((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1924145348608) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StateMutabilityContext ------------------------------------------------------------------

SolidityParser::StateMutabilityContext::StateMutabilityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SolidityParser::StateMutabilityContext::PureKeyword() {
  return getToken(SolidityParser::PureKeyword, 0);
}

tree::TerminalNode* SolidityParser::StateMutabilityContext::ConstantKeyword() {
  return getToken(SolidityParser::ConstantKeyword, 0);
}

tree::TerminalNode* SolidityParser::StateMutabilityContext::ViewKeyword() {
  return getToken(SolidityParser::ViewKeyword, 0);
}

tree::TerminalNode* SolidityParser::StateMutabilityContext::PayableKeyword() {
  return getToken(SolidityParser::PayableKeyword, 0);
}


size_t SolidityParser::StateMutabilityContext::getRuleIndex() const {
  return SolidityParser::RuleStateMutability;
}

void SolidityParser::StateMutabilityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStateMutability(this);
}

void SolidityParser::StateMutabilityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStateMutability(this);
}

SolidityParser::StateMutabilityContext* SolidityParser::stateMutability() {
  StateMutabilityContext *_localctx = _tracker.createInstance<StateMutabilityContext>(_ctx, getState());
  enterRule(_localctx, 70, SolidityParser::RuleStateMutability);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(528);
    _la = _input->LA(1);
    if (!((((_la - 106) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 106)) & 10369) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContext ------------------------------------------------------------------

SolidityParser::BlockContext::BlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SolidityParser::StatementContext *> SolidityParser::BlockContext::statement() {
  return getRuleContexts<SolidityParser::StatementContext>();
}

SolidityParser::StatementContext* SolidityParser::BlockContext::statement(size_t i) {
  return getRuleContext<SolidityParser::StatementContext>(i);
}


size_t SolidityParser::BlockContext::getRuleIndex() const {
  return SolidityParser::RuleBlock;
}

void SolidityParser::BlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock(this);
}

void SolidityParser::BlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock(this);
}

SolidityParser::BlockContext* SolidityParser::block() {
  BlockContext *_localctx = _tracker.createInstance<BlockContext>(_ctx, getState());
  enterRule(_localctx, 72, SolidityParser::RuleBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(530);
    match(SolidityParser::T__13);
    setState(534);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -576483764129996784) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1747979808362463233) != 0) {
      setState(531);
      statement();
      setState(536);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(537);
    match(SolidityParser::T__15);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

SolidityParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IfStatementContext* SolidityParser::StatementContext::ifStatement() {
  return getRuleContext<SolidityParser::IfStatementContext>(0);
}

SolidityParser::TryStatementContext* SolidityParser::StatementContext::tryStatement() {
  return getRuleContext<SolidityParser::TryStatementContext>(0);
}

SolidityParser::WhileStatementContext* SolidityParser::StatementContext::whileStatement() {
  return getRuleContext<SolidityParser::WhileStatementContext>(0);
}

SolidityParser::ForStatementContext* SolidityParser::StatementContext::forStatement() {
  return getRuleContext<SolidityParser::ForStatementContext>(0);
}

SolidityParser::BlockContext* SolidityParser::StatementContext::block() {
  return getRuleContext<SolidityParser::BlockContext>(0);
}

SolidityParser::InlineAssemblyStatementContext* SolidityParser::StatementContext::inlineAssemblyStatement() {
  return getRuleContext<SolidityParser::InlineAssemblyStatementContext>(0);
}

SolidityParser::DoWhileStatementContext* SolidityParser::StatementContext::doWhileStatement() {
  return getRuleContext<SolidityParser::DoWhileStatementContext>(0);
}

SolidityParser::ContinueStatementContext* SolidityParser::StatementContext::continueStatement() {
  return getRuleContext<SolidityParser::ContinueStatementContext>(0);
}

SolidityParser::BreakStatementContext* SolidityParser::StatementContext::breakStatement() {
  return getRuleContext<SolidityParser::BreakStatementContext>(0);
}

SolidityParser::ReturnStatementContext* SolidityParser::StatementContext::returnStatement() {
  return getRuleContext<SolidityParser::ReturnStatementContext>(0);
}

SolidityParser::ThrowStatementContext* SolidityParser::StatementContext::throwStatement() {
  return getRuleContext<SolidityParser::ThrowStatementContext>(0);
}

SolidityParser::EmitStatementContext* SolidityParser::StatementContext::emitStatement() {
  return getRuleContext<SolidityParser::EmitStatementContext>(0);
}

SolidityParser::SimpleStatementContext* SolidityParser::StatementContext::simpleStatement() {
  return getRuleContext<SolidityParser::SimpleStatementContext>(0);
}


size_t SolidityParser::StatementContext::getRuleIndex() const {
  return SolidityParser::RuleStatement;
}

void SolidityParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void SolidityParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}

SolidityParser::StatementContext* SolidityParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 74, SolidityParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(552);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SolidityParser::T__40: {
        enterOuterAlt(_localctx, 1);
        setState(539);
        ifStatement();
        break;
      }

      case SolidityParser::T__42: {
        enterOuterAlt(_localctx, 2);
        setState(540);
        tryStatement();
        break;
      }

      case SolidityParser::T__44: {
        enterOuterAlt(_localctx, 3);
        setState(541);
        whileStatement();
        break;
      }

      case SolidityParser::T__25: {
        enterOuterAlt(_localctx, 4);
        setState(542);
        forStatement();
        break;
      }

      case SolidityParser::T__13: {
        enterOuterAlt(_localctx, 5);
        setState(543);
        block();
        break;
      }

      case SolidityParser::T__45: {
        enterOuterAlt(_localctx, 6);
        setState(544);
        inlineAssemblyStatement();
        break;
      }

      case SolidityParser::T__46: {
        enterOuterAlt(_localctx, 7);
        setState(545);
        doWhileStatement();
        break;
      }

      case SolidityParser::ContinueKeyword: {
        enterOuterAlt(_localctx, 8);
        setState(546);
        continueStatement();
        break;
      }

      case SolidityParser::BreakKeyword: {
        enterOuterAlt(_localctx, 9);
        setState(547);
        breakStatement();
        break;
      }

      case SolidityParser::T__47: {
        enterOuterAlt(_localctx, 10);
        setState(548);
        returnStatement();
        break;
      }

      case SolidityParser::T__48: {
        enterOuterAlt(_localctx, 11);
        setState(549);
        throwStatement();
        break;
      }

      case SolidityParser::T__49: {
        enterOuterAlt(_localctx, 12);
        setState(550);
        emitStatement();
        break;
      }

      case SolidityParser::T__3:
      case SolidityParser::T__12:
      case SolidityParser::T__21:
      case SolidityParser::T__28:
      case SolidityParser::T__32:
      case SolidityParser::T__35:
      case SolidityParser::T__39:
      case SolidityParser::T__50:
      case SolidityParser::T__51:
      case SolidityParser::T__52:
      case SolidityParser::T__53:
      case SolidityParser::T__54:
      case SolidityParser::T__55:
      case SolidityParser::T__56:
      case SolidityParser::T__57:
      case SolidityParser::T__59:
      case SolidityParser::T__60:
      case SolidityParser::T__61:
      case SolidityParser::T__62:
      case SolidityParser::T__63:
      case SolidityParser::Int:
      case SolidityParser::Uint:
      case SolidityParser::Byte:
      case SolidityParser::Fixed:
      case SolidityParser::Ufixed:
      case SolidityParser::BooleanLiteral:
      case SolidityParser::DecimalNumber:
      case SolidityParser::HexNumber:
      case SolidityParser::HexLiteralFragment:
      case SolidityParser::PayableKeyword:
      case SolidityParser::TypeKeyword:
      case SolidityParser::Identifier:
      case SolidityParser::StringLiteralFragment: {
        enterOuterAlt(_localctx, 13);
        setState(551);
        simpleStatement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionStatementContext ------------------------------------------------------------------

SolidityParser::ExpressionStatementContext::ExpressionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::ExpressionContext* SolidityParser::ExpressionStatementContext::expression() {
  return getRuleContext<SolidityParser::ExpressionContext>(0);
}


size_t SolidityParser::ExpressionStatementContext::getRuleIndex() const {
  return SolidityParser::RuleExpressionStatement;
}

void SolidityParser::ExpressionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionStatement(this);
}

void SolidityParser::ExpressionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionStatement(this);
}

SolidityParser::ExpressionStatementContext* SolidityParser::expressionStatement() {
  ExpressionStatementContext *_localctx = _tracker.createInstance<ExpressionStatementContext>(_ctx, getState());
  enterRule(_localctx, 76, SolidityParser::RuleExpressionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(554);
    expression(0);
    setState(555);
    match(SolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStatementContext ------------------------------------------------------------------

SolidityParser::IfStatementContext::IfStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::ExpressionContext* SolidityParser::IfStatementContext::expression() {
  return getRuleContext<SolidityParser::ExpressionContext>(0);
}

std::vector<SolidityParser::StatementContext *> SolidityParser::IfStatementContext::statement() {
  return getRuleContexts<SolidityParser::StatementContext>();
}

SolidityParser::StatementContext* SolidityParser::IfStatementContext::statement(size_t i) {
  return getRuleContext<SolidityParser::StatementContext>(i);
}


size_t SolidityParser::IfStatementContext::getRuleIndex() const {
  return SolidityParser::RuleIfStatement;
}

void SolidityParser::IfStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfStatement(this);
}

void SolidityParser::IfStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfStatement(this);
}

SolidityParser::IfStatementContext* SolidityParser::ifStatement() {
  IfStatementContext *_localctx = _tracker.createInstance<IfStatementContext>(_ctx, getState());
  enterRule(_localctx, 78, SolidityParser::RuleIfStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(557);
    match(SolidityParser::T__40);
    setState(558);
    match(SolidityParser::T__21);
    setState(559);
    expression(0);
    setState(560);
    match(SolidityParser::T__22);
    setState(561);
    statement();
    setState(564);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
    case 1: {
      setState(562);
      match(SolidityParser::T__41);
      setState(563);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TryStatementContext ------------------------------------------------------------------

SolidityParser::TryStatementContext::TryStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::ExpressionContext* SolidityParser::TryStatementContext::expression() {
  return getRuleContext<SolidityParser::ExpressionContext>(0);
}

SolidityParser::BlockContext* SolidityParser::TryStatementContext::block() {
  return getRuleContext<SolidityParser::BlockContext>(0);
}

SolidityParser::ReturnParametersContext* SolidityParser::TryStatementContext::returnParameters() {
  return getRuleContext<SolidityParser::ReturnParametersContext>(0);
}

std::vector<SolidityParser::CatchClauseContext *> SolidityParser::TryStatementContext::catchClause() {
  return getRuleContexts<SolidityParser::CatchClauseContext>();
}

SolidityParser::CatchClauseContext* SolidityParser::TryStatementContext::catchClause(size_t i) {
  return getRuleContext<SolidityParser::CatchClauseContext>(i);
}


size_t SolidityParser::TryStatementContext::getRuleIndex() const {
  return SolidityParser::RuleTryStatement;
}

void SolidityParser::TryStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTryStatement(this);
}

void SolidityParser::TryStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTryStatement(this);
}

SolidityParser::TryStatementContext* SolidityParser::tryStatement() {
  TryStatementContext *_localctx = _tracker.createInstance<TryStatementContext>(_ctx, getState());
  enterRule(_localctx, 80, SolidityParser::RuleTryStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(566);
    match(SolidityParser::T__42);
    setState(567);
    expression(0);
    setState(569);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SolidityParser::T__29) {
      setState(568);
      returnParameters();
    }
    setState(571);
    block();
    setState(573); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(572);
      catchClause();
      setState(575); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == SolidityParser::T__43);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CatchClauseContext ------------------------------------------------------------------

SolidityParser::CatchClauseContext::CatchClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::BlockContext* SolidityParser::CatchClauseContext::block() {
  return getRuleContext<SolidityParser::BlockContext>(0);
}

SolidityParser::ParameterListContext* SolidityParser::CatchClauseContext::parameterList() {
  return getRuleContext<SolidityParser::ParameterListContext>(0);
}

SolidityParser::IdentifierContext* SolidityParser::CatchClauseContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}


size_t SolidityParser::CatchClauseContext::getRuleIndex() const {
  return SolidityParser::RuleCatchClause;
}

void SolidityParser::CatchClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCatchClause(this);
}

void SolidityParser::CatchClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCatchClause(this);
}

SolidityParser::CatchClauseContext* SolidityParser::catchClause() {
  CatchClauseContext *_localctx = _tracker.createInstance<CatchClauseContext>(_ctx, getState());
  enterRule(_localctx, 82, SolidityParser::RuleCatchClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(577);
    match(SolidityParser::T__43);
    setState(582);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4504699143200768) != 0 || _la == SolidityParser::Identifier) {
      setState(579);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 4504699139006464) != 0 || _la == SolidityParser::Identifier) {
        setState(578);
        identifier();
      }
      setState(581);
      parameterList();
    }
    setState(584);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhileStatementContext ------------------------------------------------------------------

SolidityParser::WhileStatementContext::WhileStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::ExpressionContext* SolidityParser::WhileStatementContext::expression() {
  return getRuleContext<SolidityParser::ExpressionContext>(0);
}

SolidityParser::StatementContext* SolidityParser::WhileStatementContext::statement() {
  return getRuleContext<SolidityParser::StatementContext>(0);
}


size_t SolidityParser::WhileStatementContext::getRuleIndex() const {
  return SolidityParser::RuleWhileStatement;
}

void SolidityParser::WhileStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhileStatement(this);
}

void SolidityParser::WhileStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhileStatement(this);
}

SolidityParser::WhileStatementContext* SolidityParser::whileStatement() {
  WhileStatementContext *_localctx = _tracker.createInstance<WhileStatementContext>(_ctx, getState());
  enterRule(_localctx, 84, SolidityParser::RuleWhileStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(586);
    match(SolidityParser::T__44);
    setState(587);
    match(SolidityParser::T__21);
    setState(588);
    expression(0);
    setState(589);
    match(SolidityParser::T__22);
    setState(590);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForStatementContext ------------------------------------------------------------------

SolidityParser::ForStatementContext::ForStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::StatementContext* SolidityParser::ForStatementContext::statement() {
  return getRuleContext<SolidityParser::StatementContext>(0);
}

SolidityParser::SimpleStatementContext* SolidityParser::ForStatementContext::simpleStatement() {
  return getRuleContext<SolidityParser::SimpleStatementContext>(0);
}

SolidityParser::ExpressionStatementContext* SolidityParser::ForStatementContext::expressionStatement() {
  return getRuleContext<SolidityParser::ExpressionStatementContext>(0);
}

SolidityParser::ExpressionContext* SolidityParser::ForStatementContext::expression() {
  return getRuleContext<SolidityParser::ExpressionContext>(0);
}


size_t SolidityParser::ForStatementContext::getRuleIndex() const {
  return SolidityParser::RuleForStatement;
}

void SolidityParser::ForStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForStatement(this);
}

void SolidityParser::ForStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForStatement(this);
}

SolidityParser::ForStatementContext* SolidityParser::forStatement() {
  ForStatementContext *_localctx = _tracker.createInstance<ForStatementContext>(_ctx, getState());
  enterRule(_localctx, 86, SolidityParser::RuleForStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(592);
    match(SolidityParser::T__25);
    setState(593);
    match(SolidityParser::T__21);
    setState(596);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SolidityParser::T__3:
      case SolidityParser::T__12:
      case SolidityParser::T__21:
      case SolidityParser::T__28:
      case SolidityParser::T__32:
      case SolidityParser::T__35:
      case SolidityParser::T__39:
      case SolidityParser::T__50:
      case SolidityParser::T__51:
      case SolidityParser::T__52:
      case SolidityParser::T__53:
      case SolidityParser::T__54:
      case SolidityParser::T__55:
      case SolidityParser::T__56:
      case SolidityParser::T__57:
      case SolidityParser::T__59:
      case SolidityParser::T__60:
      case SolidityParser::T__61:
      case SolidityParser::T__62:
      case SolidityParser::T__63:
      case SolidityParser::Int:
      case SolidityParser::Uint:
      case SolidityParser::Byte:
      case SolidityParser::Fixed:
      case SolidityParser::Ufixed:
      case SolidityParser::BooleanLiteral:
      case SolidityParser::DecimalNumber:
      case SolidityParser::HexNumber:
      case SolidityParser::HexLiteralFragment:
      case SolidityParser::PayableKeyword:
      case SolidityParser::TypeKeyword:
      case SolidityParser::Identifier:
      case SolidityParser::StringLiteralFragment: {
        setState(594);
        simpleStatement();
        break;
      }

      case SolidityParser::T__1: {
        setState(595);
        match(SolidityParser::T__1);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(600);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SolidityParser::T__3:
      case SolidityParser::T__12:
      case SolidityParser::T__21:
      case SolidityParser::T__32:
      case SolidityParser::T__39:
      case SolidityParser::T__50:
      case SolidityParser::T__51:
      case SolidityParser::T__52:
      case SolidityParser::T__53:
      case SolidityParser::T__54:
      case SolidityParser::T__55:
      case SolidityParser::T__56:
      case SolidityParser::T__57:
      case SolidityParser::T__59:
      case SolidityParser::T__60:
      case SolidityParser::T__61:
      case SolidityParser::T__62:
      case SolidityParser::T__63:
      case SolidityParser::Int:
      case SolidityParser::Uint:
      case SolidityParser::Byte:
      case SolidityParser::Fixed:
      case SolidityParser::Ufixed:
      case SolidityParser::BooleanLiteral:
      case SolidityParser::DecimalNumber:
      case SolidityParser::HexNumber:
      case SolidityParser::HexLiteralFragment:
      case SolidityParser::PayableKeyword:
      case SolidityParser::TypeKeyword:
      case SolidityParser::Identifier:
      case SolidityParser::StringLiteralFragment: {
        setState(598);
        expressionStatement();
        break;
      }

      case SolidityParser::T__1: {
        setState(599);
        match(SolidityParser::T__1);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(603);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -578711444011343856) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1747960017153163265) != 0) {
      setState(602);
      expression(0);
    }
    setState(605);
    match(SolidityParser::T__22);
    setState(606);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleStatementContext ------------------------------------------------------------------

SolidityParser::SimpleStatementContext::SimpleStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::VariableDeclarationStatementContext* SolidityParser::SimpleStatementContext::variableDeclarationStatement() {
  return getRuleContext<SolidityParser::VariableDeclarationStatementContext>(0);
}

SolidityParser::ExpressionStatementContext* SolidityParser::SimpleStatementContext::expressionStatement() {
  return getRuleContext<SolidityParser::ExpressionStatementContext>(0);
}


size_t SolidityParser::SimpleStatementContext::getRuleIndex() const {
  return SolidityParser::RuleSimpleStatement;
}

void SolidityParser::SimpleStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleStatement(this);
}

void SolidityParser::SimpleStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleStatement(this);
}

SolidityParser::SimpleStatementContext* SolidityParser::simpleStatement() {
  SimpleStatementContext *_localctx = _tracker.createInstance<SimpleStatementContext>(_ctx, getState());
  enterRule(_localctx, 88, SolidityParser::RuleSimpleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(610);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx)) {
    case 1: {
      setState(608);
      variableDeclarationStatement();
      break;
    }

    case 2: {
      setState(609);
      expressionStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InlineAssemblyStatementContext ------------------------------------------------------------------

SolidityParser::InlineAssemblyStatementContext::InlineAssemblyStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::AssemblyBlockContext* SolidityParser::InlineAssemblyStatementContext::assemblyBlock() {
  return getRuleContext<SolidityParser::AssemblyBlockContext>(0);
}

tree::TerminalNode* SolidityParser::InlineAssemblyStatementContext::StringLiteralFragment() {
  return getToken(SolidityParser::StringLiteralFragment, 0);
}


size_t SolidityParser::InlineAssemblyStatementContext::getRuleIndex() const {
  return SolidityParser::RuleInlineAssemblyStatement;
}

void SolidityParser::InlineAssemblyStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInlineAssemblyStatement(this);
}

void SolidityParser::InlineAssemblyStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInlineAssemblyStatement(this);
}

SolidityParser::InlineAssemblyStatementContext* SolidityParser::inlineAssemblyStatement() {
  InlineAssemblyStatementContext *_localctx = _tracker.createInstance<InlineAssemblyStatementContext>(_ctx, getState());
  enterRule(_localctx, 90, SolidityParser::RuleInlineAssemblyStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(612);
    match(SolidityParser::T__45);
    setState(614);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SolidityParser::StringLiteralFragment) {
      setState(613);
      match(SolidityParser::StringLiteralFragment);
    }
    setState(616);
    assemblyBlock();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DoWhileStatementContext ------------------------------------------------------------------

SolidityParser::DoWhileStatementContext::DoWhileStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::StatementContext* SolidityParser::DoWhileStatementContext::statement() {
  return getRuleContext<SolidityParser::StatementContext>(0);
}

SolidityParser::ExpressionContext* SolidityParser::DoWhileStatementContext::expression() {
  return getRuleContext<SolidityParser::ExpressionContext>(0);
}


size_t SolidityParser::DoWhileStatementContext::getRuleIndex() const {
  return SolidityParser::RuleDoWhileStatement;
}

void SolidityParser::DoWhileStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoWhileStatement(this);
}

void SolidityParser::DoWhileStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoWhileStatement(this);
}

SolidityParser::DoWhileStatementContext* SolidityParser::doWhileStatement() {
  DoWhileStatementContext *_localctx = _tracker.createInstance<DoWhileStatementContext>(_ctx, getState());
  enterRule(_localctx, 92, SolidityParser::RuleDoWhileStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(618);
    match(SolidityParser::T__46);
    setState(619);
    statement();
    setState(620);
    match(SolidityParser::T__44);
    setState(621);
    match(SolidityParser::T__21);
    setState(622);
    expression(0);
    setState(623);
    match(SolidityParser::T__22);
    setState(624);
    match(SolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ContinueStatementContext ------------------------------------------------------------------

SolidityParser::ContinueStatementContext::ContinueStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SolidityParser::ContinueStatementContext::ContinueKeyword() {
  return getToken(SolidityParser::ContinueKeyword, 0);
}


size_t SolidityParser::ContinueStatementContext::getRuleIndex() const {
  return SolidityParser::RuleContinueStatement;
}

void SolidityParser::ContinueStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContinueStatement(this);
}

void SolidityParser::ContinueStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContinueStatement(this);
}

SolidityParser::ContinueStatementContext* SolidityParser::continueStatement() {
  ContinueStatementContext *_localctx = _tracker.createInstance<ContinueStatementContext>(_ctx, getState());
  enterRule(_localctx, 94, SolidityParser::RuleContinueStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(626);
    match(SolidityParser::ContinueKeyword);
    setState(627);
    match(SolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BreakStatementContext ------------------------------------------------------------------

SolidityParser::BreakStatementContext::BreakStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SolidityParser::BreakStatementContext::BreakKeyword() {
  return getToken(SolidityParser::BreakKeyword, 0);
}


size_t SolidityParser::BreakStatementContext::getRuleIndex() const {
  return SolidityParser::RuleBreakStatement;
}

void SolidityParser::BreakStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBreakStatement(this);
}

void SolidityParser::BreakStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBreakStatement(this);
}

SolidityParser::BreakStatementContext* SolidityParser::breakStatement() {
  BreakStatementContext *_localctx = _tracker.createInstance<BreakStatementContext>(_ctx, getState());
  enterRule(_localctx, 96, SolidityParser::RuleBreakStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(629);
    match(SolidityParser::BreakKeyword);
    setState(630);
    match(SolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnStatementContext ------------------------------------------------------------------

SolidityParser::ReturnStatementContext::ReturnStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::ExpressionContext* SolidityParser::ReturnStatementContext::expression() {
  return getRuleContext<SolidityParser::ExpressionContext>(0);
}


size_t SolidityParser::ReturnStatementContext::getRuleIndex() const {
  return SolidityParser::RuleReturnStatement;
}

void SolidityParser::ReturnStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnStatement(this);
}

void SolidityParser::ReturnStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnStatement(this);
}

SolidityParser::ReturnStatementContext* SolidityParser::returnStatement() {
  ReturnStatementContext *_localctx = _tracker.createInstance<ReturnStatementContext>(_ctx, getState());
  enterRule(_localctx, 98, SolidityParser::RuleReturnStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(632);
    match(SolidityParser::T__47);
    setState(634);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -578711444011343856) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1747960017153163265) != 0) {
      setState(633);
      expression(0);
    }
    setState(636);
    match(SolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThrowStatementContext ------------------------------------------------------------------

SolidityParser::ThrowStatementContext::ThrowStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SolidityParser::ThrowStatementContext::getRuleIndex() const {
  return SolidityParser::RuleThrowStatement;
}

void SolidityParser::ThrowStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrowStatement(this);
}

void SolidityParser::ThrowStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrowStatement(this);
}

SolidityParser::ThrowStatementContext* SolidityParser::throwStatement() {
  ThrowStatementContext *_localctx = _tracker.createInstance<ThrowStatementContext>(_ctx, getState());
  enterRule(_localctx, 100, SolidityParser::RuleThrowStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(638);
    match(SolidityParser::T__48);
    setState(639);
    match(SolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmitStatementContext ------------------------------------------------------------------

SolidityParser::EmitStatementContext::EmitStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::FunctionCallContext* SolidityParser::EmitStatementContext::functionCall() {
  return getRuleContext<SolidityParser::FunctionCallContext>(0);
}


size_t SolidityParser::EmitStatementContext::getRuleIndex() const {
  return SolidityParser::RuleEmitStatement;
}

void SolidityParser::EmitStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmitStatement(this);
}

void SolidityParser::EmitStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmitStatement(this);
}

SolidityParser::EmitStatementContext* SolidityParser::emitStatement() {
  EmitStatementContext *_localctx = _tracker.createInstance<EmitStatementContext>(_ctx, getState());
  enterRule(_localctx, 102, SolidityParser::RuleEmitStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(641);
    match(SolidityParser::T__49);
    setState(642);
    functionCall();
    setState(643);
    match(SolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationStatementContext ------------------------------------------------------------------

SolidityParser::VariableDeclarationStatementContext::VariableDeclarationStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IdentifierListContext* SolidityParser::VariableDeclarationStatementContext::identifierList() {
  return getRuleContext<SolidityParser::IdentifierListContext>(0);
}

SolidityParser::VariableDeclarationContext* SolidityParser::VariableDeclarationStatementContext::variableDeclaration() {
  return getRuleContext<SolidityParser::VariableDeclarationContext>(0);
}

SolidityParser::VariableDeclarationListContext* SolidityParser::VariableDeclarationStatementContext::variableDeclarationList() {
  return getRuleContext<SolidityParser::VariableDeclarationListContext>(0);
}

SolidityParser::ExpressionContext* SolidityParser::VariableDeclarationStatementContext::expression() {
  return getRuleContext<SolidityParser::ExpressionContext>(0);
}


size_t SolidityParser::VariableDeclarationStatementContext::getRuleIndex() const {
  return SolidityParser::RuleVariableDeclarationStatement;
}

void SolidityParser::VariableDeclarationStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclarationStatement(this);
}

void SolidityParser::VariableDeclarationStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclarationStatement(this);
}

SolidityParser::VariableDeclarationStatementContext* SolidityParser::variableDeclarationStatement() {
  VariableDeclarationStatementContext *_localctx = _tracker.createInstance<VariableDeclarationStatementContext>(_ctx, getState());
  enterRule(_localctx, 104, SolidityParser::RuleVariableDeclarationStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(652);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
    case 1: {
      setState(645);
      match(SolidityParser::T__50);
      setState(646);
      identifierList();
      break;
    }

    case 2: {
      setState(647);
      variableDeclaration();
      break;
    }

    case 3: {
      setState(648);
      match(SolidityParser::T__21);
      setState(649);
      variableDeclarationList();
      setState(650);
      match(SolidityParser::T__22);
      break;
    }

    default:
      break;
    }
    setState(656);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SolidityParser::T__8) {
      setState(654);
      match(SolidityParser::T__8);
      setState(655);
      expression(0);
    }
    setState(658);
    match(SolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationListContext ------------------------------------------------------------------

SolidityParser::VariableDeclarationListContext::VariableDeclarationListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SolidityParser::VariableDeclarationContext *> SolidityParser::VariableDeclarationListContext::variableDeclaration() {
  return getRuleContexts<SolidityParser::VariableDeclarationContext>();
}

SolidityParser::VariableDeclarationContext* SolidityParser::VariableDeclarationListContext::variableDeclaration(size_t i) {
  return getRuleContext<SolidityParser::VariableDeclarationContext>(i);
}


size_t SolidityParser::VariableDeclarationListContext::getRuleIndex() const {
  return SolidityParser::RuleVariableDeclarationList;
}

void SolidityParser::VariableDeclarationListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclarationList(this);
}

void SolidityParser::VariableDeclarationListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclarationList(this);
}

SolidityParser::VariableDeclarationListContext* SolidityParser::variableDeclarationList() {
  VariableDeclarationListContext *_localctx = _tracker.createInstance<VariableDeclarationListContext>(_ctx, getState());
  enterRule(_localctx, 106, SolidityParser::RuleVariableDeclarationList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(661);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 69806962992226304) != 0 || (((_la - 93) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 93)) & 1073741855) != 0) {
      setState(660);
      variableDeclaration();
    }
    setState(669);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SolidityParser::T__14) {
      setState(663);
      match(SolidityParser::T__14);
      setState(665);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 69806962992226304) != 0 || (((_la - 93) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 93)) & 1073741855) != 0) {
        setState(664);
        variableDeclaration();
      }
      setState(671);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierListContext ------------------------------------------------------------------

SolidityParser::IdentifierListContext::IdentifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SolidityParser::IdentifierContext *> SolidityParser::IdentifierListContext::identifier() {
  return getRuleContexts<SolidityParser::IdentifierContext>();
}

SolidityParser::IdentifierContext* SolidityParser::IdentifierListContext::identifier(size_t i) {
  return getRuleContext<SolidityParser::IdentifierContext>(i);
}


size_t SolidityParser::IdentifierListContext::getRuleIndex() const {
  return SolidityParser::RuleIdentifierList;
}

void SolidityParser::IdentifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierList(this);
}

void SolidityParser::IdentifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierList(this);
}

SolidityParser::IdentifierListContext* SolidityParser::identifierList() {
  IdentifierListContext *_localctx = _tracker.createInstance<IdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 108, SolidityParser::RuleIdentifierList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(672);
    match(SolidityParser::T__21);
    setState(679);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(674);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 4504699139006464) != 0 || _la == SolidityParser::Identifier) {
          setState(673);
          identifier();
        }
        setState(676);
        match(SolidityParser::T__14); 
      }
      setState(681);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx);
    }
    setState(683);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4504699139006464) != 0 || _la == SolidityParser::Identifier) {
      setState(682);
      identifier();
    }
    setState(685);
    match(SolidityParser::T__22);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementaryTypeNameContext ------------------------------------------------------------------

SolidityParser::ElementaryTypeNameContext::ElementaryTypeNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SolidityParser::ElementaryTypeNameContext::PayableKeyword() {
  return getToken(SolidityParser::PayableKeyword, 0);
}

tree::TerminalNode* SolidityParser::ElementaryTypeNameContext::Int() {
  return getToken(SolidityParser::Int, 0);
}

tree::TerminalNode* SolidityParser::ElementaryTypeNameContext::Uint() {
  return getToken(SolidityParser::Uint, 0);
}

tree::TerminalNode* SolidityParser::ElementaryTypeNameContext::Byte() {
  return getToken(SolidityParser::Byte, 0);
}

tree::TerminalNode* SolidityParser::ElementaryTypeNameContext::Fixed() {
  return getToken(SolidityParser::Fixed, 0);
}

tree::TerminalNode* SolidityParser::ElementaryTypeNameContext::Ufixed() {
  return getToken(SolidityParser::Ufixed, 0);
}


size_t SolidityParser::ElementaryTypeNameContext::getRuleIndex() const {
  return SolidityParser::RuleElementaryTypeName;
}

void SolidityParser::ElementaryTypeNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElementaryTypeName(this);
}

void SolidityParser::ElementaryTypeNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElementaryTypeName(this);
}

SolidityParser::ElementaryTypeNameContext* SolidityParser::elementaryTypeName() {
  ElementaryTypeNameContext *_localctx = _tracker.createInstance<ElementaryTypeNameContext>(_ctx, getState());
  enterRule(_localctx, 110, SolidityParser::RuleElementaryTypeName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(700);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SolidityParser::T__51: {
        enterOuterAlt(_localctx, 1);
        setState(687);
        match(SolidityParser::T__51);
        setState(689);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx)) {
        case 1: {
          setState(688);
          match(SolidityParser::PayableKeyword);
          break;
        }

        default:
          break;
        }
        break;
      }

      case SolidityParser::T__52: {
        enterOuterAlt(_localctx, 2);
        setState(691);
        match(SolidityParser::T__52);
        break;
      }

      case SolidityParser::T__53: {
        enterOuterAlt(_localctx, 3);
        setState(692);
        match(SolidityParser::T__53);
        break;
      }

      case SolidityParser::T__50: {
        enterOuterAlt(_localctx, 4);
        setState(693);
        match(SolidityParser::T__50);
        break;
      }

      case SolidityParser::Int: {
        enterOuterAlt(_localctx, 5);
        setState(694);
        match(SolidityParser::Int);
        break;
      }

      case SolidityParser::Uint: {
        enterOuterAlt(_localctx, 6);
        setState(695);
        match(SolidityParser::Uint);
        break;
      }

      case SolidityParser::T__54: {
        enterOuterAlt(_localctx, 7);
        setState(696);
        match(SolidityParser::T__54);
        break;
      }

      case SolidityParser::Byte: {
        enterOuterAlt(_localctx, 8);
        setState(697);
        match(SolidityParser::Byte);
        break;
      }

      case SolidityParser::Fixed: {
        enterOuterAlt(_localctx, 9);
        setState(698);
        match(SolidityParser::Fixed);
        break;
      }

      case SolidityParser::Ufixed: {
        enterOuterAlt(_localctx, 10);
        setState(699);
        match(SolidityParser::Ufixed);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

SolidityParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::TypeNameContext* SolidityParser::ExpressionContext::typeName() {
  return getRuleContext<SolidityParser::TypeNameContext>(0);
}

tree::TerminalNode* SolidityParser::ExpressionContext::PayableKeyword() {
  return getToken(SolidityParser::PayableKeyword, 0);
}

std::vector<SolidityParser::ExpressionContext *> SolidityParser::ExpressionContext::expression() {
  return getRuleContexts<SolidityParser::ExpressionContext>();
}

SolidityParser::ExpressionContext* SolidityParser::ExpressionContext::expression(size_t i) {
  return getRuleContext<SolidityParser::ExpressionContext>(i);
}

SolidityParser::PrimaryExpressionContext* SolidityParser::ExpressionContext::primaryExpression() {
  return getRuleContext<SolidityParser::PrimaryExpressionContext>(0);
}

SolidityParser::IdentifierContext* SolidityParser::ExpressionContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}

SolidityParser::NameValueListContext* SolidityParser::ExpressionContext::nameValueList() {
  return getRuleContext<SolidityParser::NameValueListContext>(0);
}

SolidityParser::FunctionCallArgumentsContext* SolidityParser::ExpressionContext::functionCallArguments() {
  return getRuleContext<SolidityParser::FunctionCallArgumentsContext>(0);
}


size_t SolidityParser::ExpressionContext::getRuleIndex() const {
  return SolidityParser::RuleExpression;
}

void SolidityParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void SolidityParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}


SolidityParser::ExpressionContext* SolidityParser::expression() {
   return expression(0);
}

SolidityParser::ExpressionContext* SolidityParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  SolidityParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  SolidityParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 112;
  enterRecursionRule(_localctx, 112, SolidityParser::RuleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(725);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx)) {
    case 1: {
      setState(703);
      match(SolidityParser::T__57);
      setState(704);
      typeName(0);
      break;
    }

    case 2: {
      setState(705);
      match(SolidityParser::PayableKeyword);
      setState(706);
      match(SolidityParser::T__21);
      setState(707);
      expression(0);
      setState(708);
      match(SolidityParser::T__22);
      break;
    }

    case 3: {
      setState(710);
      match(SolidityParser::T__21);
      setState(711);
      expression(0);
      setState(712);
      match(SolidityParser::T__22);
      break;
    }

    case 4: {
      setState(714);
      _la = _input->LA(1);
      if (!(_la == SolidityParser::T__55

      || _la == SolidityParser::T__56)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(715);
      expression(19);
      break;
    }

    case 5: {
      setState(716);
      _la = _input->LA(1);
      if (!(_la == SolidityParser::T__59

      || _la == SolidityParser::T__60)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(717);
      expression(18);
      break;
    }

    case 6: {
      setState(718);
      _la = _input->LA(1);
      if (!(_la == SolidityParser::T__61

      || _la == SolidityParser::T__62)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(719);
      expression(17);
      break;
    }

    case 7: {
      setState(720);
      match(SolidityParser::T__63);
      setState(721);
      expression(16);
      break;
    }

    case 8: {
      setState(722);
      match(SolidityParser::T__3);
      setState(723);
      expression(15);
      break;
    }

    case 9: {
      setState(724);
      primaryExpression();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(802);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(800);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(727);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(728);
          match(SolidityParser::T__64);
          setState(729);
          expression(15);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(730);

          if (!(precpred(_ctx, 13))) throw FailedPredicateException(this, "precpred(_ctx, 13)");
          setState(731);
          _la = _input->LA(1);
          if (!((((_la - 12) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 12)) & 54043195528445953) != 0)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(732);
          expression(14);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(733);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(734);
          _la = _input->LA(1);
          if (!(_la == SolidityParser::T__59

          || _la == SolidityParser::T__60)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(735);
          expression(13);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(736);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(737);
          _la = _input->LA(1);
          if (!(_la == SolidityParser::T__67

          || _la == SolidityParser::T__68)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(738);
          expression(12);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(739);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(740);
          match(SolidityParser::T__69);
          setState(741);
          expression(11);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(742);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(743);
          match(SolidityParser::T__2);
          setState(744);
          expression(10);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(745);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(746);
          match(SolidityParser::T__70);
          setState(747);
          expression(9);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(748);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(749);
          _la = _input->LA(1);
          if (!(((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 480) != 0)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(750);
          expression(8);
          break;
        }

        case 9: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(751);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(752);
          _la = _input->LA(1);
          if (!(_la == SolidityParser::T__71

          || _la == SolidityParser::T__72)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(753);
          expression(7);
          break;
        }

        case 10: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(754);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(755);
          match(SolidityParser::T__73);
          setState(756);
          expression(6);
          break;
        }

        case 11: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(757);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(758);
          match(SolidityParser::T__74);
          setState(759);
          expression(5);
          break;
        }

        case 12: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(760);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(761);
          match(SolidityParser::T__75);
          setState(762);
          expression(0);
          setState(763);
          match(SolidityParser::T__58);
          setState(764);
          expression(4);
          break;
        }

        case 13: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(766);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(767);
          _la = _input->LA(1);
          if (!(_la == SolidityParser::T__8 || (((_la - 77) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 77)) & 1023) != 0)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(768);
          expression(3);
          break;
        }

        case 14: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(769);

          if (!(precpred(_ctx, 28))) throw FailedPredicateException(this, "precpred(_ctx, 28)");
          setState(770);
          _la = _input->LA(1);
          if (!(_la == SolidityParser::T__55

          || _la == SolidityParser::T__56)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        case 15: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(771);

          if (!(precpred(_ctx, 26))) throw FailedPredicateException(this, "precpred(_ctx, 26)");
          setState(772);
          match(SolidityParser::T__32);
          setState(774);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & -578711444011343856) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & 1747960017153163265) != 0) {
            setState(773);
            expression(0);
          }
          setState(776);
          match(SolidityParser::T__33);
          break;
        }

        case 16: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(777);

          if (!(precpred(_ctx, 25))) throw FailedPredicateException(this, "precpred(_ctx, 25)");
          setState(778);
          match(SolidityParser::T__32);
          setState(780);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & -578711444011343856) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & 1747960017153163265) != 0) {
            setState(779);
            expression(0);
          }
          setState(782);
          match(SolidityParser::T__58);
          setState(784);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & -578711444011343856) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & 1747960017153163265) != 0) {
            setState(783);
            expression(0);
          }
          setState(786);
          match(SolidityParser::T__33);
          break;
        }

        case 17: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(787);

          if (!(precpred(_ctx, 24))) throw FailedPredicateException(this, "precpred(_ctx, 24)");
          setState(788);
          match(SolidityParser::T__34);
          setState(789);
          identifier();
          break;
        }

        case 18: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(790);

          if (!(precpred(_ctx, 23))) throw FailedPredicateException(this, "precpred(_ctx, 23)");
          setState(791);
          match(SolidityParser::T__13);
          setState(792);
          nameValueList();
          setState(793);
          match(SolidityParser::T__15);
          break;
        }

        case 19: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(795);

          if (!(precpred(_ctx, 22))) throw FailedPredicateException(this, "precpred(_ctx, 22)");
          setState(796);
          match(SolidityParser::T__21);
          setState(797);
          functionCallArguments();
          setState(798);
          match(SolidityParser::T__22);
          break;
        }

        default:
          break;
        } 
      }
      setState(804);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- PrimaryExpressionContext ------------------------------------------------------------------

SolidityParser::PrimaryExpressionContext::PrimaryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SolidityParser::PrimaryExpressionContext::BooleanLiteral() {
  return getToken(SolidityParser::BooleanLiteral, 0);
}

SolidityParser::NumberLiteralContext* SolidityParser::PrimaryExpressionContext::numberLiteral() {
  return getRuleContext<SolidityParser::NumberLiteralContext>(0);
}

SolidityParser::HexLiteralContext* SolidityParser::PrimaryExpressionContext::hexLiteral() {
  return getRuleContext<SolidityParser::HexLiteralContext>(0);
}

SolidityParser::StringLiteralContext* SolidityParser::PrimaryExpressionContext::stringLiteral() {
  return getRuleContext<SolidityParser::StringLiteralContext>(0);
}

SolidityParser::IdentifierContext* SolidityParser::PrimaryExpressionContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}

tree::TerminalNode* SolidityParser::PrimaryExpressionContext::TypeKeyword() {
  return getToken(SolidityParser::TypeKeyword, 0);
}

SolidityParser::TupleExpressionContext* SolidityParser::PrimaryExpressionContext::tupleExpression() {
  return getRuleContext<SolidityParser::TupleExpressionContext>(0);
}

SolidityParser::TypeNameExpressionContext* SolidityParser::PrimaryExpressionContext::typeNameExpression() {
  return getRuleContext<SolidityParser::TypeNameExpressionContext>(0);
}


size_t SolidityParser::PrimaryExpressionContext::getRuleIndex() const {
  return SolidityParser::RulePrimaryExpression;
}

void SolidityParser::PrimaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExpression(this);
}

void SolidityParser::PrimaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExpression(this);
}

SolidityParser::PrimaryExpressionContext* SolidityParser::primaryExpression() {
  PrimaryExpressionContext *_localctx = _tracker.createInstance<PrimaryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 114, SolidityParser::RulePrimaryExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(821);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(805);
      match(SolidityParser::BooleanLiteral);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(806);
      numberLiteral();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(807);
      hexLiteral();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(808);
      stringLiteral();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(809);
      identifier();
      setState(812);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx)) {
      case 1: {
        setState(810);
        match(SolidityParser::T__32);
        setState(811);
        match(SolidityParser::T__33);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(814);
      match(SolidityParser::TypeKeyword);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(815);
      tupleExpression();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(816);
      typeNameExpression();
      setState(819);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
      case 1: {
        setState(817);
        match(SolidityParser::T__32);
        setState(818);
        match(SolidityParser::T__33);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionListContext ------------------------------------------------------------------

SolidityParser::ExpressionListContext::ExpressionListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SolidityParser::ExpressionContext *> SolidityParser::ExpressionListContext::expression() {
  return getRuleContexts<SolidityParser::ExpressionContext>();
}

SolidityParser::ExpressionContext* SolidityParser::ExpressionListContext::expression(size_t i) {
  return getRuleContext<SolidityParser::ExpressionContext>(i);
}


size_t SolidityParser::ExpressionListContext::getRuleIndex() const {
  return SolidityParser::RuleExpressionList;
}

void SolidityParser::ExpressionListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionList(this);
}

void SolidityParser::ExpressionListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionList(this);
}

SolidityParser::ExpressionListContext* SolidityParser::expressionList() {
  ExpressionListContext *_localctx = _tracker.createInstance<ExpressionListContext>(_ctx, getState());
  enterRule(_localctx, 116, SolidityParser::RuleExpressionList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(823);
    expression(0);
    setState(828);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SolidityParser::T__14) {
      setState(824);
      match(SolidityParser::T__14);
      setState(825);
      expression(0);
      setState(830);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameValueListContext ------------------------------------------------------------------

SolidityParser::NameValueListContext::NameValueListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SolidityParser::NameValueContext *> SolidityParser::NameValueListContext::nameValue() {
  return getRuleContexts<SolidityParser::NameValueContext>();
}

SolidityParser::NameValueContext* SolidityParser::NameValueListContext::nameValue(size_t i) {
  return getRuleContext<SolidityParser::NameValueContext>(i);
}


size_t SolidityParser::NameValueListContext::getRuleIndex() const {
  return SolidityParser::RuleNameValueList;
}

void SolidityParser::NameValueListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNameValueList(this);
}

void SolidityParser::NameValueListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNameValueList(this);
}

SolidityParser::NameValueListContext* SolidityParser::nameValueList() {
  NameValueListContext *_localctx = _tracker.createInstance<NameValueListContext>(_ctx, getState());
  enterRule(_localctx, 118, SolidityParser::RuleNameValueList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(831);
    nameValue();
    setState(836);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(832);
        match(SolidityParser::T__14);
        setState(833);
        nameValue(); 
      }
      setState(838);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx);
    }
    setState(840);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SolidityParser::T__14) {
      setState(839);
      match(SolidityParser::T__14);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameValueContext ------------------------------------------------------------------

SolidityParser::NameValueContext::NameValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IdentifierContext* SolidityParser::NameValueContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}

SolidityParser::ExpressionContext* SolidityParser::NameValueContext::expression() {
  return getRuleContext<SolidityParser::ExpressionContext>(0);
}


size_t SolidityParser::NameValueContext::getRuleIndex() const {
  return SolidityParser::RuleNameValue;
}

void SolidityParser::NameValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNameValue(this);
}

void SolidityParser::NameValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNameValue(this);
}

SolidityParser::NameValueContext* SolidityParser::nameValue() {
  NameValueContext *_localctx = _tracker.createInstance<NameValueContext>(_ctx, getState());
  enterRule(_localctx, 120, SolidityParser::RuleNameValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(842);
    identifier();
    setState(843);
    match(SolidityParser::T__58);
    setState(844);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionCallArgumentsContext ------------------------------------------------------------------

SolidityParser::FunctionCallArgumentsContext::FunctionCallArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::NameValueListContext* SolidityParser::FunctionCallArgumentsContext::nameValueList() {
  return getRuleContext<SolidityParser::NameValueListContext>(0);
}

SolidityParser::ExpressionListContext* SolidityParser::FunctionCallArgumentsContext::expressionList() {
  return getRuleContext<SolidityParser::ExpressionListContext>(0);
}


size_t SolidityParser::FunctionCallArgumentsContext::getRuleIndex() const {
  return SolidityParser::RuleFunctionCallArguments;
}

void SolidityParser::FunctionCallArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionCallArguments(this);
}

void SolidityParser::FunctionCallArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionCallArguments(this);
}

SolidityParser::FunctionCallArgumentsContext* SolidityParser::functionCallArguments() {
  FunctionCallArgumentsContext *_localctx = _tracker.createInstance<FunctionCallArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 122, SolidityParser::RuleFunctionCallArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(854);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SolidityParser::T__13: {
        enterOuterAlt(_localctx, 1);
        setState(846);
        match(SolidityParser::T__13);
        setState(848);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 4504699139006464) != 0 || _la == SolidityParser::Identifier) {
          setState(847);
          nameValueList();
        }
        setState(850);
        match(SolidityParser::T__15);
        break;
      }

      case SolidityParser::T__3:
      case SolidityParser::T__12:
      case SolidityParser::T__21:
      case SolidityParser::T__22:
      case SolidityParser::T__32:
      case SolidityParser::T__39:
      case SolidityParser::T__50:
      case SolidityParser::T__51:
      case SolidityParser::T__52:
      case SolidityParser::T__53:
      case SolidityParser::T__54:
      case SolidityParser::T__55:
      case SolidityParser::T__56:
      case SolidityParser::T__57:
      case SolidityParser::T__59:
      case SolidityParser::T__60:
      case SolidityParser::T__61:
      case SolidityParser::T__62:
      case SolidityParser::T__63:
      case SolidityParser::Int:
      case SolidityParser::Uint:
      case SolidityParser::Byte:
      case SolidityParser::Fixed:
      case SolidityParser::Ufixed:
      case SolidityParser::BooleanLiteral:
      case SolidityParser::DecimalNumber:
      case SolidityParser::HexNumber:
      case SolidityParser::HexLiteralFragment:
      case SolidityParser::PayableKeyword:
      case SolidityParser::TypeKeyword:
      case SolidityParser::Identifier:
      case SolidityParser::StringLiteralFragment: {
        enterOuterAlt(_localctx, 2);
        setState(852);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & -578711444011343856) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1747960017153163265) != 0) {
          setState(851);
          expressionList();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionCallContext ------------------------------------------------------------------

SolidityParser::FunctionCallContext::FunctionCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::ExpressionContext* SolidityParser::FunctionCallContext::expression() {
  return getRuleContext<SolidityParser::ExpressionContext>(0);
}

SolidityParser::FunctionCallArgumentsContext* SolidityParser::FunctionCallContext::functionCallArguments() {
  return getRuleContext<SolidityParser::FunctionCallArgumentsContext>(0);
}


size_t SolidityParser::FunctionCallContext::getRuleIndex() const {
  return SolidityParser::RuleFunctionCall;
}

void SolidityParser::FunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionCall(this);
}

void SolidityParser::FunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionCall(this);
}

SolidityParser::FunctionCallContext* SolidityParser::functionCall() {
  FunctionCallContext *_localctx = _tracker.createInstance<FunctionCallContext>(_ctx, getState());
  enterRule(_localctx, 124, SolidityParser::RuleFunctionCall);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(856);
    expression(0);
    setState(857);
    match(SolidityParser::T__21);
    setState(858);
    functionCallArguments();
    setState(859);
    match(SolidityParser::T__22);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TupleExpressionContext ------------------------------------------------------------------

SolidityParser::TupleExpressionContext::TupleExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SolidityParser::ExpressionContext *> SolidityParser::TupleExpressionContext::expression() {
  return getRuleContexts<SolidityParser::ExpressionContext>();
}

SolidityParser::ExpressionContext* SolidityParser::TupleExpressionContext::expression(size_t i) {
  return getRuleContext<SolidityParser::ExpressionContext>(i);
}


size_t SolidityParser::TupleExpressionContext::getRuleIndex() const {
  return SolidityParser::RuleTupleExpression;
}

void SolidityParser::TupleExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTupleExpression(this);
}

void SolidityParser::TupleExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTupleExpression(this);
}

SolidityParser::TupleExpressionContext* SolidityParser::tupleExpression() {
  TupleExpressionContext *_localctx = _tracker.createInstance<TupleExpressionContext>(_ctx, getState());
  enterRule(_localctx, 126, SolidityParser::RuleTupleExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(887);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SolidityParser::T__21: {
        enterOuterAlt(_localctx, 1);
        setState(861);
        match(SolidityParser::T__21);

        setState(863);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & -578711444011343856) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1747960017153163265) != 0) {
          setState(862);
          expression(0);
        }
        setState(871);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SolidityParser::T__14) {
          setState(865);
          match(SolidityParser::T__14);
          setState(867);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & -578711444011343856) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & 1747960017153163265) != 0) {
            setState(866);
            expression(0);
          }
          setState(873);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(874);
        match(SolidityParser::T__22);
        break;
      }

      case SolidityParser::T__32: {
        enterOuterAlt(_localctx, 2);
        setState(875);
        match(SolidityParser::T__32);
        setState(884);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & -578711444011343856) != 0 || (((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1747960017153163265) != 0) {
          setState(876);
          expression(0);
          setState(881);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SolidityParser::T__14) {
            setState(877);
            match(SolidityParser::T__14);
            setState(878);
            expression(0);
            setState(883);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
        }
        setState(886);
        match(SolidityParser::T__33);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeNameExpressionContext ------------------------------------------------------------------

SolidityParser::TypeNameExpressionContext::TypeNameExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::ElementaryTypeNameContext* SolidityParser::TypeNameExpressionContext::elementaryTypeName() {
  return getRuleContext<SolidityParser::ElementaryTypeNameContext>(0);
}

SolidityParser::UserDefinedTypeNameContext* SolidityParser::TypeNameExpressionContext::userDefinedTypeName() {
  return getRuleContext<SolidityParser::UserDefinedTypeNameContext>(0);
}


size_t SolidityParser::TypeNameExpressionContext::getRuleIndex() const {
  return SolidityParser::RuleTypeNameExpression;
}

void SolidityParser::TypeNameExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeNameExpression(this);
}

void SolidityParser::TypeNameExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeNameExpression(this);
}

SolidityParser::TypeNameExpressionContext* SolidityParser::typeNameExpression() {
  TypeNameExpressionContext *_localctx = _tracker.createInstance<TypeNameExpressionContext>(_ctx, getState());
  enterRule(_localctx, 128, SolidityParser::RuleTypeNameExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(891);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(889);
      elementaryTypeName();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(890);
      userDefinedTypeName();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyItemContext ------------------------------------------------------------------

SolidityParser::AssemblyItemContext::AssemblyItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IdentifierContext* SolidityParser::AssemblyItemContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}

SolidityParser::AssemblyBlockContext* SolidityParser::AssemblyItemContext::assemblyBlock() {
  return getRuleContext<SolidityParser::AssemblyBlockContext>(0);
}

SolidityParser::AssemblyExpressionContext* SolidityParser::AssemblyItemContext::assemblyExpression() {
  return getRuleContext<SolidityParser::AssemblyExpressionContext>(0);
}

SolidityParser::AssemblyLocalDefinitionContext* SolidityParser::AssemblyItemContext::assemblyLocalDefinition() {
  return getRuleContext<SolidityParser::AssemblyLocalDefinitionContext>(0);
}

SolidityParser::AssemblyAssignmentContext* SolidityParser::AssemblyItemContext::assemblyAssignment() {
  return getRuleContext<SolidityParser::AssemblyAssignmentContext>(0);
}

SolidityParser::AssemblyStackAssignmentContext* SolidityParser::AssemblyItemContext::assemblyStackAssignment() {
  return getRuleContext<SolidityParser::AssemblyStackAssignmentContext>(0);
}

SolidityParser::LabelDefinitionContext* SolidityParser::AssemblyItemContext::labelDefinition() {
  return getRuleContext<SolidityParser::LabelDefinitionContext>(0);
}

SolidityParser::AssemblySwitchContext* SolidityParser::AssemblyItemContext::assemblySwitch() {
  return getRuleContext<SolidityParser::AssemblySwitchContext>(0);
}

SolidityParser::AssemblyFunctionDefinitionContext* SolidityParser::AssemblyItemContext::assemblyFunctionDefinition() {
  return getRuleContext<SolidityParser::AssemblyFunctionDefinitionContext>(0);
}

SolidityParser::AssemblyForContext* SolidityParser::AssemblyItemContext::assemblyFor() {
  return getRuleContext<SolidityParser::AssemblyForContext>(0);
}

SolidityParser::AssemblyIfContext* SolidityParser::AssemblyItemContext::assemblyIf() {
  return getRuleContext<SolidityParser::AssemblyIfContext>(0);
}

tree::TerminalNode* SolidityParser::AssemblyItemContext::BreakKeyword() {
  return getToken(SolidityParser::BreakKeyword, 0);
}

tree::TerminalNode* SolidityParser::AssemblyItemContext::ContinueKeyword() {
  return getToken(SolidityParser::ContinueKeyword, 0);
}

tree::TerminalNode* SolidityParser::AssemblyItemContext::LeaveKeyword() {
  return getToken(SolidityParser::LeaveKeyword, 0);
}

SolidityParser::SubAssemblyContext* SolidityParser::AssemblyItemContext::subAssembly() {
  return getRuleContext<SolidityParser::SubAssemblyContext>(0);
}

SolidityParser::NumberLiteralContext* SolidityParser::AssemblyItemContext::numberLiteral() {
  return getRuleContext<SolidityParser::NumberLiteralContext>(0);
}

SolidityParser::StringLiteralContext* SolidityParser::AssemblyItemContext::stringLiteral() {
  return getRuleContext<SolidityParser::StringLiteralContext>(0);
}

SolidityParser::HexLiteralContext* SolidityParser::AssemblyItemContext::hexLiteral() {
  return getRuleContext<SolidityParser::HexLiteralContext>(0);
}


size_t SolidityParser::AssemblyItemContext::getRuleIndex() const {
  return SolidityParser::RuleAssemblyItem;
}

void SolidityParser::AssemblyItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyItem(this);
}

void SolidityParser::AssemblyItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyItem(this);
}

SolidityParser::AssemblyItemContext* SolidityParser::assemblyItem() {
  AssemblyItemContext *_localctx = _tracker.createInstance<AssemblyItemContext>(_ctx, getState());
  enterRule(_localctx, 130, SolidityParser::RuleAssemblyItem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(911);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(893);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(894);
      assemblyBlock();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(895);
      assemblyExpression();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(896);
      assemblyLocalDefinition();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(897);
      assemblyAssignment();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(898);
      assemblyStackAssignment();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(899);
      labelDefinition();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(900);
      assemblySwitch();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(901);
      assemblyFunctionDefinition();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(902);
      assemblyFor();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(903);
      assemblyIf();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(904);
      match(SolidityParser::BreakKeyword);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(905);
      match(SolidityParser::ContinueKeyword);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(906);
      match(SolidityParser::LeaveKeyword);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(907);
      subAssembly();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(908);
      numberLiteral();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(909);
      stringLiteral();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(910);
      hexLiteral();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyBlockContext ------------------------------------------------------------------

SolidityParser::AssemblyBlockContext::AssemblyBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SolidityParser::AssemblyItemContext *> SolidityParser::AssemblyBlockContext::assemblyItem() {
  return getRuleContexts<SolidityParser::AssemblyItemContext>();
}

SolidityParser::AssemblyItemContext* SolidityParser::AssemblyBlockContext::assemblyItem(size_t i) {
  return getRuleContext<SolidityParser::AssemblyItemContext>(i);
}


size_t SolidityParser::AssemblyBlockContext::getRuleIndex() const {
  return SolidityParser::RuleAssemblyBlock;
}

void SolidityParser::AssemblyBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyBlock(this);
}

void SolidityParser::AssemblyBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyBlock(this);
}

SolidityParser::AssemblyBlockContext* SolidityParser::assemblyBlock() {
  AssemblyBlockContext *_localctx = _tracker.createInstance<AssemblyBlockContext>(_ctx, getState());
  enterRule(_localctx, 132, SolidityParser::RuleAssemblyBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(913);
    match(SolidityParser::T__13);
    setState(917);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 40887539506110464) != 0 || (((_la - 87) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 87)) & 206165030925) != 0) {
      setState(914);
      assemblyItem();
      setState(919);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(920);
    match(SolidityParser::T__15);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyExpressionContext ------------------------------------------------------------------

SolidityParser::AssemblyExpressionContext::AssemblyExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::AssemblyCallContext* SolidityParser::AssemblyExpressionContext::assemblyCall() {
  return getRuleContext<SolidityParser::AssemblyCallContext>(0);
}

SolidityParser::AssemblyLiteralContext* SolidityParser::AssemblyExpressionContext::assemblyLiteral() {
  return getRuleContext<SolidityParser::AssemblyLiteralContext>(0);
}


size_t SolidityParser::AssemblyExpressionContext::getRuleIndex() const {
  return SolidityParser::RuleAssemblyExpression;
}

void SolidityParser::AssemblyExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyExpression(this);
}

void SolidityParser::AssemblyExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyExpression(this);
}

SolidityParser::AssemblyExpressionContext* SolidityParser::assemblyExpression() {
  AssemblyExpressionContext *_localctx = _tracker.createInstance<AssemblyExpressionContext>(_ctx, getState());
  enterRule(_localctx, 134, SolidityParser::RuleAssemblyExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(924);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SolidityParser::T__12:
      case SolidityParser::T__39:
      case SolidityParser::T__47:
      case SolidityParser::T__51:
      case SolidityParser::T__54:
      case SolidityParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(922);
        assemblyCall();
        break;
      }

      case SolidityParser::BooleanLiteral:
      case SolidityParser::DecimalNumber:
      case SolidityParser::HexNumber:
      case SolidityParser::HexLiteralFragment:
      case SolidityParser::StringLiteralFragment: {
        enterOuterAlt(_localctx, 2);
        setState(923);
        assemblyLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyCallContext ------------------------------------------------------------------

SolidityParser::AssemblyCallContext::AssemblyCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IdentifierContext* SolidityParser::AssemblyCallContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}

std::vector<SolidityParser::AssemblyExpressionContext *> SolidityParser::AssemblyCallContext::assemblyExpression() {
  return getRuleContexts<SolidityParser::AssemblyExpressionContext>();
}

SolidityParser::AssemblyExpressionContext* SolidityParser::AssemblyCallContext::assemblyExpression(size_t i) {
  return getRuleContext<SolidityParser::AssemblyExpressionContext>(i);
}


size_t SolidityParser::AssemblyCallContext::getRuleIndex() const {
  return SolidityParser::RuleAssemblyCall;
}

void SolidityParser::AssemblyCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyCall(this);
}

void SolidityParser::AssemblyCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyCall(this);
}

SolidityParser::AssemblyCallContext* SolidityParser::assemblyCall() {
  AssemblyCallContext *_localctx = _tracker.createInstance<AssemblyCallContext>(_ctx, getState());
  enterRule(_localctx, 136, SolidityParser::RuleAssemblyCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(930);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 104, _ctx)) {
    case 1: {
      setState(926);
      match(SolidityParser::T__47);
      break;
    }

    case 2: {
      setState(927);
      match(SolidityParser::T__51);
      break;
    }

    case 3: {
      setState(928);
      match(SolidityParser::T__54);
      break;
    }

    case 4: {
      setState(929);
      identifier();
      break;
    }

    default:
      break;
    }
    setState(944);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SolidityParser::T__21) {
      setState(932);
      match(SolidityParser::T__21);
      setState(934);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 40814971134681088) != 0 || (((_la - 98) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 98)) & 100663319) != 0) {
        setState(933);
        assemblyExpression();
      }
      setState(940);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SolidityParser::T__14) {
        setState(936);
        match(SolidityParser::T__14);
        setState(937);
        assemblyExpression();
        setState(942);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(943);
      match(SolidityParser::T__22);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyLocalDefinitionContext ------------------------------------------------------------------

SolidityParser::AssemblyLocalDefinitionContext::AssemblyLocalDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::AssemblyIdentifierListContext* SolidityParser::AssemblyLocalDefinitionContext::assemblyIdentifierList() {
  return getRuleContext<SolidityParser::AssemblyIdentifierListContext>(0);
}

SolidityParser::AssemblyExpressionContext* SolidityParser::AssemblyLocalDefinitionContext::assemblyExpression() {
  return getRuleContext<SolidityParser::AssemblyExpressionContext>(0);
}


size_t SolidityParser::AssemblyLocalDefinitionContext::getRuleIndex() const {
  return SolidityParser::RuleAssemblyLocalDefinition;
}

void SolidityParser::AssemblyLocalDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyLocalDefinition(this);
}

void SolidityParser::AssemblyLocalDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyLocalDefinition(this);
}

SolidityParser::AssemblyLocalDefinitionContext* SolidityParser::assemblyLocalDefinition() {
  AssemblyLocalDefinitionContext *_localctx = _tracker.createInstance<AssemblyLocalDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 138, SolidityParser::RuleAssemblyLocalDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(946);
    match(SolidityParser::T__86);
    setState(947);
    assemblyIdentifierList();
    setState(950);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SolidityParser::T__87) {
      setState(948);
      match(SolidityParser::T__87);
      setState(949);
      assemblyExpression();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyAssignmentContext ------------------------------------------------------------------

SolidityParser::AssemblyAssignmentContext::AssemblyAssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::AssemblyIdentifierListContext* SolidityParser::AssemblyAssignmentContext::assemblyIdentifierList() {
  return getRuleContext<SolidityParser::AssemblyIdentifierListContext>(0);
}

SolidityParser::AssemblyExpressionContext* SolidityParser::AssemblyAssignmentContext::assemblyExpression() {
  return getRuleContext<SolidityParser::AssemblyExpressionContext>(0);
}


size_t SolidityParser::AssemblyAssignmentContext::getRuleIndex() const {
  return SolidityParser::RuleAssemblyAssignment;
}

void SolidityParser::AssemblyAssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyAssignment(this);
}

void SolidityParser::AssemblyAssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyAssignment(this);
}

SolidityParser::AssemblyAssignmentContext* SolidityParser::assemblyAssignment() {
  AssemblyAssignmentContext *_localctx = _tracker.createInstance<AssemblyAssignmentContext>(_ctx, getState());
  enterRule(_localctx, 140, SolidityParser::RuleAssemblyAssignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(952);
    assemblyIdentifierList();
    setState(953);
    match(SolidityParser::T__87);
    setState(954);
    assemblyExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyIdentifierListContext ------------------------------------------------------------------

SolidityParser::AssemblyIdentifierListContext::AssemblyIdentifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SolidityParser::IdentifierContext *> SolidityParser::AssemblyIdentifierListContext::identifier() {
  return getRuleContexts<SolidityParser::IdentifierContext>();
}

SolidityParser::IdentifierContext* SolidityParser::AssemblyIdentifierListContext::identifier(size_t i) {
  return getRuleContext<SolidityParser::IdentifierContext>(i);
}


size_t SolidityParser::AssemblyIdentifierListContext::getRuleIndex() const {
  return SolidityParser::RuleAssemblyIdentifierList;
}

void SolidityParser::AssemblyIdentifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyIdentifierList(this);
}

void SolidityParser::AssemblyIdentifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyIdentifierList(this);
}

SolidityParser::AssemblyIdentifierListContext* SolidityParser::assemblyIdentifierList() {
  AssemblyIdentifierListContext *_localctx = _tracker.createInstance<AssemblyIdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 142, SolidityParser::RuleAssemblyIdentifierList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(956);
    identifier();
    setState(961);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SolidityParser::T__14) {
      setState(957);
      match(SolidityParser::T__14);
      setState(958);
      identifier();
      setState(963);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyStackAssignmentContext ------------------------------------------------------------------

SolidityParser::AssemblyStackAssignmentContext::AssemblyStackAssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IdentifierContext* SolidityParser::AssemblyStackAssignmentContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}


size_t SolidityParser::AssemblyStackAssignmentContext::getRuleIndex() const {
  return SolidityParser::RuleAssemblyStackAssignment;
}

void SolidityParser::AssemblyStackAssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyStackAssignment(this);
}

void SolidityParser::AssemblyStackAssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyStackAssignment(this);
}

SolidityParser::AssemblyStackAssignmentContext* SolidityParser::assemblyStackAssignment() {
  AssemblyStackAssignmentContext *_localctx = _tracker.createInstance<AssemblyStackAssignmentContext>(_ctx, getState());
  enterRule(_localctx, 144, SolidityParser::RuleAssemblyStackAssignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(964);
    match(SolidityParser::T__88);
    setState(965);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelDefinitionContext ------------------------------------------------------------------

SolidityParser::LabelDefinitionContext::LabelDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IdentifierContext* SolidityParser::LabelDefinitionContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}


size_t SolidityParser::LabelDefinitionContext::getRuleIndex() const {
  return SolidityParser::RuleLabelDefinition;
}

void SolidityParser::LabelDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabelDefinition(this);
}

void SolidityParser::LabelDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabelDefinition(this);
}

SolidityParser::LabelDefinitionContext* SolidityParser::labelDefinition() {
  LabelDefinitionContext *_localctx = _tracker.createInstance<LabelDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 146, SolidityParser::RuleLabelDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(967);
    identifier();
    setState(968);
    match(SolidityParser::T__58);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblySwitchContext ------------------------------------------------------------------

SolidityParser::AssemblySwitchContext::AssemblySwitchContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::AssemblyExpressionContext* SolidityParser::AssemblySwitchContext::assemblyExpression() {
  return getRuleContext<SolidityParser::AssemblyExpressionContext>(0);
}

std::vector<SolidityParser::AssemblyCaseContext *> SolidityParser::AssemblySwitchContext::assemblyCase() {
  return getRuleContexts<SolidityParser::AssemblyCaseContext>();
}

SolidityParser::AssemblyCaseContext* SolidityParser::AssemblySwitchContext::assemblyCase(size_t i) {
  return getRuleContext<SolidityParser::AssemblyCaseContext>(i);
}


size_t SolidityParser::AssemblySwitchContext::getRuleIndex() const {
  return SolidityParser::RuleAssemblySwitch;
}

void SolidityParser::AssemblySwitchContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblySwitch(this);
}

void SolidityParser::AssemblySwitchContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblySwitch(this);
}

SolidityParser::AssemblySwitchContext* SolidityParser::assemblySwitch() {
  AssemblySwitchContext *_localctx = _tracker.createInstance<AssemblySwitchContext>(_ctx, getState());
  enterRule(_localctx, 148, SolidityParser::RuleAssemblySwitch);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(970);
    match(SolidityParser::T__89);
    setState(971);
    assemblyExpression();
    setState(975);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SolidityParser::T__90

    || _la == SolidityParser::T__91) {
      setState(972);
      assemblyCase();
      setState(977);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyCaseContext ------------------------------------------------------------------

SolidityParser::AssemblyCaseContext::AssemblyCaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::AssemblyLiteralContext* SolidityParser::AssemblyCaseContext::assemblyLiteral() {
  return getRuleContext<SolidityParser::AssemblyLiteralContext>(0);
}

SolidityParser::AssemblyBlockContext* SolidityParser::AssemblyCaseContext::assemblyBlock() {
  return getRuleContext<SolidityParser::AssemblyBlockContext>(0);
}

SolidityParser::AssemblyTypeContext* SolidityParser::AssemblyCaseContext::assemblyType() {
  return getRuleContext<SolidityParser::AssemblyTypeContext>(0);
}


size_t SolidityParser::AssemblyCaseContext::getRuleIndex() const {
  return SolidityParser::RuleAssemblyCase;
}

void SolidityParser::AssemblyCaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyCase(this);
}

void SolidityParser::AssemblyCaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyCase(this);
}

SolidityParser::AssemblyCaseContext* SolidityParser::assemblyCase() {
  AssemblyCaseContext *_localctx = _tracker.createInstance<AssemblyCaseContext>(_ctx, getState());
  enterRule(_localctx, 150, SolidityParser::RuleAssemblyCase);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(987);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SolidityParser::T__90: {
        enterOuterAlt(_localctx, 1);
        setState(978);
        match(SolidityParser::T__90);
        setState(979);
        assemblyLiteral();
        setState(981);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SolidityParser::T__58) {
          setState(980);
          assemblyType();
        }
        setState(983);
        assemblyBlock();
        break;
      }

      case SolidityParser::T__91: {
        enterOuterAlt(_localctx, 2);
        setState(985);
        match(SolidityParser::T__91);
        setState(986);
        assemblyBlock();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyFunctionDefinitionContext ------------------------------------------------------------------

SolidityParser::AssemblyFunctionDefinitionContext::AssemblyFunctionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IdentifierContext* SolidityParser::AssemblyFunctionDefinitionContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}

SolidityParser::AssemblyBlockContext* SolidityParser::AssemblyFunctionDefinitionContext::assemblyBlock() {
  return getRuleContext<SolidityParser::AssemblyBlockContext>(0);
}

SolidityParser::AssemblyTypedVariableListContext* SolidityParser::AssemblyFunctionDefinitionContext::assemblyTypedVariableList() {
  return getRuleContext<SolidityParser::AssemblyTypedVariableListContext>(0);
}

SolidityParser::AssemblyFunctionReturnsContext* SolidityParser::AssemblyFunctionDefinitionContext::assemblyFunctionReturns() {
  return getRuleContext<SolidityParser::AssemblyFunctionReturnsContext>(0);
}


size_t SolidityParser::AssemblyFunctionDefinitionContext::getRuleIndex() const {
  return SolidityParser::RuleAssemblyFunctionDefinition;
}

void SolidityParser::AssemblyFunctionDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyFunctionDefinition(this);
}

void SolidityParser::AssemblyFunctionDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyFunctionDefinition(this);
}

SolidityParser::AssemblyFunctionDefinitionContext* SolidityParser::assemblyFunctionDefinition() {
  AssemblyFunctionDefinitionContext *_localctx = _tracker.createInstance<AssemblyFunctionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 152, SolidityParser::RuleAssemblyFunctionDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(989);
    match(SolidityParser::T__28);
    setState(990);
    identifier();
    setState(991);
    match(SolidityParser::T__21);
    setState(993);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4504699139006464) != 0 || _la == SolidityParser::Identifier) {
      setState(992);
      assemblyTypedVariableList();
    }
    setState(995);
    match(SolidityParser::T__22);
    setState(997);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SolidityParser::T__60) {
      setState(996);
      assemblyFunctionReturns();
    }
    setState(999);
    assemblyBlock();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyFunctionReturnsContext ------------------------------------------------------------------

SolidityParser::AssemblyFunctionReturnsContext::AssemblyFunctionReturnsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::AssemblyTypedVariableListContext* SolidityParser::AssemblyFunctionReturnsContext::assemblyTypedVariableList() {
  return getRuleContext<SolidityParser::AssemblyTypedVariableListContext>(0);
}


size_t SolidityParser::AssemblyFunctionReturnsContext::getRuleIndex() const {
  return SolidityParser::RuleAssemblyFunctionReturns;
}

void SolidityParser::AssemblyFunctionReturnsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyFunctionReturns(this);
}

void SolidityParser::AssemblyFunctionReturnsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyFunctionReturns(this);
}

SolidityParser::AssemblyFunctionReturnsContext* SolidityParser::assemblyFunctionReturns() {
  AssemblyFunctionReturnsContext *_localctx = _tracker.createInstance<AssemblyFunctionReturnsContext>(_ctx, getState());
  enterRule(_localctx, 154, SolidityParser::RuleAssemblyFunctionReturns);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1001);
    match(SolidityParser::T__60);
    setState(1002);
    match(SolidityParser::T__5);
    setState(1003);
    assemblyTypedVariableList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyForContext ------------------------------------------------------------------

SolidityParser::AssemblyForContext::AssemblyForContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SolidityParser::AssemblyBlockContext *> SolidityParser::AssemblyForContext::assemblyBlock() {
  return getRuleContexts<SolidityParser::AssemblyBlockContext>();
}

SolidityParser::AssemblyBlockContext* SolidityParser::AssemblyForContext::assemblyBlock(size_t i) {
  return getRuleContext<SolidityParser::AssemblyBlockContext>(i);
}

SolidityParser::AssemblyExpressionContext* SolidityParser::AssemblyForContext::assemblyExpression() {
  return getRuleContext<SolidityParser::AssemblyExpressionContext>(0);
}


size_t SolidityParser::AssemblyForContext::getRuleIndex() const {
  return SolidityParser::RuleAssemblyFor;
}

void SolidityParser::AssemblyForContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyFor(this);
}

void SolidityParser::AssemblyForContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyFor(this);
}

SolidityParser::AssemblyForContext* SolidityParser::assemblyFor() {
  AssemblyForContext *_localctx = _tracker.createInstance<AssemblyForContext>(_ctx, getState());
  enterRule(_localctx, 156, SolidityParser::RuleAssemblyFor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1005);
    match(SolidityParser::T__25);
    setState(1006);
    assemblyBlock();
    setState(1007);
    assemblyExpression();
    setState(1008);
    assemblyBlock();
    setState(1009);
    assemblyBlock();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyIfContext ------------------------------------------------------------------

SolidityParser::AssemblyIfContext::AssemblyIfContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::AssemblyExpressionContext* SolidityParser::AssemblyIfContext::assemblyExpression() {
  return getRuleContext<SolidityParser::AssemblyExpressionContext>(0);
}

SolidityParser::AssemblyBlockContext* SolidityParser::AssemblyIfContext::assemblyBlock() {
  return getRuleContext<SolidityParser::AssemblyBlockContext>(0);
}


size_t SolidityParser::AssemblyIfContext::getRuleIndex() const {
  return SolidityParser::RuleAssemblyIf;
}

void SolidityParser::AssemblyIfContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyIf(this);
}

void SolidityParser::AssemblyIfContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyIf(this);
}

SolidityParser::AssemblyIfContext* SolidityParser::assemblyIf() {
  AssemblyIfContext *_localctx = _tracker.createInstance<AssemblyIfContext>(_ctx, getState());
  enterRule(_localctx, 158, SolidityParser::RuleAssemblyIf);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1011);
    match(SolidityParser::T__40);
    setState(1012);
    assemblyExpression();
    setState(1013);
    assemblyBlock();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyLiteralContext ------------------------------------------------------------------

SolidityParser::AssemblyLiteralContext::AssemblyLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::StringLiteralContext* SolidityParser::AssemblyLiteralContext::stringLiteral() {
  return getRuleContext<SolidityParser::StringLiteralContext>(0);
}

tree::TerminalNode* SolidityParser::AssemblyLiteralContext::DecimalNumber() {
  return getToken(SolidityParser::DecimalNumber, 0);
}

tree::TerminalNode* SolidityParser::AssemblyLiteralContext::HexNumber() {
  return getToken(SolidityParser::HexNumber, 0);
}

SolidityParser::HexLiteralContext* SolidityParser::AssemblyLiteralContext::hexLiteral() {
  return getRuleContext<SolidityParser::HexLiteralContext>(0);
}

tree::TerminalNode* SolidityParser::AssemblyLiteralContext::BooleanLiteral() {
  return getToken(SolidityParser::BooleanLiteral, 0);
}

SolidityParser::AssemblyTypeContext* SolidityParser::AssemblyLiteralContext::assemblyType() {
  return getRuleContext<SolidityParser::AssemblyTypeContext>(0);
}


size_t SolidityParser::AssemblyLiteralContext::getRuleIndex() const {
  return SolidityParser::RuleAssemblyLiteral;
}

void SolidityParser::AssemblyLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyLiteral(this);
}

void SolidityParser::AssemblyLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyLiteral(this);
}

SolidityParser::AssemblyLiteralContext* SolidityParser::assemblyLiteral() {
  AssemblyLiteralContext *_localctx = _tracker.createInstance<AssemblyLiteralContext>(_ctx, getState());
  enterRule(_localctx, 160, SolidityParser::RuleAssemblyLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1020);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SolidityParser::StringLiteralFragment: {
        setState(1015);
        stringLiteral();
        break;
      }

      case SolidityParser::DecimalNumber: {
        setState(1016);
        match(SolidityParser::DecimalNumber);
        break;
      }

      case SolidityParser::HexNumber: {
        setState(1017);
        match(SolidityParser::HexNumber);
        break;
      }

      case SolidityParser::HexLiteralFragment: {
        setState(1018);
        hexLiteral();
        break;
      }

      case SolidityParser::BooleanLiteral: {
        setState(1019);
        match(SolidityParser::BooleanLiteral);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1023);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx)) {
    case 1: {
      setState(1022);
      assemblyType();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyTypedVariableListContext ------------------------------------------------------------------

SolidityParser::AssemblyTypedVariableListContext::AssemblyTypedVariableListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IdentifierContext* SolidityParser::AssemblyTypedVariableListContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}

SolidityParser::AssemblyTypeContext* SolidityParser::AssemblyTypedVariableListContext::assemblyType() {
  return getRuleContext<SolidityParser::AssemblyTypeContext>(0);
}

SolidityParser::AssemblyTypedVariableListContext* SolidityParser::AssemblyTypedVariableListContext::assemblyTypedVariableList() {
  return getRuleContext<SolidityParser::AssemblyTypedVariableListContext>(0);
}


size_t SolidityParser::AssemblyTypedVariableListContext::getRuleIndex() const {
  return SolidityParser::RuleAssemblyTypedVariableList;
}

void SolidityParser::AssemblyTypedVariableListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyTypedVariableList(this);
}

void SolidityParser::AssemblyTypedVariableListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyTypedVariableList(this);
}

SolidityParser::AssemblyTypedVariableListContext* SolidityParser::assemblyTypedVariableList() {
  AssemblyTypedVariableListContext *_localctx = _tracker.createInstance<AssemblyTypedVariableListContext>(_ctx, getState());
  enterRule(_localctx, 162, SolidityParser::RuleAssemblyTypedVariableList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1025);
    identifier();
    setState(1027);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SolidityParser::T__58) {
      setState(1026);
      assemblyType();
    }
    setState(1031);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SolidityParser::T__14) {
      setState(1029);
      match(SolidityParser::T__14);
      setState(1030);
      assemblyTypedVariableList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyTypeContext ------------------------------------------------------------------

SolidityParser::AssemblyTypeContext::AssemblyTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IdentifierContext* SolidityParser::AssemblyTypeContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}


size_t SolidityParser::AssemblyTypeContext::getRuleIndex() const {
  return SolidityParser::RuleAssemblyType;
}

void SolidityParser::AssemblyTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyType(this);
}

void SolidityParser::AssemblyTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyType(this);
}

SolidityParser::AssemblyTypeContext* SolidityParser::assemblyType() {
  AssemblyTypeContext *_localctx = _tracker.createInstance<AssemblyTypeContext>(_ctx, getState());
  enterRule(_localctx, 164, SolidityParser::RuleAssemblyType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1033);
    match(SolidityParser::T__58);
    setState(1034);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubAssemblyContext ------------------------------------------------------------------

SolidityParser::SubAssemblyContext::SubAssemblyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SolidityParser::IdentifierContext* SolidityParser::SubAssemblyContext::identifier() {
  return getRuleContext<SolidityParser::IdentifierContext>(0);
}

SolidityParser::AssemblyBlockContext* SolidityParser::SubAssemblyContext::assemblyBlock() {
  return getRuleContext<SolidityParser::AssemblyBlockContext>(0);
}


size_t SolidityParser::SubAssemblyContext::getRuleIndex() const {
  return SolidityParser::RuleSubAssembly;
}

void SolidityParser::SubAssemblyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubAssembly(this);
}

void SolidityParser::SubAssemblyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubAssembly(this);
}

SolidityParser::SubAssemblyContext* SolidityParser::subAssembly() {
  SubAssemblyContext *_localctx = _tracker.createInstance<SubAssemblyContext>(_ctx, getState());
  enterRule(_localctx, 166, SolidityParser::RuleSubAssembly);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1036);
    match(SolidityParser::T__45);
    setState(1037);
    identifier();
    setState(1038);
    assemblyBlock();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumberLiteralContext ------------------------------------------------------------------

SolidityParser::NumberLiteralContext::NumberLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SolidityParser::NumberLiteralContext::DecimalNumber() {
  return getToken(SolidityParser::DecimalNumber, 0);
}

tree::TerminalNode* SolidityParser::NumberLiteralContext::HexNumber() {
  return getToken(SolidityParser::HexNumber, 0);
}

tree::TerminalNode* SolidityParser::NumberLiteralContext::NumberUnit() {
  return getToken(SolidityParser::NumberUnit, 0);
}


size_t SolidityParser::NumberLiteralContext::getRuleIndex() const {
  return SolidityParser::RuleNumberLiteral;
}

void SolidityParser::NumberLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumberLiteral(this);
}

void SolidityParser::NumberLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumberLiteral(this);
}

SolidityParser::NumberLiteralContext* SolidityParser::numberLiteral() {
  NumberLiteralContext *_localctx = _tracker.createInstance<NumberLiteralContext>(_ctx, getState());
  enterRule(_localctx, 168, SolidityParser::RuleNumberLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1040);
    _la = _input->LA(1);
    if (!(_la == SolidityParser::DecimalNumber

    || _la == SolidityParser::HexNumber)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1042);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 119, _ctx)) {
    case 1: {
      setState(1041);
      match(SolidityParser::NumberUnit);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

SolidityParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SolidityParser::IdentifierContext::Identifier() {
  return getToken(SolidityParser::Identifier, 0);
}


size_t SolidityParser::IdentifierContext::getRuleIndex() const {
  return SolidityParser::RuleIdentifier;
}

void SolidityParser::IdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier(this);
}

void SolidityParser::IdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier(this);
}

SolidityParser::IdentifierContext* SolidityParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 170, SolidityParser::RuleIdentifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1044);
    _la = _input->LA(1);
    if (!(((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4504699139006464) != 0 || _la == SolidityParser::Identifier)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HexLiteralContext ------------------------------------------------------------------

SolidityParser::HexLiteralContext::HexLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> SolidityParser::HexLiteralContext::HexLiteralFragment() {
  return getTokens(SolidityParser::HexLiteralFragment);
}

tree::TerminalNode* SolidityParser::HexLiteralContext::HexLiteralFragment(size_t i) {
  return getToken(SolidityParser::HexLiteralFragment, i);
}


size_t SolidityParser::HexLiteralContext::getRuleIndex() const {
  return SolidityParser::RuleHexLiteral;
}

void SolidityParser::HexLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHexLiteral(this);
}

void SolidityParser::HexLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHexLiteral(this);
}

SolidityParser::HexLiteralContext* SolidityParser::hexLiteral() {
  HexLiteralContext *_localctx = _tracker.createInstance<HexLiteralContext>(_ctx, getState());
  enterRule(_localctx, 172, SolidityParser::RuleHexLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1047); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1046);
              match(SolidityParser::HexLiteralFragment);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1049); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringLiteralContext ------------------------------------------------------------------

SolidityParser::StringLiteralContext::StringLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> SolidityParser::StringLiteralContext::StringLiteralFragment() {
  return getTokens(SolidityParser::StringLiteralFragment);
}

tree::TerminalNode* SolidityParser::StringLiteralContext::StringLiteralFragment(size_t i) {
  return getToken(SolidityParser::StringLiteralFragment, i);
}


size_t SolidityParser::StringLiteralContext::getRuleIndex() const {
  return SolidityParser::RuleStringLiteral;
}

void SolidityParser::StringLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringLiteral(this);
}

void SolidityParser::StringLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringLiteral(this);
}

SolidityParser::StringLiteralContext* SolidityParser::stringLiteral() {
  StringLiteralContext *_localctx = _tracker.createInstance<StringLiteralContext>(_ctx, getState());
  enterRule(_localctx, 174, SolidityParser::RuleStringLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1052); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1051);
              match(SolidityParser::StringLiteralFragment);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1054); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool SolidityParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 30: return typeNameSempred(antlrcpp::downCast<TypeNameContext *>(context), predicateIndex);
    case 56: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool SolidityParser::typeNameSempred(TypeNameContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool SolidityParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return precpred(_ctx, 14);
    case 2: return precpred(_ctx, 13);
    case 3: return precpred(_ctx, 12);
    case 4: return precpred(_ctx, 11);
    case 5: return precpred(_ctx, 10);
    case 6: return precpred(_ctx, 9);
    case 7: return precpred(_ctx, 8);
    case 8: return precpred(_ctx, 7);
    case 9: return precpred(_ctx, 6);
    case 10: return precpred(_ctx, 5);
    case 11: return precpred(_ctx, 4);
    case 12: return precpred(_ctx, 3);
    case 13: return precpred(_ctx, 2);
    case 14: return precpred(_ctx, 28);
    case 15: return precpred(_ctx, 26);
    case 16: return precpred(_ctx, 25);
    case 17: return precpred(_ctx, 24);
    case 18: return precpred(_ctx, 23);
    case 19: return precpred(_ctx, 22);

  default:
    break;
  }
  return true;
}

void SolidityParser::initialize() {
  ::antlr4::internal::call_once(solidityParserOnceFlag, solidityParserInitialize);
}
